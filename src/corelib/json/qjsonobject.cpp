begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qjsonobject.h>
end_include
begin_include
include|#
directive|include
file|<qjsonvalue.h>
end_include
begin_include
include|#
directive|include
file|<qjsonarray.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qvariant.h>
end_include
begin_include
include|#
directive|include
file|"qjson_p.h"
end_include
begin_include
include|#
directive|include
file|"qjsonwriter_p.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QJsonObject     \inmodule QtCore     \ingroup json     \reentrant     \since 5.0      \brief The QJsonObject class encapsulates a JSON object.      A JSON object is a list of key value pairs, where the keys are unique strings     and the values are represented by a QJsonValue.      A QJsonObject can be converted to and from a QVariantMap. You can query the     number of (key, value) pairs with size(), insert(), and remove() entries from it     and iterate over its content using the standard C++ iterator pattern.      QJsonObject is an implicitly shared class, and shares the data with the document     it has been created from as long as it is not being modified.      You can convert the array to and from text based JSON through QJsonDocument. */
end_comment
begin_comment
comment|/*!     \typedef QJsonObject::Iterator      Qt-style synonym for QJsonObject::iterator. */
end_comment
begin_comment
comment|/*!     \typedef QJsonObject::ConstIterator      Qt-style synonym for QJsonObject::const_iterator. */
end_comment
begin_comment
comment|/*!     \typedef QJsonObject::key_type      Typedef for QString. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*!     \typedef QJsonObject::mapped_type      Typedef for QJsonValue. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*!     \typedef QJsonObject::size_type      Typedef for int. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*!     Constructs an empty JSON object      \sa isEmpty()  */
end_comment
begin_constructor
DECL|function|QJsonObject
name|QJsonObject
operator|::
name|QJsonObject
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|o
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal  */
end_comment
begin_constructor
DECL|function|QJsonObject
name|QJsonObject
operator|::
name|QJsonObject
parameter_list|(
name|QJsonPrivate
operator|::
name|Data
modifier|*
name|data
parameter_list|,
name|QJsonPrivate
operator|::
name|Object
modifier|*
name|object
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|data
argument_list|)
member_init_list|,
name|o
argument_list|(
name|object
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the object.  */
end_comment
begin_destructor
DECL|function|~QJsonObject
name|QJsonObject
operator|::
name|~
name|QJsonObject
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Creates a copy of \a other.      Since QJsonObject is implicitly shared, the copy is shallow     as long as the object does not get modified.  */
end_comment
begin_constructor
DECL|function|QJsonObject
name|QJsonObject
operator|::
name|QJsonObject
parameter_list|(
specifier|const
name|QJsonObject
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
name|o
operator|=
name|other
operator|.
name|o
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns \a other to this object.  */
end_comment
begin_function
DECL|function|operator =
name|QJsonObject
modifier|&
name|QJsonObject
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QJsonObject
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|d
operator|!=
name|other
operator|.
name|d
condition|)
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
name|o
operator|=
name|other
operator|.
name|o
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the variant map \a map to a QJsonObject.      The keys in \a map will be used as the keys in the JSON object,     and the QVariant values will be converted to JSON values.      \sa toVariantMap(), QJsonValue::fromVariant()  */
end_comment
begin_function
DECL|function|fromVariantMap
name|QJsonObject
name|QJsonObject
operator|::
name|fromVariantMap
parameter_list|(
specifier|const
name|QVariantMap
modifier|&
name|map
parameter_list|)
block|{
comment|// ### this is implemented the trivial way, not the most efficient way
name|QJsonObject
name|object
decl_stmt|;
for|for
control|(
name|QVariantMap
operator|::
name|const_iterator
name|it
init|=
name|map
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|map
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|object
operator|.
name|insert
argument_list|(
name|it
operator|.
name|key
argument_list|()
argument_list|,
name|QJsonValue
operator|::
name|fromVariant
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|object
return|;
block|}
end_function
begin_comment
comment|/*!     Converts this object to a QVariantMap.      Returns the created map.  */
end_comment
begin_function
DECL|function|toVariantMap
name|QVariantMap
name|QJsonObject
operator|::
name|toVariantMap
parameter_list|()
specifier|const
block|{
name|QVariantMap
name|map
decl_stmt|;
if|if
condition|(
name|o
condition|)
block|{
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|o
operator|->
name|length
condition|;
operator|++
name|i
control|)
block|{
name|QJsonPrivate
operator|::
name|Entry
modifier|*
name|e
init|=
name|o
operator|->
name|entryAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|map
operator|.
name|insert
argument_list|(
name|e
operator|->
name|key
argument_list|()
argument_list|,
name|QJsonValue
argument_list|(
name|d
argument_list|,
name|o
argument_list|,
name|e
operator|->
name|value
argument_list|)
operator|.
name|toVariant
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all keys in this object.  */
end_comment
begin_function
DECL|function|keys
name|QStringList
name|QJsonObject
operator|::
name|keys
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QStringList
argument_list|()
return|;
name|QStringList
name|keys
decl_stmt|;
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|o
operator|->
name|length
condition|;
operator|++
name|i
control|)
block|{
name|QJsonPrivate
operator|::
name|Entry
modifier|*
name|e
init|=
name|o
operator|->
name|entryAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|keys
operator|.
name|append
argument_list|(
name|e
operator|->
name|key
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|keys
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the the number of (key, value) pairs stored in the object.  */
end_comment
begin_function
DECL|function|size
name|int
name|QJsonObject
operator|::
name|size
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
return|return
name|o
operator|->
name|length
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the object is empty. This is the same as size() == 0.      \sa size()  */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QJsonObject
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|true
return|;
return|return
operator|!
name|o
operator|->
name|length
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QJsonValue representing the value for the key \a key.      The returned QJsonValue is \c Undefined, if the key does not exist.      \sa QJsonValue, QJsonValue::isUndefined()  */
end_comment
begin_function
DECL|function|value
name|QJsonValue
name|QJsonObject
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|QJsonValue
argument_list|()
return|;
name|bool
name|keyExists
decl_stmt|;
name|int
name|i
init|=
name|o
operator|->
name|indexOf
argument_list|(
name|key
argument_list|,
operator|&
name|keyExists
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|keyExists
condition|)
return|return
name|QJsonValue
argument_list|(
name|QJsonValue
operator|::
name|Undefined
argument_list|)
return|;
return|return
name|QJsonValue
argument_list|(
name|d
argument_list|,
name|o
argument_list|,
name|o
operator|->
name|entryAt
argument_list|(
name|i
argument_list|)
operator|->
name|value
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QJsonValue representing the value for the key \a key.      This does the same as value().      The returned QJsonValue is \c Undefined, if the key does not exist.      \sa value(), QJsonValue, QJsonValue::isUndefined()  */
end_comment
begin_function
DECL|function|operator []
name|QJsonValue
name|QJsonObject
operator|::
name|operator
name|[]
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
return|return
name|value
argument_list|(
name|key
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a reference to the value for \a key.      The return value is of type QJsonValueRef, a helper class for QJsonArray     and QJsonObject. When you get an object of type QJsonValueRef, you can     use it as if it were a reference to a QJsonValue. If you assign to it,     the assignment will apply to the character in the QJsonArray of QJsonObject     from which you got the reference.      \sa value()  */
end_comment
begin_function
DECL|function|operator []
name|QJsonValueRef
name|QJsonObject
operator|::
name|operator
name|[]
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
comment|// ### somewhat inefficient, as we lookup the key twice if it doesn't yet exist
name|bool
name|keyExists
init|=
literal|false
decl_stmt|;
name|int
name|index
init|=
name|o
condition|?
name|o
operator|->
name|indexOf
argument_list|(
name|key
argument_list|,
operator|&
name|keyExists
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|keyExists
condition|)
block|{
name|iterator
name|i
init|=
name|insert
argument_list|(
name|key
argument_list|,
name|QJsonValue
argument_list|()
argument_list|)
decl_stmt|;
name|index
operator|=
name|i
operator|.
name|i
expr_stmt|;
block|}
return|return
name|QJsonValueRef
argument_list|(
name|this
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts a new item with the key \a key and a value of \a value.      If there is already an item with the key \a key then that item's value     is replaced with \a value.      Returns an iterator pointing to the inserted item.      If the value is QJsonValue::Undefined, it will cause the key to get removed     from the object. The returned iterator will then point to end()      \sa remove(), take(), QJsonObject::iterator, end()  */
end_comment
begin_function
DECL|function|insert
name|QJsonObject
operator|::
name|iterator
name|QJsonObject
operator|::
name|insert
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QJsonValue
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|.
name|t
operator|==
name|QJsonValue
operator|::
name|Undefined
condition|)
block|{
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|end
argument_list|()
return|;
block|}
name|bool
name|latinOrIntValue
decl_stmt|;
name|int
name|valueSize
init|=
name|QJsonPrivate
operator|::
name|Value
operator|::
name|requiredStorage
argument_list|(
name|value
argument_list|,
operator|&
name|latinOrIntValue
argument_list|)
decl_stmt|;
name|bool
name|latinKey
init|=
name|QJsonPrivate
operator|::
name|useCompressed
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|int
name|valueOffset
init|=
sizeof|sizeof
argument_list|(
name|QJsonPrivate
operator|::
name|Entry
argument_list|)
operator|+
name|QJsonPrivate
operator|::
name|qStringSize
argument_list|(
name|key
argument_list|,
name|latinKey
argument_list|)
decl_stmt|;
name|int
name|requiredSize
init|=
name|valueOffset
operator|+
name|valueSize
decl_stmt|;
name|detach
argument_list|(
name|requiredSize
operator|+
sizeof|sizeof
argument_list|(
name|QJsonPrivate
operator|::
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|// offset for the new index entry
if|if
condition|(
operator|!
name|o
operator|->
name|length
condition|)
name|o
operator|->
name|tableOffset
operator|=
sizeof|sizeof
argument_list|(
name|QJsonPrivate
operator|::
name|Object
argument_list|)
expr_stmt|;
name|bool
name|keyExists
init|=
literal|false
decl_stmt|;
name|int
name|pos
init|=
name|o
operator|->
name|indexOf
argument_list|(
name|key
argument_list|,
operator|&
name|keyExists
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyExists
condition|)
operator|++
name|d
operator|->
name|compactionCounter
expr_stmt|;
name|o
operator|->
name|reserveSpace
argument_list|(
name|requiredSize
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|,
name|keyExists
argument_list|)
expr_stmt|;
name|QJsonPrivate
operator|::
name|Entry
modifier|*
name|e
init|=
name|o
operator|->
name|entryAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|e
operator|->
name|value
operator|.
name|type
operator|=
name|value
operator|.
name|t
expr_stmt|;
name|e
operator|->
name|value
operator|.
name|latinKey
operator|=
name|latinKey
expr_stmt|;
name|e
operator|->
name|value
operator|.
name|latinOrIntValue
operator|=
name|latinOrIntValue
expr_stmt|;
name|e
operator|->
name|value
operator|.
name|value
operator|=
name|QJsonPrivate
operator|::
name|Value
operator|::
name|valueToStore
argument_list|(
name|value
argument_list|,
operator|(
name|char
operator|*
operator|)
name|e
operator|-
operator|(
name|char
operator|*
operator|)
name|o
operator|+
name|valueOffset
argument_list|)
expr_stmt|;
name|QJsonPrivate
operator|::
name|copyString
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|e
operator|+
literal|1
operator|)
argument_list|,
name|key
argument_list|,
name|latinKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|valueSize
condition|)
name|QJsonPrivate
operator|::
name|Value
operator|::
name|copyData
argument_list|(
name|value
argument_list|,
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|valueOffset
argument_list|,
name|latinOrIntValue
argument_list|)
expr_stmt|;
return|return
name|iterator
argument_list|(
name|this
argument_list|,
name|pos
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Removes \a key from the object.      \sa insert(), take()  */
end_comment
begin_function
DECL|function|remove
name|void
name|QJsonObject
operator|::
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return;
name|bool
name|keyExists
decl_stmt|;
name|int
name|index
init|=
name|o
operator|->
name|indexOf
argument_list|(
name|key
argument_list|,
operator|&
name|keyExists
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|keyExists
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|o
operator|->
name|removeItems
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|++
name|d
operator|->
name|compactionCounter
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|compactionCounter
operator|>
literal|32u
operator|&&
name|d
operator|->
name|compactionCounter
operator|>=
name|unsigned
argument_list|(
name|o
operator|->
name|length
argument_list|)
operator|/
literal|2u
condition|)
name|compact
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes \a key from the object.      Returns a QJsonValue containing the value referenced by \a key.     If \a key was not contained in the object, the returned QJsonValue     is Undefined.      \sa insert(), remove(), QJsonValue  */
end_comment
begin_function
DECL|function|take
name|QJsonValue
name|QJsonObject
operator|::
name|take
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
condition|)
return|return
name|QJsonValue
argument_list|(
name|QJsonValue
operator|::
name|Undefined
argument_list|)
return|;
name|bool
name|keyExists
decl_stmt|;
name|int
name|index
init|=
name|o
operator|->
name|indexOf
argument_list|(
name|key
argument_list|,
operator|&
name|keyExists
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|keyExists
condition|)
return|return
name|QJsonValue
argument_list|(
name|QJsonValue
operator|::
name|Undefined
argument_list|)
return|;
name|QJsonPrivate
operator|::
name|Entry
modifier|*
name|e
init|=
name|o
operator|->
name|entryAt
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|o
operator|->
name|removeItems
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|++
name|d
operator|->
name|compactionCounter
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|compactionCounter
operator|>
literal|32u
operator|&&
name|d
operator|->
name|compactionCounter
operator|>=
name|unsigned
argument_list|(
name|o
operator|->
name|length
argument_list|)
operator|/
literal|2u
condition|)
name|compact
argument_list|()
expr_stmt|;
return|return
name|QJsonValue
argument_list|(
name|d
argument_list|,
name|o
argument_list|,
name|e
operator|->
name|value
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the object contains key \a key.      \sa insert(), remove(), take()  */
end_comment
begin_function
DECL|function|contains
name|bool
name|QJsonObject
operator|::
name|contains
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|o
condition|)
return|return
literal|false
return|;
name|bool
name|keyExists
decl_stmt|;
name|o
operator|->
name|indexOf
argument_list|(
name|key
argument_list|,
operator|&
name|keyExists
argument_list|)
expr_stmt|;
return|return
name|keyExists
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if \a other is equal to this object  */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QJsonObject
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QJsonObject
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|o
operator|==
name|other
operator|.
name|o
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|o
condition|)
return|return
operator|!
name|other
operator|.
name|o
operator|->
name|length
return|;
if|if
condition|(
operator|!
name|other
operator|.
name|o
condition|)
return|return
operator|!
name|o
operator|->
name|length
return|;
if|if
condition|(
name|o
operator|->
name|length
operator|!=
name|other
operator|.
name|o
operator|->
name|length
condition|)
return|return
literal|false
return|;
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|o
operator|->
name|length
condition|;
operator|++
name|i
control|)
block|{
name|QJsonPrivate
operator|::
name|Entry
modifier|*
name|e
init|=
name|o
operator|->
name|entryAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QJsonValue
name|v
argument_list|(
name|d
argument_list|,
name|o
argument_list|,
name|e
operator|->
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|other
operator|.
name|value
argument_list|(
name|e
operator|->
name|key
argument_list|()
argument_list|)
operator|!=
name|v
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if \a other is not equal to this object  */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QJsonObject
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QJsonObject
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|other
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the (key, value) pair pointed to by the iterator \a it     from the map, and returns an iterator to the next item in the     map.      \sa remove()  */
end_comment
begin_function
DECL|function|erase
name|QJsonObject
operator|::
name|iterator
name|QJsonObject
operator|::
name|erase
parameter_list|(
name|QJsonObject
operator|::
name|iterator
name|it
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|d
operator|&&
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|o
operator|!=
name|this
operator|||
name|it
operator|.
name|i
operator|<
literal|0
operator|||
name|it
operator|.
name|i
operator|>=
operator|(
name|int
operator|)
name|o
operator|->
name|length
condition|)
return|return
name|iterator
argument_list|(
name|this
argument_list|,
name|o
operator|->
name|length
argument_list|)
return|;
name|int
name|index
init|=
name|it
operator|.
name|i
decl_stmt|;
name|o
operator|->
name|removeItems
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|++
name|d
operator|->
name|compactionCounter
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|compactionCounter
operator|>
literal|32u
operator|&&
name|d
operator|->
name|compactionCounter
operator|>=
name|unsigned
argument_list|(
name|o
operator|->
name|length
argument_list|)
operator|/
literal|2u
condition|)
name|compact
argument_list|()
expr_stmt|;
comment|// iterator hasn't changed
return|return
name|it
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an iterator pointing to the item with key \a key in the     map.      If the map contains no item with key \a key, the function     returns end().  */
end_comment
begin_function
DECL|function|find
name|QJsonObject
operator|::
name|iterator
name|QJsonObject
operator|::
name|find
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
name|bool
name|keyExists
init|=
literal|false
decl_stmt|;
name|int
name|index
init|=
name|o
condition|?
name|o
operator|->
name|indexOf
argument_list|(
name|key
argument_list|,
operator|&
name|keyExists
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|keyExists
condition|)
return|return
name|end
argument_list|()
return|;
name|detach
argument_list|()
expr_stmt|;
return|return
name|iterator
argument_list|(
name|this
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn QJsonObject::const_iterator QJsonObject::find(const QString&key) const      \overload */
end_comment
begin_comment
comment|/*!     Returns an const iterator pointing to the item with key \a key in the     map.      If the map contains no item with key \a key, the function     returns constEnd().  */
end_comment
begin_function
DECL|function|constFind
name|QJsonObject
operator|::
name|const_iterator
name|QJsonObject
operator|::
name|constFind
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|bool
name|keyExists
init|=
literal|false
decl_stmt|;
name|int
name|index
init|=
name|o
condition|?
name|o
operator|->
name|indexOf
argument_list|(
name|key
argument_list|,
operator|&
name|keyExists
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|keyExists
condition|)
return|return
name|end
argument_list|()
return|;
return|return
name|const_iterator
argument_list|(
name|this
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn int QJsonObject::count() const      \overload      Same as size(). */
end_comment
begin_comment
comment|/*! \fn int QJsonObject::length() const      \overload      Same as size(). */
end_comment
begin_comment
comment|/*! \fn QJsonObject::iterator QJsonObject::begin()      Returns an \l{STL-style iterator} pointing to the first item in     the object.      \sa constBegin(), end() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator QJsonObject::begin() const      \overload */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator QJsonObject::constBegin() const      Returns a const \l{STL-style iterator} pointing to the first item     in the object.      \sa begin(), constEnd() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::iterator QJsonObject::end()      Returns an \l{STL-style iterator} pointing to the imaginary item     after the last item in the object.      \sa begin(), constEnd() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator QJsonObject::end() const      \overload */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator QJsonObject::constEnd() const      Returns a const \l{STL-style iterator} pointing to the imaginary     item after the last item in the object.      \sa constBegin(), end() */
end_comment
begin_comment
comment|/*!     \fn bool QJsonObject::empty() const      This function is provided for STL compatibility. It is equivalent     to isEmpty(), returning \c true if the object is empty; otherwise     returning \c false. */
end_comment
begin_comment
comment|/*! \class QJsonObject::iterator     \inmodule QtCore     \ingroup json     \reentrant     \since 5.0      \brief The QJsonObject::iterator class provides an STL-style non-const iterator for QJsonObject.      QJsonObject::iterator allows you to iterate over a QJsonObject     and to modify the value (but not the key) stored under     a particular key. If you want to iterate over a const QJsonObject, you     should use QJsonObject::const_iterator. It is generally good practice to     use QJsonObject::const_iterator on a non-const QJsonObject as well, unless you     need to change the QJsonObject through the iterator. Const iterators are     slightly faster, and improves code readability.      The default QJsonObject::iterator constructor creates an uninitialized     iterator. You must initialize it using a QJsonObject function like     QJsonObject::begin(), QJsonObject::end(), or QJsonObject::find() before you can     start iterating.      Multiple iterators can be used on the same object. Existing iterators will however     become dangling once the object gets modified.      \sa QJsonObject::const_iterator */
end_comment
begin_comment
comment|/*! \typedef QJsonObject::iterator::difference_type      \internal */
end_comment
begin_comment
comment|/*! \typedef QJsonObject::iterator::iterator_category    A synonym for \e {std::bidirectional_iterator_tag} indicating   this iterator is a bidirectional iterator. */
end_comment
begin_comment
comment|/*! \typedef QJsonObject::iterator::reference      \internal */
end_comment
begin_comment
comment|/*! \typedef QJsonObject::iterator::value_type      \internal */
end_comment
begin_comment
comment|/*! \fn QJsonObject::iterator::iterator()      Constructs an uninitialized iterator.      Functions like key(), value(), and operator++() must not be     called on an uninitialized iterator. Use operator=() to assign a     value to it before using it.      \sa QJsonObject::begin(), QJsonObject::end() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::iterator::iterator(QJsonObject *obj, int index)     \internal */
end_comment
begin_comment
comment|/*! \fn QString QJsonObject::iterator::key() const      Returns the current item's key.      There is no direct way of changing an item's key through an     iterator, although it can be done by calling QJsonObject::erase()     followed by QJsonObject::insert().      \sa value() */
end_comment
begin_comment
comment|/*! \fn QJsonValueRef QJsonObject::iterator::value() const      Returns a modifiable reference to the current item's value.      You can change the value of an item by using value() on     the left side of an assignment.      The return value is of type QJsonValueRef, a helper class for QJsonArray     and QJsonObject. When you get an object of type QJsonValueRef, you can     use it as if it were a reference to a QJsonValue. If you assign to it,     the assignment will apply to the character in the QJsonArray of QJsonObject     from which you got the reference.      \sa key(), operator*() */
end_comment
begin_comment
comment|/*! \fn QJsonValueRef QJsonObject::iterator::operator*() const      Returns a modifiable reference to the current item's value.      Same as value().      The return value is of type QJsonValueRef, a helper class for QJsonArray     and QJsonObject. When you get an object of type QJsonValueRef, you can     use it as if it were a reference to a QJsonValue. If you assign to it,     the assignment will apply to the character in the QJsonArray of QJsonObject     from which you got the reference.      \sa key() */
end_comment
begin_comment
comment|/*!     \fn bool QJsonObject::iterator::operator==(const iterator&other) const     \fn bool QJsonObject::iterator::operator==(const const_iterator&other) const      Returns \c true if \a other points to the same item as this     iterator; otherwise returns \c false.      \sa operator!=() */
end_comment
begin_comment
comment|/*!     \fn bool QJsonObject::iterator::operator!=(const iterator&other) const     \fn bool QJsonObject::iterator::operator!=(const const_iterator&other) const      Returns \c true if \a other points to a different item than this     iterator; otherwise returns \c false.      \sa operator==() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::iterator QJsonObject::iterator::operator++()      The prefix ++ operator, \c{++i}, advances the iterator to the     next item in the object and returns an iterator to the new current     item.      Calling this function on QJsonObject::end() leads to undefined results.      \sa operator--() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::iterator QJsonObject::iterator::operator++(int)      \overload      The postfix ++ operator, \c{i++}, advances the iterator to the     next item in the object and returns an iterator to the previously     current item. */
end_comment
begin_comment
comment|/*! \fn QJsonObject::iterator QJsonObject::iterator::operator--()      The prefix -- operator, \c{--i}, makes the preceding item     current and returns an iterator pointing to the new current item.      Calling this function on QJsonObject::begin() leads to undefined     results.      \sa operator++() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::iterator QJsonObject::iterator::operator--(int)      \overload      The postfix -- operator, \c{i--}, makes the preceding item     current and returns an iterator pointing to the previously     current item. */
end_comment
begin_comment
comment|/*! \fn QJsonObject::iterator QJsonObject::iterator::operator+(int j) const      Returns an iterator to the item at \a j positions forward from     this iterator. If \a j is negative, the iterator goes backward.      \sa operator-()  */
end_comment
begin_comment
comment|/*! \fn QJsonObject::iterator QJsonObject::iterator::operator-(int j) const      Returns an iterator to the item at \a j positions backward from     this iterator. If \a j is negative, the iterator goes forward.      \sa operator+() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::iterator&QJsonObject::iterator::operator+=(int j)      Advances the iterator by \a j items. If \a j is negative, the     iterator goes backward.      \sa operator-=(), operator+() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::iterator&QJsonObject::iterator::operator-=(int j)      Makes the iterator go back by \a j items. If \a j is negative,     the iterator goes forward.      \sa operator+=(), operator-() */
end_comment
begin_comment
comment|/*!     \class QJsonObject::const_iterator     \inmodule QtCore     \brief The QJsonObject::const_iterator class provides an STL-style const iterator for QJsonObject.      QJsonObject::const_iterator allows you to iterate over a QJsonObject.     If you want to modify the QJsonObject as you iterate     over it, you must use QJsonObject::iterator instead. It is generally     good practice to use QJsonObject::const_iterator on a non-const QJsonObject as     well, unless you need to change the QJsonObject through the iterator.     Const iterators are slightly faster and improves code     readability.      The default QJsonObject::const_iterator constructor creates an     uninitialized iterator. You must initialize it using a QJsonObject     function like QJsonObject::constBegin(), QJsonObject::constEnd(), or     QJsonObject::find() before you can start iterating.      Multiple iterators can be used on the same object. Existing iterators     will however become dangling if the object gets modified.      \sa QJsonObject::iterator */
end_comment
begin_comment
comment|/*! \typedef QJsonObject::const_iterator::difference_type      \internal */
end_comment
begin_comment
comment|/*! \typedef QJsonObject::const_iterator::iterator_category    A synonym for \e {std::bidirectional_iterator_tag} indicating   this iterator is a bidirectional iterator. */
end_comment
begin_comment
comment|/*! \typedef QJsonObject::const_iterator::reference      \internal */
end_comment
begin_comment
comment|/*! \typedef QJsonObject::const_iterator::value_type      \internal */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator::const_iterator()      Constructs an uninitialized iterator.      Functions like key(), value(), and operator++() must not be     called on an uninitialized iterator. Use operator=() to assign a     value to it before using it.      \sa QJsonObject::constBegin(), QJsonObject::constEnd() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator::const_iterator(const QJsonObject *obj, int index)     \internal */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator::const_iterator(const iterator&other)      Constructs a copy of \a other. */
end_comment
begin_comment
comment|/*! \fn QString QJsonObject::const_iterator::key() const      Returns the current item's key.      \sa value() */
end_comment
begin_comment
comment|/*! \fn QJsonValue QJsonObject::const_iterator::value() const      Returns the current item's value.      \sa key(), operator*() */
end_comment
begin_comment
comment|/*! \fn QJsonValue QJsonObject::const_iterator::operator*() const      Returns the current item's value.      Same as value().      \sa key() */
end_comment
begin_comment
comment|/*! \fn bool QJsonObject::const_iterator::operator==(const const_iterator&other) const     \fn bool QJsonObject::const_iterator::operator==(const iterator&other) const      Returns \c true if \a other points to the same item as this     iterator; otherwise returns \c false.      \sa operator!=() */
end_comment
begin_comment
comment|/*! \fn bool QJsonObject::const_iterator::operator!=(const const_iterator&other) const     \fn bool QJsonObject::const_iterator::operator!=(const iterator&other) const      Returns \c true if \a other points to a different item than this     iterator; otherwise returns \c false.      \sa operator==() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator QJsonObject::const_iterator::operator++()      The prefix ++ operator, \c{++i}, advances the iterator to the     next item in the object and returns an iterator to the new current     item.      Calling this function on QJsonObject::end() leads to undefined results.      \sa operator--() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator QJsonObject::const_iterator::operator++(int)      \overload      The postfix ++ operator, \c{i++}, advances the iterator to the     next item in the object and returns an iterator to the previously     current item. */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator&QJsonObject::const_iterator::operator--()      The prefix -- operator, \c{--i}, makes the preceding item     current and returns an iterator pointing to the new current item.      Calling this function on QJsonObject::begin() leads to undefined     results.      \sa operator++() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator QJsonObject::const_iterator::operator--(int)      \overload      The postfix -- operator, \c{i--}, makes the preceding item     current and returns an iterator pointing to the previously     current item. */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator QJsonObject::const_iterator::operator+(int j) const      Returns an iterator to the item at \a j positions forward from     this iterator. If \a j is negative, the iterator goes backward.      This operation can be slow for large \a j values.      \sa operator-() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator QJsonObject::const_iterator::operator-(int j) const      Returns an iterator to the item at \a j positions backward from     this iterator. If \a j is negative, the iterator goes forward.      This operation can be slow for large \a j values.      \sa operator+() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator&QJsonObject::const_iterator::operator+=(int j)      Advances the iterator by \a j items. If \a j is negative, the     iterator goes backward.      This operation can be slow for large \a j values.      \sa operator-=(), operator+() */
end_comment
begin_comment
comment|/*! \fn QJsonObject::const_iterator&QJsonObject::const_iterator::operator-=(int j)      Makes the iterator go back by \a j items. If \a j is negative,     the iterator goes forward.      This operation can be slow for large \a j values.      \sa operator+=(), operator-() */
end_comment
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|detach
name|void
name|QJsonObject
operator|::
name|detach
parameter_list|(
name|uint
name|reserve
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|d
operator|=
operator|new
name|QJsonPrivate
operator|::
name|Data
argument_list|(
name|reserve
argument_list|,
name|QJsonValue
operator|::
name|Object
argument_list|)
expr_stmt|;
name|o
operator|=
cast|static_cast
argument_list|<
name|QJsonPrivate
operator|::
name|Object
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|header
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
return|return;
block|}
if|if
condition|(
name|reserve
operator|==
literal|0
operator|&&
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
condition|)
return|return;
name|QJsonPrivate
operator|::
name|Data
modifier|*
name|x
init|=
name|d
operator|->
name|clone
argument_list|(
name|o
argument_list|,
name|reserve
argument_list|)
decl_stmt|;
name|x
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
name|o
operator|=
cast|static_cast
argument_list|<
name|QJsonPrivate
operator|::
name|Object
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|header
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|compact
name|void
name|QJsonObject
operator|::
name|compact
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|compactionCounter
condition|)
return|return;
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|compact
argument_list|()
expr_stmt|;
name|o
operator|=
cast|static_cast
argument_list|<
name|QJsonPrivate
operator|::
name|Object
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|header
operator|->
name|root
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|keyAt
name|QString
name|QJsonObject
operator|::
name|keyAt
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|o
operator|&&
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
operator|(
name|int
operator|)
name|o
operator|->
name|length
argument_list|)
expr_stmt|;
name|QJsonPrivate
operator|::
name|Entry
modifier|*
name|e
init|=
name|o
operator|->
name|entryAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
return|return
name|e
operator|->
name|key
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|valueAt
name|QJsonValue
name|QJsonObject
operator|::
name|valueAt
parameter_list|(
name|int
name|i
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|o
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
operator|(
name|int
operator|)
name|o
operator|->
name|length
condition|)
return|return
name|QJsonValue
argument_list|(
name|QJsonValue
operator|::
name|Undefined
argument_list|)
return|;
name|QJsonPrivate
operator|::
name|Entry
modifier|*
name|e
init|=
name|o
operator|->
name|entryAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
return|return
name|QJsonValue
argument_list|(
name|d
argument_list|,
name|o
argument_list|,
name|e
operator|->
name|value
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|setValueAt
name|void
name|QJsonObject
operator|::
name|setValueAt
parameter_list|(
name|int
name|i
parameter_list|,
specifier|const
name|QJsonValue
modifier|&
name|val
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|o
operator|&&
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
operator|(
name|int
operator|)
name|o
operator|->
name|length
argument_list|)
expr_stmt|;
name|QJsonPrivate
operator|::
name|Entry
modifier|*
name|e
init|=
name|o
operator|->
name|entryAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|insert
argument_list|(
name|e
operator|->
name|key
argument_list|()
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QJsonObject
modifier|&
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
operator|.
name|o
condition|)
block|{
name|dbg
operator|<<
literal|"QJsonObject()"
expr_stmt|;
return|return
name|dbg
return|;
block|}
name|QByteArray
name|json
decl_stmt|;
name|QJsonPrivate
operator|::
name|Writer
operator|::
name|objectToJson
argument_list|(
name|o
operator|.
name|o
argument_list|,
name|json
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QJsonObject("
operator|<<
name|json
operator|.
name|constData
argument_list|()
comment|// print as utf-8 string without extra quotation marks
operator|<<
literal|")"
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
