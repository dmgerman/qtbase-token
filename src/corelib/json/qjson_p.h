begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Copyright (C) 2016 Intel Corporation. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QJSON_P_H
end_ifndef
begin_define
DECL|macro|QJSON_P_H
define|#
directive|define
name|QJSON_P_H
end_define
begin_comment
comment|//
end_comment
begin_comment
comment|//  W A R N I N G
end_comment
begin_comment
comment|//  -------------
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// This file is not part of the Qt API.  It exists purely as an
end_comment
begin_comment
comment|// implementation detail.  This header file may change from version to
end_comment
begin_comment
comment|// version without notice, or even be removed.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// We mean it.
end_comment
begin_comment
comment|//
end_comment
begin_include
include|#
directive|include
file|<qjsonobject.h>
end_include
begin_include
include|#
directive|include
file|<qjsonvalue.h>
end_include
begin_include
include|#
directive|include
file|<qjsondocument.h>
end_include
begin_include
include|#
directive|include
file|<qjsonarray.h>
end_include
begin_include
include|#
directive|include
file|<qatomic.h>
end_include
begin_include
include|#
directive|include
file|<qstring.h>
end_include
begin_include
include|#
directive|include
file|<qendian.h>
end_include
begin_include
include|#
directive|include
file|<qnumeric.h>
end_include
begin_include
include|#
directive|include
file|"private/qsimd_p.h"
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<limits>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/*   This defines a binary data structure for Json data. The data structure is optimised for fast reading   and minimum allocations. The whole data structure can be mmap'ed and used directly.    In most cases the binary structure is not as space efficient as a utf8 encoded text representation, but   much faster to access.    The size requirements are:    String:     Latin1 data: 2 bytes header + string.length()     Full Unicode: 4 bytes header + 2*(string.length())    Values: 4 bytes + size of data (size can be 0 for some data)     bool: 0 bytes     double: 8 bytes (0 if integer with less than 27bits)     string: see above     array: size of array     object: size of object   Array: 12 bytes + 4*length + size of Value data   Object: 12 bytes + 8*length + size of Key Strings + size of Value data    For an example such as      {                                           // object: 12 + 5*8                   = 52          "firstName": "John",                   // key 12, value 8                    = 20          "lastName" : "Smith",                  // key 12, value 8                    = 20          "age"      : 25,                       // key 8, value 0                     = 8          "address"  :                           // key 12, object below               = 140          {                                      // object: 12 + 4*8              "streetAddress": "21 2nd Street",  // key 16, value 16              "city"         : "New York",       // key 8, value 12              "state"        : "NY",             // key 8, value 4              "postalCode"   : "10021"           // key 12, value 8          },                                     // object total: 128          "phoneNumber":                         // key: 16, value array below         = 172          [                                      // array: 12 + 2*4 + values below: 156              {                                  // object 12 + 2*8                "type"  : "home",                // key 8, value 8                "number": "212 555-1234"         // key 8, value 16              },                                 // object total: 68              {                                  // object 12 + 2*8                "type"  : "fax",                 // key 8, value 8                "number": "646 555-4567"         // key 8, value 16              }                                  // object total: 68          ]                                      // array total: 156     }                                           // great total:                         412 bytes      The uncompressed text file used roughly 500 bytes, so in this case we end up using about     the same space as the text representation.      Other measurements have shown a slightly bigger binary size than a compact text     representation where all possible whitespace was stripped out. */
DECL|macro|Q_DECLARE_JSONPRIVATE_TYPEINFO
define|#
directive|define
name|Q_DECLARE_JSONPRIVATE_TYPEINFO
parameter_list|(
name|Class
parameter_list|,
name|Flags
parameter_list|)
value|} Q_DECLARE_TYPEINFO(QJsonPrivate::Class, Flags); namespace QJsonPrivate {
name|namespace
name|QJsonPrivate
block|{
name|class
name|Array
decl_stmt|;
name|class
name|Object
decl_stmt|;
name|class
name|Value
decl_stmt|;
name|class
name|Entry
decl_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|q_littleendian
block|{
name|public
operator|:
name|T
name|val
block|;
name|q_littleendian
operator|&
name|operator
operator|=
operator|(
name|T
name|i
operator|)
block|{
name|val
operator|=
name|qToLittleEndian
argument_list|(
name|i
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|operator
name|T
argument_list|()
specifier|const
block|{
return|return
name|qFromLittleEndian
argument_list|(
name|val
argument_list|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
name|T
name|i
operator|)
block|{
return|return
name|qFromLittleEndian
argument_list|(
name|val
argument_list|)
operator|==
name|i
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
name|T
name|i
operator|)
block|{
return|return
name|qFromLittleEndian
argument_list|(
name|val
argument_list|)
operator|!=
name|i
return|;
block|}
name|bool
name|operator
operator|==
operator|(
name|q_littleendian
operator|<
name|T
operator|>
name|i
operator|)
block|{
return|return
name|val
operator|==
name|i
operator|.
name|val
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
name|q_littleendian
operator|<
name|T
operator|>
name|i
operator|)
block|{
return|return
name|val
operator|!=
name|i
operator|.
name|val
return|;
block|}
name|bool
name|operator
operator|<
operator|(
name|T
name|i
operator|)
block|{
return|return
name|qFromLittleEndian
argument_list|(
name|val
argument_list|)
operator|<
name|i
return|;
block|}
name|bool
name|operator
operator|>
operator|(
name|T
name|i
operator|)
block|{
return|return
name|qFromLittleEndian
argument_list|(
name|val
argument_list|)
operator|>
name|i
return|;
block|}
name|bool
name|operator
operator|<=
operator|(
name|T
name|i
operator|)
block|{
return|return
name|qFromLittleEndian
argument_list|(
name|val
argument_list|)
operator|<=
name|i
return|;
block|}
name|bool
name|operator
operator|>=
operator|(
name|T
name|i
operator|)
block|{
return|return
name|qFromLittleEndian
argument_list|(
name|val
argument_list|)
operator|>=
name|i
return|;
block|}
name|q_littleendian
operator|&
name|operator
operator|+=
operator|(
name|T
name|i
operator|)
block|{
name|val
operator|=
name|qToLittleEndian
argument_list|(
name|qFromLittleEndian
argument_list|(
name|val
argument_list|)
operator|+
name|i
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
expr|}
block|; }
comment|// namespace QJsonPrivate
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QTypeInfo
operator|<
name|QJsonPrivate
operator|::
name|q_littleendian
operator|<
name|T
operator|>
expr|>
DECL|variable|T
operator|:
name|public
name|QTypeInfoMerger
operator|<
name|QJsonPrivate
operator|::
name|q_littleendian
operator|<
name|T
operator|>
operator|,
name|T
operator|>
block|{}
expr_stmt|;
name|namespace
name|QJsonPrivate
block|{
typedef|typedef
name|q_littleendian
operator|<
name|short
operator|>
name|qle_short
expr_stmt|;
typedef|typedef
name|q_littleendian
operator|<
name|unsigned
name|short
operator|>
name|qle_ushort
expr_stmt|;
typedef|typedef
name|q_littleendian
operator|<
name|int
operator|>
name|qle_int
expr_stmt|;
typedef|typedef
name|q_littleendian
operator|<
name|unsigned
name|int
operator|>
name|qle_uint
expr_stmt|;
name|template
operator|<
name|int
name|pos
operator|,
name|int
name|width
operator|>
name|class
name|qle_bitfield
block|{
name|public
operator|:
name|uint
name|val
block|;      enum
block|{
name|mask
operator|=
operator|(
operator|(
literal|1u
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|<<
name|pos
block|}
block|;
name|void
name|operator
operator|=
operator|(
name|uint
name|t
operator|)
block|{
name|uint
name|i
operator|=
name|qFromLittleEndian
argument_list|(
name|val
argument_list|)
block|;
name|i
operator|&=
operator|~
name|mask
block|;
name|i
operator||=
name|t
operator|<<
name|pos
block|;
name|val
operator|=
name|qToLittleEndian
argument_list|(
name|i
argument_list|)
block|;     }
name|operator
name|uint
argument_list|()
specifier|const
block|{
name|uint
name|t
operator|=
name|qFromLittleEndian
argument_list|(
name|val
argument_list|)
block|;
name|t
operator|&=
name|mask
block|;
name|t
operator|>>=
name|pos
block|;
return|return
name|t
return|;
block|}
name|bool
name|operator
operator|!
operator|(
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
name|uint
argument_list|()
return|;
block|}
name|bool
name|operator
operator|==
operator|(
name|uint
name|t
operator|)
block|{
return|return
name|uint
argument_list|(
operator|*
name|this
argument_list|)
operator|==
name|t
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
name|uint
name|t
operator|)
block|{
return|return
name|uint
argument_list|(
operator|*
name|this
argument_list|)
operator|!=
name|t
return|;
block|}
name|bool
name|operator
operator|<
operator|(
name|uint
name|t
operator|)
block|{
return|return
name|uint
argument_list|(
operator|*
name|this
argument_list|)
operator|<
name|t
return|;
block|}
name|bool
name|operator
operator|>
operator|(
name|uint
name|t
operator|)
block|{
return|return
name|uint
argument_list|(
operator|*
name|this
argument_list|)
operator|>
name|t
return|;
block|}
name|bool
name|operator
operator|<=
operator|(
name|uint
name|t
operator|)
block|{
return|return
name|uint
argument_list|(
operator|*
name|this
argument_list|)
operator|<=
name|t
return|;
block|}
name|bool
name|operator
operator|>=
operator|(
name|uint
name|t
operator|)
block|{
return|return
name|uint
argument_list|(
operator|*
name|this
argument_list|)
operator|>=
name|t
return|;
block|}
name|qle_bitfield
operator|&
name|operator
operator|+=
operator|(
name|uint
name|i
operator|)
block|{
operator|*
name|this
operator|=
operator|(
name|uint
argument_list|(
operator|*
name|this
argument_list|)
operator|+
name|i
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|qle_bitfield
operator|&
name|operator
operator|-=
operator|(
name|uint
name|i
operator|)
block|{
operator|*
name|this
operator|=
operator|(
name|uint
argument_list|(
operator|*
name|this
argument_list|)
operator|-
name|i
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
expr|}
block|;
name|template
operator|<
name|int
name|pos
block|,
name|int
name|width
operator|>
name|class
name|qle_signedbitfield
block|{
name|public
operator|:
name|uint
name|val
block|;      enum
block|{
name|mask
operator|=
operator|(
operator|(
literal|1u
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|<<
name|pos
block|}
block|;
name|void
name|operator
operator|=
operator|(
name|int
name|t
operator|)
block|{
name|uint
name|i
operator|=
name|qFromLittleEndian
argument_list|(
name|val
argument_list|)
block|;
name|i
operator|&=
operator|~
name|mask
block|;
name|i
operator||=
name|t
operator|<<
name|pos
block|;
name|val
operator|=
name|qToLittleEndian
argument_list|(
name|i
argument_list|)
block|;     }
name|operator
name|int
argument_list|()
specifier|const
block|{
name|uint
name|i
operator|=
name|qFromLittleEndian
argument_list|(
name|val
argument_list|)
block|;
name|i
operator|<<=
literal|32
operator|-
name|width
operator|-
name|pos
block|;
name|int
name|t
operator|=
operator|(
name|int
operator|)
name|i
block|;
name|t
operator|>>=
name|pos
block|;
return|return
name|t
return|;
block|}
name|bool
name|operator
operator|!
operator|(
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
name|int
argument_list|()
return|;
block|}
name|bool
name|operator
operator|==
operator|(
name|int
name|t
operator|)
block|{
return|return
name|int
argument_list|(
operator|*
name|this
argument_list|)
operator|==
name|t
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
name|int
name|t
operator|)
block|{
return|return
name|int
argument_list|(
operator|*
name|this
argument_list|)
operator|!=
name|t
return|;
block|}
name|bool
name|operator
operator|<
operator|(
name|int
name|t
operator|)
block|{
return|return
name|int
argument_list|(
operator|*
name|this
argument_list|)
operator|<
name|t
return|;
block|}
name|bool
name|operator
operator|>
operator|(
name|int
name|t
operator|)
block|{
return|return
name|int
argument_list|(
operator|*
name|this
argument_list|)
operator|>
name|t
return|;
block|}
name|bool
name|operator
operator|<=
operator|(
name|int
name|t
operator|)
block|{
return|return
name|int
argument_list|(
operator|*
name|this
argument_list|)
operator|<=
name|t
return|;
block|}
name|bool
name|operator
operator|>=
operator|(
name|int
name|t
operator|)
block|{
return|return
name|int
argument_list|(
operator|*
name|this
argument_list|)
operator|>=
name|t
return|;
block|}
name|qle_signedbitfield
operator|&
name|operator
operator|+=
operator|(
name|int
name|i
operator|)
block|{
operator|*
name|this
operator|=
operator|(
name|int
argument_list|(
operator|*
name|this
argument_list|)
operator|+
name|i
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|qle_signedbitfield
operator|&
name|operator
operator|-=
operator|(
name|int
name|i
operator|)
block|{
operator|*
name|this
operator|=
operator|(
name|int
argument_list|(
operator|*
name|this
argument_list|)
operator|-
name|i
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
expr|}
block|;
typedef|typedef
name|qle_uint
name|offset
typedef|;
comment|// round the size up to the next 4 byte boundary
specifier|inline
name|int
name|alignedSize
argument_list|(
argument|int size
argument_list|)
block|{
return|return
operator|(
name|size
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
return|;
block|}
specifier|static
specifier|inline
name|bool
name|useCompressed
argument_list|(
argument|const QString&s
argument_list|)
block|{
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>=
literal|0x8000
condition|)
return|return
name|false
return|;
specifier|const
name|ushort
operator|*
name|uc
operator|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|s
operator|.
name|constData
argument_list|()
block|;
specifier|const
name|ushort
operator|*
name|e
operator|=
name|uc
operator|+
name|s
operator|.
name|length
argument_list|()
block|;
while|while
condition|(
name|uc
operator|<
name|e
condition|)
block|{
if|if
condition|(
operator|*
name|uc
operator|>
literal|0xff
condition|)
return|return
name|false
return|;
operator|++
name|uc
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|int
name|qStringSize
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
name|bool
name|compress
parameter_list|)
block|{
name|int
name|l
init|=
literal|2
operator|+
name|string
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|compress
condition|)
name|l
operator|*=
literal|2
expr_stmt|;
return|return
name|alignedSize
argument_list|(
name|l
argument_list|)
return|;
block|}
comment|// returns INT_MAX if it can't compress it into 28 bits
specifier|static
specifier|inline
name|int
name|compressedNumber
parameter_list|(
name|double
name|d
parameter_list|)
block|{
comment|// this relies on details of how ieee floats are represented
specifier|const
name|int
name|exponent_off
init|=
literal|52
decl_stmt|;
specifier|const
name|quint64
name|fraction_mask
init|=
literal|0x000fffffffffffffull
decl_stmt|;
specifier|const
name|quint64
name|exponent_mask
init|=
literal|0x7ff0000000000000ull
decl_stmt|;
name|quint64
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|exp
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|val
operator|&
name|exponent_mask
operator|)
operator|>>
name|exponent_off
argument_list|)
operator|-
literal|1023
decl_stmt|;
if|if
condition|(
name|exp
operator|<
literal|0
operator|||
name|exp
operator|>
literal|25
condition|)
return|return
name|INT_MAX
return|;
name|quint64
name|non_int
init|=
name|val
operator|&
operator|(
name|fraction_mask
operator|>>
name|exp
operator|)
decl_stmt|;
if|if
condition|(
name|non_int
condition|)
return|return
name|INT_MAX
return|;
name|bool
name|neg
init|=
operator|(
name|val
operator|>>
literal|63
operator|)
operator|!=
literal|0
decl_stmt|;
name|val
operator|&=
name|fraction_mask
expr_stmt|;
name|val
operator||=
operator|(
operator|(
name|quint64
operator|)
literal|1
operator|<<
literal|52
operator|)
expr_stmt|;
name|int
name|res
init|=
call|(
name|int
call|)
argument_list|(
name|val
operator|>>
operator|(
literal|52
operator|-
name|exp
operator|)
argument_list|)
decl_stmt|;
return|return
name|neg
condition|?
operator|-
name|res
else|:
name|res
return|;
block|}
name|class
name|Latin1String
decl_stmt|;
name|class
name|String
block|{
name|public
label|:
name|String
argument_list|(
argument|const char *data
argument_list|)
block|{
name|d
operator|=
operator|(
name|Data
operator|*
operator|)
name|data
expr_stmt|;
block|}
struct|struct
name|Data
block|{
name|qle_int
name|length
decl_stmt|;
name|qle_ushort
name|utf16
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
name|Data
modifier|*
name|d
decl_stmt|;
specifier|inline
name|String
modifier|&
name|operator
init|=
operator|(
specifier|const
name|QString
operator|&
name|str
operator|)
block|{
name|d
operator|->
name|length
operator|=
name|str
operator|.
name|length
argument_list|()
block|;
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_BIG_ENDIAN
specifier|const
name|ushort
operator|*
name|uc
operator|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|str
operator|.
name|unicode
argument_list|()
block|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|utf16
index|[
name|i
index|]
operator|=
name|uc
index|[
name|i
index|]
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|d
operator|->
name|utf16
argument_list|,
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|str
operator|.
name|length
argument_list|()
operator|&
literal|1
condition|)
name|d
operator|->
name|utf16
index|[
name|str
operator|.
name|length
argument_list|()
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|QString
operator|&
name|str
operator|)
specifier|const
block|{
name|int
name|slen
operator|=
name|str
operator|.
name|length
argument_list|()
block|;
name|int
name|l
operator|=
name|d
operator|->
name|length
block|;
if|if
condition|(
name|slen
operator|!=
name|l
condition|)
return|return
name|false
return|;
specifier|const
name|ushort
operator|*
name|s
operator|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|str
operator|.
name|constData
argument_list|()
expr_stmt|;
specifier|const
name|qle_ushort
modifier|*
name|a
init|=
name|d
operator|->
name|utf16
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|b
init|=
name|s
decl_stmt|;
while|while
condition|(
name|l
operator|--
operator|&&
operator|*
name|a
operator|==
operator|*
name|b
condition|)
name|a
operator|++
operator|,
name|b
operator|++
expr_stmt|;
return|return
operator|(
name|l
operator|==
operator|-
literal|1
operator|)
return|;
block|}
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|QString
operator|&
name|str
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|str
operator|)
return|;
block|}
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|QString
operator|&
name|str
operator|)
specifier|const
block|{
comment|// ###
return|return
name|toString
argument_list|()
operator|>=
name|str
return|;
block|}
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|Latin1String
operator|&
name|str
operator|)
specifier|const
expr_stmt|;
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|Latin1String
operator|&
name|str
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|<
operator|(
name|str
operator|)
return|;
block|}
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Latin1String
operator|&
name|str
operator|)
specifier|const
expr_stmt|;
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|String
operator|&
name|str
operator|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|length
operator|!=
name|str
operator|.
name|d
operator|->
name|length
condition|)
return|return
name|false
return|;
return|return
operator|!
name|memcmp
argument_list|(
name|d
operator|->
name|utf16
argument_list|,
name|str
operator|.
name|d
operator|->
name|utf16
argument_list|,
name|d
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt
begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|String
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
end_expr_stmt
begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|String
operator|&
name|other
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|<
name|other
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QString
name|toString
argument_list|()
specifier|const
block|{
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_LITTLE_ENDIAN
return|return
name|QString
argument_list|(
operator|(
name|QChar
operator|*
operator|)
name|d
operator|->
name|utf16
argument_list|,
name|d
operator|->
name|length
argument_list|)
return|;
else|#
directive|else
name|int
name|l
operator|=
name|d
operator|->
name|length
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|QString
name|str
argument_list|(
name|l
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|QChar
modifier|*
name|ch
init|=
name|str
operator|.
name|data
argument_list|()
decl_stmt|;
end_decl_stmt
begin_for
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
operator|++
name|i
control|)
name|ch
index|[
name|i
index|]
operator|=
name|QChar
argument_list|(
name|d
operator|->
name|utf16
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_for
begin_return
return|return
name|str
return|;
end_return
begin_endif
endif|#
directive|endif
end_endif
begin_empty_stmt
unit|}  }
empty_stmt|;
end_empty_stmt
begin_decl_stmt
name|class
name|Latin1String
block|{
name|public
label|:
name|Latin1String
argument_list|(
argument|const char *data
argument_list|)
block|{
name|d
operator|=
operator|(
name|Data
operator|*
operator|)
name|data
expr_stmt|;
block|}
struct|struct
name|Data
block|{
name|qle_short
name|length
decl_stmt|;
name|char
name|latin1
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
name|Data
modifier|*
name|d
decl_stmt|;
specifier|inline
name|Latin1String
modifier|&
name|operator
init|=
operator|(
specifier|const
name|QString
operator|&
name|str
operator|)
block|{
name|int
name|len
operator|=
name|d
operator|->
name|length
operator|=
name|str
operator|.
name|length
argument_list|()
block|;
name|uchar
operator|*
name|l
operator|=
operator|(
name|uchar
operator|*
operator|)
name|d
operator|->
name|latin1
block|;
specifier|const
name|ushort
operator|*
name|uc
operator|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|str
operator|.
name|unicode
argument_list|()
block|;
name|int
name|i
operator|=
literal|0
block|;
ifdef|#
directive|ifdef
name|__SSE2__
for|for
control|(
init|;
name|i
operator|+
literal|16
operator|<
name|len
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|__m128i
name|chunk1
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|&
name|uc
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|// load
name|__m128i
name|chunk2
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|&
name|uc
index|[
name|i
operator|+
literal|8
index|]
argument_list|)
decl_stmt|;
comment|// load
comment|// pack the two vector to 16 x 8bits elements
specifier|const
name|__m128i
name|result
init|=
name|_mm_packus_epi16
argument_list|(
name|chunk1
argument_list|,
name|chunk2
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|&
name|l
index|[
name|i
index|]
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|// store
block|}
ifdef|#
directive|ifdef
name|Q_PROCESSOR_X86_64
comment|// we can do one more round, of 8 characters
if|if
condition|(
name|i
operator|+
literal|8
operator|<
name|len
condition|)
block|{
name|__m128i
name|chunk
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|&
name|uc
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|// load
comment|// pack with itself, we'll discard the high part anyway
name|chunk
operator|=
name|_mm_packus_epi16
argument_list|(
name|chunk
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
comment|// unaligned 64-bit store
name|qUnalignedStore
argument_list|(
name|l
operator|+
name|i
argument_list|,
name|_mm_cvtsi128_si64
argument_list|(
name|chunk
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|8
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|l
index|[
name|i
index|]
operator|=
name|uc
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
call|(
name|quintptr
call|)
argument_list|(
name|l
operator|+
name|i
argument_list|)
operator|&
literal|0x3
condition|;
operator|++
name|i
control|)
name|l
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt
begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|QString
operator|&
name|str
operator|)
specifier|const
block|{
return|return
name|QLatin1String
argument_list|(
name|d
operator|->
name|latin1
argument_list|,
name|d
operator|->
name|length
argument_list|)
operator|==
name|str
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|QString
operator|&
name|str
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|str
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|QString
operator|&
name|str
operator|)
specifier|const
block|{
return|return
name|QLatin1String
argument_list|(
name|d
operator|->
name|latin1
argument_list|,
name|d
operator|->
name|length
argument_list|)
operator|>=
name|str
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Latin1String
operator|&
name|str
operator|)
specifier|const
block|{
return|return
name|d
operator|->
name|length
operator|==
name|str
operator|.
name|d
operator|->
name|length
operator|&&
operator|!
name|strcmp
argument_list|(
name|d
operator|->
name|latin1
argument_list|,
name|str
operator|.
name|d
operator|->
name|latin1
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|Latin1String
operator|&
name|str
operator|)
specifier|const
block|{
name|int
name|l
operator|=
name|qMin
argument_list|(
name|d
operator|->
name|length
argument_list|,
name|str
operator|.
name|d
operator|->
name|length
argument_list|)
block|;
name|int
name|val
operator|=
name|strncmp
argument_list|(
name|d
operator|->
name|latin1
argument_list|,
name|str
operator|.
name|d
operator|->
name|latin1
argument_list|,
name|l
argument_list|)
block|;
if|if
condition|(
operator|!
name|val
condition|)
name|val
operator|=
name|d
operator|->
name|length
operator|-
name|str
operator|.
name|d
operator|->
name|length
expr_stmt|;
end_expr_stmt
begin_return
return|return
name|val
operator|>=
literal|0
return|;
end_return
begin_expr_stmt
unit|}     inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|String
operator|&
name|str
operator|)
specifier|const
block|{
specifier|const
name|qle_ushort
operator|*
name|uc
operator|=
operator|(
name|qle_ushort
operator|*
operator|)
name|str
operator|.
name|d
operator|->
name|utf16
block|;
if|if
condition|(
operator|!
name|uc
operator|||
operator|*
name|uc
operator|==
literal|0
condition|)
return|return
name|false
return|;
specifier|const
name|uchar
operator|*
name|c
operator|=
operator|(
name|uchar
operator|*
operator|)
name|d
operator|->
name|latin1
expr_stmt|;
end_expr_stmt
begin_decl_stmt
specifier|const
name|uchar
modifier|*
name|e
init|=
name|c
operator|+
name|qMin
argument_list|(
operator|(
name|int
operator|)
name|d
operator|->
name|length
argument_list|,
operator|(
name|int
operator|)
name|str
operator|.
name|d
operator|->
name|length
argument_list|)
decl_stmt|;
end_decl_stmt
begin_while
while|while
condition|(
name|c
operator|<
name|e
condition|)
block|{
if|if
condition|(
operator|*
name|c
operator|!=
operator|*
name|uc
condition|)
break|break;
operator|++
name|c
expr_stmt|;
operator|++
name|uc
expr_stmt|;
block|}
end_while
begin_return
return|return
operator|(
name|c
operator|==
name|e
condition|?
operator|(
name|int
operator|)
name|d
operator|->
name|length
operator|<
operator|(
name|int
operator|)
name|str
operator|.
name|d
operator|->
name|length
else|:
operator|*
name|c
operator|<
operator|*
name|uc
operator|)
return|;
end_return
begin_expr_stmt
unit|}     inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|String
operator|&
name|str
operator|)
specifier|const
block|{
return|return
operator|(
name|str
operator|==
operator|*
name|this
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|String
operator|&
name|str
operator|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|<
name|str
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QString
name|toString
argument_list|()
specifier|const
block|{
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|d
operator|->
name|latin1
argument_list|,
name|d
operator|->
name|length
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
unit|};
specifier|inline
name|bool
name|String
operator|::
name|operator
operator|==
operator|(
specifier|const
name|Latin1String
operator|&
name|str
operator|)
specifier|const
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|d
operator|->
name|length
operator|!=
operator|(
name|int
operator|)
name|str
operator|.
name|d
operator|->
name|length
condition|)
return|return
name|false
return|;
specifier|const
name|qle_ushort
operator|*
name|uc
operator|=
name|d
operator|->
name|utf16
expr_stmt|;
end_expr_stmt
begin_decl_stmt
specifier|const
name|qle_ushort
modifier|*
name|e
init|=
name|uc
operator|+
name|d
operator|->
name|length
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|const
name|uchar
modifier|*
name|c
init|=
operator|(
name|uchar
operator|*
operator|)
name|str
operator|.
name|d
operator|->
name|latin1
decl_stmt|;
end_decl_stmt
begin_while
while|while
condition|(
name|uc
operator|<
name|e
condition|)
block|{
if|if
condition|(
operator|*
name|uc
operator|!=
operator|*
name|c
condition|)
return|return
name|false
return|;
operator|++
name|uc
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
end_while
begin_return
return|return
name|true
return|;
end_return
begin_expr_stmt
unit|}  inline
name|bool
name|String
operator|::
name|operator
operator|<
operator|(
specifier|const
name|String
operator|&
name|other
operator|)
specifier|const
block|{
name|int
name|alen
operator|=
name|d
operator|->
name|length
block|;
name|int
name|blen
operator|=
name|other
operator|.
name|d
operator|->
name|length
block|;
name|int
name|l
operator|=
name|qMin
argument_list|(
name|alen
argument_list|,
name|blen
argument_list|)
block|;
name|qle_ushort
operator|*
name|a
operator|=
name|d
operator|->
name|utf16
block|;
name|qle_ushort
operator|*
name|b
operator|=
name|other
operator|.
name|d
operator|->
name|utf16
block|;
while|while
condition|(
name|l
operator|--
operator|&&
operator|*
name|a
operator|==
operator|*
name|b
condition|)
name|a
operator|++
operator|,
name|b
operator|++
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|l
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|alen
operator|<
name|blen
operator|)
return|;
end_if
begin_return
return|return
operator|(
name|ushort
operator|)
operator|*
name|a
operator|<
operator|(
name|ushort
operator|)
operator|*
name|b
return|;
end_return
begin_expr_stmt
unit|}  inline
name|bool
name|String
operator|::
name|operator
operator|<
operator|(
specifier|const
name|Latin1String
operator|&
name|str
operator|)
specifier|const
block|{
specifier|const
name|uchar
operator|*
name|c
operator|=
operator|(
name|uchar
operator|*
operator|)
name|str
operator|.
name|d
operator|->
name|latin1
block|;
if|if
condition|(
operator|!
name|c
operator|||
operator|*
name|c
operator|==
literal|0
condition|)
return|return
name|false
return|;
specifier|const
name|qle_ushort
operator|*
name|uc
operator|=
name|d
operator|->
name|utf16
expr_stmt|;
end_expr_stmt
begin_decl_stmt
specifier|const
name|qle_ushort
modifier|*
name|e
init|=
name|uc
operator|+
name|qMin
argument_list|(
operator|(
name|int
operator|)
name|d
operator|->
name|length
argument_list|,
operator|(
name|int
operator|)
name|str
operator|.
name|d
operator|->
name|length
argument_list|)
decl_stmt|;
end_decl_stmt
begin_while
while|while
condition|(
name|uc
operator|<
name|e
condition|)
block|{
if|if
condition|(
operator|*
name|uc
operator|!=
operator|*
name|c
condition|)
break|break;
operator|++
name|uc
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
end_while
begin_return
return|return
operator|(
name|uc
operator|==
name|e
condition|?
operator|(
name|int
operator|)
name|d
operator|->
name|length
operator|<
operator|(
name|int
operator|)
name|str
operator|.
name|d
operator|->
name|length
else|:
operator|(
name|ushort
operator|)
operator|*
name|uc
operator|<
operator|*
name|c
operator|)
return|;
end_return
begin_function
unit|}  static
specifier|inline
name|void
name|copyString
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|bool
name|compress
parameter_list|)
block|{
if|if
condition|(
name|compress
condition|)
block|{
name|Latin1String
name|string
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|string
operator|=
name|str
expr_stmt|;
block|}
else|else
block|{
name|String
name|string
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|string
operator|=
name|str
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  Base is the base class for both Object and Array. Both classe work more or less the same way.  The class starts with a header (defined by the struct below), then followed by data (the data for  values in the Array case and Entry's (see below) for objects.   After the data a table follows (tableOffset points to it) containing Value objects for Arrays, and  offsets from the beginning of the object to Entry's in the case of Object.   Entry's in the Object's table are lexicographically sorted by key in the table(). This allows the usage  of a binary search over the keys in an Object.  */
end_comment
begin_decl_stmt
name|class
name|Base
block|{
name|public
label|:
name|qle_uint
name|size
decl_stmt|;
union|union
block|{
name|uint
name|_dummy
decl_stmt|;
name|qle_bitfield
operator|<
literal|0
operator|,
literal|1
operator|>
name|is_object
expr_stmt|;
name|qle_bitfield
operator|<
literal|1
operator|,
literal|31
operator|>
name|length
expr_stmt|;
block|}
union|;
name|offset
name|tableOffset
decl_stmt|;
comment|// content follows here
specifier|inline
name|bool
name|isObject
argument_list|()
specifier|const
block|{
return|return
operator|!
operator|!
name|is_object
return|;
block|}
specifier|inline
name|bool
name|isArray
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isObject
argument_list|()
return|;
block|}
specifier|inline
name|offset
operator|*
name|table
argument_list|()
specifier|const
block|{
return|return
operator|(
name|offset
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|this
operator|)
operator|+
name|tableOffset
operator|)
return|;
block|}
name|int
name|reserveSpace
parameter_list|(
name|uint
name|dataSize
parameter_list|,
name|int
name|posInTable
parameter_list|,
name|uint
name|numItems
parameter_list|,
name|bool
name|replace
parameter_list|)
function_decl|;
name|void
name|removeItems
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|numItems
parameter_list|)
function_decl|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_decl_stmt
name|class
name|Object
range|:
name|public
name|Base
block|{
name|public
operator|:
name|Entry
operator|*
name|entryAt
argument_list|(
argument|int i
argument_list|)
specifier|const
block|{
return|return
name|reinterpret_cast
operator|<
name|Entry
operator|*
operator|>
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|this
operator|)
operator|+
name|table
argument_list|()
index|[
name|i
index|]
operator|)
return|;
block|}
name|int
name|indexOf
argument_list|(
specifier|const
name|QString
operator|&
name|key
argument_list|,
name|bool
operator|*
name|exists
argument_list|)
block|;
name|bool
name|isValid
argument_list|()
specifier|const
block|; }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|class
name|Array
range|:
name|public
name|Base
block|{
name|public
operator|:
specifier|inline
name|Value
name|at
argument_list|(
argument|int i
argument_list|)
specifier|const
block|;
specifier|inline
name|Value
operator|&
name|operator
index|[]
operator|(
name|int
name|i
operator|)
block|;
name|bool
name|isValid
argument_list|()
specifier|const
block|; }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|class
name|Value
block|{
name|public
label|:
enum|enum
block|{
name|MaxSize
init|=
operator|(
literal|1
operator|<<
literal|27
operator|)
operator|-
literal|1
block|}
enum|;
union|union
block|{
name|uint
name|_dummy
decl_stmt|;
name|qle_bitfield
operator|<
literal|0
operator|,
literal|3
operator|>
name|type
expr_stmt|;
name|qle_bitfield
operator|<
literal|3
operator|,
literal|1
operator|>
name|latinOrIntValue
expr_stmt|;
name|qle_bitfield
operator|<
literal|4
operator|,
literal|1
operator|>
name|latinKey
expr_stmt|;
name|qle_bitfield
operator|<
literal|5
operator|,
literal|27
operator|>
name|value
expr_stmt|;
name|qle_signedbitfield
operator|<
literal|5
operator|,
literal|27
operator|>
name|int_value
expr_stmt|;
block|}
union|;
specifier|inline
name|char
modifier|*
name|data
argument_list|(
specifier|const
name|Base
operator|*
name|b
argument_list|)
decl|const
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|b
operator|)
operator|+
name|value
return|;
block|}
name|int
name|usedStorage
argument_list|(
specifier|const
name|Base
operator|*
name|b
argument_list|)
decl|const
decl_stmt|;
name|bool
name|toBoolean
argument_list|()
specifier|const
expr_stmt|;
name|double
name|toDouble
argument_list|(
specifier|const
name|Base
operator|*
name|b
argument_list|)
decl|const
decl_stmt|;
name|QString
name|toString
argument_list|(
specifier|const
name|Base
operator|*
name|b
argument_list|)
decl|const
decl_stmt|;
name|String
name|asString
argument_list|(
specifier|const
name|Base
operator|*
name|b
argument_list|)
decl|const
decl_stmt|;
name|Latin1String
name|asLatin1String
argument_list|(
specifier|const
name|Base
operator|*
name|b
argument_list|)
decl|const
decl_stmt|;
name|Base
modifier|*
name|base
argument_list|(
specifier|const
name|Base
operator|*
name|b
argument_list|)
decl|const
decl_stmt|;
name|bool
name|isValid
argument_list|(
specifier|const
name|Base
operator|*
name|b
argument_list|)
decl|const
decl_stmt|;
specifier|static
name|int
name|requiredStorage
parameter_list|(
name|QJsonValue
modifier|&
name|v
parameter_list|,
name|bool
modifier|*
name|compressed
parameter_list|)
function_decl|;
specifier|static
name|uint
name|valueToStore
parameter_list|(
specifier|const
name|QJsonValue
modifier|&
name|v
parameter_list|,
name|uint
name|offset
parameter_list|)
function_decl|;
specifier|static
name|void
name|copyData
parameter_list|(
specifier|const
name|QJsonValue
modifier|&
name|v
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|bool
name|compressed
parameter_list|)
function_decl|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_macro
name|Q_DECLARE_JSONPRIVATE_TYPEINFO
argument_list|(
argument|Value
argument_list|,
argument|Q_PRIMITIVE_TYPE
argument_list|)
end_macro
begin_expr_stmt
specifier|inline
name|Value
name|Array
operator|::
name|at
argument_list|(
argument|int i
argument_list|)
specifier|const
block|{
return|return
operator|*
operator|(
name|Value
operator|*
operator|)
operator|(
name|table
argument_list|()
operator|+
name|i
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|Value
operator|&
name|Array
operator|::
name|operator
index|[]
operator|(
name|int
name|i
operator|)
block|{
return|return
operator|*
operator|(
name|Value
operator|*
operator|)
operator|(
name|table
argument_list|()
operator|+
name|i
operator|)
return|;
block|}
end_expr_stmt
begin_decl_stmt
name|class
name|Entry
block|{
name|public
label|:
name|Value
name|value
decl_stmt|;
comment|// key
comment|// value data follows key
name|int
name|size
argument_list|()
specifier|const
block|{
name|int
name|s
operator|=
sizeof|sizeof
argument_list|(
name|Entry
argument_list|)
block|;
if|if
condition|(
name|value
operator|.
name|latinKey
condition|)
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
operator|+
name|qFromLittleEndian
argument_list|(
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|this
operator|+
sizeof|sizeof
argument_list|(
name|Entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
operator|*
name|qFromLittleEndian
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|this
operator|+
sizeof|sizeof
argument_list|(
name|Entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|alignedSize
argument_list|(
name|s
argument_list|)
return|;
block|}
end_decl_stmt
begin_decl_stmt
name|int
name|usedStorage
argument_list|(
name|Base
operator|*
name|b
argument_list|)
decl|const
block|{
return|return
name|size
argument_list|()
operator|+
name|value
operator|.
name|usedStorage
argument_list|(
name|b
argument_list|)
return|;
block|}
end_decl_stmt
begin_expr_stmt
name|String
name|shallowKey
argument_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|value
operator|.
name|latinKey
argument_list|)
block|;
return|return
name|String
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|this
operator|+
sizeof|sizeof
argument_list|(
name|Entry
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|Latin1String
name|shallowLatin1Key
argument_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|value
operator|.
name|latinKey
argument_list|)
block|;
return|return
name|Latin1String
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|this
operator|+
sizeof|sizeof
argument_list|(
name|Entry
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|QString
name|key
argument_list|()
specifier|const
block|{
if|if
condition|(
name|value
operator|.
name|latinKey
condition|)
block|{
return|return
name|shallowLatin1Key
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
end_expr_stmt
begin_return
return|return
name|shallowKey
argument_list|()
operator|.
name|toString
argument_list|()
return|;
end_return
begin_expr_stmt
unit|}      bool
name|operator
operator|==
operator|(
specifier|const
name|QString
operator|&
name|key
operator|)
specifier|const
expr_stmt|;
end_expr_stmt
begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|QString
operator|&
name|key
operator|)
specifier|const
block|{
return|return
operator|!
name|operator
operator|==
operator|(
name|key
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|QString
operator|&
name|key
operator|)
specifier|const
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|bool
name|operator
operator|==
operator|(
specifier|const
name|Entry
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|bool
name|operator
operator|>=
operator|(
specifier|const
name|Entry
operator|&
name|other
operator|)
specifier|const
expr_stmt|;
end_expr_stmt
begin_expr_stmt
unit|};
specifier|inline
name|bool
name|Entry
operator|::
name|operator
operator|>=
operator|(
specifier|const
name|QString
operator|&
name|key
operator|)
specifier|const
block|{
if|if
condition|(
name|value
operator|.
name|latinKey
condition|)
return|return
operator|(
name|shallowLatin1Key
argument_list|()
operator|>=
name|key
operator|)
return|;
else|else
return|return
operator|(
name|shallowKey
argument_list|()
operator|>=
name|key
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|QString
operator|&
name|key
operator|,
specifier|const
name|Entry
operator|&
name|e
operator|)
block|{
return|return
name|e
operator|>=
name|key
return|;
block|}
end_expr_stmt
begin_decl_stmt
name|class
name|Header
block|{
name|public
label|:
name|qle_uint
name|tag
decl_stmt|;
comment|// 'qbjs'
name|qle_uint
name|version
decl_stmt|;
comment|// 1
name|Base
modifier|*
name|root
parameter_list|()
block|{
return|return
operator|(
name|Base
operator|*
operator|)
operator|(
name|this
operator|+
literal|1
operator|)
return|;
block|}
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
specifier|inline
name|bool
name|Value
operator|::
name|toBoolean
argument_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|type
operator|==
name|QJsonValue
operator|::
name|Bool
argument_list|)
block|;
return|return
name|value
operator|!=
literal|0
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|double
name|Value
operator|::
name|toDouble
argument_list|(
argument|const Base *b
argument_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|type
operator|==
name|QJsonValue
operator|::
name|Double
argument_list|)
block|;
if|if
condition|(
name|latinOrIntValue
condition|)
return|return
name|int_value
return|;
name|quint64
name|i
operator|=
name|qFromLittleEndian
operator|<
name|quint64
operator|>
operator|(
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|b
operator|+
name|value
operator|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|double
name|d
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|memcpy
argument_list|(
operator|&
name|d
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_return
return|return
name|d
return|;
end_return
begin_expr_stmt
unit|}  inline
name|String
name|Value
operator|::
name|asString
argument_list|(
argument|const Base *b
argument_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|type
operator|==
name|QJsonValue
operator|::
name|String
operator|&&
operator|!
name|latinOrIntValue
argument_list|)
block|;
return|return
name|String
argument_list|(
name|data
argument_list|(
name|b
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|Latin1String
name|Value
operator|::
name|asLatin1String
argument_list|(
argument|const Base *b
argument_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|type
operator|==
name|QJsonValue
operator|::
name|String
operator|&&
name|latinOrIntValue
argument_list|)
block|;
return|return
name|Latin1String
argument_list|(
name|data
argument_list|(
name|b
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QString
name|Value
operator|::
name|toString
argument_list|(
argument|const Base *b
argument_list|)
specifier|const
block|{
if|if
condition|(
name|latinOrIntValue
condition|)
return|return
name|asLatin1String
argument_list|(
name|b
argument_list|)
operator|.
name|toString
argument_list|()
return|;
else|else
return|return
name|asString
argument_list|(
name|b
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|Base
operator|*
name|Value
operator|::
name|base
argument_list|(
argument|const Base *b
argument_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|type
operator|==
name|QJsonValue
operator|::
name|Array
operator|||
name|type
operator|==
name|QJsonValue
operator|::
name|Object
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
name|Base
operator|*
operator|>
operator|(
name|data
argument_list|(
name|b
argument_list|)
operator|)
return|;
block|}
end_expr_stmt
begin_decl_stmt
name|class
name|Data
block|{
name|public
label|:
enum|enum
name|Validation
block|{
name|Unchecked
block|,
name|Validated
block|,
name|Invalid
block|}
enum|;
name|QAtomicInt
name|ref
decl_stmt|;
name|int
name|alloc
decl_stmt|;
union|union
block|{
name|char
modifier|*
name|rawData
decl_stmt|;
name|Header
modifier|*
name|header
decl_stmt|;
block|}
union|;
name|uint
name|compactionCounter
range|:
literal|31
decl_stmt|;
name|uint
name|ownsData
range|:
literal|1
decl_stmt|;
specifier|inline
name|Data
argument_list|(
argument|char *raw
argument_list|,
argument|int a
argument_list|)
operator|:
name|alloc
argument_list|(
name|a
argument_list|)
operator|,
name|rawData
argument_list|(
name|raw
argument_list|)
operator|,
name|compactionCounter
argument_list|(
literal|0
argument_list|)
operator|,
name|ownsData
argument_list|(
argument|true
argument_list|)
block|{     }
specifier|inline
name|Data
argument_list|(
argument|int reserved
argument_list|,
argument|QJsonValue::Type valueType
argument_list|)
operator|:
name|rawData
argument_list|(
literal|0
argument_list|)
operator|,
name|compactionCounter
argument_list|(
literal|0
argument_list|)
operator|,
name|ownsData
argument_list|(
argument|true
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|valueType
operator|==
name|QJsonValue
operator|::
name|Array
operator|||
name|valueType
operator|==
name|QJsonValue
operator|::
name|Object
argument_list|)
block|;
name|alloc
operator|=
sizeof|sizeof
argument_list|(
name|Header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Base
argument_list|)
operator|+
name|reserved
operator|+
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
block|;
name|header
operator|=
operator|(
name|Header
operator|*
operator|)
name|malloc
argument_list|(
name|alloc
argument_list|)
block|;
name|Q_CHECK_PTR
argument_list|(
name|header
argument_list|)
block|;
name|header
operator|->
name|tag
operator|=
name|QJsonDocument
operator|::
name|BinaryFormatTag
block|;
name|header
operator|->
name|version
operator|=
literal|1
block|;
name|Base
operator|*
name|b
operator|=
name|header
operator|->
name|root
argument_list|()
block|;
name|b
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|Base
argument_list|)
block|;
name|b
operator|->
name|is_object
operator|=
operator|(
name|valueType
operator|==
name|QJsonValue
operator|::
name|Object
operator|)
block|;
name|b
operator|->
name|tableOffset
operator|=
sizeof|sizeof
argument_list|(
name|Base
argument_list|)
block|;
name|b
operator|->
name|length
operator|=
literal|0
block|;     }
specifier|inline
operator|~
name|Data
argument_list|()
block|{
if|if
condition|(
name|ownsData
condition|)
name|free
argument_list|(
name|rawData
argument_list|)
expr_stmt|;
block|}
name|uint
name|offsetOf
argument_list|(
specifier|const
name|void
operator|*
name|ptr
argument_list|)
decl|const
block|{
return|return
call|(
name|uint
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|-
name|rawData
operator|)
argument_list|)
return|;
block|}
name|QJsonObject
name|toObject
argument_list|(
name|Object
operator|*
name|o
argument_list|)
decl|const
block|{
return|return
name|QJsonObject
argument_list|(
name|const_cast
operator|<
name|Data
operator|*
operator|>
operator|(
name|this
operator|)
argument_list|,
name|o
argument_list|)
return|;
block|}
name|QJsonArray
name|toArray
argument_list|(
name|Array
operator|*
name|a
argument_list|)
decl|const
block|{
return|return
name|QJsonArray
argument_list|(
name|const_cast
operator|<
name|Data
operator|*
operator|>
operator|(
name|this
operator|)
argument_list|,
name|a
argument_list|)
return|;
block|}
name|Data
modifier|*
name|clone
parameter_list|(
name|Base
modifier|*
name|b
parameter_list|,
name|int
name|reserve
init|=
literal|0
parameter_list|)
block|{
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
name|Header
argument_list|)
operator|+
name|b
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|header
operator|->
name|root
argument_list|()
operator|&&
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
operator|&&
name|alloc
operator|>=
name|size
operator|+
name|reserve
condition|)
return|return
name|this
return|;
if|if
condition|(
name|reserve
condition|)
block|{
if|if
condition|(
name|reserve
operator|<
literal|128
condition|)
name|reserve
operator|=
literal|128
expr_stmt|;
name|size
operator|=
name|qMax
argument_list|(
name|size
operator|+
name|reserve
argument_list|,
name|qMin
argument_list|(
name|size
operator|*
literal|2
argument_list|,
operator|(
name|int
operator|)
name|Value
operator|::
name|MaxSize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|Value
operator|::
name|MaxSize
condition|)
block|{
name|qWarning
argument_list|(
literal|"QJson: Document too large to store in data structure"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|char
modifier|*
name|raw
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|raw
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|raw
operator|+
sizeof|sizeof
argument_list|(
name|Header
argument_list|)
argument_list|,
name|b
argument_list|,
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
name|Header
modifier|*
name|h
init|=
operator|(
name|Header
operator|*
operator|)
name|raw
decl_stmt|;
name|h
operator|->
name|tag
operator|=
name|QJsonDocument
operator|::
name|BinaryFormatTag
expr_stmt|;
name|h
operator|->
name|version
operator|=
literal|1
expr_stmt|;
name|Data
modifier|*
name|d
init|=
name|new
name|Data
argument_list|(
name|raw
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|d
operator|->
name|compactionCounter
operator|=
operator|(
name|b
operator|==
name|header
operator|->
name|root
argument_list|()
operator|)
condition|?
name|compactionCounter
else|:
literal|0
expr_stmt|;
return|return
name|d
return|;
block|}
name|void
name|compact
parameter_list|()
function_decl|;
name|bool
name|valid
argument_list|()
specifier|const
expr_stmt|;
name|private
label|:
name|Q_DISABLE_COPY
argument_list|(
argument|Data
argument_list|)
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_endif
unit|}  QT_END_NAMESPACE
endif|#
directive|endif
end_endif
begin_comment
comment|// QJSON_P_H
end_comment
end_unit
