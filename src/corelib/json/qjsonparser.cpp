begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|"qjsonparser_p.h"
end_include
begin_include
include|#
directive|include
file|"qjson_p.h"
end_include
begin_comment
comment|//#define PARSER_DEBUG
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|PARSER_DEBUG
end_ifdef
begin_decl_stmt
DECL|variable|indent
specifier|static
name|int
name|indent
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|BEGIN
define|#
directive|define
name|BEGIN
value|qDebug()<< QByteArray(4*indent++, ' ').constData()<< "pos="<< current
end_define
begin_define
DECL|macro|END
define|#
directive|define
name|END
value|--indent
end_define
begin_define
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|qDebug()<< QByteArray(4*indent, ' ').constData()
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|BEGIN
define|#
directive|define
name|BEGIN
value|if (1) ; else qDebug()
end_define
begin_define
DECL|macro|END
define|#
directive|define
name|END
value|do {} while (0)
end_define
begin_define
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|if (1) ; else qDebug()
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|nestingLimit
specifier|static
specifier|const
name|int
name|nestingLimit
init|=
literal|1024
decl_stmt|;
end_decl_stmt
begin_function
name|QT_BEGIN_NAMESPACE
comment|// error strings for the JSON parser
DECL|macro|JSONERR_OK
define|#
directive|define
name|JSONERR_OK
value|QT_TRANSLATE_NOOP("QJsonParseError", "no error occurred")
DECL|macro|JSONERR_UNTERM_OBJ
define|#
directive|define
name|JSONERR_UNTERM_OBJ
value|QT_TRANSLATE_NOOP("QJsonParseError", "unterminated object")
DECL|macro|JSONERR_MISS_NSEP
define|#
directive|define
name|JSONERR_MISS_NSEP
value|QT_TRANSLATE_NOOP("QJsonParseError", "missing name separator")
DECL|macro|JSONERR_UNTERM_AR
define|#
directive|define
name|JSONERR_UNTERM_AR
value|QT_TRANSLATE_NOOP("QJsonParseError", "unterminated array")
DECL|macro|JSONERR_MISS_VSEP
define|#
directive|define
name|JSONERR_MISS_VSEP
value|QT_TRANSLATE_NOOP("QJsonParseError", "missing value separator")
DECL|macro|JSONERR_ILLEGAL_VAL
define|#
directive|define
name|JSONERR_ILLEGAL_VAL
value|QT_TRANSLATE_NOOP("QJsonParseError", "illegal value")
DECL|macro|JSONERR_END_OF_NUM
define|#
directive|define
name|JSONERR_END_OF_NUM
value|QT_TRANSLATE_NOOP("QJsonParseError", "invalid termination by number")
DECL|macro|JSONERR_ILLEGAL_NUM
define|#
directive|define
name|JSONERR_ILLEGAL_NUM
value|QT_TRANSLATE_NOOP("QJsonParseError", "illegal number")
DECL|macro|JSONERR_STR_ESC_SEQ
define|#
directive|define
name|JSONERR_STR_ESC_SEQ
value|QT_TRANSLATE_NOOP("QJsonParseError", "invalid escape sequence")
DECL|macro|JSONERR_STR_UTF8
define|#
directive|define
name|JSONERR_STR_UTF8
value|QT_TRANSLATE_NOOP("QJsonParseError", "invalid UTF8 string")
DECL|macro|JSONERR_UTERM_STR
define|#
directive|define
name|JSONERR_UTERM_STR
value|QT_TRANSLATE_NOOP("QJsonParseError", "unterminated string")
DECL|macro|JSONERR_MISS_OBJ
define|#
directive|define
name|JSONERR_MISS_OBJ
value|QT_TRANSLATE_NOOP("QJsonParseError", "object is missing after a comma")
DECL|macro|JSONERR_DEEP_NEST
define|#
directive|define
name|JSONERR_DEEP_NEST
value|QT_TRANSLATE_NOOP("QJsonParseError", "too deeply nested document")
DECL|macro|JSONERR_DOC_LARGE
define|#
directive|define
name|JSONERR_DOC_LARGE
value|QT_TRANSLATE_NOOP("QJsonParseError", "too large document")
comment|/*!     \class QJsonParseError     \inmodule QtCore     \ingroup json     \reentrant     \since 5.0      \brief The QJsonParseError class is used to report errors during JSON parsing. */
comment|/*!     \enum QJsonParseError::ParseError      This enum describes the type of error that occurred during the parsing of a JSON document.      \value NoError                  No error occurred     \value UnterminatedObject       An object is not correctly terminated with a closing curly bracket     \value MissingNameSeparator     A comma separating different items is missing     \value UnterminatedArray        The array is not correctly terminated with a closing square bracket     \value MissingValueSeparator    A colon separating keys from values inside objects is missing     \value IllegalValue             The value is illegal     \value TerminationByNumber      The input stream ended while parsing a number     \value IllegalNumber            The number is not well formed     \value IllegalEscapeSequence    An illegal escape sequence occurred in the input     \value IllegalUTF8String        An illegal UTF8 sequence occurred in the input     \value UnterminatedString       A string wasn't terminated with a quote     \value MissingObject            An object was expected but couldn't be found     \value DeepNesting              The JSON document is too deeply nested for the parser to parse it     \value DocumentTooLarge         The JSON document is too large for the parser to parse it */
comment|/*!     \variable QJsonParseError::error      Contains the type of the parse error. Is equal to QJsonParseError::NoError if the document     was parsed correctly.      \sa ParseError, errorString() */
comment|/*!     \variable QJsonParseError::offset      Contains the offset in the input string where the parse error occurred.      \sa error, errorString() */
comment|/*!   Returns the human-readable message appropriate to the reported JSON parsing error.    \sa error  */
DECL|function|errorString
name|QString
name|QJsonParseError
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
specifier|const
name|char
modifier|*
name|sz
init|=
literal|""
decl_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|NoError
case|:
name|sz
operator|=
name|JSONERR_OK
expr_stmt|;
break|break;
case|case
name|UnterminatedObject
case|:
name|sz
operator|=
name|JSONERR_UNTERM_OBJ
expr_stmt|;
break|break;
case|case
name|MissingNameSeparator
case|:
name|sz
operator|=
name|JSONERR_MISS_NSEP
expr_stmt|;
break|break;
case|case
name|UnterminatedArray
case|:
name|sz
operator|=
name|JSONERR_UNTERM_AR
expr_stmt|;
break|break;
case|case
name|MissingValueSeparator
case|:
name|sz
operator|=
name|JSONERR_MISS_VSEP
expr_stmt|;
break|break;
case|case
name|IllegalValue
case|:
name|sz
operator|=
name|JSONERR_ILLEGAL_VAL
expr_stmt|;
break|break;
case|case
name|TerminationByNumber
case|:
name|sz
operator|=
name|JSONERR_END_OF_NUM
expr_stmt|;
break|break;
case|case
name|IllegalNumber
case|:
name|sz
operator|=
name|JSONERR_ILLEGAL_NUM
expr_stmt|;
break|break;
case|case
name|IllegalEscapeSequence
case|:
name|sz
operator|=
name|JSONERR_STR_ESC_SEQ
expr_stmt|;
break|break;
case|case
name|IllegalUTF8String
case|:
name|sz
operator|=
name|JSONERR_STR_UTF8
expr_stmt|;
break|break;
case|case
name|UnterminatedString
case|:
name|sz
operator|=
name|JSONERR_UTERM_STR
expr_stmt|;
break|break;
case|case
name|MissingObject
case|:
name|sz
operator|=
name|JSONERR_MISS_OBJ
expr_stmt|;
break|break;
case|case
name|DeepNesting
case|:
name|sz
operator|=
name|JSONERR_DEEP_NEST
expr_stmt|;
break|break;
case|case
name|DocumentTooLarge
case|:
name|sz
operator|=
name|JSONERR_DOC_LARGE
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
return|return
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QJsonParseError"
argument_list|,
name|sz
argument_list|)
return|;
else|#
directive|else
return|return
name|QLatin1String
argument_list|(
name|sz
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_using
using|using
namespace|namespace
name|QJsonPrivate
namespace|;
end_using
begin_constructor
DECL|function|Parser
name|Parser
operator|::
name|Parser
parameter_list|(
specifier|const
name|char
modifier|*
name|json
parameter_list|,
name|int
name|length
parameter_list|)
member_init_list|:
name|head
argument_list|(
name|json
argument_list|)
member_init_list|,
name|json
argument_list|(
name|json
argument_list|)
member_init_list|,
name|data
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|dataLength
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|current
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|nestingLevel
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lastError
argument_list|(
name|QJsonParseError
operator|::
name|NoError
argument_list|)
block|{
name|end
operator|=
name|json
operator|+
name|length
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*  begin-array     = ws %x5B ws  ; [ left square bracket  begin-object    = ws %x7B ws  ; { left curly bracket  end-array       = ws %x5D ws  ; ] right square bracket  end-object      = ws %x7D ws  ; } right curly bracket  name-separator  = ws %x3A ws  ; : colon  value-separator = ws %x2C ws  ; , comma  Insignificant whitespace is allowed before or after any of the six structural characters.  ws = *(           %x20 /              ; Space           %x09 /              ; Horizontal tab           %x0A /              ; Line feed or New line           %x0D                ; Carriage return       )  */
end_comment
begin_enum
enum|enum
block|{
DECL|enumerator|Space
name|Space
init|=
literal|0x20
block|,
DECL|enumerator|Tab
name|Tab
init|=
literal|0x09
block|,
DECL|enumerator|LineFeed
name|LineFeed
init|=
literal|0x0a
block|,
DECL|enumerator|Return
name|Return
init|=
literal|0x0d
block|,
DECL|enumerator|BeginArray
name|BeginArray
init|=
literal|0x5b
block|,
DECL|enumerator|BeginObject
name|BeginObject
init|=
literal|0x7b
block|,
DECL|enumerator|EndArray
name|EndArray
init|=
literal|0x5d
block|,
DECL|enumerator|EndObject
name|EndObject
init|=
literal|0x7d
block|,
DECL|enumerator|NameSeparator
name|NameSeparator
init|=
literal|0x3a
block|,
DECL|enumerator|ValueSeparator
name|ValueSeparator
init|=
literal|0x2c
block|,
DECL|enumerator|Quote
name|Quote
init|=
literal|0x22
block|}
enum|;
end_enum
begin_function
DECL|function|eatBOM
name|void
name|Parser
operator|::
name|eatBOM
parameter_list|()
block|{
comment|// eat UTF-8 byte order mark
name|uchar
name|utf8bom
index|[
literal|3
index|]
init|=
block|{
literal|0xef
block|,
literal|0xbb
block|,
literal|0xbf
block|}
decl_stmt|;
if|if
condition|(
name|end
operator|-
name|json
operator|>
literal|3
operator|&&
operator|(
name|uchar
operator|)
name|json
index|[
literal|0
index|]
operator|==
name|utf8bom
index|[
literal|0
index|]
operator|&&
operator|(
name|uchar
operator|)
name|json
index|[
literal|1
index|]
operator|==
name|utf8bom
index|[
literal|1
index|]
operator|&&
operator|(
name|uchar
operator|)
name|json
index|[
literal|2
index|]
operator|==
name|utf8bom
index|[
literal|2
index|]
condition|)
name|json
operator|+=
literal|3
expr_stmt|;
block|}
end_function
begin_function
DECL|function|eatSpace
name|bool
name|Parser
operator|::
name|eatSpace
parameter_list|()
block|{
while|while
condition|(
name|json
operator|<
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|json
operator|>
name|Space
condition|)
break|break;
if|if
condition|(
operator|*
name|json
operator|!=
name|Space
operator|&&
operator|*
name|json
operator|!=
name|Tab
operator|&&
operator|*
name|json
operator|!=
name|LineFeed
operator|&&
operator|*
name|json
operator|!=
name|Return
condition|)
break|break;
operator|++
name|json
expr_stmt|;
block|}
return|return
operator|(
name|json
operator|<
name|end
operator|)
return|;
block|}
end_function
begin_function
DECL|function|nextToken
name|char
name|Parser
operator|::
name|nextToken
parameter_list|()
block|{
if|if
condition|(
operator|!
name|eatSpace
argument_list|()
condition|)
return|return
literal|0
return|;
name|char
name|token
init|=
operator|*
name|json
operator|++
decl_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|BeginArray
case|:
case|case
name|BeginObject
case|:
case|case
name|NameSeparator
case|:
case|case
name|ValueSeparator
case|:
case|case
name|EndArray
case|:
case|case
name|EndObject
case|:
name|eatSpace
argument_list|()
expr_stmt|;
case|case
name|Quote
case|:
break|break;
default|default:
name|token
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|token
return|;
block|}
end_function
begin_comment
comment|/*     JSON-text = object / array */
end_comment
begin_function
DECL|function|parse
name|QJsonDocument
name|Parser
operator|::
name|parse
parameter_list|(
name|QJsonParseError
modifier|*
name|error
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PARSER_DEBUG
name|indent
operator|=
literal|0
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|">>>>> parser begin"
expr_stmt|;
endif|#
directive|endif
comment|// allocate some space
name|dataLength
operator|=
name|qMax
argument_list|(
name|end
operator|-
name|json
argument_list|,
operator|(
name|ptrdiff_t
operator|)
literal|256
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|dataLength
argument_list|)
expr_stmt|;
comment|// fill in Header data
name|QJsonPrivate
operator|::
name|Header
modifier|*
name|h
init|=
operator|(
name|QJsonPrivate
operator|::
name|Header
operator|*
operator|)
name|data
decl_stmt|;
name|h
operator|->
name|tag
operator|=
name|QJsonDocument
operator|::
name|BinaryFormatTag
expr_stmt|;
name|h
operator|->
name|version
operator|=
literal|1u
expr_stmt|;
name|current
operator|=
sizeof|sizeof
argument_list|(
name|QJsonPrivate
operator|::
name|Header
argument_list|)
expr_stmt|;
name|eatBOM
argument_list|()
expr_stmt|;
name|char
name|token
init|=
name|nextToken
argument_list|()
decl_stmt|;
name|DEBUG
operator|<<
name|hex
operator|<<
operator|(
name|uint
operator|)
name|token
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|BeginArray
condition|)
block|{
if|if
condition|(
operator|!
name|parseArray
argument_list|()
condition|)
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|BeginObject
condition|)
block|{
if|if
condition|(
operator|!
name|parseObject
argument_list|()
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|IllegalValue
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|END
expr_stmt|;
block|{
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|error
operator|->
name|error
operator|=
name|QJsonParseError
operator|::
name|NoError
expr_stmt|;
block|}
name|QJsonPrivate
operator|::
name|Data
modifier|*
name|d
init|=
operator|new
name|QJsonPrivate
operator|::
name|Data
argument_list|(
name|data
argument_list|,
name|current
argument_list|)
decl_stmt|;
return|return
name|QJsonDocument
argument_list|(
name|d
argument_list|)
return|;
block|}
name|error
label|:
ifdef|#
directive|ifdef
name|PARSER_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|">>>>> parser error"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|->
name|offset
operator|=
name|json
operator|-
name|head
expr_stmt|;
name|error
operator|->
name|error
operator|=
name|lastError
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|QJsonDocument
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|insert
name|void
name|Parser
operator|::
name|ParsedObject
operator|::
name|insert
parameter_list|(
name|uint
name|offset
parameter_list|)
block|{
specifier|const
name|QJsonPrivate
operator|::
name|Entry
modifier|*
name|newEntry
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|QJsonPrivate
operator|::
name|Entry
operator|*
argument_list|>
argument_list|(
name|parser
operator|->
name|data
operator|+
name|objectPosition
operator|+
name|offset
argument_list|)
decl_stmt|;
name|int
name|min
init|=
literal|0
decl_stmt|;
name|int
name|n
init|=
name|offsets
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|int
name|half
init|=
name|n
operator|>>
literal|1
decl_stmt|;
name|int
name|middle
init|=
name|min
operator|+
name|half
decl_stmt|;
if|if
condition|(
operator|*
name|entryAt
argument_list|(
name|middle
argument_list|)
operator|>=
operator|*
name|newEntry
condition|)
block|{
name|n
operator|=
name|half
expr_stmt|;
block|}
else|else
block|{
name|min
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
name|n
operator|-=
name|half
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min
operator|<
name|offsets
operator|.
name|size
argument_list|()
operator|&&
operator|*
name|entryAt
argument_list|(
name|min
argument_list|)
operator|==
operator|*
name|newEntry
condition|)
block|{
name|offsets
index|[
name|min
index|]
operator|=
name|offset
expr_stmt|;
block|}
else|else
block|{
name|offsets
operator|.
name|insert
argument_list|(
name|min
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*     object = begin-object [ member *( value-separator member ) ]     end-object */
end_comment
begin_function
DECL|function|parseObject
name|bool
name|Parser
operator|::
name|parseObject
parameter_list|()
block|{
if|if
condition|(
operator|++
name|nestingLevel
operator|>
name|nestingLimit
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|DeepNesting
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|objectOffset
init|=
name|reserveSpace
argument_list|(
sizeof|sizeof
argument_list|(
name|QJsonPrivate
operator|::
name|Object
argument_list|)
argument_list|)
decl_stmt|;
name|BEGIN
operator|<<
literal|"parseObject pos="
operator|<<
name|objectOffset
operator|<<
name|current
operator|<<
name|json
expr_stmt|;
name|ParsedObject
name|parsedObject
argument_list|(
name|this
argument_list|,
name|objectOffset
argument_list|)
decl_stmt|;
name|char
name|token
init|=
name|nextToken
argument_list|()
decl_stmt|;
while|while
condition|(
name|token
operator|==
name|Quote
condition|)
block|{
name|int
name|off
init|=
name|current
operator|-
name|objectOffset
decl_stmt|;
if|if
condition|(
operator|!
name|parseMember
argument_list|(
name|objectOffset
argument_list|)
condition|)
return|return
literal|false
return|;
name|parsedObject
operator|.
name|insert
argument_list|(
name|off
argument_list|)
expr_stmt|;
name|token
operator|=
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|ValueSeparator
condition|)
break|break;
name|token
operator|=
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|EndObject
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|MissingObject
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|DEBUG
operator|<<
literal|"end token="
operator|<<
name|token
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|EndObject
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|UnterminatedObject
expr_stmt|;
return|return
literal|false
return|;
block|}
name|DEBUG
operator|<<
literal|"numEntries"
operator|<<
name|parsedObject
operator|.
name|offsets
operator|.
name|size
argument_list|()
expr_stmt|;
name|int
name|table
init|=
name|objectOffset
decl_stmt|;
comment|// finalize the object
if|if
condition|(
name|parsedObject
operator|.
name|offsets
operator|.
name|size
argument_list|()
condition|)
block|{
name|int
name|tableSize
init|=
name|parsedObject
operator|.
name|offsets
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
decl_stmt|;
name|table
operator|=
name|reserveSpace
argument_list|(
name|tableSize
argument_list|)
expr_stmt|;
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_LITTLE_ENDIAN
name|memcpy
argument_list|(
name|data
operator|+
name|table
argument_list|,
name|parsedObject
operator|.
name|offsets
operator|.
name|constData
argument_list|()
argument_list|,
name|tableSize
argument_list|)
expr_stmt|;
else|#
directive|else
name|offset
modifier|*
name|o
init|=
operator|(
name|offset
operator|*
operator|)
operator|(
name|data
operator|+
name|table
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parsedObject
operator|.
name|offsets
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|o
index|[
name|i
index|]
operator|=
name|parsedObject
operator|.
name|offsets
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
block|}
name|QJsonPrivate
operator|::
name|Object
modifier|*
name|o
init|=
operator|(
name|QJsonPrivate
operator|::
name|Object
operator|*
operator|)
operator|(
name|data
operator|+
name|objectOffset
operator|)
decl_stmt|;
name|o
operator|->
name|tableOffset
operator|=
name|table
operator|-
name|objectOffset
expr_stmt|;
name|o
operator|->
name|size
operator|=
name|current
operator|-
name|objectOffset
expr_stmt|;
name|o
operator|->
name|is_object
operator|=
literal|true
expr_stmt|;
name|o
operator|->
name|length
operator|=
name|parsedObject
operator|.
name|offsets
operator|.
name|size
argument_list|()
expr_stmt|;
name|DEBUG
operator|<<
literal|"current="
operator|<<
name|current
expr_stmt|;
name|END
expr_stmt|;
operator|--
name|nestingLevel
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*     member = string name-separator value */
end_comment
begin_function
DECL|function|parseMember
name|bool
name|Parser
operator|::
name|parseMember
parameter_list|(
name|int
name|baseOffset
parameter_list|)
block|{
name|int
name|entryOffset
init|=
name|reserveSpace
argument_list|(
sizeof|sizeof
argument_list|(
name|QJsonPrivate
operator|::
name|Entry
argument_list|)
argument_list|)
decl_stmt|;
name|BEGIN
operator|<<
literal|"parseMember pos="
operator|<<
name|entryOffset
expr_stmt|;
name|bool
name|latin1
decl_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|(
operator|&
name|latin1
argument_list|)
condition|)
return|return
literal|false
return|;
name|char
name|token
init|=
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|!=
name|NameSeparator
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|MissingNameSeparator
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QJsonPrivate
operator|::
name|Value
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|parseValue
argument_list|(
operator|&
name|val
argument_list|,
name|baseOffset
argument_list|)
condition|)
return|return
literal|false
return|;
comment|// finalize the entry
name|QJsonPrivate
operator|::
name|Entry
modifier|*
name|e
init|=
operator|(
name|QJsonPrivate
operator|::
name|Entry
operator|*
operator|)
operator|(
name|data
operator|+
name|entryOffset
operator|)
decl_stmt|;
name|e
operator|->
name|value
operator|=
name|val
expr_stmt|;
name|e
operator|->
name|value
operator|.
name|latinKey
operator|=
name|latin1
expr_stmt|;
name|END
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*     array = begin-array [ value *( value-separator value ) ] end-array */
end_comment
begin_function
DECL|function|parseArray
name|bool
name|Parser
operator|::
name|parseArray
parameter_list|()
block|{
name|BEGIN
operator|<<
literal|"parseArray"
expr_stmt|;
if|if
condition|(
operator|++
name|nestingLevel
operator|>
name|nestingLimit
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|DeepNesting
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|arrayOffset
init|=
name|reserveSpace
argument_list|(
sizeof|sizeof
argument_list|(
name|QJsonPrivate
operator|::
name|Array
argument_list|)
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|QJsonPrivate
operator|::
name|Value
argument_list|,
literal|64
argument_list|>
name|values
decl_stmt|;
if|if
condition|(
operator|!
name|eatSpace
argument_list|()
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|UnterminatedArray
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|*
name|json
operator|==
name|EndArray
condition|)
block|{
name|nextToken
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|QJsonPrivate
operator|::
name|Value
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|parseValue
argument_list|(
operator|&
name|val
argument_list|,
name|arrayOffset
argument_list|)
condition|)
return|return
literal|false
return|;
name|values
operator|.
name|append
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|char
name|token
init|=
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|EndArray
condition|)
break|break;
elseif|else
if|if
condition|(
name|token
operator|!=
name|ValueSeparator
condition|)
block|{
if|if
condition|(
operator|!
name|eatSpace
argument_list|()
condition|)
name|lastError
operator|=
name|QJsonParseError
operator|::
name|UnterminatedArray
expr_stmt|;
else|else
name|lastError
operator|=
name|QJsonParseError
operator|::
name|MissingValueSeparator
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|DEBUG
operator|<<
literal|"size ="
operator|<<
name|values
operator|.
name|size
argument_list|()
expr_stmt|;
name|int
name|table
init|=
name|arrayOffset
decl_stmt|;
comment|// finalize the object
if|if
condition|(
name|values
operator|.
name|size
argument_list|()
condition|)
block|{
name|int
name|tableSize
init|=
name|values
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QJsonPrivate
operator|::
name|Value
argument_list|)
decl_stmt|;
name|table
operator|=
name|reserveSpace
argument_list|(
name|tableSize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
name|table
argument_list|,
name|values
operator|.
name|constData
argument_list|()
argument_list|,
name|tableSize
argument_list|)
expr_stmt|;
block|}
name|QJsonPrivate
operator|::
name|Array
modifier|*
name|a
init|=
operator|(
name|QJsonPrivate
operator|::
name|Array
operator|*
operator|)
operator|(
name|data
operator|+
name|arrayOffset
operator|)
decl_stmt|;
name|a
operator|->
name|tableOffset
operator|=
name|table
operator|-
name|arrayOffset
expr_stmt|;
name|a
operator|->
name|size
operator|=
name|current
operator|-
name|arrayOffset
expr_stmt|;
name|a
operator|->
name|is_object
operator|=
literal|false
expr_stmt|;
name|a
operator|->
name|length
operator|=
name|values
operator|.
name|size
argument_list|()
expr_stmt|;
name|DEBUG
operator|<<
literal|"current="
operator|<<
name|current
expr_stmt|;
name|END
expr_stmt|;
operator|--
name|nestingLevel
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/* value = false / null / true / object / array / number / string  */
end_comment
begin_function
DECL|function|parseValue
name|bool
name|Parser
operator|::
name|parseValue
parameter_list|(
name|QJsonPrivate
operator|::
name|Value
modifier|*
name|val
parameter_list|,
name|int
name|baseOffset
parameter_list|)
block|{
name|BEGIN
operator|<<
literal|"parse Value"
operator|<<
name|json
expr_stmt|;
name|val
operator|->
name|_dummy
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|json
operator|++
condition|)
block|{
case|case
literal|'n'
case|:
if|if
condition|(
name|end
operator|-
name|json
operator|<
literal|4
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|IllegalValue
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|*
name|json
operator|++
operator|==
literal|'u'
operator|&&
operator|*
name|json
operator|++
operator|==
literal|'l'
operator|&&
operator|*
name|json
operator|++
operator|==
literal|'l'
condition|)
block|{
name|val
operator|->
name|type
operator|=
name|QJsonValue
operator|::
name|Null
expr_stmt|;
name|DEBUG
operator|<<
literal|"value: null"
expr_stmt|;
name|END
expr_stmt|;
return|return
literal|true
return|;
block|}
name|lastError
operator|=
name|QJsonParseError
operator|::
name|IllegalValue
expr_stmt|;
return|return
literal|false
return|;
case|case
literal|'t'
case|:
if|if
condition|(
name|end
operator|-
name|json
operator|<
literal|4
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|IllegalValue
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|*
name|json
operator|++
operator|==
literal|'r'
operator|&&
operator|*
name|json
operator|++
operator|==
literal|'u'
operator|&&
operator|*
name|json
operator|++
operator|==
literal|'e'
condition|)
block|{
name|val
operator|->
name|type
operator|=
name|QJsonValue
operator|::
name|Bool
expr_stmt|;
name|val
operator|->
name|value
operator|=
literal|true
expr_stmt|;
name|DEBUG
operator|<<
literal|"value: true"
expr_stmt|;
name|END
expr_stmt|;
return|return
literal|true
return|;
block|}
name|lastError
operator|=
name|QJsonParseError
operator|::
name|IllegalValue
expr_stmt|;
return|return
literal|false
return|;
case|case
literal|'f'
case|:
if|if
condition|(
name|end
operator|-
name|json
operator|<
literal|5
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|IllegalValue
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|*
name|json
operator|++
operator|==
literal|'a'
operator|&&
operator|*
name|json
operator|++
operator|==
literal|'l'
operator|&&
operator|*
name|json
operator|++
operator|==
literal|'s'
operator|&&
operator|*
name|json
operator|++
operator|==
literal|'e'
condition|)
block|{
name|val
operator|->
name|type
operator|=
name|QJsonValue
operator|::
name|Bool
expr_stmt|;
name|val
operator|->
name|value
operator|=
literal|false
expr_stmt|;
name|DEBUG
operator|<<
literal|"value: false"
expr_stmt|;
name|END
expr_stmt|;
return|return
literal|true
return|;
block|}
name|lastError
operator|=
name|QJsonParseError
operator|::
name|IllegalValue
expr_stmt|;
return|return
literal|false
return|;
case|case
name|Quote
case|:
block|{
name|val
operator|->
name|type
operator|=
name|QJsonValue
operator|::
name|String
expr_stmt|;
if|if
condition|(
name|current
operator|-
name|baseOffset
operator|>=
name|Value
operator|::
name|MaxSize
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|DocumentTooLarge
expr_stmt|;
return|return
literal|false
return|;
block|}
name|val
operator|->
name|value
operator|=
name|current
operator|-
name|baseOffset
expr_stmt|;
name|bool
name|latin1
decl_stmt|;
if|if
condition|(
operator|!
name|parseString
argument_list|(
operator|&
name|latin1
argument_list|)
condition|)
return|return
literal|false
return|;
name|val
operator|->
name|latinOrIntValue
operator|=
name|latin1
expr_stmt|;
name|DEBUG
operator|<<
literal|"value: string"
expr_stmt|;
name|END
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|BeginArray
case|:
name|val
operator|->
name|type
operator|=
name|QJsonValue
operator|::
name|Array
expr_stmt|;
if|if
condition|(
name|current
operator|-
name|baseOffset
operator|>=
name|Value
operator|::
name|MaxSize
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|DocumentTooLarge
expr_stmt|;
return|return
literal|false
return|;
block|}
name|val
operator|->
name|value
operator|=
name|current
operator|-
name|baseOffset
expr_stmt|;
if|if
condition|(
operator|!
name|parseArray
argument_list|()
condition|)
return|return
literal|false
return|;
name|DEBUG
operator|<<
literal|"value: array"
expr_stmt|;
name|END
expr_stmt|;
return|return
literal|true
return|;
case|case
name|BeginObject
case|:
name|val
operator|->
name|type
operator|=
name|QJsonValue
operator|::
name|Object
expr_stmt|;
if|if
condition|(
name|current
operator|-
name|baseOffset
operator|>=
name|Value
operator|::
name|MaxSize
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|DocumentTooLarge
expr_stmt|;
return|return
literal|false
return|;
block|}
name|val
operator|->
name|value
operator|=
name|current
operator|-
name|baseOffset
expr_stmt|;
if|if
condition|(
operator|!
name|parseObject
argument_list|()
condition|)
return|return
literal|false
return|;
name|DEBUG
operator|<<
literal|"value: object"
expr_stmt|;
name|END
expr_stmt|;
return|return
literal|true
return|;
case|case
name|EndArray
case|:
name|lastError
operator|=
name|QJsonParseError
operator|::
name|MissingObject
expr_stmt|;
return|return
literal|false
return|;
default|default:
operator|--
name|json
expr_stmt|;
if|if
condition|(
operator|!
name|parseNumber
argument_list|(
name|val
argument_list|,
name|baseOffset
argument_list|)
condition|)
return|return
literal|false
return|;
name|DEBUG
operator|<<
literal|"value: number"
expr_stmt|;
name|END
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*         number = [ minus ] int [ frac ] [ exp ]         decimal-point = %x2E       ; .         digit1-9 = %x31-39         ; 1-9         e = %x65 / %x45            ; e E         exp = e [ minus / plus ] 1*DIGIT         frac = decimal-point 1*DIGIT         int = zero / ( digit1-9 *DIGIT )         minus = %x2D               ; -         plus = %x2B                ; +         zero = %x30                ; 0  */
end_comment
begin_function
DECL|function|parseNumber
name|bool
name|Parser
operator|::
name|parseNumber
parameter_list|(
name|QJsonPrivate
operator|::
name|Value
modifier|*
name|val
parameter_list|,
name|int
name|baseOffset
parameter_list|)
block|{
name|BEGIN
operator|<<
literal|"parseNumber"
operator|<<
name|json
expr_stmt|;
name|val
operator|->
name|type
operator|=
name|QJsonValue
operator|::
name|Double
expr_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|json
decl_stmt|;
name|bool
name|isInt
init|=
literal|true
decl_stmt|;
comment|// minus
if|if
condition|(
name|json
operator|<
name|end
operator|&&
operator|*
name|json
operator|==
literal|'-'
condition|)
operator|++
name|json
expr_stmt|;
comment|// int = zero / ( digit1-9 *DIGIT )
if|if
condition|(
name|json
operator|<
name|end
operator|&&
operator|*
name|json
operator|==
literal|'0'
condition|)
block|{
operator|++
name|json
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|json
operator|<
name|end
operator|&&
operator|*
name|json
operator|>=
literal|'0'
operator|&&
operator|*
name|json
operator|<=
literal|'9'
condition|)
operator|++
name|json
expr_stmt|;
block|}
comment|// frac = decimal-point 1*DIGIT
if|if
condition|(
name|json
operator|<
name|end
operator|&&
operator|*
name|json
operator|==
literal|'.'
condition|)
block|{
name|isInt
operator|=
literal|false
expr_stmt|;
operator|++
name|json
expr_stmt|;
while|while
condition|(
name|json
operator|<
name|end
operator|&&
operator|*
name|json
operator|>=
literal|'0'
operator|&&
operator|*
name|json
operator|<=
literal|'9'
condition|)
operator|++
name|json
expr_stmt|;
block|}
comment|// exp = e [ minus / plus ] 1*DIGIT
if|if
condition|(
name|json
operator|<
name|end
operator|&&
operator|(
operator|*
name|json
operator|==
literal|'e'
operator|||
operator|*
name|json
operator|==
literal|'E'
operator|)
condition|)
block|{
name|isInt
operator|=
literal|false
expr_stmt|;
operator|++
name|json
expr_stmt|;
if|if
condition|(
name|json
operator|<
name|end
operator|&&
operator|(
operator|*
name|json
operator|==
literal|'-'
operator|||
operator|*
name|json
operator|==
literal|'+'
operator|)
condition|)
operator|++
name|json
expr_stmt|;
while|while
condition|(
name|json
operator|<
name|end
operator|&&
operator|*
name|json
operator|>=
literal|'0'
operator|&&
operator|*
name|json
operator|<=
literal|'9'
condition|)
operator|++
name|json
expr_stmt|;
block|}
if|if
condition|(
name|json
operator|>=
name|end
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|TerminationByNumber
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QByteArray
name|number
argument_list|(
name|start
argument_list|,
name|json
operator|-
name|start
argument_list|)
decl_stmt|;
name|DEBUG
operator|<<
literal|"numberstring"
operator|<<
name|number
expr_stmt|;
if|if
condition|(
name|isInt
condition|)
block|{
name|bool
name|ok
decl_stmt|;
name|int
name|n
init|=
name|number
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
operator|&&
name|n
argument_list|<
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|&&
name|n
argument_list|>
operator|-
operator|(
literal|1
operator|<<
literal|25
operator|)
condition|)
block|{
name|val
operator|->
name|int_value
operator|=
name|n
expr_stmt|;
name|val
operator|->
name|latinOrIntValue
operator|=
literal|true
expr_stmt|;
name|END
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|bool
name|ok
decl_stmt|;
union|union
block|{
name|quint64
name|ui
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
union|;
name|d
operator|=
name|number
operator|.
name|toDouble
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|IllegalNumber
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|pos
init|=
name|reserveSpace
argument_list|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
decl_stmt|;
operator|*
operator|(
name|quint64
operator|*
operator|)
operator|(
name|data
operator|+
name|pos
operator|)
operator|=
name|qToLittleEndian
argument_list|(
name|ui
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|-
name|baseOffset
operator|>=
name|Value
operator|::
name|MaxSize
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|DocumentTooLarge
expr_stmt|;
return|return
literal|false
return|;
block|}
name|val
operator|->
name|value
operator|=
name|pos
operator|-
name|baseOffset
expr_stmt|;
name|val
operator|->
name|latinOrIntValue
operator|=
literal|false
expr_stmt|;
name|END
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*          string = quotation-mark *char quotation-mark          char = unescaped /                escape (                    %x22 /          ; "    quotation mark  U+0022                    %x5C /          ; \    reverse solidus U+005C                    %x2F /          ; /    solidus         U+002F                    %x62 /          ; b    backspace       U+0008                    %x66 /          ; f    form feed       U+000C                    %x6E /          ; n    line feed       U+000A                    %x72 /          ; r    carriage return U+000D                    %x74 /          ; t    tab             U+0009                    %x75 4HEXDIG )  ; uXXXX                U+XXXX          escape = %x5C              ; \          quotation-mark = %x22      ; "          unescaped = %x20-21 / %x23-5B / %x5D-10FFFF  */
end_comment
begin_function
DECL|function|addHexDigit
specifier|static
specifier|inline
name|bool
name|addHexDigit
parameter_list|(
name|char
name|digit
parameter_list|,
name|uint
modifier|*
name|result
parameter_list|)
block|{
operator|*
name|result
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|'0'
operator|&&
name|digit
operator|<=
literal|'9'
condition|)
operator|*
name|result
operator||=
operator|(
name|digit
operator|-
literal|'0'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|digit
operator|>=
literal|'a'
operator|&&
name|digit
operator|<=
literal|'f'
condition|)
operator|*
name|result
operator||=
operator|(
name|digit
operator|-
literal|'a'
operator|)
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|digit
operator|>=
literal|'A'
operator|&&
name|digit
operator|<=
literal|'F'
condition|)
operator|*
name|result
operator||=
operator|(
name|digit
operator|-
literal|'A'
operator|)
operator|+
literal|10
expr_stmt|;
else|else
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|scanEscapeSequence
specifier|static
specifier|inline
name|bool
name|scanEscapeSequence
parameter_list|(
specifier|const
name|char
modifier|*
modifier|&
name|json
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|uint
modifier|*
name|ch
parameter_list|)
block|{
operator|++
name|json
expr_stmt|;
if|if
condition|(
name|json
operator|>=
name|end
condition|)
return|return
literal|false
return|;
name|DEBUG
operator|<<
literal|"scan escape"
operator|<<
operator|(
name|char
operator|)
operator|*
name|json
expr_stmt|;
name|uint
name|escaped
init|=
operator|*
name|json
operator|++
decl_stmt|;
switch|switch
condition|(
name|escaped
condition|)
block|{
case|case
literal|'"'
case|:
operator|*
name|ch
operator|=
literal|'"'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
operator|*
name|ch
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
operator|*
name|ch
operator|=
literal|'/'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|ch
operator|=
literal|0x8
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|ch
operator|=
literal|0xc
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|ch
operator|=
literal|0xa
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|ch
operator|=
literal|0xd
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|ch
operator|=
literal|0x9
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
block|{
operator|*
name|ch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|json
operator|>
name|end
operator|-
literal|4
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|addHexDigit
argument_list|(
operator|*
name|json
argument_list|,
name|ch
argument_list|)
condition|)
return|return
literal|false
return|;
operator|++
name|json
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
default|default:
comment|// this is not as strict as one could be, but allows for more Json files
comment|// to be parsed correctly.
operator|*
name|ch
operator|=
name|escaped
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|scanUtf8Char
specifier|static
specifier|inline
name|bool
name|scanUtf8Char
parameter_list|(
specifier|const
name|char
modifier|*
modifier|&
name|json
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|uint
modifier|*
name|result
parameter_list|)
block|{
name|int
name|need
decl_stmt|;
name|uint
name|min_uc
decl_stmt|;
name|uint
name|uc
decl_stmt|;
name|uchar
name|ch
init|=
operator|*
name|json
operator|++
decl_stmt|;
if|if
condition|(
name|ch
operator|<
literal|128
condition|)
block|{
operator|*
name|result
operator|=
name|ch
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
block|{
name|uc
operator|=
name|ch
operator|&
literal|0x1f
expr_stmt|;
name|need
operator|=
literal|1
expr_stmt|;
name|min_uc
operator|=
literal|0x80
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
block|{
name|uc
operator|=
name|ch
operator|&
literal|0x0f
expr_stmt|;
name|need
operator|=
literal|2
expr_stmt|;
name|min_uc
operator|=
literal|0x800
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
block|{
name|uc
operator|=
name|ch
operator|&
literal|0x07
expr_stmt|;
name|need
operator|=
literal|3
expr_stmt|;
name|min_uc
operator|=
literal|0x10000
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|json
operator|>=
name|end
operator|-
name|need
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|need
condition|;
operator|++
name|i
control|)
block|{
name|ch
operator|=
operator|*
name|json
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
literal|false
return|;
name|uc
operator|=
operator|(
name|uc
operator|<<
literal|6
operator|)
operator||
operator|(
name|ch
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|uc
argument_list|<
name|min_uc
operator|||
name|QChar
operator|::
name|isNonCharacter
operator|(
name|uc
operator|)
operator|||
name|QChar
operator|::
name|isSurrogate
operator|(
name|uc
operator|)
operator|||
name|uc
argument_list|>
name|QChar
operator|::
name|LastValidCodePoint
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|result
operator|=
name|uc
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|parseString
name|bool
name|Parser
operator|::
name|parseString
parameter_list|(
name|bool
modifier|*
name|latin1
parameter_list|)
block|{
operator|*
name|latin1
operator|=
literal|true
expr_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|json
decl_stmt|;
name|int
name|outStart
init|=
name|current
decl_stmt|;
comment|// try to write out a latin1 string
name|int
name|stringPos
init|=
name|reserveSpace
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|BEGIN
operator|<<
literal|"parse string stringPos="
operator|<<
name|stringPos
operator|<<
name|json
expr_stmt|;
while|while
condition|(
name|json
operator|<
name|end
condition|)
block|{
name|uint
name|ch
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|json
operator|==
literal|'"'
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|json
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|!
name|scanEscapeSequence
argument_list|(
name|json
argument_list|,
name|end
argument_list|,
operator|&
name|ch
argument_list|)
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|IllegalEscapeSequence
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|scanUtf8Char
argument_list|(
name|json
argument_list|,
name|end
argument_list|,
operator|&
name|ch
argument_list|)
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|IllegalUTF8String
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|ch
operator|>
literal|0xff
condition|)
block|{
operator|*
name|latin1
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|int
name|pos
init|=
name|reserveSpace
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|DEBUG
operator|<<
literal|"  "
operator|<<
name|ch
operator|<<
operator|(
name|char
operator|)
name|ch
expr_stmt|;
name|data
index|[
name|pos
index|]
operator|=
operator|(
name|uchar
operator|)
name|ch
expr_stmt|;
block|}
operator|++
name|json
expr_stmt|;
name|DEBUG
operator|<<
literal|"end of string"
expr_stmt|;
if|if
condition|(
name|json
operator|>=
name|end
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|UnterminatedString
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// no unicode string, we are done
if|if
condition|(
operator|*
name|latin1
condition|)
block|{
comment|// write string length
operator|*
operator|(
name|QJsonPrivate
operator|::
name|qle_ushort
operator|*
operator|)
operator|(
name|data
operator|+
name|stringPos
operator|)
operator|=
name|ushort
argument_list|(
name|current
operator|-
name|outStart
operator|-
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
name|reserveSpace
argument_list|(
operator|(
literal|4
operator|-
name|current
operator|)
operator|&
literal|3
argument_list|)
decl_stmt|;
while|while
condition|(
name|pos
operator|&
literal|3
condition|)
name|data
index|[
name|pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|END
expr_stmt|;
return|return
literal|true
return|;
block|}
operator|*
name|latin1
operator|=
literal|false
expr_stmt|;
name|DEBUG
operator|<<
literal|"not latin"
expr_stmt|;
name|json
operator|=
name|start
expr_stmt|;
name|current
operator|=
name|outStart
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
while|while
condition|(
name|json
operator|<
name|end
condition|)
block|{
name|uint
name|ch
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|json
operator|==
literal|'"'
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|json
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|!
name|scanEscapeSequence
argument_list|(
name|json
argument_list|,
name|end
argument_list|,
operator|&
name|ch
argument_list|)
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|IllegalEscapeSequence
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|scanUtf8Char
argument_list|(
name|json
argument_list|,
name|end
argument_list|,
operator|&
name|ch
argument_list|)
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|IllegalUTF8String
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|int
name|pos
init|=
name|reserveSpace
argument_list|(
literal|4
argument_list|)
decl_stmt|;
operator|*
operator|(
name|QJsonPrivate
operator|::
name|qle_ushort
operator|*
operator|)
operator|(
name|data
operator|+
name|pos
operator|)
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|ch
argument_list|)
expr_stmt|;
operator|*
operator|(
name|QJsonPrivate
operator|::
name|qle_ushort
operator|*
operator|)
operator|(
name|data
operator|+
name|pos
operator|+
literal|2
operator|)
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|pos
init|=
name|reserveSpace
argument_list|(
literal|2
argument_list|)
decl_stmt|;
operator|*
operator|(
name|QJsonPrivate
operator|::
name|qle_ushort
operator|*
operator|)
operator|(
name|data
operator|+
name|pos
operator|)
operator|=
operator|(
name|ushort
operator|)
name|ch
expr_stmt|;
block|}
block|}
operator|++
name|json
expr_stmt|;
if|if
condition|(
name|json
operator|>=
name|end
condition|)
block|{
name|lastError
operator|=
name|QJsonParseError
operator|::
name|UnterminatedString
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// write string length
operator|*
operator|(
name|QJsonPrivate
operator|::
name|qle_int
operator|*
operator|)
operator|(
name|data
operator|+
name|stringPos
operator|)
operator|=
operator|(
name|current
operator|-
name|outStart
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|/
literal|2
expr_stmt|;
name|int
name|pos
init|=
name|reserveSpace
argument_list|(
operator|(
literal|4
operator|-
name|current
operator|)
operator|&
literal|3
argument_list|)
decl_stmt|;
while|while
condition|(
name|pos
operator|&
literal|3
condition|)
name|data
index|[
name|pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|END
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
