begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qmimeprovider_p.h"
end_include
begin_include
include|#
directive|include
file|"qmimetypeparser_p.h"
end_include
begin_include
include|#
directive|include
file|<qstandardpaths.h>
end_include
begin_include
include|#
directive|include
file|"qmimemagicrulematcher_p.h"
end_include
begin_include
include|#
directive|include
file|<QXmlStreamReader>
end_include
begin_include
include|#
directive|include
file|<QDir>
end_include
begin_include
include|#
directive|include
file|<QFile>
end_include
begin_include
include|#
directive|include
file|<QByteArrayMatcher>
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_include
include|#
directive|include
file|<QDateTime>
end_include
begin_include
include|#
directive|include
file|<QtEndian>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|fallbackParent
specifier|static
name|QString
name|fallbackParent
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeTypeName
parameter_list|)
block|{
specifier|const
name|QString
name|myGroup
init|=
name|mimeTypeName
operator|.
name|left
argument_list|(
name|mimeTypeName
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// All text/* types are subclasses of text/plain.
if|if
condition|(
name|myGroup
operator|==
name|QLatin1String
argument_list|(
literal|"text"
argument_list|)
operator|&&
name|mimeTypeName
operator|!=
name|QLatin1String
argument_list|(
literal|"text/plain"
argument_list|)
condition|)
return|return
name|QLatin1String
argument_list|(
literal|"text/plain"
argument_list|)
return|;
comment|// All real-file mimetypes implicitly derive from application/octet-stream
if|if
condition|(
name|myGroup
operator|!=
name|QLatin1String
argument_list|(
literal|"inode"
argument_list|)
operator|&&
comment|// ignore non-file extensions
name|myGroup
operator|!=
name|QLatin1String
argument_list|(
literal|"all"
argument_list|)
operator|&&
name|myGroup
operator|!=
name|QLatin1String
argument_list|(
literal|"fonts"
argument_list|)
operator|&&
name|myGroup
operator|!=
name|QLatin1String
argument_list|(
literal|"print"
argument_list|)
operator|&&
name|myGroup
operator|!=
name|QLatin1String
argument_list|(
literal|"uri"
argument_list|)
operator|&&
name|mimeTypeName
operator|!=
name|QLatin1String
argument_list|(
literal|"application/octet-stream"
argument_list|)
condition|)
block|{
return|return
name|QLatin1String
argument_list|(
literal|"application/octet-stream"
argument_list|)
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_constructor
DECL|function|QMimeProviderBase
name|QMimeProviderBase
operator|::
name|QMimeProviderBase
parameter_list|(
name|QMimeDatabasePrivate
modifier|*
name|db
parameter_list|)
member_init_list|:
name|m_db
argument_list|(
name|db
argument_list|)
block|{ }
end_constructor
begin_decl_stmt
DECL|variable|qmime_secondsBetweenChecks
name|Q_CORE_EXPORT
name|int
name|qmime_secondsBetweenChecks
init|=
literal|5
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|qmime_secondsBetweenChecks
comment|// exported for the unit test
end_comment
begin_function
DECL|function|shouldCheck
name|bool
name|QMimeProviderBase
operator|::
name|shouldCheck
parameter_list|()
block|{
specifier|const
name|QDateTime
name|now
init|=
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|m_lastCheck
operator|.
name|isValid
argument_list|()
operator|&&
name|m_lastCheck
operator|.
name|secsTo
argument_list|(
name|now
argument_list|)
operator|<
name|qmime_secondsBetweenChecks
condition|)
return|return
literal|false
return|;
name|m_lastCheck
operator|=
name|now
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_constructor
DECL|function|QMimeBinaryProvider
name|QMimeBinaryProvider
operator|::
name|QMimeBinaryProvider
parameter_list|(
name|QMimeDatabasePrivate
modifier|*
name|db
parameter_list|)
member_init_list|:
name|QMimeProviderBase
argument_list|(
name|db
argument_list|)
member_init_list|,
name|m_mimetypeListLoaded
argument_list|(
literal|false
argument_list|)
block|{ }
end_constructor
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_INTEGRITY
argument_list|)
end_if
begin_define
DECL|macro|QT_USE_MMAP
define|#
directive|define
name|QT_USE_MMAP
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_struct
DECL|struct|CacheFile
struct|struct
name|QMimeBinaryProvider
operator|::
name|CacheFile
block|{
name|CacheFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
constructor_decl|;
name|~
name|CacheFile
parameter_list|()
destructor_decl|;
DECL|function|isValid
name|bool
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|m_valid
return|;
block|}
DECL|function|getUint16
specifier|inline
name|quint16
name|getUint16
parameter_list|(
name|int
name|offset
parameter_list|)
specifier|const
block|{
return|return
name|qFromBigEndian
argument_list|(
operator|*
cast|reinterpret_cast
argument_list|<
name|quint16
operator|*
argument_list|>
argument_list|(
name|data
operator|+
name|offset
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getUint32
specifier|inline
name|quint32
name|getUint32
parameter_list|(
name|int
name|offset
parameter_list|)
specifier|const
block|{
return|return
name|qFromBigEndian
argument_list|(
operator|*
cast|reinterpret_cast
argument_list|<
name|quint32
operator|*
argument_list|>
argument_list|(
name|data
operator|+
name|offset
argument_list|)
argument_list|)
return|;
block|}
DECL|function|getCharStar
specifier|inline
specifier|const
name|char
modifier|*
name|getCharStar
parameter_list|(
name|int
name|offset
parameter_list|)
specifier|const
block|{
return|return
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|data
operator|+
name|offset
argument_list|)
return|;
block|}
name|bool
name|load
parameter_list|()
function_decl|;
name|bool
name|reload
parameter_list|()
function_decl|;
DECL|member|file
name|QFile
name|file
decl_stmt|;
DECL|member|data
name|uchar
modifier|*
name|data
decl_stmt|;
DECL|member|m_mtime
name|QDateTime
name|m_mtime
decl_stmt|;
DECL|member|m_valid
name|bool
name|m_valid
decl_stmt|;
block|}
struct|;
end_struct
begin_constructor
DECL|function|CacheFile
name|QMimeBinaryProvider
operator|::
name|CacheFile
operator|::
name|CacheFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
member_init_list|:
name|file
argument_list|(
name|fileName
argument_list|)
member_init_list|,
name|m_valid
argument_list|(
literal|false
argument_list|)
block|{
name|load
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~CacheFile
name|QMimeBinaryProvider
operator|::
name|CacheFile
operator|::
name|~
name|CacheFile
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|load
name|bool
name|QMimeBinaryProvider
operator|::
name|CacheFile
operator|::
name|load
parameter_list|()
block|{
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return
literal|false
return|;
name|data
operator|=
name|file
operator|.
name|map
argument_list|(
literal|0
argument_list|,
name|file
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
specifier|const
name|int
name|major
init|=
name|getUint16
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|int
name|minor
init|=
name|getUint16
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|m_valid
operator|=
operator|(
name|major
operator|==
literal|1
operator|&&
name|minor
operator|>=
literal|1
operator|&&
name|minor
operator|<=
literal|2
operator|)
expr_stmt|;
block|}
name|m_mtime
operator|=
name|QFileInfo
argument_list|(
name|file
argument_list|)
operator|.
name|lastModified
argument_list|()
expr_stmt|;
return|return
name|m_valid
return|;
block|}
end_function
begin_function
DECL|function|reload
name|bool
name|QMimeBinaryProvider
operator|::
name|CacheFile
operator|::
name|reload
parameter_list|()
block|{
comment|//qDebug()<< "reload!"<< file->fileName();
name|m_valid
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|isOpen
argument_list|()
condition|)
block|{
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|data
operator|=
literal|0
expr_stmt|;
return|return
name|load
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|findCacheFile
name|QMimeBinaryProvider
operator|::
name|CacheFile
modifier|*
name|QMimeBinaryProvider
operator|::
name|CacheFileList
operator|::
name|findCacheFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
specifier|const
block|{
for|for
control|(
name|const_iterator
name|it
init|=
name|begin
argument_list|()
init|;
name|it
operator|!=
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|->
name|file
operator|.
name|fileName
argument_list|()
operator|==
name|fileName
condition|)
return|return
operator|*
name|it
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_destructor
DECL|function|~QMimeBinaryProvider
name|QMimeBinaryProvider
operator|::
name|~
name|QMimeBinaryProvider
parameter_list|()
block|{
name|qDeleteAll
argument_list|(
name|m_cacheFiles
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|// Position of the "list offsets" values, at the beginning of the mime.cache file
end_comment
begin_enum
enum|enum
block|{
DECL|enumerator|PosAliasListOffset
name|PosAliasListOffset
init|=
literal|4
block|,
DECL|enumerator|PosParentListOffset
name|PosParentListOffset
init|=
literal|8
block|,
DECL|enumerator|PosLiteralListOffset
name|PosLiteralListOffset
init|=
literal|12
block|,
DECL|enumerator|PosReverseSuffixTreeOffset
name|PosReverseSuffixTreeOffset
init|=
literal|16
block|,
DECL|enumerator|PosGlobListOffset
name|PosGlobListOffset
init|=
literal|20
block|,
DECL|enumerator|PosMagicListOffset
name|PosMagicListOffset
init|=
literal|24
block|,
comment|// PosNamespaceListOffset = 28,
DECL|enumerator|PosIconsListOffset
name|PosIconsListOffset
init|=
literal|32
block|,
DECL|enumerator|PosGenericIconsListOffset
name|PosGenericIconsListOffset
init|=
literal|36
block|}
enum|;
end_enum
begin_function
DECL|function|isValid
name|bool
name|QMimeBinaryProvider
operator|::
name|isValid
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_MMAP
argument_list|)
if|if
condition|(
operator|!
name|qEnvironmentVariableIsEmpty
argument_list|(
literal|"QT_NO_MIME_CACHE"
argument_list|)
condition|)
return|return
literal|false
return|;
name|Q_ASSERT
argument_list|(
name|m_cacheFiles
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// this method is only ever called once
name|checkCache
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_cacheFiles
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|m_cacheFiles
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// We found exactly one file; is it the user-modified mimes, or a system file?
specifier|const
name|QString
name|foundFile
init|=
name|m_cacheFiles
operator|.
name|first
argument_list|()
operator|->
name|file
operator|.
name|fileName
argument_list|()
decl_stmt|;
specifier|const
name|QString
name|localCacheFile
init|=
name|QStandardPaths
operator|::
name|writableLocation
argument_list|(
name|QStandardPaths
operator|::
name|GenericDataLocation
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"/mime/mime.cache"
argument_list|)
decl_stmt|;
return|return
name|foundFile
operator|!=
name|localCacheFile
return|;
else|#
directive|else
return|return
literal|false
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|checkCacheChanged
name|bool
name|QMimeBinaryProvider
operator|::
name|CacheFileList
operator|::
name|checkCacheChanged
parameter_list|()
block|{
name|bool
name|somethingChanged
init|=
literal|false
decl_stmt|;
name|QMutableListIterator
argument_list|<
name|CacheFile
modifier|*
argument_list|>
name|it
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|CacheFile
modifier|*
name|cacheFile
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|QFileInfo
name|fileInfo
argument_list|(
name|cacheFile
operator|->
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fileInfo
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// This can't happen by just running update-mime-database. But the user could use rm -rf :-)
operator|delete
name|cacheFile
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|somethingChanged
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fileInfo
operator|.
name|lastModified
argument_list|()
operator|>
name|cacheFile
operator|->
name|m_mtime
condition|)
block|{
if|if
condition|(
operator|!
name|cacheFile
operator|->
name|reload
argument_list|()
condition|)
block|{
operator|delete
name|cacheFile
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|somethingChanged
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|somethingChanged
return|;
block|}
end_function
begin_function
DECL|function|checkCache
name|void
name|QMimeBinaryProvider
operator|::
name|checkCache
parameter_list|()
block|{
if|if
condition|(
operator|!
name|shouldCheck
argument_list|()
condition|)
return|return;
comment|// First iterate over existing known cache files and check for uptodate
if|if
condition|(
name|m_cacheFiles
operator|.
name|checkCacheChanged
argument_list|()
condition|)
name|m_mimetypeListLoaded
operator|=
literal|false
expr_stmt|;
comment|// Then check if new cache files appeared
specifier|const
name|QStringList
name|cacheFileNames
init|=
name|QStandardPaths
operator|::
name|locateAll
argument_list|(
name|QStandardPaths
operator|::
name|GenericDataLocation
argument_list|,
name|QLatin1String
argument_list|(
literal|"mime/mime.cache"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cacheFileNames
operator|!=
name|m_cacheFileNames
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|cacheFileName
decl|,
name|cacheFileNames
control|)
block|{
name|CacheFile
modifier|*
name|cacheFile
init|=
name|m_cacheFiles
operator|.
name|findCacheFile
argument_list|(
name|cacheFileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cacheFile
condition|)
block|{
comment|//qDebug()<< "new file:"<< cacheFileName;
name|cacheFile
operator|=
operator|new
name|CacheFile
argument_list|(
name|cacheFileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|cacheFile
operator|->
name|isValid
argument_list|()
condition|)
comment|// verify version
name|m_cacheFiles
operator|.
name|append
argument_list|(
name|cacheFile
argument_list|)
expr_stmt|;
else|else
operator|delete
name|cacheFile
expr_stmt|;
block|}
block|}
name|m_cacheFileNames
operator|=
name|cacheFileNames
expr_stmt|;
name|m_mimetypeListLoaded
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|mimeTypeForNameUnchecked
specifier|static
name|QMimeType
name|mimeTypeForNameUnchecked
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QMimeTypePrivate
name|data
decl_stmt|;
name|data
operator|.
name|name
operator|=
name|name
expr_stmt|;
comment|// The rest is retrieved on demand.
comment|// comment and globPatterns: in loadMimeTypePrivate
comment|// iconName: in loadIcon
comment|// genericIconName: in loadGenericIcon
return|return
name|QMimeType
argument_list|(
name|data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mimeTypeForName
name|QMimeType
name|QMimeBinaryProvider
operator|::
name|mimeTypeForName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|checkCache
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|m_mimetypeListLoaded
condition|)
name|loadMimeTypeList
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|m_mimetypeNames
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|QMimeType
argument_list|()
return|;
comment|// unknown mimetype
return|return
name|mimeTypeForNameUnchecked
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|findByFileName
name|QStringList
name|QMimeBinaryProvider
operator|::
name|findByFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QString
modifier|*
name|foundSuffix
parameter_list|)
block|{
name|checkCache
argument_list|()
expr_stmt|;
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QStringList
argument_list|()
return|;
specifier|const
name|QString
name|lowerFileName
init|=
name|fileName
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|QMimeGlobMatchResult
name|result
decl_stmt|;
comment|// TODO this parses in the order (local, global). Check that it handles "NOGLOBS" correctly.
foreach|foreach
control|(
name|CacheFile
modifier|*
name|cacheFile
decl|,
name|m_cacheFiles
control|)
block|{
name|matchGlobList
argument_list|(
name|result
argument_list|,
name|cacheFile
argument_list|,
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|PosLiteralListOffset
argument_list|)
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|matchGlobList
argument_list|(
name|result
argument_list|,
name|cacheFile
argument_list|,
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|PosGlobListOffset
argument_list|)
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
specifier|const
name|int
name|reverseSuffixTreeOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|PosReverseSuffixTreeOffset
argument_list|)
decl_stmt|;
specifier|const
name|int
name|numRoots
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|reverseSuffixTreeOffset
argument_list|)
decl_stmt|;
specifier|const
name|int
name|firstRootOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|reverseSuffixTreeOffset
operator|+
literal|4
argument_list|)
decl_stmt|;
name|matchSuffixTree
argument_list|(
name|result
argument_list|,
name|cacheFile
argument_list|,
name|numRoots
argument_list|,
name|firstRootOffset
argument_list|,
name|lowerFileName
argument_list|,
name|fileName
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|m_matchingMimeTypes
operator|.
name|isEmpty
argument_list|()
condition|)
name|matchSuffixTree
argument_list|(
name|result
argument_list|,
name|cacheFile
argument_list|,
name|numRoots
argument_list|,
name|firstRootOffset
argument_list|,
name|fileName
argument_list|,
name|fileName
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|foundSuffix
condition|)
operator|*
name|foundSuffix
operator|=
name|result
operator|.
name|m_foundSuffix
expr_stmt|;
return|return
name|result
operator|.
name|m_matchingMimeTypes
return|;
block|}
end_function
begin_function
DECL|function|matchGlobList
name|void
name|QMimeBinaryProvider
operator|::
name|matchGlobList
parameter_list|(
name|QMimeGlobMatchResult
modifier|&
name|result
parameter_list|,
name|CacheFile
modifier|*
name|cacheFile
parameter_list|,
name|int
name|off
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
specifier|const
name|int
name|numGlobs
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
argument_list|)
decl_stmt|;
comment|//qDebug()<< "Loading"<< numGlobs<< "globs from"<< cacheFile->file.fileName()<< "at offset"<< cacheFile->globListOffset;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numGlobs
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|globOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|4
operator|+
literal|12
operator|*
name|i
argument_list|)
decl_stmt|;
specifier|const
name|int
name|mimeTypeOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|4
operator|+
literal|12
operator|*
name|i
operator|+
literal|4
argument_list|)
decl_stmt|;
specifier|const
name|int
name|flagsAndWeight
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|4
operator|+
literal|12
operator|*
name|i
operator|+
literal|8
argument_list|)
decl_stmt|;
specifier|const
name|int
name|weight
init|=
name|flagsAndWeight
operator|&
literal|0xff
decl_stmt|;
specifier|const
name|bool
name|caseSensitive
init|=
name|flagsAndWeight
operator|&
literal|0x100
decl_stmt|;
specifier|const
name|Qt
operator|::
name|CaseSensitivity
name|qtCaseSensitive
init|=
name|caseSensitive
condition|?
name|Qt
operator|::
name|CaseSensitive
else|:
name|Qt
operator|::
name|CaseInsensitive
decl_stmt|;
specifier|const
name|QString
name|pattern
init|=
name|QLatin1String
argument_list|(
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|globOffset
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|mimeType
init|=
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|mimeTypeOffset
argument_list|)
decl_stmt|;
comment|//qDebug()<< pattern<< mimeType<< weight<< caseSensitive;
name|QMimeGlobPattern
name|glob
argument_list|(
name|pattern
argument_list|,
name|QString
argument_list|()
comment|/*unused*/
argument_list|,
name|weight
argument_list|,
name|qtCaseSensitive
argument_list|)
decl_stmt|;
comment|// TODO: this could be done faster for literals where a simple == would do.
if|if
condition|(
name|glob
operator|.
name|matchFileName
argument_list|(
name|fileName
argument_list|)
condition|)
name|result
operator|.
name|addMatch
argument_list|(
name|QLatin1String
argument_list|(
name|mimeType
argument_list|)
argument_list|,
name|weight
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|matchSuffixTree
name|bool
name|QMimeBinaryProvider
operator|::
name|matchSuffixTree
parameter_list|(
name|QMimeGlobMatchResult
modifier|&
name|result
parameter_list|,
name|QMimeBinaryProvider
operator|::
name|CacheFile
modifier|*
name|cacheFile
parameter_list|,
name|int
name|numEntries
parameter_list|,
name|int
name|firstOffset
parameter_list|,
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|int
name|charPos
parameter_list|,
name|bool
name|caseSensitiveCheck
parameter_list|)
block|{
name|QChar
name|fileChar
init|=
name|fileName
index|[
name|charPos
index|]
decl_stmt|;
name|int
name|min
init|=
literal|0
decl_stmt|;
name|int
name|max
init|=
name|numEntries
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|min
operator|<=
name|max
condition|)
block|{
specifier|const
name|int
name|mid
init|=
operator|(
name|min
operator|+
name|max
operator|)
operator|/
literal|2
decl_stmt|;
specifier|const
name|int
name|off
init|=
name|firstOffset
operator|+
literal|12
operator|*
name|mid
decl_stmt|;
specifier|const
name|QChar
name|ch
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|<
name|fileChar
condition|)
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>
name|fileChar
condition|)
name|max
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
else|else
block|{
operator|--
name|charPos
expr_stmt|;
name|int
name|numChildren
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|4
argument_list|)
decl_stmt|;
name|int
name|childrenOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|8
argument_list|)
decl_stmt|;
name|bool
name|success
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|charPos
operator|>
literal|0
condition|)
name|success
operator|=
name|matchSuffixTree
argument_list|(
name|result
argument_list|,
name|cacheFile
argument_list|,
name|numChildren
argument_list|,
name|childrenOffset
argument_list|,
name|fileName
argument_list|,
name|charPos
argument_list|,
name|caseSensitiveCheck
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numChildren
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|childOff
init|=
name|childrenOffset
operator|+
literal|12
operator|*
name|i
decl_stmt|;
specifier|const
name|int
name|mch
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|childOff
argument_list|)
decl_stmt|;
if|if
condition|(
name|mch
operator|!=
literal|0
condition|)
break|break;
specifier|const
name|int
name|mimeTypeOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|childOff
operator|+
literal|4
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|mimeType
init|=
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|mimeTypeOffset
argument_list|)
decl_stmt|;
specifier|const
name|int
name|flagsAndWeight
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|childOff
operator|+
literal|8
argument_list|)
decl_stmt|;
specifier|const
name|int
name|weight
init|=
name|flagsAndWeight
operator|&
literal|0xff
decl_stmt|;
specifier|const
name|bool
name|caseSensitive
init|=
name|flagsAndWeight
operator|&
literal|0x100
decl_stmt|;
if|if
condition|(
name|caseSensitiveCheck
operator|||
operator|!
name|caseSensitive
condition|)
block|{
name|result
operator|.
name|addMatch
argument_list|(
name|QLatin1String
argument_list|(
name|mimeType
argument_list|)
argument_list|,
name|weight
argument_list|,
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
operator|+
name|fileName
operator|.
name|mid
argument_list|(
name|charPos
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
return|return
name|success
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|matchMagicRule
name|bool
name|QMimeBinaryProvider
operator|::
name|matchMagicRule
parameter_list|(
name|QMimeBinaryProvider
operator|::
name|CacheFile
modifier|*
name|cacheFile
parameter_list|,
name|int
name|numMatchlets
parameter_list|,
name|int
name|firstOffset
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dataPtr
init|=
name|data
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|int
name|dataSize
init|=
name|data
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|matchlet
init|=
literal|0
init|;
name|matchlet
operator|<
name|numMatchlets
condition|;
operator|++
name|matchlet
control|)
block|{
specifier|const
name|int
name|off
init|=
name|firstOffset
operator|+
name|matchlet
operator|*
literal|32
decl_stmt|;
specifier|const
name|int
name|rangeStart
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
argument_list|)
decl_stmt|;
specifier|const
name|int
name|rangeLength
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|4
argument_list|)
decl_stmt|;
comment|//const int wordSize = cacheFile->getUint32(off + 8);
specifier|const
name|int
name|valueLength
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|12
argument_list|)
decl_stmt|;
specifier|const
name|int
name|valueOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|16
argument_list|)
decl_stmt|;
specifier|const
name|int
name|maskOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|20
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|mask
init|=
name|maskOffset
condition|?
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|maskOffset
argument_list|)
else|:
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|QMimeMagicRule
operator|::
name|matchSubstring
argument_list|(
name|dataPtr
argument_list|,
name|dataSize
argument_list|,
name|rangeStart
argument_list|,
name|rangeLength
argument_list|,
name|valueLength
argument_list|,
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|valueOffset
argument_list|)
argument_list|,
name|mask
argument_list|)
condition|)
continue|continue;
specifier|const
name|int
name|numChildren
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|24
argument_list|)
decl_stmt|;
specifier|const
name|int
name|firstChildOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|28
argument_list|)
decl_stmt|;
if|if
condition|(
name|numChildren
operator|==
literal|0
condition|)
comment|// No submatch? Then we are done.
return|return
literal|true
return|;
comment|// Check that one of the submatches matches too
if|if
condition|(
name|matchMagicRule
argument_list|(
name|cacheFile
argument_list|,
name|numChildren
argument_list|,
name|firstChildOffset
argument_list|,
name|data
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|findByMagic
name|QMimeType
name|QMimeBinaryProvider
operator|::
name|findByMagic
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|int
modifier|*
name|accuracyPtr
parameter_list|)
block|{
name|checkCache
argument_list|()
expr_stmt|;
foreach|foreach
control|(
name|CacheFile
modifier|*
name|cacheFile
decl|,
name|m_cacheFiles
control|)
block|{
specifier|const
name|int
name|magicListOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|PosMagicListOffset
argument_list|)
decl_stmt|;
specifier|const
name|int
name|numMatches
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|magicListOffset
argument_list|)
decl_stmt|;
comment|//const int maxExtent = cacheFile->getUint32(magicListOffset + 4);
specifier|const
name|int
name|firstMatchOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|magicListOffset
operator|+
literal|8
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numMatches
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|off
init|=
name|firstMatchOffset
operator|+
name|i
operator|*
literal|16
decl_stmt|;
specifier|const
name|int
name|numMatchlets
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|8
argument_list|)
decl_stmt|;
specifier|const
name|int
name|firstMatchletOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchMagicRule
argument_list|(
name|cacheFile
argument_list|,
name|numMatchlets
argument_list|,
name|firstMatchletOffset
argument_list|,
name|data
argument_list|)
condition|)
block|{
specifier|const
name|int
name|mimeTypeOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|4
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|mimeType
init|=
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|mimeTypeOffset
argument_list|)
decl_stmt|;
operator|*
name|accuracyPtr
operator|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
argument_list|)
expr_stmt|;
comment|// Return the first match. We have no rules for conflicting magic data...
comment|// (mime.cache itself is sorted, but what about local overrides with a lower prio?)
return|return
name|mimeTypeForNameUnchecked
argument_list|(
name|QLatin1String
argument_list|(
name|mimeType
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|QMimeType
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|parents
name|QStringList
name|QMimeBinaryProvider
operator|::
name|parents
parameter_list|(
specifier|const
name|QString
modifier|&
name|mime
parameter_list|)
block|{
name|checkCache
argument_list|()
expr_stmt|;
specifier|const
name|QByteArray
name|mimeStr
init|=
name|mime
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
name|QStringList
name|result
decl_stmt|;
foreach|foreach
control|(
name|CacheFile
modifier|*
name|cacheFile
decl|,
name|m_cacheFiles
control|)
block|{
specifier|const
name|int
name|parentListOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|PosParentListOffset
argument_list|)
decl_stmt|;
specifier|const
name|int
name|numEntries
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|parentListOffset
argument_list|)
decl_stmt|;
name|int
name|begin
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
name|numEntries
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|begin
operator|<=
name|end
condition|)
block|{
specifier|const
name|int
name|medium
init|=
operator|(
name|begin
operator|+
name|end
operator|)
operator|/
literal|2
decl_stmt|;
specifier|const
name|int
name|off
init|=
name|parentListOffset
operator|+
literal|4
operator|+
literal|8
operator|*
name|medium
decl_stmt|;
specifier|const
name|int
name|mimeOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|aMime
init|=
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|mimeOffset
argument_list|)
decl_stmt|;
specifier|const
name|int
name|cmp
init|=
name|qstrcmp
argument_list|(
name|aMime
argument_list|,
name|mimeStr
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|begin
operator|=
name|medium
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|end
operator|=
name|medium
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|parentsOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|4
argument_list|)
decl_stmt|;
specifier|const
name|int
name|numParents
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|parentsOffset
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numParents
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|int
name|parentOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|parentsOffset
operator|+
literal|4
operator|+
literal|4
operator|*
name|i
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|aParent
init|=
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|parentOffset
argument_list|)
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|aParent
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QString
name|parent
init|=
name|fallbackParent
argument_list|(
name|mime
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|.
name|append
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|resolveAlias
name|QString
name|QMimeBinaryProvider
operator|::
name|resolveAlias
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|checkCache
argument_list|()
expr_stmt|;
specifier|const
name|QByteArray
name|input
init|=
name|name
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|CacheFile
modifier|*
name|cacheFile
decl|,
name|m_cacheFiles
control|)
block|{
specifier|const
name|int
name|aliasListOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|PosAliasListOffset
argument_list|)
decl_stmt|;
specifier|const
name|int
name|numEntries
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|aliasListOffset
argument_list|)
decl_stmt|;
name|int
name|begin
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
name|numEntries
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|begin
operator|<=
name|end
condition|)
block|{
specifier|const
name|int
name|medium
init|=
operator|(
name|begin
operator|+
name|end
operator|)
operator|/
literal|2
decl_stmt|;
specifier|const
name|int
name|off
init|=
name|aliasListOffset
operator|+
literal|4
operator|+
literal|8
operator|*
name|medium
decl_stmt|;
specifier|const
name|int
name|aliasOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|alias
init|=
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|aliasOffset
argument_list|)
decl_stmt|;
specifier|const
name|int
name|cmp
init|=
name|qstrcmp
argument_list|(
name|alias
argument_list|,
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|begin
operator|=
name|medium
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|end
operator|=
name|medium
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|mimeOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|4
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|mimeType
init|=
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|mimeOffset
argument_list|)
decl_stmt|;
return|return
name|QLatin1String
argument_list|(
name|mimeType
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|name
return|;
block|}
end_function
begin_function
DECL|function|listAliases
name|QStringList
name|QMimeBinaryProvider
operator|::
name|listAliases
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|checkCache
argument_list|()
expr_stmt|;
name|QStringList
name|result
decl_stmt|;
specifier|const
name|QByteArray
name|input
init|=
name|name
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|CacheFile
modifier|*
name|cacheFile
decl|,
name|m_cacheFiles
control|)
block|{
specifier|const
name|int
name|aliasListOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|PosAliasListOffset
argument_list|)
decl_stmt|;
specifier|const
name|int
name|numEntries
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|aliasListOffset
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|numEntries
condition|;
operator|++
name|pos
control|)
block|{
specifier|const
name|int
name|off
init|=
name|aliasListOffset
operator|+
literal|4
operator|+
literal|8
operator|*
name|pos
decl_stmt|;
specifier|const
name|int
name|mimeOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|4
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|mimeType
init|=
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|mimeOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|input
operator|==
name|mimeType
condition|)
block|{
specifier|const
name|int
name|aliasOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|alias
init|=
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|aliasOffset
argument_list|)
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|loadMimeTypeList
name|void
name|QMimeBinaryProvider
operator|::
name|loadMimeTypeList
parameter_list|()
block|{
if|if
condition|(
operator|!
name|m_mimetypeListLoaded
condition|)
block|{
name|m_mimetypeListLoaded
operator|=
literal|true
expr_stmt|;
name|m_mimetypeNames
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Unfortunately mime.cache doesn't have a full list of all mimetypes.
comment|// So we have to parse the plain-text files called "types".
specifier|const
name|QStringList
name|typesFilenames
init|=
name|QStandardPaths
operator|::
name|locateAll
argument_list|(
name|QStandardPaths
operator|::
name|GenericDataLocation
argument_list|,
name|QLatin1String
argument_list|(
literal|"mime/types"
argument_list|)
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|typeFilename
decl|,
name|typesFilenames
control|)
block|{
name|QFile
name|file
argument_list|(
name|typeFilename
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|file
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|QByteArray
name|line
init|=
name|file
operator|.
name|readLine
argument_list|()
decl_stmt|;
name|line
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|m_mimetypeNames
operator|.
name|insert
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|line
operator|.
name|constData
argument_list|()
argument_list|,
name|line
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|allMimeTypes
name|QList
argument_list|<
name|QMimeType
argument_list|>
name|QMimeBinaryProvider
operator|::
name|allMimeTypes
parameter_list|()
block|{
name|QList
argument_list|<
name|QMimeType
argument_list|>
name|result
decl_stmt|;
name|loadMimeTypeList
argument_list|()
expr_stmt|;
for|for
control|(
name|QSet
argument_list|<
name|QString
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|m_mimetypeNames
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|m_mimetypeNames
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
name|result
operator|.
name|append
argument_list|(
name|mimeTypeForNameUnchecked
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|loadMimeTypePrivate
name|void
name|QMimeBinaryProvider
operator|::
name|loadMimeTypePrivate
parameter_list|(
name|QMimeTypePrivate
modifier|&
name|data
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_XMLSTREAMREADER
name|qWarning
argument_list|()
operator|<<
literal|"Cannot load mime type since QXmlStreamReader is not available."
expr_stmt|;
return|return;
else|#
directive|else
if|if
condition|(
name|data
operator|.
name|loaded
condition|)
return|return;
name|data
operator|.
name|loaded
operator|=
literal|true
expr_stmt|;
comment|// load comment and globPatterns
specifier|const
name|QString
name|file
init|=
name|data
operator|.
name|name
operator|+
name|QLatin1String
argument_list|(
literal|".xml"
argument_list|)
decl_stmt|;
specifier|const
name|QStringList
name|mimeFiles
init|=
name|QStandardPaths
operator|::
name|locateAll
argument_list|(
name|QStandardPaths
operator|::
name|GenericDataLocation
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"mime/"
argument_list|)
operator|+
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|mimeFiles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// TODO: ask Thiago about this
name|qWarning
argument_list|()
operator|<<
literal|"No file found for"
operator|<<
name|file
operator|<<
literal|", even though the file appeared in a directory listing."
expr_stmt|;
name|qWarning
argument_list|()
operator|<<
literal|"Either it was just removed, or the directory doesn't have executable permission..."
expr_stmt|;
name|qWarning
argument_list|()
operator|<<
name|QStandardPaths
operator|::
name|locateAll
argument_list|(
name|QStandardPaths
operator|::
name|GenericDataLocation
argument_list|,
name|QLatin1String
argument_list|(
literal|"mime"
argument_list|)
argument_list|,
name|QStandardPaths
operator|::
name|LocateDirectory
argument_list|)
expr_stmt|;
return|return;
block|}
name|QString
name|comment
decl_stmt|;
name|QString
name|mainPattern
decl_stmt|;
specifier|const
name|QString
name|preferredLanguage
init|=
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|name
argument_list|()
decl_stmt|;
name|QListIterator
argument_list|<
name|QString
argument_list|>
name|mimeFilesIter
argument_list|(
name|mimeFiles
argument_list|)
decl_stmt|;
name|mimeFilesIter
operator|.
name|toBack
argument_list|()
expr_stmt|;
while|while
condition|(
name|mimeFilesIter
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
comment|// global first, then local.
specifier|const
name|QString
name|fullPath
init|=
name|mimeFilesIter
operator|.
name|previous
argument_list|()
decl_stmt|;
name|QFile
name|qfile
argument_list|(
name|fullPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qfile
operator|.
name|open
argument_list|(
name|QFile
operator|::
name|ReadOnly
argument_list|)
condition|)
continue|continue;
name|QXmlStreamReader
name|xml
argument_list|(
operator|&
name|qfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|xml
operator|.
name|readNextStartElement
argument_list|()
condition|)
block|{
if|if
condition|(
name|xml
operator|.
name|name
argument_list|()
operator|!=
name|QLatin1String
argument_list|(
literal|"mime-type"
argument_list|)
condition|)
block|{
continue|continue;
block|}
specifier|const
name|QString
name|name
init|=
name|xml
operator|.
name|attributes
argument_list|()
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"type"
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|name
operator|!=
name|data
operator|.
name|name
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Got name"
operator|<<
name|name
operator|<<
literal|"in file"
operator|<<
name|file
operator|<<
literal|"expected"
operator|<<
name|data
operator|.
name|name
expr_stmt|;
block|}
while|while
condition|(
name|xml
operator|.
name|readNextStartElement
argument_list|()
condition|)
block|{
specifier|const
name|QStringRef
name|tag
init|=
name|xml
operator|.
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|==
name|QLatin1String
argument_list|(
literal|"comment"
argument_list|)
condition|)
block|{
name|QString
name|lang
init|=
name|xml
operator|.
name|attributes
argument_list|()
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"xml:lang"
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|const
name|QString
name|text
init|=
name|xml
operator|.
name|readElementText
argument_list|()
decl_stmt|;
if|if
condition|(
name|lang
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lang
operator|=
name|QLatin1String
argument_list|(
literal|"en_US"
argument_list|)
expr_stmt|;
block|}
name|data
operator|.
name|localeComments
operator|.
name|insert
argument_list|(
name|lang
argument_list|,
name|text
argument_list|)
expr_stmt|;
continue|continue;
comment|// we called readElementText, so we're at the EndElement already.
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
name|QLatin1String
argument_list|(
literal|"icon"
argument_list|)
condition|)
block|{
comment|// as written out by shared-mime-info>= 0.40
name|data
operator|.
name|iconName
operator|=
name|xml
operator|.
name|attributes
argument_list|()
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"name"
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
name|QLatin1String
argument_list|(
literal|"glob-deleteall"
argument_list|)
condition|)
block|{
comment|// as written out by shared-mime-info>= 0.70
name|data
operator|.
name|globPatterns
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
name|QLatin1String
argument_list|(
literal|"glob"
argument_list|)
condition|)
block|{
comment|// as written out by shared-mime-info>= 0.70
specifier|const
name|QString
name|pattern
init|=
name|xml
operator|.
name|attributes
argument_list|()
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"pattern"
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|mainPattern
operator|.
name|isEmpty
argument_list|()
operator|&&
name|pattern
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
argument_list|)
condition|)
block|{
name|mainPattern
operator|=
name|pattern
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|data
operator|.
name|globPatterns
operator|.
name|contains
argument_list|(
name|pattern
argument_list|)
condition|)
name|data
operator|.
name|globPatterns
operator|.
name|append
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
name|xml
operator|.
name|skipCurrentElement
argument_list|()
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|xml
operator|.
name|name
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"mime-type"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Let's assume that shared-mime-info is at least version 0.70
comment|// Otherwise we would need 1) a version check, and 2) code for parsing patterns from the globs file.
if|#
directive|if
literal|1
if|if
condition|(
operator|!
name|mainPattern
operator|.
name|isEmpty
argument_list|()
operator|&&
name|data
operator|.
name|globPatterns
operator|.
name|first
argument_list|()
operator|!=
name|mainPattern
condition|)
block|{
comment|// ensure it's first in the list of patterns
name|data
operator|.
name|globPatterns
operator|.
name|removeAll
argument_list|(
name|mainPattern
argument_list|)
expr_stmt|;
name|data
operator|.
name|globPatterns
operator|.
name|prepend
argument_list|(
name|mainPattern
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
specifier|const
name|bool
name|globsInXml
init|=
name|sharedMimeInfoVersion
argument_list|()
operator|>=
name|QT_VERSION_CHECK
argument_list|(
literal|0
argument_list|,
literal|70
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|globsInXml
condition|)
block|{
if|if
condition|(
operator|!
name|mainPattern
operator|.
name|isEmpty
argument_list|()
operator|&&
name|data
operator|.
name|globPatterns
operator|.
name|first
argument_list|()
operator|!=
name|mainPattern
condition|)
block|{
comment|// ensure it's first in the list of patterns
name|data
operator|.
name|globPatterns
operator|.
name|removeAll
argument_list|(
name|mainPattern
argument_list|)
expr_stmt|;
name|data
operator|.
name|globPatterns
operator|.
name|prepend
argument_list|(
name|mainPattern
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Fallback: get the patterns from the globs file
comment|// TODO: This would be the only way to support shared-mime-info< 0.70
comment|// But is this really worth the effort?
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|//QT_NO_XMLSTREAMREADER
block|}
end_function
begin_comment
comment|// Binary search in the icons or generic-icons list
end_comment
begin_function
DECL|function|iconForMime
name|QString
name|QMimeBinaryProvider
operator|::
name|iconForMime
parameter_list|(
name|CacheFile
modifier|*
name|cacheFile
parameter_list|,
name|int
name|posListOffset
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|inputMime
parameter_list|)
block|{
specifier|const
name|int
name|iconsListOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|posListOffset
argument_list|)
decl_stmt|;
specifier|const
name|int
name|numIcons
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|iconsListOffset
argument_list|)
decl_stmt|;
name|int
name|begin
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
name|numIcons
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|begin
operator|<=
name|end
condition|)
block|{
specifier|const
name|int
name|medium
init|=
operator|(
name|begin
operator|+
name|end
operator|)
operator|/
literal|2
decl_stmt|;
specifier|const
name|int
name|off
init|=
name|iconsListOffset
operator|+
literal|4
operator|+
literal|8
operator|*
name|medium
decl_stmt|;
specifier|const
name|int
name|mimeOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|mime
init|=
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|mimeOffset
argument_list|)
decl_stmt|;
specifier|const
name|int
name|cmp
init|=
name|qstrcmp
argument_list|(
name|mime
argument_list|,
name|inputMime
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|begin
operator|=
name|medium
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|end
operator|=
name|medium
operator|-
literal|1
expr_stmt|;
else|else
block|{
specifier|const
name|int
name|iconOffset
init|=
name|cacheFile
operator|->
name|getUint32
argument_list|(
name|off
operator|+
literal|4
argument_list|)
decl_stmt|;
return|return
name|QLatin1String
argument_list|(
name|cacheFile
operator|->
name|getCharStar
argument_list|(
name|iconOffset
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|loadIcon
name|void
name|QMimeBinaryProvider
operator|::
name|loadIcon
parameter_list|(
name|QMimeTypePrivate
modifier|&
name|data
parameter_list|)
block|{
name|checkCache
argument_list|()
expr_stmt|;
specifier|const
name|QByteArray
name|inputMime
init|=
name|data
operator|.
name|name
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|CacheFile
modifier|*
name|cacheFile
decl|,
name|m_cacheFiles
control|)
block|{
specifier|const
name|QString
name|icon
init|=
name|iconForMime
argument_list|(
name|cacheFile
argument_list|,
name|PosIconsListOffset
argument_list|,
name|inputMime
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|icon
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|data
operator|.
name|iconName
operator|=
name|icon
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_function
DECL|function|loadGenericIcon
name|void
name|QMimeBinaryProvider
operator|::
name|loadGenericIcon
parameter_list|(
name|QMimeTypePrivate
modifier|&
name|data
parameter_list|)
block|{
name|checkCache
argument_list|()
expr_stmt|;
specifier|const
name|QByteArray
name|inputMime
init|=
name|data
operator|.
name|name
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|CacheFile
modifier|*
name|cacheFile
decl|,
name|m_cacheFiles
control|)
block|{
specifier|const
name|QString
name|icon
init|=
name|iconForMime
argument_list|(
name|cacheFile
argument_list|,
name|PosGenericIconsListOffset
argument_list|,
name|inputMime
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|icon
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|data
operator|.
name|genericIconName
operator|=
name|icon
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_comment
comment|////
end_comment
begin_constructor
DECL|function|QMimeXMLProvider
name|QMimeXMLProvider
operator|::
name|QMimeXMLProvider
parameter_list|(
name|QMimeDatabasePrivate
modifier|*
name|db
parameter_list|)
member_init_list|:
name|QMimeProviderBase
argument_list|(
name|db
argument_list|)
member_init_list|,
name|m_loaded
argument_list|(
literal|false
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|isValid
name|bool
name|QMimeXMLProvider
operator|::
name|isValid
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|mimeTypeForName
name|QMimeType
name|QMimeXMLProvider
operator|::
name|mimeTypeForName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|ensureLoaded
argument_list|()
expr_stmt|;
return|return
name|m_nameMimeTypeMap
operator|.
name|value
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|findByFileName
name|QStringList
name|QMimeXMLProvider
operator|::
name|findByFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QString
modifier|*
name|foundSuffix
parameter_list|)
block|{
name|ensureLoaded
argument_list|()
expr_stmt|;
specifier|const
name|QStringList
name|matchingMimeTypes
init|=
name|m_mimeTypeGlobs
operator|.
name|matchingGlobs
argument_list|(
name|fileName
argument_list|,
name|foundSuffix
argument_list|)
decl_stmt|;
return|return
name|matchingMimeTypes
return|;
block|}
end_function
begin_function
DECL|function|findByMagic
name|QMimeType
name|QMimeXMLProvider
operator|::
name|findByMagic
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|int
modifier|*
name|accuracyPtr
parameter_list|)
block|{
name|ensureLoaded
argument_list|()
expr_stmt|;
name|QString
name|candidate
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QMimeMagicRuleMatcher
modifier|&
name|matcher
decl|,
name|m_magicMatchers
control|)
block|{
if|if
condition|(
name|matcher
operator|.
name|matches
argument_list|(
name|data
argument_list|)
condition|)
block|{
specifier|const
name|int
name|priority
init|=
name|matcher
operator|.
name|priority
argument_list|()
decl_stmt|;
if|if
condition|(
name|priority
operator|>
operator|*
name|accuracyPtr
condition|)
block|{
operator|*
name|accuracyPtr
operator|=
name|priority
expr_stmt|;
name|candidate
operator|=
name|matcher
operator|.
name|mimetype
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|mimeTypeForName
argument_list|(
name|candidate
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ensureLoaded
name|void
name|QMimeXMLProvider
operator|::
name|ensureLoaded
parameter_list|()
block|{
if|if
condition|(
operator|!
name|m_loaded
operator|||
name|shouldCheck
argument_list|()
condition|)
block|{
name|bool
name|fdoXmlFound
init|=
literal|false
decl_stmt|;
name|QStringList
name|allFiles
decl_stmt|;
specifier|const
name|QStringList
name|packageDirs
init|=
name|QStandardPaths
operator|::
name|locateAll
argument_list|(
name|QStandardPaths
operator|::
name|GenericDataLocation
argument_list|,
name|QLatin1String
argument_list|(
literal|"mime/packages"
argument_list|)
argument_list|,
name|QStandardPaths
operator|::
name|LocateDirectory
argument_list|)
decl_stmt|;
comment|//qDebug()<< "packageDirs="<< packageDirs;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|packageDir
decl|,
name|packageDirs
control|)
block|{
name|QDir
name|dir
argument_list|(
name|packageDir
argument_list|)
decl_stmt|;
specifier|const
name|QStringList
name|files
init|=
name|dir
operator|.
name|entryList
argument_list|(
name|QDir
operator|::
name|Files
operator||
name|QDir
operator|::
name|NoDotAndDotDot
argument_list|)
decl_stmt|;
comment|//qDebug()<< static_cast<const void *>(this)<< Q_FUNC_INFO<< packageDir<< files;
if|if
condition|(
operator|!
name|fdoXmlFound
condition|)
name|fdoXmlFound
operator|=
name|files
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"freedesktop.org.xml"
argument_list|)
argument_list|)
expr_stmt|;
name|QStringList
operator|::
name|const_iterator
name|endIt
argument_list|(
name|files
operator|.
name|constEnd
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|const_iterator
name|it
argument_list|(
name|files
operator|.
name|constBegin
argument_list|()
argument_list|)
init|;
name|it
operator|!=
name|endIt
condition|;
operator|++
name|it
control|)
block|{
name|allFiles
operator|.
name|append
argument_list|(
name|packageDir
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
operator|*
name|it
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fdoXmlFound
condition|)
block|{
comment|// We could instead install the file as part of installing Qt?
name|allFiles
operator|.
name|prepend
argument_list|(
name|QLatin1String
argument_list|(
literal|":/qt-project.org/qmime/freedesktop.org.xml"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m_allFiles
operator|==
name|allFiles
condition|)
return|return;
name|m_allFiles
operator|=
name|allFiles
expr_stmt|;
name|m_nameMimeTypeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_aliases
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_parents
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_mimeTypeGlobs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_magicMatchers
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|//qDebug()<< "Loading"<< m_allFiles;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|file
decl|,
name|allFiles
control|)
name|load
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|load
name|void
name|QMimeXMLProvider
operator|::
name|load
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QString
name|errorMessage
decl_stmt|;
if|if
condition|(
operator|!
name|load
argument_list|(
name|fileName
argument_list|,
operator|&
name|errorMessage
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"QMimeDatabase: Error loading %s\n%s"
argument_list|,
name|qPrintable
argument_list|(
name|fileName
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|errorMessage
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|load
name|bool
name|QMimeXMLProvider
operator|::
name|load
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QString
modifier|*
name|errorMessage
parameter_list|)
block|{
name|m_loaded
operator|=
literal|true
expr_stmt|;
name|QFile
name|file
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
operator||
name|QIODevice
operator|::
name|Text
argument_list|)
condition|)
block|{
if|if
condition|(
name|errorMessage
condition|)
operator|*
name|errorMessage
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Cannot open %1: %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|,
name|file
operator|.
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|errorMessage
condition|)
name|errorMessage
operator|->
name|clear
argument_list|()
expr_stmt|;
name|QMimeTypeParser
name|parser
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
return|return
name|parser
operator|.
name|parse
argument_list|(
operator|&
name|file
argument_list|,
name|fileName
argument_list|,
name|errorMessage
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addGlobPattern
name|void
name|QMimeXMLProvider
operator|::
name|addGlobPattern
parameter_list|(
specifier|const
name|QMimeGlobPattern
modifier|&
name|glob
parameter_list|)
block|{
name|m_mimeTypeGlobs
operator|.
name|addGlob
argument_list|(
name|glob
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addMimeType
name|void
name|QMimeXMLProvider
operator|::
name|addMimeType
parameter_list|(
specifier|const
name|QMimeType
modifier|&
name|mt
parameter_list|)
block|{
name|m_nameMimeTypeMap
operator|.
name|insert
argument_list|(
name|mt
operator|.
name|name
argument_list|()
argument_list|,
name|mt
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parents
name|QStringList
name|QMimeXMLProvider
operator|::
name|parents
parameter_list|(
specifier|const
name|QString
modifier|&
name|mime
parameter_list|)
block|{
name|ensureLoaded
argument_list|()
expr_stmt|;
name|QStringList
name|result
init|=
name|m_parents
operator|.
name|value
argument_list|(
name|mime
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QString
name|parent
init|=
name|fallbackParent
argument_list|(
name|mime
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|.
name|append
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|addParent
name|void
name|QMimeXMLProvider
operator|::
name|addParent
parameter_list|(
specifier|const
name|QString
modifier|&
name|child
parameter_list|,
specifier|const
name|QString
modifier|&
name|parent
parameter_list|)
block|{
name|m_parents
index|[
name|child
index|]
operator|.
name|append
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|listAliases
name|QStringList
name|QMimeXMLProvider
operator|::
name|listAliases
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|ensureLoaded
argument_list|()
expr_stmt|;
comment|// Iterate through the whole hash. This method is rarely used.
return|return
name|m_aliases
operator|.
name|keys
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|resolveAlias
name|QString
name|QMimeXMLProvider
operator|::
name|resolveAlias
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|ensureLoaded
argument_list|()
expr_stmt|;
return|return
name|m_aliases
operator|.
name|value
argument_list|(
name|name
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addAlias
name|void
name|QMimeXMLProvider
operator|::
name|addAlias
parameter_list|(
specifier|const
name|QString
modifier|&
name|alias
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|m_aliases
operator|.
name|insert
argument_list|(
name|alias
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|allMimeTypes
name|QList
argument_list|<
name|QMimeType
argument_list|>
name|QMimeXMLProvider
operator|::
name|allMimeTypes
parameter_list|()
block|{
name|ensureLoaded
argument_list|()
expr_stmt|;
return|return
name|m_nameMimeTypeMap
operator|.
name|values
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|addMagicMatcher
name|void
name|QMimeXMLProvider
operator|::
name|addMagicMatcher
parameter_list|(
specifier|const
name|QMimeMagicRuleMatcher
modifier|&
name|matcher
parameter_list|)
block|{
name|m_magicMatchers
operator|.
name|append
argument_list|(
name|matcher
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
