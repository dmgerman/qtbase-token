begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtextcodec_p.h"
end_include
begin_include
include|#
directive|include
file|<private/qcore_symbian_p.h>
end_include
begin_include
include|#
directive|include
file|<QThreadStorage>
end_include
begin_include
include|#
directive|include
file|<QScopedPointer>
end_include
begin_include
include|#
directive|include
file|<charconv.h>
end_include
begin_struct
DECL|struct|QSymbianCodecInitData
struct|struct
name|QSymbianCodecInitData
block|{
DECL|member|charsetId
name|uint
name|charsetId
decl_stmt|;
DECL|member|mib
name|int
name|mib
decl_stmt|;
DECL|member|aliases
specifier|const
name|char
modifier|*
name|aliases
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* This table contains the known Symbian codecs aliases.    It is required because symbian does not provide aliases for codecs.    It is also faster to have a name here than asking the system.    It is ordered by charsetId to allow binary search lookup  */
end_comment
begin_decl_stmt
DECL|variable|codecsData
specifier|static
specifier|const
name|QSymbianCodecInitData
name|codecsData
index|[]
init|=
block|{
block|{
comment|/*268439485*/
name|KCharacterSetIdentifierShiftJis
block|,
literal|17
block|,
literal|"Shift_JIS\0MS_Kanji\0csShiftJIS\0SJIS\0"
block|}
block|,
block|{
comment|/*268439486*/
name|KCharacterSetIdentifierGb2312
block|,
literal|57
block|,
literal|"GB2312\0csGB2312\0CN-GB\0EUC-CN\0"
block|}
block|,
comment|// Note: ConvertCharacterSetIdentifierToMibEnumL returns Mib 0 instaead of 57
block|{
comment|/*268439487*/
name|KCharacterSetIdentifierBig5
block|,
literal|2026
block|,
literal|"Big5\0csBig5\0Big5-ETen\0CP950\0BIG-FIVE\0CN-BIG5\0"
block|}
block|,
block|{
comment|/*268440246*/
name|KCharacterSetIdentifierCodePage1252
block|,
literal|2252
block|,
literal|"windows-1252\0Code Page 1252\0CP1252\0MS-ANSI\0"
block|}
block|,
comment|//  { /*268450576*/ KCharacterSetIdentifierIso88591,             4, "ISO-8859-1\0ISO_8859-1:1987\0iso-ir-100\0ISO_8859-1\0latin1\0l1\0IBM819\0CP819\0csISOLatin1\0ISO-IR-100\0ISO8859-1\0L1\0LATIN1\0CSISOLATIN1\0" },
block|{
comment|/*268451531*/
name|KCharacterSetIdentifierGbk
block|,
literal|113
block|,
literal|"GBK\0MS936\0windows-936\0CP936\0"
block|}
block|,
block|{
comment|/*268451866*/
name|KCharacterSetIdentifierGb12345
block|,
literal|0
block|,
literal|"GB12345\0"
block|}
block|,
block|{
comment|/*268455110*/
name|KCharacterSetIdentifierAscii
block|,
literal|3
block|,
literal|"US-ASCII\0ANSI_X3.4-1968\0iso-ir-6\0ANSI_X3.4-1986\0ISO_646.irv:1991\0ASCII\0ISO646-US\0us\0IBM367\0cp367\0csASCII\0ISO-IR-6\0ISO_646.IRV:1991\0"
block|}
block|,
block|{
comment|/*268456062*/
name|KCharacterSetIdentifierIso88592
block|,
literal|5
block|,
literal|"ISO-8859-2\0ISO_8859-2:1987\0iso-ir-101\0latin2\0l2\0csISOLatin2\0"
block|}
block|,
block|{
comment|/*268456063*/
name|KCharacterSetIdentifierIso88594
block|,
literal|7
block|,
literal|"ISO-8859-4\0ISO_8859-4:1988\0iso-ir-110\0latin4\0l4\0csISOLatin4\0"
block|}
block|,
block|{
comment|/*268456064*/
name|KCharacterSetIdentifierIso88595
block|,
literal|8
block|,
literal|"ISO-8859-5\0ISO_8859-5:1988\0iso-ir-144\0cyrillic\0csISOLatinCyrillic\0"
block|}
block|,
block|{
comment|/*268456065*/
name|KCharacterSetIdentifierIso88597
block|,
literal|10
block|,
literal|"ISO-8859-7\0ISO_8859-7:1987\0iso-ir-126\0ELOT_928\0ECMA-118\0greek\0greek8\0csISOLatinGreek\0"
block|}
block|,
block|{
comment|/*268456066*/
name|KCharacterSetIdentifierIso88599
block|,
literal|12
block|,
literal|"ISO-8859-9\0ISO_8859-9:1989\0iso-ir-148\0latin5\0l5\0csISOLatin5\0"
block|}
block|,
block|{
comment|/*268456875*/
name|KCharacterSetIdentifierSms7Bit
block|,
literal|0
block|,
literal|"SMS 7-bit\0"
block|}
block|,
block|{
comment|/*268458028*/
name|KCharacterSetIdentifierUtf7
block|,
literal|103
block|,
literal|"UTF-7\0UNICODE-1-1-UTF-7\0CSUNICODE11UTF7\0"
block|}
block|,
comment|//  { /*268458029*/ KCharacterSetIdentifierUtf8,               106, "UTF-8\0" },
block|{
comment|/*268458030*/
name|KCharacterSetIdentifierImapUtf7
block|,
literal|0
block|,
literal|"IMAP UTF-7\0"
block|}
block|,
block|{
comment|/*268458031*/
name|KCharacterSetIdentifierJavaConformantUtf8
block|,
literal|0
block|,
literal|"JAVA UTF-8\0"
block|}
block|,
block|{
comment|/*268458454*/
literal|268458454
block|,
literal|2250
block|,
literal|"Windows-1250\0CP1250\0MS-EE\0"
block|}
block|,
block|{
comment|/*268458455*/
literal|268458455
block|,
literal|2251
block|,
literal|"Windows-1251\0CP1251\0MS-CYRL\0"
block|}
block|,
block|{
comment|/*268458456*/
literal|268458456
block|,
literal|2253
block|,
literal|"Windows-1253\0CP1253\0MS-GREEK\0"
block|}
block|,
block|{
comment|/*268458457*/
literal|268458457
block|,
literal|2254
block|,
literal|"Windows-1254\0CP1254\0MS-TURK\0"
block|}
block|,
block|{
comment|/*268458458*/
literal|268458458
block|,
literal|2257
block|,
literal|"Windows-1257\0CP1257\0WINBALTRIM\0"
block|}
block|,
block|{
comment|/*268460133*/
name|KCharacterSetIdentifierHz
block|,
literal|2085
block|,
literal|"HZ-GB-2312\0HZ\0"
block|}
block|,
block|{
comment|/*268460134*/
name|KCharacterSetIdentifierJis
block|,
literal|16
block|,
literal|"JIS_Encoding\0JIS\0"
block|}
block|,
block|{
comment|/*268460135*/
name|KCharacterSetIdentifierEucJpPacked
block|,
literal|18
block|,
literal|"EUC-JP\0Extended_UNIX_Code_Packed_Format_for_Japanese\0csEUCPkdFmtJapanese\0EUCJP_PACKED\0"
block|}
block|,
block|{
comment|/*268461728*/
name|KCharacterSetIdentifierIso2022Jp
block|,
literal|39
block|,
literal|"ISO-2022-JP\0csISO2022JP\0JIS7\0"
block|}
block|,
block|{
comment|/*268461731*/
name|KCharacterSetIdentifierIso2022Jp1
block|,
literal|0
block|,
literal|"ISO2022JP1\0"
block|}
block|,
block|{
comment|/*268470824*/
name|KCharacterSetIdentifierIso88593
block|,
literal|6
block|,
literal|"ISO-8859-3\0ISO_8859-3:1988\0iso-ir-109\0latin3\0l3\0csISOLatin3\0"
block|}
block|,
block|{
comment|/*268470825*/
name|KCharacterSetIdentifierIso88596
block|,
literal|9
block|,
literal|"ISO-8859-6\0ISO_8859-6:1987\0iso-ir-127\0ECMA-114\0ASMO-708\0arabic\0ISO88596\0csISOLatinArabic\0ARABIC\0"
block|}
block|,
block|{
comment|/*268470826*/
name|KCharacterSetIdentifierIso88598
block|,
literal|11
block|,
literal|"ISO-8859-8\0ISO_8859-8:1988\0iso-ir-138\0hebrew\0csISOLatinHebrew\0"
block|}
block|,
block|{
comment|/*268470827*/
name|KCharacterSetIdentifierIso885910
block|,
literal|13
block|,
literal|"ISO-8859-10\0iso-ir-157\0l6\0ISO_8859-10:1992\0csISOLatin6\0latin6\0"
block|}
block|,
block|{
comment|/*268470828*/
name|KCharacterSetIdentifierIso885913
block|,
literal|109
block|,
literal|"ISO-8859-13\0ISO885913\0ISO-IR-179\0ISO8859-13\0L7\0LATIN7\0CSISOLATIN7\0"
block|}
block|,
block|{
comment|/*268470829*/
name|KCharacterSetIdentifierIso885914
block|,
literal|110
block|,
literal|"ISO-8859-14\0iso-ir-199\0ISO_8859-14:1998\0latin8\0iso-celtic\0l8\0"
block|}
block|,
block|{
comment|/*268470830*/
name|KCharacterSetIdentifierIso885915
block|,
literal|111
block|,
literal|"ISO-8859-15\0latin-9\0ISO-IR-203\0"
block|}
block|,
comment|//  { /*270483374*/ KCharacterSetIdentifierUnicodeLittle,     1014, "UTF-16LE\0Little-Endian UNICODE\0" },
comment|//  { /*270483538*/ KCharacterSetIdentifierUnicodeBig,        1013, "UTF-16BE\0Big-Endian UNICODE\0" },
block|{
comment|/*270501191*/
literal|270501191
block|,
literal|2255
block|,
literal|"Windows-1255\0CP1255\0MS-HEBR\0"
block|}
block|,
block|{
comment|/*270501192*/
literal|270501192
block|,
literal|2256
block|,
literal|"Windows-1256\0CP1256\0MS-ARAB\0"
block|}
block|,
block|{
comment|/*270501193*/
literal|270501193
block|,
literal|2259
block|,
literal|"TIS-620\0ISO-IR-166\0TIS620-0\0TIS620.2529-1\0TIS620.2533-0\0TIS620.2533-1\0"
block|}
block|,
block|{
comment|/*270501194*/
literal|270501194
block|,
literal|0
block|,
literal|"windows-874\0CP874\0IBM874\0"
block|}
block|,
block|{
comment|/*270501325*/
literal|270501325
block|,
literal|0
block|,
literal|"SmsStrict\0"
block|}
block|,
block|{
comment|/*270501521*/
literal|270501521
block|,
literal|0
block|,
literal|"ShiftJisDirectmap\0"
block|}
block|,
block|{
comment|/*270501542*/
literal|270501542
block|,
literal|0
block|,
literal|"EucJpDirectmap\0"
block|}
block|,
comment|/* 270501691   (duplicate)  Windows-1252  | windows-1252 |Windows-1252 |Code Page 1252 |CP1252 |MS-ANSI |WINDOWS-1252 |2252 */
block|{
comment|/*270501729*/
literal|270501729
block|,
literal|2088
block|,
literal|"KOI8-U\0"
block|}
block|,
block|{
comment|/*270501752*/
literal|270501752
block|,
literal|2084
block|,
literal|"KOI8-R\0csKOI8R\0"
block|}
block|,
block|{
comment|/*270529682*/
literal|270529682
block|,
literal|1000
block|,
literal|"ISO-10646-UCS-2\0UCS-2\0CSUNICODE\0"
block|}
block|,
block|{
comment|/*270562232*/
literal|270562232
block|,
literal|2258
block|,
literal|"Windows-1258\0CP1258\0WINDOWS-1258\0"
block|}
block|,
block|{
comment|/*270586888*/
literal|270586888
block|,
literal|0
block|,
literal|"J5\0"
block|}
block|,
block|{
comment|/*271011982*/
literal|271011982
block|,
literal|0
block|,
literal|"ISCII\0"
block|}
block|,
block|{
comment|/*271066541*/
literal|271066541
block|,
literal|2009
block|,
literal|"CP850\0IBM850\0"
literal|"850\0csPC850Multilingual\0"
block|}
block|,
comment|// Note: ConvertCharacterSetIdentifierToMibEnumL returns Mib 0 instead of 2009
block|{
comment|/*271082493*/
literal|271082493
block|,
literal|0
block|,
literal|"EXTENDED_SMS_7BIT\0"
block|}
block|,
block|{
comment|/*271082494*/
literal|271082494
block|,
literal|0
block|,
literal|"gsm7_turkish_single\0"
block|}
block|,
block|{
comment|/*271082495*/
literal|271082495
block|,
literal|0
block|,
literal|"turkish_locking_gsm7ext\0"
block|}
block|,
block|{
comment|/*271082496*/
literal|271082496
block|,
literal|0
block|,
literal|"turkish_locking_single\0"
block|}
block|,
block|{
comment|/*271082503*/
literal|271082503
block|,
literal|0
block|,
literal|"portuguese_gsm7_single\0"
block|}
block|,
block|{
comment|/*271082504*/
literal|271082504
block|,
literal|0
block|,
literal|"portuguese_locking_gsm7ext\0"
block|}
block|,
block|{
comment|/*271082505*/
literal|271082505
block|,
literal|0
block|,
literal|"portuguese_locking_single\0"
block|}
block|,
block|{
comment|/*271082506*/
literal|271082506
block|,
literal|0
block|,
literal|"spanish_gsm7_single\0"
block|}
block|,
block|{
comment|/*271085624*/
literal|271085624
block|,
literal|114
block|,
literal|"GB18030\0"
block|}
block|,
block|{
comment|/*536929574*/
literal|536929574
block|,
literal|38
block|,
literal|"EUC-KR\0"
block|}
block|,
block|{
comment|/*536936703*/
literal|536936703
block|,
literal|0
block|,
literal|"CP949\0"
block|}
block|,
block|{
comment|/*536936705*/
literal|536936705
block|,
literal|37
block|,
literal|"ISO-2022-KR\0csISO2022KR\0"
block|}
block|,
block|{
comment|/*536941517*/
literal|536941517
block|,
literal|36
block|,
literal|"KS_C_5601-1987\0iso-ir-149\0KS_C_5601-1989\0KSC_5601\0Korean\0csKSC56011987\0"
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_class
DECL|class|QSymbianTextCodec
class|class
name|QSymbianTextCodec
super|:
specifier|public
name|QTextCodec
block|{
public|public:
name|QString
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|ConverterState
modifier|*
parameter_list|)
specifier|const
function_decl|;
name|QByteArray
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
parameter_list|,
name|int
parameter_list|,
name|ConverterState
modifier|*
parameter_list|)
specifier|const
function_decl|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|aliases
parameter_list|()
specifier|const
function_decl|;
name|QByteArray
name|name
parameter_list|()
specifier|const
function_decl|;
name|int
name|mibEnum
parameter_list|()
specifier|const
function_decl|;
DECL|function|QSymbianTextCodec
specifier|explicit
name|QSymbianTextCodec
parameter_list|(
name|uint
name|charsetId
parameter_list|,
name|int
name|staticIndex
init|=
operator|-
literal|1
parameter_list|)
member_init_list|:
name|m_charsetId
argument_list|(
name|charsetId
argument_list|)
member_init_list|,
name|m_staticIndex
argument_list|(
name|staticIndex
argument_list|)
block|{ }
specifier|static
name|QSymbianTextCodec
modifier|*
name|init
parameter_list|()
function_decl|;
DECL|member|localeMapper
specifier|static
name|QSymbianTextCodec
modifier|*
name|localeMapper
decl_stmt|;
private|private:
specifier|static
name|CCnvCharacterSetConverter
modifier|*
name|converter
parameter_list|()
function_decl|;
specifier|static
name|uint
name|getLanguageDependentCharacterSet
parameter_list|()
function_decl|;
DECL|member|m_charsetId
name|uint
name|m_charsetId
decl_stmt|;
DECL|member|m_staticIndex
name|int
name|m_staticIndex
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|member|localeMapper
name|QSymbianTextCodec
modifier|*
name|QSymbianTextCodec
operator|::
name|localeMapper
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_class
DECL|class|QSymbianTextCodecWithName
class|class
name|QSymbianTextCodecWithName
super|:
specifier|public
name|QSymbianTextCodec
block|{
public|public:
DECL|function|QSymbianTextCodecWithName
name|QSymbianTextCodecWithName
parameter_list|(
name|uint
name|charsetId
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|)
member_init_list|:
name|QSymbianTextCodec
argument_list|(
name|charsetId
argument_list|)
member_init_list|,
name|m_name
argument_list|(
name|name
argument_list|)
block|{ }
DECL|function|name
name|QByteArray
name|name
parameter_list|()
specifier|const
block|{
return|return
name|m_name
return|;
block|}
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|aliases
parameter_list|()
specifier|const
block|{
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
block|}
private|private:
DECL|member|m_name
name|QByteArray
name|m_name
decl_stmt|;
block|}
class|;
end_class
begin_expr_stmt
name|Q_GLOBAL_STATIC
argument_list|(
name|QThreadStorage
argument_list|<
name|CCnvCharacterSetConverter
operator|*
argument_list|>
argument_list|,
name|gs_converterStore
argument_list|)
expr_stmt|;
end_expr_stmt
begin_function
DECL|function|converter
name|CCnvCharacterSetConverter
modifier|*
name|QSymbianTextCodec
operator|::
name|converter
parameter_list|()
block|{
name|CCnvCharacterSetConverter
modifier|*
modifier|&
name|conv
init|=
name|gs_converterStore
argument_list|()
operator|->
name|localData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|conv
condition|)
name|QT_TRAP_THROWING
argument_list|(
argument|conv = CCnvCharacterSetConverter::NewL()
argument_list|)
return|return
name|conv
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QSymbianTextCodec
operator|::
name|name
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|m_staticIndex
operator|>=
literal|0
condition|)
return|return
name|QByteArray
argument_list|(
name|codecsData
index|[
name|m_staticIndex
index|]
operator|.
name|aliases
argument_list|)
return|;
name|QScopedPointer
argument_list|<
name|HBufC8
argument_list|>
name|buf
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
argument|buf.reset(converter()->ConvertCharacterSetIdentifierToStandardNameL(m_charsetId, qt_s60GetRFs()))
argument_list|)
if|if
condition|(
name|buf
condition|)
return|return
name|QByteArray
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|buf
operator|->
name|Ptr
argument_list|()
argument_list|)
argument_list|,
name|buf
operator|->
name|Length
argument_list|()
argument_list|)
return|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QSymbianTextCodec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|m_staticIndex
operator|>=
literal|0
condition|)
return|return
name|codecsData
index|[
name|m_staticIndex
index|]
operator|.
name|mib
return|;
name|int
name|mib
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
argument|mib = converter()->ConvertCharacterSetIdentifierToMibEnumL(m_charsetId, qt_s60GetRFs())
argument_list|)
return|return
name|mib
return|;
block|}
end_function
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QSymbianTextCodec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
name|m_staticIndex
operator|>=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|aliases
init|=
name|codecsData
index|[
name|m_staticIndex
index|]
operator|.
name|aliases
decl_stmt|;
name|aliases
operator|+=
name|strlen
argument_list|(
name|aliases
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|aliases
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|aliases
argument_list|)
decl_stmt|;
name|result
operator|+=
name|QByteArray
argument_list|(
name|aliases
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|aliases
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QSymbianTextCodec
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
name|uint
name|charsetId
init|=
name|m_charsetId
decl_stmt|;
comment|// no support for utf7 with state
if|if
condition|(
name|state
operator|&&
operator|(
name|charsetId
operator|==
name|KCharacterSetIdentifierUtf7
operator|||
name|charsetId
operator|==
name|KCharacterSetIdentifierImapUtf7
operator|)
condition|)
block|{
return|return
name|QString
argument_list|()
return|;
block|}
name|CCnvCharacterSetConverter
modifier|*
name|converter
init|=
name|QSymbianTextCodec
operator|::
name|converter
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
block|{
return|return
name|QString
argument_list|()
return|;
block|}
comment|//Search the character set array  containing all of the character sets for which conversion is available
name|CCnvCharacterSetConverter
operator|::
name|TAvailability
name|av
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
argument|av = converter->PrepareToConvertToOrFromL(charsetId, qt_s60GetRFs())
argument_list|)
if|if
condition|(
name|av
operator|==
name|CCnvCharacterSetConverter
operator|::
name|ENotAvailable
condition|)
block|{
return|return
name|QString
argument_list|()
return|;
block|}
name|char
modifier|*
name|str2
decl_stmt|;
name|int
name|len2
decl_stmt|;
name|QByteArray
name|helperBA
decl_stmt|;
if|if
condition|(
name|state
operator|&&
operator|(
name|state
operator|->
name|remainingChars
operator|>
literal|0
operator|)
condition|)
block|{
comment|// we should prepare the input string ourselves
comment|// the real size
name|len2
operator|=
name|len
operator|+
name|state
operator|->
name|remainingChars
expr_stmt|;
name|helperBA
operator|.
name|resize
argument_list|(
name|len2
argument_list|)
expr_stmt|;
name|str2
operator|=
name|helperBA
operator|.
name|data
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|remainingChars
operator|>
literal|3
condition|)
block|{
comment|// doesn't happen usually
name|memcpy
argument_list|(
name|str2
argument_list|,
name|state
operator|->
name|d
argument_list|,
name|state
operator|->
name|remainingChars
argument_list|)
expr_stmt|;
name|qFree
argument_list|(
name|state
operator|->
name|d
argument_list|)
expr_stmt|;
name|state
operator|->
name|d
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|char
name|charTbl
index|[
literal|3
index|]
decl_stmt|;
name|charTbl
index|[
literal|0
index|]
operator|=
name|state
operator|->
name|state_data
index|[
literal|0
index|]
expr_stmt|;
name|charTbl
index|[
literal|1
index|]
operator|=
name|state
operator|->
name|state_data
index|[
literal|1
index|]
expr_stmt|;
name|charTbl
index|[
literal|2
index|]
operator|=
name|state
operator|->
name|state_data
index|[
literal|2
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|str2
argument_list|,
name|charTbl
argument_list|,
name|state
operator|->
name|remainingChars
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|str2
operator|+
name|state
operator|->
name|remainingChars
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len2
operator|=
name|len
expr_stmt|;
name|str2
operator|=
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|QString
name|UnicodeText
argument_list|(
name|len2
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|TPtrC8
name|remainderOfForeignText
decl_stmt|;
name|remainderOfForeignText
operator|.
name|Set
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|str2
argument_list|)
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|int
name|numberOfUnconvertibleCharacters
init|=
literal|0
decl_stmt|;
name|int
name|indexOfFirstUnconvertibleCharacter
decl_stmt|;
comment|// Use null character as replacement, if it is asked
name|bool
name|convertToNull
init|=
operator|(
name|state
operator|&&
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|ConvertInvalidToNull
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|convertToNull
condition|)
block|{
name|_LIT8
argument_list|(
name|KReplacement
argument_list|,
literal|"\x00"
argument_list|)
expr_stmt|;
name|QT_TRAP_THROWING
argument_list|(
argument|converter->SetReplacementForUnconvertibleUnicodeCharactersL(KReplacement)
argument_list|)
block|}
comment|// use state->invalidChars for keeping symbian state
name|int
name|sState
init|=
name|CCnvCharacterSetConverter
operator|::
name|KStateDefault
decl_stmt|;
if|if
condition|(
name|state
operator|&&
operator|(
name|state
operator|->
name|invalidChars
operator|!=
name|CCnvCharacterSetConverter
operator|::
name|KStateDefault
operator|)
condition|)
block|{
name|sState
operator|=
name|state
operator|->
name|invalidChars
expr_stmt|;
block|}
comment|//Convert text encoded in a non-Unicode character set into the Unicode character set (UCS-2).
name|int
name|remainingChars
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|initial_size
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|TPtr16
name|UnicodePtr
argument_list|(
cast|reinterpret_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|UnicodeText
operator|.
name|data
argument_list|()
operator|+
name|initial_size
argument_list|)
argument_list|,
name|UnicodeText
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
argument|remainingChars = converter->ConvertToUnicode(UnicodePtr,                                                                  remainderOfForeignText,                                                                  sState,                                                                  numberOfUnconvertibleCharacters,                                                                  indexOfFirstUnconvertibleCharacter)
argument_list|)
name|initial_size
operator|+=
name|UnicodePtr
operator|.
name|Length
argument_list|()
expr_stmt|;
comment|// replace 0xFFFD with 0x0000 and only if state set to convert to it
if|if
condition|(
name|numberOfUnconvertibleCharacters
operator|>
literal|0
operator|&&
name|convertToNull
condition|)
block|{
name|int
name|len2
init|=
name|UnicodePtr
operator|.
name|Length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|indexOfFirstUnconvertibleCharacter
init|;
name|i
operator|<
name|len2
condition|;
name|i
operator|++
control|)
block|{
name|UnicodePtr
index|[
name|i
index|]
operator|=
literal|0x0000
expr_stmt|;
block|}
block|}
comment|// success
if|if
condition|(
name|remainingChars
operator|==
name|KErrNone
condition|)
block|{
break|break;
block|}
comment|// if ConvertToUnicode could not consume the foreign text at all
comment|//   UTF-8: EErrorIllFormedInput = KErrCorrupt
comment|//   UCS-2: KErrNotFound
if|if
condition|(
name|remainingChars
operator|==
name|CCnvCharacterSetConverter
operator|::
name|EErrorIllFormedInput
operator|||
name|remainingChars
operator|==
name|KErrNotFound
condition|)
block|{
name|remainingChars
operator|=
name|remainderOfForeignText
operator|.
name|Size
argument_list|()
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|remainingChars
operator|<
literal|0
condition|)
block|{
return|return
name|QString
argument_list|()
return|;
block|}
block|}
comment|//
name|UnicodeText
operator|.
name|resize
argument_list|(
name|UnicodeText
operator|.
name|size
argument_list|()
operator|+
name|remainingChars
operator|*
literal|2
argument_list|)
expr_stmt|;
name|remainderOfForeignText
operator|.
name|Set
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|str2
operator|+
name|len2
operator|-
name|remainingChars
argument_list|)
argument_list|,
name|remainingChars
argument_list|)
expr_stmt|;
block|}
comment|// save symbian state
if|if
condition|(
name|state
condition|)
block|{
name|state
operator|->
name|invalidChars
operator|=
name|sState
expr_stmt|;
block|}
if|if
condition|(
name|remainingChars
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|state
condition|)
block|{
comment|// No way to signal, if there is still remaining chars, for ex. UTF-8 still can have
comment|// some characters hanging around.
return|return
name|QString
argument_list|()
return|;
block|}
specifier|const
name|unsigned
name|char
modifier|*
name|charPtr
init|=
name|remainderOfForeignText
operator|.
name|Right
argument_list|(
name|remainingChars
argument_list|)
operator|.
name|Ptr
argument_list|()
decl_stmt|;
if|if
condition|(
name|remainingChars
operator|>
literal|3
condition|)
block|{
comment|// doesn't happen usually
name|state
operator|->
name|d
operator|=
operator|(
name|void
operator|*
operator|)
name|qMalloc
argument_list|(
name|remainingChars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|d
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// copy characters there
name|memcpy
argument_list|(
name|state
operator|->
name|d
argument_list|,
name|charPtr
argument_list|,
name|remainingChars
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// fallthru is correct
switch|switch
condition|(
name|remainingChars
condition|)
block|{
case|case
literal|3
case|:
name|state
operator|->
name|state_data
index|[
literal|2
index|]
operator|=
name|charPtr
index|[
literal|2
index|]
expr_stmt|;
case|case
literal|2
case|:
name|state
operator|->
name|state_data
index|[
literal|1
index|]
operator|=
name|charPtr
index|[
literal|1
index|]
expr_stmt|;
case|case
literal|1
case|:
name|state
operator|->
name|state_data
index|[
literal|0
index|]
operator|=
name|charPtr
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
name|state
operator|->
name|remainingChars
operator|=
name|remainingChars
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|state
condition|)
block|{
comment|// If we continued from an earlier iteration
name|state
operator|->
name|remainingChars
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// check if any ORIGINAL headers should be left
if|if
condition|(
name|initial_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|state
operator|||
operator|(
name|state
operator|&&
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
operator|)
condition|)
block|{
comment|// always skip headers on following state loops
if|if
condition|(
name|state
condition|)
block|{
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
block|}
specifier|const
name|TUint16
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|TUint16
operator|*
argument_list|>
argument_list|(
name|UnicodeText
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
name|QChar
operator|::
name|ByteOrderMark
operator|||
name|ptr
index|[
literal|0
index|]
operator|==
name|QChar
operator|::
name|ByteOrderSwapped
condition|)
block|{
return|return
name|UnicodeText
operator|.
name|mid
argument_list|(
literal|1
argument_list|,
name|initial_size
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|initial_size
operator|>=
literal|0
condition|)
block|{
name|UnicodeText
operator|.
name|resize
argument_list|(
name|initial_size
argument_list|)
expr_stmt|;
return|return
name|UnicodeText
return|;
block|}
else|else
block|{
return|return
name|QString
argument_list|()
return|;
block|}
block|}
end_function
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QSymbianTextCodec
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
name|uint
name|charsetId
init|=
name|m_charsetId
decl_stmt|;
name|CCnvCharacterSetConverter
modifier|*
name|converter
init|=
name|QSymbianTextCodec
operator|::
name|converter
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|QByteArray
argument_list|()
return|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|QByteArray
argument_list|()
return|;
comment|// no support for utf7 with state
if|if
condition|(
name|state
operator|&&
operator|(
name|charsetId
operator|==
name|KCharacterSetIdentifierUtf7
operator|||
name|charsetId
operator|==
name|KCharacterSetIdentifierImapUtf7
operator|)
condition|)
return|return
name|QByteArray
argument_list|()
return|;
comment|//Get reference file session from backend
name|RFs
modifier|&
name|fileSession
init|=
name|qt_s60GetRFs
argument_list|()
decl_stmt|;
comment|//Search the character set array  containing all of the character sets for which conversion is available
name|CCnvCharacterSetConverter
operator|::
name|TAvailability
name|av
init|=
name|CCnvCharacterSetConverter
operator|::
name|ENotAvailable
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
argument|av = converter->PrepareToConvertToOrFromL(charsetId, fileSession)
argument_list|)
if|if
condition|(
name|av
operator|==
name|CCnvCharacterSetConverter
operator|::
name|ENotAvailable
condition|)
return|return
name|QByteArray
argument_list|()
return|;
comment|// Use null character as replacement, if it is asked
if|if
condition|(
name|state
operator|&&
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|ConvertInvalidToNull
operator|)
condition|)
block|{
name|_LIT8
argument_list|(
name|KReplacement
argument_list|,
literal|"\x00"
argument_list|)
expr_stmt|;
name|QT_TRAP_THROWING
argument_list|(
argument|converter->SetReplacementForUnconvertibleUnicodeCharactersL(KReplacement)
argument_list|)
block|}
else|else
block|{
name|_LIT8
argument_list|(
name|KReplacement
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
name|QT_TRAP_THROWING
argument_list|(
argument|converter->SetReplacementForUnconvertibleUnicodeCharactersL(KReplacement)
argument_list|)
block|}
name|QByteArray
name|outputBuffer
decl_stmt|;
comment|// add header if no state (one run), or if no ignoreheader (from first state)
name|int
name|bomofs
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|state
operator|||
operator|(
name|state
operator|&&
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
operator|)
condition|)
block|{
name|QChar
name|bom
argument_list|(
name|QChar
operator|::
name|ByteOrderMark
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
condition|)
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
comment|// bom handling only on first state
switch|switch
condition|(
name|charsetId
condition|)
block|{
case|case
name|KCharacterSetIdentifierUcs2
case|:
name|outputBuffer
operator|.
name|append
argument_list|(
name|bom
operator|.
name|row
argument_list|()
argument_list|)
expr_stmt|;
name|outputBuffer
operator|.
name|append
argument_list|(
name|bom
operator|.
name|cell
argument_list|()
argument_list|)
expr_stmt|;
name|bomofs
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|KCharacterSetIdentifierUtf8
case|:
comment|// we don't add bom for UTF-8
case|case
name|KCharacterSetIdentifierJavaConformantUtf8
case|:
comment|/*outputBuffer.append("\xef\xbb\xbf");             bomofs = 3;             */
break|break;
case|case
name|KCharacterSetIdentifierUnicodeLittle
case|:
name|outputBuffer
operator|.
name|append
argument_list|(
name|bom
operator|.
name|cell
argument_list|()
argument_list|)
expr_stmt|;
name|outputBuffer
operator|.
name|append
argument_list|(
name|bom
operator|.
name|row
argument_list|()
argument_list|)
expr_stmt|;
name|bomofs
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|KCharacterSetIdentifierUnicodeBig
case|:
name|outputBuffer
operator|.
name|append
argument_list|(
name|bom
operator|.
name|row
argument_list|()
argument_list|)
expr_stmt|;
name|outputBuffer
operator|.
name|append
argument_list|(
name|bom
operator|.
name|cell
argument_list|()
argument_list|)
expr_stmt|;
name|bomofs
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|// len is 16bit chars, reserve 3 8bit chars for each input char
comment|// jsz - it could be differentiated, to allocate less
name|outputBuffer
operator|.
name|resize
argument_list|(
name|len
operator|*
literal|3
operator|+
name|bomofs
argument_list|)
expr_stmt|;
comment|// loop for too short output buffer
name|int
name|unconverted
decl_stmt|;
name|int
name|numberOfUnconvertibleCharacters
init|=
name|len
decl_stmt|;
name|int
name|indexOfFirstUnconvertibleCharacter
decl_stmt|;
name|int
name|convertedSize
decl_stmt|;
name|int
name|lastUnconverted
init|=
literal|0
decl_stmt|;
name|int
name|initial_size
init|=
literal|0
decl_stmt|;
name|int
name|remainderToConvert
init|=
name|len
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|TPtr8
name|outputPtr
argument_list|(
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
name|outputBuffer
operator|.
name|data
argument_list|()
operator|+
name|bomofs
operator|+
name|initial_size
argument_list|)
argument_list|,
name|outputBuffer
operator|.
name|size
argument_list|()
operator|-
name|bomofs
argument_list|)
decl_stmt|;
name|TPtrC16
name|UnicodeText
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|str
operator|+
name|len
operator|-
name|remainderToConvert
argument_list|)
argument_list|,
name|remainderToConvert
argument_list|)
decl_stmt|;
comment|//Convert text encoded in the Unicode character set (UCS-2) into other character sets
name|unconverted
operator|=
operator|-
literal|1
expr_stmt|;
name|QT_TRAP_THROWING
argument_list|(
argument|unconverted = converter->ConvertFromUnicode(outputPtr,                                    UnicodeText,                                    numberOfUnconvertibleCharacters,                                    indexOfFirstUnconvertibleCharacter)
argument_list|)
name|initial_size
operator|+=
name|outputPtr
operator|.
name|Length
argument_list|()
expr_stmt|;
if|if
condition|(
name|unconverted
operator|<
literal|0
condition|)
block|{
return|return
name|QByteArray
argument_list|()
return|;
block|}
if|if
condition|(
name|unconverted
operator|==
literal|0
condition|)
block|{
name|convertedSize
operator|=
name|initial_size
expr_stmt|;
break|break;
block|}
comment|// check what means unconverted> 0
if|if
condition|(
name|indexOfFirstUnconvertibleCharacter
operator|<
literal|0
condition|)
block|{
comment|// 8859-6 and 8859-8 break with certain input (string of \xc0 - \xd9 converted to unicode and back)
if|if
condition|(
name|unconverted
operator|==
name|lastUnconverted
condition|)
block|{
return|return
name|QByteArray
argument_list|()
return|;
block|}
name|lastUnconverted
operator|=
name|unconverted
expr_stmt|;
block|}
else|else
block|{
comment|// were some character not possible to convert
block|}
name|remainderToConvert
operator|=
name|unconverted
expr_stmt|;
comment|// len - indexOfFirstUnconvertibleCharacter;
comment|// resize output buffer, use =op for the null check
name|outputBuffer
operator|.
name|resize
argument_list|(
name|outputBuffer
operator|.
name|size
argument_list|()
operator|+
name|remainderToConvert
operator|*
literal|3
operator|+
name|bomofs
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|// shorten output
name|outputBuffer
operator|.
name|resize
argument_list|(
name|convertedSize
operator|+
name|bomofs
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
name|state
operator|->
name|invalidChars
operator|=
name|numberOfUnconvertibleCharacters
expr_stmt|;
comment|// check if any Symbian CONVERTED headers should be removed
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|&&
name|state
operator|->
name|state_data
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|state
operator|->
name|state_data
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
comment|// bom handling only on first state
if|if
condition|(
name|charsetId
operator|==
name|KCharacterSetIdentifierUcs2
operator|&&
name|outputBuffer
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|QChar
name|bom
argument_list|(
name|QChar
operator|::
name|ByteOrderMark
argument_list|)
decl_stmt|;
if|if
condition|(
name|outputBuffer
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|bom
operator|.
name|row
argument_list|()
operator|&&
name|outputBuffer
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|bom
operator|.
name|cell
argument_list|()
condition|)
block|{
name|outputBuffer
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outputBuffer
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|bom
operator|.
name|cell
argument_list|()
operator|&&
name|outputBuffer
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|bom
operator|.
name|row
argument_list|()
condition|)
block|{
name|outputBuffer
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|charsetId
operator|==
name|KCharacterSetIdentifierUtf8
operator|||
name|charsetId
operator|==
name|KCharacterSetIdentifierJavaConformantUtf8
operator|)
operator|&&
name|outputBuffer
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|outputBuffer
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|0xef
operator|&&
name|outputBuffer
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
literal|0xbb
operator|&&
name|outputBuffer
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|==
literal|0xbf
condition|)
block|{
name|outputBuffer
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|charsetId
operator|==
name|KCharacterSetIdentifierUnicodeLittle
operator|&&
name|outputBuffer
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|QChar
name|bom
argument_list|(
name|QChar
operator|::
name|ByteOrderMark
argument_list|)
decl_stmt|;
if|if
condition|(
name|outputBuffer
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|bom
operator|.
name|row
argument_list|()
operator|&&
name|outputBuffer
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|bom
operator|.
name|cell
argument_list|()
condition|)
block|{
name|outputBuffer
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|charsetId
operator|==
name|KCharacterSetIdentifierUnicodeBig
operator|&&
name|outputBuffer
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|QChar
name|bom
argument_list|(
name|QChar
operator|::
name|ByteOrderSwapped
argument_list|)
decl_stmt|;
if|if
condition|(
name|outputBuffer
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|bom
operator|.
name|row
argument_list|()
operator|&&
name|outputBuffer
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
name|bom
operator|.
name|cell
argument_list|()
condition|)
block|{
name|outputBuffer
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|outputBuffer
return|;
block|}
end_function
begin_function
DECL|function|getLanguageDependentCharacterSet
name|uint
name|QSymbianTextCodec
operator|::
name|getLanguageDependentCharacterSet
parameter_list|()
block|{
name|TLanguage
name|lang
init|=
name|User
operator|::
name|Language
argument_list|()
decl_stmt|;
name|uint
name|langIndex
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|lang
condition|)
block|{
case|case
literal|14
case|:
comment|//ELangTurkish
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88599
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|//ELangRussian
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88595
expr_stmt|;
break|break;
case|case
literal|17
case|:
comment|//ELangHungarian
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88592
expr_stmt|;
break|break;
case|case
literal|25
case|:
comment|//ELangCzec
case|case
literal|26
case|:
comment|//ELangSlovak
case|case
literal|27
case|:
comment|//ELangPolish
case|case
literal|28
case|:
comment|//ELangSlovenian
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88592
expr_stmt|;
break|break;
case|case
literal|29
case|:
comment|//ELangTaiwanChinese
case|case
literal|30
case|:
comment|//ELangHongKongChinese
name|langIndex
operator|=
name|KCharacterSetIdentifierBig5
expr_stmt|;
break|break;
case|case
literal|31
case|:
comment|//ELangPrcChinese
name|langIndex
operator|=
name|KCharacterSetIdentifierGbk
expr_stmt|;
break|break;
case|case
literal|32
case|:
comment|//ELangJapanese
name|langIndex
operator|=
name|KCharacterSetIdentifierShiftJis
expr_stmt|;
break|break;
case|case
literal|33
case|:
comment|//ELangThai
name|langIndex
operator|=
literal|270501193
comment|/*KCharacterSetIdentifierTis620*/
expr_stmt|;
break|break;
case|case
literal|37
case|:
comment|//ELangArabic
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88596
expr_stmt|;
break|break;
case|case
literal|40
case|:
comment|//ELangBelarussian
case|case
literal|42
case|:
comment|//ELangBulgarian
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88595
expr_stmt|;
break|break;
case|case
literal|45
case|:
comment|//ELangCroatian
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88592
expr_stmt|;
break|break;
case|case
literal|49
case|:
comment|//ELangEstonian
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88594
expr_stmt|;
break|break;
case|case
literal|54
case|:
comment|//ELangGreek
case|case
literal|55
case|:
comment|//ELangCyprusGreek
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88597
expr_stmt|;
break|break;
case|case
literal|57
case|:
comment|//ELangHebrew
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88598
expr_stmt|;
break|break;
case|case
literal|58
case|:
comment|//ELangHindi
name|langIndex
operator|=
literal|271011982
comment|/*KCharacterSetIdentifierIscii*/
expr_stmt|;
break|break;
case|case
literal|67
case|:
comment|//ELangLatvian
case|case
literal|68
case|:
comment|//ELangLithuanian
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88594
expr_stmt|;
break|break;
case|case
literal|69
case|:
comment|//ELangMacedonian
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88595
expr_stmt|;
break|break;
case|case
literal|78
case|:
comment|//ELangRomanian
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88592
expr_stmt|;
break|break;
case|case
literal|79
case|:
comment|//ELangSerbian
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88592
expr_stmt|;
break|break;
case|case
literal|91
case|:
comment|//ELangCyprusTurkish
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88599
expr_stmt|;
break|break;
case|case
literal|93
case|:
comment|//ELangUkrainian
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88595
expr_stmt|;
break|break;
case|case
literal|94
case|:
comment|//ELangUrdu
name|langIndex
operator|=
name|KCharacterSetIdentifierIso88596
expr_stmt|;
break|break;
case|case
literal|157
case|:
comment|//ELangEnglish_Taiwan
case|case
literal|158
case|:
comment|//ELangEnglish_HongKong
name|langIndex
operator|=
name|KCharacterSetIdentifierBig5
expr_stmt|;
break|break;
case|case
literal|159
case|:
comment|//ELangEnglish_Prc
name|langIndex
operator|=
name|KCharacterSetIdentifierGbk
expr_stmt|;
break|break;
case|case
literal|160
case|:
name|langIndex
operator|=
name|KCharacterSetIdentifierShiftJis
expr_stmt|;
break|break;
case|case
literal|161
case|:
comment|//ELangEnglish_Thailand
name|langIndex
operator|=
literal|270501193
comment|/*KCharacterSetIdentifierTis620*/
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|langIndex
operator|>
literal|0
condition|)
block|{
return|return
name|langIndex
return|;
block|}
return|return
name|KCharacterSetIdentifierCodePage1252
return|;
block|}
end_function
begin_comment
comment|/* Create the codecs that have aliases and return the locale mapper*/
end_comment
begin_function
DECL|function|init
name|QSymbianTextCodec
modifier|*
name|QSymbianTextCodec
operator|::
name|init
parameter_list|()
block|{
specifier|const
name|uint
name|localeMapperId
init|=
name|getLanguageDependentCharacterSet
argument_list|()
decl_stmt|;
name|QScopedPointer
argument_list|<
name|CArrayFix
argument_list|<
name|CCnvCharacterSetConverter
operator|::
name|SCharacterSet
argument_list|>
argument_list|>
name|array
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
argument|array.reset(CCnvCharacterSetConverter::CreateArrayOfCharacterSetsAvailableL(qt_s60GetRFs()))
argument_list|)
name|CCnvCharacterSetConverter
modifier|*
name|converter
init|=
name|QSymbianTextCodec
operator|::
name|converter
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|array
operator|->
name|Count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|charsetId
init|=
name|array
operator|->
name|At
argument_list|(
name|i
argument_list|)
operator|.
name|Identifier
argument_list|()
decl_stmt|;
comment|// skip builtin Qt codecs
if|if
condition|(
name|charsetId
operator|==
name|KCharacterSetIdentifierUtf8
operator|||
name|charsetId
operator|==
name|KCharacterSetIdentifierUnicodeLittle
operator|||
name|charsetId
operator|==
name|KCharacterSetIdentifierUnicodeLittle
operator|||
name|charsetId
operator|==
name|KCharacterSetIdentifierUnicodeBig
operator|||
name|charsetId
operator|==
name|KCharacterSetIdentifierIso88591
operator|||
name|charsetId
operator|==
literal|270501691
comment|/* skip Windows-1252 duplicate*/
condition|)
block|{
continue|continue;
block|}
name|int
name|begin
init|=
literal|0
decl_stmt|;
name|int
name|n
init|=
sizeof|sizeof
argument_list|(
name|codecsData
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|codecsData
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|half
decl_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|half
operator|=
name|n
operator|>>
literal|1
expr_stmt|;
name|int
name|middle
init|=
name|begin
operator|+
name|half
decl_stmt|;
if|if
condition|(
name|codecsData
index|[
name|middle
index|]
operator|.
name|charsetId
operator|<
name|charsetId
condition|)
block|{
name|begin
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
name|n
operator|-=
name|half
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|half
expr_stmt|;
block|}
block|}
if|if
condition|(
name|codecsData
index|[
name|begin
index|]
operator|.
name|charsetId
operator|==
name|charsetId
condition|)
block|{
name|QSymbianTextCodec
modifier|*
name|c
init|=
operator|new
name|QSymbianTextCodec
argument_list|(
name|charsetId
argument_list|,
name|begin
argument_list|)
decl_stmt|;
if|if
condition|(
name|charsetId
operator|==
name|localeMapperId
condition|)
name|localeMapper
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
comment|// We did not find the charsetId in our codecsData[], therefore we ask
comment|// the OS for the codec name. We first try to get a "standard name" and fall
comment|// back to array->At(i).Name(), if really needed. array->At(i).Name() is not
comment|// guaranteed to be a correct name for QTextCodec::codecFromName().
name|QScopedPointer
argument_list|<
name|HBufC8
argument_list|>
name|buf
decl_stmt|;
name|QT_TRAP_THROWING
argument_list|(
argument|buf.reset(converter->ConvertCharacterSetIdentifierToStandardNameL(charsetId, qt_s60GetRFs()))
argument_list|)
name|QByteArray
name|name
decl_stmt|;
if|if
condition|(
name|buf
operator|&&
name|buf
operator|->
name|Length
argument_list|()
condition|)
block|{
name|name
operator|=
name|QByteArray
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|buf
operator|->
name|Ptr
argument_list|()
argument_list|)
argument_list|,
name|buf
operator|->
name|Length
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TPtrC
name|charSetName
init|=
name|array
operator|->
name|At
argument_list|(
name|i
argument_list|)
operator|.
name|NameIsFileName
argument_list|()
condition|?
name|TParsePtrC
argument_list|(
name|array
operator|->
name|At
argument_list|(
name|i
argument_list|)
operator|.
name|Name
argument_list|()
argument_list|)
operator|.
name|Name
argument_list|()
else|:
name|array
operator|->
name|At
argument_list|(
name|i
argument_list|)
operator|.
name|Name
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|charSetName
operator|.
name|Length
argument_list|()
decl_stmt|;
name|QString
name|str
decl_stmt|;
name|str
operator|.
name|setUnicode
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|charSetName
operator|.
name|Ptr
argument_list|()
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
operator|=
name|str
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
operator|new
name|QSymbianTextCodecWithName
argument_list|(
name|charsetId
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|localeMapper
return|;
block|}
end_function
end_unit
