begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Copyright (C) 2013 Intel Corporation ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qutfcodec_p.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qendian.h"
end_include
begin_include
include|#
directive|include
file|"qchar.h"
end_include
begin_include
include|#
directive|include
file|"private/qsimd_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qstringiterator_p.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|enumerator|Endian
DECL|enumerator|Data
name|enum
type|{
name|Endian
init|=
literal|0
decl_stmt|,
name|Data
init|=
literal|1
end_decl_stmt
begin_decl_stmt
DECL|enumerator|Endian
DECL|enumerator|Data
unit|};
DECL|variable|utf8bom
specifier|static
specifier|const
name|uchar
name|utf8bom
index|[]
init|=
block|{
literal|0xef
block|,
literal|0xbb
block|,
literal|0xbf
block|}
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SSE2__
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SSE2
argument_list|)
end_if
begin_function
DECL|function|simdEncodeAscii
specifier|static
specifier|inline
name|bool
name|simdEncodeAscii
parameter_list|(
name|uchar
modifier|*
modifier|&
name|dst
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|nextAscii
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|src
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|)
block|{
comment|// do sixteen characters at a time
for|for
control|(
init|;
name|end
operator|-
name|src
operator|>=
literal|16
condition|;
name|src
operator|+=
literal|16
operator|,
name|dst
operator|+=
literal|16
control|)
block|{
name|__m128i
name|data1
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|src
argument_list|)
decl_stmt|;
name|__m128i
name|data2
init|=
name|_mm_loadu_si128
argument_list|(
literal|1
operator|+
operator|(
name|__m128i
operator|*
operator|)
name|src
argument_list|)
decl_stmt|;
comment|// check if everything is ASCII
comment|// the highest ASCII value is U+007F
comment|// Do the packing directly:
comment|// The PACKUSWB instruction has packs a signed 16-bit integer to an unsigned 8-bit
comment|// with saturation. That is, anything from 0x0100 to 0x7fff is saturated to 0xff,
comment|// while all negatives (0x8000 to 0xffff) get saturated to 0x00. To detect non-ASCII,
comment|// we simply do a signed greater-than comparison to 0x00. That means we detect NULs as
comment|// "non-ASCII", but it's an acceptable compromise.
name|__m128i
name|packed
init|=
name|_mm_packus_epi16
argument_list|(
name|data1
argument_list|,
name|data2
argument_list|)
decl_stmt|;
name|__m128i
name|nonAscii
init|=
name|_mm_cmpgt_epi8
argument_list|(
name|packed
argument_list|,
name|_mm_setzero_si128
argument_list|()
argument_list|)
decl_stmt|;
comment|// store, even if there are non-ASCII characters here
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|dst
argument_list|,
name|packed
argument_list|)
expr_stmt|;
comment|// n will contain 1 bit set per character in [data1, data2] that is non-ASCII (or NUL)
name|ushort
name|n
init|=
name|~
name|_mm_movemask_epi8
argument_list|(
name|nonAscii
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|// find the next probable ASCII character
comment|// we don't want to load 32 bytes again in this loop if we know there are non-ASCII
comment|// characters still coming
name|nextAscii
operator|=
name|src
operator|+
name|_bit_scan_reverse
argument_list|(
name|n
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|_bit_scan_forward
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|n
expr_stmt|;
name|src
operator|+=
name|n
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
name|src
operator|==
name|end
return|;
block|}
end_function
begin_function
DECL|function|simdDecodeAscii
specifier|static
specifier|inline
name|bool
name|simdDecodeAscii
parameter_list|(
name|ushort
modifier|*
modifier|&
name|dst
parameter_list|,
specifier|const
name|uchar
modifier|*
modifier|&
name|nextAscii
parameter_list|,
specifier|const
name|uchar
modifier|*
modifier|&
name|src
parameter_list|,
specifier|const
name|uchar
modifier|*
name|end
parameter_list|)
block|{
comment|// do sixteen characters at a time
for|for
control|(
init|;
name|end
operator|-
name|src
operator|>=
literal|16
condition|;
name|src
operator|+=
literal|16
operator|,
name|dst
operator|+=
literal|16
control|)
block|{
name|__m128i
name|data
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|src
argument_list|)
decl_stmt|;
comment|// check if everything is ASCII
comment|// movemask extracts the high bit of every byte, so n is non-zero if something isn't ASCII
name|uint
name|n
init|=
name|_mm_movemask_epi8
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|// copy the front part that is still ASCII
while|while
condition|(
operator|!
operator|(
name|n
operator|&
literal|1
operator|)
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|n
operator|>>=
literal|1
expr_stmt|;
block|}
comment|// find the next probable ASCII character
comment|// we don't want to load 16 bytes again in this loop if we know there are non-ASCII
comment|// characters still coming
name|n
operator|=
name|_bit_scan_reverse
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|nextAscii
operator|=
name|src
operator|+
name|n
operator|+
literal|1
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// unpack
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|dst
argument_list|,
name|_mm_unpacklo_epi8
argument_list|(
name|data
argument_list|,
name|_mm_setzero_si128
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|_mm_storeu_si128
argument_list|(
literal|1
operator|+
operator|(
name|__m128i
operator|*
operator|)
name|dst
argument_list|,
name|_mm_unpackhi_epi8
argument_list|(
name|data
argument_list|,
name|_mm_setzero_si128
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|src
operator|==
name|end
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|simdEncodeAscii
specifier|static
specifier|inline
name|bool
name|simdEncodeAscii
parameter_list|(
name|uchar
modifier|*
parameter_list|,
specifier|const
name|ushort
modifier|*
parameter_list|,
specifier|const
name|ushort
modifier|*
parameter_list|,
specifier|const
name|ushort
modifier|*
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|simdDecodeAscii
specifier|static
specifier|inline
name|bool
name|simdDecodeAscii
parameter_list|(
name|ushort
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf8
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// create a QByteArray with the worst case scenario size
name|QByteArray
name|result
argument_list|(
name|len
operator|*
literal|3
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|dst
init|=
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|src
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|uc
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
specifier|const
name|end
init|=
name|src
operator|+
name|len
decl_stmt|;
while|while
condition|(
name|src
operator|!=
name|end
condition|)
block|{
specifier|const
name|ushort
modifier|*
name|nextAscii
init|=
name|end
decl_stmt|;
if|if
condition|(
name|simdEncodeAscii
argument_list|(
name|dst
argument_list|,
name|nextAscii
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
condition|)
break|break;
do|do
block|{
name|ushort
name|uc
init|=
operator|*
name|src
operator|++
decl_stmt|;
name|int
name|res
init|=
name|QUtf8Functions
operator|::
name|toUtf8
argument_list|<
name|QUtf8BaseTraits
argument_list|>
argument_list|(
name|uc
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
comment|// encoding error - append '?'
operator|*
name|dst
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|src
operator|<
name|nextAscii
condition|)
do|;
block|}
name|result
operator|.
name|truncate
argument_list|(
name|dst
operator|-
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf8
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
parameter_list|)
block|{
name|uchar
name|replacement
init|=
literal|'?'
decl_stmt|;
name|int
name|rlen
init|=
literal|3
operator|*
name|len
decl_stmt|;
name|int
name|surrogate_high
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|ConvertInvalidToNull
condition|)
name|replacement
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
condition|)
name|rlen
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|remainingChars
condition|)
name|surrogate_high
operator|=
name|state
operator|->
name|state_data
index|[
literal|0
index|]
expr_stmt|;
block|}
name|QByteArray
name|rstr
argument_list|(
name|rlen
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|cursor
init|=
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|rstr
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|src
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|uc
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
specifier|const
name|end
init|=
name|src
operator|+
name|len
decl_stmt|;
name|int
name|invalid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|state
operator|&&
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
condition|)
block|{
comment|// append UTF-8 BOM
operator|*
name|cursor
operator|++
operator|=
name|utf8bom
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|cursor
operator|++
operator|=
name|utf8bom
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|cursor
operator|++
operator|=
name|utf8bom
index|[
literal|2
index|]
expr_stmt|;
block|}
specifier|const
name|ushort
modifier|*
name|nextAscii
init|=
name|src
decl_stmt|;
while|while
condition|(
name|src
operator|!=
name|end
condition|)
block|{
name|int
name|res
decl_stmt|;
name|ushort
name|uc
decl_stmt|;
if|if
condition|(
name|surrogate_high
operator|!=
operator|-
literal|1
condition|)
block|{
name|uc
operator|=
name|surrogate_high
expr_stmt|;
name|surrogate_high
operator|=
operator|-
literal|1
expr_stmt|;
name|res
operator|=
name|QUtf8Functions
operator|::
name|toUtf8
argument_list|<
name|QUtf8BaseTraits
argument_list|>
argument_list|(
name|uc
argument_list|,
name|cursor
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|src
operator|>=
name|nextAscii
operator|&&
name|simdEncodeAscii
argument_list|(
name|cursor
argument_list|,
name|nextAscii
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
condition|)
break|break;
name|uc
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|res
operator|=
name|QUtf8Functions
operator|::
name|toUtf8
argument_list|<
name|QUtf8BaseTraits
argument_list|>
argument_list|(
name|uc
argument_list|,
name|cursor
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|res
operator|>=
literal|0
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|Error
condition|)
block|{
comment|// encoding error
operator|++
name|invalid
expr_stmt|;
operator|*
name|cursor
operator|++
operator|=
name|replacement
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|EndOfString
condition|)
block|{
name|surrogate_high
operator|=
name|uc
expr_stmt|;
break|break;
block|}
block|}
name|rstr
operator|.
name|resize
argument_list|(
name|cursor
operator|-
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|rstr
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
name|state
operator|->
name|invalidChars
operator|+=
name|invalid
expr_stmt|;
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
name|state
operator|->
name|remainingChars
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|surrogate_high
operator|>=
literal|0
condition|)
block|{
name|state
operator|->
name|remainingChars
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|state_data
index|[
literal|0
index|]
operator|=
name|surrogate_high
expr_stmt|;
block|}
block|}
return|return
name|rstr
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf8
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// UTF-8 to UTF-16 always needs the exact same number of words or less:
comment|//    UTF-8     UTF-16
comment|//   1 byte     1 word
comment|//   2 bytes    1 word
comment|//   3 bytes    1 word
comment|//   4 bytes    2 words (one surrogate pair)
comment|// That is, we'll use the full buffer if the input is US-ASCII (1-byte UTF-8),
comment|// half the buffer for U+0080-U+07FF text (e.g., Greek, Cyrillic, Arabic) or
comment|// non-BMP text, and one third of the buffer for U+0800-U+FFFF text (e.g, CJK).
comment|//
comment|// The table holds for invalid sequences too: we'll insert one replacement char
comment|// per invalid byte.
name|QString
name|result
argument_list|(
name|len
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|ushort
modifier|*
name|dst
init|=
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|src
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|chars
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|end
init|=
name|src
operator|+
name|len
decl_stmt|;
comment|// attempt to do a full decoding in SIMD
specifier|const
name|uchar
modifier|*
name|nextAscii
init|=
name|end
decl_stmt|;
if|if
condition|(
operator|!
name|simdDecodeAscii
argument_list|(
name|dst
argument_list|,
name|nextAscii
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
condition|)
block|{
comment|// at least one non-ASCII entry
comment|// check if we failed to decode the UTF-8 BOM; if so, skip it
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|src
operator|==
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|chars
argument_list|)
argument_list|)
operator|&&
name|end
operator|-
name|src
operator|>=
literal|3
operator|&&
name|Q_UNLIKELY
argument_list|(
name|src
index|[
literal|0
index|]
operator|==
name|utf8bom
index|[
literal|0
index|]
operator|&&
name|src
index|[
literal|1
index|]
operator|==
name|utf8bom
index|[
literal|1
index|]
operator|&&
name|src
index|[
literal|2
index|]
operator|==
name|utf8bom
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|src
operator|+=
literal|3
expr_stmt|;
block|}
while|while
condition|(
name|src
operator|<
name|end
condition|)
block|{
name|nextAscii
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|simdDecodeAscii
argument_list|(
name|dst
argument_list|,
name|nextAscii
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
condition|)
break|break;
do|do
block|{
name|uchar
name|b
init|=
operator|*
name|src
operator|++
decl_stmt|;
name|int
name|res
init|=
name|QUtf8Functions
operator|::
name|fromUtf8
argument_list|<
name|QUtf8BaseTraits
argument_list|>
argument_list|(
name|b
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
comment|// decoding error
operator|*
name|dst
operator|++
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
block|}
block|}
do|while
condition|(
name|src
operator|<
name|nextAscii
condition|)
do|;
block|}
block|}
name|result
operator|.
name|truncate
argument_list|(
name|dst
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf8
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
parameter_list|)
block|{
name|bool
name|headerdone
init|=
literal|false
decl_stmt|;
name|ushort
name|replacement
init|=
name|QChar
operator|::
name|ReplacementCharacter
decl_stmt|;
name|int
name|need
init|=
literal|0
decl_stmt|;
name|int
name|invalid
init|=
literal|0
decl_stmt|;
name|int
name|res
decl_stmt|;
name|uchar
name|ch
init|=
literal|0
decl_stmt|;
comment|// See above for buffer requirements for stateless decoding. However, that
comment|// fails if the state is not empty. The following situations can add to the
comment|// requirements:
comment|//  state contains      chars starts with           requirement
comment|//   1 of 2 bytes       valid continuation          0
comment|//   2 of 3 bytes       same                        0
comment|//   3 bytes of 4       same                        +1 (need to insert surrogate pair)
comment|//   1 of 2 bytes       invalid continuation        +1 (need to insert replacement and restart)
comment|//   2 of 3 bytes       same                        +1 (same)
comment|//   3 of 4 bytes       same                        +1 (same)
name|QString
name|result
argument_list|(
name|need
operator|+
name|len
operator|+
literal|1
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|ushort
modifier|*
name|dst
init|=
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|src
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|chars
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|end
init|=
name|src
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
condition|)
name|headerdone
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|ConvertInvalidToNull
condition|)
name|replacement
operator|=
name|QChar
operator|::
name|Null
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|remainingChars
condition|)
block|{
comment|// handle incoming state first
name|uchar
name|remainingCharsData
index|[
literal|4
index|]
decl_stmt|;
comment|// longest UTF-8 sequence possible
name|int
name|remainingCharsCount
init|=
name|state
operator|->
name|remainingChars
decl_stmt|;
name|int
name|newCharsToCopy
init|=
name|qMin
argument_list|<
name|int
argument_list|>
argument_list|(
sizeof|sizeof
argument_list|(
name|remainingCharsData
argument_list|)
operator|-
name|remainingCharsCount
argument_list|,
name|end
operator|-
name|src
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|remainingCharsData
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|remainingCharsData
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|remainingCharsData
argument_list|,
operator|&
name|state
operator|->
name|state_data
index|[
literal|0
index|]
argument_list|,
name|remainingCharsCount
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|remainingCharsData
operator|+
name|remainingCharsCount
argument_list|,
name|src
argument_list|,
name|newCharsToCopy
argument_list|)
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|begin
init|=
operator|&
name|remainingCharsData
index|[
literal|1
index|]
decl_stmt|;
name|res
operator|=
name|QUtf8Functions
operator|::
name|fromUtf8
argument_list|<
name|QUtf8BaseTraits
argument_list|>
argument_list|(
name|remainingCharsData
index|[
literal|0
index|]
argument_list|,
name|dst
argument_list|,
name|begin
argument_list|,
cast|static_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|remainingCharsData
argument_list|)
operator|+
name|remainingCharsCount
operator|+
name|newCharsToCopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|Error
operator|||
operator|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|EndOfString
operator|&&
name|len
operator|==
literal|0
operator|)
condition|)
block|{
comment|// special case for len == 0:
comment|// if we were supplied an empty string, terminate the previous, unfinished sequence with error
operator|++
name|invalid
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|replacement
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|EndOfString
condition|)
block|{
comment|// if we got EndOfString again, then there were too few bytes in src;
comment|// copy to our state and return
name|state
operator|->
name|remainingChars
operator|=
name|remainingCharsCount
operator|+
name|newCharsToCopy
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|state_data
index|[
literal|0
index|]
argument_list|,
name|remainingCharsData
argument_list|,
name|state
operator|->
name|remainingChars
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|headerdone
operator|&&
name|res
operator|>=
literal|0
condition|)
block|{
comment|// eat the UTF-8 BOM
name|headerdone
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|dst
index|[
operator|-
literal|1
index|]
operator|==
literal|0xfeff
condition|)
operator|--
name|dst
expr_stmt|;
block|}
comment|// adjust src now that we have maybe consumed a few chars
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|res
operator|>
name|remainingCharsCount
argument_list|)
expr_stmt|;
name|src
operator|+=
name|res
operator|-
name|remainingCharsCount
expr_stmt|;
block|}
block|}
block|}
comment|// main body, stateless decoding
name|res
operator|=
literal|0
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|nextAscii
init|=
name|src
decl_stmt|;
while|while
condition|(
name|res
operator|>=
literal|0
operator|&&
name|src
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|src
operator|>=
name|nextAscii
operator|&&
name|simdDecodeAscii
argument_list|(
name|dst
argument_list|,
name|nextAscii
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
condition|)
break|break;
name|ch
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|res
operator|=
name|QUtf8Functions
operator|::
name|fromUtf8
argument_list|<
name|QUtf8BaseTraits
argument_list|>
argument_list|(
name|ch
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|headerdone
operator|&&
name|res
operator|>=
literal|0
condition|)
block|{
name|headerdone
operator|=
literal|true
expr_stmt|;
comment|// eat the UTF-8 BOM
if|if
condition|(
name|dst
index|[
operator|-
literal|1
index|]
operator|==
literal|0xfeff
condition|)
operator|--
name|dst
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|Error
condition|)
block|{
name|res
operator|=
literal|0
expr_stmt|;
operator|++
name|invalid
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|replacement
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|state
operator|&&
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|EndOfString
condition|)
block|{
comment|// unterminated UTF sequence
operator|*
name|dst
operator|++
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
while|while
condition|(
name|src
operator|++
operator|<
name|end
condition|)
operator|*
name|dst
operator|++
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
block|}
name|result
operator|.
name|truncate
argument_list|(
name|dst
operator|-
operator|(
name|ushort
operator|*
operator|)
name|result
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
name|state
operator|->
name|invalidChars
operator|+=
name|invalid
expr_stmt|;
if|if
condition|(
name|headerdone
condition|)
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|EndOfString
condition|)
block|{
operator|--
name|src
expr_stmt|;
comment|// unread the byte in ch
name|state
operator|->
name|remainingChars
operator|=
name|end
operator|-
name|src
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|state_data
index|[
literal|0
index|]
argument_list|,
name|src
argument_list|,
name|end
operator|-
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|remainingChars
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf16
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
parameter_list|,
name|DataEndianness
name|e
parameter_list|)
block|{
name|DataEndianness
name|endian
init|=
name|e
decl_stmt|;
name|int
name|length
init|=
literal|2
operator|*
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|state
operator|||
operator|(
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
operator|)
condition|)
block|{
name|length
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|==
name|DetectEndianness
condition|)
block|{
name|endian
operator|=
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|)
condition|?
name|BigEndianness
else|:
name|LittleEndianness
expr_stmt|;
block|}
name|QByteArray
name|d
decl_stmt|;
name|d
operator|.
name|resize
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|char
modifier|*
name|data
init|=
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|state
operator|||
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
condition|)
block|{
name|QChar
name|bom
argument_list|(
name|QChar
operator|::
name|ByteOrderMark
argument_list|)
decl_stmt|;
if|if
condition|(
name|endian
operator|==
name|BigEndianness
condition|)
block|{
name|data
index|[
literal|0
index|]
operator|=
name|bom
operator|.
name|row
argument_list|()
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|bom
operator|.
name|cell
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|data
index|[
literal|0
index|]
operator|=
name|bom
operator|.
name|cell
argument_list|()
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|bom
operator|.
name|row
argument_list|()
expr_stmt|;
block|}
name|data
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|endian
operator|==
name|BigEndianness
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|uc
index|[
name|i
index|]
operator|.
name|row
argument_list|()
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|uc
index|[
name|i
index|]
operator|.
name|cell
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|uc
index|[
name|i
index|]
operator|.
name|cell
argument_list|()
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|uc
index|[
name|i
index|]
operator|.
name|row
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
condition|)
block|{
name|state
operator|->
name|remainingChars
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf16
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
parameter_list|,
name|DataEndianness
name|e
parameter_list|)
block|{
name|DataEndianness
name|endian
init|=
name|e
decl_stmt|;
name|bool
name|half
init|=
literal|false
decl_stmt|;
name|uchar
name|buf
init|=
literal|0
decl_stmt|;
name|bool
name|headerdone
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|state
condition|)
block|{
name|headerdone
operator|=
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
if|if
condition|(
name|endian
operator|==
name|DetectEndianness
condition|)
name|endian
operator|=
operator|(
name|DataEndianness
operator|)
name|state
operator|->
name|state_data
index|[
name|Endian
index|]
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|remainingChars
condition|)
block|{
name|half
operator|=
literal|true
expr_stmt|;
name|buf
operator|=
name|state
operator|->
name|state_data
index|[
name|Data
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|headerdone
operator|&&
name|endian
operator|==
name|DetectEndianness
condition|)
name|endian
operator|=
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|)
condition|?
name|BigEndianness
else|:
name|LittleEndianness
expr_stmt|;
name|QString
name|result
argument_list|(
name|len
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
comment|// worst case
name|QChar
modifier|*
name|qch
init|=
operator|(
name|QChar
operator|*
operator|)
name|result
operator|.
name|unicode
argument_list|()
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
name|half
condition|)
block|{
name|QChar
name|ch
decl_stmt|;
if|if
condition|(
name|endian
operator|==
name|LittleEndianness
condition|)
block|{
name|ch
operator|.
name|setRow
argument_list|(
operator|*
name|chars
operator|++
argument_list|)
expr_stmt|;
name|ch
operator|.
name|setCell
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|.
name|setRow
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ch
operator|.
name|setCell
argument_list|(
operator|*
name|chars
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|headerdone
condition|)
block|{
name|headerdone
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|endian
operator|==
name|DetectEndianness
condition|)
block|{
if|if
condition|(
name|ch
operator|==
name|QChar
operator|::
name|ByteOrderSwapped
condition|)
block|{
name|endian
operator|=
name|LittleEndianness
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QChar
operator|::
name|ByteOrderMark
condition|)
block|{
name|endian
operator|=
name|BigEndianness
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
name|endian
operator|=
name|BigEndianness
expr_stmt|;
block|}
else|else
block|{
name|endian
operator|=
name|LittleEndianness
expr_stmt|;
name|ch
operator|=
name|QChar
argument_list|(
operator|(
name|ch
operator|.
name|unicode
argument_list|()
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|ch
operator|.
name|unicode
argument_list|()
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|qch
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|!=
name|QChar
operator|::
name|ByteOrderMark
condition|)
block|{
operator|*
name|qch
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|qch
operator|++
operator|=
name|ch
expr_stmt|;
block|}
name|half
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
operator|*
name|chars
operator|++
expr_stmt|;
name|half
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|result
operator|.
name|truncate
argument_list|(
name|qch
operator|-
name|result
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|headerdone
condition|)
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
name|state
operator|->
name|state_data
index|[
name|Endian
index|]
operator|=
name|endian
expr_stmt|;
if|if
condition|(
name|half
condition|)
block|{
name|state
operator|->
name|remainingChars
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|state_data
index|[
name|Data
index|]
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|remainingChars
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|state_data
index|[
name|Data
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf32
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
parameter_list|,
name|DataEndianness
name|e
parameter_list|)
block|{
name|DataEndianness
name|endian
init|=
name|e
decl_stmt|;
name|int
name|length
init|=
literal|4
operator|*
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|state
operator|||
operator|(
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
operator|)
condition|)
block|{
name|length
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|==
name|DetectEndianness
condition|)
block|{
name|endian
operator|=
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|)
condition|?
name|BigEndianness
else|:
name|LittleEndianness
expr_stmt|;
block|}
name|QByteArray
name|d
argument_list|(
name|length
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|state
operator|||
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
condition|)
block|{
if|if
condition|(
name|endian
operator|==
name|BigEndianness
condition|)
block|{
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|)
literal|0xfe
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
operator|(
name|char
operator|)
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|0xff
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
literal|0xfe
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|data
operator|+=
literal|4
expr_stmt|;
block|}
name|QStringIterator
name|i
argument_list|(
name|uc
argument_list|,
name|uc
operator|+
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|endian
operator|==
name|BigEndianness
condition|)
block|{
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|uint
name|cp
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|cp
operator|>>
literal|24
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
operator|(
name|cp
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
operator|(
name|cp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|cp
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|uint
name|cp
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|cp
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
operator|(
name|cp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
operator|(
name|cp
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|cp
operator|>>
literal|24
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
condition|)
block|{
name|state
operator|->
name|remainingChars
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf32
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
parameter_list|,
name|DataEndianness
name|e
parameter_list|)
block|{
name|DataEndianness
name|endian
init|=
name|e
decl_stmt|;
name|uchar
name|tuple
index|[
literal|4
index|]
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|bool
name|headerdone
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|state
condition|)
block|{
name|headerdone
operator|=
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
if|if
condition|(
name|endian
operator|==
name|DetectEndianness
condition|)
block|{
name|endian
operator|=
operator|(
name|DataEndianness
operator|)
name|state
operator|->
name|state_data
index|[
name|Endian
index|]
expr_stmt|;
block|}
name|num
operator|=
name|state
operator|->
name|remainingChars
expr_stmt|;
name|memcpy
argument_list|(
name|tuple
argument_list|,
operator|&
name|state
operator|->
name|state_data
index|[
name|Data
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|headerdone
operator|&&
name|endian
operator|==
name|DetectEndianness
condition|)
name|endian
operator|=
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|)
condition|?
name|BigEndianness
else|:
name|LittleEndianness
expr_stmt|;
name|QString
name|result
decl_stmt|;
name|result
operator|.
name|resize
argument_list|(
operator|(
name|num
operator|+
name|len
operator|)
operator|>>
literal|2
operator|<<
literal|1
argument_list|)
expr_stmt|;
comment|// worst case
name|QChar
modifier|*
name|qch
init|=
operator|(
name|QChar
operator|*
operator|)
name|result
operator|.
name|unicode
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|chars
operator|+
name|len
decl_stmt|;
while|while
condition|(
name|chars
operator|<
name|end
condition|)
block|{
name|tuple
index|[
name|num
operator|++
index|]
operator|=
operator|*
name|chars
operator|++
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|4
condition|)
block|{
if|if
condition|(
operator|!
name|headerdone
condition|)
block|{
if|if
condition|(
name|endian
operator|==
name|DetectEndianness
condition|)
block|{
if|if
condition|(
name|tuple
index|[
literal|0
index|]
operator|==
literal|0xff
operator|&&
name|tuple
index|[
literal|1
index|]
operator|==
literal|0xfe
operator|&&
name|tuple
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|tuple
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|endian
operator|!=
name|BigEndianness
condition|)
block|{
name|endian
operator|=
name|LittleEndianness
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|tuple
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|tuple
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|tuple
index|[
literal|2
index|]
operator|==
literal|0xfe
operator|&&
name|tuple
index|[
literal|3
index|]
operator|==
literal|0xff
operator|&&
name|endian
operator|!=
name|LittleEndianness
condition|)
block|{
name|endian
operator|=
name|BigEndianness
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
name|endian
operator|=
name|BigEndianness
expr_stmt|;
block|}
else|else
block|{
name|endian
operator|=
name|LittleEndianness
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|endian
operator|==
name|BigEndianness
operator|)
condition|?
name|qFromBigEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|tuple
argument_list|)
else|:
name|qFromLittleEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|tuple
argument_list|)
operator|)
operator|==
name|QChar
operator|::
name|ByteOrderMark
condition|)
block|{
name|num
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
name|uint
name|code
init|=
operator|(
name|endian
operator|==
name|BigEndianness
operator|)
condition|?
name|qFromBigEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|tuple
argument_list|)
else|:
name|qFromLittleEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|tuple
argument_list|)
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|code
argument_list|)
condition|)
block|{
operator|*
name|qch
operator|++
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|code
argument_list|)
expr_stmt|;
operator|*
name|qch
operator|++
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|qch
operator|++
operator|=
name|code
expr_stmt|;
block|}
name|num
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|result
operator|.
name|truncate
argument_list|(
name|qch
operator|-
name|result
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|headerdone
condition|)
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
name|state
operator|->
name|state_data
index|[
name|Endian
index|]
operator|=
name|endian
expr_stmt|;
name|state
operator|->
name|remainingChars
operator|=
name|num
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|state_data
index|[
name|Data
index|]
argument_list|,
name|tuple
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
end_ifndef
begin_destructor
DECL|function|~QUtf8Codec
name|QUtf8Codec
operator|::
name|~
name|QUtf8Codec
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf8Codec
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
return|return
name|QUtf8
operator|::
name|convertFromUnicode
argument_list|(
name|uc
argument_list|,
name|len
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|void
name|QUtf8Codec
operator|::
name|convertToUnicode
parameter_list|(
name|QString
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
operator|*
name|target
operator|+=
name|QUtf8
operator|::
name|convertToUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf8Codec
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
return|return
name|QUtf8
operator|::
name|convertToUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf8Codec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-8"
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf8Codec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|106
return|;
block|}
end_function
begin_destructor
DECL|function|~QUtf16Codec
name|QUtf16Codec
operator|::
name|~
name|QUtf16Codec
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf16Codec
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
return|return
name|QUtf16
operator|::
name|convertFromUnicode
argument_list|(
name|uc
argument_list|,
name|len
argument_list|,
name|state
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf16Codec
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
return|return
name|QUtf16
operator|::
name|convertToUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
name|state
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf16Codec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|1015
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf16Codec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-16"
return|;
block|}
end_function
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtf16Codec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf16BECodec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|1013
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf16BECodec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-16BE"
return|;
block|}
end_function
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtf16BECodec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf16LECodec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|1014
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf16LECodec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-16LE"
return|;
block|}
end_function
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtf16LECodec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_destructor
DECL|function|~QUtf32Codec
name|QUtf32Codec
operator|::
name|~
name|QUtf32Codec
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf32Codec
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
return|return
name|QUtf32
operator|::
name|convertFromUnicode
argument_list|(
name|uc
argument_list|,
name|len
argument_list|,
name|state
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf32Codec
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
return|return
name|QUtf32
operator|::
name|convertToUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
name|state
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf32Codec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|1017
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf32Codec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-32"
return|;
block|}
end_function
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtf32Codec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf32BECodec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|1018
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf32BECodec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-32BE"
return|;
block|}
end_function
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtf32BECodec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf32LECodec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|1019
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf32LECodec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-32LE"
return|;
block|}
end_function
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtf32LECodec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_TEXTCODEC
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
