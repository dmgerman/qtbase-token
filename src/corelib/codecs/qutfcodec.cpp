begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Copyright (C) 2013 Intel Corporation ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qutfcodec_p.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qendian.h"
end_include
begin_include
include|#
directive|include
file|"qchar.h"
end_include
begin_include
include|#
directive|include
file|"private/qsimd_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qstringiterator_p.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|enumerator|Endian
DECL|enumerator|Data
name|enum
type|{
name|Endian
init|=
literal|0
decl_stmt|,
name|Data
init|=
literal|1
end_decl_stmt
begin_decl_stmt
DECL|enumerator|Endian
DECL|enumerator|Data
unit|};
DECL|variable|utf8bom
specifier|static
specifier|const
name|uchar
name|utf8bom
index|[]
init|=
block|{
literal|0xef
block|,
literal|0xbb
block|,
literal|0xbf
block|}
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SSE2__
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SSE2
argument_list|)
end_if
begin_function
DECL|function|simdEncodeAscii
specifier|static
specifier|inline
name|bool
name|simdEncodeAscii
parameter_list|(
name|uchar
modifier|*
modifier|&
name|dst
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|nextAscii
parameter_list|,
specifier|const
name|ushort
modifier|*
modifier|&
name|src
parameter_list|,
specifier|const
name|ushort
modifier|*
name|end
parameter_list|)
block|{
comment|// do sixteen characters at a time
for|for
control|(
init|;
name|end
operator|-
name|src
operator|>=
literal|16
condition|;
name|src
operator|+=
literal|16
operator|,
name|dst
operator|+=
literal|16
control|)
block|{
name|__m128i
name|data1
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
specifier|const
name|__m128i
operator|*
operator|)
name|src
argument_list|)
decl_stmt|;
name|__m128i
name|data2
init|=
name|_mm_loadu_si128
argument_list|(
literal|1
operator|+
operator|(
specifier|const
name|__m128i
operator|*
operator|)
name|src
argument_list|)
decl_stmt|;
comment|// check if everything is ASCII
comment|// the highest ASCII value is U+007F
comment|// Do the packing directly:
comment|// The PACKUSWB instruction has packs a signed 16-bit integer to an unsigned 8-bit
comment|// with saturation. That is, anything from 0x0100 to 0x7fff is saturated to 0xff,
comment|// while all negatives (0x8000 to 0xffff) get saturated to 0x00. To detect non-ASCII,
comment|// we simply do a signed greater-than comparison to 0x00. That means we detect NULs as
comment|// "non-ASCII", but it's an acceptable compromise.
name|__m128i
name|packed
init|=
name|_mm_packus_epi16
argument_list|(
name|data1
argument_list|,
name|data2
argument_list|)
decl_stmt|;
name|__m128i
name|nonAscii
init|=
name|_mm_cmpgt_epi8
argument_list|(
name|packed
argument_list|,
name|_mm_setzero_si128
argument_list|()
argument_list|)
decl_stmt|;
comment|// store, even if there are non-ASCII characters here
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|dst
argument_list|,
name|packed
argument_list|)
expr_stmt|;
comment|// n will contain 1 bit set per character in [data1, data2] that is non-ASCII (or NUL)
name|ushort
name|n
init|=
name|~
name|_mm_movemask_epi8
argument_list|(
name|nonAscii
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|// find the next probable ASCII character
comment|// we don't want to load 32 bytes again in this loop if we know there are non-ASCII
comment|// characters still coming
name|nextAscii
operator|=
name|src
operator|+
name|_bit_scan_reverse
argument_list|(
name|n
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|_bit_scan_forward
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|n
expr_stmt|;
name|src
operator|+=
name|n
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
name|src
operator|==
name|end
return|;
block|}
end_function
begin_function
DECL|function|simdDecodeAscii
specifier|static
specifier|inline
name|bool
name|simdDecodeAscii
parameter_list|(
name|ushort
modifier|*
modifier|&
name|dst
parameter_list|,
specifier|const
name|uchar
modifier|*
modifier|&
name|nextAscii
parameter_list|,
specifier|const
name|uchar
modifier|*
modifier|&
name|src
parameter_list|,
specifier|const
name|uchar
modifier|*
name|end
parameter_list|)
block|{
comment|// do sixteen characters at a time
for|for
control|(
init|;
name|end
operator|-
name|src
operator|>=
literal|16
condition|;
name|src
operator|+=
literal|16
operator|,
name|dst
operator|+=
literal|16
control|)
block|{
name|__m128i
name|data
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
specifier|const
name|__m128i
operator|*
operator|)
name|src
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|__AVX2__
specifier|const
name|int
name|BitSpacing
init|=
literal|2
decl_stmt|;
comment|// load and zero extend to an YMM register
specifier|const
name|__m256i
name|extended
init|=
name|_mm256_cvtepu8_epi16
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|uint
name|n
init|=
name|_mm256_movemask_epi8
argument_list|(
name|extended
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|// store
name|_mm256_storeu_si256
argument_list|(
operator|(
name|__m256i
operator|*
operator|)
name|dst
argument_list|,
name|extended
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|#
directive|else
specifier|const
name|int
name|BitSpacing
init|=
literal|1
decl_stmt|;
comment|// check if everything is ASCII
comment|// movemask extracts the high bit of every byte, so n is non-zero if something isn't ASCII
name|uint
name|n
init|=
name|_mm_movemask_epi8
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|// unpack
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|dst
argument_list|,
name|_mm_unpacklo_epi8
argument_list|(
name|data
argument_list|,
name|_mm_setzero_si128
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|_mm_storeu_si128
argument_list|(
literal|1
operator|+
operator|(
name|__m128i
operator|*
operator|)
name|dst
argument_list|,
name|_mm_unpackhi_epi8
argument_list|(
name|data
argument_list|,
name|_mm_setzero_si128
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|// copy the front part that is still ASCII
while|while
condition|(
operator|!
operator|(
name|n
operator|&
literal|1
operator|)
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|n
operator|>>=
name|BitSpacing
expr_stmt|;
block|}
comment|// find the next probable ASCII character
comment|// we don't want to load 16 bytes again in this loop if we know there are non-ASCII
comment|// characters still coming
name|n
operator|=
name|_bit_scan_reverse
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|nextAscii
operator|=
name|src
operator|+
operator|(
name|n
operator|/
name|BitSpacing
operator|)
operator|+
literal|1
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|src
operator|==
name|end
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|simdEncodeAscii
specifier|static
specifier|inline
name|bool
name|simdEncodeAscii
parameter_list|(
name|uchar
modifier|*
parameter_list|,
specifier|const
name|ushort
modifier|*
parameter_list|,
specifier|const
name|ushort
modifier|*
parameter_list|,
specifier|const
name|ushort
modifier|*
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|simdDecodeAscii
specifier|static
specifier|inline
name|bool
name|simdDecodeAscii
parameter_list|(
name|ushort
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|,
specifier|const
name|uchar
modifier|*
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf8
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// create a QByteArray with the worst case scenario size
name|QByteArray
name|result
argument_list|(
name|len
operator|*
literal|3
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|dst
init|=
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|src
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|uc
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
specifier|const
name|end
init|=
name|src
operator|+
name|len
decl_stmt|;
while|while
condition|(
name|src
operator|!=
name|end
condition|)
block|{
specifier|const
name|ushort
modifier|*
name|nextAscii
init|=
name|end
decl_stmt|;
if|if
condition|(
name|simdEncodeAscii
argument_list|(
name|dst
argument_list|,
name|nextAscii
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
condition|)
break|break;
do|do
block|{
name|ushort
name|uc
init|=
operator|*
name|src
operator|++
decl_stmt|;
name|int
name|res
init|=
name|QUtf8Functions
operator|::
name|toUtf8
argument_list|<
name|QUtf8BaseTraits
argument_list|>
argument_list|(
name|uc
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
comment|// encoding error - append '?'
operator|*
name|dst
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|src
operator|<
name|nextAscii
condition|)
do|;
block|}
name|result
operator|.
name|truncate
argument_list|(
name|dst
operator|-
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf8
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
parameter_list|)
block|{
name|uchar
name|replacement
init|=
literal|'?'
decl_stmt|;
name|int
name|rlen
init|=
literal|3
operator|*
name|len
decl_stmt|;
name|int
name|surrogate_high
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|ConvertInvalidToNull
condition|)
name|replacement
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
condition|)
name|rlen
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|remainingChars
condition|)
name|surrogate_high
operator|=
name|state
operator|->
name|state_data
index|[
literal|0
index|]
expr_stmt|;
block|}
name|QByteArray
name|rstr
argument_list|(
name|rlen
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|cursor
init|=
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|rstr
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|src
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|uc
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
specifier|const
name|end
init|=
name|src
operator|+
name|len
decl_stmt|;
name|int
name|invalid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|state
operator|&&
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
condition|)
block|{
comment|// append UTF-8 BOM
operator|*
name|cursor
operator|++
operator|=
name|utf8bom
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|cursor
operator|++
operator|=
name|utf8bom
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|cursor
operator|++
operator|=
name|utf8bom
index|[
literal|2
index|]
expr_stmt|;
block|}
specifier|const
name|ushort
modifier|*
name|nextAscii
init|=
name|src
decl_stmt|;
while|while
condition|(
name|src
operator|!=
name|end
condition|)
block|{
name|int
name|res
decl_stmt|;
name|ushort
name|uc
decl_stmt|;
if|if
condition|(
name|surrogate_high
operator|!=
operator|-
literal|1
condition|)
block|{
name|uc
operator|=
name|surrogate_high
expr_stmt|;
name|surrogate_high
operator|=
operator|-
literal|1
expr_stmt|;
name|res
operator|=
name|QUtf8Functions
operator|::
name|toUtf8
argument_list|<
name|QUtf8BaseTraits
argument_list|>
argument_list|(
name|uc
argument_list|,
name|cursor
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|src
operator|>=
name|nextAscii
operator|&&
name|simdEncodeAscii
argument_list|(
name|cursor
argument_list|,
name|nextAscii
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
condition|)
break|break;
name|uc
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|res
operator|=
name|QUtf8Functions
operator|::
name|toUtf8
argument_list|<
name|QUtf8BaseTraits
argument_list|>
argument_list|(
name|uc
argument_list|,
name|cursor
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|res
operator|>=
literal|0
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|Error
condition|)
block|{
comment|// encoding error
operator|++
name|invalid
expr_stmt|;
operator|*
name|cursor
operator|++
operator|=
name|replacement
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|EndOfString
condition|)
block|{
name|surrogate_high
operator|=
name|uc
expr_stmt|;
break|break;
block|}
block|}
name|rstr
operator|.
name|resize
argument_list|(
name|cursor
operator|-
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|rstr
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
name|state
operator|->
name|invalidChars
operator|+=
name|invalid
expr_stmt|;
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
name|state
operator|->
name|remainingChars
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|surrogate_high
operator|>=
literal|0
condition|)
block|{
name|state
operator|->
name|remainingChars
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|state_data
index|[
literal|0
index|]
operator|=
name|surrogate_high
expr_stmt|;
block|}
block|}
return|return
name|rstr
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf8
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// UTF-8 to UTF-16 always needs the exact same number of words or less:
comment|//    UTF-8     UTF-16
comment|//   1 byte     1 word
comment|//   2 bytes    1 word
comment|//   3 bytes    1 word
comment|//   4 bytes    2 words (one surrogate pair)
comment|// That is, we'll use the full buffer if the input is US-ASCII (1-byte UTF-8),
comment|// half the buffer for U+0080-U+07FF text (e.g., Greek, Cyrillic, Arabic) or
comment|// non-BMP text, and one third of the buffer for U+0800-U+FFFF text (e.g, CJK).
comment|//
comment|// The table holds for invalid sequences too: we'll insert one replacement char
comment|// per invalid byte.
name|QString
name|result
argument_list|(
name|len
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|QChar
modifier|*
name|data
init|=
cast|const_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
comment|// we know we're not shared
specifier|const
name|QChar
modifier|*
name|end
init|=
name|convertToUnicode
argument_list|(
name|data
argument_list|,
name|chars
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|result
operator|.
name|truncate
argument_list|(
name|end
operator|-
name|data
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.7     \overload      Converts the UTF-8 sequence of \a len octets beginning at \a chars to     a sequence of QChar starting at \a buffer. The buffer is expected to be     large enough to hold the result. An upper bound for the size of the     buffer is \a len QChars.      If, during decoding, an error occurs, a QChar::ReplacementCharacter is     written.      Returns a pointer to one past the last QChar written.      This function never throws. */
end_comment
begin_function
name|QChar
modifier|*
name|QUtf8
operator|::
name|convertToUnicode
parameter_list|(
name|QChar
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
name|Q_DECL_NOTHROW
block|{
name|ushort
modifier|*
name|dst
init|=
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|src
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|chars
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|end
init|=
name|src
operator|+
name|len
decl_stmt|;
comment|// attempt to do a full decoding in SIMD
specifier|const
name|uchar
modifier|*
name|nextAscii
init|=
name|end
decl_stmt|;
if|if
condition|(
operator|!
name|simdDecodeAscii
argument_list|(
name|dst
argument_list|,
name|nextAscii
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
condition|)
block|{
comment|// at least one non-ASCII entry
comment|// check if we failed to decode the UTF-8 BOM; if so, skip it
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|src
operator|==
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|chars
argument_list|)
argument_list|)
operator|&&
name|end
operator|-
name|src
operator|>=
literal|3
operator|&&
name|Q_UNLIKELY
argument_list|(
name|src
index|[
literal|0
index|]
operator|==
name|utf8bom
index|[
literal|0
index|]
operator|&&
name|src
index|[
literal|1
index|]
operator|==
name|utf8bom
index|[
literal|1
index|]
operator|&&
name|src
index|[
literal|2
index|]
operator|==
name|utf8bom
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|src
operator|+=
literal|3
expr_stmt|;
block|}
while|while
condition|(
name|src
operator|<
name|end
condition|)
block|{
name|nextAscii
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|simdDecodeAscii
argument_list|(
name|dst
argument_list|,
name|nextAscii
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
condition|)
break|break;
do|do
block|{
name|uchar
name|b
init|=
operator|*
name|src
operator|++
decl_stmt|;
name|int
name|res
init|=
name|QUtf8Functions
operator|::
name|fromUtf8
argument_list|<
name|QUtf8BaseTraits
argument_list|>
argument_list|(
name|b
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
comment|// decoding error
operator|*
name|dst
operator|++
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
block|}
block|}
do|while
condition|(
name|src
operator|<
name|nextAscii
condition|)
do|;
block|}
block|}
return|return
cast|reinterpret_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
name|dst
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf8
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
parameter_list|)
block|{
name|bool
name|headerdone
init|=
literal|false
decl_stmt|;
name|ushort
name|replacement
init|=
name|QChar
operator|::
name|ReplacementCharacter
decl_stmt|;
name|int
name|invalid
init|=
literal|0
decl_stmt|;
name|int
name|res
decl_stmt|;
name|uchar
name|ch
init|=
literal|0
decl_stmt|;
comment|// See above for buffer requirements for stateless decoding. However, that
comment|// fails if the state is not empty. The following situations can add to the
comment|// requirements:
comment|//  state contains      chars starts with           requirement
comment|//   1 of 2 bytes       valid continuation          0
comment|//   2 of 3 bytes       same                        0
comment|//   3 bytes of 4       same                        +1 (need to insert surrogate pair)
comment|//   1 of 2 bytes       invalid continuation        +1 (need to insert replacement and restart)
comment|//   2 of 3 bytes       same                        +1 (same)
comment|//   3 of 4 bytes       same                        +1 (same)
name|QString
name|result
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|ushort
modifier|*
name|dst
init|=
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
name|result
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|src
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|chars
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|end
init|=
name|src
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
condition|)
name|headerdone
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|ConvertInvalidToNull
condition|)
name|replacement
operator|=
name|QChar
operator|::
name|Null
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|remainingChars
condition|)
block|{
comment|// handle incoming state first
name|uchar
name|remainingCharsData
index|[
literal|4
index|]
decl_stmt|;
comment|// longest UTF-8 sequence possible
name|int
name|remainingCharsCount
init|=
name|state
operator|->
name|remainingChars
decl_stmt|;
name|int
name|newCharsToCopy
init|=
name|qMin
argument_list|<
name|int
argument_list|>
argument_list|(
sizeof|sizeof
argument_list|(
name|remainingCharsData
argument_list|)
operator|-
name|remainingCharsCount
argument_list|,
name|end
operator|-
name|src
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|remainingCharsData
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|remainingCharsData
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|remainingCharsData
argument_list|,
operator|&
name|state
operator|->
name|state_data
index|[
literal|0
index|]
argument_list|,
name|remainingCharsCount
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|remainingCharsData
operator|+
name|remainingCharsCount
argument_list|,
name|src
argument_list|,
name|newCharsToCopy
argument_list|)
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|begin
init|=
operator|&
name|remainingCharsData
index|[
literal|1
index|]
decl_stmt|;
name|res
operator|=
name|QUtf8Functions
operator|::
name|fromUtf8
argument_list|<
name|QUtf8BaseTraits
argument_list|>
argument_list|(
name|remainingCharsData
index|[
literal|0
index|]
argument_list|,
name|dst
argument_list|,
name|begin
argument_list|,
cast|static_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|remainingCharsData
argument_list|)
operator|+
name|remainingCharsCount
operator|+
name|newCharsToCopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|Error
operator|||
operator|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|EndOfString
operator|&&
name|len
operator|==
literal|0
operator|)
condition|)
block|{
comment|// special case for len == 0:
comment|// if we were supplied an empty string, terminate the previous, unfinished sequence with error
operator|++
name|invalid
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|replacement
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|EndOfString
condition|)
block|{
comment|// if we got EndOfString again, then there were too few bytes in src;
comment|// copy to our state and return
name|state
operator|->
name|remainingChars
operator|=
name|remainingCharsCount
operator|+
name|newCharsToCopy
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|state_data
index|[
literal|0
index|]
argument_list|,
name|remainingCharsData
argument_list|,
name|state
operator|->
name|remainingChars
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|headerdone
operator|&&
name|res
operator|>=
literal|0
condition|)
block|{
comment|// eat the UTF-8 BOM
name|headerdone
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|dst
index|[
operator|-
literal|1
index|]
operator|==
literal|0xfeff
condition|)
operator|--
name|dst
expr_stmt|;
block|}
comment|// adjust src now that we have maybe consumed a few chars
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|res
operator|>
name|remainingCharsCount
argument_list|)
expr_stmt|;
name|src
operator|+=
name|res
operator|-
name|remainingCharsCount
expr_stmt|;
block|}
block|}
block|}
comment|// main body, stateless decoding
name|res
operator|=
literal|0
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|nextAscii
init|=
name|src
decl_stmt|;
while|while
condition|(
name|res
operator|>=
literal|0
operator|&&
name|src
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|src
operator|>=
name|nextAscii
operator|&&
name|simdDecodeAscii
argument_list|(
name|dst
argument_list|,
name|nextAscii
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
condition|)
break|break;
name|ch
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|res
operator|=
name|QUtf8Functions
operator|::
name|fromUtf8
argument_list|<
name|QUtf8BaseTraits
argument_list|>
argument_list|(
name|ch
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|headerdone
operator|&&
name|res
operator|>=
literal|0
condition|)
block|{
name|headerdone
operator|=
literal|true
expr_stmt|;
comment|// eat the UTF-8 BOM
if|if
condition|(
name|dst
index|[
operator|-
literal|1
index|]
operator|==
literal|0xfeff
condition|)
operator|--
name|dst
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|Error
condition|)
block|{
name|res
operator|=
literal|0
expr_stmt|;
operator|++
name|invalid
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|replacement
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|state
operator|&&
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|EndOfString
condition|)
block|{
comment|// unterminated UTF sequence
operator|*
name|dst
operator|++
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
while|while
condition|(
name|src
operator|++
operator|<
name|end
condition|)
operator|*
name|dst
operator|++
operator|=
name|QChar
operator|::
name|ReplacementCharacter
expr_stmt|;
block|}
name|result
operator|.
name|truncate
argument_list|(
name|dst
operator|-
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|result
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
name|state
operator|->
name|invalidChars
operator|+=
name|invalid
expr_stmt|;
if|if
condition|(
name|headerdone
condition|)
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|QUtf8BaseTraits
operator|::
name|EndOfString
condition|)
block|{
operator|--
name|src
expr_stmt|;
comment|// unread the byte in ch
name|state
operator|->
name|remainingChars
operator|=
name|end
operator|-
name|src
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|state_data
index|[
literal|0
index|]
argument_list|,
name|src
argument_list|,
name|end
operator|-
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|remainingChars
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf16
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
parameter_list|,
name|DataEndianness
name|e
parameter_list|)
block|{
name|DataEndianness
name|endian
init|=
name|e
decl_stmt|;
name|int
name|length
init|=
literal|2
operator|*
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|state
operator|||
operator|(
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
operator|)
condition|)
block|{
name|length
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|==
name|DetectEndianness
condition|)
block|{
name|endian
operator|=
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|)
condition|?
name|BigEndianness
else|:
name|LittleEndianness
expr_stmt|;
block|}
name|QByteArray
name|d
decl_stmt|;
name|d
operator|.
name|resize
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|char
modifier|*
name|data
init|=
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|state
operator|||
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
condition|)
block|{
name|QChar
name|bom
argument_list|(
name|QChar
operator|::
name|ByteOrderMark
argument_list|)
decl_stmt|;
if|if
condition|(
name|endian
operator|==
name|BigEndianness
condition|)
block|{
name|data
index|[
literal|0
index|]
operator|=
name|bom
operator|.
name|row
argument_list|()
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|bom
operator|.
name|cell
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|data
index|[
literal|0
index|]
operator|=
name|bom
operator|.
name|cell
argument_list|()
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|bom
operator|.
name|row
argument_list|()
expr_stmt|;
block|}
name|data
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|endian
operator|==
name|BigEndianness
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|uc
index|[
name|i
index|]
operator|.
name|row
argument_list|()
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|uc
index|[
name|i
index|]
operator|.
name|cell
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|uc
index|[
name|i
index|]
operator|.
name|cell
argument_list|()
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|uc
index|[
name|i
index|]
operator|.
name|row
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
condition|)
block|{
name|state
operator|->
name|remainingChars
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf16
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
parameter_list|,
name|DataEndianness
name|e
parameter_list|)
block|{
name|DataEndianness
name|endian
init|=
name|e
decl_stmt|;
name|bool
name|half
init|=
literal|false
decl_stmt|;
name|uchar
name|buf
init|=
literal|0
decl_stmt|;
name|bool
name|headerdone
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|state
condition|)
block|{
name|headerdone
operator|=
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
if|if
condition|(
name|endian
operator|==
name|DetectEndianness
condition|)
name|endian
operator|=
operator|(
name|DataEndianness
operator|)
name|state
operator|->
name|state_data
index|[
name|Endian
index|]
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|remainingChars
condition|)
block|{
name|half
operator|=
literal|true
expr_stmt|;
name|buf
operator|=
name|state
operator|->
name|state_data
index|[
name|Data
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|headerdone
operator|&&
name|endian
operator|==
name|DetectEndianness
condition|)
name|endian
operator|=
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|)
condition|?
name|BigEndianness
else|:
name|LittleEndianness
expr_stmt|;
name|QString
name|result
argument_list|(
name|len
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
comment|// worst case
name|QChar
modifier|*
name|qch
init|=
operator|(
name|QChar
operator|*
operator|)
name|result
operator|.
name|data
argument_list|()
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
name|half
condition|)
block|{
name|QChar
name|ch
decl_stmt|;
if|if
condition|(
name|endian
operator|==
name|LittleEndianness
condition|)
block|{
name|ch
operator|.
name|setRow
argument_list|(
operator|*
name|chars
operator|++
argument_list|)
expr_stmt|;
name|ch
operator|.
name|setCell
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|.
name|setRow
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ch
operator|.
name|setCell
argument_list|(
operator|*
name|chars
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|headerdone
condition|)
block|{
name|headerdone
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|endian
operator|==
name|DetectEndianness
condition|)
block|{
if|if
condition|(
name|ch
operator|==
name|QChar
operator|::
name|ByteOrderSwapped
condition|)
block|{
name|endian
operator|=
name|LittleEndianness
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|QChar
operator|::
name|ByteOrderMark
condition|)
block|{
name|endian
operator|=
name|BigEndianness
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
name|endian
operator|=
name|BigEndianness
expr_stmt|;
block|}
else|else
block|{
name|endian
operator|=
name|LittleEndianness
expr_stmt|;
name|ch
operator|=
name|QChar
argument_list|(
operator|(
name|ch
operator|.
name|unicode
argument_list|()
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|ch
operator|.
name|unicode
argument_list|()
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|qch
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|!=
name|QChar
operator|::
name|ByteOrderMark
condition|)
block|{
operator|*
name|qch
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|qch
operator|++
operator|=
name|ch
expr_stmt|;
block|}
name|half
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
operator|*
name|chars
operator|++
expr_stmt|;
name|half
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|result
operator|.
name|truncate
argument_list|(
name|qch
operator|-
name|result
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|headerdone
condition|)
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
name|state
operator|->
name|state_data
index|[
name|Endian
index|]
operator|=
name|endian
expr_stmt|;
if|if
condition|(
name|half
condition|)
block|{
name|state
operator|->
name|remainingChars
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|state_data
index|[
name|Data
index|]
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|remainingChars
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|state_data
index|[
name|Data
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf32
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
parameter_list|,
name|DataEndianness
name|e
parameter_list|)
block|{
name|DataEndianness
name|endian
init|=
name|e
decl_stmt|;
name|int
name|length
init|=
literal|4
operator|*
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|state
operator|||
operator|(
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
operator|)
condition|)
block|{
name|length
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|==
name|DetectEndianness
condition|)
block|{
name|endian
operator|=
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|)
condition|?
name|BigEndianness
else|:
name|LittleEndianness
expr_stmt|;
block|}
name|QByteArray
name|d
argument_list|(
name|length
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|d
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|state
operator|||
operator|!
operator|(
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
operator|)
condition|)
block|{
if|if
condition|(
name|endian
operator|==
name|BigEndianness
condition|)
block|{
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|)
literal|0xfe
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
operator|(
name|char
operator|)
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|0xff
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
literal|0xfe
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|data
operator|+=
literal|4
expr_stmt|;
block|}
name|QStringIterator
name|i
argument_list|(
name|uc
argument_list|,
name|uc
operator|+
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|endian
operator|==
name|BigEndianness
condition|)
block|{
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|uint
name|cp
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|cp
operator|>>
literal|24
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
operator|(
name|cp
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
operator|(
name|cp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|cp
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|uint
name|cp
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|cp
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
operator|(
name|cp
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
operator|(
name|cp
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|cp
operator|>>
literal|24
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
condition|)
block|{
name|state
operator|->
name|remainingChars
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf32
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|QTextCodec
operator|::
name|ConverterState
modifier|*
name|state
parameter_list|,
name|DataEndianness
name|e
parameter_list|)
block|{
name|DataEndianness
name|endian
init|=
name|e
decl_stmt|;
name|uchar
name|tuple
index|[
literal|4
index|]
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|bool
name|headerdone
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|state
condition|)
block|{
name|headerdone
operator|=
name|state
operator|->
name|flags
operator|&
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
if|if
condition|(
name|endian
operator|==
name|DetectEndianness
condition|)
block|{
name|endian
operator|=
operator|(
name|DataEndianness
operator|)
name|state
operator|->
name|state_data
index|[
name|Endian
index|]
expr_stmt|;
block|}
name|num
operator|=
name|state
operator|->
name|remainingChars
expr_stmt|;
name|memcpy
argument_list|(
name|tuple
argument_list|,
operator|&
name|state
operator|->
name|state_data
index|[
name|Data
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|headerdone
operator|&&
name|endian
operator|==
name|DetectEndianness
condition|)
name|endian
operator|=
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|)
condition|?
name|BigEndianness
else|:
name|LittleEndianness
expr_stmt|;
name|QString
name|result
decl_stmt|;
name|result
operator|.
name|resize
argument_list|(
operator|(
name|num
operator|+
name|len
operator|)
operator|>>
literal|2
operator|<<
literal|1
argument_list|)
expr_stmt|;
comment|// worst case
name|QChar
modifier|*
name|qch
init|=
operator|(
name|QChar
operator|*
operator|)
name|result
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|chars
operator|+
name|len
decl_stmt|;
while|while
condition|(
name|chars
operator|<
name|end
condition|)
block|{
name|tuple
index|[
name|num
operator|++
index|]
operator|=
operator|*
name|chars
operator|++
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|4
condition|)
block|{
if|if
condition|(
operator|!
name|headerdone
condition|)
block|{
if|if
condition|(
name|endian
operator|==
name|DetectEndianness
condition|)
block|{
if|if
condition|(
name|tuple
index|[
literal|0
index|]
operator|==
literal|0xff
operator|&&
name|tuple
index|[
literal|1
index|]
operator|==
literal|0xfe
operator|&&
name|tuple
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|tuple
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|endian
operator|!=
name|BigEndianness
condition|)
block|{
name|endian
operator|=
name|LittleEndianness
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|tuple
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|tuple
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|tuple
index|[
literal|2
index|]
operator|==
literal|0xfe
operator|&&
name|tuple
index|[
literal|3
index|]
operator|==
literal|0xff
operator|&&
name|endian
operator|!=
name|LittleEndianness
condition|)
block|{
name|endian
operator|=
name|BigEndianness
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
name|endian
operator|=
name|BigEndianness
expr_stmt|;
block|}
else|else
block|{
name|endian
operator|=
name|LittleEndianness
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|endian
operator|==
name|BigEndianness
operator|)
condition|?
name|qFromBigEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|tuple
argument_list|)
else|:
name|qFromLittleEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|tuple
argument_list|)
operator|)
operator|==
name|QChar
operator|::
name|ByteOrderMark
condition|)
block|{
name|num
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
name|uint
name|code
init|=
operator|(
name|endian
operator|==
name|BigEndianness
operator|)
condition|?
name|qFromBigEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|tuple
argument_list|)
else|:
name|qFromLittleEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|tuple
argument_list|)
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|code
argument_list|)
condition|)
block|{
operator|*
name|qch
operator|++
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|code
argument_list|)
expr_stmt|;
operator|*
name|qch
operator|++
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|qch
operator|++
operator|=
name|code
expr_stmt|;
block|}
name|num
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|result
operator|.
name|truncate
argument_list|(
name|qch
operator|-
name|result
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|headerdone
condition|)
name|state
operator|->
name|flags
operator||=
name|QTextCodec
operator|::
name|IgnoreHeader
expr_stmt|;
name|state
operator|->
name|state_data
index|[
name|Endian
index|]
operator|=
name|endian
expr_stmt|;
name|state
operator|->
name|remainingChars
operator|=
name|num
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|state_data
index|[
name|Data
index|]
argument_list|,
name|tuple
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
end_ifndef
begin_destructor
DECL|function|~QUtf8Codec
name|QUtf8Codec
operator|::
name|~
name|QUtf8Codec
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf8Codec
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
return|return
name|QUtf8
operator|::
name|convertFromUnicode
argument_list|(
name|uc
argument_list|,
name|len
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|void
name|QUtf8Codec
operator|::
name|convertToUnicode
parameter_list|(
name|QString
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
operator|*
name|target
operator|+=
name|QUtf8
operator|::
name|convertToUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf8Codec
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
return|return
name|QUtf8
operator|::
name|convertToUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf8Codec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-8"
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf8Codec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|106
return|;
block|}
end_function
begin_destructor
DECL|function|~QUtf16Codec
name|QUtf16Codec
operator|::
name|~
name|QUtf16Codec
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf16Codec
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
return|return
name|QUtf16
operator|::
name|convertFromUnicode
argument_list|(
name|uc
argument_list|,
name|len
argument_list|,
name|state
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf16Codec
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
return|return
name|QUtf16
operator|::
name|convertToUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
name|state
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf16Codec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|1015
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf16Codec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-16"
return|;
block|}
end_function
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtf16Codec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf16BECodec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|1013
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf16BECodec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-16BE"
return|;
block|}
end_function
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtf16BECodec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf16LECodec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|1014
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf16LECodec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-16LE"
return|;
block|}
end_function
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtf16LECodec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_destructor
DECL|function|~QUtf32Codec
name|QUtf32Codec
operator|::
name|~
name|QUtf32Codec
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QUtf32Codec
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
return|return
name|QUtf32
operator|::
name|convertFromUnicode
argument_list|(
name|uc
argument_list|,
name|len
argument_list|,
name|state
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicode
name|QString
name|QUtf32Codec
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
return|return
name|QUtf32
operator|::
name|convertToUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
name|state
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf32Codec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|1017
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf32Codec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-32"
return|;
block|}
end_function
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtf32Codec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf32BECodec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|1018
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf32BECodec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-32BE"
return|;
block|}
end_function
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtf32BECodec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QUtf32LECodec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|1019
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QUtf32LECodec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"UTF-32LE"
return|;
block|}
end_function
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtf32LECodec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_TEXTCODEC
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
