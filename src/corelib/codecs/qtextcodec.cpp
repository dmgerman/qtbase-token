begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qtextcodec.h"
end_include
begin_include
include|#
directive|include
file|"qtextcodec_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
end_ifndef
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
end_if
begin_include
include|#
directive|include
file|<private/qcoreapplication_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"private/qcoreglobaldata_p.h"
end_include
begin_include
include|#
directive|include
file|"qutfcodec_p.h"
end_include
begin_include
include|#
directive|include
file|"qlatincodec_p.h"
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qtsciicodec_p.h"
end_include
begin_include
include|#
directive|include
file|"qisciicodec_p.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_ICU
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qicucodec_p.h"
end_include
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_ICONV
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qiconvcodec_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_include
include|#
directive|include
file|"qwindowscodec_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qsimplecodec_p.h"
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_BIG_CODECS
argument_list|)
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_INTEGRITY
end_ifndef
begin_include
include|#
directive|include
file|"qgb18030codec_p.h"
end_include
begin_include
include|#
directive|include
file|"qeucjpcodec_p.h"
end_include
begin_include
include|#
directive|include
file|"qjiscodec_p.h"
end_include
begin_include
include|#
directive|include
file|"qsjiscodec_p.h"
end_include
begin_include
include|#
directive|include
file|"qeuckrcodec_p.h"
end_include
begin_include
include|#
directive|include
file|"qbig5codec_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !Q_OS_INTEGRITY
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QT_NO_BIG_CODECS
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_USE_ICU
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BOOTSTRAPPED
end_comment
begin_include
include|#
directive|include
file|"qmutex.h"
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<locale.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_XOPEN_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_OSF
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_LINUX_ANDROID
argument_list|)
end_if
begin_include
include|#
directive|include
file|<langinfo.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
name|QMutex
argument_list|,
name|textCodecsMutex
argument_list|,
operator|(
name|QMutex
operator|::
name|Recursive
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qTextCodecsMutex
name|QMutex
modifier|*
name|qTextCodecsMutex
parameter_list|()
block|{
return|return
name|textCodecsMutex
argument_list|()
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_USE_ICU
argument_list|)
end_if
begin_function
DECL|function|qtolower
specifier|static
name|char
name|qtolower
parameter_list|(
specifier|register
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
return|return
name|c
operator|+
literal|0x20
return|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|qisalnum
specifier|static
name|bool
name|qisalnum
parameter_list|(
specifier|register
name|char
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
operator|(
name|c
operator||
literal|0x20
operator|)
operator|>=
literal|'a'
operator|&&
operator|(
name|c
operator||
literal|0x20
operator|)
operator|<=
literal|'z'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|qTextCodecNameMatch
name|bool
name|qTextCodecNameMatch
parameter_list|(
specifier|const
name|char
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|h
parameter_list|)
block|{
if|if
condition|(
name|qstricmp
argument_list|(
name|n
argument_list|,
name|h
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|true
return|;
comment|// if the letters and numbers are the same, we have a match
while|while
condition|(
operator|*
name|n
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|qisalnum
argument_list|(
operator|*
name|n
argument_list|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|h
operator|==
literal|'\0'
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|qisalnum
argument_list|(
operator|*
name|h
argument_list|)
condition|)
break|break;
operator|++
name|h
expr_stmt|;
block|}
if|if
condition|(
name|qtolower
argument_list|(
operator|*
name|n
argument_list|)
operator|!=
name|qtolower
argument_list|(
operator|*
name|h
argument_list|)
condition|)
return|return
literal|false
return|;
operator|++
name|h
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|h
operator|&&
operator|!
name|qisalnum
argument_list|(
operator|*
name|h
argument_list|)
condition|)
operator|++
name|h
expr_stmt|;
return|return
operator|(
operator|*
name|h
operator|==
literal|'\0'
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_LOCALE_IS_UTF8
argument_list|)
end_if
begin_function
DECL|function|checkForCodec
specifier|static
name|QTextCodec
modifier|*
name|checkForCodec
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|)
block|{
name|QTextCodec
modifier|*
name|c
init|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
specifier|const
name|int
name|index
init|=
name|name
operator|.
name|indexOf
argument_list|(
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|name
operator|.
name|left
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|static
name|void
name|setup
parameter_list|()
function_decl|;
end_function_decl
begin_comment
comment|// \threadsafe
end_comment
begin_comment
comment|// this returns the codec the method sets up as locale codec to
end_comment
begin_comment
comment|// avoid a race condition in codecForLocale() when
end_comment
begin_comment
comment|// setCodecForLocale(0) is called at the same time.
end_comment
begin_function
DECL|function|setupLocaleMapper
specifier|static
name|QTextCodec
modifier|*
name|setupLocaleMapper
parameter_list|()
block|{
name|QCoreGlobalData
modifier|*
name|globalData
init|=
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
decl_stmt|;
name|QTextCodec
modifier|*
name|locale
init|=
literal|0
decl_stmt|;
block|{
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|globalData
operator|->
name|allCodecs
operator|.
name|isEmpty
argument_list|()
condition|)
name|setup
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
name|QCoreApplicationPrivate
operator|::
name|initLocale
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|QT_LOCALE_IS_UTF8
argument_list|)
name|locale
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|locale
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"System"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// First try getting the codecs name from nl_langinfo and see
comment|// if we have a builtin codec for it.
comment|// Only fall back to using iconv if we can't find a builtin codec
comment|// This is because the builtin utf8 codec is around 5 times faster
comment|// then the using QIconvCodec
if|#
directive|if
name|defined
argument_list|(
name|_XOPEN_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_OSF
argument_list|)
name|char
modifier|*
name|charset
init|=
name|nl_langinfo
argument_list|(
name|CODESET
argument_list|)
decl_stmt|;
if|if
condition|(
name|charset
condition|)
name|locale
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|charset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_ICONV
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
if|if
condition|(
operator|!
name|locale
condition|)
block|{
comment|// no builtin codec for the locale found, let's try using iconv
operator|(
name|void
operator|)
operator|new
name|QIconvCodec
argument_list|()
expr_stmt|;
name|locale
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"System"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|locale
condition|)
block|{
comment|// Very poorly defined and followed standards causes lots of
comment|// code to try to get all the cases... This logic is
comment|// duplicated in QIconvCodec, so if you change it here, change
comment|// it there too.
comment|// Try to determine locale codeset from locale name assigned to
comment|// LC_CTYPE category.
comment|// First part is getting that locale name.  First try setlocale() which
comment|// definitely knows it, but since we cannot fully trust it, get ready
comment|// to fall back to environment variables.
specifier|const
name|QByteArray
name|ctype
init|=
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Get the first nonempty value from $LC_ALL, $LC_CTYPE, and $LANG
comment|// environment variables.
name|QByteArray
name|lang
init|=
name|qgetenv
argument_list|(
literal|"LC_ALL"
argument_list|)
decl_stmt|;
if|if
condition|(
name|lang
operator|.
name|isEmpty
argument_list|()
operator|||
name|lang
operator|==
literal|"C"
condition|)
block|{
name|lang
operator|=
name|qgetenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lang
operator|.
name|isEmpty
argument_list|()
operator|||
name|lang
operator|==
literal|"C"
condition|)
block|{
name|lang
operator|=
name|qgetenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
block|}
comment|// Now try these in order:
comment|// 1. CODESET from ctype if it contains a .CODESET part (e.g. en_US.ISO8859-15)
comment|// 2. CODESET from lang if it contains a .CODESET part
comment|// 3. ctype (maybe the locale is named "ISO-8859-1" or something)
comment|// 4. locale (ditto)
comment|// 5. check for "@euro"
comment|// 6. guess locale from ctype unless ctype is "C"
comment|// 7. guess locale from lang
comment|// 1. CODESET from ctype if it contains a .CODESET part (e.g. en_US.ISO8859-15)
name|int
name|indexOfDot
init|=
name|ctype
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexOfDot
operator|!=
operator|-
literal|1
condition|)
name|locale
operator|=
name|checkForCodec
argument_list|(
name|ctype
operator|.
name|mid
argument_list|(
name|indexOfDot
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// 2. CODESET from lang if it contains a .CODESET part
if|if
condition|(
operator|!
name|locale
condition|)
block|{
name|indexOfDot
operator|=
name|lang
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexOfDot
operator|!=
operator|-
literal|1
condition|)
name|locale
operator|=
name|checkForCodec
argument_list|(
name|lang
operator|.
name|mid
argument_list|(
name|indexOfDot
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 3. ctype (maybe the locale is named "ISO-8859-1" or something)
if|if
condition|(
operator|!
name|locale
operator|&&
operator|!
name|ctype
operator|.
name|isEmpty
argument_list|()
operator|&&
name|ctype
operator|!=
literal|"C"
condition|)
name|locale
operator|=
name|checkForCodec
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
comment|// 4. locale (ditto)
if|if
condition|(
operator|!
name|locale
operator|&&
operator|!
name|lang
operator|.
name|isEmpty
argument_list|()
condition|)
name|locale
operator|=
name|checkForCodec
argument_list|(
name|lang
argument_list|)
expr_stmt|;
comment|// 5. "@euro"
if|if
condition|(
operator|(
operator|!
name|locale
operator|&&
name|ctype
operator|.
name|contains
argument_list|(
literal|"@euro"
argument_list|)
operator|)
operator|||
name|lang
operator|.
name|contains
argument_list|(
literal|"@euro"
argument_list|)
condition|)
name|locale
operator|=
name|checkForCodec
argument_list|(
literal|"ISO 8859-15"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// If everything failed, we default to 8859-1
if|if
condition|(
operator|!
name|locale
condition|)
name|locale
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-1"
argument_list|)
expr_stmt|;
name|globalData
operator|->
name|codecForLocale
operator|.
name|storeRelease
argument_list|(
name|locale
argument_list|)
expr_stmt|;
return|return
name|locale
return|;
block|}
end_function
begin_comment
comment|// textCodecsMutex need to be locked to enter this function
end_comment
begin_function
DECL|function|setup
specifier|static
name|void
name|setup
parameter_list|()
block|{
name|QCoreGlobalData
modifier|*
name|globalData
init|=
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|globalData
operator|->
name|allCodecs
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_CODECS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
operator|(
name|void
operator|)
operator|new
name|QTsciiCodec
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
operator|++
name|i
control|)
operator|(
name|void
operator|)
operator|new
name|QIsciiCodec
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|QSimpleTextCodec
operator|::
name|numSimpleCodecs
condition|;
operator|++
name|i
control|)
operator|(
name|void
operator|)
operator|new
name|QSimpleTextCodec
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_BIG_CODECS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_INTEGRITY
argument_list|)
operator|(
name|void
operator|)
operator|new
name|QGb18030Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QGbkCodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QGb2312Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QEucJpCodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QJisCodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QSjisCodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QEucKrCodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QCP949Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QBig5Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QBig5hkscsCodec
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_BIG_CODECS&& !Q_OS_INTEGRITY
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_ICONV
argument_list|)
operator|(
name|void
operator|)
operator|new
name|QIconvCodec
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|(
name|void
operator|)
operator|new
name|QWindowsLocalCodec
expr_stmt|;
endif|#
directive|endif
comment|// Q_OS_WIN32
endif|#
directive|endif
comment|// !QT_NO_CODECS&& !QT_BOOTSTRAPPED
operator|(
name|void
operator|)
operator|new
name|QUtf16Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QUtf16BECodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QUtf16LECodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QUtf32Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QUtf32BECodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QUtf32LECodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QLatin15Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QLatin1Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QUtf8Codec
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|setup
specifier|static
name|void
name|setup
parameter_list|()
block|{}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_USE_ICU
end_comment
begin_comment
comment|/*!     \enum QTextCodec::ConversionFlag      \value DefaultConversion  No flag is set.     \value ConvertInvalidToNull  If this flag is set, each invalid input                                  character is output as a null character.     \value IgnoreHeader  Ignore any Unicode byte-order mark and don't generate any.      \omitvalue FreeFunction */
end_comment
begin_comment
comment|/*!     \fn QTextCodec::ConverterState::ConverterState(ConversionFlags flags)      Constructs a ConverterState object initialized with the given \a flags. */
end_comment
begin_comment
comment|/*!     Destroys the ConverterState object. */
end_comment
begin_destructor
DECL|function|~ConverterState
name|QTextCodec
operator|::
name|ConverterState
operator|::
name|~
name|ConverterState
parameter_list|()
block|{
if|if
condition|(
name|flags
operator|&
name|FreeFunction
condition|)
operator|(
name|QTextCodecUnalignedPointer
operator|::
name|decode
argument_list|(
name|state_data
argument_list|)
operator|)
operator|(
name|this
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
condition|)
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \class QTextCodec     \inmodule QtCore     \brief The QTextCodec class provides conversions between text encodings.     \reentrant     \ingroup i18n      Qt uses Unicode to store, draw and manipulate strings. In many     situations you may wish to deal with data that uses a different     encoding. For example, most Japanese documents are still stored     in Shift-JIS or ISO 2022-JP, while Russian users often have their     documents in KOI8-R or Windows-1251.      Qt provides a set of QTextCodec classes to help with converting     non-Unicode formats to and from Unicode. You can also create your     own codec classes.      The supported encodings are:      \list     \li Apple Roman     \li \l{Big5 Text Codec}{Big5}     \li \l{Big5-HKSCS Text Codec}{Big5-HKSCS}     \li CP949     \li \l{EUC-JP Text Codec}{EUC-JP}     \li \l{EUC-KR Text Codec}{EUC-KR}     \li \l{GBK Text Codec}{GB18030-0}     \li IBM 850     \li IBM 866     \li IBM 874     \li \l{ISO 2022-JP (JIS) Text Codec}{ISO 2022-JP}     \li ISO 8859-1 to 10     \li ISO 8859-13 to 16     \li Iscii-Bng, Dev, Gjr, Knd, Mlm, Ori, Pnj, Tlg, and Tml     \li JIS X 0201     \li JIS X 0208     \li KOI8-R     \li KOI8-U     \li \l{Shift-JIS Text Codec}{Shift-JIS}     \li TIS-620     \li \l{TSCII Text Codec}{TSCII}     \li UTF-8     \li UTF-16     \li UTF-16BE     \li UTF-16LE     \li UTF-32     \li UTF-32BE     \li UTF-32LE     \li Windows-1250 to 1258     \endlist      If Qt is compiled with ICU support enabled, most codecs supported by     ICU will also be available to the application.      QTextCodecs can be used as follows to convert some locally encoded     string to Unicode. Suppose you have some string encoded in Russian     KOI8-R encoding, and want to convert it to Unicode. The simple way     to do it is like this:      \snippet code/src_corelib_codecs_qtextcodec.cpp 0      After this, \c string holds the text converted to Unicode.     Converting a string from Unicode to the local encoding is just as     easy:      \snippet code/src_corelib_codecs_qtextcodec.cpp 1      To read or write files in various encodings, use QTextStream and     its \l{QTextStream::setCodec()}{setCodec()} function. See the     \l{tools/codecs}{Codecs} example for an application of QTextCodec     to file I/O.      Some care must be taken when trying to convert the data in chunks,     for example, when receiving it over a network. In such cases it is     possible that a multi-byte character will be split over two     chunks. At best this might result in the loss of a character and     at worst cause the entire conversion to fail.      The approach to use in these situations is to create a QTextDecoder     object for the codec and use this QTextDecoder for the whole     decoding process, as shown below:      \snippet code/src_corelib_codecs_qtextcodec.cpp 2      The QTextDecoder object maintains state between chunks and therefore     works correctly even if a multi-byte character is split between     chunks.      \section1 Creating Your Own Codec Class      Support for new text encodings can be added to Qt by creating     QTextCodec subclasses.      The pure virtual functions describe the encoder to the system and     the coder is used as required in the different text file formats     supported by QTextStream, and under X11, for the locale-specific     character input and output.      To add support for another encoding to Qt, make a subclass of     QTextCodec and implement the functions listed in the table below.      \table     \header \li Function \li Description      \row \li name()          \li Returns the official name for the encoding. If the             encoding is listed in the             \l{IANA character-sets encoding file}, the name             should be the preferred MIME name for the encoding.      \row \li aliases()          \li Returns a list of alternative names for the encoding.             QTextCodec provides a default implementation that returns             an empty list. For example, "ISO-8859-1" has "latin1",             "CP819", "IBM819", and "iso-ir-100" as aliases.      \row \li mibEnum()          \li Return the MIB enum for the encoding if it is listed in             the \l{IANA character-sets encoding file}.      \row \li convertToUnicode()          \li Converts an 8-bit character string to Unicode.      \row \li convertFromUnicode()          \li Converts a Unicode string to an 8-bit character string.     \endtable      \sa QTextStream, QTextDecoder, QTextEncoder, {Codecs Example} */
end_comment
begin_comment
comment|/*!     Constructs a QTextCodec, and gives it the highest precedence. The     QTextCodec should always be constructed on the heap (i.e. with \c     new). Qt takes ownership and will delete it when the application     terminates. */
end_comment
begin_constructor
DECL|function|QTextCodec
name|QTextCodec
operator|::
name|QTextCodec
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
operator|->
name|allCodecs
operator|.
name|prepend
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \nonreentrant      Destroys the QTextCodec. Note that you should not delete codecs     yourself: once created they become Qt's responsibility. */
end_comment
begin_destructor
DECL|function|~QTextCodec
name|QTextCodec
operator|::
name|~
name|QTextCodec
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \fn QTextCodec *QTextCodec::codecForName(const char *name)      Searches all installed QTextCodec objects and returns the one     which best matches \a name; the match is case-insensitive. Returns     0 if no codec matching the name \a name could be found. */
end_comment
begin_comment
comment|/*!     \threadsafe     Searches all installed QTextCodec objects and returns the one     which best matches \a name; the match is case-insensitive. Returns     0 if no codec matching the name \a name could be found. */
end_comment
begin_function
DECL|function|codecForName
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForName
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
name|QCoreGlobalData
modifier|*
name|globalData
init|=
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|globalData
condition|)
return|return
literal|0
return|;
name|setup
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_USE_ICU
name|QTextCodecCache
modifier|*
name|cache
init|=
operator|&
name|globalData
operator|->
name|codecCache
decl_stmt|;
name|QTextCodec
modifier|*
name|codec
decl_stmt|;
if|if
condition|(
name|cache
condition|)
block|{
name|codec
operator|=
name|cache
operator|->
name|value
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
condition|)
return|return
name|codec
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|globalData
operator|->
name|allCodecs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTextCodec
modifier|*
name|cursor
init|=
name|globalData
operator|->
name|allCodecs
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|qTextCodecNameMatch
argument_list|(
name|cursor
operator|->
name|name
argument_list|()
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|cache
condition|)
name|cache
operator|->
name|insert
argument_list|(
name|name
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|aliases
init|=
name|cursor
operator|->
name|aliases
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|aliases
operator|.
name|size
argument_list|()
condition|;
operator|++
name|y
control|)
if|if
condition|(
name|qTextCodecNameMatch
argument_list|(
name|aliases
operator|.
name|at
argument_list|(
name|y
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|cache
condition|)
name|cache
operator|->
name|insert
argument_list|(
name|name
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
block|}
return|return
literal|0
return|;
else|#
directive|else
return|return
name|QIcuCodec
operator|::
name|codecForNameUnlocked
argument_list|(
name|name
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \threadsafe     Returns the QTextCodec which matches the     \l{QTextCodec::mibEnum()}{MIBenum} \a mib. */
end_comment
begin_function
DECL|function|codecForMib
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForMib
parameter_list|(
name|int
name|mib
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
name|QCoreGlobalData
modifier|*
name|globalData
init|=
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|globalData
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|globalData
operator|->
name|allCodecs
operator|.
name|isEmpty
argument_list|()
condition|)
name|setup
argument_list|()
expr_stmt|;
name|QByteArray
name|key
init|=
literal|"MIB: "
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|mib
argument_list|)
decl_stmt|;
name|QTextCodecCache
modifier|*
name|cache
init|=
operator|&
name|globalData
operator|->
name|codecCache
decl_stmt|;
name|QTextCodec
modifier|*
name|codec
decl_stmt|;
if|if
condition|(
name|cache
condition|)
block|{
name|codec
operator|=
name|cache
operator|->
name|value
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
condition|)
return|return
name|codec
return|;
block|}
name|QList
argument_list|<
name|QTextCodec
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|i
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|globalData
operator|->
name|allCodecs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTextCodec
modifier|*
name|cursor
init|=
name|globalData
operator|->
name|allCodecs
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cursor
operator|->
name|mibEnum
argument_list|()
operator|==
name|mib
condition|)
block|{
if|if
condition|(
name|cache
condition|)
name|cache
operator|->
name|insert
argument_list|(
name|key
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|QT_USE_ICU
return|return
name|QIcuCodec
operator|::
name|codecForMibUnlocked
argument_list|(
name|mib
argument_list|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \threadsafe     Returns the list of all available codecs, by name. Call     QTextCodec::codecForName() to obtain the QTextCodec for the name.      The list may contain many mentions of the same codec     if the codec has aliases.      \sa availableMibs(), name(), aliases() */
end_comment
begin_function
DECL|function|availableCodecs
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QTextCodec
operator|::
name|availableCodecs
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_USE_ICU
return|return
name|QIcuCodec
operator|::
name|availableCodecs
argument_list|()
return|;
else|#
directive|else
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
name|QCoreGlobalData
modifier|*
name|globalData
init|=
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
name|globalData
operator|->
name|allCodecs
operator|.
name|isEmpty
argument_list|()
condition|)
name|setup
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|codecs
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|globalData
operator|->
name|allCodecs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|codecs
operator|+=
name|globalData
operator|->
name|allCodecs
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|name
argument_list|()
expr_stmt|;
name|codecs
operator|+=
name|globalData
operator|->
name|allCodecs
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|aliases
argument_list|()
expr_stmt|;
block|}
return|return
name|codecs
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \threadsafe     Returns the list of MIBs for all available codecs. Call     QTextCodec::codecForMib() to obtain the QTextCodec for the MIB.      \sa availableCodecs(), mibEnum() */
end_comment
begin_function
DECL|function|availableMibs
name|QList
argument_list|<
name|int
argument_list|>
name|QTextCodec
operator|::
name|availableMibs
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_USE_ICU
return|return
name|QIcuCodec
operator|::
name|availableMibs
argument_list|()
return|;
else|#
directive|else
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
name|QCoreGlobalData
modifier|*
name|globalData
init|=
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
name|globalData
operator|->
name|allCodecs
operator|.
name|isEmpty
argument_list|()
condition|)
name|setup
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|codecs
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|globalData
operator|->
name|allCodecs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|codecs
operator|+=
name|globalData
operator|->
name|allCodecs
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|mibEnum
argument_list|()
expr_stmt|;
return|return
name|codecs
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \nonreentrant      Set the codec to \a c; this will be returned by     codecForLocale(). If \a c is a null pointer, the codec is reset to     the default.      This might be needed for some applications that want to use their     own mechanism for setting the locale.      \sa codecForLocale() */
end_comment
begin_function
DECL|function|setCodecForLocale
name|void
name|QTextCodec
operator|::
name|setCodecForLocale
parameter_list|(
name|QTextCodec
modifier|*
name|c
parameter_list|)
block|{
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
operator|->
name|codecForLocale
operator|.
name|storeRelease
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \threadsafe     Returns a pointer to the codec most suitable for this locale.      On Windows, the codec will be based on a system locale. On Unix     systems, the codec will might fall back to using the \e iconv     library if no builtin codec for the locale can be found.      Note that in these cases the codec's name will be "System". */
end_comment
begin_function
DECL|function|codecForLocale
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForLocale
parameter_list|()
block|{
name|QCoreGlobalData
modifier|*
name|globalData
init|=
name|QCoreGlobalData
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|globalData
condition|)
return|return
literal|0
return|;
name|QTextCodec
modifier|*
name|codec
init|=
name|globalData
operator|->
name|codecForLocale
operator|.
name|loadAcquire
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|codec
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_USE_ICU
name|textCodecsMutex
argument_list|()
operator|->
name|lock
argument_list|()
expr_stmt|;
name|codec
operator|=
name|QIcuCodec
operator|::
name|defaultCodecUnlocked
argument_list|()
expr_stmt|;
name|textCodecsMutex
argument_list|()
operator|->
name|unlock
argument_list|()
expr_stmt|;
else|#
directive|else
comment|// setupLocaleMapper locks as necessary
name|codec
operator|=
name|setupLocaleMapper
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|codec
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray QTextCodec::name() const      QTextCodec subclasses must reimplement this function. It returns     the name of the encoding supported by the subclass.      If the codec is registered as a character set in the     \l{IANA character-sets encoding file} this method should     return the preferred mime name for the codec if defined,     otherwise its name. */
end_comment
begin_comment
comment|/*!     \fn int QTextCodec::mibEnum() const      Subclasses of QTextCodec must reimplement this function. It     returns the MIBenum (see \l{IANA character-sets encoding file}     for more information). It is important that each QTextCodec     subclass returns the correct unique value for this function. */
end_comment
begin_comment
comment|/*!   Subclasses can return a number of aliases for the codec in question.    Standard aliases for codecs can be found in the   \l{IANA character-sets encoding file}. */
end_comment
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QTextCodec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QTextCodec::convertToUnicode(const char *chars, int len,                                              ConverterState *state) const      QTextCodec subclasses must reimplement this function.      Converts the first \a len characters of \a chars from the     encoding of the subclass to Unicode, and returns the result in a     QString.      \a state can be 0, in which case the conversion is stateless and     default conversion rules should be used. If state is not 0, the     codec should save the state after the conversion in \a state, and     adjust the remainingChars and invalidChars members of the struct. */
end_comment
begin_comment
comment|/*!     \fn QByteArray QTextCodec::convertFromUnicode(const QChar *input, int number,                                                   ConverterState *state) const      QTextCodec subclasses must reimplement this function.      Converts the first \a number of characters from the \a input array     from Unicode to the encoding of the subclass, and returns the result     in a QByteArray.      \a state can be 0 in which case the conversion is stateless and     default conversion rules should be used. If state is not 0, the     codec should save the state after the conversion in \a state, and     adjust the remainingChars and invalidChars members of the struct. */
end_comment
begin_comment
comment|/*!     Creates a QTextDecoder with a specified \a flags to decode chunks     of \c{char *} data to create chunks of Unicode data.      The caller is responsible for deleting the returned object.      \since 4.7 */
end_comment
begin_function
DECL|function|makeDecoder
name|QTextDecoder
modifier|*
name|QTextCodec
operator|::
name|makeDecoder
parameter_list|(
name|QTextCodec
operator|::
name|ConversionFlags
name|flags
parameter_list|)
specifier|const
block|{
return|return
operator|new
name|QTextDecoder
argument_list|(
name|this
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a QTextEncoder with a specified \a flags to encode chunks     of Unicode data as \c{char *} data.      The caller is responsible for deleting the returned object.      \since 4.7 */
end_comment
begin_function
DECL|function|makeEncoder
name|QTextEncoder
modifier|*
name|QTextCodec
operator|::
name|makeEncoder
parameter_list|(
name|QTextCodec
operator|::
name|ConversionFlags
name|flags
parameter_list|)
specifier|const
block|{
return|return
operator|new
name|QTextEncoder
argument_list|(
name|this
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray QTextCodec::fromUnicode(const QChar *input, int number,                                            ConverterState *state) const      Converts the first \a number of characters from the \a input array     from Unicode to the encoding of this codec, and returns the result     in a QByteArray.      The \a state of the convertor used is updated. */
end_comment
begin_comment
comment|/*!     Converts \a str from Unicode to the encoding of this codec, and     returns the result in a QByteArray. */
end_comment
begin_function
DECL|function|fromUnicode
name|QByteArray
name|QTextCodec
operator|::
name|fromUnicode
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
specifier|const
block|{
return|return
name|convertFromUnicode
argument_list|(
name|str
operator|.
name|constData
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QTextCodec::toUnicode(const char *input, int size,                                       ConverterState *state) const      Converts the first \a size characters from the \a input from the     encoding of this codec to Unicode, and returns the result in a     QString.      The \a state of the convertor used is updated. */
end_comment
begin_comment
comment|/*!     Converts \a a from the encoding of this codec to Unicode, and     returns the result in a QString. */
end_comment
begin_function
DECL|function|toUnicode
name|QString
name|QTextCodec
operator|::
name|toUnicode
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|a
parameter_list|)
specifier|const
block|{
return|return
name|convertToUnicode
argument_list|(
name|a
operator|.
name|constData
argument_list|()
argument_list|,
name|a
operator|.
name|length
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the Unicode character \a ch can be fully encoded     with this codec; otherwise returns false. */
end_comment
begin_function
DECL|function|canEncode
name|bool
name|QTextCodec
operator|::
name|canEncode
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
block|{
name|ConverterState
name|state
decl_stmt|;
name|state
operator|.
name|flags
operator|=
name|ConvertInvalidToNull
expr_stmt|;
name|convertFromUnicode
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|state
operator|.
name|invalidChars
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \a s contains the string being tested for encode-ability. */
end_comment
begin_function
DECL|function|canEncode
name|bool
name|QTextCodec
operator|::
name|canEncode
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
specifier|const
block|{
name|ConverterState
name|state
decl_stmt|;
name|state
operator|.
name|flags
operator|=
name|ConvertInvalidToNull
expr_stmt|;
name|convertFromUnicode
argument_list|(
name|s
operator|.
name|constData
argument_list|()
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|state
operator|.
name|invalidChars
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \a chars contains the source characters. */
end_comment
begin_function
DECL|function|toUnicode
name|QString
name|QTextCodec
operator|::
name|toUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|)
specifier|const
block|{
name|int
name|len
init|=
name|qstrlen
argument_list|(
name|chars
argument_list|)
decl_stmt|;
return|return
name|convertToUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \class QTextEncoder     \inmodule QtCore     \brief The QTextEncoder class provides a state-based encoder.     \reentrant     \ingroup i18n      A text encoder converts text from Unicode into an encoded text format     using a specific codec.      The encoder converts Unicode into another format, remembering any     state that is required between calls.      \sa QTextCodec::makeEncoder(), QTextDecoder */
end_comment
begin_comment
comment|/*!     \fn QTextEncoder::QTextEncoder(const QTextCodec *codec)      Constructs a text encoder for the given \a codec. */
end_comment
begin_comment
comment|/*!     Constructs a text encoder for the given \a codec and conversion \a flags.      \since 4.7 */
end_comment
begin_constructor
DECL|function|QTextEncoder
name|QTextEncoder
operator|::
name|QTextEncoder
parameter_list|(
specifier|const
name|QTextCodec
modifier|*
name|codec
parameter_list|,
name|QTextCodec
operator|::
name|ConversionFlags
name|flags
parameter_list|)
member_init_list|:
name|c
argument_list|(
name|codec
argument_list|)
member_init_list|,
name|state
argument_list|()
block|{
name|state
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the encoder. */
end_comment
begin_destructor
DECL|function|~QTextEncoder
name|QTextEncoder
operator|::
name|~
name|QTextEncoder
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \internal     \since 4.5     Determines whether the eecoder encountered a failure while decoding the input. If     an error was encountered, the produced result is undefined, and gets converted as according     to the conversion flags.  */
end_comment
begin_function
DECL|function|hasFailure
name|bool
name|QTextEncoder
operator|::
name|hasFailure
parameter_list|()
specifier|const
block|{
return|return
name|state
operator|.
name|invalidChars
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the Unicode string \a str into an encoded QByteArray. */
end_comment
begin_function
DECL|function|fromUnicode
name|QByteArray
name|QTextEncoder
operator|::
name|fromUnicode
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|QByteArray
name|result
init|=
name|c
operator|->
name|fromUnicode
argument_list|(
name|str
operator|.
name|constData
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|,
operator|&
name|state
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Converts \a len characters (not bytes) from \a uc, and returns the     result in a QByteArray. */
end_comment
begin_function
DECL|function|fromUnicode
name|QByteArray
name|QTextEncoder
operator|::
name|fromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|QByteArray
name|result
init|=
name|c
operator|->
name|fromUnicode
argument_list|(
name|uc
argument_list|,
name|len
argument_list|,
operator|&
name|state
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \class QTextDecoder     \inmodule QtCore     \brief The QTextDecoder class provides a state-based decoder.     \reentrant     \ingroup i18n      A text decoder converts text from an encoded text format into Unicode     using a specific codec.      The decoder converts text in this format into Unicode, remembering any     state that is required between calls.      \sa QTextCodec::makeDecoder(), QTextEncoder */
end_comment
begin_comment
comment|/*!     \fn QTextDecoder::QTextDecoder(const QTextCodec *codec)      Constructs a text decoder for the given \a codec. */
end_comment
begin_comment
comment|/*!     Constructs a text decoder for the given \a codec and conversion \a flags.      \since 4.7 */
end_comment
begin_constructor
DECL|function|QTextDecoder
name|QTextDecoder
operator|::
name|QTextDecoder
parameter_list|(
specifier|const
name|QTextCodec
modifier|*
name|codec
parameter_list|,
name|QTextCodec
operator|::
name|ConversionFlags
name|flags
parameter_list|)
member_init_list|:
name|c
argument_list|(
name|codec
argument_list|)
member_init_list|,
name|state
argument_list|()
block|{
name|state
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the decoder. */
end_comment
begin_destructor
DECL|function|~QTextDecoder
name|QTextDecoder
operator|::
name|~
name|QTextDecoder
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \fn QString QTextDecoder::toUnicode(const char *chars, int len)      Converts the first \a len bytes in \a chars to Unicode, returning     the result.      If not all characters are used (e.g. if only part of a multi-byte     encoding is at the end of the characters), the decoder remembers     enough state to continue with the next call to this function. */
end_comment
begin_function
DECL|function|toUnicode
name|QString
name|QTextDecoder
operator|::
name|toUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|c
operator|->
name|toUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
operator|&
name|state
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \overload      The converted string is returned in \a target.  */
end_comment
begin_function
DECL|function|toUnicode
name|void
name|QTextDecoder
operator|::
name|toUnicode
parameter_list|(
name|QString
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|target
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|mibEnum
argument_list|()
condition|)
block|{
case|case
literal|106
case|:
comment|// utf8
cast|static_cast
argument_list|<
specifier|const
name|QUtf8Codec
operator|*
argument_list|>
argument_list|(
name|c
argument_list|)
operator|->
name|convertToUnicode
argument_list|(
name|target
argument_list|,
name|chars
argument_list|,
name|len
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
block|{
comment|// latin1
name|target
operator|->
name|resize
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ushort
modifier|*
name|data
init|=
operator|(
name|ushort
operator|*
operator|)
name|target
operator|->
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|len
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|data
index|[
name|i
index|]
operator|=
operator|(
name|uchar
operator|)
name|chars
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
default|default:
operator|*
name|target
operator|=
name|c
operator|->
name|toUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Converts the bytes in the byte array specified by \a ba to Unicode     and returns the result. */
end_comment
begin_function
DECL|function|toUnicode
name|QString
name|QTextDecoder
operator|::
name|toUnicode
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
return|return
name|c
operator|->
name|toUnicode
argument_list|(
name|ba
operator|.
name|constData
argument_list|()
argument_list|,
name|ba
operator|.
name|length
argument_list|()
argument_list|,
operator|&
name|state
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Tries to detect the encoding of the provided snippet of HTML in     the given byte array, \a ba, by checking the BOM (Byte Order Mark)     and the content-type meta header and returns a QTextCodec instance     that is capable of decoding the html to unicode.  If the codec     cannot be detected from the content provided, \a defaultCodec is     returned.      \sa codecForUtfText() */
end_comment
begin_function
DECL|function|codecForHtml
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForHtml
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|,
name|QTextCodec
modifier|*
name|defaultCodec
parameter_list|)
block|{
comment|// determine charset
name|QTextCodec
modifier|*
name|c
init|=
name|QTextCodec
operator|::
name|codecForUtfText
argument_list|(
name|ba
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|QByteArray
name|header
init|=
name|ba
operator|.
name|left
argument_list|(
literal|512
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|header
operator|.
name|indexOf
argument_list|(
literal|"meta "
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
name|pos
operator|=
name|header
operator|.
name|indexOf
argument_list|(
literal|"charset="
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
name|pos
operator|+=
name|qstrlen
argument_list|(
literal|"charset="
argument_list|)
expr_stmt|;
name|int
name|pos2
init|=
name|pos
decl_stmt|;
comment|// The attribute can be closed with either """, "'", ">" or "/",
comment|// none of which are valid charset characters.
while|while
condition|(
operator|++
name|pos2
operator|<
name|header
operator|.
name|size
argument_list|()
condition|)
block|{
name|char
name|ch
init|=
name|header
operator|.
name|at
argument_list|(
name|pos2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\"'
operator|||
name|ch
operator|==
literal|'\''
operator|||
name|ch
operator|==
literal|'>'
condition|)
block|{
name|c
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|header
operator|.
name|mid
argument_list|(
name|pos
argument_list|,
name|pos2
operator|-
name|pos
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c
condition|?
name|c
else|:
name|defaultCodec
return|;
block|}
block|}
block|}
block|}
block|}
return|return
name|defaultCodec
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Tries to detect the encoding of the provided snippet of HTML in     the given byte array, \a ba, by checking the BOM (Byte Order Mark)     and the content-type meta header and returns a QTextCodec instance     that is capable of decoding the html to unicode. If the codec cannot     be detected, this overload returns a Latin-1 QTextCodec. */
end_comment
begin_function
DECL|function|codecForHtml
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForHtml
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
return|return
name|codecForHtml
argument_list|(
name|ba
argument_list|,
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Tries to detect the encoding of the provided snippet \a ba by     using the BOM (Byte Order Mark) and returns a QTextCodec instance     that is capable of decoding the text to unicode. If the codec     cannot be detected from the content provided, \a defaultCodec is     returned.      \sa codecForHtml() */
end_comment
begin_function
DECL|function|codecForUtfText
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForUtfText
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|,
name|QTextCodec
modifier|*
name|defaultCodec
parameter_list|)
block|{
specifier|const
name|int
name|arraySize
init|=
name|ba
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|arraySize
operator|>
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|uchar
operator|)
name|ba
index|[
literal|0
index|]
operator|==
literal|0x00
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|1
index|]
operator|==
literal|0x00
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|2
index|]
operator|==
literal|0xFE
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|3
index|]
operator|==
literal|0xFF
condition|)
return|return
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
literal|1018
argument_list|)
return|;
comment|// utf-32 be
elseif|else
if|if
condition|(
operator|(
name|uchar
operator|)
name|ba
index|[
literal|0
index|]
operator|==
literal|0xFF
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|1
index|]
operator|==
literal|0xFE
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|2
index|]
operator|==
literal|0x00
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|3
index|]
operator|==
literal|0x00
condition|)
return|return
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
literal|1019
argument_list|)
return|;
comment|// utf-32 le
block|}
if|if
condition|(
name|arraySize
operator|<
literal|2
condition|)
return|return
name|defaultCodec
return|;
if|if
condition|(
operator|(
name|uchar
operator|)
name|ba
index|[
literal|0
index|]
operator|==
literal|0xfe
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|1
index|]
operator|==
literal|0xff
condition|)
return|return
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
literal|1013
argument_list|)
return|;
comment|// utf16 be
elseif|else
if|if
condition|(
operator|(
name|uchar
operator|)
name|ba
index|[
literal|0
index|]
operator|==
literal|0xff
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|1
index|]
operator|==
literal|0xfe
condition|)
return|return
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
literal|1014
argument_list|)
return|;
comment|// utf16 le
if|if
condition|(
name|arraySize
operator|<
literal|3
condition|)
return|return
name|defaultCodec
return|;
if|if
condition|(
operator|(
name|uchar
operator|)
name|ba
index|[
literal|0
index|]
operator|==
literal|0xef
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|1
index|]
operator|==
literal|0xbb
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|2
index|]
operator|==
literal|0xbf
condition|)
return|return
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
literal|106
argument_list|)
return|;
comment|// utf-8
return|return
name|defaultCodec
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Tries to detect the encoding of the provided snippet \a ba by     using the BOM (Byte Order Mark) and returns a QTextCodec instance     that is capable of decoding the text to unicode. If the codec     cannot be detected, this overload returns a Latin-1 QTextCodec.      \sa codecForHtml() */
end_comment
begin_function
DECL|function|codecForUtfText
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForUtfText
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
return|return
name|codecForUtfText
argument_list|(
name|ba
argument_list|,
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
comment|/*Latin 1*/
literal|4
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.3     Determines whether the decoder encountered a failure while decoding the input. If     an error was encountered, the produced result is undefined, and gets converted as according     to the conversion flags.  */
end_comment
begin_function
DECL|function|hasFailure
name|bool
name|QTextDecoder
operator|::
name|hasFailure
parameter_list|()
specifier|const
block|{
return|return
name|state
operator|.
name|invalidChars
operator|!=
literal|0
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTCODEC
end_comment
end_unit
