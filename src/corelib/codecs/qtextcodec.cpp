begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qtextcodec.h"
end_include
begin_include
include|#
directive|include
file|"qtextcodec_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
end_ifndef
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
end_ifndef
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qtextcodecplugin.h"
end_include
begin_include
include|#
directive|include
file|"private/qfactoryloader_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|"qiconvcodec_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qutfcodec_p.h"
end_include
begin_include
include|#
directive|include
file|"qsimplecodec_p.h"
end_include
begin_include
include|#
directive|include
file|"qlatincodec_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CODECS
end_ifndef
begin_include
include|#
directive|include
file|"qtsciicodec_p.h"
end_include
begin_include
include|#
directive|include
file|"qisciicodec_p.h"
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_INTEGRITY
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_ICONV
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
end_if
begin_comment
comment|// no iconv(3) support, must build all codecs into the library
end_comment
begin_include
include|#
directive|include
file|"../../plugins/codecs/cn/qgb18030codec.h"
end_include
begin_include
include|#
directive|include
file|"../../plugins/codecs/jp/qeucjpcodec.h"
end_include
begin_include
include|#
directive|include
file|"../../plugins/codecs/jp/qjiscodec.h"
end_include
begin_include
include|#
directive|include
file|"../../plugins/codecs/jp/qsjiscodec.h"
end_include
begin_include
include|#
directive|include
file|"../../plugins/codecs/kr/qeuckrcodec.h"
end_include
begin_include
include|#
directive|include
file|"../../plugins/codecs/tw/qbig5codec.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_ICONV
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qfontlaocodec_p.h"
end_include
begin_include
include|#
directive|include
file|"../../plugins/codecs/jp/qfontjpcodec.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_SYMBIAN
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CODECS
end_comment
begin_include
include|#
directive|include
file|"qlocale.h"
end_include
begin_include
include|#
directive|include
file|"qmutex.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<locale.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_XOPEN_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_OSF
argument_list|)
end_if
begin_include
include|#
directive|include
file|<langinfo.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_SETLOCALE
define|#
directive|define
name|QT_NO_SETLOCALE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
end_ifdef
begin_include
include|#
directive|include
file|"qtextcodec_symbian.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// enabling this is not exception safe!
end_comment
begin_comment
comment|// #define Q_DEBUG_TEXTCODEC
end_comment
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_LIBRARY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_TEXTCODECPLUGIN
argument_list|)
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
name|QFactoryLoader
argument_list|,
name|loader
argument_list|,
operator|(
name|QTextCodecFactoryInterface_iid
operator|,
name|QLatin1String
argument_list|(
literal|"/codecs"
argument_list|)
operator|)
argument_list|)
endif|#
directive|endif
comment|//Cache for QTextCodec::codecForName and codecForMib.
decl|typedef
DECL|typedef|QTextCodecCache
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QTextCodec
modifier|*
argument_list|>
name|QTextCodecCache
decl_stmt|;
end_decl_stmt
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QTextCodecCache
argument_list|,
argument|qTextCodecCache
argument_list|)
end_macro
begin_function
DECL|function|qtolower
specifier|static
name|char
name|qtolower
parameter_list|(
specifier|register
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
return|return
name|c
operator|+
literal|0x20
return|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|qisalnum
specifier|static
name|bool
name|qisalnum
parameter_list|(
specifier|register
name|char
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
operator|(
name|c
operator||
literal|0x20
operator|)
operator|>=
literal|'a'
operator|&&
operator|(
name|c
operator||
literal|0x20
operator|)
operator|<=
literal|'z'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|nameMatch
specifier|static
name|bool
name|nameMatch
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|test
parameter_list|)
block|{
comment|// if they're the same, return a perfect score
if|if
condition|(
name|qstricmp
argument_list|(
name|name
argument_list|,
name|test
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|true
return|;
specifier|const
name|char
modifier|*
name|n
init|=
name|name
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|h
init|=
name|test
operator|.
name|constData
argument_list|()
decl_stmt|;
comment|// if the letters and numbers are the same, we have a match
while|while
condition|(
operator|*
name|n
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|qisalnum
argument_list|(
operator|*
name|n
argument_list|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|h
operator|==
literal|'\0'
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|qisalnum
argument_list|(
operator|*
name|h
argument_list|)
condition|)
break|break;
operator|++
name|h
expr_stmt|;
block|}
if|if
condition|(
name|qtolower
argument_list|(
operator|*
name|n
argument_list|)
operator|!=
name|qtolower
argument_list|(
operator|*
name|h
argument_list|)
condition|)
return|return
literal|false
return|;
operator|++
name|h
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|h
operator|&&
operator|!
name|qisalnum
argument_list|(
operator|*
name|h
argument_list|)
condition|)
operator|++
name|h
expr_stmt|;
return|return
operator|(
operator|*
name|h
operator|==
literal|'\0'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|createForName
specifier|static
name|QTextCodec
modifier|*
name|createForName
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_LIBRARY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_TEXTCODECPLUGIN
argument_list|)
name|QFactoryLoader
modifier|*
name|l
init|=
name|loader
argument_list|()
decl_stmt|;
name|QStringList
name|keys
init|=
name|l
operator|->
name|keys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|nameMatch
argument_list|(
name|name
argument_list|,
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLatin1
argument_list|()
argument_list|)
condition|)
block|{
name|QString
name|realName
init|=
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|QTextCodecFactoryInterface
modifier|*
name|factory
init|=
name|qobject_cast
argument_list|<
name|QTextCodecFactoryInterface
operator|*
argument_list|>
argument_list|(
name|l
operator|->
name|instance
argument_list|(
name|realName
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|factory
operator|->
name|create
argument_list|(
name|realName
argument_list|)
return|;
block|}
block|}
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|createForMib
specifier|static
name|QTextCodec
modifier|*
name|createForMib
parameter_list|(
name|int
name|mib
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODECPLUGIN
name|QString
name|name
init|=
name|QLatin1String
argument_list|(
literal|"MIB: "
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|mib
argument_list|)
decl_stmt|;
if|if
condition|(
name|QTextCodecFactoryInterface
modifier|*
name|factory
init|=
name|qobject_cast
argument_list|<
name|QTextCodecFactoryInterface
operator|*
argument_list|>
argument_list|(
name|loader
argument_list|()
operator|->
name|instance
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
return|return
name|factory
operator|->
name|create
argument_list|(
name|name
argument_list|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|mib
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|all
specifier|static
name|QList
argument_list|<
name|QTextCodec
modifier|*
argument_list|>
modifier|*
name|all
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|Q_DEBUG_TEXTCODEC
end_ifdef
begin_decl_stmt
DECL|variable|destroying_is_ok
specifier|static
name|bool
name|destroying_is_ok
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|localeMapper
specifier|static
name|QTextCodec
modifier|*
name|localeMapper
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|cftr
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|cftr
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_class
DECL|class|QTextCodecCleanup
class|class
name|QTextCodecCleanup
block|{
public|public:
name|~
name|QTextCodecCleanup
parameter_list|()
destructor_decl|;
block|}
class|;
end_class
begin_comment
comment|/*     Deletes all the created codecs. This destructor is called just     before exiting to delete any QTextCodec objects that may be lying     around. */
end_comment
begin_destructor
DECL|function|~QTextCodecCleanup
name|QTextCodecCleanup
operator|::
name|~
name|QTextCodecCleanup
parameter_list|()
block|{
if|if
condition|(
operator|!
name|all
condition|)
return|return;
ifdef|#
directive|ifdef
name|Q_DEBUG_TEXTCODEC
name|destroying_is_ok
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
name|QList
argument_list|<
name|QTextCodec
modifier|*
argument_list|>
modifier|*
name|myAll
init|=
name|all
decl_stmt|;
name|all
operator|=
literal|0
expr_stmt|;
comment|// Otherwise the d'tor destroys the iterator
for|for
control|(
name|QList
argument_list|<
name|QTextCodec
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|myAll
operator|->
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|myAll
operator|->
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
operator|delete
operator|*
name|it
expr_stmt|;
block|}
operator|delete
name|myAll
expr_stmt|;
name|localeMapper
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_DEBUG_TEXTCODEC
name|destroying_is_ok
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QTextCodecCleanup
argument_list|,
argument|createQTextCodecCleanup
argument_list|)
end_macro
begin_function
DECL|function|validCodecs
name|bool
name|QTextCodec
operator|::
name|validCodecs
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
comment|// If we don't have a trap handler, we're outside of the main() function,
comment|// ie. in global constructors or destructors. Don't use codecs in this
comment|// case as it would lead to crashes because we don't have a cleanup stack on Symbian
return|return
operator|(
name|User
operator|::
name|TrapHandler
argument_list|()
operator|!=
name|NULL
operator|)
return|;
else|#
directive|else
return|return
literal|true
return|;
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_class
DECL|class|QWindowsLocalCodec
class|class
name|QWindowsLocalCodec
super|:
specifier|public
name|QTextCodec
block|{
public|public:
name|QWindowsLocalCodec
parameter_list|()
constructor_decl|;
name|~
name|QWindowsLocalCodec
parameter_list|()
destructor_decl|;
name|QString
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|ConverterState
modifier|*
parameter_list|)
specifier|const
function_decl|;
name|QByteArray
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
parameter_list|,
name|int
parameter_list|,
name|ConverterState
modifier|*
parameter_list|)
specifier|const
function_decl|;
name|QString
name|convertToUnicodeCharByChar
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|length
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
function_decl|;
name|QByteArray
name|name
parameter_list|()
specifier|const
function_decl|;
name|int
name|mibEnum
parameter_list|()
specifier|const
function_decl|;
block|}
class|;
end_class
begin_constructor
DECL|function|QWindowsLocalCodec
name|QWindowsLocalCodec
operator|::
name|QWindowsLocalCodec
parameter_list|()
block|{ }
end_constructor
begin_destructor
DECL|function|~QWindowsLocalCodec
name|QWindowsLocalCodec
operator|::
name|~
name|QWindowsLocalCodec
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|convertToUnicode
name|QString
name|QWindowsLocalCodec
operator|::
name|convertToUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|length
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
specifier|const
name|char
modifier|*
name|mb
init|=
name|chars
decl_stmt|;
name|int
name|mblen
init|=
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|mb
operator|||
operator|!
name|mblen
condition|)
return|return
name|QString
argument_list|()
return|;
specifier|const
name|int
name|wclen_auto
init|=
literal|4096
decl_stmt|;
name|wchar_t
name|wc_auto
index|[
name|wclen_auto
index|]
decl_stmt|;
name|int
name|wclen
init|=
name|wclen_auto
decl_stmt|;
name|wchar_t
modifier|*
name|wc
init|=
name|wc_auto
decl_stmt|;
name|int
name|len
decl_stmt|;
name|QString
name|sp
decl_stmt|;
name|bool
name|prepend
init|=
literal|false
decl_stmt|;
name|char
name|state_data
init|=
literal|0
decl_stmt|;
name|int
name|remainingChars
init|=
literal|0
decl_stmt|;
comment|//save the current state information
if|if
condition|(
name|state
condition|)
block|{
name|state_data
operator|=
operator|(
name|char
operator|)
name|state
operator|->
name|state_data
index|[
literal|0
index|]
expr_stmt|;
name|remainingChars
operator|=
name|state
operator|->
name|remainingChars
expr_stmt|;
block|}
comment|//convert the pending charcter (if available)
if|if
condition|(
name|state
operator|&&
name|remainingChars
condition|)
block|{
name|char
name|prev
index|[
literal|3
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|prev
index|[
literal|0
index|]
operator|=
name|state_data
expr_stmt|;
name|prev
index|[
literal|1
index|]
operator|=
name|mb
index|[
literal|0
index|]
expr_stmt|;
name|remainingChars
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|MultiByteToWideChar
argument_list|(
name|CP_ACP
argument_list|,
name|MB_PRECOMPOSED
argument_list|,
name|prev
argument_list|,
literal|2
argument_list|,
name|wc
argument_list|,
name|wclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|prepend
operator|=
literal|true
expr_stmt|;
name|sp
operator|.
name|append
argument_list|(
name|QChar
argument_list|(
name|wc
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|mb
operator|++
expr_stmt|;
name|mblen
operator|--
expr_stmt|;
name|wc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
operator|(
name|len
operator|=
name|MultiByteToWideChar
argument_list|(
name|CP_ACP
argument_list|,
name|MB_PRECOMPOSED
operator||
name|MB_ERR_INVALID_CHARS
argument_list|,
name|mb
argument_list|,
name|mblen
argument_list|,
name|wc
argument_list|,
name|wclen
argument_list|)
operator|)
condition|)
block|{
name|int
name|r
init|=
name|GetLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|ERROR_INSUFFICIENT_BUFFER
condition|)
block|{
if|if
condition|(
name|wc
operator|!=
name|wc_auto
condition|)
block|{
name|qWarning
argument_list|(
literal|"MultiByteToWideChar: Size changed"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|wclen
operator|=
name|MultiByteToWideChar
argument_list|(
name|CP_ACP
argument_list|,
name|MB_PRECOMPOSED
argument_list|,
name|mb
argument_list|,
name|mblen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wc
operator|=
operator|new
name|wchar_t
index|[
name|wclen
index|]
expr_stmt|;
comment|// and try again...
block|}
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|ERROR_NO_UNICODE_TRANSLATION
condition|)
block|{
comment|//find the last non NULL character
while|while
condition|(
name|mblen
operator|>
literal|1
operator|&&
operator|!
operator|(
name|mb
index|[
name|mblen
operator|-
literal|1
index|]
operator|)
condition|)
name|mblen
operator|--
expr_stmt|;
comment|//check whether,  we hit an invalid character in the middle
if|if
condition|(
operator|(
name|mblen
operator|<=
literal|1
operator|)
operator|||
operator|(
name|remainingChars
operator|&&
name|state_data
operator|)
condition|)
return|return
name|convertToUnicodeCharByChar
argument_list|(
name|chars
argument_list|,
name|length
argument_list|,
name|state
argument_list|)
return|;
comment|//Remove the last character and try again...
name|state_data
operator|=
name|mb
index|[
name|mblen
operator|-
literal|1
index|]
expr_stmt|;
name|remainingChars
operator|=
literal|1
expr_stmt|;
name|mblen
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|// Fail.
name|qWarning
argument_list|(
literal|"MultiByteToWideChar: Cannot convert multibyte text"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|wc
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
comment|// len - 1: we don't want terminator
operator|--
name|len
expr_stmt|;
comment|//save the new state information
if|if
condition|(
name|state
condition|)
block|{
name|state
operator|->
name|state_data
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|state_data
expr_stmt|;
name|state
operator|->
name|remainingChars
operator|=
name|remainingChars
expr_stmt|;
block|}
name|QString
name|s
argument_list|(
operator|(
name|QChar
operator|*
operator|)
name|wc
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|wc
operator|!=
name|wc_auto
condition|)
operator|delete
index|[]
name|wc
expr_stmt|;
if|if
condition|(
name|prepend
condition|)
block|{
return|return
name|sp
operator|+
name|s
return|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|convertToUnicodeCharByChar
name|QString
name|QWindowsLocalCodec
operator|::
name|convertToUnicodeCharByChar
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|length
parameter_list|,
name|ConverterState
modifier|*
name|state
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|chars
operator|||
operator|!
name|length
condition|)
return|return
name|QString
argument_list|()
return|;
name|int
name|copyLocation
init|=
literal|0
decl_stmt|;
name|int
name|extra
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|state
operator|&&
name|state
operator|->
name|remainingChars
condition|)
block|{
name|copyLocation
operator|=
name|state
operator|->
name|remainingChars
expr_stmt|;
name|extra
operator|+=
name|copyLocation
expr_stmt|;
block|}
name|int
name|newLength
init|=
name|length
operator|+
name|extra
decl_stmt|;
name|char
modifier|*
name|mbcs
init|=
operator|new
name|char
index|[
name|newLength
index|]
decl_stmt|;
comment|//ensure that we have a NULL terminated string
name|mbcs
index|[
name|newLength
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mbcs
index|[
name|newLength
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|mbcs
index|[
name|copyLocation
index|]
operator|)
argument_list|,
name|chars
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyLocation
condition|)
block|{
comment|//copy the last character from the state
name|mbcs
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|state
operator|->
name|state_data
index|[
literal|0
index|]
expr_stmt|;
name|state
operator|->
name|remainingChars
operator|=
literal|0
expr_stmt|;
block|}
specifier|const
name|char
modifier|*
name|mb
init|=
name|mbcs
decl_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_WINCE
specifier|const
name|char
modifier|*
name|next
init|=
literal|0
decl_stmt|;
name|QString
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|CharNextExA
argument_list|(
name|CP_ACP
argument_list|,
name|mb
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|mb
condition|)
block|{
name|wchar_t
name|wc
index|[
literal|2
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|charlength
init|=
name|next
operator|-
name|mb
decl_stmt|;
name|int
name|len
init|=
name|MultiByteToWideChar
argument_list|(
name|CP_ACP
argument_list|,
name|MB_PRECOMPOSED
operator||
name|MB_ERR_INVALID_CHARS
argument_list|,
name|mb
argument_list|,
name|charlength
argument_list|,
name|wc
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|QChar
argument_list|(
name|wc
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|r
init|=
name|GetLastError
argument_list|()
decl_stmt|;
comment|//check if the character being dropped is the last character
if|if
condition|(
name|r
operator|==
name|ERROR_NO_UNICODE_TRANSLATION
operator|&&
name|mb
operator|==
operator|(
name|mbcs
operator|+
name|newLength
operator|-
literal|3
operator|)
operator|&&
name|state
condition|)
block|{
name|state
operator|->
name|remainingChars
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|state_data
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
operator|*
name|mb
expr_stmt|;
block|}
block|}
name|mb
operator|=
name|next
expr_stmt|;
block|}
else|#
directive|else
name|QString
name|s
decl_stmt|;
name|int
name|size
init|=
name|mbstowcs
argument_list|(
name|NULL
argument_list|,
name|mb
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|Q_ASSERT
argument_list|(
literal|"Error in CE TextCodec"
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|wchar_t
modifier|*
name|ws
init|=
operator|new
name|wchar_t
index|[
name|size
operator|+
literal|2
index|]
decl_stmt|;
name|ws
index|[
name|size
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ws
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|mbstowcs
argument_list|(
name|ws
argument_list|,
name|mb
argument_list|,
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|s
operator|.
name|append
argument_list|(
name|QChar
argument_list|(
name|ws
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|ws
expr_stmt|;
endif|#
directive|endif
operator|delete
name|mbcs
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|convertFromUnicode
name|QByteArray
name|QWindowsLocalCodec
operator|::
name|convertFromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|ch
parameter_list|,
name|int
name|uclen
parameter_list|,
name|ConverterState
modifier|*
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|ch
condition|)
return|return
name|QByteArray
argument_list|()
return|;
if|if
condition|(
name|uclen
operator|==
literal|0
condition|)
return|return
name|QByteArray
argument_list|(
literal|""
argument_list|)
return|;
name|BOOL
name|used_def
decl_stmt|;
name|QByteArray
name|mb
argument_list|(
literal|4096
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|len
operator|=
name|WideCharToMultiByte
argument_list|(
name|CP_ACP
argument_list|,
literal|0
argument_list|,
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|ch
argument_list|,
name|uclen
argument_list|,
name|mb
operator|.
name|data
argument_list|()
argument_list|,
name|mb
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|used_def
argument_list|)
operator|)
condition|)
block|{
name|int
name|r
init|=
name|GetLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|ERROR_INSUFFICIENT_BUFFER
condition|)
block|{
name|mb
operator|.
name|resize
argument_list|(
literal|1
operator|+
name|WideCharToMultiByte
argument_list|(
name|CP_ACP
argument_list|,
literal|0
argument_list|,
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|ch
argument_list|,
name|uclen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|used_def
argument_list|)
argument_list|)
expr_stmt|;
comment|// and try again...
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
comment|// Fail.
name|qWarning
argument_list|(
literal|"WideCharToMultiByte: Cannot convert multibyte text (error %d): %s (UTF-8)"
argument_list|,
name|r
argument_list|,
name|QString
argument_list|(
name|ch
argument_list|,
name|uclen
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
name|mb
operator|.
name|resize
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
name|mb
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QWindowsLocalCodec
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
literal|"System"
return|;
block|}
end_function
begin_function
DECL|function|mibEnum
name|int
name|QWindowsLocalCodec
operator|::
name|mibEnum
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* locale names mostly copied from XFree86 */
end_comment
begin_decl_stmt
DECL|variable|iso8859_2locales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|iso8859_2locales
index|[]
init|=
block|{
literal|"croatian"
block|,
literal|"cs"
block|,
literal|"cs_CS"
block|,
literal|"cs_CZ"
block|,
literal|"cz"
block|,
literal|"cz_CZ"
block|,
literal|"czech"
block|,
literal|"hr"
block|,
literal|"hr_HR"
block|,
literal|"hu"
block|,
literal|"hu_HU"
block|,
literal|"hungarian"
block|,
literal|"pl"
block|,
literal|"pl_PL"
block|,
literal|"polish"
block|,
literal|"ro"
block|,
literal|"ro_RO"
block|,
literal|"rumanian"
block|,
literal|"serbocroatian"
block|,
literal|"sh"
block|,
literal|"sh_SP"
block|,
literal|"sh_YU"
block|,
literal|"sk"
block|,
literal|"sk_SK"
block|,
literal|"sl"
block|,
literal|"sl_CS"
block|,
literal|"sl_SI"
block|,
literal|"slovak"
block|,
literal|"slovene"
block|,
literal|"sr_SP"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|iso8859_3locales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|iso8859_3locales
index|[]
init|=
block|{
literal|"eo"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|iso8859_4locales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|iso8859_4locales
index|[]
init|=
block|{
literal|"ee"
block|,
literal|"ee_EE"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|iso8859_5locales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|iso8859_5locales
index|[]
init|=
block|{
literal|"mk"
block|,
literal|"mk_MK"
block|,
literal|"sp"
block|,
literal|"sp_YU"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cp_1251locales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|cp_1251locales
index|[]
init|=
block|{
literal|"be"
block|,
literal|"be_BY"
block|,
literal|"bg"
block|,
literal|"bg_BG"
block|,
literal|"bulgarian"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pt_154locales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|pt_154locales
index|[]
init|=
block|{
literal|"ba_RU"
block|,
literal|"ky"
block|,
literal|"ky_KG"
block|,
literal|"kk"
block|,
literal|"kk_KZ"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|iso8859_6locales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|iso8859_6locales
index|[]
init|=
block|{
literal|"ar_AA"
block|,
literal|"ar_SA"
block|,
literal|"arabic"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|iso8859_7locales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|iso8859_7locales
index|[]
init|=
block|{
literal|"el"
block|,
literal|"el_GR"
block|,
literal|"greek"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|iso8859_8locales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|iso8859_8locales
index|[]
init|=
block|{
literal|"hebrew"
block|,
literal|"he"
block|,
literal|"he_IL"
block|,
literal|"iw"
block|,
literal|"iw_IL"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|iso8859_9locales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|iso8859_9locales
index|[]
init|=
block|{
literal|"tr"
block|,
literal|"tr_TR"
block|,
literal|"turkish"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|iso8859_13locales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|iso8859_13locales
index|[]
init|=
block|{
literal|"lt"
block|,
literal|"lt_LT"
block|,
literal|"lv"
block|,
literal|"lv_LV"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|iso8859_15locales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|iso8859_15locales
index|[]
init|=
block|{
literal|"et"
block|,
literal|"et_EE"
block|,
comment|// Euro countries
literal|"br_FR"
block|,
literal|"ca_ES"
block|,
literal|"de"
block|,
literal|"de_AT"
block|,
literal|"de_BE"
block|,
literal|"de_DE"
block|,
literal|"de_LU"
block|,
literal|"en_IE"
block|,
literal|"es"
block|,
literal|"es_ES"
block|,
literal|"eu_ES"
block|,
literal|"fi"
block|,
literal|"fi_FI"
block|,
literal|"finnish"
block|,
literal|"fr"
block|,
literal|"fr_FR"
block|,
literal|"fr_BE"
block|,
literal|"fr_LU"
block|,
literal|"french"
block|,
literal|"ga_IE"
block|,
literal|"gl_ES"
block|,
literal|"it"
block|,
literal|"it_IT"
block|,
literal|"oc_FR"
block|,
literal|"nl"
block|,
literal|"nl_BE"
block|,
literal|"nl_NL"
block|,
literal|"pt"
block|,
literal|"pt_PT"
block|,
literal|"sv_FI"
block|,
literal|"wa_BE"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|koi8_ulocales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|koi8_ulocales
index|[]
init|=
block|{
literal|"uk"
block|,
literal|"uk_UA"
block|,
literal|"ru_UA"
block|,
literal|"ukrainian"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|tis_620locales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tis_620locales
index|[]
init|=
block|{
literal|"th"
block|,
literal|"th_TH"
block|,
literal|"thai"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|// static const char * const tcvnlocales[] = {
end_comment
begin_comment
comment|//     "vi", "vi_VN", 0 };
end_comment
begin_function
DECL|function|try_locale_list
specifier|static
name|bool
name|try_locale_list
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|locale
index|[]
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|lang
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|locale
index|[
name|i
index|]
operator|&&
name|lang
operator|!=
name|locale
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
name|locale
index|[
name|i
index|]
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|// For the probably_koi8_locales we have to look. the standard says
end_comment
begin_comment
comment|// these are 8859-5, but almost all Russian users use KOI8-R and
end_comment
begin_comment
comment|// incorrectly set $LANG to ru_RU. We'll check tolower() to see what
end_comment
begin_comment
comment|// it thinks ru_RU means.
end_comment
begin_comment
comment|// If you read the history, it seems that many Russians blame ISO and
end_comment
begin_comment
comment|// Perestroika for the confusion.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The real bug is that some programs break if the user specifies
end_comment
begin_comment
comment|// ru_RU.KOI8-R.
end_comment
begin_decl_stmt
DECL|variable|probably_koi8_rlocales
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|probably_koi8_rlocales
index|[]
init|=
block|{
literal|"ru"
block|,
literal|"ru_SU"
block|,
literal|"ru_RU"
block|,
literal|"russian"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|ru_RU_hack
specifier|static
name|QTextCodec
modifier|*
name|ru_RU_hack
parameter_list|(
specifier|const
name|char
modifier|*
name|i
parameter_list|)
block|{
name|QTextCodec
modifier|*
name|ru_RU_codec
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_SETLOCALE
argument_list|)
name|QByteArray
name|origlocale
argument_list|(
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|QByteArray
name|origlocale
argument_list|(
name|i
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|// unicode   koi8r   latin5   name
comment|// 0x044E    0xC0    0xEE     CYRILLIC SMALL LETTER YU
comment|// 0x042E    0xE0    0xCE     CYRILLIC CAPITAL LETTER YU
name|int
name|latin5
init|=
name|tolower
argument_list|(
literal|0xCE
argument_list|)
decl_stmt|;
name|int
name|koi8r
init|=
name|tolower
argument_list|(
literal|0xE0
argument_list|)
decl_stmt|;
if|if
condition|(
name|koi8r
operator|==
literal|0xC0
operator|&&
name|latin5
operator|!=
literal|0xEE
condition|)
block|{
name|ru_RU_codec
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"KOI8-R"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|koi8r
operator|!=
literal|0xC0
operator|&&
name|latin5
operator|==
literal|0xEE
condition|)
block|{
name|ru_RU_codec
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-5"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// something else again... let's assume... *throws dice*
name|ru_RU_codec
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"KOI8-R"
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"QTextCodec: Using KOI8-R, probe failed (%02x %02x %s)"
argument_list|,
name|koi8r
argument_list|,
name|latin5
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
name|origlocale
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ru_RU_codec
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_function
DECL|function|checkForCodec
specifier|static
name|QTextCodec
modifier|*
name|checkForCodec
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|)
block|{
name|QTextCodec
modifier|*
name|c
init|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
specifier|const
name|int
name|index
init|=
name|name
operator|.
name|indexOf
argument_list|(
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|name
operator|.
name|left
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* the next two functions are implicitely thread safe,    as they are only called by setup() which uses a mutex. */
end_comment
begin_function
DECL|function|setupLocaleMapper
specifier|static
name|void
name|setupLocaleMapper
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
name|localeMapper
operator|=
name|QSymbianTextCodec
operator|::
name|localeMapper
expr_stmt|;
if|if
condition|(
name|localeMapper
condition|)
return|return;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"System"
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|QT_NO_ICONV
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"System"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|_XOPEN_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_OSF
argument_list|)
if|if
condition|(
operator|!
name|localeMapper
condition|)
block|{
name|char
modifier|*
name|charset
init|=
name|nl_langinfo
argument_list|(
name|CODESET
argument_list|)
decl_stmt|;
if|if
condition|(
name|charset
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|charset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|localeMapper
condition|)
block|{
comment|// Very poorly defined and followed standards causes lots of
comment|// code to try to get all the cases... This logic is
comment|// duplicated in QIconvCodec, so if you change it here, change
comment|// it there too.
comment|// Try to determine locale codeset from locale name assigned to
comment|// LC_CTYPE category.
comment|// First part is getting that locale name.  First try setlocale() which
comment|// definitely knows it, but since we cannot fully trust it, get ready
comment|// to fall back to environment variables.
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_SETLOCALE
argument_list|)
specifier|const
name|QByteArray
name|ctype
init|=
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|const
name|QByteArray
name|ctype
decl_stmt|;
endif|#
directive|endif
comment|// Get the first nonempty value from $LC_ALL, $LC_CTYPE, and $LANG
comment|// environment variables.
name|QByteArray
name|lang
init|=
name|qgetenv
argument_list|(
literal|"LC_ALL"
argument_list|)
decl_stmt|;
if|if
condition|(
name|lang
operator|.
name|isEmpty
argument_list|()
operator|||
name|lang
operator|==
literal|"C"
condition|)
block|{
name|lang
operator|=
name|qgetenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lang
operator|.
name|isEmpty
argument_list|()
operator|||
name|lang
operator|==
literal|"C"
condition|)
block|{
name|lang
operator|=
name|qgetenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
block|}
comment|// Now try these in order:
comment|// 1. CODESET from ctype if it contains a .CODESET part (e.g. en_US.ISO8859-15)
comment|// 2. CODESET from lang if it contains a .CODESET part
comment|// 3. ctype (maybe the locale is named "ISO-8859-1" or something)
comment|// 4. locale (ditto)
comment|// 5. check for "@euro"
comment|// 6. guess locale from ctype unless ctype is "C"
comment|// 7. guess locale from lang
comment|// 1. CODESET from ctype if it contains a .CODESET part (e.g. en_US.ISO8859-15)
name|int
name|indexOfDot
init|=
name|ctype
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexOfDot
operator|!=
operator|-
literal|1
condition|)
name|localeMapper
operator|=
name|checkForCodec
argument_list|(
name|ctype
operator|.
name|mid
argument_list|(
name|indexOfDot
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// 2. CODESET from lang if it contains a .CODESET part
if|if
condition|(
operator|!
name|localeMapper
condition|)
block|{
name|indexOfDot
operator|=
name|lang
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexOfDot
operator|!=
operator|-
literal|1
condition|)
name|localeMapper
operator|=
name|checkForCodec
argument_list|(
name|lang
operator|.
name|mid
argument_list|(
name|indexOfDot
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 3. ctype (maybe the locale is named "ISO-8859-1" or something)
if|if
condition|(
operator|!
name|localeMapper
operator|&&
operator|!
name|ctype
operator|.
name|isEmpty
argument_list|()
operator|&&
name|ctype
operator|!=
literal|"C"
condition|)
name|localeMapper
operator|=
name|checkForCodec
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
comment|// 4. locale (ditto)
if|if
condition|(
operator|!
name|localeMapper
operator|&&
operator|!
name|lang
operator|.
name|isEmpty
argument_list|()
condition|)
name|localeMapper
operator|=
name|checkForCodec
argument_list|(
name|lang
argument_list|)
expr_stmt|;
comment|// 5. "@euro"
if|if
condition|(
operator|(
operator|!
name|localeMapper
operator|&&
name|ctype
operator|.
name|contains
argument_list|(
literal|"@euro"
argument_list|)
operator|)
operator|||
name|lang
operator|.
name|contains
argument_list|(
literal|"@euro"
argument_list|)
condition|)
name|localeMapper
operator|=
name|checkForCodec
argument_list|(
literal|"ISO 8859-15"
argument_list|)
expr_stmt|;
comment|// 6. guess locale from ctype unless ctype is "C"
comment|// 7. guess locale from lang
specifier|const
name|QByteArray
modifier|&
name|try_by_name
init|=
operator|(
operator|!
name|ctype
operator|.
name|isEmpty
argument_list|()
operator|&&
name|ctype
operator|!=
literal|"C"
operator|)
condition|?
name|lang
else|:
name|ctype
decl_stmt|;
comment|// Now do the guessing.
if|if
condition|(
operator|!
name|lang
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|localeMapper
operator|&&
operator|!
name|try_by_name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|try_locale_list
argument_list|(
name|iso8859_15locales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-15"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|iso8859_2locales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-2"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|iso8859_3locales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-3"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|iso8859_4locales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-4"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|iso8859_5locales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-5"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|iso8859_6locales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-6"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|iso8859_7locales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-7"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|iso8859_8locales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-8-I"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|iso8859_9locales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-9"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|iso8859_13locales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-13"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|tis_620locales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-11"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|koi8_ulocales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"KOI8-U"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|cp_1251locales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"CP 1251"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|pt_154locales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"PT 154"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|try_locale_list
argument_list|(
name|probably_koi8_rlocales
argument_list|,
name|lang
argument_list|)
condition|)
name|localeMapper
operator|=
name|ru_RU_hack
argument_list|(
name|lang
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If everything failed, we default to 8859-1
comment|// We could perhaps default to 8859-15.
if|if
condition|(
operator|!
name|localeMapper
condition|)
name|localeMapper
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
literal|"ISO 8859-1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_THREAD
end_ifndef
begin_expr_stmt
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
name|QMutex
argument_list|,
name|textCodecsMutex
argument_list|,
operator|(
name|QMutex
operator|::
name|Recursive
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// textCodecsMutex need to be locked to enter this function
end_comment
begin_function
DECL|function|setup
specifier|static
name|void
name|setup
parameter_list|()
block|{
if|if
condition|(
name|all
condition|)
return|return;
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
comment|// If we don't have a trap handler, we're outside of the main() function,
comment|// ie. in global constructors or destructors. Don't create codecs in this
comment|// case as it would lead to crashes because of a missing cleanup stack on Symbian
if|if
condition|(
name|User
operator|::
name|TrapHandler
argument_list|()
operator|==
name|NULL
condition|)
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_DEBUG_TEXTCODEC
if|if
condition|(
name|destroying_is_ok
condition|)
name|qWarning
argument_list|(
literal|"QTextCodec: Creating new codec during codec cleanup"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|all
operator|=
operator|new
name|QList
argument_list|<
name|QTextCodec
operator|*
argument_list|>
expr_stmt|;
comment|// create the cleanup object to cleanup all codecs on exit
operator|(
name|void
operator|)
name|createQTextCodecCleanup
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CODECS
operator|(
name|void
operator|)
operator|new
name|QTsciiCodec
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
operator|++
name|i
control|)
operator|(
name|void
operator|)
operator|new
name|QIsciiCodec
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|QSimpleTextCodec
operator|::
name|numSimpleCodecs
condition|;
operator|++
name|i
control|)
operator|(
name|void
operator|)
operator|new
name|QSimpleTextCodec
argument_list|(
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
name|localeMapper
operator|=
name|QSymbianTextCodec
operator|::
name|init
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
comment|// no font codecs when bootstrapping
operator|(
name|void
operator|)
operator|new
name|QFontLaoCodec
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_ICONV
argument_list|)
comment|// no iconv(3) support, must build all codecs into the library
operator|(
name|void
operator|)
operator|new
name|QFontGb2312Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QFontGbkCodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QFontGb18030_0Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QFontJis0208Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QFontJis0201Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QFontKsc5601Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QFontBig5hkscsCodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QFontBig5Codec
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_ICONV&& !QT_BOOTSTRAPPED
endif|#
directive|endif
comment|// Q_OS_UNIX
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_INTEGRITY
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_ICONV
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
comment|// no asian codecs when bootstrapping, sorry
operator|(
name|void
operator|)
operator|new
name|QGb18030Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QGbkCodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QGb2312Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QEucJpCodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QJisCodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QSjisCodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QEucKrCodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QCP949Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QBig5Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QBig5hkscsCodec
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_ICONV&& !QT_BOOTSTRAPPED
endif|#
directive|endif
comment|//Q_OS_SYMBIAN
endif|#
directive|endif
comment|// QT_NO_CODECS
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|(
name|void
operator|)
operator|new
name|QWindowsLocalCodec
expr_stmt|;
endif|#
directive|endif
comment|// Q_OS_WIN32
operator|(
name|void
operator|)
operator|new
name|QUtf16Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QUtf16BECodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QUtf16LECodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QUtf32Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QUtf32BECodec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QUtf32LECodec
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_SYMBIAN
operator|(
name|void
operator|)
operator|new
name|QLatin15Codec
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
operator|new
name|QLatin1Codec
expr_stmt|;
operator|(
name|void
operator|)
operator|new
name|QUtf8Codec
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_INTEGRITY
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_ICONV
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
comment|// QIconvCodec depends on the UTF-16 codec, so it needs to be created last
operator|(
name|void
operator|)
operator|new
name|QIconvCodec
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|localeMapper
condition|)
name|setupLocaleMapper
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \enum QTextCodec::ConversionFlag      \value DefaultConversion  No flag is set.     \value ConvertInvalidToNull  If this flag is set, each invalid input                                  character is output as a null character.     \value IgnoreHeader  Ignore any Unicode byte-order mark and don't generate any.      \omitvalue FreeFunction */
end_comment
begin_comment
comment|/*!     \fn QTextCodec::ConverterState::ConverterState(ConversionFlags flags)      Constructs a ConverterState object initialized with the given \a flags. */
end_comment
begin_comment
comment|/*!     Destroys the ConverterState object. */
end_comment
begin_destructor
DECL|function|~ConverterState
name|QTextCodec
operator|::
name|ConverterState
operator|::
name|~
name|ConverterState
parameter_list|()
block|{
if|if
condition|(
name|flags
operator|&
name|FreeFunction
condition|)
operator|(
name|QTextCodecUnalignedPointer
operator|::
name|decode
argument_list|(
name|state_data
argument_list|)
operator|)
operator|(
name|this
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
condition|)
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \class QTextCodec     \brief The QTextCodec class provides conversions between text encodings.     \reentrant     \ingroup i18n      Qt uses Unicode to store, draw and manipulate strings. In many     situations you may wish to deal with data that uses a different     encoding. For example, most Japanese documents are still stored     in Shift-JIS or ISO 2022-JP, while Russian users often have their     documents in KOI8-R or Windows-1251.      Qt provides a set of QTextCodec classes to help with converting     non-Unicode formats to and from Unicode. You can also create your     own codec classes.      The supported encodings are:      \list     \o Apple Roman     \o \l{Big5 Text Codec}{Big5}     \o \l{Big5-HKSCS Text Codec}{Big5-HKSCS}     \o CP949     \o \l{EUC-JP Text Codec}{EUC-JP}     \o \l{EUC-KR Text Codec}{EUC-KR}     \o \l{GBK Text Codec}{GB18030-0}     \o IBM 850     \o IBM 866     \o IBM 874     \o \l{ISO 2022-JP (JIS) Text Codec}{ISO 2022-JP}     \o ISO 8859-1 to 10     \o ISO 8859-13 to 16     \o Iscii-Bng, Dev, Gjr, Knd, Mlm, Ori, Pnj, Tlg, and Tml     \o JIS X 0201     \o JIS X 0208     \o KOI8-R     \o KOI8-U     \o MuleLao-1     \o ROMAN8     \o \l{Shift-JIS Text Codec}{Shift-JIS}     \o TIS-620     \o \l{TSCII Text Codec}{TSCII}     \o UTF-8     \o UTF-16     \o UTF-16BE     \o UTF-16LE     \o UTF-32     \o UTF-32BE     \o UTF-32LE     \o Windows-1250 to 1258     \o WINSAMI2     \endlist      QTextCodecs can be used as follows to convert some locally encoded     string to Unicode. Suppose you have some string encoded in Russian     KOI8-R encoding, and want to convert it to Unicode. The simple way     to do it is like this:      \snippet doc/src/snippets/code/src_corelib_codecs_qtextcodec.cpp 0      After this, \c string holds the text converted to Unicode.     Converting a string from Unicode to the local encoding is just as     easy:      \snippet doc/src/snippets/code/src_corelib_codecs_qtextcodec.cpp 1      To read or write files in various encodings, use QTextStream and     its \l{QTextStream::setCodec()}{setCodec()} function. See the     \l{tools/codecs}{Codecs} example for an application of QTextCodec     to file I/O.      Some care must be taken when trying to convert the data in chunks,     for example, when receiving it over a network. In such cases it is     possible that a multi-byte character will be split over two     chunks. At best this might result in the loss of a character and     at worst cause the entire conversion to fail.      The approach to use in these situations is to create a QTextDecoder     object for the codec and use this QTextDecoder for the whole     decoding process, as shown below:      \snippet doc/src/snippets/code/src_corelib_codecs_qtextcodec.cpp 2      The QTextDecoder object maintains state between chunks and therefore     works correctly even if a multi-byte character is split between     chunks.      \section1 Creating Your Own Codec Class      Support for new text encodings can be added to Qt by creating     QTextCodec subclasses.      The pure virtual functions describe the encoder to the system and     the coder is used as required in the different text file formats     supported by QTextStream, and under X11, for the locale-specific     character input and output.      To add support for another encoding to Qt, make a subclass of     QTextCodec and implement the functions listed in the table below.      \table     \header \o Function \o Description      \row \o name()          \o Returns the official name for the encoding. If the             encoding is listed in the             \l{IANA character-sets encoding file}, the name             should be the preferred MIME name for the encoding.      \row \o aliases()          \o Returns a list of alternative names for the encoding.             QTextCodec provides a default implementation that returns             an empty list. For example, "ISO-8859-1" has "latin1",             "CP819", "IBM819", and "iso-ir-100" as aliases.      \row \o mibEnum()          \o Return the MIB enum for the encoding if it is listed in             the \l{IANA character-sets encoding file}.      \row \o convertToUnicode()          \o Converts an 8-bit character string to Unicode.      \row \o convertFromUnicode()          \o Converts a Unicode string to an 8-bit character string.     \endtable      You may find it more convenient to make your codec class     available as a plugin; see \l{How to Create Qt Plugins} for     details.      \sa QTextStream, QTextDecoder, QTextEncoder, {Codecs Example} */
end_comment
begin_comment
comment|/*!     Constructs a QTextCodec, and gives it the highest precedence. The     QTextCodec should always be constructed on the heap (i.e. with \c     new). Qt takes ownership and will delete it when the application     terminates. */
end_comment
begin_constructor
DECL|function|QTextCodec
name|QTextCodec
operator|::
name|QTextCodec
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|setup
argument_list|()
expr_stmt|;
name|all
operator|->
name|prepend
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \nonreentrant      Destroys the QTextCodec. Note that you should not delete codecs     yourself: once created they become Qt's responsibility. */
end_comment
begin_destructor
DECL|function|~QTextCodec
name|QTextCodec
operator|::
name|~
name|QTextCodec
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_DEBUG_TEXTCODEC
if|if
condition|(
operator|!
name|destroying_is_ok
condition|)
name|qWarning
argument_list|(
literal|"QTextCodec::~QTextCodec: Called by application"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|all
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|all
operator|->
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QTextCodecCache
modifier|*
name|cache
init|=
name|qTextCodecCache
argument_list|()
decl_stmt|;
if|if
condition|(
name|cache
condition|)
name|cache
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_destructor
begin_comment
comment|/*!     \fn QTextCodec *QTextCodec::codecForName(const char *name)      Searches all installed QTextCodec objects and returns the one     which best matches \a name; the match is case-insensitive. Returns     0 if no codec matching the name \a name could be found. */
end_comment
begin_comment
comment|/*!     Searches all installed QTextCodec objects and returns the one     which best matches \a name; the match is case-insensitive. Returns     0 if no codec matching the name \a name could be found. */
end_comment
begin_function
DECL|function|codecForName
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForName
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|setup
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|validCodecs
argument_list|()
condition|)
return|return
literal|0
return|;
name|QTextCodecCache
modifier|*
name|cache
init|=
name|qTextCodecCache
argument_list|()
decl_stmt|;
name|QTextCodec
modifier|*
name|codec
decl_stmt|;
if|if
condition|(
name|cache
condition|)
block|{
name|codec
operator|=
name|cache
operator|->
name|value
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
condition|)
return|return
name|codec
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|all
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTextCodec
modifier|*
name|cursor
init|=
name|all
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|nameMatch
argument_list|(
name|cursor
operator|->
name|name
argument_list|()
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|cache
condition|)
name|cache
operator|->
name|insert
argument_list|(
name|name
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|aliases
init|=
name|cursor
operator|->
name|aliases
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|aliases
operator|.
name|size
argument_list|()
condition|;
operator|++
name|y
control|)
if|if
condition|(
name|nameMatch
argument_list|(
name|aliases
operator|.
name|at
argument_list|(
name|y
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|cache
condition|)
name|cache
operator|->
name|insert
argument_list|(
name|name
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
block|}
name|codec
operator|=
name|createForName
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|&&
name|cache
condition|)
name|cache
operator|->
name|insert
argument_list|(
name|name
argument_list|,
name|codec
argument_list|)
expr_stmt|;
return|return
name|codec
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the QTextCodec which matches the \link     QTextCodec::mibEnum() MIBenum\endlink \a mib. */
end_comment
begin_function
DECL|function|codecForMib
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForMib
parameter_list|(
name|int
name|mib
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|setup
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|validCodecs
argument_list|()
condition|)
return|return
literal|0
return|;
name|QByteArray
name|key
init|=
literal|"MIB: "
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|mib
argument_list|)
decl_stmt|;
name|QTextCodecCache
modifier|*
name|cache
init|=
name|qTextCodecCache
argument_list|()
decl_stmt|;
name|QTextCodec
modifier|*
name|codec
decl_stmt|;
if|if
condition|(
name|cache
condition|)
block|{
name|codec
operator|=
name|cache
operator|->
name|value
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
condition|)
return|return
name|codec
return|;
block|}
name|QList
argument_list|<
name|QTextCodec
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|i
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|all
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTextCodec
modifier|*
name|cursor
init|=
name|all
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cursor
operator|->
name|mibEnum
argument_list|()
operator|==
name|mib
condition|)
block|{
if|if
condition|(
name|cache
condition|)
name|cache
operator|->
name|insert
argument_list|(
name|key
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
block|}
name|codec
operator|=
name|createForMib
argument_list|(
name|mib
argument_list|)
expr_stmt|;
comment|// Qt 3 used 1000 (mib for UCS2) as its identifier for the utf16 codec. Map
comment|// this correctly for compatibility.
if|if
condition|(
operator|!
name|codec
operator|&&
name|mib
operator|==
literal|1000
condition|)
return|return
name|codecForMib
argument_list|(
literal|1015
argument_list|)
return|;
if|if
condition|(
name|codec
operator|&&
name|cache
condition|)
name|cache
operator|->
name|insert
argument_list|(
name|key
argument_list|,
name|codec
argument_list|)
expr_stmt|;
return|return
name|codec
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the list of all available codecs, by name. Call     QTextCodec::codecForName() to obtain the QTextCodec for the name.      The list may contain many mentions of the same codec     if the codec has aliases.      \sa availableMibs(), name(), aliases() */
end_comment
begin_function
DECL|function|availableCodecs
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QTextCodec
operator|::
name|availableCodecs
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|setup
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|codecs
decl_stmt|;
if|if
condition|(
operator|!
name|validCodecs
argument_list|()
condition|)
return|return
name|codecs
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|all
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|codecs
operator|+=
name|all
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|name
argument_list|()
expr_stmt|;
name|codecs
operator|+=
name|all
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|aliases
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_LIBRARY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_TEXTCODECPLUGIN
argument_list|)
name|QFactoryLoader
modifier|*
name|l
init|=
name|loader
argument_list|()
decl_stmt|;
name|QStringList
name|keys
init|=
name|l
operator|->
name|keys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"MIB: "
argument_list|)
argument_list|)
condition|)
block|{
name|QByteArray
name|name
init|=
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|codecs
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
name|codecs
operator|+=
name|name
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|codecs
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the list of MIBs for all available codecs. Call     QTextCodec::codecForMib() to obtain the QTextCodec for the MIB.      \sa availableCodecs(), mibEnum() */
end_comment
begin_function
DECL|function|availableMibs
name|QList
argument_list|<
name|int
argument_list|>
name|QTextCodec
operator|::
name|availableMibs
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|setup
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|codecs
decl_stmt|;
if|if
condition|(
operator|!
name|validCodecs
argument_list|()
condition|)
return|return
name|codecs
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|all
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|codecs
operator|+=
name|all
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|mibEnum
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_LIBRARY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_TEXTCODECPLUGIN
argument_list|)
name|QFactoryLoader
modifier|*
name|l
init|=
name|loader
argument_list|()
decl_stmt|;
name|QStringList
name|keys
init|=
name|l
operator|->
name|keys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"MIB: "
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|mib
init|=
name|keys
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|mid
argument_list|(
literal|5
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|codecs
operator|.
name|contains
argument_list|(
name|mib
argument_list|)
condition|)
name|codecs
operator|+=
name|mib
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|codecs
return|;
block|}
end_function
begin_comment
comment|/*!     Set the codec to \a c; this will be returned by     codecForLocale(). If \a c is a null pointer, the codec is reset to     the default.      This might be needed for some applications that want to use their     own mechanism for setting the locale.      \sa codecForLocale() */
end_comment
begin_function
DECL|function|setCodecForLocale
name|void
name|QTextCodec
operator|::
name|setCodecForLocale
parameter_list|(
name|QTextCodec
modifier|*
name|c
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|localeMapper
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|localeMapper
condition|)
name|setupLocaleMapper
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the codec most suitable for this locale.      On Windows, the codec will be based on a system locale. On Unix     systems, starting with Qt 4.2, the codec will be using the \e     iconv library. Note that in both cases the codec's name will be     "System". */
end_comment
begin_function
DECL|function|codecForLocale
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForLocale
parameter_list|()
block|{
if|if
condition|(
operator|!
name|validCodecs
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|localeMapper
condition|)
return|return
name|localeMapper
return|;
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|QMutexLocker
name|locker
argument_list|(
name|textCodecsMutex
argument_list|()
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|setup
argument_list|()
expr_stmt|;
return|return
name|localeMapper
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray QTextCodec::name() const      QTextCodec subclasses must reimplement this function. It returns     the name of the encoding supported by the subclass.      If the codec is registered as a character set in the     \l{IANA character-sets encoding file} this method should     return the preferred mime name for the codec if defined,     otherwise its name. */
end_comment
begin_comment
comment|/*!     \fn int QTextCodec::mibEnum() const      Subclasses of QTextCodec must reimplement this function. It     returns the MIBenum (see \l{IANA character-sets encoding file}     for more information). It is important that each QTextCodec     subclass returns the correct unique value for this function. */
end_comment
begin_comment
comment|/*!   Subclasses can return a number of aliases for the codec in question.    Standard aliases for codecs can be found in the   \l{IANA character-sets encoding file}. */
end_comment
begin_function
DECL|function|aliases
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QTextCodec
operator|::
name|aliases
parameter_list|()
specifier|const
block|{
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QTextCodec::convertToUnicode(const char *chars, int len,                                              ConverterState *state) const      QTextCodec subclasses must reimplement this function.      Converts the first \a len characters of \a chars from the     encoding of the subclass to Unicode, and returns the result in a     QString.      \a state can be 0, in which case the conversion is stateless and     default conversion rules should be used. If state is not 0, the     codec should save the state after the conversion in \a state, and     adjust the remainingChars and invalidChars members of the struct. */
end_comment
begin_comment
comment|/*!     \fn QByteArray QTextCodec::convertFromUnicode(const QChar *input, int number,                                                   ConverterState *state) const      QTextCodec subclasses must reimplement this function.      Converts the first \a number of characters from the \a input array     from Unicode to the encoding of the subclass, and returns the result     in a QByteArray.      \a state can be 0 in which case the conversion is stateless and     default conversion rules should be used. If state is not 0, the     codec should save the state after the conversion in \a state, and     adjust the remainingChars and invalidChars members of the struct. */
end_comment
begin_comment
comment|/*!     Creates a QTextDecoder which stores enough state to decode chunks     of \c{char *} data to create chunks of Unicode data.      The caller is responsible for deleting the returned object. */
end_comment
begin_function
DECL|function|makeDecoder
name|QTextDecoder
modifier|*
name|QTextCodec
operator|::
name|makeDecoder
parameter_list|()
specifier|const
block|{
return|return
operator|new
name|QTextDecoder
argument_list|(
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a QTextDecoder with a specified \a flags to decode chunks     of \c{char *} data to create chunks of Unicode data.      The caller is responsible for deleting the returned object.      \since 4.7 */
end_comment
begin_function
DECL|function|makeDecoder
name|QTextDecoder
modifier|*
name|QTextCodec
operator|::
name|makeDecoder
parameter_list|(
name|QTextCodec
operator|::
name|ConversionFlags
name|flags
parameter_list|)
specifier|const
block|{
return|return
operator|new
name|QTextDecoder
argument_list|(
name|this
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a QTextEncoder which stores enough state to encode chunks     of Unicode data as \c{char *} data.      The caller is responsible for deleting the returned object. */
end_comment
begin_function
DECL|function|makeEncoder
name|QTextEncoder
modifier|*
name|QTextCodec
operator|::
name|makeEncoder
parameter_list|()
specifier|const
block|{
return|return
operator|new
name|QTextEncoder
argument_list|(
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Creates a QTextEncoder with a specified \a flags to encode chunks     of Unicode data as \c{char *} data.      The caller is responsible for deleting the returned object.      \since 4.7 */
end_comment
begin_function
DECL|function|makeEncoder
name|QTextEncoder
modifier|*
name|QTextCodec
operator|::
name|makeEncoder
parameter_list|(
name|QTextCodec
operator|::
name|ConversionFlags
name|flags
parameter_list|)
specifier|const
block|{
return|return
operator|new
name|QTextEncoder
argument_list|(
name|this
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray QTextCodec::fromUnicode(const QChar *input, int number,                                            ConverterState *state) const      Converts the first \a number of characters from the \a input array     from Unicode to the encoding of this codec, and returns the result     in a QByteArray.      The \a state of the convertor used is updated. */
end_comment
begin_comment
comment|/*!     Converts \a str from Unicode to the encoding of this codec, and     returns the result in a QByteArray. */
end_comment
begin_function
DECL|function|fromUnicode
name|QByteArray
name|QTextCodec
operator|::
name|fromUnicode
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
specifier|const
block|{
return|return
name|convertFromUnicode
argument_list|(
name|str
operator|.
name|constData
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QTextCodec::toUnicode(const char *input, int size,                                       ConverterState *state) const      Converts the first \a size characters from the \a input from the     encoding of this codec to Unicode, and returns the result in a     QString.      The \a state of the convertor used is updated. */
end_comment
begin_comment
comment|/*!     Converts \a a from the encoding of this codec to Unicode, and     returns the result in a QString. */
end_comment
begin_function
DECL|function|toUnicode
name|QString
name|QTextCodec
operator|::
name|toUnicode
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|a
parameter_list|)
specifier|const
block|{
return|return
name|convertToUnicode
argument_list|(
name|a
operator|.
name|constData
argument_list|()
argument_list|,
name|a
operator|.
name|length
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the Unicode character \a ch can be fully encoded     with this codec; otherwise returns false. */
end_comment
begin_function
DECL|function|canEncode
name|bool
name|QTextCodec
operator|::
name|canEncode
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
block|{
name|ConverterState
name|state
decl_stmt|;
name|state
operator|.
name|flags
operator|=
name|ConvertInvalidToNull
expr_stmt|;
name|convertFromUnicode
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|state
operator|.
name|invalidChars
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \a s contains the string being tested for encode-ability. */
end_comment
begin_function
DECL|function|canEncode
name|bool
name|QTextCodec
operator|::
name|canEncode
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
specifier|const
block|{
name|ConverterState
name|state
decl_stmt|;
name|state
operator|.
name|flags
operator|=
name|ConvertInvalidToNull
expr_stmt|;
name|convertFromUnicode
argument_list|(
name|s
operator|.
name|constData
argument_list|()
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|state
operator|.
name|invalidChars
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \a chars contains the source characters. */
end_comment
begin_function
DECL|function|toUnicode
name|QString
name|QTextCodec
operator|::
name|toUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|)
specifier|const
block|{
name|int
name|len
init|=
name|qstrlen
argument_list|(
name|chars
argument_list|)
decl_stmt|;
return|return
name|convertToUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \class QTextEncoder     \brief The QTextEncoder class provides a state-based encoder.     \reentrant     \ingroup i18n      A text encoder converts text from Unicode into an encoded text format     using a specific codec.      The encoder converts Unicode into another format, remembering any     state that is required between calls.      \sa QTextCodec::makeEncoder(), QTextDecoder */
end_comment
begin_comment
comment|/*!     \fn QTextEncoder::QTextEncoder(const QTextCodec *codec)      Constructs a text encoder for the given \a codec. */
end_comment
begin_comment
comment|/*!     Constructs a text encoder for the given \a codec and conversion \a flags.      \since 4.7 */
end_comment
begin_constructor
DECL|function|QTextEncoder
name|QTextEncoder
operator|::
name|QTextEncoder
parameter_list|(
specifier|const
name|QTextCodec
modifier|*
name|codec
parameter_list|,
name|QTextCodec
operator|::
name|ConversionFlags
name|flags
parameter_list|)
member_init_list|:
name|c
argument_list|(
name|codec
argument_list|)
member_init_list|,
name|state
argument_list|()
block|{
name|state
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the encoder. */
end_comment
begin_destructor
DECL|function|~QTextEncoder
name|QTextEncoder
operator|::
name|~
name|QTextEncoder
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*! \internal     \since 4.5     Determines whether the eecoder encountered a failure while decoding the input. If     an error was encountered, the produced result is undefined, and gets converted as according     to the conversion flags.  */
end_comment
begin_function
DECL|function|hasFailure
name|bool
name|QTextEncoder
operator|::
name|hasFailure
parameter_list|()
specifier|const
block|{
return|return
name|state
operator|.
name|invalidChars
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the Unicode string \a str into an encoded QByteArray. */
end_comment
begin_function
DECL|function|fromUnicode
name|QByteArray
name|QTextEncoder
operator|::
name|fromUnicode
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|QByteArray
name|result
init|=
name|c
operator|->
name|fromUnicode
argument_list|(
name|str
operator|.
name|constData
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|,
operator|&
name|state
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Converts \a len characters (not bytes) from \a uc, and returns the     result in a QByteArray. */
end_comment
begin_function
DECL|function|fromUnicode
name|QByteArray
name|QTextEncoder
operator|::
name|fromUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|QByteArray
name|result
init|=
name|c
operator|->
name|fromUnicode
argument_list|(
name|uc
argument_list|,
name|len
argument_list|,
operator|&
name|state
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \class QTextDecoder     \brief The QTextDecoder class provides a state-based decoder.     \reentrant     \ingroup i18n      A text decoder converts text from an encoded text format into Unicode     using a specific codec.      The decoder converts text in this format into Unicode, remembering any     state that is required between calls.      \sa QTextCodec::makeDecoder(), QTextEncoder */
end_comment
begin_comment
comment|/*!     \fn QTextDecoder::QTextDecoder(const QTextCodec *codec)      Constructs a text decoder for the given \a codec. */
end_comment
begin_comment
comment|/*!     Constructs a text decoder for the given \a codec and conversion \a flags.      \since 4.7 */
end_comment
begin_constructor
DECL|function|QTextDecoder
name|QTextDecoder
operator|::
name|QTextDecoder
parameter_list|(
specifier|const
name|QTextCodec
modifier|*
name|codec
parameter_list|,
name|QTextCodec
operator|::
name|ConversionFlags
name|flags
parameter_list|)
member_init_list|:
name|c
argument_list|(
name|codec
argument_list|)
member_init_list|,
name|state
argument_list|()
block|{
name|state
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the decoder. */
end_comment
begin_destructor
DECL|function|~QTextDecoder
name|QTextDecoder
operator|::
name|~
name|QTextDecoder
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \fn QString QTextDecoder::toUnicode(const char *chars, int len)      Converts the first \a len bytes in \a chars to Unicode, returning     the result.      If not all characters are used (e.g. if only part of a multi-byte     encoding is at the end of the characters), the decoder remembers     enough state to continue with the next call to this function. */
end_comment
begin_function
DECL|function|toUnicode
name|QString
name|QTextDecoder
operator|::
name|toUnicode
parameter_list|(
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|c
operator|->
name|toUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
operator|&
name|state
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \overload      The converted string is returned in \a target.  */
end_comment
begin_function
DECL|function|toUnicode
name|void
name|QTextDecoder
operator|::
name|toUnicode
parameter_list|(
name|QString
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|target
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|mibEnum
argument_list|()
condition|)
block|{
case|case
literal|106
case|:
comment|// utf8
cast|static_cast
argument_list|<
specifier|const
name|QUtf8Codec
operator|*
argument_list|>
argument_list|(
name|c
argument_list|)
operator|->
name|convertToUnicode
argument_list|(
name|target
argument_list|,
name|chars
argument_list|,
name|len
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
block|{
comment|// latin1
name|target
operator|->
name|resize
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ushort
modifier|*
name|data
init|=
operator|(
name|ushort
operator|*
operator|)
name|target
operator|->
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|len
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|data
index|[
name|i
index|]
operator|=
operator|(
name|uchar
operator|)
name|chars
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
default|default:
operator|*
name|target
operator|=
name|c
operator|->
name|toUnicode
argument_list|(
name|chars
argument_list|,
name|len
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload      Converts the bytes in the byte array specified by \a ba to Unicode     and returns the result. */
end_comment
begin_function
DECL|function|toUnicode
name|QString
name|QTextDecoder
operator|::
name|toUnicode
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
return|return
name|c
operator|->
name|toUnicode
argument_list|(
name|ba
operator|.
name|constData
argument_list|()
argument_list|,
name|ba
operator|.
name|length
argument_list|()
argument_list|,
operator|&
name|state
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTextCodec* QTextCodec::codecForTr()      Returns the codec used by QObject::tr() on its argument. If this     function returns 0 (the default), tr() assumes Latin-1.      \sa setCodecForTr() */
end_comment
begin_comment
comment|/*!     \fn void QTextCodec::setCodecForTr(QTextCodec *c)     \nonreentrant      Sets the codec used by QObject::tr() on its argument to \a c. If     \a c is 0 (the default), tr() assumes Latin-1.      If the literal quoted text in the program is not in the Latin-1     encoding, this function can be used to set the appropriate     encoding. For example, software developed by Korean programmers     might use eucKR for all the text in the program, in which case the     main() function might look like this:      \snippet doc/src/snippets/code/src_corelib_codecs_qtextcodec.cpp 3      Note that this is not the way to select the encoding that the \e     user has chosen. For example, to convert an application containing     literal English strings to Korean, all that is needed is for the     English strings to be passed through tr() and for translation     files to be loaded. For details of internationalization, see     \l{Internationalization with Qt}.      \sa codecForTr(), setCodecForCStrings() */
end_comment
begin_comment
comment|/*!     \fn QTextCodec* QTextCodec::codecForCStrings()      Returns the codec used by QString to convert to and from \c{const     char *} and QByteArrays. If this function returns 0 (the default),     QString assumes Latin-1.      \sa setCodecForCStrings() */
end_comment
begin_comment
comment|/*!     \fn void QTextCodec::setCodecForCStrings(QTextCodec *codec)     \nonreentrant      Sets the codec used by QString to convert to and from \c{const     char *} and QByteArrays. If the \a codec is 0 (the default),     QString assumes Latin-1.      \warning Some codecs do not preserve the characters in the ASCII     range (0x00 to 0x7F). For example, the Japanese Shift-JIS     encoding maps the backslash character (0x5A) to the Yen     character. To avoid undesirable side-effects, we recommend     avoiding such codecs with setCodecsForCString().      \sa codecForCStrings(), setCodecForTr() */
end_comment
begin_comment
comment|/*!     \since 4.4      Tries to detect the encoding of the provided snippet of HTML in     the given byte array, \a ba, by checking the BOM (Byte Order Mark)     and the content-type meta header and returns a QTextCodec instance     that is capable of decoding the html to unicode.  If the codec     cannot be detected from the content provided, \a defaultCodec is     returned.      \sa codecForUtfText() */
end_comment
begin_function
DECL|function|codecForHtml
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForHtml
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|,
name|QTextCodec
modifier|*
name|defaultCodec
parameter_list|)
block|{
comment|// determine charset
name|int
name|pos
decl_stmt|;
name|QTextCodec
modifier|*
name|c
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|QTextCodec
operator|::
name|codecForUtfText
argument_list|(
name|ba
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|QByteArray
name|header
init|=
name|ba
operator|.
name|left
argument_list|(
literal|512
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|pos
operator|=
name|header
operator|.
name|indexOf
argument_list|(
literal|"http-equiv="
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|pos
operator|=
name|header
operator|.
name|lastIndexOf
argument_list|(
literal|"meta "
argument_list|,
name|pos
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|pos
operator|=
name|header
operator|.
name|indexOf
argument_list|(
literal|"charset="
argument_list|,
name|pos
argument_list|)
operator|+
name|int
argument_list|(
name|strlen
argument_list|(
literal|"charset="
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|pos2
init|=
name|header
operator|.
name|indexOf
argument_list|(
literal|'\"'
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
decl_stmt|;
name|QByteArray
name|cs
init|=
name|header
operator|.
name|mid
argument_list|(
name|pos
argument_list|,
name|pos2
operator|-
name|pos
argument_list|)
decl_stmt|;
comment|//            qDebug("found charset: %s", cs.data());
name|c
operator|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|c
condition|)
name|c
operator|=
name|defaultCodec
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Tries to detect the encoding of the provided snippet of HTML in     the given byte array, \a ba, by checking the BOM (Byte Order Mark)     and the content-type meta header and returns a QTextCodec instance     that is capable of decoding the html to unicode. If the codec cannot     be detected, this overload returns a Latin-1 QTextCodec. */
end_comment
begin_function
DECL|function|codecForHtml
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForHtml
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
return|return
name|codecForHtml
argument_list|(
name|ba
argument_list|,
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
comment|/*Latin 1*/
literal|4
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Tries to detect the encoding of the provided snippet \a ba by     using the BOM (Byte Order Mark) and returns a QTextCodec instance     that is capable of decoding the text to unicode. If the codec     cannot be detected from the content provided, \a defaultCodec is     returned.      \sa codecForHtml() */
end_comment
begin_function
DECL|function|codecForUtfText
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForUtfText
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|,
name|QTextCodec
modifier|*
name|defaultCodec
parameter_list|)
block|{
specifier|const
name|int
name|arraySize
init|=
name|ba
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|arraySize
operator|>
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|uchar
operator|)
name|ba
index|[
literal|0
index|]
operator|==
literal|0x00
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|1
index|]
operator|==
literal|0x00
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|2
index|]
operator|==
literal|0xFE
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|3
index|]
operator|==
literal|0xFF
condition|)
return|return
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
literal|1018
argument_list|)
return|;
comment|// utf-32 be
elseif|else
if|if
condition|(
operator|(
name|uchar
operator|)
name|ba
index|[
literal|0
index|]
operator|==
literal|0xFF
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|1
index|]
operator|==
literal|0xFE
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|2
index|]
operator|==
literal|0x00
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|3
index|]
operator|==
literal|0x00
condition|)
return|return
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
literal|1019
argument_list|)
return|;
comment|// utf-32 le
block|}
if|if
condition|(
name|arraySize
operator|<
literal|2
condition|)
return|return
name|defaultCodec
return|;
if|if
condition|(
operator|(
name|uchar
operator|)
name|ba
index|[
literal|0
index|]
operator|==
literal|0xfe
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|1
index|]
operator|==
literal|0xff
condition|)
return|return
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
literal|1013
argument_list|)
return|;
comment|// utf16 be
elseif|else
if|if
condition|(
operator|(
name|uchar
operator|)
name|ba
index|[
literal|0
index|]
operator|==
literal|0xff
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|1
index|]
operator|==
literal|0xfe
condition|)
return|return
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
literal|1014
argument_list|)
return|;
comment|// utf16 le
if|if
condition|(
name|arraySize
operator|<
literal|3
condition|)
return|return
name|defaultCodec
return|;
if|if
condition|(
operator|(
name|uchar
operator|)
name|ba
index|[
literal|0
index|]
operator|==
literal|0xef
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|1
index|]
operator|==
literal|0xbb
operator|&&
operator|(
name|uchar
operator|)
name|ba
index|[
literal|2
index|]
operator|==
literal|0xbf
condition|)
return|return
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
literal|106
argument_list|)
return|;
comment|// utf-8
return|return
name|defaultCodec
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Tries to detect the encoding of the provided snippet \a ba by     using the BOM (Byte Order Mark) and returns a QTextCodec instance     that is capable of decoding the text to unicode. If the codec     cannot be detected, this overload returns a Latin-1 QTextCodec.      \sa codecForHtml() */
end_comment
begin_function
DECL|function|codecForUtfText
name|QTextCodec
modifier|*
name|QTextCodec
operator|::
name|codecForUtfText
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
return|return
name|codecForUtfText
argument_list|(
name|ba
argument_list|,
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
comment|/*Latin 1*/
literal|4
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal     \since 4.3     Determines whether the decoder encountered a failure while decoding the input. If     an error was encountered, the produced result is undefined, and gets converted as according     to the conversion flags.  */
end_comment
begin_function
DECL|function|hasFailure
name|bool
name|QTextDecoder
operator|::
name|hasFailure
parameter_list|()
specifier|const
block|{
return|return
name|state
operator|.
name|invalidChars
operator|!=
literal|0
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTCODEC
end_comment
end_unit
