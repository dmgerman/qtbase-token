begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 John Layt<jlayt@kde.org> ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtimezone.h"
end_include
begin_include
include|#
directive|include
file|"qtimezoneprivate_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/QFile>
end_include
begin_include
include|#
directive|include
file|<QtCore/QHash>
end_include
begin_include
include|#
directive|include
file|<QtCore/QDateTime>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*     Private      tz file implementation */
end_comment
begin_struct
DECL|struct|QTzTimeZone
struct|struct
name|QTzTimeZone
block|{
DECL|member|country
name|QLocale
operator|::
name|Country
name|country
decl_stmt|;
DECL|member|comment
name|QByteArray
name|comment
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|// Define as a type as Q_GLOBAL_STATIC doesn't like it
end_comment
begin_typedef
DECL|typedef|QTzTimeZoneHash
typedef|typedef
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QTzTimeZone
argument_list|>
name|QTzTimeZoneHash
typedef|;
end_typedef
begin_comment
comment|// Parse zone.tab table, assume lists all installed zones, if not will need to read directories
end_comment
begin_function
DECL|function|loadTzTimeZones
specifier|static
name|QTzTimeZoneHash
name|loadTzTimeZones
parameter_list|()
block|{
name|QString
name|path
init|=
name|QStringLiteral
argument_list|(
literal|"/usr/share/zoneinfo/zone.tab"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QFile
operator|::
name|exists
argument_list|(
name|path
argument_list|)
condition|)
name|path
operator|=
name|QStringLiteral
argument_list|(
literal|"/usr/lib/zoneinfo/zone.tab"
argument_list|)
expr_stmt|;
name|QFile
name|tzif
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tzif
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return
name|QTzTimeZoneHash
argument_list|()
return|;
name|QTzTimeZoneHash
name|zonesHash
decl_stmt|;
comment|// TODO QTextStream inefficient, replace later
name|QTextStream
name|ts
argument_list|(
operator|&
name|tzif
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|ts
operator|.
name|atEnd
argument_list|()
condition|)
block|{
specifier|const
name|QString
name|line
init|=
name|ts
operator|.
name|readLine
argument_list|()
decl_stmt|;
comment|// Comment lines are prefixed with a #
if|if
condition|(
operator|!
name|line
operator|.
name|isEmpty
argument_list|()
operator|&&
name|line
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'#'
condition|)
block|{
comment|// Data rows are tab-separated columns Region, Coordinates, ID, Optional Comments
specifier|const
name|QStringList
name|parts
init|=
name|line
operator|.
name|split
argument_list|(
literal|'\t'
argument_list|)
decl_stmt|;
name|QTzTimeZone
name|zone
decl_stmt|;
name|zone
operator|.
name|country
operator|=
name|QLocalePrivate
operator|::
name|codeToCountry
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|size
argument_list|()
operator|>
literal|3
condition|)
name|zone
operator|.
name|comment
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|toUtf8
argument_list|()
expr_stmt|;
name|zonesHash
operator|.
name|insert
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toUtf8
argument_list|()
argument_list|,
name|zone
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|zonesHash
return|;
block|}
end_function
begin_comment
comment|// Hash of available system tz files as loaded by loadTzTimeZones()
end_comment
begin_expr_stmt
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
specifier|const
name|QTzTimeZoneHash
argument_list|,
name|tzZones
argument_list|,
operator|(
name|loadTzTimeZones
argument_list|()
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/*     The following is copied and modified from tzfile.h which is in the public domain.     Copied as no compatibility guarantee and is never system installed.     See https://github.com/eggert/tz/blob/master/tzfile.h */
end_comment
begin_define
DECL|macro|TZ_MAGIC
define|#
directive|define
name|TZ_MAGIC
value|"TZif"
end_define
begin_define
DECL|macro|TZ_MAX_TIMES
define|#
directive|define
name|TZ_MAX_TIMES
value|1200
end_define
begin_define
DECL|macro|TZ_MAX_TYPES
define|#
directive|define
name|TZ_MAX_TYPES
value|256
end_define
begin_comment
DECL|macro|TZ_MAX_TYPES
comment|// Limited by what (unsigned char)'s can hold
end_comment
begin_define
DECL|macro|TZ_MAX_CHARS
define|#
directive|define
name|TZ_MAX_CHARS
value|50
end_define
begin_comment
DECL|macro|TZ_MAX_CHARS
comment|// Maximum number of abbreviation characters
end_comment
begin_define
DECL|macro|TZ_MAX_LEAPS
define|#
directive|define
name|TZ_MAX_LEAPS
value|50
end_define
begin_comment
DECL|macro|TZ_MAX_LEAPS
comment|// Maximum number of leap second corrections
end_comment
begin_struct
DECL|struct|QTzHeader
struct|struct
name|QTzHeader
block|{
DECL|member|tzh_magic
name|char
name|tzh_magic
index|[
literal|4
index|]
decl_stmt|;
comment|// TZ_MAGIC
DECL|member|tzh_version
name|char
name|tzh_version
decl_stmt|;
comment|// '\0' or '2' as of 2005
DECL|member|tzh_reserved
name|char
name|tzh_reserved
index|[
literal|15
index|]
decl_stmt|;
comment|// reserved--must be zero
DECL|member|tzh_ttisgmtcnt
name|quint32
name|tzh_ttisgmtcnt
decl_stmt|;
comment|// number of trans. time flags
DECL|member|tzh_ttisstdcnt
name|quint32
name|tzh_ttisstdcnt
decl_stmt|;
comment|// number of trans. time flags
DECL|member|tzh_leapcnt
name|quint32
name|tzh_leapcnt
decl_stmt|;
comment|// number of leap seconds
DECL|member|tzh_timecnt
name|quint32
name|tzh_timecnt
decl_stmt|;
comment|// number of transition times
DECL|member|tzh_typecnt
name|quint32
name|tzh_typecnt
decl_stmt|;
comment|// number of local time types
DECL|member|tzh_charcnt
name|quint32
name|tzh_charcnt
decl_stmt|;
comment|// number of abbr. chars
block|}
struct|;
end_struct
begin_struct
DECL|struct|QTzTransition
struct|struct
name|QTzTransition
block|{
DECL|member|tz_time
name|qint64
name|tz_time
decl_stmt|;
comment|// Transition time
DECL|member|tz_typeind
name|quint8
name|tz_typeind
decl_stmt|;
comment|// Type Index
block|}
struct|;
end_struct
begin_struct
DECL|struct|QTzType
struct|struct
name|QTzType
block|{
DECL|member|tz_gmtoff
name|int
name|tz_gmtoff
decl_stmt|;
comment|// UTC offset in seconds
DECL|member|tz_isdst
name|bool
name|tz_isdst
decl_stmt|;
comment|// Is DST
DECL|member|tz_abbrind
name|quint8
name|tz_abbrind
decl_stmt|;
comment|// abbreviation list index
DECL|member|tz_ttisgmt
name|bool
name|tz_ttisgmt
decl_stmt|;
comment|// Is in UTC time
DECL|member|tz_ttisstd
name|bool
name|tz_ttisstd
decl_stmt|;
comment|// Is in Standard time
block|}
struct|;
end_struct
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|QTzType
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|// TZ File parsing
end_comment
begin_function
DECL|function|parseTzHeader
specifier|static
name|QTzHeader
name|parseTzHeader
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
name|QTzHeader
name|hdr
decl_stmt|;
name|quint8
name|ch
decl_stmt|;
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
comment|// Parse Magic, 4 bytes
name|ds
operator|.
name|readRawData
argument_list|(
name|hdr
operator|.
name|tzh_magic
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|hdr
operator|.
name|tzh_magic
argument_list|,
name|TZ_MAGIC
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|||
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return
name|hdr
return|;
comment|// Parse Version, 1 byte, before 2005 was '\0', since 2005 a '2', since 2013 a '3'
name|ds
operator|>>
name|ch
expr_stmt|;
name|hdr
operator|.
name|tzh_version
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
operator|||
operator|(
name|hdr
operator|.
name|tzh_version
operator|!=
literal|'2'
operator|&&
name|hdr
operator|.
name|tzh_version
operator|!=
literal|'\0'
operator|&&
name|hdr
operator|.
name|tzh_version
operator|!=
literal|'3'
operator|)
condition|)
block|{
return|return
name|hdr
return|;
block|}
comment|// Parse reserved space, 15 bytes
name|ds
operator|.
name|readRawData
argument_list|(
name|hdr
operator|.
name|tzh_reserved
argument_list|,
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return
name|hdr
return|;
comment|// Parse rest of header, 6 x 4-byte transition counts
name|ds
operator|>>
name|hdr
operator|.
name|tzh_ttisgmtcnt
operator|>>
name|hdr
operator|.
name|tzh_ttisstdcnt
operator|>>
name|hdr
operator|.
name|tzh_leapcnt
operator|>>
name|hdr
operator|.
name|tzh_timecnt
operator|>>
name|hdr
operator|.
name|tzh_typecnt
operator|>>
name|hdr
operator|.
name|tzh_charcnt
expr_stmt|;
comment|// Check defined maximums
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
operator|||
name|hdr
operator|.
name|tzh_timecnt
operator|>
name|TZ_MAX_TIMES
operator|||
name|hdr
operator|.
name|tzh_typecnt
operator|>
name|TZ_MAX_TYPES
operator|||
name|hdr
operator|.
name|tzh_charcnt
operator|>
name|TZ_MAX_CHARS
operator|||
name|hdr
operator|.
name|tzh_leapcnt
operator|>
name|TZ_MAX_LEAPS
operator|||
name|hdr
operator|.
name|tzh_ttisgmtcnt
operator|>
name|hdr
operator|.
name|tzh_typecnt
operator|||
name|hdr
operator|.
name|tzh_ttisstdcnt
operator|>
name|hdr
operator|.
name|tzh_typecnt
condition|)
block|{
return|return
name|hdr
return|;
block|}
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|hdr
return|;
block|}
end_function
begin_function
DECL|function|parseTzTransitions
specifier|static
name|QList
argument_list|<
name|QTzTransition
argument_list|>
name|parseTzTransitions
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|,
name|int
name|tzh_timecnt
parameter_list|,
name|bool
name|longTran
parameter_list|)
block|{
name|QList
argument_list|<
name|QTzTransition
argument_list|>
name|tranList
decl_stmt|;
if|if
condition|(
name|longTran
condition|)
block|{
comment|// Parse tzh_timecnt x 8-byte transition times
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tzh_timecnt
operator|&&
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|;
operator|++
name|i
control|)
block|{
name|QTzTransition
name|tran
decl_stmt|;
name|ds
operator|>>
name|tran
operator|.
name|tz_time
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|)
name|tranList
operator|.
name|append
argument_list|(
name|tran
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Parse tzh_timecnt x 4-byte transition times
name|int
name|val
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tzh_timecnt
operator|&&
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|;
operator|++
name|i
control|)
block|{
name|QTzTransition
name|tran
decl_stmt|;
name|ds
operator|>>
name|val
expr_stmt|;
name|tran
operator|.
name|tz_time
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|)
name|tranList
operator|.
name|append
argument_list|(
name|tran
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Parse tzh_timecnt x 1-byte transition type index
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tzh_timecnt
operator|&&
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|;
operator|++
name|i
control|)
block|{
name|quint8
name|typeind
decl_stmt|;
name|ds
operator|>>
name|typeind
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|)
name|tranList
index|[
name|i
index|]
operator|.
name|tz_typeind
operator|=
name|typeind
expr_stmt|;
block|}
return|return
name|tranList
return|;
block|}
end_function
begin_function
DECL|function|parseTzTypes
specifier|static
name|QList
argument_list|<
name|QTzType
argument_list|>
name|parseTzTypes
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|,
name|int
name|tzh_typecnt
parameter_list|)
block|{
name|QList
argument_list|<
name|QTzType
argument_list|>
name|typeList
decl_stmt|;
comment|// Parse tzh_typecnt x transition types
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tzh_typecnt
operator|&&
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|;
operator|++
name|i
control|)
block|{
name|QTzType
name|type
decl_stmt|;
comment|// Parse UTC Offset, 4 bytes
name|ds
operator|>>
name|type
operator|.
name|tz_gmtoff
expr_stmt|;
comment|// Parse Is DST flag, 1 byte
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|)
name|ds
operator|>>
name|type
operator|.
name|tz_isdst
expr_stmt|;
comment|// Parse Abbreviation Array Index, 1 byte
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|)
name|ds
operator|>>
name|type
operator|.
name|tz_abbrind
expr_stmt|;
comment|// Set defaults in case not populated later
name|type
operator|.
name|tz_ttisgmt
operator|=
literal|false
expr_stmt|;
name|type
operator|.
name|tz_ttisstd
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|)
name|typeList
operator|.
name|append
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|typeList
return|;
block|}
end_function
begin_function
DECL|function|parseTzAbbreviations
specifier|static
name|QMap
argument_list|<
name|int
argument_list|,
name|QByteArray
argument_list|>
name|parseTzAbbreviations
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|,
name|int
name|tzh_charcnt
parameter_list|,
name|QList
argument_list|<
name|QTzType
argument_list|>
name|typeList
parameter_list|)
block|{
comment|// Parse the abbreviation list which is tzh_charcnt long with '\0' separated strings. The
comment|// QTzType.tz_abbrind index points to the first char of the abbreviation in the array, not the
comment|// occurrence in the list. It can also point to a partial string so we need to use the actual typeList
comment|// index values when parsing.  By using a map with tz_abbrind as ordered key we get both index
comment|// methods in one data structure and can convert the types afterwards.
name|QMap
argument_list|<
name|int
argument_list|,
name|QByteArray
argument_list|>
name|map
decl_stmt|;
name|quint8
name|ch
decl_stmt|;
name|QByteArray
name|input
decl_stmt|;
comment|// First parse the full abbrev string
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tzh_charcnt
operator|&&
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|;
operator|++
name|i
control|)
block|{
name|ds
operator|>>
name|ch
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|)
name|input
operator|.
name|append
argument_list|(
name|char
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|map
return|;
block|}
comment|// Then extract all the substrings pointed to by typeList
foreach|foreach
control|(
specifier|const
name|QTzType
name|type
decl|,
name|typeList
control|)
block|{
name|QByteArray
name|abbrev
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|type
operator|.
name|tz_abbrind
init|;
name|input
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
name|abbrev
operator|.
name|append
argument_list|(
name|input
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// Have reached end of an abbreviation, so add to map
name|map
index|[
name|type
operator|.
name|tz_abbrind
index|]
operator|=
name|abbrev
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
end_function
begin_function
DECL|function|parseTzLeapSeconds
specifier|static
name|void
name|parseTzLeapSeconds
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|,
name|int
name|tzh_leapcnt
parameter_list|,
name|bool
name|longTran
parameter_list|)
block|{
comment|// Parse tzh_leapcnt x pairs of leap seconds
comment|// We don't use leap seconds, so only read and don't store
name|qint64
name|val
decl_stmt|;
if|if
condition|(
name|longTran
condition|)
block|{
name|qint64
name|time
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tzh_leapcnt
operator|&&
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|;
operator|++
name|i
control|)
block|{
comment|// Parse Leap Occurrence Time, 8 bytes
name|ds
operator|>>
name|time
expr_stmt|;
comment|// Parse Leap Seconds To Apply, 4 bytes
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|)
name|ds
operator|>>
name|val
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tzh_leapcnt
operator|&&
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|;
operator|++
name|i
control|)
block|{
comment|// Parse Leap Occurrence Time, 4 bytes
name|ds
operator|>>
name|val
expr_stmt|;
comment|// Parse Leap Seconds To Apply, 4 bytes
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|)
name|ds
operator|>>
name|val
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|parseTzIndicators
specifier|static
name|QList
argument_list|<
name|QTzType
argument_list|>
name|parseTzIndicators
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|,
specifier|const
name|QList
argument_list|<
name|QTzType
argument_list|>
modifier|&
name|typeList
parameter_list|,
name|int
name|tzh_ttisstdcnt
parameter_list|,
name|int
name|tzh_ttisgmtcnt
parameter_list|)
block|{
name|QList
argument_list|<
name|QTzType
argument_list|>
name|list
init|=
name|typeList
decl_stmt|;
name|bool
name|temp
decl_stmt|;
comment|// Parse tzh_ttisstdcnt x 1-byte standard/wall indicators
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tzh_ttisstdcnt
operator|&&
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|;
operator|++
name|i
control|)
block|{
name|ds
operator|>>
name|temp
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|)
name|list
index|[
name|i
index|]
operator|.
name|tz_ttisstd
operator|=
name|temp
expr_stmt|;
block|}
comment|// Parse tzh_ttisgmtcnt x 1-byte UTC/local indicators
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tzh_ttisgmtcnt
operator|&&
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|;
operator|++
name|i
control|)
block|{
name|ds
operator|>>
name|temp
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|)
name|list
index|[
name|i
index|]
operator|.
name|tz_ttisgmt
operator|=
name|temp
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|parseTzPosixRule
specifier|static
name|QByteArray
name|parseTzPosixRule
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|)
block|{
comment|// Parse POSIX rule, variable length '\n' enclosed
name|QByteArray
name|rule
decl_stmt|;
name|quint8
name|ch
decl_stmt|;
name|ds
operator|>>
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\n'
operator|||
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return
name|rule
return|;
name|ds
operator|>>
name|ch
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ds
operator|.
name|status
argument_list|()
operator|==
name|QDataStream
operator|::
name|Ok
condition|)
block|{
name|rule
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|ch
argument_list|)
expr_stmt|;
name|ds
operator|>>
name|ch
expr_stmt|;
block|}
return|return
name|rule
return|;
block|}
end_function
begin_function
DECL|function|calculateDowDate
specifier|static
name|QDate
name|calculateDowDate
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|dayOfWeek
parameter_list|,
name|int
name|week
parameter_list|)
block|{
name|QDate
name|date
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|startDow
init|=
name|date
operator|.
name|dayOfWeek
argument_list|()
decl_stmt|;
if|if
condition|(
name|startDow
operator|<=
name|dayOfWeek
condition|)
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
name|dayOfWeek
operator|-
name|startDow
operator|-
literal|7
argument_list|)
expr_stmt|;
else|else
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
name|dayOfWeek
operator|-
name|startDow
argument_list|)
expr_stmt|;
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
name|week
operator|*
literal|7
argument_list|)
expr_stmt|;
while|while
condition|(
name|date
operator|.
name|month
argument_list|()
operator|!=
name|month
condition|)
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
operator|-
literal|7
argument_list|)
expr_stmt|;
return|return
name|date
return|;
block|}
end_function
begin_function
DECL|function|calculatePosixDate
specifier|static
name|QDate
name|calculatePosixDate
parameter_list|(
specifier|const
name|QByteArray
name|dateRule
parameter_list|,
name|int
name|year
parameter_list|)
block|{
comment|// Can start with M, J, or a digit
if|if
condition|(
name|dateRule
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'M'
condition|)
block|{
comment|// nth week in month format "Mmonth.week.dow"
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|dateParts
init|=
name|dateRule
operator|.
name|split
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|int
name|month
init|=
name|dateParts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|int
name|week
init|=
name|dateParts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|int
name|dow
init|=
name|dateParts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|dow
operator|==
literal|0
condition|)
operator|++
name|dow
expr_stmt|;
return|return
name|calculateDowDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|dow
argument_list|,
name|week
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|dateRule
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'J'
condition|)
block|{
comment|// Day of Year ignores Feb 29
name|int
name|doy
init|=
name|dateRule
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
name|QDate
name|date
init|=
name|QDate
argument_list|(
name|year
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|.
name|addDays
argument_list|(
name|doy
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|QDate
operator|::
name|isLeapYear
argument_list|(
name|date
operator|.
name|year
argument_list|()
argument_list|)
condition|)
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|date
return|;
block|}
else|else
block|{
comment|// Day of Year includes Feb 29
name|int
name|doy
init|=
name|dateRule
operator|.
name|toInt
argument_list|()
decl_stmt|;
return|return
name|QDate
argument_list|(
name|year
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|.
name|addDays
argument_list|(
name|doy
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|parsePosixTime
specifier|static
name|QTime
name|parsePosixTime
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|timeRule
parameter_list|)
block|{
comment|// Format "HH:mm:ss", put check parts count just in case
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|parts
init|=
name|timeRule
operator|.
name|split
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|parts
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|3
condition|)
return|return
name|QTime
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|,
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|,
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
return|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|2
condition|)
return|return
name|QTime
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|,
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|1
condition|)
return|return
name|QTime
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|QTime
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parsePosixOffset
specifier|static
name|int
name|parsePosixOffset
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|timeRule
parameter_list|)
block|{
comment|// Format "[+|-]hh[:mm[:ss]]"
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|parts
init|=
name|timeRule
operator|.
name|split
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|parts
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|3
condition|)
return|return
operator|(
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|()
operator|*
operator|-
literal|60
operator|*
literal|60
operator|)
operator|+
operator|(
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
operator|*
literal|60
operator|)
operator|+
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
return|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|2
condition|)
return|return
operator|(
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|()
operator|*
operator|-
literal|60
operator|*
literal|60
operator|)
operator|+
operator|(
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
operator|*
literal|60
operator|)
return|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|1
condition|)
return|return
operator|(
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|()
operator|*
operator|-
literal|60
operator|*
literal|60
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|calculatePosixTransitions
specifier|static
name|QList
argument_list|<
name|QTimeZonePrivate
operator|::
name|Data
argument_list|>
name|calculatePosixTransitions
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|posixRule
parameter_list|,
name|int
name|startYear
parameter_list|,
name|int
name|endYear
parameter_list|,
name|int
name|lastTranMSecs
parameter_list|)
block|{
name|QList
argument_list|<
name|QTimeZonePrivate
operator|::
name|Data
argument_list|>
name|list
decl_stmt|;
comment|// Limit year by qint64 max size for msecs
if|if
condition|(
name|startYear
operator|>
literal|292278994
condition|)
name|startYear
operator|=
literal|292278994
expr_stmt|;
if|if
condition|(
name|endYear
operator|>
literal|292278994
condition|)
name|endYear
operator|=
literal|292278994
expr_stmt|;
comment|// POSIX Format is like "TZ=CST6CDT,M3.2.0/2:00:00,M11.1.0/2:00:00"
comment|// i.e. "std offset dst [offset],start[/time],end[/time]"
comment|// See http://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|parts
init|=
name|posixRule
operator|.
name|split
argument_list|(
literal|','
argument_list|)
decl_stmt|;
name|QString
name|name
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|stdName
decl_stmt|;
name|QString
name|stdOffsetString
decl_stmt|;
name|QString
name|dstName
decl_stmt|;
name|QString
name|dstOffsetString
decl_stmt|;
name|bool
name|parsedStdName
init|=
literal|false
decl_stmt|;
name|bool
name|parsedStdOffset
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|name
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|name
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isLetter
argument_list|()
condition|)
block|{
if|if
condition|(
name|parsedStdName
condition|)
block|{
name|parsedStdOffset
operator|=
literal|true
expr_stmt|;
name|dstName
operator|.
name|append
argument_list|(
name|name
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stdName
operator|.
name|append
argument_list|(
name|name
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|parsedStdName
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|parsedStdOffset
condition|)
name|dstOffsetString
operator|.
name|append
argument_list|(
name|name
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|stdOffsetString
operator|.
name|append
argument_list|(
name|name
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|utcOffset
init|=
name|parsePosixOffset
argument_list|(
name|stdOffsetString
operator|.
name|toUtf8
argument_list|()
argument_list|)
decl_stmt|;
comment|// If only the name part then no transitions
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
name|QTimeZonePrivate
operator|::
name|Data
name|data
decl_stmt|;
name|data
operator|.
name|atMSecsSinceEpoch
operator|=
name|lastTranMSecs
expr_stmt|;
name|data
operator|.
name|offsetFromUtc
operator|=
name|utcOffset
expr_stmt|;
name|data
operator|.
name|standardTimeOffset
operator|=
name|utcOffset
expr_stmt|;
name|data
operator|.
name|daylightTimeOffset
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|abbreviation
operator|=
name|stdName
expr_stmt|;
name|list
operator|<<
name|data
expr_stmt|;
return|return
name|list
return|;
block|}
comment|// If not populated the total dst offset is 1 hour
name|int
name|dstOffset
init|=
name|utcOffset
operator|+
operator|(
literal|60
operator|*
literal|60
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|dstOffsetString
operator|.
name|isEmpty
argument_list|()
condition|)
name|dstOffset
operator|=
name|parsePosixOffset
argument_list|(
name|dstOffsetString
operator|.
name|toUtf8
argument_list|()
argument_list|)
expr_stmt|;
comment|// Get the std to dst transtion details
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|dstParts
init|=
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|split
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|QByteArray
name|dstDateRule
init|=
name|dstParts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QTime
name|dstTime
decl_stmt|;
if|if
condition|(
name|dstParts
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
name|dstTime
operator|=
name|parsePosixTime
argument_list|(
name|dstParts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dstTime
operator|=
name|QTime
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Get the dst to std transtion details
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|stdParts
init|=
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|split
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|QByteArray
name|stdDateRule
init|=
name|stdParts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QTime
name|stdTime
decl_stmt|;
if|if
condition|(
name|stdParts
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
name|stdTime
operator|=
name|parsePosixTime
argument_list|(
name|stdParts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|stdTime
operator|=
name|QTime
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|year
init|=
name|startYear
init|;
name|year
operator|<=
name|endYear
condition|;
operator|++
name|year
control|)
block|{
name|QTimeZonePrivate
operator|::
name|Data
name|dstData
decl_stmt|;
name|QDateTime
name|dst
argument_list|(
name|calculatePosixDate
argument_list|(
name|dstDateRule
argument_list|,
name|year
argument_list|)
argument_list|,
name|dstTime
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
name|dstData
operator|.
name|atMSecsSinceEpoch
operator|=
name|dst
operator|.
name|toMSecsSinceEpoch
argument_list|()
operator|-
operator|(
name|utcOffset
operator|*
literal|1000
operator|)
expr_stmt|;
name|dstData
operator|.
name|offsetFromUtc
operator|=
name|dstOffset
expr_stmt|;
name|dstData
operator|.
name|standardTimeOffset
operator|=
name|utcOffset
expr_stmt|;
name|dstData
operator|.
name|daylightTimeOffset
operator|=
name|dstOffset
operator|-
name|utcOffset
expr_stmt|;
name|dstData
operator|.
name|abbreviation
operator|=
name|dstName
expr_stmt|;
name|QTimeZonePrivate
operator|::
name|Data
name|stdData
decl_stmt|;
name|QDateTime
name|std
argument_list|(
name|calculatePosixDate
argument_list|(
name|stdDateRule
argument_list|,
name|year
argument_list|)
argument_list|,
name|stdTime
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
name|stdData
operator|.
name|atMSecsSinceEpoch
operator|=
name|std
operator|.
name|toMSecsSinceEpoch
argument_list|()
operator|-
operator|(
name|dstOffset
operator|*
literal|1000
operator|)
expr_stmt|;
name|stdData
operator|.
name|offsetFromUtc
operator|=
name|utcOffset
expr_stmt|;
name|stdData
operator|.
name|standardTimeOffset
operator|=
name|utcOffset
expr_stmt|;
name|stdData
operator|.
name|daylightTimeOffset
operator|=
literal|0
expr_stmt|;
name|stdData
operator|.
name|abbreviation
operator|=
name|stdName
expr_stmt|;
comment|// Part of the high year will overflow
if|if
condition|(
name|year
operator|==
literal|292278994
operator|&&
operator|(
name|dstData
operator|.
name|atMSecsSinceEpoch
operator|<
literal|0
operator|||
name|stdData
operator|.
name|atMSecsSinceEpoch
operator|<
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|dstData
operator|.
name|atMSecsSinceEpoch
operator|>
literal|0
condition|)
block|{
name|list
operator|<<
name|dstData
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stdData
operator|.
name|atMSecsSinceEpoch
operator|>
literal|0
condition|)
block|{
name|list
operator|<<
name|stdData
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dst
operator|<
name|std
condition|)
block|{
name|list
operator|<<
name|dstData
operator|<<
name|stdData
expr_stmt|;
block|}
else|else
block|{
name|list
operator|<<
name|stdData
operator|<<
name|dstData
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|// Create the system default time zone
end_comment
begin_constructor
DECL|function|QTzTimeZonePrivate
name|QTzTimeZonePrivate
operator|::
name|QTzTimeZonePrivate
parameter_list|()
ifdef|#
directive|ifdef
name|QT_USE_ICU
member_init_list|:
name|m_icu
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
comment|// QT_USE_ICU
block|{
name|init
argument_list|(
name|systemTimeZoneId
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|// Create a named time zone
end_comment
begin_constructor
DECL|function|QTzTimeZonePrivate
name|QTzTimeZonePrivate
operator|::
name|QTzTimeZonePrivate
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ianaId
parameter_list|)
ifdef|#
directive|ifdef
name|QT_USE_ICU
member_init_list|:
name|m_icu
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
comment|// QT_USE_ICU
block|{
name|init
argument_list|(
name|ianaId
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QTzTimeZonePrivate
name|QTzTimeZonePrivate
operator|::
name|QTzTimeZonePrivate
parameter_list|(
specifier|const
name|QTzTimeZonePrivate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|QTimeZonePrivate
argument_list|(
name|other
argument_list|)
member_init_list|,
name|m_tranTimes
argument_list|(
name|other
operator|.
name|m_tranTimes
argument_list|)
member_init_list|,
name|m_tranRules
argument_list|(
name|other
operator|.
name|m_tranRules
argument_list|)
member_init_list|,
name|m_abbreviations
argument_list|(
name|other
operator|.
name|m_abbreviations
argument_list|)
member_init_list|,
ifdef|#
directive|ifdef
name|QT_USE_ICU
name|m_icu
argument_list|(
name|other
operator|.
name|m_icu
argument_list|)
member_init_list|,
endif|#
directive|endif
comment|// QT_USE_ICU
name|m_posixRule
argument_list|(
name|other
operator|.
name|m_posixRule
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QTzTimeZonePrivate
name|QTzTimeZonePrivate
operator|::
name|~
name|QTzTimeZonePrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|clone
name|QTimeZonePrivate
modifier|*
name|QTzTimeZonePrivate
operator|::
name|clone
parameter_list|()
block|{
return|return
operator|new
name|QTzTimeZonePrivate
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QTzTimeZonePrivate
operator|::
name|init
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ianaId
parameter_list|)
block|{
name|QFile
name|tzif
decl_stmt|;
if|if
condition|(
name|ianaId
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Open system tz
name|tzif
operator|.
name|setFileName
argument_list|(
name|QStringLiteral
argument_list|(
literal|"/etc/localtime"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tzif
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
comment|// Open named tz, try modern path first, if fails try legacy path
name|tzif
operator|.
name|setFileName
argument_list|(
name|QLatin1String
argument_list|(
literal|"/usr/share/zoneinfo/"
argument_list|)
operator|+
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|ianaId
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tzif
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|tzif
operator|.
name|setFileName
argument_list|(
name|QLatin1String
argument_list|(
literal|"/usr/lib/zoneinfo/"
argument_list|)
operator|+
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|ianaId
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tzif
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return;
block|}
block|}
name|QDataStream
name|ds
argument_list|(
operator|&
name|tzif
argument_list|)
decl_stmt|;
comment|// Parse the old version block of data
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|QTzHeader
name|hdr
init|=
name|parseTzHeader
argument_list|(
name|ds
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
operator|||
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return;
name|QList
argument_list|<
name|QTzTransition
argument_list|>
name|tranList
init|=
name|parseTzTransitions
argument_list|(
name|ds
argument_list|,
name|hdr
operator|.
name|tzh_timecnt
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return;
name|QList
argument_list|<
name|QTzType
argument_list|>
name|typeList
init|=
name|parseTzTypes
argument_list|(
name|ds
argument_list|,
name|hdr
operator|.
name|tzh_typecnt
argument_list|)
decl_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return;
name|QMap
argument_list|<
name|int
argument_list|,
name|QByteArray
argument_list|>
name|abbrevMap
init|=
name|parseTzAbbreviations
argument_list|(
name|ds
argument_list|,
name|hdr
operator|.
name|tzh_charcnt
argument_list|,
name|typeList
argument_list|)
decl_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return;
name|parseTzLeapSeconds
argument_list|(
name|ds
argument_list|,
name|hdr
operator|.
name|tzh_leapcnt
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return;
name|typeList
operator|=
name|parseTzIndicators
argument_list|(
name|ds
argument_list|,
name|typeList
argument_list|,
name|hdr
operator|.
name|tzh_ttisstdcnt
argument_list|,
name|hdr
operator|.
name|tzh_ttisgmtcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return;
comment|// If version 2 then parse the second block of data
if|if
condition|(
name|hdr
operator|.
name|tzh_version
operator|==
literal|'2'
operator|||
name|hdr
operator|.
name|tzh_version
operator|==
literal|'3'
condition|)
block|{
name|ok
operator|=
literal|false
expr_stmt|;
name|QTzHeader
name|hdr2
init|=
name|parseTzHeader
argument_list|(
name|ds
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
operator|||
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return;
name|tranList
operator|=
name|parseTzTransitions
argument_list|(
name|ds
argument_list|,
name|hdr2
operator|.
name|tzh_timecnt
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return;
name|typeList
operator|=
name|parseTzTypes
argument_list|(
name|ds
argument_list|,
name|hdr2
operator|.
name|tzh_typecnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return;
name|abbrevMap
operator|=
name|parseTzAbbreviations
argument_list|(
name|ds
argument_list|,
name|hdr2
operator|.
name|tzh_charcnt
argument_list|,
name|typeList
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return;
name|parseTzLeapSeconds
argument_list|(
name|ds
argument_list|,
name|hdr2
operator|.
name|tzh_leapcnt
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return;
name|typeList
operator|=
name|parseTzIndicators
argument_list|(
name|ds
argument_list|,
name|typeList
argument_list|,
name|hdr2
operator|.
name|tzh_ttisstdcnt
argument_list|,
name|hdr2
operator|.
name|tzh_ttisgmtcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return;
name|m_posixRule
operator|=
name|parseTzPosixRule
argument_list|(
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return;
block|}
comment|// Translate the TZ file into internal format
comment|// Translate the array index based tz_abbrind into list index
name|m_abbreviations
operator|=
name|abbrevMap
operator|.
name|values
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|int
argument_list|>
name|abbrindList
init|=
name|abbrevMap
operator|.
name|keys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|typeList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|typeList
index|[
name|i
index|]
operator|.
name|tz_abbrind
operator|=
name|abbrindList
operator|.
name|indexOf
argument_list|(
name|typeList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|tz_abbrind
argument_list|)
expr_stmt|;
comment|// Offsets are stored as total offset, want to know separate UTC and DST offsets
comment|// so find the first non-dst transition to use as base UTC Offset
name|int
name|utcOffset
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QTzTransition
modifier|&
name|tran
decl|,
name|tranList
control|)
block|{
if|if
condition|(
operator|!
name|typeList
operator|.
name|at
argument_list|(
name|tran
operator|.
name|tz_typeind
argument_list|)
operator|.
name|tz_isdst
condition|)
block|{
name|utcOffset
operator|=
name|typeList
operator|.
name|at
argument_list|(
name|tran
operator|.
name|tz_typeind
argument_list|)
operator|.
name|tz_gmtoff
expr_stmt|;
break|break;
block|}
block|}
comment|// Now for each transition time calculate our rule and save them
foreach|foreach
control|(
specifier|const
name|QTzTransition
modifier|&
name|tz_tran
decl|,
name|tranList
control|)
block|{
name|QTzTransitionTime
name|tran
decl_stmt|;
name|QTzTransitionRule
name|rule
decl_stmt|;
specifier|const
name|QTzType
name|tz_type
init|=
name|typeList
operator|.
name|at
argument_list|(
name|tz_tran
operator|.
name|tz_typeind
argument_list|)
decl_stmt|;
comment|// Calculate the associated Rule
if|if
condition|(
operator|!
name|tz_type
operator|.
name|tz_isdst
condition|)
name|utcOffset
operator|=
name|tz_type
operator|.
name|tz_gmtoff
expr_stmt|;
name|rule
operator|.
name|stdOffset
operator|=
name|utcOffset
expr_stmt|;
name|rule
operator|.
name|dstOffset
operator|=
name|tz_type
operator|.
name|tz_gmtoff
operator|-
name|utcOffset
expr_stmt|;
name|rule
operator|.
name|abbreviationIndex
operator|=
name|tz_type
operator|.
name|tz_abbrind
expr_stmt|;
comment|// If the rule already exist then use that, otherwise add it
name|int
name|ruleIndex
init|=
name|m_tranRules
operator|.
name|indexOf
argument_list|(
name|rule
argument_list|)
decl_stmt|;
if|if
condition|(
name|ruleIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|m_tranRules
operator|.
name|append
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|tran
operator|.
name|ruleIndex
operator|=
name|m_tranRules
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tran
operator|.
name|ruleIndex
operator|=
name|ruleIndex
expr_stmt|;
block|}
comment|// TODO convert to UTC if not in UTC
if|if
condition|(
name|tz_type
operator|.
name|tz_ttisgmt
condition|)
name|tran
operator|.
name|atMSecsSinceEpoch
operator|=
name|tz_tran
operator|.
name|tz_time
operator|*
literal|1000
expr_stmt|;
elseif|else
if|if
condition|(
name|tz_type
operator|.
name|tz_ttisstd
condition|)
name|tran
operator|.
name|atMSecsSinceEpoch
operator|=
name|tz_tran
operator|.
name|tz_time
operator|*
literal|1000
expr_stmt|;
else|else
name|tran
operator|.
name|atMSecsSinceEpoch
operator|=
name|tz_tran
operator|.
name|tz_time
operator|*
literal|1000
expr_stmt|;
name|m_tranTimes
operator|.
name|append
argument_list|(
name|tran
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ianaId
operator|.
name|isEmpty
argument_list|()
condition|)
name|m_id
operator|=
name|systemTimeZoneId
argument_list|()
expr_stmt|;
else|else
name|m_id
operator|=
name|ianaId
expr_stmt|;
block|}
end_function
begin_function
DECL|function|country
name|QLocale
operator|::
name|Country
name|QTzTimeZonePrivate
operator|::
name|country
parameter_list|()
specifier|const
block|{
return|return
name|tzZones
operator|->
name|value
argument_list|(
name|m_id
argument_list|)
operator|.
name|country
return|;
block|}
end_function
begin_function
DECL|function|comment
name|QString
name|QTzTimeZonePrivate
operator|::
name|comment
parameter_list|()
specifier|const
block|{
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
name|tzZones
operator|->
name|value
argument_list|(
name|m_id
argument_list|)
operator|.
name|comment
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|displayName
name|QString
name|QTzTimeZonePrivate
operator|::
name|displayName
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|,
name|QTimeZone
operator|::
name|NameType
name|nameType
parameter_list|,
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
specifier|const
block|{
ifdef|#
directive|ifdef
name|QT_USE_ICU
if|if
condition|(
operator|!
name|m_icu
condition|)
name|m_icu
operator|=
operator|new
name|QIcuTimeZonePrivate
argument_list|(
name|m_id
argument_list|)
expr_stmt|;
comment|// TODO small risk may not match if tran times differ due to outdated files
comment|// TODO Some valid TZ names are not valid ICU names, use translation table?
if|if
condition|(
name|m_icu
operator|->
name|isValid
argument_list|()
condition|)
return|return
name|m_icu
operator|->
name|displayName
argument_list|(
name|atMSecsSinceEpoch
argument_list|,
name|nameType
argument_list|,
name|locale
argument_list|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|nameType
argument_list|)
name|Q_UNUSED
argument_list|(
argument|locale
argument_list|)
endif|#
directive|endif
comment|// QT_USE_ICU
return|return
name|abbreviation
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|displayName
name|QString
name|QTzTimeZonePrivate
operator|::
name|displayName
parameter_list|(
name|QTimeZone
operator|::
name|TimeType
name|timeType
parameter_list|,
name|QTimeZone
operator|::
name|NameType
name|nameType
parameter_list|,
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
specifier|const
block|{
ifdef|#
directive|ifdef
name|QT_USE_ICU
if|if
condition|(
operator|!
name|m_icu
condition|)
name|m_icu
operator|=
operator|new
name|QIcuTimeZonePrivate
argument_list|(
name|m_id
argument_list|)
expr_stmt|;
comment|// TODO small risk may not match if tran times differ due to outdated files
comment|// TODO Some valid TZ names are not valid ICU names, use translation table?
if|if
condition|(
name|m_icu
operator|->
name|isValid
argument_list|()
condition|)
return|return
name|m_icu
operator|->
name|displayName
argument_list|(
name|timeType
argument_list|,
name|nameType
argument_list|,
name|locale
argument_list|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|timeType
argument_list|)
name|Q_UNUSED
argument_list|(
argument|nameType
argument_list|)
name|Q_UNUSED
argument_list|(
argument|locale
argument_list|)
endif|#
directive|endif
comment|// QT_USE_ICU
comment|// If no ICU available then have to use abbreviations instead
comment|// Abbreviations don't have GenericTime
if|if
condition|(
name|timeType
operator|==
name|QTimeZone
operator|::
name|GenericTime
condition|)
name|timeType
operator|=
name|QTimeZone
operator|::
name|StandardTime
expr_stmt|;
comment|// Get current tran, if valid and is what we want, then use it
specifier|const
name|qint64
name|currentMSecs
init|=
name|QDateTime
operator|::
name|currentMSecsSinceEpoch
argument_list|()
decl_stmt|;
name|QTimeZonePrivate
operator|::
name|Data
name|tran
init|=
name|data
argument_list|(
name|currentMSecs
argument_list|)
decl_stmt|;
if|if
condition|(
name|tran
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
operator|&&
operator|(
operator|(
name|timeType
operator|==
name|QTimeZone
operator|::
name|DaylightTime
operator|&&
name|tran
operator|.
name|daylightTimeOffset
operator|!=
literal|0
operator|)
operator|||
operator|(
name|timeType
operator|==
name|QTimeZone
operator|::
name|StandardTime
operator|&&
name|tran
operator|.
name|daylightTimeOffset
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
return|return
name|tran
operator|.
name|abbreviation
return|;
block|}
comment|// Otherwise get next tran and if valid and is what we want, then use it
name|tran
operator|=
name|nextTransition
argument_list|(
name|currentMSecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tran
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
operator|&&
operator|(
operator|(
name|timeType
operator|==
name|QTimeZone
operator|::
name|DaylightTime
operator|&&
name|tran
operator|.
name|daylightTimeOffset
operator|!=
literal|0
operator|)
operator|||
operator|(
name|timeType
operator|==
name|QTimeZone
operator|::
name|StandardTime
operator|&&
name|tran
operator|.
name|daylightTimeOffset
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
return|return
name|tran
operator|.
name|abbreviation
return|;
block|}
comment|// Otherwise get prev tran and if valid and is what we want, then use it
name|tran
operator|=
name|previousTransition
argument_list|(
name|currentMSecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tran
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
condition|)
name|tran
operator|=
name|previousTransition
argument_list|(
name|tran
operator|.
name|atMSecsSinceEpoch
argument_list|)
expr_stmt|;
if|if
condition|(
name|tran
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
operator|&&
operator|(
operator|(
name|timeType
operator|==
name|QTimeZone
operator|::
name|DaylightTime
operator|&&
name|tran
operator|.
name|daylightTimeOffset
operator|!=
literal|0
operator|)
operator|||
operator|(
name|timeType
operator|==
name|QTimeZone
operator|::
name|StandardTime
operator|&&
name|tran
operator|.
name|daylightTimeOffset
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
return|return
name|tran
operator|.
name|abbreviation
return|;
block|}
comment|// Otherwise is strange sequence, so work backwards through trans looking for first match, if any
for|for
control|(
name|int
name|i
init|=
name|m_tranTimes
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|m_tranTimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|atMSecsSinceEpoch
operator|<=
name|currentMSecs
condition|)
block|{
name|tran
operator|=
name|dataForTzTransition
argument_list|(
name|m_tranTimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|timeType
operator|==
name|QTimeZone
operator|::
name|DaylightTime
operator|&&
name|tran
operator|.
name|daylightTimeOffset
operator|!=
literal|0
operator|)
operator|||
operator|(
name|timeType
operator|==
name|QTimeZone
operator|::
name|StandardTime
operator|&&
name|tran
operator|.
name|daylightTimeOffset
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|tran
operator|.
name|abbreviation
return|;
block|}
block|}
block|}
comment|// Otherwise if no match use current data
return|return
name|data
argument_list|(
name|currentMSecs
argument_list|)
operator|.
name|abbreviation
return|;
block|}
end_function
begin_function
DECL|function|abbreviation
name|QString
name|QTzTimeZonePrivate
operator|::
name|abbreviation
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
return|return
name|data
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
operator|.
name|abbreviation
return|;
block|}
end_function
begin_function
DECL|function|offsetFromUtc
name|int
name|QTzTimeZonePrivate
operator|::
name|offsetFromUtc
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
specifier|const
name|QTimeZonePrivate
operator|::
name|Data
name|tran
init|=
name|data
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
decl_stmt|;
return|return
name|tran
operator|.
name|standardTimeOffset
operator|+
name|tran
operator|.
name|daylightTimeOffset
return|;
block|}
end_function
begin_function
DECL|function|standardTimeOffset
name|int
name|QTzTimeZonePrivate
operator|::
name|standardTimeOffset
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
return|return
name|data
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
operator|.
name|standardTimeOffset
return|;
block|}
end_function
begin_function
DECL|function|daylightTimeOffset
name|int
name|QTzTimeZonePrivate
operator|::
name|daylightTimeOffset
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
return|return
name|data
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
operator|.
name|daylightTimeOffset
return|;
block|}
end_function
begin_function
DECL|function|hasDaylightTime
name|bool
name|QTzTimeZonePrivate
operator|::
name|hasDaylightTime
parameter_list|()
specifier|const
block|{
comment|// TODO Perhaps cache as frequently accessed?
foreach|foreach
control|(
specifier|const
name|QTzTransitionRule
modifier|&
name|rule
decl|,
name|m_tranRules
control|)
block|{
if|if
condition|(
name|rule
operator|.
name|dstOffset
operator|!=
literal|0
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|isDaylightTime
name|bool
name|QTzTimeZonePrivate
operator|::
name|isDaylightTime
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|daylightTimeOffset
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|dataForTzTransition
name|QTimeZonePrivate
operator|::
name|Data
name|QTzTimeZonePrivate
operator|::
name|dataForTzTransition
parameter_list|(
name|QTzTransitionTime
name|tran
parameter_list|)
specifier|const
block|{
name|QTimeZonePrivate
operator|::
name|Data
name|data
decl_stmt|;
name|data
operator|.
name|atMSecsSinceEpoch
operator|=
name|tran
operator|.
name|atMSecsSinceEpoch
expr_stmt|;
name|QTzTransitionRule
name|rule
init|=
name|m_tranRules
operator|.
name|at
argument_list|(
name|tran
operator|.
name|ruleIndex
argument_list|)
decl_stmt|;
name|data
operator|.
name|standardTimeOffset
operator|=
name|rule
operator|.
name|stdOffset
expr_stmt|;
name|data
operator|.
name|daylightTimeOffset
operator|=
name|rule
operator|.
name|dstOffset
expr_stmt|;
name|data
operator|.
name|offsetFromUtc
operator|=
name|rule
operator|.
name|stdOffset
operator|+
name|rule
operator|.
name|dstOffset
expr_stmt|;
name|data
operator|.
name|abbreviation
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|m_abbreviations
operator|.
name|at
argument_list|(
name|rule
operator|.
name|abbreviationIndex
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_function
DECL|function|data
name|QTimeZonePrivate
operator|::
name|Data
name|QTzTimeZonePrivate
operator|::
name|data
parameter_list|(
name|qint64
name|forMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
comment|// If the required time is after the last transition and we have a POSIX rule then use it
if|if
condition|(
name|m_tranTimes
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|m_tranTimes
operator|.
name|last
argument_list|()
operator|.
name|atMSecsSinceEpoch
operator|<
name|forMSecsSinceEpoch
operator|&&
operator|!
name|m_posixRule
operator|.
name|isEmpty
argument_list|()
operator|&&
name|forMSecsSinceEpoch
operator|>=
literal|0
condition|)
block|{
specifier|const
name|int
name|year
init|=
name|QDateTime
operator|::
name|fromMSecsSinceEpoch
argument_list|(
name|forMSecsSinceEpoch
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
decl_stmt|;
specifier|const
name|int
name|lastMSecs
init|=
operator|(
name|m_tranTimes
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
condition|?
name|m_tranTimes
operator|.
name|last
argument_list|()
operator|.
name|atMSecsSinceEpoch
else|:
literal|0
decl_stmt|;
name|QList
argument_list|<
name|QTimeZonePrivate
operator|::
name|Data
argument_list|>
name|posixTrans
init|=
name|calculatePosixTransitions
argument_list|(
name|m_posixRule
argument_list|,
name|year
operator|-
literal|1
argument_list|,
name|year
operator|+
literal|1
argument_list|,
name|lastMSecs
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|posixTrans
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|posixTrans
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|atMSecsSinceEpoch
operator|<=
name|forMSecsSinceEpoch
condition|)
block|{
name|QTimeZonePrivate
operator|::
name|Data
name|data
decl_stmt|;
name|data
operator|=
name|posixTrans
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|data
operator|.
name|atMSecsSinceEpoch
operator|=
name|forMSecsSinceEpoch
expr_stmt|;
return|return
name|data
return|;
block|}
block|}
block|}
comment|// Otherwise if we can find a valid tran then use its rule
for|for
control|(
name|int
name|i
init|=
name|m_tranTimes
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|m_tranTimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|atMSecsSinceEpoch
operator|<=
name|forMSecsSinceEpoch
condition|)
block|{
name|Data
name|data
init|=
name|dataForTzTransition
argument_list|(
name|m_tranTimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|data
operator|.
name|atMSecsSinceEpoch
operator|=
name|forMSecsSinceEpoch
expr_stmt|;
return|return
name|data
return|;
block|}
block|}
comment|// Otherwise use the earliest transition we have
if|if
condition|(
name|m_tranTimes
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Data
name|data
init|=
name|dataForTzTransition
argument_list|(
name|m_tranTimes
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|data
operator|.
name|atMSecsSinceEpoch
operator|=
name|forMSecsSinceEpoch
expr_stmt|;
return|return
name|data
return|;
block|}
comment|// Otherwise we have no rules, so probably an invalid tz, so return invalid data
return|return
name|invalidData
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|hasTransitions
name|bool
name|QTzTimeZonePrivate
operator|::
name|hasTransitions
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|nextTransition
name|QTimeZonePrivate
operator|::
name|Data
name|QTzTimeZonePrivate
operator|::
name|nextTransition
parameter_list|(
name|qint64
name|afterMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
comment|// If the required time is after the last transition and we have a POSIX rule then use it
if|if
condition|(
name|m_tranTimes
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|m_tranTimes
operator|.
name|last
argument_list|()
operator|.
name|atMSecsSinceEpoch
operator|<
name|afterMSecsSinceEpoch
operator|&&
operator|!
name|m_posixRule
operator|.
name|isEmpty
argument_list|()
operator|&&
name|afterMSecsSinceEpoch
operator|>=
literal|0
condition|)
block|{
specifier|const
name|int
name|year
init|=
name|QDateTime
operator|::
name|fromMSecsSinceEpoch
argument_list|(
name|afterMSecsSinceEpoch
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
decl_stmt|;
specifier|const
name|int
name|lastMSecs
init|=
operator|(
name|m_tranTimes
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
condition|?
name|m_tranTimes
operator|.
name|last
argument_list|()
operator|.
name|atMSecsSinceEpoch
else|:
literal|0
decl_stmt|;
name|QList
argument_list|<
name|QTimeZonePrivate
operator|::
name|Data
argument_list|>
name|posixTrans
init|=
name|calculatePosixTransitions
argument_list|(
name|m_posixRule
argument_list|,
name|year
operator|-
literal|1
argument_list|,
name|year
operator|+
literal|1
argument_list|,
name|lastMSecs
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|posixTrans
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|posixTrans
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|atMSecsSinceEpoch
operator|>
name|afterMSecsSinceEpoch
condition|)
return|return
name|posixTrans
operator|.
name|at
argument_list|(
name|i
argument_list|)
return|;
block|}
block|}
comment|// Otherwise if we can find a valid tran then use its rule
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_tranTimes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|m_tranTimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|atMSecsSinceEpoch
operator|>
name|afterMSecsSinceEpoch
condition|)
block|{
return|return
name|dataForTzTransition
argument_list|(
name|m_tranTimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|// Otherwise we have no rule, or there is no next transition, so return invalid data
return|return
name|invalidData
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|previousTransition
name|QTimeZonePrivate
operator|::
name|Data
name|QTzTimeZonePrivate
operator|::
name|previousTransition
parameter_list|(
name|qint64
name|beforeMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
comment|// If the required time is after the last transition and we have a POSIX rule then use it
if|if
condition|(
name|m_tranTimes
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|m_tranTimes
operator|.
name|last
argument_list|()
operator|.
name|atMSecsSinceEpoch
argument_list|<
name|beforeMSecsSinceEpoch
operator|&&
operator|!
name|m_posixRule
operator|.
name|isEmpty
operator|(
operator|)
operator|&&
name|beforeMSecsSinceEpoch
argument_list|>
literal|0
condition|)
block|{
specifier|const
name|int
name|year
init|=
name|QDateTime
operator|::
name|fromMSecsSinceEpoch
argument_list|(
name|beforeMSecsSinceEpoch
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
decl_stmt|;
specifier|const
name|int
name|lastMSecs
init|=
operator|(
name|m_tranTimes
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
condition|?
name|m_tranTimes
operator|.
name|last
argument_list|()
operator|.
name|atMSecsSinceEpoch
else|:
literal|0
decl_stmt|;
name|QList
argument_list|<
name|QTimeZonePrivate
operator|::
name|Data
argument_list|>
name|posixTrans
init|=
name|calculatePosixTransitions
argument_list|(
name|m_posixRule
argument_list|,
name|year
operator|-
literal|1
argument_list|,
name|year
operator|+
literal|1
argument_list|,
name|lastMSecs
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|posixTrans
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|posixTrans
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|atMSecsSinceEpoch
operator|<
name|beforeMSecsSinceEpoch
condition|)
return|return
name|posixTrans
operator|.
name|at
argument_list|(
name|i
argument_list|)
return|;
block|}
block|}
comment|// Otherwise if we can find a valid tran then use its rule
for|for
control|(
name|int
name|i
init|=
name|m_tranTimes
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|m_tranTimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|atMSecsSinceEpoch
operator|<
name|beforeMSecsSinceEpoch
condition|)
block|{
return|return
name|dataForTzTransition
argument_list|(
name|m_tranTimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|// Otherwise we have no rule, so return invalid data
return|return
name|invalidData
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// TODO Could cache the value and monitor the required files for any changes
end_comment
begin_function
DECL|function|systemTimeZoneId
name|QByteArray
name|QTzTimeZonePrivate
operator|::
name|systemTimeZoneId
parameter_list|()
specifier|const
block|{
comment|// Check TZ env var first, if not populated try find it
name|QByteArray
name|ianaId
init|=
name|qgetenv
argument_list|(
literal|"TZ"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ianaId
operator|.
name|isEmpty
argument_list|()
operator|&&
name|ianaId
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|':'
condition|)
name|ianaId
operator|=
name|ianaId
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// On Debian Etch and later /etc/localtime is real file with name held in /etc/timezone
if|if
condition|(
name|ianaId
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QFile
name|tzif
argument_list|(
name|QStringLiteral
argument_list|(
literal|"/etc/timezone"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tzif
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
comment|// TODO QTextStream inefficient, replace later
name|QTextStream
name|ts
argument_list|(
operator|&
name|tzif
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ts
operator|.
name|atEnd
argument_list|()
condition|)
name|ianaId
operator|=
name|ts
operator|.
name|readLine
argument_list|()
operator|.
name|toUtf8
argument_list|()
expr_stmt|;
block|}
block|}
comment|// On other distros /etc/localtime is symlink to real file so can extract name from the path
if|if
condition|(
name|ianaId
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|QString
name|path
init|=
name|QFile
operator|::
name|symLinkTarget
argument_list|(
name|QStringLiteral
argument_list|(
literal|"/etc/localtime"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// /etc/localtime is a symlink to the current TZ file, so extract from path
name|int
name|index
init|=
name|path
operator|.
name|indexOf
argument_list|(
name|QLatin1String
argument_list|(
literal|"/zoneinfo/"
argument_list|)
argument_list|)
operator|+
literal|10
decl_stmt|;
name|ianaId
operator|=
name|path
operator|.
name|mid
argument_list|(
name|index
argument_list|)
operator|.
name|toUtf8
argument_list|()
expr_stmt|;
block|}
block|}
comment|// On some Red Hat distros /etc/localtime is real file with name held in /etc/sysconfig/clock
comment|// in a line like ZONE="Europe/Oslo" or TIMEZONE="Europe/Oslo"
if|if
condition|(
name|ianaId
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QFile
name|tzif
argument_list|(
name|QStringLiteral
argument_list|(
literal|"/etc/sysconfig/clock"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tzif
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
comment|// TODO QTextStream inefficient, replace later
name|QTextStream
name|ts
argument_list|(
operator|&
name|tzif
argument_list|)
decl_stmt|;
name|QString
name|line
decl_stmt|;
while|while
condition|(
name|ianaId
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|ts
operator|.
name|atEnd
argument_list|()
operator|&&
name|ts
operator|.
name|status
argument_list|()
operator|==
name|QTextStream
operator|::
name|Ok
condition|)
block|{
name|line
operator|=
name|ts
operator|.
name|readLine
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|left
argument_list|(
literal|5
argument_list|)
operator|==
name|QStringLiteral
argument_list|(
literal|"ZONE="
argument_list|)
condition|)
block|{
name|ianaId
operator|=
name|line
operator|.
name|mid
argument_list|(
literal|6
argument_list|,
name|line
operator|.
name|size
argument_list|()
operator|-
literal|7
argument_list|)
operator|.
name|toUtf8
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|left
argument_list|(
literal|9
argument_list|)
operator|==
name|QStringLiteral
argument_list|(
literal|"TIMEZONE="
argument_list|)
condition|)
block|{
name|ianaId
operator|=
name|line
operator|.
name|mid
argument_list|(
literal|10
argument_list|,
name|line
operator|.
name|size
argument_list|()
operator|-
literal|11
argument_list|)
operator|.
name|toUtf8
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Give up for now and return UTC
if|if
condition|(
name|ianaId
operator|.
name|isEmpty
argument_list|()
condition|)
name|ianaId
operator|=
name|QByteArrayLiteral
argument_list|(
literal|"UTC"
argument_list|)
expr_stmt|;
return|return
name|ianaId
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|QTzTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|()
specifier|const
block|{
return|return
name|tzZones
operator|->
name|keys
argument_list|()
operator|.
name|toSet
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|QTzTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|(
name|QLocale
operator|::
name|Country
name|country
parameter_list|)
specifier|const
block|{
comment|// TODO AnyCountry
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|set
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|key
decl|,
name|tzZones
operator|->
name|keys
argument_list|()
control|)
block|{
if|if
condition|(
name|tzZones
operator|->
name|value
argument_list|(
name|key
argument_list|)
operator|.
name|country
operator|==
name|country
condition|)
name|set
operator|<<
name|key
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
