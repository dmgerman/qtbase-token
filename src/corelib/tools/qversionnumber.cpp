begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Copyright (C) 2014 Keith Gardner<kreios4004@gmail.com> ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtCore/qversionnumber.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qhash.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qlocale_tools_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qcollator.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_include
include|#
directive|include
file|<QtCore/qdatastream.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QVersionNumber     \inmodule QtCore     \since 5.4     \brief The QVersionNumber class contains a version number with an arbitrary            number of segments.      \snippet qversionnumber/main.cpp 0 */
comment|/*!     \fn QVersionNumber::QVersionNumber()      Produces a null version.      \sa isNull() */
comment|/*!     \fn QVersionNumber::QVersionNumber(int maj)      Constructs a QVersionNumber consisting of just the major version number \a maj. */
comment|/*!     \fn QVersionNumber::QVersionNumber(int maj, int min)      Constructs a QVersionNumber consisting of the major and minor     version numbers \a maj and \a min, respectively. */
comment|/*!     \fn QVersionNumber::QVersionNumber(int maj, int min, int mic)      Constructs a QVersionNumber consisting of the major, minor, and     micro version numbers \a maj, \a min and \a mic, respectively. */
comment|/*!     \fn QVersionNumber::QVersionNumber(const QVector<int>&seg)      Constructs a version number from the list of numbers contained in \a seg. */
comment|/*!     \fn QVersionNumber::QVersionNumber(QVector<int>&&seg)      Move-constructs a version number from the list of numbers contained in \a seg.      This constructor is only enabled if the compiler supports C++11 move semantics. */
comment|/*!     \fn QVersionNumber::QVersionNumber(std::initializer_list<int> args)      Construct a version number from the std::initializer_list specified by     \a args.      This constructor is only enabled if the compiler supports C++11 initializer     lists. */
comment|/*!     \fn bool QVersionNumber::isNull() const      Returns \c true if there are zero numerical segments, otherwise returns     \c false.      \sa segments() */
comment|/*!   \fn bool QVersionNumber::isNormalized() const    Returns \c true if the version number does not contain any trailing zeros,   otherwise returns \c false.    \sa normalized() */
comment|/*!     \fn int QVersionNumber::majorVersion() const      Returns the major version number, that is, the first segment.     This function is equivalent to segmentAt(0). If this QVersionNumber object     is null, this function returns 0.      \sa isNull(), segmentAt() */
comment|/*!     \fn int QVersionNumber::minorVersion() const      Returns the minor version number, that is, the second segment.     This function is equivalent to segmentAt(1). If this QVersionNumber object     does not contain a minor number, this function returns 0.      \sa isNull(), segmentAt() */
comment|/*!     \fn int QVersionNumber::microVersion() const      Returns the micro version number, that is, the third segment.     This function is equivalent to segmentAt(2). If this QVersionNumber object     does not contain a micro number, this function returns 0.      \sa isNull(), segmentAt() */
comment|/*!     \fn const QVector<int>& QVersionNumber::segments() const      Returns all of the numerical segments.      \sa majorVersion(), minorVersion(), microVersion() */
comment|/*!     \fn int QVersionNumber::segmentAt(int index) const      Returns the segement value at \a index.  If the index does not exist,     returns 0.      \sa segments(), segmentCount() */
comment|/*!     \fn int QVersionNumber::segmentCount() const      Returns the number of integers stored in segments().      \sa segments() */
comment|/*!     \fn QVersionNumber QVersionNumber::normalized() const      Returns an equivalent version number but with all trailing zeros removed.      To check if two numbers are equivalent, use normalized() on both version     numbers before perforing the compare.      \snippet qversionnumber/main.cpp 4  */
comment|/*!     \fn bool QVersionNumber::isPrefixOf(const QVersionNumber&other) const      Returns \c true if the current version number is contained in the \a other     version number, otherwise returns \c false.      \snippet qversionnumber/main.cpp 2      \sa commonPrefix() */
name|bool
name|QVersionNumber
operator|::
name|isPrefixOf
parameter_list|(
specifier|const
name|QVersionNumber
modifier|&
name|other
parameter_list|)
specifier|const
name|Q_DECL_NOTHROW
block|{
return|return
name|m_segments
operator|.
name|size
argument_list|()
operator|<=
name|other
operator|.
name|m_segments
operator|.
name|size
argument_list|()
operator|&&
name|std
operator|::
name|equal
argument_list|(
name|m_segments
operator|.
name|begin
argument_list|()
argument_list|,
name|m_segments
operator|.
name|end
argument_list|()
argument_list|,
name|other
operator|.
name|m_segments
operator|.
name|begin
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QVersionNumber::compare(const QVersionNumber&v1,                                     const QVersionNumber&v2)      Compares \a v1 with \a v2 and returns an integer less than, equal to, or     greater than zero, depending on whether \a v1 is less than, equal to, or     greater than \a v2, respectively.      Comparisons are performed by comparing the segments of \a v1 and \a v2     starting at index 0 and working towards the end of the longer list.      \snippet qversionnumber/main.cpp 1 */
end_comment
begin_function
name|int
name|QVersionNumber
operator|::
name|compare
parameter_list|(
specifier|const
name|QVersionNumber
modifier|&
name|v1
parameter_list|,
specifier|const
name|QVersionNumber
modifier|&
name|v2
parameter_list|)
name|Q_DECL_NOTHROW
block|{
name|QVector
argument_list|<
name|int
argument_list|>
operator|::
name|const_iterator
name|i1
init|=
name|v1
operator|.
name|m_segments
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
operator|::
name|const_iterator
name|e1
init|=
name|v1
operator|.
name|m_segments
operator|.
name|constEnd
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
operator|::
name|const_iterator
name|i2
init|=
name|v2
operator|.
name|m_segments
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
operator|::
name|const_iterator
name|e2
init|=
name|v2
operator|.
name|m_segments
operator|.
name|constEnd
argument_list|()
decl_stmt|;
while|while
condition|(
name|i1
operator|!=
name|e1
operator|&&
name|i2
operator|!=
name|e2
condition|)
block|{
if|if
condition|(
operator|*
name|i1
operator|!=
operator|*
name|i2
condition|)
return|return
operator|(
operator|*
name|i1
operator|-
operator|*
name|i2
operator|)
return|;
operator|++
name|i1
expr_stmt|;
operator|++
name|i2
expr_stmt|;
block|}
comment|// ran out of segments in v1 and/or v2 and need to check the first trailing
comment|// segment to finish the compare
if|if
condition|(
name|i1
operator|!=
name|e1
condition|)
block|{
comment|// v1 is longer
if|if
condition|(
operator|*
name|i1
operator|!=
literal|0
condition|)
return|return
operator|*
name|i1
return|;
else|else
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|i2
operator|!=
name|e2
condition|)
block|{
comment|// v2 is longer
if|if
condition|(
operator|*
name|i2
operator|!=
literal|0
condition|)
return|return
operator|-
operator|*
name|i2
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
comment|// the two version numbers are the same
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     QVersionNumber QVersionNumber::commonPrefix(const QVersionNumber&v1,                                                     const QVersionNumber&v2)      Returns a version number that is a parent version of both \a v1 and \a v2.      \sa isPrefixOf() */
end_comment
begin_function
DECL|function|commonPrefix
name|QVersionNumber
name|QVersionNumber
operator|::
name|commonPrefix
parameter_list|(
specifier|const
name|QVersionNumber
modifier|&
name|v1
parameter_list|,
specifier|const
name|QVersionNumber
modifier|&
name|v2
parameter_list|)
block|{
name|int
name|min
init|=
name|qMin
argument_list|(
name|v1
operator|.
name|m_segments
operator|.
name|size
argument_list|()
argument_list|,
name|v2
operator|.
name|m_segments
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
operator|::
name|const_iterator
name|i1
init|=
name|v1
operator|.
name|m_segments
operator|.
name|begin
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
operator|::
name|const_iterator
name|e1
decl_stmt|;
name|e1
operator|=
name|std
operator|::
name|mismatch
argument_list|(
name|i1
argument_list|,
name|v1
operator|.
name|m_segments
operator|.
name|begin
argument_list|()
operator|+
name|min
argument_list|,
name|v2
operator|.
name|m_segments
operator|.
name|begin
argument_list|()
argument_list|)
operator|.
name|first
expr_stmt|;
return|return
name|QVersionNumber
argument_list|(
name|v1
operator|.
name|m_segments
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
name|e1
operator|-
name|i1
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool operator<(const QVersionNumber&lhs, const QVersionNumber&rhs)     \relates QVersionNumber      Returns \c true if \a lhs is less than \a rhs; otherwise returns \c false.      \sa QVersionNumber::compare() */
end_comment
begin_comment
comment|/*!     \fn bool operator<=(const QVersionNumber&lhs, const QVersionNumber&rhs)     \relates QVersionNumber      Returns \c true if \a lhs is less than or equal to \a rhs; otherwise     returns \c false.      \sa QVersionNumber::compare() */
end_comment
begin_comment
comment|/*!     \fn bool operator>(const QVersionNumber&lhs, const QVersionNumber&rhs)     \relates QVersionNumber      Returns \c true if \a lhs is greater than \a rhs; otherwise returns \c     false.      \sa QVersionNumber::compare() */
end_comment
begin_comment
comment|/*!     \fn bool operator>=(const QVersionNumber&lhs, const QVersionNumber&rhs)     \relates QVersionNumber      Returns \c true if \a lhs is greater than or equal to \a rhs; otherwise     returns \c false.      \sa QVersionNumber::compare() */
end_comment
begin_comment
comment|/*!     \fn bool operator==(const QVersionNumber&lhs, const QVersionNumber&rhs)     \relates QVersionNumber      Returns \c true if \a lhs is equal to \a rhs; otherwise returns \c false.      \sa QVersionNumber::compare() */
end_comment
begin_comment
comment|/*!     \fn bool operator!=(const QVersionNumber&lhs, const QVersionNumber&rhs)     \relates QVersionNumber      Returns \c true if \a lhs is not equal to \a rhs; otherwise returns     \c false.      \sa QVersionNumber::compare() */
end_comment
begin_comment
comment|/*!     \fn QString QVersionNumber::toString() const      Returns a string with all of the segments delimited by a '.'.      \sa majorVersion(), minorVersion(), microVersion(), segments() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QVersionNumber
operator|::
name|toString
parameter_list|()
specifier|const
block|{
name|QString
name|version
decl_stmt|;
name|version
operator|.
name|reserve
argument_list|(
name|qMax
argument_list|(
name|m_segments
operator|.
name|size
argument_list|()
operator|*
literal|2
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|QVector
argument_list|<
name|int
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|m_segments
operator|.
name|begin
argument_list|()
init|,
name|end
init|=
name|m_segments
operator|.
name|end
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|version
operator|+=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|version
operator|+=
name|QString
operator|::
name|number
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|version
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QVersionNumber QVersionNumber::fromString(const QString&string,                                                   int *suffixIndex)      Constructs a QVersionNumber from a specially formatted \a string of     non-negative decimal numbers delimited by '.'.      Once the numerical segments have been parsed, the remainder of the string     is considered to be the suffix string.  The start index of that string will be     stored in \a suffixIndex if it is not null.      \snippet qversionnumber/main.cpp 3      \sa isNull() */
end_comment
begin_function
DECL|function|fromString
name|QVersionNumber
name|QVersionNumber
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
name|int
modifier|*
name|suffixIndex
parameter_list|)
block|{
name|QVector
argument_list|<
name|int
argument_list|>
name|seg
decl_stmt|;
specifier|const
name|QByteArray
name|cString
argument_list|(
name|string
operator|.
name|toLatin1
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|cString
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|lastGoodEnd
init|=
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|endOfString
init|=
name|cString
operator|.
name|constData
argument_list|()
operator|+
name|cString
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|value
decl_stmt|;
do|do
block|{
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|value
operator|=
name|int
argument_list|(
name|qstrtoull
argument_list|(
name|start
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|,
operator|&
name|ok
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
break|break;
name|seg
operator|.
name|append
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
name|lastGoodEnd
operator|=
name|end
expr_stmt|;
block|}
do|while
condition|(
name|start
operator|<
name|endOfString
operator|&&
operator|(
name|end
operator|<
name|endOfString
operator|&&
operator|*
name|end
operator|==
literal|'.'
operator|)
condition|)
do|;
if|if
condition|(
name|suffixIndex
condition|)
operator|*
name|suffixIndex
operator|=
name|int
argument_list|(
name|lastGoodEnd
operator|-
name|cString
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|QVersionNumber
argument_list|(
name|qMove
argument_list|(
name|seg
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QVersionNumber QVersionNumber::normalizedImpl(QVector<int>&segs)      Implementation of the normalized() function.  Takes the movable list \a segs     and normalizes them.      \internal  */
end_comment
begin_function
DECL|function|normalizedImpl
name|QVersionNumber
name|QVersionNumber
operator|::
name|normalizedImpl
parameter_list|(
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|segs
parameter_list|)
block|{
while|while
condition|(
name|segs
operator|.
name|size
argument_list|()
operator|&&
name|segs
operator|.
name|last
argument_list|()
operator|==
literal|0
condition|)
name|segs
operator|.
name|pop_back
argument_list|()
expr_stmt|;
return|return
name|QVersionNumber
argument_list|(
name|qMove
argument_list|(
name|segs
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!    \fn  QDataStream& operator<<(QDataStream&out,                                 const QVersionNumber&version)    \relates QVersionNumber     Writes the version number \a version to stream \a out.     Note that this has nothing to do with QDataStream::version().  */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QVersionNumber
modifier|&
name|version
parameter_list|)
block|{
name|out
operator|<<
name|version
operator|.
name|segments
argument_list|()
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*!    \fn QDataStream& operator>>(QDataStream&in, QVersionNumber&version)    \relates QVersionNumber     Reads a version number from stream \a in and stores it in \a version.     Note that this has nothing to do with QDataStream::version().  */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QVersionNumber
modifier|&
name|version
parameter_list|)
block|{
name|in
operator|>>
name|version
operator|.
name|m_segments
expr_stmt|;
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
specifier|const
name|QVersionNumber
modifier|&
name|version
parameter_list|)
block|{
name|debug
operator|.
name|noquote
argument_list|()
operator|<<
name|version
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|debug
operator|.
name|quote
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn uint qHash(const QVersionNumber&key, uint seed)     \relates QHash     \since 5.4      Returns the hash value for the \a key, using \a seed to seed the     calculation. */
end_comment
begin_function
DECL|function|qHash
name|uint
name|qHash
parameter_list|(
specifier|const
name|QVersionNumber
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
block|{
name|uint
name|hash
init|=
name|seed
decl_stmt|;
for|for
control|(
name|QVector
argument_list|<
name|int
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|key
operator|.
name|m_segments
operator|.
name|begin
argument_list|()
init|,
name|end
init|=
name|key
operator|.
name|m_segments
operator|.
name|end
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
comment|// used to preserve order
comment|//   see N3876 for more information
name|hash
operator|^=
name|qHash
argument_list|(
operator|*
name|it
argument_list|)
operator|+
literal|0x9e3779b9
operator|+
operator|(
name|hash
operator|<<
literal|6
operator|)
operator|+
operator|(
name|hash
operator|>>
literal|2
operator|)
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
