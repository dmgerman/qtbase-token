begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|// Don't define it while compiling this module, or USERS of Qt will
end_comment
begin_comment
comment|// not be able to link.
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_CAST_FROM_ASCII
end_ifdef
begin_undef
DECL|macro|QT_NO_CAST_FROM_ASCII
undef|#
directive|undef
name|QT_NO_CAST_FROM_ASCII
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_CAST_TO_ASCII
end_ifdef
begin_undef
DECL|macro|QT_NO_CAST_TO_ASCII
undef|#
directive|undef
name|QT_NO_CAST_TO_ASCII
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qchar.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qunicodetables_p.h"
end_include
begin_include
include|#
directive|include
file|"qunicodetables.cpp"
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|macro|FLAG
define|#
directive|define
name|FLAG
parameter_list|(
name|x
parameter_list|)
value|(1<< (x))
comment|/*!     \class QLatin1Char     \inmodule QtCore     \brief The QLatin1Char class provides an 8-bit ASCII/Latin-1 character.      \ingroup string-processing      This class is only useful to construct a QChar with 8-bit character.      \sa QChar, QLatin1String, QString */
comment|/*!     \fn const char QLatin1Char::toLatin1() const      Converts a Latin-1 character to an 8-bit ASCII representation of the character. */
comment|/*!     \fn const ushort QLatin1Char::unicode() const      Converts a Latin-1 character to an 16-bit-encoded Unicode representation     of the character. */
comment|/*!     \fn QLatin1Char::QLatin1Char(char c)      Constructs a Latin-1 character for \a c. This constructor should be     used when the encoding of the input character is known to be Latin-1. */
comment|/*!     \class QChar     \inmodule QtCore     \brief The QChar class provides a 16-bit Unicode character.      \ingroup string-processing     \reentrant      In Qt, Unicode characters are 16-bit entities without any markup     or structure. This class represents such an entity. It is     lightweight, so it can be used everywhere. Most compilers treat     it like a \c{unsigned short}.      QChar provides a full complement of testing/classification     functions, converting to and from other formats, converting from     composed to decomposed Unicode, and trying to compare and     case-convert if you ask it to.      The classification functions include functions like those in the     standard C++ header \<cctype\> (formerly \<ctype.h\>), but     operating on the full range of Unicode characters, not just for the ASCII     range. They all return true if the character is a certain type of character;     otherwise they return false. These classification functions are     isNull() (returns true if the character is '\\0'), isPrint()     (true if the character is any sort of printable character,     including whitespace), isPunct() (any sort of punctation),     isMark() (Unicode Mark), isLetter() (a letter), isNumber() (any     sort of numeric character, not just 0-9), isLetterOrNumber(), and     isDigit() (decimal digits). All of these are wrappers around     category() which return the Unicode-defined category of each     character. Some of these also calculate the derived properties     (for example isSpace() returns true if the character is of category     Separator_* or an exceptional code point from Other_Control category).      QChar also provides direction(), which indicates the "natural"     writing direction of this character. The joining() function     indicates how the character joins with it's neighbors (needed     mostly for Arabic) and finally hasMirrored(), which indicates     whether the character needs to be mirrored when it is printed in     it's "unnatural" writing direction.      Composed Unicode characters (like \a ring) can be converted to     decomposed Unicode ("a" followed by "ring above") by using decomposition().      In Unicode, comparison is not necessarily possible and case     conversion is very difficult at best. Unicode, covering the     "entire" world, also includes most of the world's case and     sorting problems. operator==() and friends will do comparison     based purely on the numeric Unicode value (code point) of the     characters, and toUpper() and toLower() will do case changes when     the character has a well-defined uppercase/lowercase equivalent.     For locale-dependent comparisons, use QString::localeAwareCompare().      The conversion functions include unicode() (to a scalar),     toLatin1() (to scalar, but converts all non-Latin-1 characters to     0), row() (gives the Unicode row), cell() (gives the Unicode     cell), digitValue() (gives the integer value of any of the     numerous digit characters), and a host of constructors.      QChar provides constructors and cast operators that make it easy     to convert to and from traditional 8-bit \c{char}s. If you     defined \c QT_NO_CAST_FROM_ASCII and \c QT_NO_CAST_TO_ASCII, as     explained in the QString documentation, you will need to     explicitly call fromLatin1(), or use QLatin1Char,     to construct a QChar from an 8-bit \c char, and you will need to     call toLatin1() to get the 8-bit value back.      For more information see     \l{http://www.unicode.org/ucd/}{"About the Unicode Character Database"}.      \sa Unicode, QString, QLatin1Char */
comment|/*!     \enum QChar::UnicodeVersion      Specifies which version of the \l{http://www.unicode.org/}{Unicode standard}     introduced a certain character.      \value Unicode_1_1  Version 1.1     \value Unicode_2_0  Version 2.0     \value Unicode_2_1_2  Version 2.1.2     \value Unicode_3_0  Version 3.0     \value Unicode_3_1  Version 3.1     \value Unicode_3_2  Version 3.2     \value Unicode_4_0  Version 4.0     \value Unicode_4_1  Version 4.1     \value Unicode_5_0  Version 5.0     \value Unicode_5_1  Version 5.1     \value Unicode_5_2  Version 5.2     \value Unicode_6_0  Version 6.0     \value Unicode_6_1  Version 6.1     \value Unicode_6_2  Version 6.2     \value Unicode_Unassigned  The value is not assigned to any character                                in version 6.2 of Unicode.      \sa unicodeVersion(), currentUnicodeVersion() */
comment|/*!     \enum QChar::Category      This enum maps the Unicode character categories.      The following characters are normative in Unicode:      \value Mark_NonSpacing  Unicode class name Mn      \value Mark_SpacingCombining  Unicode class name Mc      \value Mark_Enclosing  Unicode class name Me      \value Number_DecimalDigit  Unicode class name Nd      \value Number_Letter  Unicode class name Nl      \value Number_Other  Unicode class name No      \value Separator_Space  Unicode class name Zs      \value Separator_Line  Unicode class name Zl      \value Separator_Paragraph  Unicode class name Zp      \value Other_Control  Unicode class name Cc      \value Other_Format  Unicode class name Cf      \value Other_Surrogate  Unicode class name Cs      \value Other_PrivateUse  Unicode class name Co      \value Other_NotAssigned  Unicode class name Cn       The following categories are informative in Unicode:      \value Letter_Uppercase  Unicode class name Lu      \value Letter_Lowercase  Unicode class name Ll      \value Letter_Titlecase  Unicode class name Lt      \value Letter_Modifier  Unicode class name Lm      \value Letter_Other Unicode class name Lo      \value Punctuation_Connector  Unicode class name Pc      \value Punctuation_Dash  Unicode class name Pd      \value Punctuation_Open  Unicode class name Ps      \value Punctuation_Close  Unicode class name Pe      \value Punctuation_InitialQuote  Unicode class name Pi      \value Punctuation_FinalQuote  Unicode class name Pf      \value Punctuation_Other  Unicode class name Po      \value Symbol_Math  Unicode class name Sm      \value Symbol_Currency  Unicode class name Sc      \value Symbol_Modifier  Unicode class name Sk      \value Symbol_Other  Unicode class name So      \sa category() */
comment|/*!     \enum QChar::Script     \since 5.1      This enum type defines the Unicode script property values.      For details about the Unicode script property values see     \l{http://www.unicode.org/reports/tr24/}{Unicode Standard Annex #24}.      In order to conform to C/C++ naming conventions "Script_" is prepended     to the codes used in the Unicode Standard.      \value Script_Unknown    For unassigned, private-use, noncharacter, and surrogate code points.     \value Script_Inherited  For characters that may be used with multiple scripts                              and that inherit their script from the preceding characters.                              These include nonspacing marks, enclosing marks,                              and zero width joiner/non-joiner characters.     \value Script_Common     For characters that may be used with multiple scripts                              and that do not inherit their script from the preceding characters.      \value Script_Latin     \value Script_Greek     \value Script_Cyrillic     \value Script_Armenian     \value Script_Hebrew     \value Script_Arabic     \value Script_Syriac     \value Script_Thaana     \value Script_Devanagari     \value Script_Bengali     \value Script_Gurmukhi     \value Script_Gujarati     \value Script_Oriya     \value Script_Tamil     \value Script_Telugu     \value Script_Kannada     \value Script_Malayalam     \value Script_Sinhala     \value Script_Thai     \value Script_Lao     \value Script_Tibetan     \value Script_Myanmar     \value Script_Georgian     \value Script_Hangul     \value Script_Ethiopic     \value Script_Cherokee     \value Script_CanadianAboriginal     \value Script_Ogham     \value Script_Runic     \value Script_Khmer     \value Script_Mongolian     \value Script_Hiragana     \value Script_Katakana     \value Script_Bopomofo     \value Script_Han     \value Script_Yi     \value Script_OldItalic     \value Script_Gothic     \value Script_Deseret     \value Script_Tagalog     \value Script_Hanunoo     \value Script_Buhid     \value Script_Tagbanwa     \value Script_Coptic     \value Script_Limbu     \value Script_TaiLe     \value Script_LinearB     \value Script_Ugaritic     \value Script_Shavian     \value Script_Osmanya     \value Script_Cypriot     \value Script_Braille     \value Script_Buginese     \value Script_NewTaiLue     \value Script_Glagolitic     \value Script_Tifinagh     \value Script_SylotiNagri     \value Script_OldPersian     \value Script_Kharoshthi     \value Script_Balinese     \value Script_Cuneiform     \value Script_Phoenician     \value Script_PhagsPa     \value Script_Nko     \value Script_Sundanese     \value Script_Lepcha     \value Script_OlChiki     \value Script_Vai     \value Script_Saurashtra     \value Script_KayahLi     \value Script_Rejang     \value Script_Lycian     \value Script_Carian     \value Script_Lydian     \value Script_Cham     \value Script_TaiTham     \value Script_TaiViet     \value Script_Avestan     \value Script_EgyptianHieroglyphs     \value Script_Samaritan     \value Script_Lisu     \value Script_Bamum     \value Script_Javanese     \value Script_MeeteiMayek     \value Script_ImperialAramaic     \value Script_OldSouthArabian     \value Script_InscriptionalParthian     \value Script_InscriptionalPahlavi     \value Script_OldTurkic     \value Script_Kaithi     \value Script_Batak     \value Script_Brahmi     \value Script_Mandaic     \value Script_Chakma     \value Script_MeroiticCursive     \value Script_MeroiticHieroglyphs     \value Script_Miao     \value Script_Sharada     \value Script_SoraSompeng     \value Script_Takri      \omitvalue ScriptCount      \sa script() */
comment|/*!     \enum QChar::Direction      This enum type defines the Unicode direction attributes. See the     \l{http://www.unicode.org/}{Unicode Standard} for a description     of the values.      In order to conform to C/C++ naming conventions "Dir" is prepended     to the codes used in the Unicode Standard.      \value DirAL     \value DirAN     \value DirB     \value DirBN     \value DirCS     \value DirEN     \value DirES     \value DirET     \value DirL     \value DirLRE     \value DirLRO     \value DirNSM     \value DirON     \value DirPDF     \value DirR     \value DirRLE     \value DirRLO     \value DirS     \value DirWS      \sa direction() */
comment|/*!     \enum QChar::Decomposition      This enum type defines the Unicode decomposition attributes. See     the \l{http://www.unicode.org/}{Unicode Standard} for a     description of the values.      \value NoDecomposition     \value Canonical     \value Circle     \value Compat     \value Final     \value Font     \value Fraction     \value Initial     \value Isolated     \value Medial     \value Narrow     \value NoBreak     \value Small     \value Square     \value Sub     \value Super     \value Vertical     \value Wide      \sa decomposition() */
comment|/*!     \enum QChar::Joining      This enum type defines the Unicode joining attributes. See the     \l{http://www.unicode.org/}{Unicode Standard} for a description     of the values.      \value Center     \value Dual     \value OtherJoining     \value Right      \sa joining() */
comment|/*!     \enum QChar::CombiningClass      \internal      This enum type defines names for some of the Unicode combining     classes. See the \l{http://www.unicode.org/}{Unicode Standard}     for a description of the values.      \value Combining_Above     \value Combining_AboveAttached     \value Combining_AboveLeft     \value Combining_AboveLeftAttached     \value Combining_AboveRight     \value Combining_AboveRightAttached     \value Combining_Below     \value Combining_BelowAttached     \value Combining_BelowLeft     \value Combining_BelowLeftAttached     \value Combining_BelowRight     \value Combining_BelowRightAttached     \value Combining_DoubleAbove     \value Combining_DoubleBelow     \value Combining_IotaSubscript     \value Combining_Left     \value Combining_LeftAttached     \value Combining_Right     \value Combining_RightAttached */
comment|/*!     \enum QChar::SpecialCharacter      \value Null A QChar with this value isNull().     \value Tabulation Character tabulation.     \value LineFeed     \value CarriageReturn     \value Space     \value Nbsp Non-breaking space.     \value ReplacementCharacter The character shown when a font has no glyph            for a certain codepoint. A special question mark character is often            used. Codecs use this codepoint when input data cannot be            represented in Unicode.     \value ObjectReplacementCharacter Used to represent an object such as an            image when such objects cannot be presented.     \value ByteOrderMark     \value ByteOrderSwapped     \value ParagraphSeparator     \value LineSeparator     \value LastValidCodePoint */
comment|/*!     \fn void QChar::setCell(uchar cell)     \internal */
comment|/*!     \fn void QChar::setRow(uchar row)     \internal */
comment|/*!     \fn QChar::QChar()      Constructs a null QChar ('\\0').      \sa isNull() */
comment|/*!     \fn QChar::QChar(QLatin1Char ch)      Constructs a QChar corresponding to ASCII/Latin-1 character \a ch. */
comment|/*!     \fn QChar::QChar(SpecialCharacter ch)      Constructs a QChar for the predefined character value \a ch. */
comment|/*!     \fn QChar::QChar(char ch)      Constructs a QChar corresponding to ASCII/Latin-1 character \a ch. */
comment|/*!     \fn QChar::QChar(uchar ch)      Constructs a QChar corresponding to ASCII/Latin-1 character \a ch. */
comment|/*!     \fn QChar::QChar(uchar cell, uchar row)      Constructs a QChar for Unicode cell \a cell in row \a row.      \sa cell(), row() */
comment|/*!     \fn QChar::QChar(ushort code)      Constructs a QChar for the character with Unicode code point \a code. */
comment|/*!     \fn QChar::QChar(short code)      Constructs a QChar for the character with Unicode code point \a code. */
comment|/*!     \fn QChar::QChar(uint code)      Constructs a QChar for the character with Unicode code point \a code. */
comment|/*!     \fn QChar::QChar(int code)      Constructs a QChar for the character with Unicode code point \a code. */
comment|/*!     \fn bool QChar::isNull() const      Returns true if the character is the Unicode character 0x0000     ('\\0'); otherwise returns false. */
comment|/*!     \fn uchar QChar::cell() const      Returns the cell (least significant byte) of the Unicode character.      \sa row() */
comment|/*!     \fn uchar QChar::row() const      Returns the row (most significant byte) of the Unicode character.      \sa cell() */
comment|/*!     \fn bool QChar::isPrint() const      Returns true if the character is a printable character; otherwise     returns false. This is any character not of category Other_*.      Note that this gives no indication of whether the character is     available in a particular font. */
comment|/*!     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4 is     a printable character; otherwise returns false.     This is any character not of category Other_*.      Note that this gives no indication of whether the character is     available in a particular font. */
DECL|function|isPrint
name|bool
name|QChar
operator|::
name|isPrint
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
literal|false
return|;
specifier|const
name|int
name|test
init|=
name|FLAG
argument_list|(
name|Other_Control
argument_list|)
operator||
name|FLAG
argument_list|(
name|Other_Format
argument_list|)
operator||
name|FLAG
argument_list|(
name|Other_Surrogate
argument_list|)
operator||
name|FLAG
argument_list|(
name|Other_PrivateUse
argument_list|)
operator||
name|FLAG
argument_list|(
name|Other_NotAssigned
argument_list|)
decl_stmt|;
return|return
operator|!
operator|(
name|FLAG
argument_list|(
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|category
argument_list|)
operator|&
name|test
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QChar::isSpace() const      Returns true if the character is a separator character     (Separator_* categories or certain code points from Other_Control category);     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QChar::isSpace(uint ucs4)     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4 is     a separator character (Separator_* categories or certain code points     from Other_Control category); otherwise returns false. */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|isSpace_helper
name|bool
name|QT_FASTCALL
name|QChar
operator|::
name|isSpace_helper
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
literal|false
return|;
specifier|const
name|int
name|test
init|=
name|FLAG
argument_list|(
name|Separator_Space
argument_list|)
operator||
name|FLAG
argument_list|(
name|Separator_Line
argument_list|)
operator||
name|FLAG
argument_list|(
name|Separator_Paragraph
argument_list|)
decl_stmt|;
return|return
name|FLAG
argument_list|(
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|category
argument_list|)
operator|&
name|test
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QChar::isMark() const      Returns true if the character is a mark (Mark_* categories);     otherwise returns false.      See QChar::Category for more information regarding marks. */
end_comment
begin_comment
comment|/*!     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4 is     a mark (Mark_* categories); otherwise returns false. */
end_comment
begin_function
DECL|function|isMark
name|bool
name|QChar
operator|::
name|isMark
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
literal|false
return|;
specifier|const
name|int
name|test
init|=
name|FLAG
argument_list|(
name|Mark_NonSpacing
argument_list|)
operator||
name|FLAG
argument_list|(
name|Mark_SpacingCombining
argument_list|)
operator||
name|FLAG
argument_list|(
name|Mark_Enclosing
argument_list|)
decl_stmt|;
return|return
name|FLAG
argument_list|(
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|category
argument_list|)
operator|&
name|test
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QChar::isPunct() const      Returns true if the character is a punctuation mark (Punctuation_*     categories); otherwise returns false. */
end_comment
begin_comment
comment|/*!     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4 is     a punctuation mark (Punctuation_* categories); otherwise returns false. */
end_comment
begin_function
DECL|function|isPunct
name|bool
name|QChar
operator|::
name|isPunct
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
literal|false
return|;
specifier|const
name|int
name|test
init|=
name|FLAG
argument_list|(
name|Punctuation_Connector
argument_list|)
operator||
name|FLAG
argument_list|(
name|Punctuation_Dash
argument_list|)
operator||
name|FLAG
argument_list|(
name|Punctuation_Open
argument_list|)
operator||
name|FLAG
argument_list|(
name|Punctuation_Close
argument_list|)
operator||
name|FLAG
argument_list|(
name|Punctuation_InitialQuote
argument_list|)
operator||
name|FLAG
argument_list|(
name|Punctuation_FinalQuote
argument_list|)
operator||
name|FLAG
argument_list|(
name|Punctuation_Other
argument_list|)
decl_stmt|;
return|return
name|FLAG
argument_list|(
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|category
argument_list|)
operator|&
name|test
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QChar::isSymbol() const      Returns true if the character is a symbol (Symbol_* categories);     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4 is     a symbol (Symbol_* categories); otherwise returns false. */
end_comment
begin_function
DECL|function|isSymbol
name|bool
name|QChar
operator|::
name|isSymbol
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
literal|false
return|;
specifier|const
name|int
name|test
init|=
name|FLAG
argument_list|(
name|Symbol_Math
argument_list|)
operator||
name|FLAG
argument_list|(
name|Symbol_Currency
argument_list|)
operator||
name|FLAG
argument_list|(
name|Symbol_Modifier
argument_list|)
operator||
name|FLAG
argument_list|(
name|Symbol_Other
argument_list|)
decl_stmt|;
return|return
name|FLAG
argument_list|(
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|category
argument_list|)
operator|&
name|test
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QChar::isLetter() const      Returns true if the character is a letter (Letter_* categories);     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QChar::isLetter(uint ucs4)     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4 is     a letter (Letter_* categories); otherwise returns false. */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|isLetter_helper
name|bool
name|QT_FASTCALL
name|QChar
operator|::
name|isLetter_helper
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
literal|false
return|;
specifier|const
name|int
name|test
init|=
name|FLAG
argument_list|(
name|Letter_Uppercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|Letter_Lowercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|Letter_Titlecase
argument_list|)
operator||
name|FLAG
argument_list|(
name|Letter_Modifier
argument_list|)
operator||
name|FLAG
argument_list|(
name|Letter_Other
argument_list|)
decl_stmt|;
return|return
name|FLAG
argument_list|(
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|category
argument_list|)
operator|&
name|test
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QChar::isNumber() const      Returns true if the character is a number (Number_* categories,     not just 0-9); otherwise returns false.      \sa isDigit() */
end_comment
begin_comment
comment|/*!     \fn bool QChar::isNumber(uint ucs4)     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4 is     a number (Number_* categories, not just 0-9); otherwise returns false.      \sa isDigit() */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|isNumber_helper
name|bool
name|QT_FASTCALL
name|QChar
operator|::
name|isNumber_helper
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
literal|false
return|;
specifier|const
name|int
name|test
init|=
name|FLAG
argument_list|(
name|Number_DecimalDigit
argument_list|)
operator||
name|FLAG
argument_list|(
name|Number_Letter
argument_list|)
operator||
name|FLAG
argument_list|(
name|Number_Other
argument_list|)
decl_stmt|;
return|return
name|FLAG
argument_list|(
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|category
argument_list|)
operator|&
name|test
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QChar::isLetterOrNumber() const      Returns true if the character is a letter or number (Letter_* or     Number_* categories); otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QChar::isLetterOrNumber(uint ucs4)     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4 is     a letter or number (Letter_* or Number_* categories); otherwise returns false. */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|isLetterOrNumber_helper
name|bool
name|QT_FASTCALL
name|QChar
operator|::
name|isLetterOrNumber_helper
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
literal|false
return|;
specifier|const
name|int
name|test
init|=
name|FLAG
argument_list|(
name|Letter_Uppercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|Letter_Lowercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|Letter_Titlecase
argument_list|)
operator||
name|FLAG
argument_list|(
name|Letter_Modifier
argument_list|)
operator||
name|FLAG
argument_list|(
name|Letter_Other
argument_list|)
operator||
name|FLAG
argument_list|(
name|Number_DecimalDigit
argument_list|)
operator||
name|FLAG
argument_list|(
name|Number_Letter
argument_list|)
operator||
name|FLAG
argument_list|(
name|Number_Other
argument_list|)
decl_stmt|;
return|return
name|FLAG
argument_list|(
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|category
argument_list|)
operator|&
name|test
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QChar::isDigit() const      Returns true if the character is a decimal digit     (Number_DecimalDigit); otherwise returns false.      \sa isNumber() */
end_comment
begin_comment
comment|/*!     \fn bool QChar::isDigit(uint ucs4)     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4 is     a decimal digit (Number_DecimalDigit); otherwise returns false.      \sa isNumber() */
end_comment
begin_comment
comment|/*!     \fn bool QChar::isNonCharacter() const     \since 5.0      Returns true if the QChar is a non-character; false otherwise.      Unicode has a certain number of code points that are classified     as "non-characters:" that is, they can be used for internal purposes     in applications but cannot be used for text interchange.     Those are the last two entries each Unicode Plane ([0xfffe..0xffff],     [0x1fffe..0x1ffff], etc.) as well as the entries in range [0xfdd0..0xfdef]. */
end_comment
begin_comment
comment|/*!     \fn bool QChar::isHighSurrogate() const      Returns true if the QChar is the high part of a UTF16 surrogate     (for example if its code point is in range [0xd800..0xdbff]); false otherwise. */
end_comment
begin_comment
comment|/*!     \fn bool QChar::isLowSurrogate() const      Returns true if the QChar is the low part of a UTF16 surrogate     (for example if its code point is in range [0xdc00..0xdfff]); false otherwise. */
end_comment
begin_comment
comment|/*!     \fn bool QChar::isSurrogate() const     \since 5.0      Returns true if the QChar contains a code point that is in either     the high or the low part of the UTF-16 surrogate range     (for example if its code point is in range [0xd800..0xdfff]); false otherwise. */
end_comment
begin_comment
comment|/*!     \fn static bool QChar::isNonCharacter(uint ucs4)     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4     is a non-character; false otherwise.      Unicode has a certain number of code points that are classified     as "non-characters:" that is, they can be used for internal purposes     in applications but cannot be used for text interchange.     Those are the last two entries each Unicode Plane ([0xfffe..0xffff],     [0x1fffe..0x1ffff], etc.) as well as the entries in range [0xfdd0..0xfdef]. */
end_comment
begin_comment
comment|/*!     \fn static bool QChar::isHighSurrogate(uint ucs4)     \overload      Returns true if the UCS-4-encoded character specified by \a ucs4     is the high part of a UTF16 surrogate     (for example if its code point is in range [0xd800..0xdbff]); false otherwise. */
end_comment
begin_comment
comment|/*!     \fn static bool QChar::isLowSurrogate(uint ucs4)     \overload      Returns true if the UCS-4-encoded character specified by \a ucs4     is the low part of a UTF16 surrogate     (for example if its code point is in range [0xdc00..0xdfff]); false otherwise. */
end_comment
begin_comment
comment|/*!     \fn static bool QChar::isSurrogate(uint ucs4)     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4     contains a code point that is in either the high or the low part of the     UTF-16 surrogate range (for example if its code point is in range [0xd800..0xdfff]);     false otherwise. */
end_comment
begin_comment
comment|/*!     \fn static bool QChar::requiresSurrogates(uint ucs4)      Returns true if the UCS-4-encoded character specified by \a ucs4     can be split into the high and low parts of a UTF16 surrogate     (for example if its code point is greater than or equals to 0x10000);     false otherwise. */
end_comment
begin_comment
comment|/*!     \fn static uint QChar::surrogateToUcs4(ushort high, ushort low)      Converts a UTF16 surrogate pair with the given \a high and \a low values     to it's UCS-4-encoded code point. */
end_comment
begin_comment
comment|/*!     \fn static uint QChar::surrogateToUcs4(QChar high, QChar low)     \overload      Converts a UTF16 surrogate pair (\a high, \a low) to it's UCS-4-encoded code point. */
end_comment
begin_comment
comment|/*!     \fn static ushort QChar::highSurrogate(uint ucs4)      Returns the high surrogate part of a UCS-4-encoded code point.     The returned result is undefined if \a ucs4 is smaller than 0x10000. */
end_comment
begin_comment
comment|/*!     \fn static ushort QChar::lowSurrogate(uint ucs4)      Returns the low surrogate part of a UCS-4-encoded code point.     The returned result is undefined if \a ucs4 is smaller than 0x10000. */
end_comment
begin_comment
comment|/*!     \fn int QChar::digitValue() const      Returns the numeric value of the digit, or -1 if the character is not a digit. */
end_comment
begin_comment
comment|/*!     \overload     Returns the numeric value of the digit specified by the UCS-4-encoded     character, \a ucs4, or -1 if the character is not a digit. */
end_comment
begin_function
DECL|function|digitValue
name|int
name|QChar
operator|::
name|digitValue
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|digitValue
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QChar::Category QChar::category() const      Returns the character's category. */
end_comment
begin_comment
comment|/*!     \overload     Returns the category of the UCS-4-encoded character specified by \a ucs4. */
end_comment
begin_function
DECL|function|category
name|QChar
operator|::
name|Category
name|QChar
operator|::
name|category
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
name|QChar
operator|::
name|Other_NotAssigned
return|;
return|return
operator|(
name|QChar
operator|::
name|Category
operator|)
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|category
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QChar::Direction QChar::direction() const      Returns the character's direction. */
end_comment
begin_comment
comment|/*!     \overload     Returns the direction of the UCS-4-encoded character specified by \a ucs4. */
end_comment
begin_function
DECL|function|direction
name|QChar
operator|::
name|Direction
name|QChar
operator|::
name|direction
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
name|QChar
operator|::
name|DirL
return|;
return|return
operator|(
name|QChar
operator|::
name|Direction
operator|)
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|direction
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QChar::Joining QChar::joining() const      Returns information about the joining properties of the character     (needed for certain languages such as Arabic). */
end_comment
begin_comment
comment|/*!     \overload     Returns information about the joining properties of the UCS-4-encoded     character specified by \a ucs4 (needed for certain languages such as Arabic). */
end_comment
begin_function
DECL|function|joining
name|QChar
operator|::
name|Joining
name|QChar
operator|::
name|joining
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
name|QChar
operator|::
name|OtherJoining
return|;
return|return
operator|(
name|QChar
operator|::
name|Joining
operator|)
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|joining
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QChar::hasMirrored() const      Returns true if the character should be reversed if the text     direction is reversed; otherwise returns false.      A bit faster equivalent of (ch.mirroredChar() != ch).      \sa mirroredChar() */
end_comment
begin_comment
comment|/*!     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4     should be reversed if the text direction is reversed; otherwise returns false.      A bit faster equivalent of (QChar::mirroredChar(ucs4) != ucs4).      \sa mirroredChar() */
end_comment
begin_function
DECL|function|hasMirrored
name|bool
name|QChar
operator|::
name|hasMirrored
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
literal|false
return|;
return|return
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|mirrorDiff
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QChar::isLower() const      Returns true if the character is a lowercase letter, for example     category() is Letter_Lowercase.      \sa isUpper(), toLower(), toUpper() */
end_comment
begin_comment
comment|/*!     \fn static bool QChar::isLower(uint ucs4)     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4     is a lowercase letter, for example category() is Letter_Lowercase.      \sa isUpper(), toLower(), toUpper() */
end_comment
begin_comment
comment|/*!     \fn bool QChar::isUpper() const      Returns true if the character is an uppercase letter, for example     category() is Letter_Uppercase.      \sa isLower(), toUpper(), toLower() */
end_comment
begin_comment
comment|/*!     \fn static bool QChar::isUpper(uint ucs4)     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4     is an uppercase letter, for example category() is Letter_Uppercase.      \sa isLower(), toUpper(), toLower() */
end_comment
begin_comment
comment|/*!     \fn bool QChar::isTitleCase() const      Returns true if the character is a titlecase letter, for example     category() is Letter_Titlecase.      \sa isLower(), toUpper(), toLower(), toTitleCase() */
end_comment
begin_comment
comment|/*!     \fn static bool QChar::isTitleCase(uint ucs4)     \overload     \since 5.0      Returns true if the UCS-4-encoded character specified by \a ucs4     is a titlecase letter, for example category() is Letter_Titlecase.      \sa isLower(), toUpper(), toLower(), toTitleCase() */
end_comment
begin_comment
comment|/*!     \fn QChar QChar::mirroredChar() const      Returns the mirrored character if this character is a mirrored     character; otherwise returns the character itself.      \sa hasMirrored() */
end_comment
begin_comment
comment|/*!     \overload     Returns the mirrored character if the UCS-4-encoded character specified     by \a ucs4 is a mirrored character; otherwise returns the character itself.      \sa hasMirrored() */
end_comment
begin_function
DECL|function|mirroredChar
name|uint
name|QChar
operator|::
name|mirroredChar
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
name|ucs4
return|;
return|return
name|ucs4
operator|+
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|mirrorDiff
return|;
block|}
end_function
begin_comment
comment|// constants for Hangul (de)composition, see UAX #15
end_comment
begin_enum
enum|enum
block|{
DECL|enumerator|Hangul_SBase
name|Hangul_SBase
init|=
literal|0xac00
block|,
DECL|enumerator|Hangul_LBase
name|Hangul_LBase
init|=
literal|0x1100
block|,
DECL|enumerator|Hangul_VBase
name|Hangul_VBase
init|=
literal|0x1161
block|,
DECL|enumerator|Hangul_TBase
name|Hangul_TBase
init|=
literal|0x11a7
block|,
DECL|enumerator|Hangul_LCount
name|Hangul_LCount
init|=
literal|19
block|,
DECL|enumerator|Hangul_VCount
name|Hangul_VCount
init|=
literal|21
block|,
DECL|enumerator|Hangul_TCount
name|Hangul_TCount
init|=
literal|28
block|,
DECL|enumerator|Hangul_NCount
name|Hangul_NCount
init|=
name|Hangul_VCount
operator|*
name|Hangul_TCount
block|,
DECL|enumerator|Hangul_SCount
name|Hangul_SCount
init|=
name|Hangul_LCount
operator|*
name|Hangul_NCount
block|}
enum|;
end_enum
begin_comment
comment|// buffer has to have a length of 3. It's needed for Hangul decomposition
end_comment
begin_function
DECL|function|decompositionHelper
specifier|static
specifier|const
name|unsigned
name|short
modifier|*
name|QT_FASTCALL
name|decompositionHelper
parameter_list|(
name|uint
name|ucs4
parameter_list|,
name|int
modifier|*
name|length
parameter_list|,
name|int
modifier|*
name|tag
parameter_list|,
name|unsigned
name|short
modifier|*
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>=
name|Hangul_SBase
operator|&&
name|ucs4
operator|<
name|Hangul_SBase
operator|+
name|Hangul_SCount
condition|)
block|{
comment|// compute Hangul syllable decomposition as per UAX #15
specifier|const
name|uint
name|SIndex
init|=
name|ucs4
operator|-
name|Hangul_SBase
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|Hangul_LBase
operator|+
name|SIndex
operator|/
name|Hangul_NCount
expr_stmt|;
comment|// L
name|buffer
index|[
literal|1
index|]
operator|=
name|Hangul_VBase
operator|+
operator|(
name|SIndex
operator|%
name|Hangul_NCount
operator|)
operator|/
name|Hangul_TCount
expr_stmt|;
comment|// V
name|buffer
index|[
literal|2
index|]
operator|=
name|Hangul_TBase
operator|+
name|SIndex
operator|%
name|Hangul_TCount
expr_stmt|;
comment|// T
operator|*
name|length
operator|=
name|buffer
index|[
literal|2
index|]
operator|==
name|Hangul_TBase
condition|?
literal|2
else|:
literal|3
expr_stmt|;
operator|*
name|tag
operator|=
name|QChar
operator|::
name|Canonical
expr_stmt|;
return|return
name|buffer
return|;
block|}
specifier|const
name|unsigned
name|short
name|index
init|=
name|GET_DECOMPOSITION_INDEX
argument_list|(
name|ucs4
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|0xffff
condition|)
block|{
operator|*
name|length
operator|=
literal|0
expr_stmt|;
operator|*
name|tag
operator|=
name|QChar
operator|::
name|NoDecomposition
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|const
name|unsigned
name|short
modifier|*
name|decomposition
init|=
name|uc_decomposition_map
operator|+
name|index
decl_stmt|;
operator|*
name|tag
operator|=
operator|(
operator|*
name|decomposition
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|length
operator|=
operator|(
operator|*
name|decomposition
operator|)
operator|>>
literal|8
expr_stmt|;
return|return
name|decomposition
operator|+
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Decomposes a character into it's constituent parts. Returns an empty string     if no decomposition exists. */
end_comment
begin_function
DECL|function|decomposition
name|QString
name|QChar
operator|::
name|decomposition
parameter_list|()
specifier|const
block|{
return|return
name|QChar
operator|::
name|decomposition
argument_list|(
name|ucs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Decomposes the UCS-4-encoded character specified by \a ucs4 into it's     constituent parts. Returns an empty string if no decomposition exists. */
end_comment
begin_function
DECL|function|decomposition
name|QString
name|QChar
operator|::
name|decomposition
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
name|unsigned
name|short
name|buffer
index|[
literal|3
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|tag
decl_stmt|;
specifier|const
name|unsigned
name|short
modifier|*
name|d
init|=
name|decompositionHelper
argument_list|(
name|ucs4
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|tag
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
return|return
name|QString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QChar::Decomposition QChar::decompositionTag() const      Returns the tag defining the composition of the character. Returns     QChar::NoDecomposition if no decomposition exists. */
end_comment
begin_comment
comment|/*!     \overload     Returns the tag defining the composition of the UCS-4-encoded character     specified by \a ucs4. Returns QChar::NoDecomposition if no decomposition exists. */
end_comment
begin_function
DECL|function|decompositionTag
name|QChar
operator|::
name|Decomposition
name|QChar
operator|::
name|decompositionTag
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>=
name|Hangul_SBase
operator|&&
name|ucs4
operator|<
name|Hangul_SBase
operator|+
name|Hangul_SCount
condition|)
return|return
name|QChar
operator|::
name|Canonical
return|;
specifier|const
name|unsigned
name|short
name|index
init|=
name|GET_DECOMPOSITION_INDEX
argument_list|(
name|ucs4
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|0xffff
condition|)
return|return
name|QChar
operator|::
name|NoDecomposition
return|;
return|return
call|(
name|QChar
operator|::
name|Decomposition
call|)
argument_list|(
name|uc_decomposition_map
index|[
name|index
index|]
operator|&
literal|0xff
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn unsigned char QChar::combiningClass() const      Returns the combining class for the character as defined in the     Unicode standard. This is mainly useful as a positioning hint for     marks attached to a base character.      The Qt text rendering engine uses this information to correctly     position non-spacing marks around a base character. */
end_comment
begin_comment
comment|/*!     \overload     Returns the combining class for the UCS-4-encoded character specified by     \a ucs4, as defined in the Unicode standard. */
end_comment
begin_function
DECL|function|combiningClass
name|unsigned
name|char
name|QChar
operator|::
name|combiningClass
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|unsigned
name|char
operator|)
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|combiningClass
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QChar::Script QChar::script() const     \since 5.1      Returns the Unicode script property value for this character. */
end_comment
begin_comment
comment|/*!     \overload     \since 5.1      Returns the Unicode script property value for the character specified in     its UCS-4-encoded form as \a ucs4. */
end_comment
begin_function
DECL|function|script
name|QChar
operator|::
name|Script
name|QChar
operator|::
name|script
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
name|QChar
operator|::
name|Script_Unknown
return|;
return|return
operator|(
name|QChar
operator|::
name|Script
operator|)
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|script
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QChar::UnicodeVersion QChar::unicodeVersion() const      Returns the Unicode version that introduced this character. */
end_comment
begin_comment
comment|/*!     \overload     Returns the Unicode version that introduced the character specified in     its UCS-4-encoded form as \a ucs4. */
end_comment
begin_function
DECL|function|unicodeVersion
name|QChar
operator|::
name|UnicodeVersion
name|QChar
operator|::
name|unicodeVersion
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
name|QChar
operator|::
name|Unicode_Unassigned
return|;
return|return
operator|(
name|QChar
operator|::
name|UnicodeVersion
operator|)
name|qGetProp
argument_list|(
name|ucs4
argument_list|)
operator|->
name|unicodeVersion
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the most recent supported Unicode version. */
end_comment
begin_function
DECL|function|currentUnicodeVersion
name|QChar
operator|::
name|UnicodeVersion
name|QChar
operator|::
name|currentUnicodeVersion
parameter_list|()
block|{
return|return
name|UNICODE_DATA_VERSION
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|toLowerCase_helper
specifier|static
specifier|inline
name|T
name|toLowerCase_helper
parameter_list|(
name|T
name|uc
parameter_list|)
block|{
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|p
init|=
name|qGetProp
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|lowerCaseSpecial
condition|)
block|{
specifier|const
name|ushort
modifier|*
name|specialCase
init|=
name|specialCaseMap
operator|+
name|p
operator|->
name|lowerCaseDiff
decl_stmt|;
return|return
operator|(
operator|*
name|specialCase
operator|==
literal|1
operator|)
condition|?
name|specialCase
index|[
literal|1
index|]
else|:
name|uc
return|;
block|}
return|return
name|uc
operator|+
name|p
operator|->
name|lowerCaseDiff
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|toUpperCase_helper
specifier|static
specifier|inline
name|T
name|toUpperCase_helper
parameter_list|(
name|T
name|uc
parameter_list|)
block|{
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|p
init|=
name|qGetProp
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|upperCaseSpecial
condition|)
block|{
specifier|const
name|ushort
modifier|*
name|specialCase
init|=
name|specialCaseMap
operator|+
name|p
operator|->
name|upperCaseDiff
decl_stmt|;
return|return
operator|(
operator|*
name|specialCase
operator|==
literal|1
operator|)
condition|?
name|specialCase
index|[
literal|1
index|]
else|:
name|uc
return|;
block|}
return|return
name|uc
operator|+
name|p
operator|->
name|upperCaseDiff
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|toTitleCase_helper
specifier|static
specifier|inline
name|T
name|toTitleCase_helper
parameter_list|(
name|T
name|uc
parameter_list|)
block|{
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|p
init|=
name|qGetProp
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|titleCaseSpecial
condition|)
block|{
specifier|const
name|ushort
modifier|*
name|specialCase
init|=
name|specialCaseMap
operator|+
name|p
operator|->
name|titleCaseDiff
decl_stmt|;
return|return
operator|(
operator|*
name|specialCase
operator|==
literal|1
operator|)
condition|?
name|specialCase
index|[
literal|1
index|]
else|:
name|uc
return|;
block|}
return|return
name|uc
operator|+
name|p
operator|->
name|titleCaseDiff
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|toCaseFolded_helper
specifier|static
specifier|inline
name|T
name|toCaseFolded_helper
parameter_list|(
name|T
name|uc
parameter_list|)
block|{
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|p
init|=
name|qGetProp
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|caseFoldSpecial
condition|)
block|{
specifier|const
name|ushort
modifier|*
name|specialCase
init|=
name|specialCaseMap
operator|+
name|p
operator|->
name|caseFoldDiff
decl_stmt|;
return|return
operator|(
operator|*
name|specialCase
operator|==
literal|1
operator|)
condition|?
name|specialCase
index|[
literal|1
index|]
else|:
name|uc
return|;
block|}
return|return
name|uc
operator|+
name|p
operator|->
name|caseFoldDiff
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QChar QChar::toLower() const      Returns the lowercase equivalent if the character is uppercase or titlecase;     otherwise returns the character itself. */
end_comment
begin_comment
comment|/*!     \overload     Returns the lowercase equivalent of the UCS-4-encoded character specified     by \a ucs4 if the character is uppercase or titlecase; otherwise returns     the character itself. */
end_comment
begin_function
DECL|function|toLower
name|uint
name|QChar
operator|::
name|toLower
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
name|ucs4
return|;
return|return
name|toLowerCase_helper
argument_list|<
name|uint
argument_list|>
argument_list|(
name|ucs4
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QChar QChar::toUpper() const      Returns the uppercase equivalent if the character is lowercase or titlecase;     otherwise returns the character itself. */
end_comment
begin_comment
comment|/*!     \overload     Returns the uppercase equivalent of the UCS-4-encoded character specified     by \a ucs4 if the character is lowercase or titlecase; otherwise returns     the character itself. */
end_comment
begin_function
DECL|function|toUpper
name|uint
name|QChar
operator|::
name|toUpper
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
name|ucs4
return|;
return|return
name|toUpperCase_helper
argument_list|<
name|uint
argument_list|>
argument_list|(
name|ucs4
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QChar QChar::toTitleCase() const      Returns the title case equivalent if the character is lowercase or uppercase;     otherwise returns the character itself. */
end_comment
begin_comment
comment|/*!     \overload     Returns the title case equivalent of the UCS-4-encoded character specified     by \a ucs4 if the character is lowercase or uppercase; otherwise returns     the character itself. */
end_comment
begin_function
DECL|function|toTitleCase
name|uint
name|QChar
operator|::
name|toTitleCase
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
name|ucs4
return|;
return|return
name|toTitleCase_helper
argument_list|<
name|uint
argument_list|>
argument_list|(
name|ucs4
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|foldCase
specifier|static
specifier|inline
name|uint
name|foldCase
parameter_list|(
specifier|const
name|ushort
modifier|*
name|ch
parameter_list|,
specifier|const
name|ushort
modifier|*
name|start
parameter_list|)
block|{
name|uint
name|c
init|=
operator|*
name|ch
decl_stmt|;
if|if
condition|(
name|QChar
argument_list|(
name|c
argument_list|)
operator|.
name|isLowSurrogate
argument_list|()
operator|&&
name|ch
operator|>
name|start
operator|&&
name|QChar
argument_list|(
operator|*
operator|(
name|ch
operator|-
literal|1
operator|)
argument_list|)
operator|.
name|isHighSurrogate
argument_list|()
condition|)
name|c
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
operator|*
operator|(
name|ch
operator|-
literal|1
operator|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|toCaseFolded_helper
argument_list|<
name|uint
argument_list|>
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|foldCase
specifier|static
specifier|inline
name|uint
name|foldCase
parameter_list|(
name|uint
name|ch
parameter_list|,
name|uint
modifier|&
name|last
parameter_list|)
block|{
name|uint
name|c
init|=
name|ch
decl_stmt|;
if|if
condition|(
name|QChar
argument_list|(
name|c
argument_list|)
operator|.
name|isLowSurrogate
argument_list|()
operator|&&
name|QChar
argument_list|(
name|last
argument_list|)
operator|.
name|isHighSurrogate
argument_list|()
condition|)
name|c
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|last
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|last
operator|=
name|ch
expr_stmt|;
return|return
name|toCaseFolded_helper
argument_list|<
name|uint
argument_list|>
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|foldCase
specifier|static
specifier|inline
name|ushort
name|foldCase
parameter_list|(
name|ushort
name|ch
parameter_list|)
block|{
return|return
name|toCaseFolded_helper
argument_list|<
name|ushort
argument_list|>
argument_list|(
name|ch
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QChar QChar::toCaseFolded() const      Returns the case folded equivalent of the character.     For most Unicode characters this is the same as toLowerCase(). */
end_comment
begin_comment
comment|/*!     \overload     Returns the case folded equivalent of the UCS-4-encoded character specified     by \a ucs4. For most Unicode characters this is the same as toLowerCase(). */
end_comment
begin_function
DECL|function|toCaseFolded
name|uint
name|QChar
operator|::
name|toCaseFolded
parameter_list|(
name|uint
name|ucs4
parameter_list|)
block|{
if|if
condition|(
name|ucs4
operator|>
name|LastValidCodePoint
condition|)
return|return
name|ucs4
return|;
return|return
name|toCaseFolded_helper
argument_list|<
name|uint
argument_list|>
argument_list|(
name|ucs4
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn char QChar::toLatin1() const      Returns the Latin-1 character equivalent to the QChar, or 0. This     is mainly useful for non-internationalized software.      \note It is not possible to distinguish a non-Latin-1 character from a Latin-1 0     (NUL) character. Prefer to use unicode(), which does not have this ambiguity.      \sa unicode() */
end_comment
begin_comment
comment|/*!     \fn QChar QChar::fromLatin1(char)      Converts the Latin-1 character \a c to its equivalent QChar. This     is mainly useful for non-internationalized software.      An alternative is to use QLatin1Char.      \sa toLatin1(), unicode() */
end_comment
begin_comment
comment|/*!     \fn char QChar::toAscii() const     \deprecated      Returns the Latin-1 character value of the QChar, or 0 if the character is not     representable.      The main purpose of this function is to preserve ASCII characters used     in C strings. This is mainly useful for developers of non-internationalized     software.      \note It is not possible to distinguish a non-Latin 1 character from an ASCII 0     (NUL) character. Prefer to use unicode(), which does not have this ambiguity.      \note This function does not check whether the character value is inside     the valid range of US-ASCII.      \sa toLatin1(), unicode() */
end_comment
begin_comment
comment|/*!     \fn QChar QChar::fromAscii(char)     \deprecated      Converts the ASCII character \a c to it's equivalent QChar. This     is mainly useful for non-internationalized software.      An alternative is to use QLatin1Char.      \sa fromLatin1(), unicode() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \relates QChar      Writes the char \a chr to the stream \a out.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
name|QChar
name|chr
parameter_list|)
block|{
name|out
operator|<<
name|quint16
argument_list|(
name|chr
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QChar      Reads a char from the stream \a in into char \a chr.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QChar
modifier|&
name|chr
parameter_list|)
block|{
name|quint16
name|u
decl_stmt|;
name|in
operator|>>
name|u
expr_stmt|;
name|chr
operator|.
name|unicode
argument_list|()
operator|=
name|ushort
argument_list|(
name|u
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*!     \fn ushort& QChar::unicode()      Returns a reference to the numeric Unicode value of the QChar. */
end_comment
begin_comment
comment|/*!     \fn ushort QChar::unicode() const      Returns the numeric Unicode value of the QChar. */
end_comment
begin_comment
comment|/*****************************************************************************   Documentation of QChar related functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \fn bool operator==(QChar c1, QChar c2)      \relates QChar      Returns true if \a c1 and \a c2 are the same Unicode character;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn int operator!=(QChar c1, QChar c2)      \relates QChar      Returns true if \a c1 and \a c2 are not the same Unicode     character; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn int operator<=(QChar c1, QChar c2)      \relates QChar      Returns true if the numeric Unicode value of \a c1 is less than     or equal to that of \a c2; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn int operator>=(QChar c1, QChar c2)      \relates QChar      Returns true if the numeric Unicode value of \a c1 is greater than     or equal to that of \a c2; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn int operator<(QChar c1, QChar c2)      \relates QChar      Returns true if the numeric Unicode value of \a c1 is less than     that of \a c2; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn int operator>(QChar c1, QChar c2)      \relates QChar      Returns true if the numeric Unicode value of \a c1 is greater than     that of \a c2; otherwise returns false. */
end_comment
begin_comment
comment|// ---------------------------------------------------------------------------
end_comment
begin_function
DECL|function|decomposeHelper
specifier|static
name|void
name|decomposeHelper
parameter_list|(
name|QString
modifier|*
name|str
parameter_list|,
name|bool
name|canonical
parameter_list|,
name|QChar
operator|::
name|UnicodeVersion
name|version
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|int
name|length
decl_stmt|;
name|int
name|tag
decl_stmt|;
name|unsigned
name|short
name|buffer
index|[
literal|3
index|]
decl_stmt|;
name|QString
modifier|&
name|s
init|=
operator|*
name|str
decl_stmt|;
specifier|const
name|unsigned
name|short
modifier|*
name|utf16
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|s
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|short
modifier|*
name|uc
init|=
name|utf16
operator|+
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|uc
operator|!=
name|utf16
operator|+
name|from
condition|)
block|{
name|uint
name|ucs4
init|=
operator|*
operator|(
operator|--
name|uc
operator|)
decl_stmt|;
if|if
condition|(
name|QChar
argument_list|(
name|ucs4
argument_list|)
operator|.
name|isLowSurrogate
argument_list|()
operator|&&
name|uc
operator|!=
name|utf16
condition|)
block|{
name|ushort
name|high
init|=
operator|*
operator|(
name|uc
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|QChar
argument_list|(
name|high
argument_list|)
operator|.
name|isHighSurrogate
argument_list|()
condition|)
block|{
operator|--
name|uc
expr_stmt|;
name|ucs4
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|high
argument_list|,
name|ucs4
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|QChar
operator|::
name|unicodeVersion
argument_list|(
name|ucs4
argument_list|)
operator|>
name|version
condition|)
continue|continue;
specifier|const
name|unsigned
name|short
modifier|*
name|d
init|=
name|decompositionHelper
argument_list|(
name|ucs4
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|tag
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|(
name|canonical
operator|&&
name|tag
operator|!=
name|QChar
operator|::
name|Canonical
operator|)
condition|)
continue|continue;
name|int
name|pos
init|=
name|uc
operator|-
name|utf16
decl_stmt|;
name|s
operator|.
name|replace
argument_list|(
name|pos
argument_list|,
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|ucs4
argument_list|)
condition|?
literal|2
else|:
literal|1
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|// since the replace invalidates the pointers and we do decomposition recursive
name|utf16
operator|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|short
operator|*
argument_list|>
argument_list|(
name|s
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|uc
operator|=
name|utf16
operator|+
name|pos
operator|+
name|length
expr_stmt|;
block|}
block|}
end_function
begin_struct
DECL|struct|UCS2Pair
struct|struct
name|UCS2Pair
block|{
DECL|member|u1
name|ushort
name|u1
decl_stmt|;
DECL|member|u2
name|ushort
name|u2
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|operator <
specifier|inline
name|bool
name|operator
name|<
parameter_list|(
name|ushort
name|u1
parameter_list|,
specifier|const
name|UCS2Pair
modifier|&
name|ligature
parameter_list|)
block|{
return|return
name|u1
operator|<
name|ligature
operator|.
name|u1
return|;
block|}
end_function
begin_function
DECL|function|operator <
specifier|inline
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|UCS2Pair
modifier|&
name|ligature
parameter_list|,
name|ushort
name|u1
parameter_list|)
block|{
return|return
name|ligature
operator|.
name|u1
operator|<
name|u1
return|;
block|}
end_function
begin_struct
DECL|struct|UCS2SurrogatePair
struct|struct
name|UCS2SurrogatePair
block|{
DECL|member|p1
name|UCS2Pair
name|p1
decl_stmt|;
DECL|member|p2
name|UCS2Pair
name|p2
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|operator <
specifier|inline
name|bool
name|operator
name|<
parameter_list|(
name|uint
name|u1
parameter_list|,
specifier|const
name|UCS2SurrogatePair
modifier|&
name|ligature
parameter_list|)
block|{
return|return
name|u1
operator|<
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|ligature
operator|.
name|p1
operator|.
name|u1
argument_list|,
name|ligature
operator|.
name|p1
operator|.
name|u2
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|operator <
specifier|inline
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|UCS2SurrogatePair
modifier|&
name|ligature
parameter_list|,
name|uint
name|u1
parameter_list|)
block|{
return|return
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|ligature
operator|.
name|p1
operator|.
name|u1
argument_list|,
name|ligature
operator|.
name|p1
operator|.
name|u2
argument_list|)
operator|<
name|u1
return|;
block|}
end_function
begin_function
DECL|function|ligatureHelper
specifier|static
name|uint
specifier|inline
name|ligatureHelper
parameter_list|(
name|uint
name|u1
parameter_list|,
name|uint
name|u2
parameter_list|)
block|{
if|if
condition|(
name|u1
operator|>=
name|Hangul_LBase
operator|&&
name|u1
operator|<=
name|Hangul_SBase
operator|+
name|Hangul_SCount
condition|)
block|{
comment|// compute Hangul syllable composition as per UAX #15
comment|// hangul L-V pair
specifier|const
name|uint
name|LIndex
init|=
name|u1
operator|-
name|Hangul_LBase
decl_stmt|;
if|if
condition|(
name|LIndex
operator|<
name|Hangul_LCount
condition|)
block|{
specifier|const
name|uint
name|VIndex
init|=
name|u2
operator|-
name|Hangul_VBase
decl_stmt|;
if|if
condition|(
name|VIndex
operator|<
name|Hangul_VCount
condition|)
return|return
name|Hangul_SBase
operator|+
operator|(
name|LIndex
operator|*
name|Hangul_VCount
operator|+
name|VIndex
operator|)
operator|*
name|Hangul_TCount
return|;
block|}
comment|// hangul LV-T pair
specifier|const
name|uint
name|SIndex
init|=
name|u1
operator|-
name|Hangul_SBase
decl_stmt|;
if|if
condition|(
name|SIndex
operator|<
name|Hangul_SCount
operator|&&
operator|(
name|SIndex
operator|%
name|Hangul_TCount
operator|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|uint
name|TIndex
init|=
name|u2
operator|-
name|Hangul_TBase
decl_stmt|;
if|if
condition|(
name|TIndex
operator|<=
name|Hangul_TCount
condition|)
return|return
name|u1
operator|+
name|TIndex
return|;
block|}
block|}
specifier|const
name|unsigned
name|short
name|index
init|=
name|GET_LIGATURE_INDEX
argument_list|(
name|u2
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|0xffff
condition|)
return|return
literal|0
return|;
specifier|const
name|unsigned
name|short
modifier|*
name|ligatures
init|=
name|uc_ligature_map
operator|+
name|index
decl_stmt|;
name|ushort
name|length
init|=
operator|*
name|ligatures
operator|++
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|u1
argument_list|)
condition|)
block|{
specifier|const
name|UCS2SurrogatePair
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|UCS2SurrogatePair
operator|*
argument_list|>
argument_list|(
name|ligatures
argument_list|)
decl_stmt|;
specifier|const
name|UCS2SurrogatePair
modifier|*
name|r
init|=
name|qBinaryFind
argument_list|(
name|data
argument_list|,
name|data
operator|+
name|length
argument_list|,
name|u1
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
name|data
operator|+
name|length
condition|)
return|return
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|r
operator|->
name|p2
operator|.
name|u1
argument_list|,
name|r
operator|->
name|p2
operator|.
name|u2
argument_list|)
return|;
block|}
else|else
block|{
specifier|const
name|UCS2Pair
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|UCS2Pair
operator|*
argument_list|>
argument_list|(
name|ligatures
argument_list|)
decl_stmt|;
specifier|const
name|UCS2Pair
modifier|*
name|r
init|=
name|qBinaryFind
argument_list|(
name|data
argument_list|,
name|data
operator|+
name|length
argument_list|,
name|ushort
argument_list|(
name|u1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
name|data
operator|+
name|length
condition|)
return|return
name|r
operator|->
name|u2
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|composeHelper
specifier|static
name|void
name|composeHelper
parameter_list|(
name|QString
modifier|*
name|str
parameter_list|,
name|QChar
operator|::
name|UnicodeVersion
name|version
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|QString
modifier|&
name|s
init|=
operator|*
name|str
decl_stmt|;
if|if
condition|(
name|from
operator|<
literal|0
operator|||
name|s
operator|.
name|length
argument_list|()
operator|-
name|from
operator|<
literal|2
condition|)
return|return;
name|uint
name|stcode
init|=
literal|0
decl_stmt|;
comment|// starter code point
name|int
name|starter
init|=
operator|-
literal|1
decl_stmt|;
comment|// starter position
name|int
name|next
init|=
operator|-
literal|1
decl_stmt|;
comment|// to prevent i == next
name|int
name|lastCombining
init|=
literal|255
decl_stmt|;
comment|// to prevent combining> lastCombining
name|int
name|pos
init|=
name|from
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
name|int
name|i
init|=
name|pos
decl_stmt|;
name|uint
name|uc
init|=
name|s
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|QChar
argument_list|(
name|uc
argument_list|)
operator|.
name|isHighSurrogate
argument_list|()
operator|&&
name|pos
operator|<
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
name|ushort
name|low
init|=
name|s
operator|.
name|at
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|QChar
argument_list|(
name|low
argument_list|)
operator|.
name|isLowSurrogate
argument_list|()
condition|)
block|{
name|uc
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|uc
argument_list|,
name|low
argument_list|)
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
block|}
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|p
init|=
name|qGetProp
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|unicodeVersion
operator|>
name|version
condition|)
block|{
name|starter
operator|=
operator|-
literal|1
expr_stmt|;
name|next
operator|=
operator|-
literal|1
expr_stmt|;
comment|// to prevent i == next
name|lastCombining
operator|=
literal|255
expr_stmt|;
comment|// to prevent combining> lastCombining
operator|++
name|pos
expr_stmt|;
continue|continue;
block|}
name|int
name|combining
init|=
name|p
operator|->
name|combiningClass
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
name|next
operator|||
name|combining
operator|>
name|lastCombining
operator|)
operator|&&
name|starter
operator|>=
name|from
condition|)
block|{
comment|// allowed to form ligature with S
name|uint
name|ligature
init|=
name|ligatureHelper
argument_list|(
name|stcode
argument_list|,
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
name|ligature
condition|)
block|{
name|stcode
operator|=
name|ligature
expr_stmt|;
name|QChar
modifier|*
name|d
init|=
name|s
operator|.
name|data
argument_list|()
decl_stmt|;
comment|// ligatureHelper() never changes planes
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|ligature
argument_list|)
condition|)
block|{
name|d
index|[
name|starter
index|]
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|ligature
argument_list|)
expr_stmt|;
name|d
index|[
name|starter
operator|+
literal|1
index|]
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|ligature
argument_list|)
expr_stmt|;
name|s
operator|.
name|remove
argument_list|(
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
index|[
name|starter
index|]
operator|=
name|ligature
expr_stmt|;
name|s
operator|.
name|remove
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
if|if
condition|(
name|combining
operator|==
literal|0
condition|)
block|{
name|starter
operator|=
name|i
expr_stmt|;
name|stcode
operator|=
name|uc
expr_stmt|;
name|next
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
block|}
name|lastCombining
operator|=
name|combining
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|canonicalOrderHelper
specifier|static
name|void
name|canonicalOrderHelper
parameter_list|(
name|QString
modifier|*
name|str
parameter_list|,
name|QChar
operator|::
name|UnicodeVersion
name|version
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|QString
modifier|&
name|s
init|=
operator|*
name|str
decl_stmt|;
specifier|const
name|int
name|l
init|=
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
decl_stmt|;
name|uint
name|u1
decl_stmt|,
name|u2
decl_stmt|;
name|ushort
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|pos
init|=
name|from
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|l
condition|)
block|{
name|int
name|p2
init|=
name|pos
operator|+
literal|1
decl_stmt|;
name|u1
operator|=
name|s
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|.
name|unicode
argument_list|()
expr_stmt|;
if|if
condition|(
name|QChar
argument_list|(
name|u1
argument_list|)
operator|.
name|isHighSurrogate
argument_list|()
condition|)
block|{
name|ushort
name|low
init|=
name|s
operator|.
name|at
argument_list|(
name|p2
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|QChar
argument_list|(
name|low
argument_list|)
operator|.
name|isLowSurrogate
argument_list|()
condition|)
block|{
name|u1
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|u1
argument_list|,
name|low
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|>=
name|l
condition|)
break|break;
operator|++
name|p2
expr_stmt|;
block|}
block|}
name|c1
operator|=
literal|0
expr_stmt|;
name|advance
label|:
name|u2
operator|=
name|s
operator|.
name|at
argument_list|(
name|p2
argument_list|)
operator|.
name|unicode
argument_list|()
expr_stmt|;
if|if
condition|(
name|QChar
argument_list|(
name|u2
argument_list|)
operator|.
name|isHighSurrogate
argument_list|()
operator|&&
name|p2
operator|<
name|l
condition|)
block|{
name|ushort
name|low
init|=
name|s
operator|.
name|at
argument_list|(
name|p2
operator|+
literal|1
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|QChar
argument_list|(
name|low
argument_list|)
operator|.
name|isLowSurrogate
argument_list|()
condition|)
block|{
name|u2
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|u2
argument_list|,
name|low
argument_list|)
expr_stmt|;
operator|++
name|p2
expr_stmt|;
block|}
block|}
name|c2
operator|=
literal|0
expr_stmt|;
block|{
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|p
init|=
name|qGetProp
argument_list|(
name|u2
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|unicodeVersion
operator|<=
name|version
condition|)
name|c2
operator|=
name|p
operator|->
name|combiningClass
expr_stmt|;
block|}
if|if
condition|(
name|c2
operator|==
literal|0
condition|)
block|{
name|pos
operator|=
name|p2
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c1
operator|==
literal|0
condition|)
block|{
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|p
init|=
name|qGetProp
argument_list|(
name|u1
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|unicodeVersion
operator|<=
name|version
condition|)
name|c1
operator|=
name|p
operator|->
name|combiningClass
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|>
name|c2
condition|)
block|{
name|QChar
modifier|*
name|uc
init|=
name|s
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
name|p
init|=
name|pos
decl_stmt|;
comment|// exchange characters
if|if
condition|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|u2
argument_list|)
condition|)
block|{
name|uc
index|[
name|p
operator|++
index|]
operator|=
name|u2
expr_stmt|;
block|}
else|else
block|{
name|uc
index|[
name|p
operator|++
index|]
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|u2
argument_list|)
expr_stmt|;
name|uc
index|[
name|p
operator|++
index|]
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|u2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|u1
argument_list|)
condition|)
block|{
name|uc
index|[
name|p
operator|++
index|]
operator|=
name|u1
expr_stmt|;
block|}
else|else
block|{
name|uc
index|[
name|p
operator|++
index|]
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|u1
argument_list|)
expr_stmt|;
name|uc
index|[
name|p
operator|++
index|]
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|u1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
operator|--
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
operator|&&
name|s
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|.
name|isLowSurrogate
argument_list|()
condition|)
operator|--
name|pos
expr_stmt|;
block|}
else|else
block|{
operator|++
name|pos
expr_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|u1
argument_list|)
condition|)
operator|++
name|pos
expr_stmt|;
name|u1
operator|=
name|u2
expr_stmt|;
name|c1
operator|=
name|c2
expr_stmt|;
comment|// != 0
name|p2
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|u1
argument_list|)
condition|)
operator|++
name|p2
expr_stmt|;
if|if
condition|(
name|p2
operator|>
name|l
condition|)
break|break;
goto|goto
name|advance
goto|;
block|}
block|}
block|}
end_function
begin_comment
comment|// returns true if the text is in a desired Normalization Form already; false otherwise.
end_comment
begin_comment
comment|// sets lastStable to the position of the last stable code point
end_comment
begin_function
DECL|function|normalizationQuickCheckHelper
specifier|static
name|bool
name|normalizationQuickCheckHelper
parameter_list|(
name|QString
modifier|*
name|str
parameter_list|,
name|QString
operator|::
name|NormalizationForm
name|mode
parameter_list|,
name|int
name|from
parameter_list|,
name|int
modifier|*
name|lastStable
parameter_list|)
block|{
name|Q_STATIC_ASSERT
argument_list|(
name|QString
operator|::
name|NormalizationForm_D
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Q_STATIC_ASSERT
argument_list|(
name|QString
operator|::
name|NormalizationForm_C
operator|==
literal|1
argument_list|)
expr_stmt|;
name|Q_STATIC_ASSERT
argument_list|(
name|QString
operator|::
name|NormalizationForm_KD
operator|==
literal|2
argument_list|)
expr_stmt|;
name|Q_STATIC_ASSERT
argument_list|(
name|QString
operator|::
name|NormalizationForm_KC
operator|==
literal|3
argument_list|)
expr_stmt|;
enum|enum
block|{
name|NFQC_YES
init|=
literal|0
block|,
name|NFQC_NO
init|=
literal|1
block|,
name|NFQC_MAYBE
init|=
literal|3
block|}
enum|;
specifier|const
name|ushort
modifier|*
name|string
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|str
operator|->
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|length
init|=
name|str
operator|->
name|length
argument_list|()
decl_stmt|;
comment|// this avoids one out of bounds check in the loop
while|while
condition|(
name|length
operator|>
name|from
operator|&&
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|string
index|[
name|length
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|length
expr_stmt|;
name|uchar
name|lastCombining
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
name|int
name|pos
init|=
name|i
decl_stmt|;
name|uint
name|uc
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|uc
operator|<
literal|0x80
condition|)
block|{
comment|// ASCII characters are stable code points
name|lastCombining
operator|=
literal|0
expr_stmt|;
operator|*
name|lastStable
operator|=
name|pos
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|uc
argument_list|)
condition|)
block|{
name|ushort
name|low
init|=
name|string
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|low
argument_list|)
condition|)
block|{
comment|// treat surrogate like stable code point
name|lastCombining
operator|=
literal|0
expr_stmt|;
operator|*
name|lastStable
operator|=
name|pos
expr_stmt|;
continue|continue;
block|}
operator|++
name|i
expr_stmt|;
name|uc
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|uc
argument_list|,
name|low
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|p
init|=
name|qGetProp
argument_list|(
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|combiningClass
argument_list|<
name|lastCombining
operator|&&
name|p
operator|->
name|combiningClass
argument_list|>
literal|0
condition|)
return|return
literal|false
return|;
specifier|const
name|uchar
name|check
init|=
operator|(
name|p
operator|->
name|nfQuickCheck
operator|>>
operator|(
name|mode
operator|<<
literal|1
operator|)
operator|)
operator|&
literal|0x03
decl_stmt|;
if|if
condition|(
name|check
operator|!=
name|NFQC_YES
condition|)
return|return
literal|false
return|;
comment|// ### can we quick check NFQC_MAYBE ?
name|lastCombining
operator|=
name|p
operator|->
name|combiningClass
expr_stmt|;
if|if
condition|(
name|lastCombining
operator|==
literal|0
condition|)
operator|*
name|lastStable
operator|=
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|!=
name|str
operator|->
name|length
argument_list|()
condition|)
comment|// low surrogate parts at the end of text
operator|*
name|lastStable
operator|=
name|str
operator|->
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
