begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Giuseppe D'Angelo<dangelog@gmail.com>. ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qregularexpression.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmutex.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvector.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|<pcre.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QRegularExpression     \reentrant      \brief The QRegularExpression class provides pattern matching using regular     expressions.      \since 5.0      \ingroup tools     \ingroup shared      \keyword regular expression      Regular expressions, or \e{regexps}, are a very powerful tool to handle     strings and texts. This is useful in many contexts, e.g.,      \table     \row \li Validation          \li A regexp can test whether a substring meets some criteria,          e.g. is an integer or contains no whitespace.     \row \li Searching          \li A regexp provides more powerful pattern matching than          simple substring matching, e.g., match one of the words          \e{mail}, \e{letter} or \e{correspondence}, but none of the          words \e{email}, \e{mailman}, \e{mailer}, \e{letterbox}, etc.     \row \li Search and Replace          \li A regexp can replace all occurrences of a substring with a          different substring, e.g., replace all occurrences of \e{&}          with \e{\&amp;} except where the \e{&} is already followed by          an \e{amp;}.     \row \li String Splitting          \li A regexp can be used to identify where a string should be          split apart, e.g. splitting tab-delimited strings.     \endtable      This document is by no means a complete reference to pattern matching using     regular expressions, and the following parts will require the reader to     have some basic knowledge about Perl-like regular expressions and their     pattern syntax.      Good references about regular expressions include:      \list     \li \e {Mastering Regular Expressions} (Third Edition) by Jeffrey E. F.     Friedl, ISBN 0-596-52812-4;     \li the \l{http://pcre.org/pcre.txt} {pcrepattern(3)} man page, describing     the pattern syntax supported by PCRE (the reference implementation of     Perl-compatible regular expressions);     \li the \l{http://perldoc.perl.org/perlre.html} {Perl's regular expression     documentation} and the \l{http://perldoc.perl.org/perlretut.html} {Perl's     regular expression tutorial}.     \endlist      \tableofcontents      \section1 Introduction      QRegularExpression implements Perl-compatible regular expressions. It fully     supports Unicode. For an overview of the regular expression syntax     supported by QRegularExpression, please refer to the aforementioned     pcrepattern(3) man page. A regular expression is made up of two things: a     \b{pattern string} and a set of \b{pattern options} that change the     meaning of the pattern string.      You can set the pattern string by passing a string to the QRegularExpression     constructor:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 0      This sets the pattern string to \c{a pattern}. You can also use the     setPattern() function to set a pattern on an existing QRegularExpression     object:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 1      Note that due to C++ literal strings rules, you must escape all backslashes     inside the pattern string with another backslash:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 2      The pattern() function returns the pattern that it's currently set for a     QRegularExpression object:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 3      \section1 Pattern options      The meaning of the pattern string can be modified by setting one or more     \e{pattern options}. For instance, it is possible to set a pattern to match     case insensitively by setting the QRegularExpression::CaseInsensitiveOption.      You can set the options by passing them to the QRegularExpression     constructor, as in:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 4      Alternatively, you can use the setPatternOptions() function on an existing     QRegularExpressionObject:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 5      It is possible to get the pattern options currently set on a     QRegularExpression object by using the patternOptions() function:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 6      Please refer to the QRegularExpression::PatternOption enum documentation for     more information about each pattern option.      \section1 Match type and match options      The last two arguments of the match() and the globalMatch() functions set     the match type and the match options. The match type is a value of the     QRegularExpression::MatchType enum; the "traditional" matching algorithm is     chosen by using the NormalMatch match type (the default). It is also     possible to enable partial matching of the regular expression against a     subject string: see the \l{partial matching} section for more details.      The match options are a set of one or more QRegularExpression::MatchOption     values. They change the way a specific match of a regular expression     against a subject string is done. Please refer to the     QRegularExpression::MatchOption enum documentation for more details.      \target normal matching     \section1 Normal matching      In order to perform a match you can simply invoke the match() function     passing a string to match against. We refer to this string as the     \e{subject string}. The result of the match() function is a     QRegularExpressionMatch object that can be used to inspect the results of     the match. For instance:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 7      If a match is successful, the (implicit) capturing group number 0 can be     used to retrieve the substring matched by the entire pattern (see also the     section about \l{extracting captured substrings}):      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 8      It's also possible to start a match at an arbitrary offset inside the     subject string by passing the offset as an argument of the     match() function. In the following example \c{"12 abc"}     is not matched because the match is started at offset 1:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 9      \target extracting captured substrings     \section2 Extracting captured substrings      The QRegularExpressionMatch object contains also information about the     substrings captured by the capturing groups in the pattern string. The     \l{QRegularExpressionMatch::}{captured()} function will return the string     captured by the n-th capturing group:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 10      Capturing groups in the pattern are numbered starting from 1, and the     implicit capturing group 0 is used to capture the substring that matched     the entire pattern.      It's also possible to retrieve the starting and the ending offsets (inside     the subject string) of each captured substring, by using the     \l{QRegularExpressionMatch::}{capturedStart()} and the     \l{QRegularExpressionMatch::}{capturedEnd()} functions:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 11      All of these functions have an overload taking a QString as a parameter     in order to extract \e{named} captured substrings. For instance:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 12      \target global matching     \section1 Global matching      \e{Global matching} is useful to find all the occurrences of a given     regular expression inside a subject string. Suppose that we want to extract     all the words from a given string, where a word is a substring matching     the pattern \c{\w+}.      QRegularExpression::globalMatch returns a QRegularExpressionMatchIterator,     which is a Java-like forward iterator that can be used to iterate over the     results. For instance:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 13      Since it's a Java-like iterator, the QRegularExpressionMatchIterator will     point immediately before the first result. Every result is returned as a     QRegularExpressionMatch object. The     \l{QRegularExpressionMatchIterator::}{hasNext()} function will return true     if there's at least one more result, and     \l{QRegularExpressionMatchIterator::}{next()} will return the next result     and advance the iterator. Continuing from the previous example:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 14      You can also use \l{QRegularExpressionMatchIterator::}{peekNext()} to get     the next result without advancing the iterator.      It is possible to pass a starting offset and one or more match options to     the globalMatch() function, exactly like normal matching with match().      \target partial matching     \section1 Partial matching      A \e{partial match} is obtained when the end of the subject string is     reached, but more characters are needed to successfully complete the match.     Note that a partial match is usually much more inefficient than a normal     match because many optimizations of the matching algorithm cannot be     employed.      A partial match must be explicitly requested by specifying a match type of     PartialPreferCompleteMatch or PartialPreferFirstMatch when calling     QRegularExpression::match or QRegularExpression::globalMatch. If a partial     match is found, then calling the \l{QRegularExpressionMatch::}{hasMatch()}     function on the QRegularExpressionMatch object returned by match() will     return \c{false}, but \l{QRegularExpressionMatch::}{hasPartialMatch()} will return     \c{true}.      When a partial match is found, no captured substrings are returned, and the     (implicit) capturing group 0 corresponding to the whole match captures the     partially matched substring of the subject string.      Note that asking for a partial match can still lead to a complete match, if     one is found; in this case, \l{QRegularExpressionMatch::}{hasMatch()} will     return \c{true} and \l{QRegularExpressionMatch::}{hasPartialMatch()}     \c{false}. It never happens that a QRegularExpressionMatch reports both a     partial and a complete match.      Partial matching is mainly useful in two scenarios: validating user input     in real time and incremental/multi-segment matching.      \target     \section2 Validating user input      Suppose that we would like the user to input a date in a specific     format, for instance "MMM dd, yyyy". We can check the input validity with     a pattern like:      \c{^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \d\d?, \d\d\d\d$}      (This pattern doesn't catch invalid days, but let's keep it for the     example's purposes).      We would like to validate the input with this regular expression \e{while}     the user is typing it, so that we can report an error in the input as soon     as it is committed (for instance, the user typed the wrong key). In order     to do so we must distinguish three cases:      \list     \li the input cannot possibly match the regular expression;     \li the input does match the regular expression;     \li the input does not match the regular expression right now,     but it will if more charaters will be added to it.     \endlist      Note that these three cases represent exactly the possible states of a     QValidator (see the QValidator::State enum).      In particular, in the last case we want the regular expression engine to     report a partial match: we are successfully matching the pattern against     the subject string but the matching cannot continue because the end of the     subject is encountered. Notice, however, that the matching algorithm should     continue and try all possibilities, and in case a complete (non-partial)     match is found, then this one should be reported, and the input string     accepted as fully valid.      This behaviour is implemented by the PartialPreferCompleteMatch match type.     For instance:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 15      If matching the same regular expression against the subject string leads to     a complete match, it is reported as usual:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 16      Another example with a different pattern, showing the behaviour of     preferring a complete match over a partial one:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 17      In this case, the subpattern \c{abc\\w+X} partially matches the subject     string; however, the subpattern \c{def} matches the subject string     completely, and therefore a complete match is reported.      In case multiple partial matches are found when matching (but no complete     match), then the QRegularExpressionMatch will report the first one that it     is found. For instance:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 18      \section2 Incremental/multi-segment matching      Incremental matching is another use case of partial matching. Suppose that     we want to find the occurrences of a regular expression inside a large text     (that is, substrings matching the regular expression). In order to do so we     would like to "feed" the large text to the regular expression engines in     smaller chunks. The obvious problem is what happens if the substring that     matches the regular expression spans across two or more chunks.      In this case, the regular expression engine should report a partial match,     so that we can match again adding new data and (eventually) get a complete     match. This implies that the regular expression engine may assume that     there are other characters \e{beyond the end} of the subject string. This     is not to be taken literally -- the engine will never try to access     any character after the last one in the subject.      QRegularExpression implements this behaviour when using the     PartialPreferFirstMatch match type. This match type reports a partial match     as soon as it is found, and other match alternatives are not tried     (even if they could lead to a complete match). For instance:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 19      This happens because when matching the first branch of the alternation     operator a partial match is found, and therefore matching stops, without     trying the second branch. Another example:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 20      This shows what could seem a counterintuitve behaviour of quantifiers:     since \c{?} is greedy, then the engine tries first to continue the match     after having matched \c{"abc"}; but then the matching reaches the end of the     subject string, and therefore a partial match is reported. This is     even more surprising in the following example:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 21      It's easy to understand this behaviour if we remember that the engine     expects the subject string to be only a substring of the whole text we're     looking for a match into (that is, how we said before, that the engine     assumes that there are other characters beyond the end of the subject     string).      Since the \c{*} quantifier is greedy, then reporting a complete match could     be an error, because after the current subject \c{"abc"} there may be other     occurrences of \c{"abc"}. For instance, the complete text could have been     "abcabcX", and therefore the \e{right} match to report (in the complete     text) would have been \c{"abcabc"}; by matching only against the leading     \c{"abc"} we instead get a partial match.      \section1 Error handling      It is possible for a QRegularExpression object to be invalid because of     syntax errors in the pattern string. The isValid() function will return     true if the regular expression is valid, or false otherwise:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 22      You can get more information about the specific error by calling the     errorString() function; moreover, the patternErrorOffset() function     will return the offset inside the pattern string      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 23      If a match is attempted with an invalid QRegularExpression, then the     returned QRegularExpressionMatch object will be invalid as well (that is,     its \l{QRegularExpressionMatch::}{isValid()} function will return false).     The same applies for attempting a global match.      \section1 Unsupported Perl-compatible regular expressions features      QRegularExpression does not support all the features available in     Perl-compatible regular expressions. The most notable one is the fact that     duplicated names for capturing groups are not supported, and using them can     lead to undefined behaviour.      This may change in a future version of Qt.      \section1 Notes for QRegExp users      The QRegularExpression class introduced in Qt 5 is a big improvement upon     QRegExp, in terms of APIs offered, supported pattern syntax and speed of     execution. The biggest difference is that QRegularExpression simply holds a     regular expression, and it's \e{not} modified when a match is requested.     Instead, a QRegularExpressionMatch object is returned, in order to check     the result of a match and extract the captured substring. The same applies     with global matching and QRegularExpressionMatchIterator.      Other differences are outlined below.      \section2 Exact matching      QRegExp::exactMatch in Qt 4 served for two purposes: it exactly matched     a regular expression against a subject string, and it implemented partial     matching. In fact, if an exact match was not found, one could still find     out how much of the subject string was matched by the regular expression     by calling QRegExp::matchedLength(). If the returned length was equal     to the subject string's length, then one could desume that a partial match     was found.      QRegularExpression supports partial matching explicitly by means of the     appropriate MatchType. If instead you simply want to be sure that the     subject string matches the regular expression exactly, you can wrap the     pattern between a couple of anchoring expressions. Simply     putting the pattern between the \c{^} and the \c{$} anchors is enough     in most cases:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 24      However, remember that the \c{$} anchor not only matches at the end of the     string, but also at a newline character right before the end of the string;     that is, the previous pattern matches against the string "this pattern must     match exactly\n". Also, the behaviour of both the \c{^} and the \c{$}     anchors changes if the MultiLineOption is set either explicitely (as a     pattern option) or implicitly (as a directive inside the pattern string).      Therefore, in the most general case, you should wrap the pattern between     the \c{\A} and the \c{\z} anchors:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 25      Note the usage of the non-capturing group in order to preserve the meaning     of the branch operator inside the pattern.      \section2 Global matching      Due to limitations of the QRegExp API it was impossible to implement global     matching correctly (that is, like Perl does). In particular, patterns that     can match 0 characters (like \c{"a*"}) are problematic.      QRegularExpression::globalMatch implements Perl global match correctly, and     the returned iterator can be used to examine each result.      \section2 Wildcard matching      There is no equivalent of wildcard matching in QRegularExpression.     Nevertheless, rewriting a regular expression in wildcard syntax to a     Perl-compatible regular expression is a very easy task, given the fact     that wildcard syntax supported by QRegExp is very simple.      \section2 Other pattern syntaxes      QRegularExpression supports only Perl-compatible regular expressions.      \section2 Minimal matching      QRegExp::setMinimal implemented minimal matching by simply reversing the     greediness of the quantifiers (QRegExp did not support lazy quantifiers,     like \c{*?}, \c{+?}, etc.). QRegularExpression instead does support greedy,     lazy and possessive quantifiers. The InvertedGreedinessOption     pattern option can be useful to emulate the effects of QRegExp::setMinimal:     if enabled, it inverts the greediness of quantifiers (greedy ones become     lazy and vice versa).      \section2 Caret modes      The AnchoredMatchOption match option can be used to emulate the     QRegExp::CaretAtOffset behaviour. There is no equivalent for the other     QRegExp::CaretMode modes.      \section1 Debugging code that uses QRegularExpression      QRegularExpression internally uses a just in time compiler (JIT) to     optimize the execution of the matching algorithm. The JIT makes extensive     usage of self-modifying code, which can lead debugging tools such as     Valgrind to crash. You must enable all checks for self-modifying code if     you want to debug programs using QRegularExpression (f.i., see Valgrind's     \c{--smc-check} command line option). The downside of enabling such checks     is that your program will run considerably slower.      To avoid that, the JIT is disabled by default if you compile Qt in debug     mode. It is possible to override the default and enable or disable the JIT     usage (both in debug or release mode) by setting the     \c{QT_ENABLE_REGEXP_JIT} environment variable to a non-zero or zero value     respectively.      \sa QRegularExpressionMatch, QRegularExpressionMatchIterator */
comment|/*!     \class QRegularExpressionMatch     \reentrant      \brief The QRegularExpressionMatch class provides the results of a matching     a QRegularExpression against a string.      \since 5.0      \ingroup tools     \ingroup shared      \keyword regular expression match      A QRegularExpressionMatch object can be obtained by calling the     QRegularExpression::match() function, or as a single result of a global     match from a QRegularExpressionMatchIterator.      The success or the failure of a match attempt can be inspected by calling     the hasMatch() function. QRegularExpressionMatch also reports a successful     partial match through the hasPartialMatch() function.      In addition, QRegularExpressionMatch returns the substrings captured by the     capturing groups in the pattern string. The implicit capturing group with     index 0 captures the result of the whole match. The captured() function     returns each substring captured, either by the capturing group's index or     by its name:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 29      For each captured substring it is possible to query its starting and ending     offsets in the subject string by calling the capturedStart() and the     capturedEnd() function, respectively. The length of each captured     substring is available using the capturedLength() function.      The convenience function capturedTexts() will return \e{all} the captured     substrings at once (including the substring matched by the entire pattern)     in the order they have been captured by captring groups; that is,     \c{captured(i) == capturedTexts().at(i)}.      You can retrieve the QRegularExpression object the subject string was     matched against by calling the regularExpression() function; the     match type and the match options are available as well by calling     the matchType() and the matchOptions() respectively.      Please refer to the QRegularExpression documentation for more information     about the Qt regular expression classes.      \sa QRegularExpression */
comment|/*!     \class QRegularExpressionMatchIterator     \reentrant      \brief The QRegularExpressionMatchIterator class provides an iterator on     the results of a global match of a QRegularExpression object against a string.      \since 5.0      \ingroup tools     \ingroup shared      \keyword regular expression iterator      A QRegularExpressionMatchIterator object is a forward only Java-like     iterator; it can be obtained by calling the     QRegularExpression::globalMatch() function. A new     QRegularExpressionMatchIterator will be positioned before the first result.     You can then call the hasNext() function to check if there are more     results available; if so, the next() function will return the next     result and advance the iterator.      Each result is a QRegularExpressionMatch object holding all the information     for that result (including captured substrings).      For instance:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 30      Moreover, QRegularExpressionMatchIterator offers a peekNext() function     to get the next result \e{without} advancing the iterator.      You can retrieve the QRegularExpression object the subject string was     matched against by calling the regularExpression() function; the     match type and the match options are available as well by calling     the matchType() and the matchOptions() respectively.      Please refer to the QRegularExpression documentation for more information     about the Qt regular expression classes.      \sa QRegularExpression, QRegularExpressionMatch */
comment|/*!     \enum QRegularExpression::PatternOption      The PatternOption enum defines modifiers to the way the pattern string     should be interpreted, and therefore the way the pattern matches against a     subject string.      \value NoPatternOption         No pattern options are set.      \value CaseInsensitiveOption         The pattern should match against the subject string in a case         insensitive way. This option corresponds to the /i modifier in Perl         regular expressions.      \value DotMatchesEverythingOption         The dot metacharacter (\c{.}) in the pattern string is allowed to match         any character in the subject string, including newlines (normally, the         dot does not match newlines). This option corresponds to the \c{/s}         modifier in Perl regular expressions.      \value MultilineOption         The caret (\c{^}) and the dollar (\c{$}) metacharacters in the pattern         string are allowed to match, respectively, immediately after and         immediately before any newline in the subject string, as well as at the         very beginning and at the very end of the subject string. This option         corresponds to the \c{/m} modifier in Perl regular expressions.      \value ExtendedPatternSyntaxOption         Any whitespace in the pattern string which is not escaped and outside a         character class is ignored. Moreover, an unescaped sharp (\b{#})         outside a character class causes all the following characters, until         the first newline (included), to be ignored. This can be used to         increase the readability of a pattern string as well as put comments         inside regular expressions; this is particulary useful if the pattern         string is loaded from a file or written by the user, because in C++         code it is always possible to use the rules for string literals to put         comments outside the pattern string. This option corresponds to the \c{/x}         modifier in Perl regular expressions.      \value InvertedGreedinessOption         The greediness of the quantifiers is inverted: \c{*}, \c{+}, \c{?},         \c{{m,n}}, etc. become lazy, while their lazy versions (\c{*?},         \c{+?}, \c{??}, \c{{m,n}?}, etc.) become greedy. There is no equivalent         for this option in Perl regular expressions.      \value DontCaptureOption         The non-named capturing groups do not capture substrings; named         capturing groups still work as intended, as well as the implicit         capturing group number 0 corresponding to the entire match. There is no         equivalent for this option in Perl regular expressions.      \value UseUnicodePropertiesOption         The meaning of the \c{\w}, \c{\d}, etc., character types, as well as         the meaning of their counterparts (\c{\W}, \c{\D}, etc.), is changed         from matching ASCII charaters only to matching any character with the         corresponding Unicode property. For instance, \c{\d} is changed to         match any character with the Unicode Nd (decimal digit) property;         \c{\w} to match any character with either the Unicode L (letter) or N         (digit) property, plus underscore, and so on. This option corresponds         to the \c{/u} modifier in Perl regular expressions. */
comment|/*!     \enum QRegularExpression::MatchType      The MatchType enum defines the type of the match that should be attempted     against the subject string.      \value NormalMatch         A normal match is done.      \value PartialPreferCompleteMatch         The pattern string is matched partially against the subject string. If         a partial match is found, then it is recorded, and other matching         alternatives are tried as usual. If a complete match is then found,         then it's preferred to the partial match; in this case only the         complete match is reported. If instead no complete match is found (but         only the partial one), then the partial one is reported.      \value PartialPreferFirstMatch         The pattern string is matched partially against the subject string. If         a partial match is found, then matching stops and the partial match is         reported. In this case, other matching alternatives (potentially         leading to a complete match) are not tried. Moreover, this match type         assumes that the subject string only a substring of a larger text, and         that (in this text) there are other characters beyond the end of the         subject string. This can lead to surprising results; see the discussion         in the \l{partial matching} section for more details. */
comment|/*!     \enum QRegularExpression::MatchOption      \value NoMatchOption         No match options are set.      \value AnchoredMatchOption         The match is constrained to start exactly at the offset passed to         match() in order to be successful, even if the pattern string does not         contain any metacharacter that anchors the match at that point. */
comment|// after how many usages we optimize the regexp
ifdef|#
directive|ifdef
name|QT_BUILD_INTERNAL
DECL|variable|qt_qregularexpression_optimize_after_use_count
name|Q_AUTOTEST_EXPORT
name|unsigned
name|int
name|qt_qregularexpression_optimize_after_use_count
init|=
literal|10
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|qt_qregularexpression_optimize_after_use_count
init|=
literal|10
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BUILD_INTERNAL
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|convertToPcreOptions
specifier|static
name|int
name|convertToPcreOptions
parameter_list|(
name|QRegularExpression
operator|::
name|PatternOptions
name|patternOptions
parameter_list|)
block|{
name|int
name|options
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|CaseInsensitiveOption
condition|)
name|options
operator||=
name|PCRE_CASELESS
expr_stmt|;
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|DotMatchesEverythingOption
condition|)
name|options
operator||=
name|PCRE_DOTALL
expr_stmt|;
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|MultilineOption
condition|)
name|options
operator||=
name|PCRE_MULTILINE
expr_stmt|;
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|ExtendedPatternSyntaxOption
condition|)
name|options
operator||=
name|PCRE_EXTENDED
expr_stmt|;
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|InvertedGreedinessOption
condition|)
name|options
operator||=
name|PCRE_UNGREEDY
expr_stmt|;
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|DontCaptureOption
condition|)
name|options
operator||=
name|PCRE_NO_AUTO_CAPTURE
expr_stmt|;
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|UseUnicodePropertiesOption
condition|)
name|options
operator||=
name|PCRE_UCP
expr_stmt|;
return|return
name|options
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|convertToPcreOptions
specifier|static
name|int
name|convertToPcreOptions
parameter_list|(
name|QRegularExpression
operator|::
name|MatchOptions
name|matchOptions
parameter_list|)
block|{
name|int
name|options
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|matchOptions
operator|&
name|QRegularExpression
operator|::
name|AnchoredMatchOption
condition|)
name|options
operator||=
name|PCRE_ANCHORED
expr_stmt|;
return|return
name|options
return|;
block|}
end_function
begin_struct
DECL|struct|QRegularExpressionPrivate
struct|struct
name|QRegularExpressionPrivate
super|:
name|QSharedData
block|{
name|QRegularExpressionPrivate
parameter_list|()
constructor_decl|;
name|~
name|QRegularExpressionPrivate
parameter_list|()
destructor_decl|;
name|QRegularExpressionPrivate
parameter_list|(
specifier|const
name|QRegularExpressionPrivate
modifier|&
name|other
parameter_list|)
constructor_decl|;
name|void
name|cleanCompiledPattern
parameter_list|()
function_decl|;
name|void
name|compilePattern
parameter_list|()
function_decl|;
name|void
name|getPatternInfo
parameter_list|()
function_decl|;
name|pcre16_extra
modifier|*
name|optimizePattern
parameter_list|()
function_decl|;
name|QRegularExpressionMatchPrivate
modifier|*
name|doMatch
parameter_list|(
specifier|const
name|QString
modifier|&
name|subject
parameter_list|,
name|int
name|offset
parameter_list|,
name|QRegularExpression
operator|::
name|MatchType
name|matchType
parameter_list|,
name|QRegularExpression
operator|::
name|MatchOptions
name|matchOptions
parameter_list|,
specifier|const
name|QRegularExpressionMatchPrivate
modifier|*
name|previous
init|=
literal|0
parameter_list|)
specifier|const
function_decl|;
name|int
name|captureIndexForName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
function_decl|;
DECL|member|pattern
name|QString
name|pattern
decl_stmt|;
DECL|member|patternOptions
name|QRegularExpression
operator|::
name|PatternOptions
name|patternOptions
decl_stmt|;
comment|// *All* of the following members are set managed while holding this mutex,
comment|// except for isDirty which is set to true by QRegularExpression setters
comment|// (right after a detach happened).
comment|// On the other hand, after the compilation and studying,
comment|// it's safe to *use* (i.e. read) them from multiple threads at the same time.
comment|// Therefore, doMatch doesn't need to lock this mutex.
DECL|member|mutex
name|QMutex
name|mutex
decl_stmt|;
comment|// The PCRE pointers are reference-counted by the QRegularExpressionPrivate
comment|// objects themselves; when the private is copied (i.e. a detach happened)
comment|// they are set to 0
DECL|member|compiledPattern
name|pcre16
modifier|*
name|compiledPattern
decl_stmt|;
DECL|member|studyData
name|pcre16_extra
modifier|*
name|studyData
decl_stmt|;
DECL|member|errorString
specifier|const
name|char
modifier|*
name|errorString
decl_stmt|;
DECL|member|errorOffset
name|int
name|errorOffset
decl_stmt|;
DECL|member|capturingCount
name|int
name|capturingCount
decl_stmt|;
DECL|member|usedCount
name|unsigned
name|int
name|usedCount
decl_stmt|;
DECL|member|usingCrLfNewlines
name|bool
name|usingCrLfNewlines
decl_stmt|;
DECL|member|isDirty
name|bool
name|isDirty
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|QRegularExpressionMatchPrivate
struct|struct
name|QRegularExpressionMatchPrivate
super|:
name|QSharedData
block|{
name|QRegularExpressionMatchPrivate
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
specifier|const
name|QString
modifier|&
name|subject
parameter_list|,
name|QRegularExpression
operator|::
name|MatchType
name|matchType
parameter_list|,
name|QRegularExpression
operator|::
name|MatchOptions
name|matchOptions
parameter_list|,
name|int
name|capturingCount
parameter_list|)
constructor_decl|;
name|QRegularExpressionMatch
name|nextMatch
parameter_list|()
specifier|const
function_decl|;
DECL|member|regularExpression
specifier|const
name|QRegularExpression
name|regularExpression
decl_stmt|;
DECL|member|subject
specifier|const
name|QString
name|subject
decl_stmt|;
comment|// the capturedOffsets vector contains pairs of (start, end) positions
comment|// for each captured substring
DECL|member|capturedOffsets
name|QVector
argument_list|<
name|int
argument_list|>
name|capturedOffsets
decl_stmt|;
DECL|member|matchType
specifier|const
name|QRegularExpression
operator|::
name|MatchType
name|matchType
decl_stmt|;
DECL|member|matchOptions
specifier|const
name|QRegularExpression
operator|::
name|MatchOptions
name|matchOptions
decl_stmt|;
DECL|member|capturedCount
name|int
name|capturedCount
decl_stmt|;
DECL|member|hasMatch
name|bool
name|hasMatch
decl_stmt|;
DECL|member|hasPartialMatch
name|bool
name|hasPartialMatch
decl_stmt|;
DECL|member|isValid
name|bool
name|isValid
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|QRegularExpressionMatchIteratorPrivate
struct|struct
name|QRegularExpressionMatchIteratorPrivate
super|:
name|QSharedData
block|{
name|QRegularExpressionMatchIteratorPrivate
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
name|QRegularExpression
operator|::
name|MatchType
name|matchType
parameter_list|,
name|QRegularExpression
operator|::
name|MatchOptions
name|matchOptions
parameter_list|,
specifier|const
name|QRegularExpressionMatch
modifier|&
name|next
parameter_list|)
constructor_decl|;
name|bool
name|hasNext
parameter_list|()
specifier|const
function_decl|;
DECL|member|next
name|QRegularExpressionMatch
name|next
decl_stmt|;
DECL|member|regularExpression
specifier|const
name|QRegularExpression
name|regularExpression
decl_stmt|;
DECL|member|matchType
specifier|const
name|QRegularExpression
operator|::
name|MatchType
name|matchType
decl_stmt|;
DECL|member|matchOptions
specifier|const
name|QRegularExpression
operator|::
name|MatchOptions
name|matchOptions
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QRegularExpression
name|QRegularExpression
operator|::
name|QRegularExpression
parameter_list|(
name|QRegularExpressionPrivate
modifier|&
name|dd
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|&
name|dd
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QRegularExpressionPrivate
name|QRegularExpressionPrivate
operator|::
name|QRegularExpressionPrivate
parameter_list|()
member_init_list|:
name|pattern
argument_list|()
member_init_list|,
name|patternOptions
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mutex
argument_list|()
member_init_list|,
name|compiledPattern
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|studyData
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|errorString
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|errorOffset
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|capturingCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|usedCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|usingCrLfNewlines
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isDirty
argument_list|(
literal|true
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_destructor
DECL|function|~QRegularExpressionPrivate
name|QRegularExpressionPrivate
operator|::
name|~
name|QRegularExpressionPrivate
parameter_list|()
block|{
name|cleanCompiledPattern
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \internal      Copies the private, which means copying only the pattern and the pattern     options. The compiledPattern and the studyData pointers are NOT copied (we     do not own them any more), and in general all the members set when     compiling a pattern are set to default values. isDirty is set back to true     so that the pattern has to be recompiled again. */
end_comment
begin_constructor
DECL|function|QRegularExpressionPrivate
name|QRegularExpressionPrivate
operator|::
name|QRegularExpressionPrivate
parameter_list|(
specifier|const
name|QRegularExpressionPrivate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|QSharedData
argument_list|(
name|other
argument_list|)
member_init_list|,
name|pattern
argument_list|(
name|other
operator|.
name|pattern
argument_list|)
member_init_list|,
name|patternOptions
argument_list|(
name|other
operator|.
name|patternOptions
argument_list|)
member_init_list|,
name|mutex
argument_list|()
member_init_list|,
name|compiledPattern
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|studyData
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|errorString
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|errorOffset
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|capturingCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|usedCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|usingCrLfNewlines
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isDirty
argument_list|(
literal|true
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|cleanCompiledPattern
name|void
name|QRegularExpressionPrivate
operator|::
name|cleanCompiledPattern
parameter_list|()
block|{
name|pcre16_free
argument_list|(
name|compiledPattern
argument_list|)
expr_stmt|;
name|pcre16_free_study
argument_list|(
name|studyData
argument_list|)
expr_stmt|;
name|usedCount
operator|=
literal|0
expr_stmt|;
name|compiledPattern
operator|=
literal|0
expr_stmt|;
name|studyData
operator|=
literal|0
expr_stmt|;
name|usingCrLfNewlines
operator|=
literal|false
expr_stmt|;
name|errorOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|capturingCount
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|compilePattern
name|void
name|QRegularExpressionPrivate
operator|::
name|compilePattern
parameter_list|()
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isDirty
condition|)
return|return;
name|isDirty
operator|=
literal|false
expr_stmt|;
name|cleanCompiledPattern
argument_list|()
expr_stmt|;
name|int
name|options
init|=
name|convertToPcreOptions
argument_list|(
name|patternOptions
argument_list|)
decl_stmt|;
name|options
operator||=
name|PCRE_UTF16
expr_stmt|;
name|int
name|errorCode
decl_stmt|;
name|compiledPattern
operator|=
name|pcre16_compile2
argument_list|(
name|pattern
operator|.
name|utf16
argument_list|()
argument_list|,
name|options
argument_list|,
operator|&
name|errorCode
argument_list|,
operator|&
name|errorString
argument_list|,
operator|&
name|errorOffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compiledPattern
condition|)
return|return;
name|Q_ASSERT
argument_list|(
name|errorCode
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|studyData
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// studying (=>optimizing) is always done later
name|errorOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|getPatternInfo
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|getPatternInfo
name|void
name|QRegularExpressionPrivate
operator|::
name|getPatternInfo
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|compiledPattern
argument_list|)
expr_stmt|;
name|pcre16_fullinfo
argument_list|(
name|compiledPattern
argument_list|,
literal|0
argument_list|,
name|PCRE_INFO_CAPTURECOUNT
argument_list|,
operator|&
name|capturingCount
argument_list|)
expr_stmt|;
comment|// detect the settings for the newline
name|int
name|patternNewlineSetting
decl_stmt|;
name|pcre16_fullinfo
argument_list|(
name|compiledPattern
argument_list|,
name|studyData
argument_list|,
name|PCRE_INFO_OPTIONS
argument_list|,
operator|&
name|patternNewlineSetting
argument_list|)
expr_stmt|;
name|patternNewlineSetting
operator|&=
name|PCRE_NEWLINE_CR
operator||
name|PCRE_NEWLINE_LF
operator||
name|PCRE_NEWLINE_CRLF
operator||
name|PCRE_NEWLINE_ANY
operator||
name|PCRE_NEWLINE_ANYCRLF
expr_stmt|;
if|if
condition|(
name|patternNewlineSetting
operator|==
literal|0
condition|)
block|{
comment|// no option was specified in the regexp, grab PCRE build defaults
name|int
name|pcreNewlineSetting
decl_stmt|;
name|pcre16_config
argument_list|(
name|PCRE_CONFIG_NEWLINE
argument_list|,
operator|&
name|pcreNewlineSetting
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcreNewlineSetting
condition|)
block|{
case|case
literal|13
case|:
name|patternNewlineSetting
operator|=
name|PCRE_NEWLINE_CR
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|patternNewlineSetting
operator|=
name|PCRE_NEWLINE_LF
expr_stmt|;
break|break;
case|case
literal|3338
case|:
comment|// (13<<8 | 10)
name|patternNewlineSetting
operator|=
name|PCRE_NEWLINE_CRLF
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
name|patternNewlineSetting
operator|=
name|PCRE_NEWLINE_ANYCRLF
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|patternNewlineSetting
operator|=
name|PCRE_NEWLINE_ANY
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QRegularExpressionPrivate::compilePattern(): "
literal|"PCRE_CONFIG_NEWLINE returned an unknown newline"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|usingCrLfNewlines
operator|=
operator|(
name|patternNewlineSetting
operator|==
name|PCRE_NEWLINE_CRLF
operator|)
operator|||
operator|(
name|patternNewlineSetting
operator|==
name|PCRE_NEWLINE_ANY
operator|)
operator|||
operator|(
name|patternNewlineSetting
operator|==
name|PCRE_NEWLINE_ANYCRLF
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|isJitEnabled
specifier|static
name|bool
name|isJitEnabled
parameter_list|()
block|{
name|QByteArray
name|jitEnvironment
init|=
name|qgetenv
argument_list|(
literal|"QT_ENABLE_REGEXP_JIT"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|jitEnvironment
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bool
name|ok
decl_stmt|;
name|int
name|enableJit
init|=
name|jitEnvironment
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
return|return
name|ok
condition|?
operator|(
name|enableJit
operator|!=
literal|0
operator|)
else|:
literal|true
return|;
block|}
ifdef|#
directive|ifdef
name|QT_DEBUG
return|return
literal|false
return|;
else|#
directive|else
return|return
literal|true
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal      The purpose of the function is to call pcre16_study (which allows some     optimizations to be performed, including JIT-compiling the pattern), and     setting the studyData member variable to the result of the study. It gets     called by doMatch() every time a match is performed. As of now, the     optimizations on the pattern are performed after a certain number of usages     (i.e. the qt_qregularexpression_optimize_after_use_count constant).      Notice that although the method is protected by a mutex, one thread may     invoke this function and return immediately (i.e. not study the pattern,     leaving studyData to NULL); but before calling pcre16_exec to perform the     match, another thread performs the studying and sets studyData to something     else. Although the assignment to studyData is itself atomic, the release of     the memory pointed by studyData isn't. Therefore, the current studyData     value is returned and used by doMatch. */
end_comment
begin_function
DECL|function|optimizePattern
name|pcre16_extra
modifier|*
name|QRegularExpressionPrivate
operator|::
name|optimizePattern
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|compiledPattern
argument_list|)
expr_stmt|;
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|studyData
operator|||
operator|(
operator|++
name|usedCount
operator|!=
name|qt_qregularexpression_optimize_after_use_count
operator|)
condition|)
return|return
name|studyData
return|;
specifier|static
specifier|const
name|bool
name|enableJit
init|=
name|isJitEnabled
argument_list|()
decl_stmt|;
name|int
name|studyOptions
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|enableJit
condition|)
name|studyOptions
operator||=
name|PCRE_STUDY_JIT_COMPILE
expr_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|studyData
operator|=
name|pcre16_study
argument_list|(
name|compiledPattern
argument_list|,
name|studyOptions
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|studyData
operator|&&
name|err
condition|)
name|qWarning
argument_list|(
literal|"QRegularExpressionPrivate::optimizePattern(): pcre_study failed: %s"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|studyData
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the capturing group number for the given name. Duplicated names for     capturing groups are not supported. */
end_comment
begin_function
DECL|function|captureIndexForName
name|int
name|QRegularExpressionPrivate
operator|::
name|captureIndexForName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|pcre16_get_stringnumber
argument_list|(
name|compiledPattern
argument_list|,
name|name
operator|.
name|utf16
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
return|return
name|index
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Performs a match of type \a matchType on the given \a subject string with     options \a matchOptions and returns the QRegularExpressionMatchPrivate of     the result. It also advances a match if a previous result is given as \a     previous.      Advancing a match is a tricky algorithm. If the previous match matched a     non-empty string, we just do an ordinary match at the offset position.      If the previous match matched an empty string, then an anchored, non-empty     match is attempted at the offset position. If that succeeds, then we got     the next match and we can return it. Otherwise, we advance by 1 position     (which can be one or two code units in UTF-16!) and reattempt a "normal"     match. We also have the problem of detecting the current newline format: if     the new advanced offset is pointing to the beginning of a CRLF sequence, we     must advance over it. */
end_comment
begin_function
DECL|function|doMatch
name|QRegularExpressionMatchPrivate
modifier|*
name|QRegularExpressionPrivate
operator|::
name|doMatch
parameter_list|(
specifier|const
name|QString
modifier|&
name|subject
parameter_list|,
name|int
name|offset
parameter_list|,
name|QRegularExpression
operator|::
name|MatchType
name|matchType
parameter_list|,
name|QRegularExpression
operator|::
name|MatchOptions
name|matchOptions
parameter_list|,
specifier|const
name|QRegularExpressionMatchPrivate
modifier|*
name|previous
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|offset
operator|+=
name|subject
operator|.
name|length
argument_list|()
expr_stmt|;
name|QRegularExpression
name|re
argument_list|(
operator|*
cast|const_cast
argument_list|<
name|QRegularExpressionPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
argument_list|<
literal|0
operator|||
name|offset
argument_list|>
name|subject
operator|.
name|length
argument_list|()
condition|)
return|return
operator|new
name|QRegularExpressionMatchPrivate
argument_list|(
name|re
argument_list|,
name|subject
argument_list|,
name|matchType
argument_list|,
name|matchOptions
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
operator|!
name|compiledPattern
condition|)
block|{
name|qWarning
argument_list|(
literal|"QRegularExpressionPrivate::doMatch(): called on an invalid QRegularExpression object"
argument_list|)
expr_stmt|;
return|return
operator|new
name|QRegularExpressionMatchPrivate
argument_list|(
name|re
argument_list|,
name|subject
argument_list|,
name|matchType
argument_list|,
name|matchOptions
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|QRegularExpressionMatchPrivate
modifier|*
name|priv
init|=
operator|new
name|QRegularExpressionMatchPrivate
argument_list|(
name|re
argument_list|,
name|subject
argument_list|,
name|matchType
argument_list|,
name|matchOptions
argument_list|,
name|capturingCount
argument_list|)
decl_stmt|;
comment|// this is mutex protected
specifier|const
name|pcre16_extra
modifier|*
name|currentStudyData
init|=
cast|const_cast
argument_list|<
name|QRegularExpressionPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|optimizePattern
argument_list|()
decl_stmt|;
name|int
name|pcreOptions
init|=
name|convertToPcreOptions
argument_list|(
name|matchOptions
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchType
operator|==
name|QRegularExpression
operator|::
name|PartialPreferCompleteMatch
condition|)
name|pcreOptions
operator||=
name|PCRE_PARTIAL_SOFT
expr_stmt|;
elseif|else
if|if
condition|(
name|matchType
operator|==
name|QRegularExpression
operator|::
name|PartialPreferFirstMatch
condition|)
name|pcreOptions
operator||=
name|PCRE_PARTIAL_HARD
expr_stmt|;
name|bool
name|previousMatchWasEmpty
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|previous
operator|&&
name|previous
operator|->
name|hasMatch
operator|&&
operator|(
name|previous
operator|->
name|capturedOffsets
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|previous
operator|->
name|capturedOffsets
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
block|{
name|previousMatchWasEmpty
operator|=
literal|true
expr_stmt|;
block|}
name|int
modifier|*
specifier|const
name|captureOffsets
init|=
name|priv
operator|->
name|capturedOffsets
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|int
name|captureOffsetsCount
init|=
name|priv
operator|->
name|capturedOffsets
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|unsigned
name|short
modifier|*
specifier|const
name|subjectUtf16
init|=
name|subject
operator|.
name|utf16
argument_list|()
decl_stmt|;
specifier|const
name|int
name|subjectLength
init|=
name|subject
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|previousMatchWasEmpty
condition|)
block|{
name|result
operator|=
name|pcre16_exec
argument_list|(
name|compiledPattern
argument_list|,
name|currentStudyData
argument_list|,
name|subjectUtf16
argument_list|,
name|subjectLength
argument_list|,
name|offset
argument_list|,
name|pcreOptions
argument_list|,
name|captureOffsets
argument_list|,
name|captureOffsetsCount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|pcre16_exec
argument_list|(
name|compiledPattern
argument_list|,
name|currentStudyData
argument_list|,
name|subjectUtf16
argument_list|,
name|subjectLength
argument_list|,
name|offset
argument_list|,
name|pcreOptions
operator||
name|PCRE_NOTEMPTY_ATSTART
operator||
name|PCRE_ANCHORED
argument_list|,
name|captureOffsets
argument_list|,
name|captureOffsetsCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|PCRE_ERROR_NOMATCH
condition|)
block|{
operator|++
name|offset
expr_stmt|;
if|if
condition|(
name|usingCrLfNewlines
operator|&&
name|offset
operator|<
name|subjectLength
operator|&&
name|subjectUtf16
index|[
name|offset
operator|-
literal|1
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
operator|&&
name|subjectUtf16
index|[
name|offset
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
condition|)
block|{
operator|++
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|<
name|subjectLength
operator|&&
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|subjectUtf16
index|[
name|offset
index|]
argument_list|)
condition|)
block|{
operator|++
name|offset
expr_stmt|;
block|}
name|result
operator|=
name|pcre16_exec
argument_list|(
name|compiledPattern
argument_list|,
name|currentStudyData
argument_list|,
name|subjectUtf16
argument_list|,
name|subjectLength
argument_list|,
name|offset
argument_list|,
name|pcreOptions
argument_list|,
name|captureOffsets
argument_list|,
name|captureOffsetsCount
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|QREGULAREXPRESSION_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"Matching"
operator|<<
name|pattern
operator|<<
literal|"against"
operator|<<
name|subject
operator|<<
name|offset
operator|<<
name|matchType
operator|<<
name|matchOptions
operator|<<
name|previousMatchWasEmpty
operator|<<
literal|"result"
operator|<<
name|result
expr_stmt|;
endif|#
directive|endif
comment|// result == 0 means not enough space in captureOffsets; should never happen
name|Q_ASSERT
argument_list|(
name|result
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
comment|// full match
name|priv
operator|->
name|isValid
operator|=
literal|true
expr_stmt|;
name|priv
operator|->
name|hasMatch
operator|=
literal|true
expr_stmt|;
name|priv
operator|->
name|capturedCount
operator|=
name|result
expr_stmt|;
name|priv
operator|->
name|capturedOffsets
operator|.
name|resize
argument_list|(
name|result
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// no match, partial match or error
name|priv
operator|->
name|hasPartialMatch
operator|=
operator|(
name|result
operator|==
name|PCRE_ERROR_PARTIAL
operator|)
expr_stmt|;
name|priv
operator|->
name|isValid
operator|=
operator|(
name|result
operator|==
name|PCRE_ERROR_NOMATCH
operator|||
name|result
operator|==
name|PCRE_ERROR_PARTIAL
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|PCRE_ERROR_PARTIAL
condition|)
block|{
comment|// partial match:
comment|// leave the start and end capture offsets (i.e. cap(0))
name|priv
operator|->
name|capturedCount
operator|=
literal|1
expr_stmt|;
name|priv
operator|->
name|capturedOffsets
operator|.
name|resize
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// no match or error
name|priv
operator|->
name|capturedCount
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|capturedOffsets
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|priv
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QRegularExpressionMatchPrivate
name|QRegularExpressionMatchPrivate
operator|::
name|QRegularExpressionMatchPrivate
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
specifier|const
name|QString
modifier|&
name|subject
parameter_list|,
name|QRegularExpression
operator|::
name|MatchType
name|matchType
parameter_list|,
name|QRegularExpression
operator|::
name|MatchOptions
name|matchOptions
parameter_list|,
name|int
name|capturingCount
parameter_list|)
member_init_list|:
name|regularExpression
argument_list|(
name|re
argument_list|)
member_init_list|,
name|subject
argument_list|(
name|subject
argument_list|)
member_init_list|,
name|matchType
argument_list|(
name|matchType
argument_list|)
member_init_list|,
name|matchOptions
argument_list|(
name|matchOptions
argument_list|)
member_init_list|,
name|capturedCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|hasMatch
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|hasPartialMatch
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isValid
argument_list|(
literal|false
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|capturingCount
operator|>=
literal|0
argument_list|)
expr_stmt|;
specifier|const
name|int
name|captureOffsetsCount
init|=
operator|(
name|capturingCount
operator|+
literal|1
operator|)
operator|*
literal|3
decl_stmt|;
name|capturedOffsets
operator|.
name|resize
argument_list|(
name|captureOffsetsCount
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|nextMatch
name|QRegularExpressionMatch
name|QRegularExpressionMatchPrivate
operator|::
name|nextMatch
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|isValid
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|hasMatch
operator|||
name|hasPartialMatch
argument_list|)
expr_stmt|;
name|QRegularExpressionMatchPrivate
modifier|*
name|nextPrivate
init|=
name|regularExpression
operator|.
name|d
operator|->
name|doMatch
argument_list|(
name|subject
argument_list|,
name|capturedOffsets
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|,
name|matchType
argument_list|,
name|matchOptions
argument_list|,
name|this
argument_list|)
decl_stmt|;
return|return
name|QRegularExpressionMatch
argument_list|(
operator|*
name|nextPrivate
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QRegularExpressionMatchIteratorPrivate
name|QRegularExpressionMatchIteratorPrivate
operator|::
name|QRegularExpressionMatchIteratorPrivate
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
name|QRegularExpression
operator|::
name|MatchType
name|matchType
parameter_list|,
name|QRegularExpression
operator|::
name|MatchOptions
name|matchOptions
parameter_list|,
specifier|const
name|QRegularExpressionMatch
modifier|&
name|next
parameter_list|)
member_init_list|:
name|next
argument_list|(
name|next
argument_list|)
member_init_list|,
name|regularExpression
argument_list|(
name|re
argument_list|)
member_init_list|,
name|matchType
argument_list|(
name|matchType
argument_list|)
member_init_list|,
name|matchOptions
argument_list|(
name|matchOptions
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|hasNext
name|bool
name|QRegularExpressionMatchIteratorPrivate
operator|::
name|hasNext
parameter_list|()
specifier|const
block|{
return|return
name|next
operator|.
name|isValid
argument_list|()
operator|&&
operator|(
name|next
operator|.
name|hasMatch
argument_list|()
operator|||
name|next
operator|.
name|hasPartialMatch
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|// PUBLIC API
end_comment
begin_comment
comment|/*!     Constructs a QRegularExpression object with an empty pattern and no pattern     options.      \sa setPattern(), setPatternOptions() */
end_comment
begin_constructor
DECL|function|QRegularExpression
name|QRegularExpression
operator|::
name|QRegularExpression
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QRegularExpressionPrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QRegularExpression object using the given \a pattern as     pattern and the \a options as the pattern options.      \sa setPattern(), setPatternOptions() */
end_comment
begin_constructor
DECL|function|QRegularExpression
name|QRegularExpression
operator|::
name|QRegularExpression
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|,
name|PatternOptions
name|options
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QRegularExpressionPrivate
argument_list|)
block|{
name|d
operator|->
name|pattern
operator|=
name|pattern
expr_stmt|;
name|d
operator|->
name|patternOptions
operator|=
name|options
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QRegularExpression object as a copy of \a re.      \sa operator=() */
end_comment
begin_constructor
DECL|function|QRegularExpression
name|QRegularExpression
operator|::
name|QRegularExpression
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|re
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QRegularExpression object. */
end_comment
begin_destructor
DECL|function|~QRegularExpression
name|QRegularExpression
operator|::
name|~
name|QRegularExpression
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Assigns the regular expression \a re to this object, and returns a reference     to the copy. Both the pattern and the pattern options are copied. */
end_comment
begin_function
DECL|function|operator =
name|QRegularExpression
modifier|&
name|QRegularExpression
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|)
block|{
name|d
operator|=
name|re
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QRegularExpression::swap(QRegularExpression&other)      Swaps the regular expression \a other with this regular expression. This     operation is very fast and never fails. */
end_comment
begin_comment
comment|/*!     Returns the pattern string of the regular expression.      \sa setPattern(), patternOptions() */
end_comment
begin_function
DECL|function|pattern
name|QString
name|QRegularExpression
operator|::
name|pattern
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|pattern
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the pattern string of the regular expression to \a pattern. The     pattern options are left unchanged.      \sa pattern(), setPatternOptions() */
end_comment
begin_function
DECL|function|setPattern
name|void
name|QRegularExpression
operator|::
name|setPattern
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|)
block|{
name|d
operator|.
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|isDirty
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|pattern
operator|=
name|pattern
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the pattern options for the regular expression.      \sa setPatternOptions(), pattern() */
end_comment
begin_function
DECL|function|patternOptions
name|QRegularExpression
operator|::
name|PatternOptions
name|QRegularExpression
operator|::
name|patternOptions
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|patternOptions
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the given \a options as the pattern options of the regular expression.     The pattern string is left unchanged.      \sa patternOptions(), setPattern() */
end_comment
begin_function
DECL|function|setPatternOptions
name|void
name|QRegularExpression
operator|::
name|setPatternOptions
parameter_list|(
name|PatternOptions
name|options
parameter_list|)
block|{
name|d
operator|.
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|isDirty
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|patternOptions
operator|=
name|options
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of capturing groups inside the pattern string,     or -1 if the regular expression is not valid.      \sa isValid() */
end_comment
begin_function
DECL|function|captureCount
name|int
name|QRegularExpression
operator|::
name|captureCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
comment|// will compile the pattern
return|return
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|capturingCount
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the regular expression is a valid regular expression (that     is, it contains no syntax errors, etc.), or false otherwise. Use     errorString() to obtain a textual description of the error.      \sa errorString(), patternErrorOffset() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QRegularExpression
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|d
operator|.
name|data
argument_list|()
operator|->
name|compilePattern
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|compiledPattern
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a textual description of the error found when checking the validity     of the regular expression, or "no error" if no error was found.      \sa isValid(), patternErrorOffset() */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QRegularExpression
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
name|d
operator|.
name|data
argument_list|()
operator|->
name|compilePattern
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|errorString
condition|)
return|return
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QRegularExpression"
argument_list|,
name|d
operator|->
name|errorString
argument_list|,
literal|0
argument_list|,
name|QCoreApplication
operator|::
name|UnicodeUTF8
argument_list|)
return|;
return|return
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QRegularExpression"
argument_list|,
literal|"no error"
argument_list|,
literal|0
argument_list|,
name|QCoreApplication
operator|::
name|UnicodeUTF8
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the offset, inside the pattern string, at which an error was found     when checking the validity of the regular expression. If no error was     found, then -1 is returned.      \sa pattern(), isValid(), errorString() */
end_comment
begin_function
DECL|function|patternErrorOffset
name|int
name|QRegularExpression
operator|::
name|patternErrorOffset
parameter_list|()
specifier|const
block|{
name|d
operator|.
name|data
argument_list|()
operator|->
name|compilePattern
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|errorOffset
return|;
block|}
end_function
begin_comment
comment|/*!     Attempts to match the regular expression against the given \a subject     string, starting at the position \a offset inside the subject, using a     match of type \a matchType and honoring the given \a matchOptions.      The returned QRegularExpressionMatch object contains the results of the     match.      \sa QRegularExpressionMatch, {normal matching} */
end_comment
begin_function
DECL|function|match
name|QRegularExpressionMatch
name|QRegularExpression
operator|::
name|match
parameter_list|(
specifier|const
name|QString
modifier|&
name|subject
parameter_list|,
name|int
name|offset
parameter_list|,
name|MatchType
name|matchType
parameter_list|,
name|MatchOptions
name|matchOptions
parameter_list|)
specifier|const
block|{
name|d
operator|.
name|data
argument_list|()
operator|->
name|compilePattern
argument_list|()
expr_stmt|;
name|QRegularExpressionMatchPrivate
modifier|*
name|priv
init|=
name|d
operator|->
name|doMatch
argument_list|(
name|subject
argument_list|,
name|offset
argument_list|,
name|matchType
argument_list|,
name|matchOptions
argument_list|)
decl_stmt|;
return|return
name|QRegularExpressionMatch
argument_list|(
operator|*
name|priv
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Attempts to perform a global match of the regular expression against the     given \a subject string, starting at the position \a offset inside the     subject, using a match of type \a matchType and honoring the given \a     matchOptions.      The returned QRegularExpressionMatchIterator is positioned before the     first match result (if any).      \sa QRegularExpressionMatchIterator, {global matching} */
end_comment
begin_function
DECL|function|globalMatch
name|QRegularExpressionMatchIterator
name|QRegularExpression
operator|::
name|globalMatch
parameter_list|(
specifier|const
name|QString
modifier|&
name|subject
parameter_list|,
name|int
name|offset
parameter_list|,
name|MatchType
name|matchType
parameter_list|,
name|MatchOptions
name|matchOptions
parameter_list|)
specifier|const
block|{
name|QRegularExpressionMatchIteratorPrivate
modifier|*
name|priv
init|=
operator|new
name|QRegularExpressionMatchIteratorPrivate
argument_list|(
operator|*
name|this
argument_list|,
name|matchType
argument_list|,
name|matchOptions
argument_list|,
name|match
argument_list|(
name|subject
argument_list|,
name|offset
argument_list|,
name|matchType
argument_list|,
name|matchOptions
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|QRegularExpressionMatchIterator
argument_list|(
operator|*
name|priv
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the regular expression is equal to \a re, or false     otherwise. Two QRegularExpression objects are equal if they have     the same pattern string and the same pattern options.      \sa operator!=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QRegularExpression
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|d
operator|==
name|re
operator|.
name|d
operator|)
operator|||
operator|(
name|d
operator|->
name|pattern
operator|==
name|re
operator|.
name|d
operator|->
name|pattern
operator|&&
name|d
operator|->
name|patternOptions
operator|==
name|re
operator|.
name|d
operator|->
name|patternOptions
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QRegularExpression::operator!=(const QRegularExpression&re) const      Returns true if the regular expression is different from \a re, or     false otherwise.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Escapes all characters of \a str so that they no longer have any special     meaning when used as a regular expression pattern string, and returns     the escaped string. For instance:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 26      This is very convenient in order to build patterns from arbitrary strings:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 27      \note This function implements Perl's quotemeta algorithm and escapes with     a backslash all characters in \a str, except for the characters in the     \c{[A-Z]}, \c{[a-z]} and \c{[0-9]} ranges, as well as the underscore     (\c{_}) character. The only difference with Perl is that a literal NUL     inside \a str is escaped with the sequence \c{"\\\\0"} (backslash +     \c{'0'}), instead of \c{"\\\\\\0"} (backslash + \c{NUL}). */
end_comment
begin_function
DECL|function|escape
name|QString
name|QRegularExpression
operator|::
name|escape
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
specifier|const
name|int
name|count
init|=
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|count
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|// everything but [a-zA-Z0-9_] gets escaped,
comment|// cf. perldoc -f quotemeta
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QChar
name|current
init|=
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|==
name|QChar
operator|::
name|Null
condition|)
block|{
comment|// unlike Perl, a literal NUL must be escaped with
comment|// "\\0" (backslash + 0) and not "\\\0" (backslash + NUL),
comment|// because pcre16_compile uses a NUL-terminated string
name|result
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|current
argument_list|<
name|QLatin1Char
operator|(
literal|'a'
operator|)
operator|||
name|current
argument_list|>
name|QLatin1Char
argument_list|(
literal|'z'
argument_list|)
operator|)
operator|&&
operator|(
name|current
argument_list|<
name|QLatin1Char
operator|(
literal|'A'
operator|)
operator|||
name|current
argument_list|>
name|QLatin1Char
argument_list|(
literal|'Z'
argument_list|)
operator|)
operator|&&
operator|(
name|current
argument_list|<
name|QLatin1Char
operator|(
literal|'0'
operator|)
operator|||
name|current
argument_list|>
name|QLatin1Char
argument_list|(
literal|'9'
argument_list|)
operator|)
operator|&&
name|current
operator|!=
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|isHighSurrogate
argument_list|()
operator|&&
name|i
operator|<
operator|(
name|count
operator|-
literal|1
operator|)
condition|)
name|result
operator|.
name|append
argument_list|(
name|str
operator|.
name|at
argument_list|(
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|append
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|.
name|squeeze
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Destroys the match result. */
end_comment
begin_destructor
DECL|function|~QRegularExpressionMatch
name|QRegularExpressionMatch
operator|::
name|~
name|QRegularExpressionMatch
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Constructs a match result by copying the result of the given \a match.      \sa operator=() */
end_comment
begin_constructor
DECL|function|QRegularExpressionMatch
name|QRegularExpressionMatch
operator|::
name|QRegularExpressionMatch
parameter_list|(
specifier|const
name|QRegularExpressionMatch
modifier|&
name|match
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|match
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns the match result \a match to this object, and returns a reference     to the copy. */
end_comment
begin_function
DECL|function|operator =
name|QRegularExpressionMatch
modifier|&
name|QRegularExpressionMatch
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QRegularExpressionMatch
modifier|&
name|match
parameter_list|)
block|{
name|d
operator|=
name|match
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QRegularExpressionMatch::swap(QRegularExpressionMatch&other)      Swaps the match result \a other with this match result. This     operation is very fast and never fails. */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QRegularExpressionMatch
name|QRegularExpressionMatch
operator|::
name|QRegularExpressionMatch
parameter_list|(
name|QRegularExpressionMatchPrivate
modifier|&
name|dd
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|&
name|dd
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Returns the QRegularExpression object whose match() function returned this     object.      \sa QRegularExpression::match(), matchType(), matchOptions() */
end_comment
begin_function
DECL|function|regularExpression
name|QRegularExpression
name|QRegularExpressionMatch
operator|::
name|regularExpression
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|regularExpression
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the match type that was used to get this QRegularExpressionMatch     object, that is, the match type that was passed to     QRegularExpression::match() or QRegularExpression::globalMatch().      \sa QRegularExpression::match(), regularExpression(), matchOptions() */
end_comment
begin_function
DECL|function|matchType
name|QRegularExpression
operator|::
name|MatchType
name|QRegularExpressionMatch
operator|::
name|matchType
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|matchType
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the match options that were used to get this     QRegularExpressionMatch object, that is, the match options that were passed     to QRegularExpression::match() or QRegularExpression::globalMatch().      \sa QRegularExpression::match(), regularExpression(), matchType() */
end_comment
begin_function
DECL|function|matchOptions
name|QRegularExpression
operator|::
name|MatchOptions
name|QRegularExpressionMatch
operator|::
name|matchOptions
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|matchOptions
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the index of the last capturing group that captured something,     including the implicit capturing group 0. This can be used to extract all     the substrings that were captured:      \snippet doc/src/snippets/code/src_corelib_tools_qregularexpression.cpp 28      Note that some of the capturing groups with an index less than     lastCapturedIndex() could have not matched, and therefore captured nothing.      If the regular expression did not match, this function returns -1.      \sa captured(), capturedStart(), capturedEnd(), capturedLength() */
end_comment
begin_function
DECL|function|lastCapturedIndex
name|int
name|QRegularExpressionMatch
operator|::
name|lastCapturedIndex
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|capturedCount
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the substring captured by the \a nth capturing group. If the \a nth     capturing group did not capture a string or doesn't exist, returns a null     QString.      \sa capturedRef(), lastCapturedIndex(), capturedStart(), capturedEnd(),     capturedLength(), QString::isNull() */
end_comment
begin_function
DECL|function|captured
name|QString
name|QRegularExpressionMatch
operator|::
name|captured
parameter_list|(
name|int
name|nth
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|nth
argument_list|<
literal|0
operator|||
name|nth
argument_list|>
name|lastCapturedIndex
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|int
name|start
init|=
name|capturedStart
argument_list|(
name|nth
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|==
operator|-
literal|1
condition|)
comment|// didn't capture
return|return
name|QString
argument_list|()
return|;
return|return
name|d
operator|->
name|subject
operator|.
name|mid
argument_list|(
name|start
argument_list|,
name|capturedLength
argument_list|(
name|nth
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a reference to the substring captured by the \a nth capturing group.     If the \a nth capturing group did not capture a string or doesn't exist,     returns a null QStringRef.      \sa captured(), lastCapturedIndex(), capturedStart(), capturedEnd(),     capturedLength(), QStringRef::isNull() */
end_comment
begin_function
DECL|function|capturedRef
name|QStringRef
name|QRegularExpressionMatch
operator|::
name|capturedRef
parameter_list|(
name|int
name|nth
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|nth
argument_list|<
literal|0
operator|||
name|nth
argument_list|>
name|lastCapturedIndex
argument_list|()
condition|)
return|return
name|QStringRef
argument_list|()
return|;
name|int
name|start
init|=
name|capturedStart
argument_list|(
name|nth
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|==
operator|-
literal|1
condition|)
comment|// didn't capture
return|return
name|QStringRef
argument_list|()
return|;
return|return
name|d
operator|->
name|subject
operator|.
name|midRef
argument_list|(
name|start
argument_list|,
name|capturedLength
argument_list|(
name|nth
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the substring captured by the capturing group named \a name. If the     capturing group named \a name did not capture a string or doesn't exist,     returns a null QString.      \sa capturedRef(), capturedStart(), capturedEnd(), capturedLength(),     QString::isNull() */
end_comment
begin_function
DECL|function|captured
name|QString
name|QRegularExpressionMatch
operator|::
name|captured
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QRegularExpressionMatch::captured: empty capturing group name passed"
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|int
name|nth
init|=
name|d
operator|->
name|regularExpression
operator|.
name|d
operator|->
name|captureIndexForName
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|nth
operator|==
operator|-
literal|1
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|captured
argument_list|(
name|nth
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a reference to the string captured by the capturing group named \a     name. If the capturing group named \a name did not capture a string or     doesn't exist, returns a null QStringRef.      \sa captured(), capturedStart(), capturedEnd(), capturedLength(),     QStringRef::isNull() */
end_comment
begin_function
DECL|function|capturedRef
name|QStringRef
name|QRegularExpressionMatch
operator|::
name|capturedRef
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QRegularExpressionMatch::capturedRef: empty capturing group name passed"
argument_list|)
expr_stmt|;
return|return
name|QStringRef
argument_list|()
return|;
block|}
name|int
name|nth
init|=
name|d
operator|->
name|regularExpression
operator|.
name|d
operator|->
name|captureIndexForName
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|nth
operator|==
operator|-
literal|1
condition|)
return|return
name|QStringRef
argument_list|()
return|;
return|return
name|capturedRef
argument_list|(
name|nth
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all strings captured by capturing groups, in the order     the groups themselves appear in the pattern string. */
end_comment
begin_function
DECL|function|capturedTexts
name|QStringList
name|QRegularExpressionMatch
operator|::
name|capturedTexts
parameter_list|()
specifier|const
block|{
name|QStringList
name|texts
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|lastCapturedIndex
argument_list|()
condition|;
operator|++
name|i
control|)
name|texts
operator|<<
name|captured
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|texts
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the offset inside the subject string corresponding to the     starting position of the substring captured by the \a nth capturing group.     If the \a nth capturing group did not capture a string or doesn't exist,     returns -1.      \sa capturedEnd(), capturedLength(), captured() */
end_comment
begin_function
DECL|function|capturedStart
name|int
name|QRegularExpressionMatch
operator|::
name|capturedStart
parameter_list|(
name|int
name|nth
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|nth
argument_list|<
literal|0
operator|||
name|nth
argument_list|>
name|lastCapturedIndex
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|capturedOffsets
operator|.
name|at
argument_list|(
name|nth
operator|*
literal|2
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the length of the substring captured by the \a nth capturing group.      \note This function returns 0 if the \a nth capturing group did not capture     a string or doesn't exist.      \sa capturedStart(), capturedEnd(), captured() */
end_comment
begin_function
DECL|function|capturedLength
name|int
name|QRegularExpressionMatch
operator|::
name|capturedLength
parameter_list|(
name|int
name|nth
parameter_list|)
specifier|const
block|{
comment|// bound checking performed by these two functions
return|return
name|capturedEnd
argument_list|(
name|nth
argument_list|)
operator|-
name|capturedStart
argument_list|(
name|nth
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the offset inside the subject string immediately after the ending     position of the substring captured by the \a nth capturing group. If the \a     nth capturing group did not capture a string or doesn't exist, returns -1.      \sa capturedStart(), capturedLength(), captured() */
end_comment
begin_function
DECL|function|capturedEnd
name|int
name|QRegularExpressionMatch
operator|::
name|capturedEnd
parameter_list|(
name|int
name|nth
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|nth
argument_list|<
literal|0
operator|||
name|nth
argument_list|>
name|lastCapturedIndex
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|d
operator|->
name|capturedOffsets
operator|.
name|at
argument_list|(
name|nth
operator|*
literal|2
operator|+
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the offset inside the subject string corresponding to the starting     position of the substring captured by the capturing group named \a name.     If the capturing group named \a name did not capture a string or doesn't     exist, returns -1.      \sa capturedEnd(), capturedLength(), captured() */
end_comment
begin_function
DECL|function|capturedStart
name|int
name|QRegularExpressionMatch
operator|::
name|capturedStart
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QRegularExpressionMatch::capturedStart: empty capturing group name passed"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|int
name|nth
init|=
name|d
operator|->
name|regularExpression
operator|.
name|d
operator|->
name|captureIndexForName
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|nth
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|capturedStart
argument_list|(
name|nth
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the offset inside the subject string corresponding to the starting     position of the substring captured by the capturing group named \a name.      \note This function returns 0 if the capturing group named \a name did not     capture a string or doesn't exist.      \sa capturedStart(), capturedEnd(), captured() */
end_comment
begin_function
DECL|function|capturedLength
name|int
name|QRegularExpressionMatch
operator|::
name|capturedLength
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QRegularExpressionMatch::capturedLength: empty capturing group name passed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|nth
init|=
name|d
operator|->
name|regularExpression
operator|.
name|d
operator|->
name|captureIndexForName
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|nth
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
name|capturedLength
argument_list|(
name|nth
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the offset inside the subject string immediately after the ending     position of the substring captured by the capturing group named \a name. If     the capturing group named \a name did not capture a string or doesn't     exist, returns -1.      \sa capturedStart(), capturedLength(), captured() */
end_comment
begin_function
DECL|function|capturedEnd
name|int
name|QRegularExpressionMatch
operator|::
name|capturedEnd
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QRegularExpressionMatch::capturedEnd: empty capturing group name passed"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|int
name|nth
init|=
name|d
operator|->
name|regularExpression
operator|.
name|d
operator|->
name|captureIndexForName
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|nth
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|capturedEnd
argument_list|(
name|nth
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the regular expression matched against the subject string,     or false otherwise.      \sa QRegularExpression::match(), hasPartialMatch() */
end_comment
begin_function
DECL|function|hasMatch
name|bool
name|QRegularExpressionMatch
operator|::
name|hasMatch
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|hasMatch
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the regular expression partially matched against the     subject string, or false otherwise.      \note Only a match that explicitely used the one of the partial match types     can yield a partial match. Still, if such a match succeeds totally, this     function will return false, while hasMatch() will return true.      \sa QRegularExpression::match(), QRegularExpression::MatchType, hasMatch() */
end_comment
begin_function
DECL|function|hasPartialMatch
name|bool
name|QRegularExpressionMatch
operator|::
name|hasPartialMatch
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|hasPartialMatch
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the match object was obtained as a result from the     QRegularExpression::match() function invoked on a valid QRegularExpression     object; returns false if the QRegularExpression was invalid.      \sa QRegularExpression::match(), QRegularExpression::isValid() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QRegularExpressionMatch
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|isValid
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QRegularExpressionMatchIterator
name|QRegularExpressionMatchIterator
operator|::
name|QRegularExpressionMatchIterator
parameter_list|(
name|QRegularExpressionMatchIteratorPrivate
modifier|&
name|dd
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|&
name|dd
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QRegularExpressionMatchIterator object. */
end_comment
begin_destructor
DECL|function|~QRegularExpressionMatchIterator
name|QRegularExpressionMatchIterator
operator|::
name|~
name|QRegularExpressionMatchIterator
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Constructs a QRegularExpressionMatchIterator object as a copy of \a     iterator.      \sa operator=() */
end_comment
begin_constructor
DECL|function|QRegularExpressionMatchIterator
name|QRegularExpressionMatchIterator
operator|::
name|QRegularExpressionMatchIterator
parameter_list|(
specifier|const
name|QRegularExpressionMatchIterator
modifier|&
name|iterator
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|iterator
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Assigns the iterator \a iterator to this object, and returns a reference to     the copy. */
end_comment
begin_function
DECL|function|operator =
name|QRegularExpressionMatchIterator
modifier|&
name|QRegularExpressionMatchIterator
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QRegularExpressionMatchIterator
modifier|&
name|iterator
parameter_list|)
block|{
name|d
operator|=
name|iterator
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QRegularExpressionMatchIterator::swap(QRegularExpressionMatchIterator&other)      Swaps the iterator \a other with this iterator object. This operation is     very fast and never fails. */
end_comment
begin_comment
comment|/*!     Returns true if the iterator object was obtained as a result from the     QRegularExpression::globalMatch() function invoked on a valid     QRegularExpression object; returns false if the QRegularExpression was     invalid.      \sa QRegularExpression::globalMatch(), QRegularExpression::isValid() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QRegularExpressionMatchIterator
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|next
operator|.
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if there is at least one match result ahead of the iterator;     otherwise it returns false.      \sa next() */
end_comment
begin_function
DECL|function|hasNext
name|bool
name|QRegularExpressionMatchIterator
operator|::
name|hasNext
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|hasNext
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the next match result without moving the iterator.      \note Calling this function when the iterator is at the end of the result     set leads to undefined results. */
end_comment
begin_function
DECL|function|peekNext
name|QRegularExpressionMatch
name|QRegularExpressionMatchIterator
operator|::
name|peekNext
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QRegularExpressionMatchIterator::peekNext() called on an iterator already at end"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|next
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the next match result and advances the iterator by one position.      \note Calling this function when the iterator is at the end of the result     set leads to undefined results. */
end_comment
begin_function
DECL|function|next
name|QRegularExpressionMatch
name|QRegularExpressionMatchIterator
operator|::
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QRegularExpressionMatchIterator::next() called on an iterator already at end"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|next
return|;
block|}
name|QRegularExpressionMatch
name|current
init|=
name|d
operator|->
name|next
decl_stmt|;
name|d
operator|->
name|next
operator|=
name|d
operator|->
name|next
operator|.
name|d
operator|.
name|constData
argument_list|()
operator|->
name|nextMatch
argument_list|()
expr_stmt|;
return|return
name|current
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the QRegularExpression object whose globalMatch() function returned     this object.      \sa QRegularExpression::globalMatch(), matchType(), matchOptions() */
end_comment
begin_function
DECL|function|regularExpression
name|QRegularExpression
name|QRegularExpressionMatchIterator
operator|::
name|regularExpression
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|regularExpression
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the match type that was used to get this     QRegularExpressionMatchIterator object, that is, the match type that was     passed to QRegularExpression::globalMatch().      \sa QRegularExpression::globalMatch(), regularExpression(), matchOptions() */
end_comment
begin_function
DECL|function|matchType
name|QRegularExpression
operator|::
name|MatchType
name|QRegularExpressionMatchIterator
operator|::
name|matchType
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|matchType
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the match options that were used to get this     QRegularExpressionMatchIterator object, that is, the match options that     were passed to QRegularExpression::globalMatch().      \sa QRegularExpression::globalMatch(), regularExpression(), matchType() */
end_comment
begin_function
DECL|function|matchOptions
name|QRegularExpression
operator|::
name|MatchOptions
name|QRegularExpressionMatchIterator
operator|::
name|matchOptions
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|matchOptions
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \relates QRegularExpression      Writes the regular expression \a re to stream \a out.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|)
block|{
name|out
operator|<<
name|re
operator|.
name|pattern
argument_list|()
operator|<<
name|quint32
argument_list|(
name|re
operator|.
name|patternOptions
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QRegularExpression      Reads a regular expression from stream \a in into \a re.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QRegularExpression
modifier|&
name|re
parameter_list|)
block|{
name|QString
name|pattern
decl_stmt|;
name|quint32
name|patternOptions
decl_stmt|;
name|in
operator|>>
name|pattern
operator|>>
name|patternOptions
expr_stmt|;
name|re
operator|.
name|setPattern
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|re
operator|.
name|setPatternOptions
argument_list|(
name|QRegularExpression
operator|::
name|PatternOptions
argument_list|(
name|patternOptions
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_comment
comment|/*!     \relates QRegularExpression      Writes the regular expression \a re into the debug object \a debug for     debugging purposes.      \sa {Debugging Techniques} */
end_comment
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|)
block|{
name|debug
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QRegularExpression("
operator|<<
name|re
operator|.
name|pattern
argument_list|()
operator|<<
literal|", "
operator|<<
name|re
operator|.
name|patternOptions
argument_list|()
operator|<<
literal|")"
expr_stmt|;
return|return
name|debug
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QRegularExpression      Writes the pattern options \a patternOptions into the debug object \a debug     for debugging purposes.      \sa {Debugging Techniques} */
end_comment
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QRegularExpression
operator|::
name|PatternOptions
name|patternOptions
parameter_list|)
block|{
name|QStringList
name|flags
decl_stmt|;
if|if
condition|(
name|patternOptions
operator|==
name|QRegularExpression
operator|::
name|NoPatternOption
condition|)
block|{
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"NoPatternOption"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|CaseInsensitiveOption
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"CaseInsensitiveOption"
argument_list|)
expr_stmt|;
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|DotMatchesEverythingOption
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"DotMatchesEverythingOption"
argument_list|)
expr_stmt|;
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|MultilineOption
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"MultilineOption"
argument_list|)
expr_stmt|;
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|ExtendedPatternSyntaxOption
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"ExtendedPatternSyntaxOption"
argument_list|)
expr_stmt|;
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|InvertedGreedinessOption
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"InvertedGreedinessOption"
argument_list|)
expr_stmt|;
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|DontCaptureOption
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"DontCaptureOption"
argument_list|)
expr_stmt|;
if|if
condition|(
name|patternOptions
operator|&
name|QRegularExpression
operator|::
name|UseUnicodePropertiesOption
condition|)
name|flags
operator|<<
name|QLatin1String
argument_list|(
literal|"UseUnicodePropertiesOption"
argument_list|)
expr_stmt|;
block|}
name|debug
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QRegularExpression::PatternOptions("
operator|<<
name|qPrintable
argument_list|(
name|flags
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|"|"
argument_list|)
argument_list|)
argument_list|)
operator|<<
literal|")"
expr_stmt|;
return|return
name|debug
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QRegularExpressionMatch      Writes the match object \a match into the debug object \a debug for     debugging purposes.      \sa {Debugging Techniques} */
end_comment
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
specifier|const
name|QRegularExpressionMatch
modifier|&
name|match
parameter_list|)
block|{
name|debug
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QRegularExpressionMatch("
expr_stmt|;
if|if
condition|(
operator|!
name|match
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|debug
operator|<<
literal|"Invalid)"
expr_stmt|;
return|return
name|debug
operator|.
name|space
argument_list|()
return|;
block|}
name|debug
operator|<<
literal|"Valid"
expr_stmt|;
if|if
condition|(
name|match
operator|.
name|hasMatch
argument_list|()
condition|)
block|{
name|debug
operator|<<
literal|", has match: "
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|match
operator|.
name|lastCapturedIndex
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|debug
operator|<<
name|i
operator|<<
literal|":("
operator|<<
name|match
operator|.
name|capturedStart
argument_list|(
name|i
argument_list|)
operator|<<
literal|", "
operator|<<
name|match
operator|.
name|capturedEnd
argument_list|(
name|i
argument_list|)
operator|<<
literal|", "
operator|<<
name|match
operator|.
name|captured
argument_list|(
name|i
argument_list|)
operator|<<
literal|")"
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|match
operator|.
name|lastCapturedIndex
argument_list|()
condition|)
name|debug
operator|<<
literal|", "
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|match
operator|.
name|hasPartialMatch
argument_list|()
condition|)
block|{
name|debug
operator|<<
literal|", has partial match: ("
operator|<<
name|match
operator|.
name|capturedStart
argument_list|(
literal|0
argument_list|)
operator|<<
literal|", "
operator|<<
name|match
operator|.
name|capturedEnd
argument_list|(
literal|0
argument_list|)
operator|<<
literal|", "
operator|<<
name|match
operator|.
name|captured
argument_list|(
literal|0
argument_list|)
operator|<<
literal|")"
expr_stmt|;
block|}
else|else
block|{
name|debug
operator|<<
literal|", no match"
expr_stmt|;
block|}
name|debug
operator|<<
literal|")"
expr_stmt|;
return|return
name|debug
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
