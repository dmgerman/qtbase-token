begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qbytearray.h"
end_include
begin_include
include|#
directive|include
file|"qbytearraymatcher.h"
end_include
begin_include
include|#
directive|include
file|"qtools_p.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qlocale.h"
end_include
begin_include
include|#
directive|include
file|"qlocale_p.h"
end_include
begin_include
include|#
directive|include
file|"qscopedpointer.h"
end_include
begin_include
include|#
directive|include
file|<qdatastream.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
end_ifndef
begin_include
include|#
directive|include
file|<zlib.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_define
DECL|macro|IS_RAW_DATA
define|#
directive|define
name|IS_RAW_DATA
parameter_list|(
name|d
parameter_list|)
value|((d)->offset != sizeof(QByteArrayData))
end_define
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|int
name|qFindByteArray
parameter_list|(
specifier|const
name|char
modifier|*
name|haystack0
parameter_list|,
name|int
name|haystackLen
parameter_list|,
name|int
name|from
parameter_list|,
specifier|const
name|char
modifier|*
name|needle0
parameter_list|,
name|int
name|needleLen
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|qAllocMore
name|int
name|qAllocMore
parameter_list|(
name|int
name|alloc
parameter_list|,
name|int
name|extra
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|alloc
operator|>=
literal|0
operator|&&
name|extra
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
name|alloc
operator|<
operator|(
literal|1
operator|<<
literal|30
operator|)
operator|-
name|extra
argument_list|,
literal|"qAllocMore"
argument_list|,
literal|"Requested size is too large!"
argument_list|)
expr_stmt|;
name|unsigned
name|nalloc
init|=
name|alloc
operator|+
name|extra
decl_stmt|;
comment|// Round up to next power of 2
comment|// Assuming container is growing, always overshoot
comment|//--nalloc;
name|nalloc
operator||=
name|nalloc
operator|>>
literal|1
expr_stmt|;
name|nalloc
operator||=
name|nalloc
operator|>>
literal|2
expr_stmt|;
name|nalloc
operator||=
name|nalloc
operator|>>
literal|4
expr_stmt|;
name|nalloc
operator||=
name|nalloc
operator|>>
literal|8
expr_stmt|;
name|nalloc
operator||=
name|nalloc
operator|>>
literal|16
expr_stmt|;
operator|++
name|nalloc
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|nalloc
operator|>
name|unsigned
argument_list|(
name|alloc
operator|+
name|extra
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|nalloc
operator|-
name|extra
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   Safe and portable C string functions; extensions to standard string.h  *****************************************************************************/
end_comment
begin_comment
comment|/*! \relates QByteArray      Returns a duplicate string.      Allocates space for a copy of \a src, copies it, and returns a     pointer to the copy. If \a src is 0, it immediately returns 0.      Ownership is passed to the caller, so the returned string must be     deleted using \c delete[]. */
end_comment
begin_function
DECL|function|qstrdup
name|char
modifier|*
name|qstrdup
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
if|if
condition|(
operator|!
name|src
condition|)
return|return
literal|0
return|;
name|char
modifier|*
name|dst
init|=
operator|new
name|char
index|[
name|strlen
argument_list|(
name|src
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
return|return
name|qstrcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \relates QByteArray      Copies all the characters up to and including the '\\0' from \a     src into \a dst and returns a pointer to \a dst. If \a src is 0,     it immediately returns 0.      This function assumes that \a dst is large enough to hold the     contents of \a src.      \sa qstrncpy() */
end_comment
begin_function
DECL|function|qstrcpy
name|char
modifier|*
name|qstrcpy
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
if|if
condition|(
operator|!
name|src
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
specifier|const
name|int
name|len
init|=
name|int
argument_list|(
name|strlen
argument_list|(
name|src
argument_list|)
argument_list|)
decl_stmt|;
comment|// This is actually not secure!!! It will be fixed
comment|// properly in a later release!
if|if
condition|(
name|len
operator|>=
literal|0
operator|&&
name|strcpy_s
argument_list|(
name|dst
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|src
argument_list|)
operator|==
literal|0
condition|)
return|return
name|dst
return|;
return|return
literal|0
return|;
else|#
directive|else
return|return
name|strcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*! \relates QByteArray      A safe \c strncpy() function.      Copies at most \a len bytes from \a src (stopping at \a len or the     terminating '\\0' whichever comes first) into \a dst and returns a     pointer to \a dst. Guarantees that \a dst is '\\0'-terminated. If     \a src or \a dst is 0, returns 0 immediately.      This function assumes that \a dst is at least \a len characters     long.      \note When compiling with Visual C++ compiler version 14.00     (Visual C++ 2005) or later, internally the function strncpy_s     will be used.      \sa qstrcpy() */
end_comment
begin_function
DECL|function|qstrncpy
name|char
modifier|*
name|qstrncpy
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|src
operator|||
operator|!
name|dst
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
name|strncpy_s
argument_list|(
name|dst
argument_list|,
name|len
argument_list|,
name|src
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|strncpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|dst
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function
begin_comment
comment|/*! \fn uint qstrlen(const char *str)     \relates QByteArray      A safe \c strlen() function.      Returns the number of characters that precede the terminating '\\0',     or 0 if \a str is 0.      \sa qstrnlen() */
end_comment
begin_comment
comment|/*! \fn uint qstrnlen(const char *str, uint maxlen)     \relates QByteArray     \since 4.2      A safe \c strnlen() function.      Returns the number of characters that precede the terminating '\\0', but     at most \a maxlen. If \a str is 0, returns 0.      \sa qstrlen() */
end_comment
begin_comment
comment|/*!     \relates QByteArray      A safe \c strcmp() function.      Compares \a str1 and \a str2. Returns a negative value if \a str1     is less than \a str2, 0 if \a str1 is equal to \a str2 or a     positive value if \a str1 is greater than \a str2.      Special case 1: Returns 0 if \a str1 and \a str2 are both 0.      Special case 2: Returns an arbitrary non-zero value if \a str1 is 0     or \a str2 is 0 (but not both).      \sa qstrncmp(), qstricmp(), qstrnicmp(), {8-bit Character Comparisons} */
end_comment
begin_function
DECL|function|qstrcmp
name|int
name|qstrcmp
parameter_list|(
specifier|const
name|char
modifier|*
name|str1
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|)
block|{
return|return
operator|(
name|str1
operator|&&
name|str2
operator|)
condition|?
name|strcmp
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
else|:
operator|(
name|str1
condition|?
literal|1
else|:
operator|(
name|str2
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn int qstrncmp(const char *str1, const char *str2, uint len);      \relates QByteArray      A safe \c strncmp() function.      Compares at most \a len bytes of \a str1 and \a str2.      Returns a negative value if \a str1 is less than \a str2, 0 if \a     str1 is equal to \a str2 or a positive value if \a str1 is greater     than \a str2.      Special case 1: Returns 0 if \a str1 and \a str2 are both 0.      Special case 2: Returns a random non-zero value if \a str1 is 0     or \a str2 is 0 (but not both).      \sa qstrcmp(), qstricmp(), qstrnicmp(), {8-bit Character Comparisons} */
end_comment
begin_comment
comment|/*! \relates QByteArray      A safe \c stricmp() function.      Compares \a str1 and \a str2 ignoring the case of the     characters. The encoding of the strings is assumed to be Latin-1.      Returns a negative value if \a str1 is less than \a str2, 0 if \a     str1 is equal to \a str2 or a positive value if \a str1 is greater     than \a str2.      Special case 1: Returns 0 if \a str1 and \a str2 are both 0.      Special case 2: Returns a random non-zero value if \a str1 is 0     or \a str2 is 0 (but not both).      \sa qstrcmp(), qstrncmp(), qstrnicmp(), {8-bit Character Comparisons} */
end_comment
begin_function
DECL|function|qstricmp
name|int
name|qstricmp
parameter_list|(
specifier|const
name|char
modifier|*
name|str1
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|)
block|{
specifier|const
name|uchar
modifier|*
name|s1
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|str1
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|s2
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|str2
argument_list|)
decl_stmt|;
name|int
name|res
decl_stmt|;
name|uchar
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|s1
operator|||
operator|!
name|s2
condition|)
return|return
name|s1
condition|?
literal|1
else|:
operator|(
name|s2
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
for|for
control|(
init|;
operator|!
operator|(
name|res
operator|=
operator|(
name|c
operator|=
name|QChar
operator|::
name|toLower
argument_list|(
operator|(
name|ushort
operator|)
operator|*
name|s1
argument_list|)
operator|)
operator|-
name|QChar
operator|::
name|toLower
argument_list|(
operator|(
name|ushort
operator|)
operator|*
name|s2
argument_list|)
operator|)
condition|;
name|s1
operator|++
operator|,
name|s2
operator|++
control|)
if|if
condition|(
operator|!
name|c
condition|)
comment|// strings are equal
break|break;
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*! \relates QByteArray      A safe \c strnicmp() function.      Compares at most \a len bytes of \a str1 and \a str2 ignoring the     case of the characters. The encoding of the strings is assumed to     be Latin-1.      Returns a negative value if \a str1 is less than \a str2, 0 if \a str1     is equal to \a str2 or a positive value if \a str1 is greater than \a     str2.      Special case 1: Returns 0 if \a str1 and \a str2 are both 0.      Special case 2: Returns a random non-zero value if \a str1 is 0     or \a str2 is 0 (but not both).      \sa qstrcmp(), qstrncmp(), qstricmp(), {8-bit Character Comparisons} */
end_comment
begin_function
DECL|function|qstrnicmp
name|int
name|qstrnicmp
parameter_list|(
specifier|const
name|char
modifier|*
name|str1
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
specifier|const
name|uchar
modifier|*
name|s1
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|str1
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|s2
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|str2
argument_list|)
decl_stmt|;
name|int
name|res
decl_stmt|;
name|uchar
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|s1
operator|||
operator|!
name|s2
condition|)
return|return
name|s1
condition|?
literal|1
else|:
operator|(
name|s2
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
for|for
control|(
init|;
name|len
operator|--
condition|;
name|s1
operator|++
operator|,
name|s2
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
operator|(
name|c
operator|=
name|QChar
operator|::
name|toLower
argument_list|(
operator|(
name|ushort
operator|)
operator|*
name|s1
argument_list|)
operator|)
operator|-
name|QChar
operator|::
name|toLower
argument_list|(
operator|(
name|ushort
operator|)
operator|*
name|s2
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
operator|!
name|c
condition|)
comment|// strings are equal
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|qstrcmp
name|int
name|qstrcmp
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|str1
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|str2
condition|)
return|return
name|str1
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
operator|+
literal|1
return|;
specifier|const
name|char
modifier|*
name|str1data
init|=
name|str1
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|str1end
init|=
name|str1data
operator|+
name|str1
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|str1data
operator|<
name|str1end
operator|&&
operator|*
name|str2
condition|;
operator|++
name|str1data
operator|,
operator|++
name|str2
control|)
block|{
name|int
name|diff
init|=
name|int
argument_list|(
name|uchar
argument_list|(
operator|*
name|str1data
argument_list|)
argument_list|)
operator|-
name|uchar
argument_list|(
operator|*
name|str2
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
condition|)
comment|// found a difference
return|return
name|diff
return|;
block|}
comment|// Why did we stop?
if|if
condition|(
operator|*
name|str2
operator|!=
literal|'\0'
condition|)
comment|// not the null, so we stopped because str1 is shorter
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|str1data
operator|<
name|str1end
condition|)
comment|// we haven't reached the end, so str1 must be longer
return|return
operator|+
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|qstrcmp
name|int
name|qstrcmp
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|str1
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|str2
parameter_list|)
block|{
name|int
name|l1
init|=
name|str1
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|l2
init|=
name|str2
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
name|memcmp
argument_list|(
name|str1
operator|.
name|constData
argument_list|()
argument_list|,
name|str2
operator|.
name|constData
argument_list|()
argument_list|,
name|qMin
argument_list|(
name|l1
argument_list|,
name|l2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
comment|// they matched qMin(l1, l2) bytes
comment|// so the longer one is lexically after the shorter one
return|return
name|l1
operator|-
name|l2
return|;
block|}
end_function
begin_comment
comment|// the CRC table below is created by the following piece of code
end_comment
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
unit|static void createCRC16Table()
comment|// build CRC16 lookup table
end_comment
begin_undef
unit|{     unsigned int i;     unsigned int j;     unsigned short crc_tbl[16];     unsigned int v0, v1, v2, v3;     for (i = 0; i< 16; i++) {         v0 = i& 1;         v1 = (i>> 1)& 1;         v2 = (i>> 2)& 1;         v3 = (i>> 3)& 1;         j = 0;
undef|#
directive|undef
name|SET_BIT
end_undef
begin_define
define|#
directive|define
name|SET_BIT
parameter_list|(
name|x
parameter_list|,
name|b
parameter_list|,
name|v
parameter_list|)
value|(x) |= (v)<< (b)
end_define
begin_endif
unit|SET_BIT(j,  0, v0);         SET_BIT(j,  7, v0);         SET_BIT(j, 12, v0);         SET_BIT(j,  1, v1);         SET_BIT(j,  8, v1);         SET_BIT(j, 13, v1);         SET_BIT(j,  2, v2);         SET_BIT(j,  9, v2);         SET_BIT(j, 14, v2);         SET_BIT(j,  3, v3);         SET_BIT(j, 10, v3);         SET_BIT(j, 15, v3);         crc_tbl[i] = j;     }     printf("static const quint16 crc_tbl[16] = {\n");     for (int i = 0; i< 16; i +=4)         printf("    0x%04x, 0x%04x, 0x%04x, 0x%04x,\n", crc_tbl[i], crc_tbl[i+1], crc_tbl[i+2], crc_tbl[i+3]);     printf("};\n"); }
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|crc_tbl
specifier|static
specifier|const
name|quint16
name|crc_tbl
index|[
literal|16
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x1081
block|,
literal|0x2102
block|,
literal|0x3183
block|,
literal|0x4204
block|,
literal|0x5285
block|,
literal|0x6306
block|,
literal|0x7387
block|,
literal|0x8408
block|,
literal|0x9489
block|,
literal|0xa50a
block|,
literal|0xb58b
block|,
literal|0xc60c
block|,
literal|0xd68d
block|,
literal|0xe70e
block|,
literal|0xf78f
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     \relates QByteArray      Returns the CRC-16 checksum of the first \a len bytes of \a data.      The checksum is independent of the byte order (endianness).      \note This function is a 16-bit cache conserving (16 entry table)     implementation of the CRC-16-CCITT algorithm. */
end_comment
begin_function
DECL|function|qChecksum
name|quint16
name|qChecksum
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
name|quint16
name|crc
init|=
literal|0xffff
decl_stmt|;
name|uchar
name|c
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|p
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|crc
operator|=
operator|(
operator|(
name|crc
operator|>>
literal|4
operator|)
operator|&
literal|0x0fff
operator|)
operator|^
name|crc_tbl
index|[
operator|(
operator|(
name|crc
operator|^
name|c
operator|)
operator|&
literal|15
operator|)
index|]
expr_stmt|;
name|c
operator|>>=
literal|4
expr_stmt|;
name|crc
operator|=
operator|(
operator|(
name|crc
operator|>>
literal|4
operator|)
operator|&
literal|0x0fff
operator|)
operator|^
name|crc_tbl
index|[
operator|(
operator|(
name|crc
operator|^
name|c
operator|)
operator|&
literal|15
operator|)
index|]
expr_stmt|;
block|}
return|return
operator|~
name|crc
operator|&
literal|0xffff
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray qCompress(const QByteArray& data, int compressionLevel)      \relates QByteArray      Compresses the \a data byte array and returns the compressed data     in a new byte array.      The \a compressionLevel parameter specifies how much compression     should be used. Valid values are between 0 and 9, with 9     corresponding to the greatest compression (i.e. smaller compressed     data) at the cost of using a slower algorithm. Smaller values (8,     7, ..., 1) provide successively less compression at slightly     faster speeds. The value 0 corresponds to no compression at all.     The default value is -1, which specifies zlib's default     compression.      \sa qUncompress() */
end_comment
begin_comment
comment|/*! \relates QByteArray      \overload      Compresses the first \a nbytes of \a data and returns the     compressed data in a new byte array. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
end_ifndef
begin_function
DECL|function|qCompress
name|QByteArray
name|qCompress
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
block|{
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
return|return
name|QByteArray
argument_list|(
literal|4
argument_list|,
literal|'\0'
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|qWarning
argument_list|(
literal|"qCompress: Data is null"
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
if|if
condition|(
name|compressionLevel
argument_list|<
operator|-
literal|1
operator|||
name|compressionLevel
argument_list|>
literal|9
condition|)
name|compressionLevel
operator|=
operator|-
literal|1
expr_stmt|;
name|ulong
name|len
init|=
name|nbytes
operator|+
name|nbytes
operator|/
literal|100
operator|+
literal|13
decl_stmt|;
name|QByteArray
name|bazip
decl_stmt|;
name|int
name|res
decl_stmt|;
do|do
block|{
name|bazip
operator|.
name|resize
argument_list|(
name|len
operator|+
literal|4
argument_list|)
expr_stmt|;
name|res
operator|=
operator|::
name|compress2
argument_list|(
operator|(
name|uchar
operator|*
operator|)
name|bazip
operator|.
name|data
argument_list|()
operator|+
literal|4
argument_list|,
operator|&
name|len
argument_list|,
operator|(
name|uchar
operator|*
operator|)
name|data
argument_list|,
name|nbytes
argument_list|,
name|compressionLevel
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|Z_OK
case|:
name|bazip
operator|.
name|resize
argument_list|(
name|len
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bazip
index|[
literal|0
index|]
operator|=
operator|(
name|nbytes
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
expr_stmt|;
name|bazip
index|[
literal|1
index|]
operator|=
operator|(
name|nbytes
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|bazip
index|[
literal|2
index|]
operator|=
operator|(
name|nbytes
operator|&
literal|0x0000ff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|bazip
index|[
literal|3
index|]
operator|=
operator|(
name|nbytes
operator|&
literal|0x000000ff
operator|)
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
name|qWarning
argument_list|(
literal|"qCompress: Z_MEM_ERROR: Not enough memory"
argument_list|)
expr_stmt|;
name|bazip
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_BUF_ERROR
case|:
name|len
operator|*=
literal|2
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|res
operator|==
name|Z_BUF_ERROR
condition|)
do|;
return|return
name|bazip
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn QByteArray qUncompress(const QByteArray&data)      \relates QByteArray      Uncompresses the \a data byte array and returns a new byte array     with the uncompressed data.      Returns an empty QByteArray if the input data was corrupt.      This function will uncompress data compressed with qCompress()     from this and any earlier Qt version, back to Qt 3.1 when this     feature was added.      \b{Note:} If you want to use this function to uncompress external     data that was compressed using zlib, you first need to prepend a four     byte header to the byte array containing the data. The header must     contain the expected length (in bytes) of the uncompressed data,     expressed as an unsigned, big-endian, 32-bit integer.      \sa qCompress() */
end_comment
begin_comment
comment|/*! \relates QByteArray      \overload      Uncompresses the first \a nbytes of \a data and returns a new byte     array with the uncompressed data. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
end_ifndef
begin_function
DECL|function|qUncompress
name|QByteArray
name|qUncompress
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|qWarning
argument_list|(
literal|"qUncompress: Data is null"
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
if|if
condition|(
name|nbytes
operator|<=
literal|4
condition|)
block|{
if|if
condition|(
name|nbytes
operator|<
literal|4
operator|||
operator|(
name|data
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|data
index|[
literal|1
index|]
operator|!=
literal|0
operator|||
name|data
index|[
literal|2
index|]
operator|!=
literal|0
operator|||
name|data
index|[
literal|3
index|]
operator|!=
literal|0
operator|)
condition|)
name|qWarning
argument_list|(
literal|"qUncompress: Input data is corrupted"
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
name|ulong
name|expectedSize
init|=
operator|(
name|data
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|data
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|data
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|data
index|[
literal|3
index|]
operator|)
decl_stmt|;
name|ulong
name|len
init|=
name|qMax
argument_list|(
name|expectedSize
argument_list|,
literal|1ul
argument_list|)
decl_stmt|;
name|QScopedPointer
argument_list|<
name|QByteArray
operator|::
name|Data
argument_list|,
name|QScopedPointerPodDeleter
argument_list|>
name|d
decl_stmt|;
forever|forever
block|{
name|ulong
name|alloc
init|=
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|>=
operator|(
literal|1u
operator|<<
literal|31u
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|QByteArray
operator|::
name|Data
argument_list|)
condition|)
block|{
comment|//QByteArray does not support that huge size anyway.
name|qWarning
argument_list|(
literal|"qUncompress: Input data is corrupted"
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
name|QByteArray
operator|::
name|Data
modifier|*
name|p
init|=
cast|static_cast
argument_list|<
name|QByteArray
operator|::
name|Data
operator|*
argument_list|>
argument_list|(
operator|::
name|realloc
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|QByteArray
operator|::
name|Data
argument_list|)
operator|+
name|alloc
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
comment|// we are not allowed to crash here when compiling with QT_NO_EXCEPTIONS
name|qWarning
argument_list|(
literal|"qUncompress: could not allocate enough memory to uncompress data"
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
name|d
operator|.
name|take
argument_list|()
expr_stmt|;
comment|// realloc was successful
name|d
operator|.
name|reset
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|d
operator|->
name|offset
operator|=
sizeof|sizeof
argument_list|(
name|QByteArrayData
argument_list|)
expr_stmt|;
name|int
name|res
init|=
operator|::
name|uncompress
argument_list|(
operator|(
name|uchar
operator|*
operator|)
name|d
operator|->
name|data
argument_list|()
argument_list|,
operator|&
name|len
argument_list|,
operator|(
name|uchar
operator|*
operator|)
name|data
operator|+
literal|4
argument_list|,
name|nbytes
operator|-
literal|4
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|Z_OK
case|:
if|if
condition|(
name|len
operator|!=
name|alloc
condition|)
block|{
if|if
condition|(
name|len
operator|>=
operator|(
literal|1u
operator|<<
literal|31u
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|QByteArray
operator|::
name|Data
argument_list|)
condition|)
block|{
comment|//QByteArray does not support that huge size anyway.
name|qWarning
argument_list|(
literal|"qUncompress: Input data is corrupted"
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
name|QByteArray
operator|::
name|Data
modifier|*
name|p
init|=
cast|static_cast
argument_list|<
name|QByteArray
operator|::
name|Data
operator|*
argument_list|>
argument_list|(
operator|::
name|realloc
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|QByteArray
operator|::
name|Data
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
comment|// we are not allowed to crash here when compiling with QT_NO_EXCEPTIONS
name|qWarning
argument_list|(
literal|"qUncompress: could not allocate enough memory to uncompress data"
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
name|d
operator|.
name|take
argument_list|()
expr_stmt|;
comment|// realloc was successful
name|d
operator|.
name|reset
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|ref
operator|.
name|initializeOwned
argument_list|()
expr_stmt|;
name|d
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|d
operator|->
name|alloc
operator|=
name|uint
argument_list|(
name|len
argument_list|)
operator|+
literal|1u
expr_stmt|;
name|d
operator|->
name|capacityReserved
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|offset
operator|=
sizeof|sizeof
argument_list|(
name|QByteArrayData
argument_list|)
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|{
name|QByteArrayDataPtr
name|dataPtr
init|=
block|{
name|d
operator|.
name|take
argument_list|()
block|}
decl_stmt|;
return|return
name|QByteArray
argument_list|(
name|dataPtr
argument_list|)
return|;
block|}
case|case
name|Z_MEM_ERROR
case|:
name|qWarning
argument_list|(
literal|"qUncompress: Z_MEM_ERROR: Not enough memory"
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
case|case
name|Z_BUF_ERROR
case|:
name|len
operator|*=
literal|2
expr_stmt|;
continue|continue;
case|case
name|Z_DATA_ERROR
case|:
name|qWarning
argument_list|(
literal|"qUncompress: Z_DATA_ERROR: Input data is corrupted"
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qIsUpper
specifier|static
specifier|inline
name|bool
name|qIsUpper
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
return|;
block|}
end_function
begin_function
DECL|function|qToLower
specifier|static
specifier|inline
name|char
name|qToLower
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
return|return
name|c
operator|-
literal|'A'
operator|+
literal|'a'
return|;
else|else
return|return
name|c
return|;
block|}
end_function
begin_comment
comment|/*!     \class QByteArray     \inmodule QtCore     \brief The QByteArray class provides an array of bytes.      \ingroup tools     \ingroup shared     \ingroup string-processing      \reentrant      QByteArray can be used to store both raw bytes (including '\\0's)     and traditional 8-bit '\\0'-terminated strings. Using QByteArray     is much more convenient than using \c{const char *}. Behind the     scenes, it always ensures that the data is followed by a '\\0'     terminator, and uses \l{implicit sharing} (copy-on-write) to     reduce memory usage and avoid needless copying of data.      In addition to QByteArray, Qt also provides the QString class to     store string data. For most purposes, QString is the class you     want to use. It stores 16-bit Unicode characters, making it easy     to store non-ASCII/non-Latin-1 characters in your application.     Furthermore, QString is used throughout in the Qt API. The two     main cases where QByteArray is appropriate are when you need to     store raw binary data, and when memory conservation is critical     (e.g., with Qt for Embedded Linux).      One way to initialize a QByteArray is simply to pass a \c{const     char *} to its constructor. For example, the following code     creates a byte array of size 5 containing the data "Hello":      \snippet code/src_corelib_tools_qbytearray.cpp 0      Although the size() is 5, the byte array also maintains an extra     '\\0' character at the end so that if a function is used that     asks for a pointer to the underlying data (e.g. a call to     data()), the data pointed to is guaranteed to be     '\\0'-terminated.      QByteArray makes a deep copy of the \c{const char *} data, so you     can modify it later without experiencing side effects. (If for     performance reasons you don't want to take a deep copy of the     character data, use QByteArray::fromRawData() instead.)      Another approach is to set the size of the array using resize()     and to initialize the data byte per byte. QByteArray uses 0-based     indexes, just like C++ arrays. To access the byte at a particular     index position, you can use operator[](). On non-const byte     arrays, operator[]() returns a reference to a byte that can be     used on the left side of an assignment. For example:      \snippet code/src_corelib_tools_qbytearray.cpp 1      For read-only access, an alternative syntax is to use at():      \snippet code/src_corelib_tools_qbytearray.cpp 2      at() can be faster than operator[](), because it never causes a     \l{deep copy} to occur.      To extract many bytes at a time, use left(), right(), or mid().      A QByteArray can embed '\\0' bytes. The size() function always     returns the size of the whole array, including embedded '\\0'     bytes, but excluding the terminating '\\0' added by QByteArray.     For example:      \snippet code/src_corelib_tools_qbytearray.cpp 48      If you want to obtain the length of the data up to and     excluding the first '\\0' character, call qstrlen() on the byte     array.      After a call to resize(), newly allocated bytes have undefined     values. To set all the bytes to a particular value, call fill().      To obtain a pointer to the actual character data, call data() or     constData(). These functions return a pointer to the beginning of the data.     The pointer is guaranteed to remain valid until a non-const function is     called on the QByteArray. It is also guaranteed that the data ends with a     '\\0' byte unless the QByteArray was created from a \l{fromRawData()}{raw     data}. This '\\0' byte is automatically provided by QByteArray and is not     counted in size().      QByteArray provides the following basic functions for modifying     the byte data: append(), prepend(), insert(), replace(), and     remove(). For example:      \snippet code/src_corelib_tools_qbytearray.cpp 3      The replace() and remove() functions' first two arguments are the     position from which to start erasing and the number of bytes that     should be erased.      When you append() data to a non-empty array, the array will be     reallocated and the new data copied to it. You can avoid this     behavior by calling reserve(), which preallocates a certain amount     of memory. You can also call capacity() to find out how much     memory QByteArray actually allocated. Data appended to an empty     array is not copied.      A frequent requirement is to remove whitespace characters from a     byte array ('\\n', '\\t', ' ', etc.). If you want to remove     whitespace from both ends of a QByteArray, use trimmed(). If you     want to remove whitespace from both ends and replace multiple     consecutive whitespaces with a single space character within the     byte array, use simplified().      If you want to find all occurrences of a particular character or     substring in a QByteArray, use indexOf() or lastIndexOf(). The     former searches forward starting from a given index position, the     latter searches backward. Both return the index position of the     character or substring if they find it; otherwise, they return -1.     For example, here's a typical loop that finds all occurrences of a     particular substring:      \snippet code/src_corelib_tools_qbytearray.cpp 4      If you simply want to check whether a QByteArray contains a     particular character or substring, use contains(). If you want to     find out how many times a particular character or substring     occurs in the byte array, use count(). If you want to replace all     occurrences of a particular value with another, use one of the     two-parameter replace() overloads.      QByteArrays can be compared using overloaded operators such as     operator<(), operator<=(), operator==(), operator>=(), and so on.     The comparison is based exclusively on the numeric values     of the characters and is very fast, but is not what a human would     expect. QString::localeAwareCompare() is a better choice for     sorting user-interface strings.      For historical reasons, QByteArray distinguishes between a null     byte array and an empty byte array. A \e null byte array is a     byte array that is initialized using QByteArray's default     constructor or by passing (const char *)0 to the constructor. An     \e empty byte array is any byte array with size 0. A null byte     array is always empty, but an empty byte array isn't necessarily     null:      \snippet code/src_corelib_tools_qbytearray.cpp 5      All functions except isNull() treat null byte arrays the same as     empty byte arrays. For example, data() returns a pointer to a     '\\0' character for a null byte array (\e not a null pointer),     and QByteArray() compares equal to QByteArray(""). We recommend     that you always use isEmpty() and avoid isNull().      \section1 Notes on Locale      \section2 Number-String Conversions      Functions that perform conversions between numeric data types and     strings are performed in the C locale, irrespective of the user's     locale settings. Use QString to perform locale-aware conversions     between numbers and strings.      \section2 8-bit Character Comparisons      In QByteArray, the notion of uppercase and lowercase and of which     character is greater than or less than another character is     locale dependent. This affects functions that support a case     insensitive option or that compare or lowercase or uppercase     their arguments. Case insensitive operations and comparisons will     be accurate if both strings contain only ASCII characters. (If \c     $LC_CTYPE is set, most Unix systems do "the right thing".)     Functions that this affects include contains(), indexOf(),     lastIndexOf(), operator<(), operator<=(), operator>(),     operator>=(), toLower() and toUpper().      This issue does not apply to QStrings since they represent     characters using Unicode.      \sa QString, QBitArray */
end_comment
begin_comment
comment|/*! \fn QByteArray::iterator QByteArray::begin()      \internal */
end_comment
begin_comment
comment|/*! \fn QByteArray::const_iterator QByteArray::begin() const      \internal */
end_comment
begin_comment
comment|/*! \fn QByteArray::const_iterator QByteArray::cbegin() const     \since 5.0      \internal */
end_comment
begin_comment
comment|/*! \fn QByteArray::const_iterator QByteArray::constBegin() const      \internal */
end_comment
begin_comment
comment|/*! \fn QByteArray::iterator QByteArray::end()      \internal */
end_comment
begin_comment
comment|/*! \fn QByteArray::const_iterator QByteArray::end() const      \internal */
end_comment
begin_comment
comment|/*! \fn QByteArray::const_iterator QByteArray::cend() const     \since 5.0      \internal */
end_comment
begin_comment
comment|/*! \fn QByteArray::const_iterator QByteArray::constEnd() const      \internal */
end_comment
begin_comment
comment|/*! \fn void QByteArray::push_back(const QByteArray&other)      This function is provided for STL compatibility. It is equivalent     to append(\a other). */
end_comment
begin_comment
comment|/*! \fn void QByteArray::push_back(const char *str)      \overload      Same as append(\a str). */
end_comment
begin_comment
comment|/*! \fn void QByteArray::push_back(char ch)      \overload      Same as append(\a ch). */
end_comment
begin_comment
comment|/*! \fn void QByteArray::push_front(const QByteArray&other)      This function is provided for STL compatibility. It is equivalent     to prepend(\a other). */
end_comment
begin_comment
comment|/*! \fn void QByteArray::push_front(const char *str)      \overload      Same as prepend(\a str). */
end_comment
begin_comment
comment|/*! \fn void QByteArray::push_front(char ch)      \overload      Same as prepend(\a ch). */
end_comment
begin_comment
comment|/*! \fn QByteArray::QByteArray(const QByteArray&other)      Constructs a copy of \a other.      This operation takes \l{constant time}, because QByteArray is     \l{implicitly shared}. This makes returning a QByteArray from a     function very fast. If a shared instance is modified, it will be     copied (copy-on-write), taking \l{linear time}.      \sa operator=() */
end_comment
begin_comment
comment|/*! \fn QByteArray::QByteArray(QByteArrayDataPtr dd)      \internal      Constructs a byte array pointing to the same data as \a dd. */
end_comment
begin_comment
comment|/*! \fn QByteArray::~QByteArray()     Destroys the byte array. */
end_comment
begin_comment
comment|/*!     Assigns \a other to this byte array and returns a reference to     this byte array. */
end_comment
begin_function
DECL|function|operator =
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|other
parameter_list|)
block|{
name|other
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|Data
operator|::
name|deallocate
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Assigns \a str to this byte array. */
end_comment
begin_function
DECL|function|operator =
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|Data
modifier|*
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
block|{
name|x
operator|=
name|Data
operator|::
name|sharedNull
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|str
condition|)
block|{
name|x
operator|=
name|Data
operator|::
name|allocate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|len
init|=
name|int
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|uint
name|fullLen
init|=
name|len
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|fullLen
operator|>
name|d
operator|->
name|alloc
operator|||
operator|(
name|len
operator|<
name|d
operator|->
name|size
operator|&&
name|fullLen
operator|<
name|uint
argument_list|(
name|d
operator|->
name|alloc
operator|>>
literal|1
argument_list|)
operator|)
condition|)
name|reallocData
argument_list|(
name|fullLen
argument_list|,
name|d
operator|->
name|detachFlags
argument_list|()
argument_list|)
expr_stmt|;
name|x
operator|=
name|d
expr_stmt|;
name|memcpy
argument_list|(
name|x
operator|->
name|data
argument_list|()
argument_list|,
name|str
argument_list|,
name|fullLen
argument_list|)
expr_stmt|;
comment|// include null terminator
name|x
operator|->
name|size
operator|=
name|len
expr_stmt|;
block|}
name|x
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|Data
operator|::
name|deallocate
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*! \fn void QByteArray::swap(QByteArray&other)     \since 4.8      Swaps byte array \a other with this byte array. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*! \fn int QByteArray::size() const      Returns the number of bytes in this byte array.      The last byte in the byte array is at position size() - 1. In addition,     QByteArray ensures that the byte at position size() is always '\\0', so     that you can use the return value of data() and constData() as arguments to     functions that expect '\\0'-terminated strings. If the QByteArray object     was created from a \l{fromRawData()}{raw data} that didn't include the     trailing null-termination character then QByteArray doesn't add it     automaticall unless the \l{deep copy} is created.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 6      \sa isEmpty(), resize() */
end_comment
begin_comment
comment|/*! \fn bool QByteArray::isEmpty() const      Returns true if the byte array has size 0; otherwise returns false.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 7      \sa size() */
end_comment
begin_comment
comment|/*! \fn int QByteArray::capacity() const      Returns the maximum number of bytes that can be stored in the     byte array without forcing a reallocation.      The sole purpose of this function is to provide a means of fine     tuning QByteArray's memory usage. In general, you will rarely     ever need to call this function. If you want to know how many     bytes are in the byte array, call size().      \sa reserve(), squeeze() */
end_comment
begin_comment
comment|/*! \fn void QByteArray::reserve(int size)      Attempts to allocate memory for at least \a size bytes. If you     know in advance how large the byte array will be, you can call     this function, and if you call resize() often you are likely to     get better performance. If \a size is an underestimate, the worst     that will happen is that the QByteArray will be a bit slower.      The sole purpose of this function is to provide a means of fine     tuning QByteArray's memory usage. In general, you will rarely     ever need to call this function. If you want to change the size     of the byte array, call resize().      \sa squeeze(), capacity() */
end_comment
begin_comment
comment|/*! \fn void QByteArray::squeeze()      Releases any memory not required to store the array's data.      The sole purpose of this function is to provide a means of fine     tuning QByteArray's memory usage. In general, you will rarely     ever need to call this function.      \sa reserve(), capacity() */
end_comment
begin_comment
comment|/*! \fn QByteArray::operator const char *() const     \fn QByteArray::operator const void *() const      \obsolete Use constData() instead.      Returns a pointer to the data stored in the byte array. The     pointer can be used to access the bytes that compose the array.     The data is '\\0'-terminated. The pointer remains valid as long     as the array isn't reallocated or destroyed.      This operator is mostly useful to pass a byte array to a function     that accepts a \c{const char *}.      You can disable this operator by defining \c     QT_NO_CAST_FROM_BYTEARRAY when you compile your applications.      Note: A QByteArray can store any byte values including '\\0's,     but most functions that take \c{char *} arguments assume that the     data ends at the first '\\0' they encounter.      \sa constData() */
end_comment
begin_comment
comment|/*!   \macro QT_NO_CAST_FROM_BYTEARRAY   \relates QByteArray    Disables automatic conversions from QByteArray to   const char * or const void *.    \sa QT_NO_CAST_TO_ASCII, QT_NO_CAST_FROM_ASCII */
end_comment
begin_comment
comment|/*! \fn char *QByteArray::data()      Returns a pointer to the data stored in the byte array. The     pointer can be used to access and modify the bytes that compose     the array. The data is '\\0'-terminated, i.e. the number of     bytes in the returned character string is size() + 1 for the     '\\0' terminator.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 8      The pointer remains valid as long as the byte array isn't     reallocated or destroyed. For read-only access, constData() is     faster because it never causes a \l{deep copy} to occur.      This function is mostly useful to pass a byte array to a function     that accepts a \c{const char *}.      The following example makes a copy of the char* returned by     data(), but it will corrupt the heap and cause a crash because it     does not allocate a byte for the '\\0' at the end:      \snippet code/src_corelib_tools_qbytearray.cpp 46      This one allocates the correct amount of space:      \snippet code/src_corelib_tools_qbytearray.cpp 47      Note: A QByteArray can store any byte values including '\\0's,     but most functions that take \c{char *} arguments assume that the     data ends at the first '\\0' they encounter.      \sa constData(), operator[]() */
end_comment
begin_comment
comment|/*! \fn const char *QByteArray::data() const      \overload */
end_comment
begin_comment
comment|/*! \fn const char *QByteArray::constData() const      Returns a pointer to the data stored in the byte array. The pointer can be     used to access the bytes that compose the array. The data is     '\\0'-terminated unless the QByteArray object was created from raw data.     The pointer remains valid as long as the byte array isn't reallocated or     destroyed.      This function is mostly useful to pass a byte array to a function     that accepts a \c{const char *}.      Note: A QByteArray can store any byte values including '\\0's,     but most functions that take \c{char *} arguments assume that the     data ends at the first '\\0' they encounter.      \sa data(), operator[](), fromRawData() */
end_comment
begin_comment
comment|/*! \fn void QByteArray::detach()      \internal */
end_comment
begin_comment
comment|/*! \fn bool QByteArray::isDetached() const      \internal */
end_comment
begin_comment
comment|/*! \fn bool QByteArray::isSharedWith(const QByteArray&other) const      \internal */
end_comment
begin_comment
comment|/*! \fn char QByteArray::at(int i) const      Returns the character at index position \a i in the byte array.      \a i must be a valid index position in the byte array (i.e., 0<=     \a i< size()).      \sa operator[]() */
end_comment
begin_comment
comment|/*! \fn QByteRef QByteArray::operator[](int i)      Returns the byte at index position \a i as a modifiable reference.      If an assignment is made beyond the end of the byte array, the     array is extended with resize() before the assignment takes     place.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 9      The return value is of type QByteRef, a helper class for     QByteArray. When you get an object of type QByteRef, you can use     it as if it were a char&. If you assign to it, the assignment     will apply to the character in the QByteArray from which you got     the reference.      \sa at() */
end_comment
begin_comment
comment|/*! \fn char QByteArray::operator[](int i) const      \overload      Same as at(\a i). */
end_comment
begin_comment
comment|/*! \fn QByteRef QByteArray::operator[](uint i)      \overload */
end_comment
begin_comment
comment|/*! \fn char QByteArray::operator[](uint i) const      \overload */
end_comment
begin_comment
comment|/*! \fn bool QByteArray::contains(const QByteArray&ba) const      Returns true if the byte array contains an occurrence of the byte     array \a ba; otherwise returns false.      \sa indexOf(), count() */
end_comment
begin_comment
comment|/*! \fn bool QByteArray::contains(const char *str) const      \overload      Returns true if the byte array contains the string \a str;     otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool QByteArray::contains(char ch) const      \overload      Returns true if the byte array contains the character \a ch;     otherwise returns false. */
end_comment
begin_comment
comment|/*!      Truncates the byte array at index position \a pos.      If \a pos is beyond the end of the array, nothing happens.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 10      \sa chop(), resize(), left() */
end_comment
begin_function
DECL|function|truncate
name|void
name|QByteArray
operator|::
name|truncate
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|<
name|d
operator|->
name|size
condition|)
name|resize
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!      Removes \a n bytes from the end of the byte array.      If \a n is greater than size(), the result is an empty byte     array.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 11      \sa truncate(), resize(), left() */
end_comment
begin_function
DECL|function|chop
name|void
name|QByteArray
operator|::
name|chop
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|resize
argument_list|(
name|d
operator|->
name|size
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \fn QByteArray&QByteArray::operator+=(const QByteArray&ba)      Appends the byte array \a ba onto the end of this byte array and     returns a reference to this byte array.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 12      Note: QByteArray is an \l{implicitly shared} class. Consequently,     if \e this is an empty QByteArray, then \e this will just share     the data held in \a ba. In this case, no copying of data is done,     taking \l{constant time}. If a shared instance is modified, it will     be copied (copy-on-write), taking \l{linear time}.      If \e this is not an empty QByteArray, a deep copy of the data is     performed, taking \l{linear time}.      This operation typically does not suffer from allocation overhead,     because QByteArray preallocates extra space at the end of the data     so that it may grow without reallocating for each append operation.      \sa append(), prepend() */
end_comment
begin_comment
comment|/*! \fn QByteArray&QByteArray::operator+=(const QString&str)      \overload      Appends the string \a str onto the end of this byte array and     returns a reference to this byte array. The Unicode data is     converted into 8-bit characters using QString::toUtf8().      If the QString contains non-ASCII Unicode characters, using this     operator can lead to loss of information. You can disable this     operator by defining \c QT_NO_CAST_TO_ASCII when you compile your     applications. You then need to call QString::toUtf8() (or     QString::toLatin1() or QString::toUtf8() or QString::toLocal8Bit())     explicitly if you want to convert the data to \c{const char *}. */
end_comment
begin_comment
comment|/*! \fn QByteArray&QByteArray::operator+=(const char *str)      \overload      Appends the string \a str onto the end of this byte array and     returns a reference to this byte array. */
end_comment
begin_comment
comment|/*! \fn QByteArray&QByteArray::operator+=(char ch)      \overload      Appends the character \a ch onto the end of this byte array and     returns a reference to this byte array. */
end_comment
begin_comment
comment|/*! \fn int QByteArray::length() const      Same as size(). */
end_comment
begin_comment
comment|/*! \fn bool QByteArray::isNull() const      Returns true if this byte array is null; otherwise returns false.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 13      Qt makes a distinction between null byte arrays and empty byte     arrays for historical reasons. For most applications, what     matters is whether or not a byte array contains any data,     and this can be determined using isEmpty().      \sa isEmpty() */
end_comment
begin_comment
comment|/*! \fn QByteArray::QByteArray()      Constructs an empty byte array.      \sa isEmpty() */
end_comment
begin_comment
comment|/*!     Constructs a byte array containing the first \a size bytes of     array \a data.      If \a data is 0, a null byte array is constructed.      If \a size is negative, \a data is assumed to point to a nul-terminated     string and its length is determined dynamically. The terminating     nul-character is not considered part of the byte array.      QByteArray makes a deep copy of the string data.      \sa fromRawData() */
end_comment
begin_constructor
DECL|function|QByteArray
name|QByteArray
operator|::
name|QByteArray
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|d
operator|=
name|Data
operator|::
name|sharedNull
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|size
operator|=
name|int
argument_list|(
name|strlen
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|d
operator|=
name|Data
operator|::
name|allocate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|Data
operator|::
name|allocate
argument_list|(
name|uint
argument_list|(
name|size
argument_list|)
operator|+
literal|1u
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
end_constructor
begin_comment
comment|/*!     Constructs a byte array of size \a size with every byte set to     character \a ch.      \sa fill() */
end_comment
begin_constructor
DECL|function|QByteArray
name|QByteArray
operator|::
name|QByteArray
parameter_list|(
name|int
name|size
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
name|d
operator|=
name|Data
operator|::
name|allocate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|Data
operator|::
name|allocate
argument_list|(
name|uint
argument_list|(
name|size
argument_list|)
operator|+
literal|1u
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|ch
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     \internal      Constructs a byte array of size \a size with uninitialized contents. */
end_comment
begin_constructor
DECL|function|QByteArray
name|QByteArray
operator|::
name|QByteArray
parameter_list|(
name|int
name|size
parameter_list|,
name|Qt
operator|::
name|Initialization
parameter_list|)
block|{
name|d
operator|=
name|Data
operator|::
name|allocate
argument_list|(
name|uint
argument_list|(
name|size
argument_list|)
operator|+
literal|1u
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Sets the size of the byte array to \a size bytes.      If \a size is greater than the current size, the byte array is     extended to make it \a size bytes with the extra bytes added to     the end. The new bytes are uninitialized.      If \a size is less than the current size, bytes are removed from     the end.      \sa size(), truncate() */
end_comment
begin_function
DECL|function|resize
name|void
name|QByteArray
operator|::
name|resize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_RAW_DATA
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|&&
name|size
operator|<
name|d
operator|->
name|size
condition|)
block|{
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|==
literal|0
operator|&&
operator|!
name|d
operator|->
name|capacityReserved
condition|)
block|{
name|Data
modifier|*
name|x
init|=
name|Data
operator|::
name|allocate
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|Data
operator|::
name|deallocate
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|size
operator|==
literal|0
operator|&&
name|d
operator|->
name|ref
operator|.
name|isStatic
argument_list|()
condition|)
block|{
comment|//
comment|// Optimize the idiom:
comment|//    QByteArray a;
comment|//    a.resize(sz);
comment|//    ...
comment|// which is used in place of the Qt 3 idiom:
comment|//    QByteArray a(sz);
comment|//
name|Data
modifier|*
name|x
init|=
name|Data
operator|::
name|allocate
argument_list|(
name|uint
argument_list|(
name|size
argument_list|)
operator|+
literal|1u
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|x
operator|->
name|data
argument_list|()
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|uint
argument_list|(
name|size
argument_list|)
operator|+
literal|1u
operator|>
name|d
operator|->
name|alloc
operator|||
operator|(
operator|!
name|d
operator|->
name|capacityReserved
operator|&&
name|size
operator|<
name|d
operator|->
name|size
operator|&&
name|uint
argument_list|(
name|size
argument_list|)
operator|+
literal|1u
operator|<
name|uint
argument_list|(
name|d
operator|->
name|alloc
operator|>>
literal|1
argument_list|)
operator|)
condition|)
name|reallocData
argument_list|(
name|uint
argument_list|(
name|size
argument_list|)
operator|+
literal|1u
argument_list|,
name|d
operator|->
name|detachFlags
argument_list|()
operator||
name|Data
operator|::
name|Grow
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|alloc
condition|)
block|{
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Sets every byte in the byte array to character \a ch. If \a size     is different from -1 (the default), the byte array is resized to     size \a size beforehand.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 14      \sa resize() */
end_comment
begin_function
DECL|function|fill
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|fill
parameter_list|(
name|char
name|ch
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|resize
argument_list|(
name|size
operator|<
literal|0
condition|?
name|d
operator|->
name|size
else|:
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|size
condition|)
name|memset
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|ch
argument_list|,
name|d
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_function
DECL|function|reallocData
name|void
name|QByteArray
operator|::
name|reallocData
parameter_list|(
name|uint
name|alloc
parameter_list|,
name|Data
operator|::
name|AllocationOptions
name|options
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|IS_RAW_DATA
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|Data
modifier|*
name|x
init|=
name|Data
operator|::
name|allocate
argument_list|(
name|alloc
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|->
name|size
operator|=
name|qMin
argument_list|(
name|int
argument_list|(
name|alloc
argument_list|)
operator|-
literal|1
argument_list|,
name|d
operator|->
name|size
argument_list|)
expr_stmt|;
operator|::
name|memcpy
argument_list|(
name|x
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|x
operator|->
name|size
argument_list|)
expr_stmt|;
name|x
operator|->
name|data
argument_list|()
index|[
name|x
operator|->
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|Data
operator|::
name|deallocate
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|options
operator|&
name|Data
operator|::
name|Grow
condition|)
name|alloc
operator|=
name|qAllocMore
argument_list|(
name|alloc
argument_list|,
sizeof|sizeof
argument_list|(
name|Data
argument_list|)
argument_list|)
expr_stmt|;
name|Data
modifier|*
name|x
init|=
cast|static_cast
argument_list|<
name|Data
operator|*
argument_list|>
argument_list|(
operator|::
name|realloc
argument_list|(
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|Data
argument_list|)
operator|+
name|alloc
argument_list|)
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|->
name|alloc
operator|=
name|alloc
expr_stmt|;
name|x
operator|->
name|capacityReserved
operator|=
operator|(
name|options
operator|&
name|Data
operator|::
name|CapacityReserved
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|expand
name|void
name|QByteArray
operator|::
name|expand
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|resize
argument_list|(
name|qMax
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|d
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!    \internal    Return a QByteArray that is sure to be NUL-terminated.     By default, all QByteArray have an extra NUL at the end,    guaranteeing that assumption. However, if QByteArray::fromRawData    is used, then the NUL is there only if the user put it there. We    can't be sure. */
end_comment
begin_function
DECL|function|nulTerminated
name|QByteArray
name|QByteArray
operator|::
name|nulTerminated
parameter_list|()
specifier|const
block|{
comment|// is this fromRawData?
if|if
condition|(
operator|!
name|IS_RAW_DATA
argument_list|(
name|d
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
comment|// no, then we're sure we're zero terminated
name|QByteArray
name|copy
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|copy
operator|.
name|detach
argument_list|()
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function
begin_comment
comment|/*!     Prepends the byte array \a ba to this byte array and returns a     reference to this byte array.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 15      This is the same as insert(0, \a ba).      Note: QByteArray is an \l{implicitly shared} class. Consequently,     if \e this is an empty QByteArray, then \e this will just share     the data held in \a ba. In this case, no copying of data is done,     taking \l{constant time}. If a shared instance is modified, it will     be copied (copy-on-write), taking \l{linear time}.      If \e this is not an empty QByteArray, a deep copy of the data is     performed, taking \l{linear time}.      \sa append(), insert() */
end_comment
begin_function
DECL|function|prepend
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|prepend
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|size
operator|==
literal|0
operator|&&
name|d
operator|->
name|ref
operator|.
name|isStatic
argument_list|()
operator|&&
operator|!
name|IS_RAW_DATA
argument_list|(
name|ba
operator|.
name|d
argument_list|)
condition|)
block|{
operator|*
name|this
operator|=
name|ba
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ba
operator|.
name|d
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|QByteArray
name|tmp
init|=
operator|*
name|this
decl_stmt|;
operator|*
name|this
operator|=
name|ba
expr_stmt|;
name|append
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Prepends the string \a str to this byte array. */
end_comment
begin_function
DECL|function|prepend
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|prepend
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|prepend
argument_list|(
name|str
argument_list|,
name|qstrlen
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.6      Prepends \a len bytes of the string \a str to this byte array. */
end_comment
begin_function
DECL|function|prepend
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|prepend
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|str
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|len
argument_list|)
operator|+
literal|1u
operator|>
name|d
operator|->
name|alloc
condition|)
name|reallocData
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|len
argument_list|)
operator|+
literal|1u
argument_list|,
name|d
operator|->
name|detachFlags
argument_list|()
operator||
name|Data
operator|::
name|Grow
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|len
argument_list|,
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|+=
name|len
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|d
operator|->
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Prepends the character \a ch to this byte array. */
end_comment
begin_function
DECL|function|prepend
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|prepend
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
operator|+
literal|2u
operator|>
name|d
operator|->
name|alloc
condition|)
name|reallocData
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
operator|+
literal|2u
argument_list|,
name|d
operator|->
name|detachFlags
argument_list|()
operator||
name|Data
operator|::
name|Grow
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
literal|1
argument_list|,
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|size
argument_list|)
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
operator|++
name|d
operator|->
name|size
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|d
operator|->
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Appends the byte array \a ba onto the end of this byte array.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 16      This is the same as insert(size(), \a ba).      Note: QByteArray is an \l{implicitly shared} class. Consequently,     if \e this is an empty QByteArray, then \e this will just share     the data held in \a ba. In this case, no copying of data is done,     taking \l{constant time}. If a shared instance is modified, it will     be copied (copy-on-write), taking \l{linear time}.      If \e this is not an empty QByteArray, a deep copy of the data is     performed, taking \l{linear time}.      This operation typically does not suffer from allocation overhead,     because QByteArray preallocates extra space at the end of the data     so that it may grow without reallocating for each append operation.      \sa operator+=(), prepend(), insert() */
end_comment
begin_function
DECL|function|append
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|append
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|size
operator|==
literal|0
operator|&&
name|d
operator|->
name|ref
operator|.
name|isStatic
argument_list|()
operator|&&
operator|!
name|IS_RAW_DATA
argument_list|(
name|ba
operator|.
name|d
argument_list|)
condition|)
block|{
operator|*
name|this
operator|=
name|ba
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ba
operator|.
name|d
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|ba
operator|.
name|d
operator|->
name|size
argument_list|)
operator|+
literal|1u
operator|>
name|d
operator|->
name|alloc
condition|)
name|reallocData
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|ba
operator|.
name|d
operator|->
name|size
argument_list|)
operator|+
literal|1u
argument_list|,
name|d
operator|->
name|detachFlags
argument_list|()
operator||
name|Data
operator|::
name|Grow
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
argument_list|,
name|ba
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|ba
operator|.
name|d
operator|->
name|size
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|+=
name|ba
operator|.
name|d
operator|->
name|size
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|d
operator|->
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*! \fn QByteArray&QByteArray::append(const QString&str)      \overload      Appends the string \a str to this byte array. The Unicode data is     converted into 8-bit characters using QString::toUtf8().      If the QString contains non-ASCII Unicode characters, using this     function can lead to loss of information. You can disable this     function by defining \c QT_NO_CAST_TO_ASCII when you compile your     applications. You then need to call QString::toUtf8() (or     QString::toLatin1() or QString::toUtf8() or QString::toLocal8Bit())     explicitly if you want to convert the data to \c{const char *}. */
end_comment
begin_comment
comment|/*!     \overload      Appends the string \a str to this byte array. */
end_comment
begin_function
DECL|function|append
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|append
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
condition|)
block|{
specifier|const
name|int
name|len
init|=
name|int
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|len
argument_list|)
operator|+
literal|1u
operator|>
name|d
operator|->
name|alloc
condition|)
name|reallocData
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|len
argument_list|)
operator|+
literal|1u
argument_list|,
name|d
operator|->
name|detachFlags
argument_list|()
operator||
name|Data
operator|::
name|Grow
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
argument_list|,
name|str
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// include null terminator
name|d
operator|->
name|size
operator|+=
name|len
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload append()      Appends the first \a len characters of the string \a str to this byte     array and returns a reference to this byte array.      If \a len is negative, the length of the string will be determined     automatically using qstrlen(). If \a len is zero or \a str is     null, nothing is appended to the byte array. Ensure that \a len is     \e not longer than \a str. */
end_comment
begin_function
DECL|function|append
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|append
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
name|qstrlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|&&
name|len
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|len
argument_list|)
operator|+
literal|1u
operator|>
name|d
operator|->
name|alloc
condition|)
name|reallocData
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|len
argument_list|)
operator|+
literal|1u
argument_list|,
name|d
operator|->
name|detachFlags
argument_list|()
operator||
name|Data
operator|::
name|Grow
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|// include null terminator
name|d
operator|->
name|size
operator|+=
name|len
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|d
operator|->
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Appends the character \a ch to this byte array. */
end_comment
begin_function
DECL|function|append
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|append
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
operator|+
literal|2u
operator|>
name|d
operator|->
name|alloc
condition|)
name|reallocData
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
operator|+
literal|2u
argument_list|,
name|d
operator|->
name|detachFlags
argument_list|()
operator||
name|Data
operator|::
name|Grow
argument_list|)
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|d
operator|->
name|size
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|d
operator|->
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Inserts \a len bytes from the array \a arr at position \a pos and returns a   reference the modified byte array. */
end_comment
begin_function
DECL|function|qbytearray_insert
specifier|static
specifier|inline
name|QByteArray
modifier|&
name|qbytearray_insert
parameter_list|(
name|QByteArray
modifier|*
name|ba
parameter_list|,
name|int
name|pos
parameter_list|,
specifier|const
name|char
modifier|*
name|arr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|pos
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|len
operator|<=
literal|0
operator|||
name|arr
operator|==
literal|0
condition|)
return|return
operator|*
name|ba
return|;
name|int
name|oldsize
init|=
name|ba
operator|->
name|size
argument_list|()
decl_stmt|;
name|ba
operator|->
name|resize
argument_list|(
name|qMax
argument_list|(
name|pos
argument_list|,
name|oldsize
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|char
modifier|*
name|dst
init|=
name|ba
operator|->
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|pos
operator|>
name|oldsize
condition|)
operator|::
name|memset
argument_list|(
name|dst
operator|+
name|oldsize
argument_list|,
literal|0x20
argument_list|,
name|pos
operator|-
name|oldsize
argument_list|)
expr_stmt|;
else|else
operator|::
name|memmove
argument_list|(
name|dst
operator|+
name|pos
operator|+
name|len
argument_list|,
name|dst
operator|+
name|pos
argument_list|,
name|oldsize
operator|-
name|pos
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|+
name|pos
argument_list|,
name|arr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|*
name|ba
return|;
block|}
end_function
begin_comment
comment|/*!     Inserts the byte array \a ba at index position \a i and returns a     reference to this byte array.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 17      \sa append(), prepend(), replace(), remove() */
end_comment
begin_function
DECL|function|insert
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|insert
parameter_list|(
name|int
name|i
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
name|QByteArray
name|copy
argument_list|(
name|ba
argument_list|)
decl_stmt|;
return|return
name|qbytearray_insert
argument_list|(
name|this
argument_list|,
name|i
argument_list|,
name|copy
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|copy
operator|.
name|d
operator|->
name|size
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray&QByteArray::insert(int i, const QString&str)      \overload      Inserts the string \a str at index position \a i in the byte     array. The Unicode data is converted into 8-bit characters using     QString::toUtf8().      If \a i is greater than size(), the array is first extended using     resize().      You can disable this function by defining \c QT_NO_CAST_TO_ASCII when you     compile your applications. You then need to call QString::toUtf8() (or     QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to     convert the data to \c{const char *}. */
end_comment
begin_comment
comment|/*!     \overload      Inserts the string \a str at position \a i in the byte array.      If \a i is greater than size(), the array is first extended using     resize(). */
end_comment
begin_function
DECL|function|insert
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|insert
parameter_list|(
name|int
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|qbytearray_insert
argument_list|(
name|this
argument_list|,
name|i
argument_list|,
name|str
argument_list|,
name|qstrlen
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.6      Inserts \a len bytes of the string \a str at position     \a i in the byte array.      If \a i is greater than size(), the array is first extended using     resize(). */
end_comment
begin_function
DECL|function|insert
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|insert
parameter_list|(
name|int
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|qbytearray_insert
argument_list|(
name|this
argument_list|,
name|i
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Inserts character \a ch at index position \a i in the byte array.     If \a i is greater than size(), the array is first extended using     resize(). */
end_comment
begin_function
DECL|function|insert
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|insert
parameter_list|(
name|int
name|i
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
return|return
name|qbytearray_insert
argument_list|(
name|this
argument_list|,
name|i
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Removes \a len bytes from the array, starting at index position \a     pos, and returns a reference to the array.      If \a pos is out of range, nothing happens. If \a pos is valid,     but \a pos + \a len is larger than the size of the array, the     array is truncated at position \a pos.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 18      \sa insert(), replace() */
end_comment
begin_function
DECL|function|remove
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|remove
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|pos
operator|>=
name|d
operator|->
name|size
operator|||
name|pos
operator|<
literal|0
condition|)
return|return
operator|*
name|this
return|;
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|+
name|len
operator|>=
name|d
operator|->
name|size
condition|)
block|{
name|resize
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memmove
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|pos
argument_list|,
name|d
operator|->
name|data
argument_list|()
operator|+
name|pos
operator|+
name|len
argument_list|,
name|d
operator|->
name|size
operator|-
name|pos
operator|-
name|len
argument_list|)
expr_stmt|;
name|resize
argument_list|(
name|d
operator|->
name|size
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Replaces \a len bytes from index position \a pos with the byte     array \a after, and returns a reference to this byte array.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 19      \sa insert(), remove() */
end_comment
begin_function
DECL|function|replace
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|replace
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|after
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
name|after
operator|.
name|d
operator|->
name|size
operator|&&
operator|(
name|pos
operator|+
name|len
operator|<=
name|d
operator|->
name|size
operator|)
condition|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|memmove
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|pos
argument_list|,
name|after
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
else|else
block|{
name|QByteArray
name|copy
argument_list|(
name|after
argument_list|)
decl_stmt|;
comment|// ### optimize me
name|remove
argument_list|(
name|pos
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|insert
argument_list|(
name|pos
argument_list|,
name|copy
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*! \fn QByteArray&QByteArray::replace(int pos, int len, const char *after)      \overload      Replaces \a len bytes from index position \a pos with the zero terminated     string \a after.      Notice: this can change the length of the byte array. */
end_comment
begin_function
DECL|function|replace
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|replace
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|after
parameter_list|)
block|{
return|return
name|replace
argument_list|(
name|pos
argument_list|,
name|len
argument_list|,
name|after
argument_list|,
name|qstrlen
argument_list|(
name|after
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn QByteArray&QByteArray::replace(int pos, int len, const char *after, int alen)      \overload      Replaces \a len bytes from index position \a pos with \a alen bytes     from the string \a after. \a after is allowed to have '\\0' characters.      \since 4.7 */
end_comment
begin_function
DECL|function|replace
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|replace
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|after
parameter_list|,
name|int
name|alen
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
name|alen
operator|&&
operator|(
name|pos
operator|+
name|len
operator|<=
name|d
operator|->
name|size
operator|)
condition|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|pos
argument_list|,
name|after
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
else|else
block|{
name|remove
argument_list|(
name|pos
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|qbytearray_insert
argument_list|(
name|this
argument_list|,
name|pos
argument_list|,
name|after
argument_list|,
name|alen
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|// ### optimize all other replace method, by offering
end_comment
begin_comment
comment|// QByteArray::replace(const char *before, int blen, const char *after, int alen)
end_comment
begin_comment
comment|/*!     \overload      Replaces every occurrence of the byte array \a before with the     byte array \a after.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 20 */
end_comment
begin_function
DECL|function|replace
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|replace
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|before
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|after
parameter_list|)
block|{
if|if
condition|(
name|isNull
argument_list|()
operator|||
name|before
operator|.
name|d
operator|==
name|after
operator|.
name|d
condition|)
return|return
operator|*
name|this
return|;
name|QByteArray
name|aft
init|=
name|after
decl_stmt|;
if|if
condition|(
name|after
operator|.
name|d
operator|==
name|d
condition|)
name|aft
operator|.
name|detach
argument_list|()
expr_stmt|;
return|return
name|replace
argument_list|(
name|before
operator|.
name|constData
argument_list|()
argument_list|,
name|before
operator|.
name|size
argument_list|()
argument_list|,
name|aft
operator|.
name|constData
argument_list|()
argument_list|,
name|aft
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray&QByteArray::replace(const char *before, const QByteArray&after)     \overload      Replaces every occurrence of the string \a before with the     byte array \a after. */
end_comment
begin_function
DECL|function|replace
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|replace
parameter_list|(
specifier|const
name|char
modifier|*
name|c
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|after
parameter_list|)
block|{
name|QByteArray
name|aft
init|=
name|after
decl_stmt|;
if|if
condition|(
name|after
operator|.
name|d
operator|==
name|d
condition|)
name|aft
operator|.
name|detach
argument_list|()
expr_stmt|;
return|return
name|replace
argument_list|(
name|c
argument_list|,
name|qstrlen
argument_list|(
name|c
argument_list|)
argument_list|,
name|aft
operator|.
name|constData
argument_list|()
argument_list|,
name|aft
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray&QByteArray::replace(const char *before, int bsize, const char *after, int asize)     \overload      Replaces every occurrence of the string \a before with the string \a after.     Since the sizes of the strings are given by \a bsize and \a asize, they     may contain zero characters and do not need to be zero-terminated. */
end_comment
begin_function
DECL|function|replace
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|replace
parameter_list|(
specifier|const
name|char
modifier|*
name|before
parameter_list|,
name|int
name|bsize
parameter_list|,
specifier|const
name|char
modifier|*
name|after
parameter_list|,
name|int
name|asize
parameter_list|)
block|{
if|if
condition|(
name|isNull
argument_list|()
operator|||
operator|(
name|before
operator|==
name|after
operator|&&
name|bsize
operator|==
name|asize
operator|)
condition|)
return|return
operator|*
name|this
return|;
comment|// protect against before or after being part of this
specifier|const
name|char
modifier|*
name|a
init|=
name|after
decl_stmt|;
specifier|const
name|char
modifier|*
name|b
init|=
name|before
decl_stmt|;
if|if
condition|(
name|after
operator|>=
name|d
operator|->
name|data
argument_list|()
operator|&&
name|after
operator|<
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
condition|)
block|{
name|char
modifier|*
name|copy
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|asize
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|after
argument_list|,
name|asize
argument_list|)
expr_stmt|;
name|a
operator|=
name|copy
expr_stmt|;
block|}
if|if
condition|(
name|before
operator|>=
name|d
operator|->
name|data
argument_list|()
operator|&&
name|before
operator|<
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
condition|)
block|{
name|char
modifier|*
name|copy
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bsize
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|before
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|b
operator|=
name|copy
expr_stmt|;
block|}
name|QByteArrayMatcher
name|matcher
argument_list|(
name|before
argument_list|,
name|bsize
argument_list|)
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|d
operator|->
name|size
decl_stmt|;
name|char
modifier|*
name|d
init|=
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|bsize
operator|==
name|asize
condition|)
block|{
if|if
condition|(
name|bsize
condition|)
block|{
while|while
condition|(
operator|(
name|index
operator|=
name|matcher
operator|.
name|indexIn
argument_list|(
operator|*
name|this
argument_list|,
name|index
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|d
operator|+
name|index
argument_list|,
name|after
argument_list|,
name|asize
argument_list|)
expr_stmt|;
name|index
operator|+=
name|bsize
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|asize
operator|<
name|bsize
condition|)
block|{
name|uint
name|to
init|=
literal|0
decl_stmt|;
name|uint
name|movestart
init|=
literal|0
decl_stmt|;
name|uint
name|num
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|index
operator|=
name|matcher
operator|.
name|indexIn
argument_list|(
operator|*
name|this
argument_list|,
name|index
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|num
condition|)
block|{
name|int
name|msize
init|=
name|index
operator|-
name|movestart
decl_stmt|;
if|if
condition|(
name|msize
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|d
operator|+
name|to
argument_list|,
name|d
operator|+
name|movestart
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|to
operator|+=
name|msize
expr_stmt|;
block|}
block|}
else|else
block|{
name|to
operator|=
name|index
expr_stmt|;
block|}
if|if
condition|(
name|asize
condition|)
block|{
name|memcpy
argument_list|(
name|d
operator|+
name|to
argument_list|,
name|after
argument_list|,
name|asize
argument_list|)
expr_stmt|;
name|to
operator|+=
name|asize
expr_stmt|;
block|}
name|index
operator|+=
name|bsize
expr_stmt|;
name|movestart
operator|=
name|index
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|num
condition|)
block|{
name|int
name|msize
init|=
name|len
operator|-
name|movestart
decl_stmt|;
if|if
condition|(
name|msize
operator|>
literal|0
condition|)
name|memmove
argument_list|(
name|d
operator|+
name|to
argument_list|,
name|d
operator|+
name|movestart
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|resize
argument_list|(
name|len
operator|-
name|num
operator|*
operator|(
name|bsize
operator|-
name|asize
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// the most complex case. We don't want to lose performance by doing repeated
comment|// copies and reallocs of the string.
while|while
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|uint
name|indices
index|[
literal|4096
index|]
decl_stmt|;
name|uint
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|<
literal|4095
condition|)
block|{
name|index
operator|=
name|matcher
operator|.
name|indexIn
argument_list|(
operator|*
name|this
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
break|break;
name|indices
index|[
name|pos
operator|++
index|]
operator|=
name|index
expr_stmt|;
name|index
operator|+=
name|bsize
expr_stmt|;
comment|// avoid infinite loop
if|if
condition|(
operator|!
name|bsize
condition|)
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pos
condition|)
break|break;
comment|// we have a table of replacement positions, use them for fast replacing
name|int
name|adjust
init|=
name|pos
operator|*
operator|(
name|asize
operator|-
name|bsize
operator|)
decl_stmt|;
comment|// index has to be adjusted in case we get back into the loop above.
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
name|index
operator|+=
name|adjust
expr_stmt|;
name|int
name|newlen
init|=
name|len
operator|+
name|adjust
decl_stmt|;
name|int
name|moveend
init|=
name|len
decl_stmt|;
if|if
condition|(
name|newlen
operator|>
name|len
condition|)
block|{
name|resize
argument_list|(
name|newlen
argument_list|)
expr_stmt|;
name|len
operator|=
name|newlen
expr_stmt|;
block|}
name|d
operator|=
name|this
operator|->
name|d
operator|->
name|data
argument_list|()
expr_stmt|;
while|while
condition|(
name|pos
condition|)
block|{
name|pos
operator|--
expr_stmt|;
name|int
name|movestart
init|=
name|indices
index|[
name|pos
index|]
operator|+
name|bsize
decl_stmt|;
name|int
name|insertstart
init|=
name|indices
index|[
name|pos
index|]
operator|+
name|pos
operator|*
operator|(
name|asize
operator|-
name|bsize
operator|)
decl_stmt|;
name|int
name|moveto
init|=
name|insertstart
operator|+
name|asize
decl_stmt|;
name|memmove
argument_list|(
name|d
operator|+
name|moveto
argument_list|,
name|d
operator|+
name|movestart
argument_list|,
operator|(
name|moveend
operator|-
name|movestart
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asize
condition|)
name|memcpy
argument_list|(
name|d
operator|+
name|insertstart
argument_list|,
name|after
argument_list|,
name|asize
argument_list|)
expr_stmt|;
name|moveend
operator|=
name|movestart
operator|-
name|bsize
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|a
operator|!=
name|after
condition|)
operator|::
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|before
condition|)
operator|::
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray&QByteArray::replace(const QByteArray&before, const char *after)     \overload      Replaces every occurrence of the byte array \a before with the     string \a after. */
end_comment
begin_comment
comment|/*! \fn QByteArray&QByteArray::replace(const QString&before, const QByteArray&after)      \overload      Replaces every occurrence of the string \a before with the byte     array \a after. The Unicode data is converted into 8-bit     characters using QString::toUtf8().      You can disable this function by defining \c QT_NO_CAST_TO_ASCII when you     compile your applications. You then need to call QString::toUtf8() (or     QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to     convert the data to \c{const char *}. */
end_comment
begin_comment
comment|/*! \fn QByteArray&QByteArray::replace(const QString&before, const char *after)     \overload      Replaces every occurrence of the string \a before with the string     \a after. */
end_comment
begin_comment
comment|/*! \fn QByteArray&QByteArray::replace(const char *before, const char *after)      \overload      Replaces every occurrence of the string \a before with the string     \a after. */
end_comment
begin_comment
comment|/*!     \overload      Replaces every occurrence of the character \a before with the     byte array \a after. */
end_comment
begin_function
DECL|function|replace
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|replace
parameter_list|(
name|char
name|before
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|after
parameter_list|)
block|{
name|char
name|b
index|[
literal|2
index|]
init|=
block|{
name|before
block|,
literal|'\0'
block|}
decl_stmt|;
name|QByteArray
name|cb
init|=
name|fromRawData
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
name|replace
argument_list|(
name|cb
argument_list|,
name|after
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn QByteArray&QByteArray::replace(char before, const QString&after)      \overload      Replaces every occurrence of the character \a before with the     string \a after. The Unicode data is converted into 8-bit     characters using QString::toUtf8().      If the QString contains non-ASCII Unicode characters, using this     function can lead to loss of information. You can disable this     function by defining \c QT_NO_CAST_TO_ASCII when you compile your     applications. You then need to call QString::toUtf8() (or     QString::toLatin1() or QString::toUtf8() or QString::toLocal8Bit())     explicitly if you want to convert the data to \c{const char *}. */
end_comment
begin_comment
comment|/*! \fn QByteArray&QByteArray::replace(char before, const char *after)      \overload      Replaces every occurrence of the character \a before with the     string \a after. */
end_comment
begin_comment
comment|/*!     \overload      Replaces every occurrence of the character \a before with the     character \a after. */
end_comment
begin_function
DECL|function|replace
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|replace
parameter_list|(
name|char
name|before
parameter_list|,
name|char
name|after
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|size
condition|)
block|{
name|char
modifier|*
name|i
init|=
name|data
argument_list|()
decl_stmt|;
name|char
modifier|*
name|e
init|=
name|i
operator|+
name|d
operator|->
name|size
decl_stmt|;
for|for
control|(
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|i
operator|==
name|before
condition|)
operator|*
name|i
operator|=
name|after
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Splits the byte array into subarrays wherever \a sep occurs, and     returns the list of those arrays. If \a sep does not match     anywhere in the byte array, split() returns a single-element list     containing this byte array. */
end_comment
begin_function
DECL|function|split
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QByteArray
operator|::
name|split
parameter_list|(
name|char
name|sep
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
name|int
name|end
decl_stmt|;
while|while
condition|(
operator|(
name|end
operator|=
name|indexOf
argument_list|(
name|sep
argument_list|,
name|start
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|list
operator|.
name|append
argument_list|(
name|mid
argument_list|(
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
block|}
name|list
operator|.
name|append
argument_list|(
name|mid
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns a copy of this byte array repeated the specified number of \a times.      If \a times is less than 1, an empty byte array is returned.      Example:      \code         QByteArray ba("ab");         ba.repeated(4);             // returns "abababab"     \endcode */
end_comment
begin_function
DECL|function|repeated
name|QByteArray
name|QByteArray
operator|::
name|repeated
parameter_list|(
name|int
name|times
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|size
operator|==
literal|0
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|times
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|times
operator|==
literal|1
condition|)
return|return
operator|*
name|this
return|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
specifier|const
name|int
name|resultSize
init|=
name|times
operator|*
name|d
operator|->
name|size
decl_stmt|;
name|QByteArray
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|resultSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|d
operator|->
name|alloc
operator|!=
name|uint
argument_list|(
name|resultSize
argument_list|)
operator|+
literal|1u
condition|)
return|return
name|QByteArray
argument_list|()
return|;
comment|// not enough memory
name|memcpy
argument_list|(
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|size
argument_list|)
expr_stmt|;
name|int
name|sizeSoFar
init|=
name|d
operator|->
name|size
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
operator|+
name|sizeSoFar
decl_stmt|;
specifier|const
name|int
name|halfResultSize
init|=
name|resultSize
operator|>>
literal|1
decl_stmt|;
while|while
condition|(
name|sizeSoFar
operator|<=
name|halfResultSize
condition|)
block|{
name|memcpy
argument_list|(
name|end
argument_list|,
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|sizeSoFar
argument_list|)
expr_stmt|;
name|end
operator|+=
name|sizeSoFar
expr_stmt|;
name|sizeSoFar
operator|<<=
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|end
argument_list|,
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|resultSize
operator|-
name|sizeSoFar
argument_list|)
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
index|[
name|resultSize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|size
operator|=
name|resultSize
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_define
DECL|macro|REHASH
define|#
directive|define
name|REHASH
parameter_list|(
name|a
parameter_list|)
define|\
value|if (ol_minus_1< sizeof(uint) * CHAR_BIT) \         hashHaystack -= (a)<< ol_minus_1; \     hashHaystack<<= 1
end_define
begin_comment
comment|/*!     Returns the index position of the first occurrence of the byte     array \a ba in this byte array, searching forward from index     position \a from. Returns -1 if \a ba could not be found.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 21      \sa lastIndexOf(), contains(), count() */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QByteArray
operator|::
name|indexOf
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|ol
init|=
name|ba
operator|.
name|d
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|ol
operator|==
literal|0
condition|)
return|return
name|from
return|;
if|if
condition|(
name|ol
operator|==
literal|1
condition|)
return|return
name|indexOf
argument_list|(
operator|*
name|ba
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|from
argument_list|)
return|;
specifier|const
name|int
name|l
init|=
name|d
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|from
operator|>
name|d
operator|->
name|size
operator|||
name|ol
operator|+
name|from
operator|>
name|l
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|qFindByteArray
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|size
argument_list|,
name|from
argument_list|,
name|ba
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|ol
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn int QByteArray::indexOf(const QString&str, int from) const      \overload      Returns the index position of the first occurrence of the string     \a str in the byte array, searching forward from index position     \a from. Returns -1 if \a str could not be found.      The Unicode data is converted into 8-bit characters using     QString::toUtf8().      You can disable this function by defining \c QT_NO_CAST_TO_ASCII when you     compile your applications. You then need to call QString::toUtf8() (or     QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to     convert the data to \c{const char *}. */
end_comment
begin_comment
comment|/*! \fn int QByteArray::indexOf(const char *str, int from) const      \overload      Returns the index position of the first occurrence of the string     \a str in the byte array, searching forward from index position \a     from. Returns -1 if \a str could not be found. */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QByteArray
operator|::
name|indexOf
parameter_list|(
specifier|const
name|char
modifier|*
name|c
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|ol
init|=
name|qstrlen
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|ol
operator|==
literal|1
condition|)
return|return
name|indexOf
argument_list|(
operator|*
name|c
argument_list|,
name|from
argument_list|)
return|;
specifier|const
name|int
name|l
init|=
name|d
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|from
operator|>
name|d
operator|->
name|size
operator|||
name|ol
operator|+
name|from
operator|>
name|l
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ol
operator|==
literal|0
condition|)
return|return
name|from
return|;
return|return
name|qFindByteArray
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|size
argument_list|,
name|from
argument_list|,
name|c
argument_list|,
name|ol
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the index position of the first occurrence of the     character \a ch in the byte array, searching forward from index     position \a from. Returns -1 if \a ch could not be found.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 22      \sa lastIndexOf(), contains() */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QByteArray
operator|::
name|indexOf
parameter_list|(
name|char
name|ch
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|=
name|qMax
argument_list|(
name|from
operator|+
name|d
operator|->
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|<
name|d
operator|->
name|size
condition|)
block|{
specifier|const
name|char
modifier|*
name|n
init|=
name|d
operator|->
name|data
argument_list|()
operator|+
name|from
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|e
init|=
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
decl_stmt|;
while|while
condition|(
operator|++
name|n
operator|!=
name|e
condition|)
if|if
condition|(
operator|*
name|n
operator|==
name|ch
condition|)
return|return
name|n
operator|-
name|d
operator|->
name|data
argument_list|()
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|lastIndexOfHelper
specifier|static
name|int
name|lastIndexOfHelper
parameter_list|(
specifier|const
name|char
modifier|*
name|haystack
parameter_list|,
name|int
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|needle
parameter_list|,
name|int
name|ol
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|int
name|delta
init|=
name|l
operator|-
name|ol
decl_stmt|;
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|=
name|delta
expr_stmt|;
if|if
condition|(
name|from
argument_list|<
literal|0
operator|||
name|from
argument_list|>
name|l
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|from
operator|>
name|delta
condition|)
name|from
operator|=
name|delta
expr_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|haystack
decl_stmt|;
name|haystack
operator|+=
name|from
expr_stmt|;
specifier|const
name|uint
name|ol_minus_1
init|=
name|ol
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|n
init|=
name|needle
operator|+
name|ol_minus_1
decl_stmt|;
specifier|const
name|char
modifier|*
name|h
init|=
name|haystack
operator|+
name|ol_minus_1
decl_stmt|;
name|uint
name|hashNeedle
init|=
literal|0
decl_stmt|,
name|hashHaystack
init|=
literal|0
decl_stmt|;
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|ol
condition|;
operator|++
name|idx
control|)
block|{
name|hashNeedle
operator|=
operator|(
operator|(
name|hashNeedle
operator|<<
literal|1
operator|)
operator|+
operator|*
operator|(
name|n
operator|-
name|idx
operator|)
operator|)
expr_stmt|;
name|hashHaystack
operator|=
operator|(
operator|(
name|hashHaystack
operator|<<
literal|1
operator|)
operator|+
operator|*
operator|(
name|h
operator|-
name|idx
operator|)
operator|)
expr_stmt|;
block|}
name|hashHaystack
operator|-=
operator|*
name|haystack
expr_stmt|;
while|while
condition|(
name|haystack
operator|>=
name|end
condition|)
block|{
name|hashHaystack
operator|+=
operator|*
name|haystack
expr_stmt|;
if|if
condition|(
name|hashHaystack
operator|==
name|hashNeedle
operator|&&
name|memcmp
argument_list|(
name|needle
argument_list|,
name|haystack
argument_list|,
name|ol
argument_list|)
operator|==
literal|0
condition|)
return|return
name|haystack
operator|-
name|end
return|;
operator|--
name|haystack
expr_stmt|;
name|REHASH
argument_list|(
operator|*
operator|(
name|haystack
operator|+
name|ol
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QByteArray::lastIndexOf(const QByteArray&ba, int from) const      Returns the index position of the last occurrence of the byte     array \a ba in this byte array, searching backward from index     position \a from. If \a from is -1 (the default), the search     starts at the last byte. Returns -1 if \a ba could not be found.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 23      \sa indexOf(), contains(), count() */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QByteArray
operator|::
name|lastIndexOf
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|ol
init|=
name|ba
operator|.
name|d
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|ol
operator|==
literal|1
condition|)
return|return
name|lastIndexOf
argument_list|(
operator|*
name|ba
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|from
argument_list|)
return|;
return|return
name|lastIndexOfHelper
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|size
argument_list|,
name|ba
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|ol
argument_list|,
name|from
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn int QByteArray::lastIndexOf(const QString&str, int from) const      \overload      Returns the index position of the last occurrence of the string \a     str in the byte array, searching backward from index position \a     from. If \a from is -1 (the default), the search starts at the     last (size() - 1) byte. Returns -1 if \a str could not be found.      The Unicode data is converted into 8-bit characters using     QString::toUtf8().      You can disable this function by defining \c QT_NO_CAST_TO_ASCII when you     compile your applications. You then need to call QString::toUtf8() (or     QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to     convert the data to \c{const char *}. */
end_comment
begin_comment
comment|/*! \fn int QByteArray::lastIndexOf(const char *str, int from) const     \overload      Returns the index position of the last occurrence of the string \a     str in the byte array, searching backward from index position \a     from. If \a from is -1 (the default), the search starts at the     last (size() - 1) byte. Returns -1 if \a str could not be found. */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QByteArray
operator|::
name|lastIndexOf
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|ol
init|=
name|qstrlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|ol
operator|==
literal|1
condition|)
return|return
name|lastIndexOf
argument_list|(
operator|*
name|str
argument_list|,
name|from
argument_list|)
return|;
return|return
name|lastIndexOfHelper
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|size
argument_list|,
name|str
argument_list|,
name|ol
argument_list|,
name|from
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the index position of the last occurrence of character \a     ch in the byte array, searching backward from index position \a     from. If \a from is -1 (the default), the search starts at the     last (size() - 1) byte. Returns -1 if \a ch could not be found.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 24      \sa indexOf(), contains() */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QByteArray
operator|::
name|lastIndexOf
parameter_list|(
name|char
name|ch
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|+=
name|d
operator|->
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|>
name|d
operator|->
name|size
condition|)
name|from
operator|=
name|d
operator|->
name|size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|from
operator|>=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|b
init|=
name|d
operator|->
name|data
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|n
init|=
name|d
operator|->
name|data
argument_list|()
operator|+
name|from
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|!=
name|b
condition|)
if|if
condition|(
operator|*
name|n
operator|==
name|ch
condition|)
return|return
name|n
operator|-
name|b
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of (potentially overlapping) occurrences of     byte array \a ba in this byte array.      \sa contains(), indexOf() */
end_comment
begin_function
DECL|function|count
name|int
name|QByteArray
operator|::
name|count
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
specifier|const
block|{
name|int
name|num
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|size
operator|>
literal|500
operator|&&
name|ba
operator|.
name|d
operator|->
name|size
operator|>
literal|5
condition|)
block|{
name|QByteArrayMatcher
name|matcher
argument_list|(
name|ba
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|matcher
operator|.
name|indexIn
argument_list|(
operator|*
name|this
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
operator|++
name|num
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|i
operator|=
name|indexOf
argument_list|(
name|ba
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
operator|++
name|num
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the number of (potentially overlapping) occurrences of     string \a str in the byte array. */
end_comment
begin_function
DECL|function|count
name|int
name|QByteArray
operator|::
name|count
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
specifier|const
block|{
return|return
name|count
argument_list|(
name|fromRawData
argument_list|(
name|str
argument_list|,
name|qstrlen
argument_list|(
name|str
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns the number of occurrences of character \a ch in the byte     array.      \sa contains(), indexOf() */
end_comment
begin_function
DECL|function|count
name|int
name|QByteArray
operator|::
name|count
parameter_list|(
name|char
name|ch
parameter_list|)
specifier|const
block|{
name|int
name|num
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|i
init|=
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|b
init|=
name|d
operator|->
name|data
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|b
condition|)
if|if
condition|(
operator|*
operator|--
name|i
operator|==
name|ch
condition|)
operator|++
name|num
expr_stmt|;
return|return
name|num
return|;
block|}
end_function
begin_comment
comment|/*! \fn int QByteArray::count() const      \overload      Same as size(). */
end_comment
begin_comment
comment|/*!     Returns true if this byte array starts with byte array \a ba;     otherwise returns false.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 25      \sa endsWith(), left() */
end_comment
begin_function
DECL|function|startsWith
name|bool
name|QByteArray
operator|::
name|startsWith
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|==
name|ba
operator|.
name|d
operator|||
name|ba
operator|.
name|d
operator|->
name|size
operator|==
literal|0
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|d
operator|->
name|size
operator|<
name|ba
operator|.
name|d
operator|->
name|size
condition|)
return|return
literal|false
return|;
return|return
name|memcmp
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|ba
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|ba
operator|.
name|d
operator|->
name|size
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \overload      Returns true if this byte array starts with string \a str;     otherwise returns false. */
end_comment
begin_function
DECL|function|startsWith
name|bool
name|QByteArray
operator|::
name|startsWith
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|str
operator|||
operator|!
operator|*
name|str
condition|)
return|return
literal|true
return|;
specifier|const
name|int
name|len
init|=
name|int
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|size
operator|<
name|len
condition|)
return|return
literal|false
return|;
return|return
name|qstrncmp
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \overload      Returns true if this byte array starts with character \a ch;     otherwise returns false. */
end_comment
begin_function
DECL|function|startsWith
name|bool
name|QByteArray
operator|::
name|startsWith
parameter_list|(
name|char
name|ch
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|size
operator|==
literal|0
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|data
argument_list|()
index|[
literal|0
index|]
operator|==
name|ch
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this byte array ends with byte array \a ba;     otherwise returns false.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 26      \sa startsWith(), right() */
end_comment
begin_function
DECL|function|endsWith
name|bool
name|QByteArray
operator|::
name|endsWith
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|==
name|ba
operator|.
name|d
operator|||
name|ba
operator|.
name|d
operator|->
name|size
operator|==
literal|0
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|d
operator|->
name|size
operator|<
name|ba
operator|.
name|d
operator|->
name|size
condition|)
return|return
literal|false
return|;
return|return
name|memcmp
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
operator|-
name|ba
operator|.
name|d
operator|->
name|size
argument_list|,
name|ba
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|ba
operator|.
name|d
operator|->
name|size
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \overload      Returns true if this byte array ends with string \a str; otherwise     returns false. */
end_comment
begin_function
DECL|function|endsWith
name|bool
name|QByteArray
operator|::
name|endsWith
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|str
operator|||
operator|!
operator|*
name|str
condition|)
return|return
literal|true
return|;
specifier|const
name|int
name|len
init|=
name|int
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|size
operator|<
name|len
condition|)
return|return
literal|false
return|;
return|return
name|qstrncmp
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
operator|-
name|len
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \overload      Returns true if this byte array ends with character \a ch;     otherwise returns false. */
end_comment
begin_function
DECL|function|endsWith
name|bool
name|QByteArray
operator|::
name|endsWith
parameter_list|(
name|char
name|ch
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|size
operator|==
literal|0
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|data
argument_list|()
index|[
name|d
operator|->
name|size
operator|-
literal|1
index|]
operator|==
name|ch
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a byte array that contains the leftmost \a len bytes of     this byte array.      The entire byte array is returned if \a len is greater than     size().      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 27      \sa right(), mid(), startsWith(), truncate() */
end_comment
begin_function
DECL|function|left
name|QByteArray
name|QByteArray
operator|::
name|left
parameter_list|(
name|int
name|len
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|len
operator|>=
name|d
operator|->
name|size
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|QByteArray
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a byte array that contains the rightmost \a len bytes of     this byte array.      The entire byte array is returned if \a len is greater than     size().      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 28      \sa endsWith(), left(), mid() */
end_comment
begin_function
DECL|function|right
name|QByteArray
name|QByteArray
operator|::
name|right
parameter_list|(
name|int
name|len
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|len
operator|>=
name|d
operator|->
name|size
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|QByteArray
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
operator|-
name|len
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a byte array containing \a len bytes from this byte array,     starting at position \a pos.      If \a len is -1 (the default), or \a pos + \a len>= size(),     returns a byte array containing all bytes starting at position \a     pos until the end of the byte array.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 29      \sa left(), right() */
end_comment
begin_function
DECL|function|mid
name|QByteArray
name|QByteArray
operator|::
name|mid
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|len
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|size
operator|==
literal|0
operator|&&
name|d
operator|->
name|ref
operator|.
name|isStatic
argument_list|()
operator|)
operator|||
name|pos
operator|>
name|d
operator|->
name|size
condition|)
return|return
name|QByteArray
argument_list|()
return|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
name|d
operator|->
name|size
operator|-
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|len
operator|+=
name|pos
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|+
name|pos
operator|>
name|d
operator|->
name|size
condition|)
name|len
operator|=
name|d
operator|->
name|size
operator|-
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|0
operator|&&
name|len
operator|==
name|d
operator|->
name|size
condition|)
return|return
operator|*
name|this
return|;
return|return
name|QByteArray
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|pos
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a lowercase copy of the byte array. The bytearray is     interpreted as a Latin-1 encoded string.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 30      \sa toUpper(), {8-bit Character Comparisons} */
end_comment
begin_function
DECL|function|toLower
name|QByteArray
name|QByteArray
operator|::
name|toLower
parameter_list|()
specifier|const
block|{
name|QByteArray
name|s
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|p
init|=
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|s
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
while|while
condition|(
operator|*
name|p
condition|)
block|{
operator|*
name|p
operator|=
name|QChar
operator|::
name|toLower
argument_list|(
operator|(
name|ushort
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an uppercase copy of the byte array. The bytearray is     interpreted as a Latin-1 encoded string.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 31      \sa toLower(), {8-bit Character Comparisons} */
end_comment
begin_function
DECL|function|toUpper
name|QByteArray
name|QByteArray
operator|::
name|toUpper
parameter_list|()
specifier|const
block|{
name|QByteArray
name|s
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|p
init|=
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|s
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
while|while
condition|(
operator|*
name|p
condition|)
block|{
operator|*
name|p
operator|=
name|QChar
operator|::
name|toUpper
argument_list|(
operator|(
name|ushort
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*! \fn void QByteArray::clear()      Clears the contents of the byte array and makes it empty.      \sa resize(), isEmpty() */
end_comment
begin_function
DECL|function|clear
name|void
name|QByteArray
operator|::
name|clear
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|Data
operator|::
name|deallocate
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|Data
operator|::
name|sharedNull
argument_list|()
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DATASTREAM
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BUILD_QMAKE
argument_list|)
operator|)
end_if
begin_comment
comment|/*! \relates QByteArray      Writes byte array \a ba to the stream \a out and returns a reference     to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
if|if
condition|(
name|ba
operator|.
name|isNull
argument_list|()
operator|&&
name|out
operator|.
name|version
argument_list|()
operator|>=
literal|6
condition|)
block|{
name|out
operator|<<
operator|(
name|quint32
operator|)
literal|0xffffffff
expr_stmt|;
return|return
name|out
return|;
block|}
return|return
name|out
operator|.
name|writeBytes
argument_list|(
name|ba
operator|.
name|constData
argument_list|()
argument_list|,
name|ba
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \relates QByteArray      Reads a byte array into \a ba from the stream \a in and returns a     reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QByteArray
modifier|&
name|ba
parameter_list|)
block|{
name|ba
operator|.
name|clear
argument_list|()
expr_stmt|;
name|quint32
name|len
decl_stmt|;
name|in
operator|>>
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0xffffffff
condition|)
return|return
name|in
return|;
specifier|const
name|quint32
name|Step
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
name|quint32
name|allocated
init|=
literal|0
decl_stmt|;
do|do
block|{
name|int
name|blockSize
init|=
name|qMin
argument_list|(
name|Step
argument_list|,
name|len
operator|-
name|allocated
argument_list|)
decl_stmt|;
name|ba
operator|.
name|resize
argument_list|(
name|allocated
operator|+
name|blockSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|readRawData
argument_list|(
name|ba
operator|.
name|data
argument_list|()
operator|+
name|allocated
argument_list|,
name|blockSize
argument_list|)
operator|!=
name|blockSize
condition|)
block|{
name|ba
operator|.
name|clear
argument_list|()
expr_stmt|;
name|in
operator|.
name|setStatus
argument_list|(
name|QDataStream
operator|::
name|ReadPastEnd
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
name|allocated
operator|+=
name|blockSize
expr_stmt|;
block|}
do|while
condition|(
name|allocated
operator|<
name|len
condition|)
do|;
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*! \fn bool QByteArray::operator==(const QString&str) const      Returns true if this byte array is equal to string \a str;     otherwise returns false.      The Unicode data is converted into 8-bit characters using     QString::toUtf8().      The comparison is case sensitive.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. You     then need to call QString::fromUtf8(), QString::fromLatin1(),     or QString::fromLocal8Bit() explicitly if you want to convert the byte     array to a QString before doing the comparison. */
end_comment
begin_comment
comment|/*! \fn bool QByteArray::operator!=(const QString&str) const      Returns true if this byte array is not equal to string \a str;     otherwise returns false.      The Unicode data is converted into 8-bit characters using     QString::toUtf8().      The comparison is case sensitive.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. You     then need to call QString::fromUtf8(), QString::fromLatin1(),     or QString::fromLocal8Bit() explicitly if you want to convert the byte     array to a QString before doing the comparison. */
end_comment
begin_comment
comment|/*! \fn bool QByteArray::operator<(const QString&str) const      Returns true if this byte array is lexically less than string \a     str; otherwise returns false.      The Unicode data is converted into 8-bit characters using     QString::toUtf8().      The comparison is case sensitive.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. You     then need to call QString::fromUtf8(), QString::fromLatin1(),     or QString::fromLocal8Bit() explicitly if you want to convert the byte     array to a QString before doing the comparison. */
end_comment
begin_comment
comment|/*! \fn bool QByteArray::operator>(const QString&str) const      Returns true if this byte array is lexically greater than string     \a str; otherwise returns false.      The Unicode data is converted into 8-bit characters using     QString::toUtf8().      The comparison is case sensitive.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. You     then need to call QString::fromUtf8(), QString::fromLatin1(),     or QString::fromLocal8Bit() explicitly if you want to convert the byte     array to a QString before doing the comparison. */
end_comment
begin_comment
comment|/*! \fn bool QByteArray::operator<=(const QString&str) const      Returns true if this byte array is lexically less than or equal     to string \a str; otherwise returns false.      The Unicode data is converted into 8-bit characters using     QString::toUtf8().      The comparison is case sensitive.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. You     then need to call QString::fromUtf8(), QString::fromLatin1(),     or QString::fromLocal8Bit() explicitly if you want to convert the byte     array to a QString before doing the comparison. */
end_comment
begin_comment
comment|/*! \fn bool QByteArray::operator>=(const QString&str) const      Returns true if this byte array is greater than or equal to string     \a str; otherwise returns false.      The Unicode data is converted into 8-bit characters using     QString::toUtf8().      The comparison is case sensitive.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. You     then need to call QString::fromUtf8(), QString::fromLatin1(),     or QString::fromLocal8Bit() explicitly if you want to convert the byte     array to a QString before doing the comparison. */
end_comment
begin_comment
comment|/*! \fn bool operator==(const QByteArray&a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns true if byte array \a a1 is equal to byte array \a a2;     otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator==(const QByteArray&a1, const char *a2)     \relates QByteArray      \overload      Returns true if byte array \a a1 is equal to string \a a2;     otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator==(const char *a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns true if string \a a1 is equal to byte array \a a2;     otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator!=(const QByteArray&a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns true if byte array \a a1 is not equal to byte array \a a2;     otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator!=(const QByteArray&a1, const char *a2)     \relates QByteArray      \overload      Returns true if byte array \a a1 is not equal to string \a a2;     otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator!=(const char *a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns true if string \a a1 is not equal to byte array \a a2;     otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator<(const QByteArray&a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns true if byte array \a a1 is lexically less than byte array     \a a2; otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn inline bool operator<(const QByteArray&a1, const char *a2)     \relates QByteArray      \overload      Returns true if byte array \a a1 is lexically less than string     \a a2; otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator<(const char *a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns true if string \a a1 is lexically less than byte array     \a a2; otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator<=(const QByteArray&a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns true if byte array \a a1 is lexically less than or equal     to byte array \a a2; otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator<=(const QByteArray&a1, const char *a2)     \relates QByteArray      \overload      Returns true if byte array \a a1 is lexically less than or equal     to string \a a2; otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator<=(const char *a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns true if string \a a1 is lexically less than or equal     to byte array \a a2; otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator>(const QByteArray&a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns true if byte array \a a1 is lexically greater than byte     array \a a2; otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator>(const QByteArray&a1, const char *a2)     \relates QByteArray      \overload      Returns true if byte array \a a1 is lexically greater than string     \a a2; otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator>(const char *a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns true if string \a a1 is lexically greater than byte array     \a a2; otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator>=(const QByteArray&a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns true if byte array \a a1 is lexically greater than or     equal to byte array \a a2; otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator>=(const QByteArray&a1, const char *a2)     \relates QByteArray      \overload      Returns true if byte array \a a1 is lexically greater than or     equal to string \a a2; otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn bool operator>=(const char *a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns true if string \a a1 is lexically greater than or     equal to byte array \a a2; otherwise returns false. */
end_comment
begin_comment
comment|/*! \fn const QByteArray operator+(const QByteArray&a1, const QByteArray&a2)     \relates QByteArray      Returns a byte array that is the result of concatenating byte     array \a a1 and byte array \a a2.      \sa QByteArray::operator+=() */
end_comment
begin_comment
comment|/*! \fn const QByteArray operator+(const QByteArray&a1, const char *a2)     \relates QByteArray      \overload      Returns a byte array that is the result of concatenating byte     array \a a1 and string \a a2. */
end_comment
begin_comment
comment|/*! \fn const QByteArray operator+(const QByteArray&a1, char a2)     \relates QByteArray      \overload      Returns a byte array that is the result of concatenating byte     array \a a1 and character \a a2. */
end_comment
begin_comment
comment|/*! \fn const QByteArray operator+(const char *a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns a byte array that is the result of concatenating string     \a a1 and byte array \a a2. */
end_comment
begin_comment
comment|/*! \fn const QByteArray operator+(char a1, const QByteArray&a2)     \relates QByteArray      \overload      Returns a byte array that is the result of concatenating character     \a a1 and byte array \a a2. */
end_comment
begin_comment
comment|/*!     Returns a byte array that has whitespace removed from the start     and the end, and which has each sequence of internal whitespace     replaced with a single space.      Whitespace means any character for which the standard C++     isspace() function returns true. This includes the ASCII     characters '\\t', '\\n', '\\v', '\\f', '\\r', and ' '.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 32      \sa trimmed() */
end_comment
begin_function
DECL|function|simplified
name|QByteArray
name|QByteArray
operator|::
name|simplified
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|size
operator|==
literal|0
condition|)
return|return
operator|*
name|this
return|;
name|QByteArray
name|result
argument_list|(
name|d
operator|->
name|size
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|from
init|=
name|d
operator|->
name|data
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|fromend
init|=
name|from
operator|+
name|d
operator|->
name|size
decl_stmt|;
name|int
name|outc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|to
init|=
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|from
operator|!=
name|fromend
operator|&&
name|isspace
argument_list|(
name|uchar
argument_list|(
operator|*
name|from
argument_list|)
argument_list|)
condition|)
name|from
operator|++
expr_stmt|;
while|while
condition|(
name|from
operator|!=
name|fromend
operator|&&
operator|!
name|isspace
argument_list|(
name|uchar
argument_list|(
operator|*
name|from
argument_list|)
argument_list|)
condition|)
name|to
index|[
name|outc
operator|++
index|]
operator|=
operator|*
name|from
operator|++
expr_stmt|;
if|if
condition|(
name|from
operator|!=
name|fromend
condition|)
name|to
index|[
name|outc
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|outc
operator|>
literal|0
operator|&&
name|to
index|[
name|outc
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|outc
operator|--
expr_stmt|;
name|result
operator|.
name|resize
argument_list|(
name|outc
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a byte array that has whitespace removed from the start     and the end.      Whitespace means any character for which the standard C++     isspace() function returns true. This includes the ASCII     characters '\\t', '\\n', '\\v', '\\f', '\\r', and ' '.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 33      Unlike simplified(), trimmed() leaves internal whitespace alone.      \sa simplified() */
end_comment
begin_function
DECL|function|trimmed
name|QByteArray
name|QByteArray
operator|::
name|trimmed
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|size
operator|==
literal|0
condition|)
return|return
operator|*
name|this
return|;
specifier|const
name|char
modifier|*
name|s
init|=
name|d
operator|->
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|uchar
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
name|uchar
argument_list|(
name|s
index|[
name|d
operator|->
name|size
operator|-
literal|1
index|]
argument_list|)
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
name|int
name|start
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
name|d
operator|->
name|size
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|start
operator|<=
name|end
operator|&&
name|isspace
argument_list|(
name|uchar
argument_list|(
name|s
index|[
name|start
index|]
argument_list|)
argument_list|)
condition|)
comment|// skip white space from start
name|start
operator|++
expr_stmt|;
if|if
condition|(
name|start
operator|<=
name|end
condition|)
block|{
comment|// only white space
while|while
condition|(
name|end
operator|&&
name|isspace
argument_list|(
name|uchar
argument_list|(
name|s
index|[
name|end
index|]
argument_list|)
argument_list|)
condition|)
comment|// skip white space from end
name|end
operator|--
expr_stmt|;
block|}
name|int
name|l
init|=
name|end
operator|-
name|start
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|l
operator|<=
literal|0
condition|)
block|{
name|QByteArrayDataPtr
name|empty
init|=
block|{
name|Data
operator|::
name|allocate
operator|(
literal|0
operator|)
block|}
decl_stmt|;
return|return
name|QByteArray
argument_list|(
name|empty
argument_list|)
return|;
block|}
return|return
name|QByteArray
argument_list|(
name|s
operator|+
name|start
argument_list|,
name|l
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a byte array of size \a width that contains this byte     array padded by the \a fill character.      If \a truncate is false and the size() of the byte array is more     than \a width, then the returned byte array is a copy of this byte     array.      If \a truncate is true and the size() of the byte array is more     than \a width, then any bytes in a copy of the byte array     after position \a width are removed, and the copy is returned.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 34      \sa rightJustified() */
end_comment
begin_function
DECL|function|leftJustified
name|QByteArray
name|QByteArray
operator|::
name|leftJustified
parameter_list|(
name|int
name|width
parameter_list|,
name|char
name|fill
parameter_list|,
name|bool
name|truncate
parameter_list|)
specifier|const
block|{
name|QByteArray
name|result
decl_stmt|;
name|int
name|len
init|=
name|d
operator|->
name|size
decl_stmt|;
name|int
name|padlen
init|=
name|width
operator|-
name|len
decl_stmt|;
if|if
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|resize
argument_list|(
name|len
operator|+
name|padlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|memcpy
argument_list|(
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
operator|+
name|len
argument_list|,
name|fill
argument_list|,
name|padlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|truncate
condition|)
name|result
operator|=
name|left
argument_list|(
name|width
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|*
name|this
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a byte array of size \a width that contains the \a fill     character followed by this byte array.      If \a truncate is false and the size of the byte array is more     than \a width, then the returned byte array is a copy of this byte     array.      If \a truncate is true and the size of the byte array is more     than \a width, then the resulting byte array is truncated at     position \a width.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 35      \sa leftJustified() */
end_comment
begin_function
DECL|function|rightJustified
name|QByteArray
name|QByteArray
operator|::
name|rightJustified
parameter_list|(
name|int
name|width
parameter_list|,
name|char
name|fill
parameter_list|,
name|bool
name|truncate
parameter_list|)
specifier|const
block|{
name|QByteArray
name|result
decl_stmt|;
name|int
name|len
init|=
name|d
operator|->
name|size
decl_stmt|;
name|int
name|padlen
init|=
name|width
operator|-
name|len
decl_stmt|;
if|if
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|resize
argument_list|(
name|len
operator|+
name|padlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|memcpy
argument_list|(
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
operator|+
name|padlen
argument_list|,
name|data
argument_list|()
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|fill
argument_list|,
name|padlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|truncate
condition|)
name|result
operator|=
name|left
argument_list|(
name|width
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|*
name|this
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|isNull
name|bool
name|QByteArray
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|==
name|QArrayData
operator|::
name|sharedNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the byte array converted to a \c {long long} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.      If \a base is 0, the base is determined automatically using the     following rules: If the byte array begins with "0x", it is assumed to     be hexadecimal; if it begins with "0", it is assumed to be octal;     otherwise it is assumed to be decimal.      Returns 0 if the conversion fails.      If \a ok is not 0: if a conversion error occurs, *\a{ok} is set to     false; otherwise *\a{ok} is set to true.      \note The conversion of the number is performed in the default C locale,     irrespective of the user's locale.      \sa number() */
end_comment
begin_function
DECL|function|toLongLong
name|qlonglong
name|QByteArray
operator|::
name|toLongLong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_CHECK_RANGE
argument_list|)
if|if
condition|(
name|base
operator|!=
literal|0
operator|&&
operator|(
name|base
argument_list|<
literal|2
operator|||
name|base
argument_list|>
literal|36
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QByteArray::toLongLong: Invalid base %d"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|QLocalePrivate
operator|::
name|bytearrayToLongLong
argument_list|(
name|nulTerminated
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|base
argument_list|,
name|ok
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the byte array converted to an \c {unsigned long long}     using base \a base, which is 10 by default and must be between 2     and 36, or 0.      If \a base is 0, the base is determined automatically using the     following rules: If the byte array begins with "0x", it is assumed to     be hexadecimal; if it begins with "0", it is assumed to be octal;     otherwise it is assumed to be decimal.      Returns 0 if the conversion fails.      If \a ok is not 0: if a conversion error occurs, *\a{ok} is set to     false; otherwise *\a{ok} is set to true.      \note The conversion of the number is performed in the default C locale,     irrespective of the user's locale.      \sa number() */
end_comment
begin_function
DECL|function|toULongLong
name|qulonglong
name|QByteArray
operator|::
name|toULongLong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_CHECK_RANGE
argument_list|)
if|if
condition|(
name|base
operator|!=
literal|0
operator|&&
operator|(
name|base
argument_list|<
literal|2
operator|||
name|base
argument_list|>
literal|36
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QByteArray::toULongLong: Invalid base %d"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|QLocalePrivate
operator|::
name|bytearrayToUnsLongLong
argument_list|(
name|nulTerminated
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|base
argument_list|,
name|ok
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the byte array converted to an \c int using base \a     base, which is 10 by default and must be between 2 and 36, or 0.      If \a base is 0, the base is determined automatically using the     following rules: If the byte array begins with "0x", it is assumed to     be hexadecimal; if it begins with "0", it is assumed to be octal;     otherwise it is assumed to be decimal.      Returns 0 if the conversion fails.      If \a ok is not 0: if a conversion error occurs, *\a{ok} is set to     false; otherwise *\a{ok} is set to true.      \snippet code/src_corelib_tools_qbytearray.cpp 36      \note The conversion of the number is performed in the default C locale,     irrespective of the user's locale.      \sa number() */
end_comment
begin_function
DECL|function|toInt
name|int
name|QByteArray
operator|::
name|toInt
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
name|qlonglong
name|v
init|=
name|toLongLong
argument_list|(
name|ok
argument_list|,
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
argument_list|<
name|INT_MIN
operator|||
name|v
argument_list|>
name|INT_MAX
condition|)
block|{
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|int
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the byte array converted to an \c {unsigned int} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.      If \a base is 0, the base is determined automatically using the     following rules: If the byte array begins with "0x", it is assumed to     be hexadecimal; if it begins with "0", it is assumed to be octal;     otherwise it is assumed to be decimal.      Returns 0 if the conversion fails.      If \a ok is not 0: if a conversion error occurs, *\a{ok} is set to     false; otherwise *\a{ok} is set to true.      \note The conversion of the number is performed in the default C locale,     irrespective of the user's locale.      \sa number() */
end_comment
begin_function
DECL|function|toUInt
name|uint
name|QByteArray
operator|::
name|toUInt
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
name|qulonglong
name|v
init|=
name|toULongLong
argument_list|(
name|ok
argument_list|,
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|>
name|UINT_MAX
condition|)
block|{
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|uint
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the byte array converted to a \c long int using base \a     base, which is 10 by default and must be between 2 and 36, or 0.      If \a base is 0, the base is determined automatically using the     following rules: If the byte array begins with "0x", it is assumed to     be hexadecimal; if it begins with "0", it is assumed to be octal;     otherwise it is assumed to be decimal.      Returns 0 if the conversion fails.      If \a ok is not 0: if a conversion error occurs, *\a{ok} is set to     false; otherwise *\a{ok} is set to true.      \snippet code/src_corelib_tools_qbytearray.cpp 37      \note The conversion of the number is performed in the default C locale,     irrespective of the user's locale.      \sa number() */
end_comment
begin_function
DECL|function|toLong
name|long
name|QByteArray
operator|::
name|toLong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
name|qlonglong
name|v
init|=
name|toLongLong
argument_list|(
name|ok
argument_list|,
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
argument_list|<
name|LONG_MIN
operator|||
name|v
argument_list|>
name|LONG_MAX
condition|)
block|{
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|long
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the byte array converted to an \c {unsigned long int} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.      If \a base is 0, the base is determined automatically using the     following rules: If the byte array begins with "0x", it is assumed to     be hexadecimal; if it begins with "0", it is assumed to be octal;     otherwise it is assumed to be decimal.      Returns 0 if the conversion fails.      If \a ok is not 0: if a conversion error occurs, *\a{ok} is set to     false; otherwise *\a{ok} is set to true.      \note The conversion of the number is performed in the default C locale,     irrespective of the user's locale.      \sa number() */
end_comment
begin_function
DECL|function|toULong
name|ulong
name|QByteArray
operator|::
name|toULong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
name|qulonglong
name|v
init|=
name|toULongLong
argument_list|(
name|ok
argument_list|,
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|>
name|ULONG_MAX
condition|)
block|{
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ulong
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the byte array converted to a \c short using base \a     base, which is 10 by default and must be between 2 and 36, or 0.      If \a base is 0, the base is determined automatically using the     following rules: If the byte array begins with "0x", it is assumed to     be hexadecimal; if it begins with "0", it is assumed to be octal;     otherwise it is assumed to be decimal.      Returns 0 if the conversion fails.      If \a ok is not 0: if a conversion error occurs, *\a{ok} is set to     false; otherwise *\a{ok} is set to true.      \note The conversion of the number is performed in the default C locale,     irrespective of the user's locale.      \sa number() */
end_comment
begin_function
DECL|function|toShort
name|short
name|QByteArray
operator|::
name|toShort
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
name|qlonglong
name|v
init|=
name|toLongLong
argument_list|(
name|ok
argument_list|,
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
argument_list|<
name|SHRT_MIN
operator|||
name|v
argument_list|>
name|SHRT_MAX
condition|)
block|{
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|short
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the byte array converted to an \c {unsigned short} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.      If \a base is 0, the base is determined automatically using the     following rules: If the byte array begins with "0x", it is assumed to     be hexadecimal; if it begins with "0", it is assumed to be octal;     otherwise it is assumed to be decimal.      Returns 0 if the conversion fails.      If \a ok is not 0: if a conversion error occurs, *\a{ok} is set to     false; otherwise *\a{ok} is set to true.      \note The conversion of the number is performed in the default C locale,     irrespective of the user's locale.      \sa number() */
end_comment
begin_function
DECL|function|toUShort
name|ushort
name|QByteArray
operator|::
name|toUShort
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
name|qulonglong
name|v
init|=
name|toULongLong
argument_list|(
name|ok
argument_list|,
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|>
name|USHRT_MAX
condition|)
block|{
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ushort
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the byte array converted to a \c double value.      Returns 0.0 if the conversion fails.      If \a ok is not 0: if a conversion error occurs, *\a{ok} is set to     false; otherwise *\a{ok} is set to true.      \snippet code/src_corelib_tools_qbytearray.cpp 38      \note The conversion of the number is performed in the default C locale,     irrespective of the user's locale.      \sa number() */
end_comment
begin_function
DECL|function|toDouble
name|double
name|QByteArray
operator|::
name|toDouble
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
return|return
name|QLocalePrivate
operator|::
name|bytearrayToDouble
argument_list|(
name|nulTerminated
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|ok
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the byte array converted to a \c float value.      Returns 0.0 if the conversion fails.      If \a ok is not 0: if a conversion error occurs, *\a{ok} is set to     false; otherwise *\a{ok} is set to true.      \note The conversion of the number is performed in the default C locale,     irrespective of the user's locale.      \sa number() */
end_comment
begin_function
DECL|function|toFloat
name|float
name|QByteArray
operator|::
name|toFloat
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
return|return
name|float
argument_list|(
name|toDouble
argument_list|(
name|ok
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a copy of the byte array, encoded as Base64.      \snippet code/src_corelib_tools_qbytearray.cpp 39      The algorithm used to encode Base64-encoded data is defined in \l{RFC 2045}.      \sa fromBase64() */
end_comment
begin_function
DECL|function|toBase64
name|QByteArray
name|QByteArray
operator|::
name|toBase64
parameter_list|()
specifier|const
block|{
specifier|const
name|char
name|alphabet
index|[]
init|=
literal|"ABCDEFGH"
literal|"IJKLMNOP"
literal|"QRSTUVWX"
literal|"YZabcdef"
literal|"ghijklmn"
literal|"opqrstuv"
literal|"wxyz0123"
literal|"456789+/"
decl_stmt|;
specifier|const
name|char
name|padchar
init|=
literal|'='
decl_stmt|;
name|int
name|padlen
init|=
literal|0
decl_stmt|;
name|QByteArray
name|tmp
argument_list|(
operator|(
name|d
operator|->
name|size
operator|*
literal|4
operator|)
operator|/
literal|3
operator|+
literal|3
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|out
init|=
name|tmp
operator|.
name|data
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|d
operator|->
name|size
condition|)
block|{
name|int
name|chunk
init|=
literal|0
decl_stmt|;
name|chunk
operator||=
name|int
argument_list|(
name|uchar
argument_list|(
name|d
operator|->
name|data
argument_list|()
index|[
name|i
operator|++
index|]
argument_list|)
argument_list|)
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|d
operator|->
name|size
condition|)
block|{
name|padlen
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|chunk
operator||=
name|int
argument_list|(
name|uchar
argument_list|(
name|d
operator|->
name|data
argument_list|()
index|[
name|i
operator|++
index|]
argument_list|)
argument_list|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|d
operator|->
name|size
condition|)
name|padlen
operator|=
literal|1
expr_stmt|;
else|else
name|chunk
operator||=
name|int
argument_list|(
name|uchar
argument_list|(
name|d
operator|->
name|data
argument_list|()
index|[
name|i
operator|++
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|j
init|=
operator|(
name|chunk
operator|&
literal|0x00fc0000
operator|)
operator|>>
literal|18
decl_stmt|;
name|int
name|k
init|=
operator|(
name|chunk
operator|&
literal|0x0003f000
operator|)
operator|>>
literal|12
decl_stmt|;
name|int
name|l
init|=
operator|(
name|chunk
operator|&
literal|0x00000fc0
operator|)
operator|>>
literal|6
decl_stmt|;
name|int
name|m
init|=
operator|(
name|chunk
operator|&
literal|0x0000003f
operator|)
decl_stmt|;
operator|*
name|out
operator|++
operator|=
name|alphabet
index|[
name|j
index|]
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|alphabet
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|padlen
operator|>
literal|1
condition|)
operator|*
name|out
operator|++
operator|=
name|padchar
expr_stmt|;
else|else
operator|*
name|out
operator|++
operator|=
name|alphabet
index|[
name|l
index|]
expr_stmt|;
if|if
condition|(
name|padlen
operator|>
literal|0
condition|)
operator|*
name|out
operator|++
operator|=
name|padchar
expr_stmt|;
else|else
operator|*
name|out
operator|++
operator|=
name|alphabet
index|[
name|m
index|]
expr_stmt|;
block|}
name|tmp
operator|.
name|truncate
argument_list|(
name|out
operator|-
name|tmp
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray&QByteArray::setNum(int n, int base)      Sets the byte array to the printed value of \a n in base \a base (10     by default) and returns a reference to the byte array. The \a base can     be any value between 2 and 36. For bases other than 10, n is treated     as an unsigned integer.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 40      \note The format of the number is not localized; the default C locale     is used irrespective of the user's locale.      \sa number(), toInt() */
end_comment
begin_comment
comment|/*!     \fn QByteArray&QByteArray::setNum(uint n, int base)     \overload      \sa toUInt() */
end_comment
begin_comment
comment|/*!     \fn QByteArray&QByteArray::setNum(short n, int base)     \overload      \sa toShort() */
end_comment
begin_comment
comment|/*!     \fn QByteArray&QByteArray::setNum(ushort n, int base)     \overload      \sa toUShort() */
end_comment
begin_comment
comment|/*!     \overload      \sa toLongLong() */
end_comment
begin_function
DECL|function|qulltoa2
specifier|static
name|char
modifier|*
name|qulltoa2
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|qulonglong
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_CHECK_RANGE
argument_list|)
if|if
condition|(
name|base
argument_list|<
literal|2
operator|||
name|base
argument_list|>
literal|36
condition|)
block|{
name|qWarning
argument_list|(
literal|"QByteArray::setNum: Invalid base %d"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
block|}
endif|#
directive|endif
specifier|const
name|char
name|b
init|=
literal|'a'
operator|-
literal|10
decl_stmt|;
do|do
block|{
specifier|const
name|int
name|c
init|=
name|n
operator|%
name|base
decl_stmt|;
name|n
operator|/=
name|base
expr_stmt|;
operator|*
operator|--
name|p
operator|=
name|c
operator|+
operator|(
name|c
operator|<
literal|10
condition|?
literal|'0'
else|:
name|b
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|n
condition|)
do|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|setNum
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|setNum
parameter_list|(
name|qlonglong
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
specifier|const
name|int
name|buffsize
init|=
literal|66
decl_stmt|;
comment|// big enough for MAX_ULLONG in base 2
name|char
name|buff
index|[
name|buffsize
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|&&
name|base
operator|==
literal|10
condition|)
block|{
name|p
operator|=
name|qulltoa2
argument_list|(
name|buff
operator|+
name|buffsize
argument_list|,
name|qulonglong
argument_list|(
operator|-
operator|(
literal|1
operator|+
name|n
operator|)
argument_list|)
operator|+
literal|1
argument_list|,
name|base
argument_list|)
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|qulltoa2
argument_list|(
name|buff
operator|+
name|buffsize
argument_list|,
name|qulonglong
argument_list|(
name|n
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
name|clear
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|p
argument_list|,
name|buffsize
operator|-
operator|(
name|p
operator|-
name|buff
operator|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \sa toULongLong() */
end_comment
begin_function
DECL|function|setNum
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|setNum
parameter_list|(
name|qulonglong
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
specifier|const
name|int
name|buffsize
init|=
literal|66
decl_stmt|;
comment|// big enough for MAX_ULLONG in base 2
name|char
name|buff
index|[
name|buffsize
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|qulltoa2
argument_list|(
name|buff
operator|+
name|buffsize
argument_list|,
name|n
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|append
argument_list|(
name|p
argument_list|,
name|buffsize
operator|-
operator|(
name|p
operator|-
name|buff
operator|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the byte array to the printed value of \a n, formatted in format     \a f with precision \a prec, and returns a reference to the     byte array.      The format \a f can be any of the following:      \table     \header \li Format \li Meaning     \row \li \c e \li format as [-]9.9e[+|-]999     \row \li \c E \li format as [-]9.9E[+|-]999     \row \li \c f \li format as [-]9.9     \row \li \c g \li use \c e or \c f format, whichever is the most concise     \row \li \c G \li use \c E or \c f format, whichever is the most concise     \endtable      With 'e', 'E', and 'f', \a prec is the number of digits after the     decimal point. With 'g' and 'G', \a prec is the maximum number of     significant digits (trailing zeroes are omitted).      \note The format of the number is not localized; the default C locale     is used irrespective of the user's locale.      \sa toDouble() */
end_comment
begin_function
DECL|function|setNum
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|setNum
parameter_list|(
name|double
name|n
parameter_list|,
name|char
name|f
parameter_list|,
name|int
name|prec
parameter_list|)
block|{
name|QLocalePrivate
operator|::
name|DoubleForm
name|form
init|=
name|QLocalePrivate
operator|::
name|DFDecimal
decl_stmt|;
name|uint
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|qIsUpper
argument_list|(
name|f
argument_list|)
condition|)
name|flags
operator|=
name|QLocalePrivate
operator|::
name|CapitalEorX
expr_stmt|;
name|f
operator|=
name|qToLower
argument_list|(
name|f
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|f
condition|)
block|{
case|case
literal|'f'
case|:
name|form
operator|=
name|QLocalePrivate
operator|::
name|DFDecimal
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|form
operator|=
name|QLocalePrivate
operator|::
name|DFExponent
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|form
operator|=
name|QLocalePrivate
operator|::
name|DFSignificantDigits
expr_stmt|;
break|break;
default|default:
if|#
directive|if
name|defined
argument_list|(
name|QT_CHECK_RANGE
argument_list|)
name|qWarning
argument_list|(
literal|"QByteArray::setNum: Invalid format char '%c'"
argument_list|,
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|QLocale
name|locale
argument_list|(
name|QLocale
operator|::
name|C
argument_list|)
decl_stmt|;
operator|*
name|this
operator|=
name|locale
operator|.
name|d
operator|->
name|doubleToString
argument_list|(
name|n
argument_list|,
name|prec
argument_list|,
name|form
argument_list|,
operator|-
literal|1
argument_list|,
name|flags
argument_list|)
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray&QByteArray::setNum(float n, char f, int prec)     \overload      Sets the byte array to the printed value of \a n, formatted in format     \a f with precision \a prec, and returns a reference to the     byte array.      \note The format of the number is not localized; the default C locale     is used irrespective of the user's locale.      \sa toFloat() */
end_comment
begin_comment
comment|/*!     Returns a byte array containing the string equivalent of the     number \a n to base \a base (10 by default). The \a base can be     any value between 2 and 36.      Example:     \snippet code/src_corelib_tools_qbytearray.cpp 41      \note The format of the number is not localized; the default C locale     is used irrespective of the user's locale.      \sa setNum(), toInt() */
end_comment
begin_function
DECL|function|number
name|QByteArray
name|QByteArray
operator|::
name|number
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|QByteArray
name|s
decl_stmt|;
name|s
operator|.
name|setNum
argument_list|(
name|n
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \sa toUInt() */
end_comment
begin_function
DECL|function|number
name|QByteArray
name|QByteArray
operator|::
name|number
parameter_list|(
name|uint
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|QByteArray
name|s
decl_stmt|;
name|s
operator|.
name|setNum
argument_list|(
name|n
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \sa toLongLong() */
end_comment
begin_function
DECL|function|number
name|QByteArray
name|QByteArray
operator|::
name|number
parameter_list|(
name|qlonglong
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|QByteArray
name|s
decl_stmt|;
name|s
operator|.
name|setNum
argument_list|(
name|n
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \sa toULongLong() */
end_comment
begin_function
DECL|function|number
name|QByteArray
name|QByteArray
operator|::
name|number
parameter_list|(
name|qulonglong
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|QByteArray
name|s
decl_stmt|;
name|s
operator|.
name|setNum
argument_list|(
name|n
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Returns a byte array that contains the printed value of \a n,     formatted in format \a f with precision \a prec.      Argument \a n is formatted according to the \a f format specified,     which is \c g by default, and can be any of the following:      \table     \header \li Format \li Meaning     \row \li \c e \li format as [-]9.9e[+|-]999     \row \li \c E \li format as [-]9.9E[+|-]999     \row \li \c f \li format as [-]9.9     \row \li \c g \li use \c e or \c f format, whichever is the most concise     \row \li \c G \li use \c E or \c f format, whichever is the most concise     \endtable      With 'e', 'E', and 'f', \a prec is the number of digits after the     decimal point. With 'g' and 'G', \a prec is the maximum number of     significant digits (trailing zeroes are omitted).      \snippet code/src_corelib_tools_qbytearray.cpp 42      \note The format of the number is not localized; the default C locale     is used irrespective of the user's locale.      \sa toDouble() */
end_comment
begin_function
DECL|function|number
name|QByteArray
name|QByteArray
operator|::
name|number
parameter_list|(
name|double
name|n
parameter_list|,
name|char
name|f
parameter_list|,
name|int
name|prec
parameter_list|)
block|{
name|QByteArray
name|s
decl_stmt|;
name|s
operator|.
name|setNum
argument_list|(
name|n
argument_list|,
name|f
argument_list|,
name|prec
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a QByteArray that uses the first \a size bytes of the     \a data array. The bytes are \e not copied. The QByteArray will     contain the \a data pointer. The caller guarantees that \a data     will not be deleted or modified as long as this QByteArray and any     copies of it exist that have not been modified. In other words,     because QByteArray is an \l{implicitly shared} class and the     instance returned by this function contains the \a data pointer,     the caller must not delete \a data or modify it directly as long     as the returned QByteArray and any copies exist. However,     QByteArray does not take ownership of \a data, so the QByteArray     destructor will never delete the raw \a data, even when the     last QByteArray referring to \a data is destroyed.      A subsequent attempt to modify the contents of the returned     QByteArray or any copy made from it will cause it to create a deep     copy of the \a data array before doing the modification. This     ensures that the raw \a data array itself will never be modified     by QByteArray.      Here is an example of how to read data using a QDataStream on raw     data in memory without copying the raw data into a QByteArray:      \snippet code/src_corelib_tools_qbytearray.cpp 43      \warning A byte array created with fromRawData() is \e not     null-terminated, unless the raw data contains a 0 character at     position \a size. While that does not matter for QDataStream or     functions like indexOf(), passing the byte array to a function     accepting a \c{const char *} expected to be '\\0'-terminated will     fail.      \sa setRawData(), data(), constData() */
end_comment
begin_function
DECL|function|fromRawData
name|QByteArray
name|QByteArray
operator|::
name|fromRawData
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|Data
modifier|*
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|x
operator|=
name|Data
operator|::
name|sharedNull
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|x
operator|=
name|Data
operator|::
name|allocate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|Data
operator|::
name|fromRawData
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|QByteArrayDataPtr
name|dataPtr
init|=
block|{
name|x
block|}
decl_stmt|;
return|return
name|QByteArray
argument_list|(
name|dataPtr
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Resets the QByteArray to use the first \a size bytes of the     \a data array. The bytes are \e not copied. The QByteArray will     contain the \a data pointer. The caller guarantees that \a data     will not be deleted or modified as long as this QByteArray and any     copies of it exist that have not been modified.      This function can be used instead of fromRawData() to re-use     existings QByteArray objects to save memory re-allocations.      \sa fromRawData(), data(), constData() */
end_comment
begin_function
DECL|function|setRawData
name|QByteArray
modifier|&
name|QByteArray
operator|::
name|setRawData
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|uint
name|size
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|d
operator|->
name|alloc
condition|)
block|{
operator|*
name|this
operator|=
name|fromRawData
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|data
condition|)
block|{
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|d
operator|->
name|offset
operator|=
name|data
operator|-
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|offset
operator|=
sizeof|sizeof
argument_list|(
name|QByteArrayData
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|d
operator|->
name|data
argument_list|()
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a decoded copy of the Base64 array \a base64. Input is not checked     for validity; invalid characters in the input are skipped, enabling the     decoding process to continue with subsequent characters.      For example:      \snippet code/src_corelib_tools_qbytearray.cpp 44      The algorithm used to decode Base64-encoded data is defined in \l{RFC 2045}.      \sa toBase64() */
end_comment
begin_function
DECL|function|fromBase64
name|QByteArray
name|QByteArray
operator|::
name|fromBase64
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|base64
parameter_list|)
block|{
name|unsigned
name|int
name|buf
init|=
literal|0
decl_stmt|;
name|int
name|nbits
init|=
literal|0
decl_stmt|;
name|QByteArray
name|tmp
argument_list|(
operator|(
name|base64
operator|.
name|size
argument_list|()
operator|*
literal|3
operator|)
operator|/
literal|4
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|base64
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|ch
init|=
name|base64
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|d
decl_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
condition|)
name|d
operator|=
name|ch
operator|-
literal|'A'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
condition|)
name|d
operator|=
name|ch
operator|-
literal|'a'
operator|+
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|d
operator|=
name|ch
operator|-
literal|'0'
operator|+
literal|52
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
name|d
operator|=
literal|62
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
name|d
operator|=
literal|63
expr_stmt|;
else|else
name|d
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|!=
operator|-
literal|1
condition|)
block|{
name|buf
operator|=
operator|(
name|buf
operator|<<
literal|6
operator|)
operator||
name|d
expr_stmt|;
name|nbits
operator|+=
literal|6
expr_stmt|;
if|if
condition|(
name|nbits
operator|>=
literal|8
condition|)
block|{
name|nbits
operator|-=
literal|8
expr_stmt|;
name|tmp
index|[
name|offset
operator|++
index|]
operator|=
name|buf
operator|>>
name|nbits
expr_stmt|;
name|buf
operator|&=
operator|(
literal|1
operator|<<
name|nbits
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
name|tmp
operator|.
name|truncate
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a decoded copy of the hex encoded array \a hexEncoded. Input is not checked     for validity; invalid characters in the input are skipped, enabling the     decoding process to continue with subsequent characters.      For example:      \snippet code/src_corelib_tools_qbytearray.cpp 45      \sa toHex() */
end_comment
begin_function
DECL|function|fromHex
name|QByteArray
name|QByteArray
operator|::
name|fromHex
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|hexEncoded
parameter_list|)
block|{
name|QByteArray
name|res
argument_list|(
operator|(
name|hexEncoded
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|result
init|=
operator|(
name|uchar
operator|*
operator|)
name|res
operator|.
name|data
argument_list|()
operator|+
name|res
operator|.
name|size
argument_list|()
decl_stmt|;
name|bool
name|odd_digit
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|hexEncoded
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|ch
init|=
name|hexEncoded
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|tmp
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
name|tmp
operator|=
name|ch
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
name|tmp
operator|=
name|ch
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
name|odd_digit
condition|)
block|{
operator|--
name|result
expr_stmt|;
operator|*
name|result
operator|=
name|tmp
expr_stmt|;
name|odd_digit
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
operator|*
name|result
operator||=
name|tmp
operator|<<
literal|4
expr_stmt|;
name|odd_digit
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|res
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|result
operator|-
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|res
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and     the letters a-f.      \sa fromHex() */
end_comment
begin_function
DECL|function|toHex
name|QByteArray
name|QByteArray
operator|::
name|toHex
parameter_list|()
specifier|const
block|{
name|QByteArray
name|hex
argument_list|(
name|d
operator|->
name|size
operator|*
literal|2
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|char
modifier|*
name|hexData
init|=
name|hex
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|data
init|=
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|d
operator|->
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|size
condition|;
operator|++
name|i
control|)
block|{
name|int
name|j
init|=
operator|(
name|data
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
decl_stmt|;
if|if
condition|(
name|j
operator|<=
literal|9
condition|)
name|hexData
index|[
name|i
operator|*
literal|2
index|]
operator|=
operator|(
name|j
operator|+
literal|'0'
operator|)
expr_stmt|;
else|else
name|hexData
index|[
name|i
operator|*
literal|2
index|]
operator|=
operator|(
name|j
operator|+
literal|'a'
operator|-
literal|10
operator|)
expr_stmt|;
name|j
operator|=
name|data
index|[
name|i
index|]
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|j
operator|<=
literal|9
condition|)
name|hexData
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
operator|(
name|j
operator|+
literal|'0'
operator|)
expr_stmt|;
else|else
name|hexData
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
operator|(
name|j
operator|+
literal|'a'
operator|-
literal|10
operator|)
expr_stmt|;
block|}
return|return
name|hex
return|;
block|}
end_function
begin_function
DECL|function|q_fromPercentEncoding
specifier|static
name|void
name|q_fromPercentEncoding
parameter_list|(
name|QByteArray
modifier|*
name|ba
parameter_list|,
name|char
name|percent
parameter_list|)
block|{
if|if
condition|(
name|ba
operator|->
name|isEmpty
argument_list|()
condition|)
return|return;
name|char
modifier|*
name|data
init|=
name|ba
operator|->
name|data
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|inputPtr
init|=
name|data
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|ba
operator|->
name|count
argument_list|()
decl_stmt|;
name|int
name|outlen
init|=
literal|0
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|c
operator|=
name|inputPtr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|percent
operator|&&
name|i
operator|+
literal|2
operator|<
name|len
condition|)
block|{
name|a
operator|=
name|inputPtr
index|[
operator|++
name|i
index|]
expr_stmt|;
name|b
operator|=
name|inputPtr
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
name|a
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
name|a
operator|=
name|a
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'A'
operator|&&
name|a
operator|<=
literal|'F'
condition|)
name|a
operator|=
name|a
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|b
operator|>=
literal|'0'
operator|&&
name|b
operator|<=
literal|'9'
condition|)
name|b
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|>=
literal|'a'
operator|&&
name|b
operator|<=
literal|'f'
condition|)
name|b
operator|=
name|b
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|>=
literal|'A'
operator|&&
name|b
operator|<=
literal|'F'
condition|)
name|b
operator|=
name|b
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
operator|*
name|data
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|a
operator|<<
literal|4
operator|)
operator||
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|data
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
operator|++
name|outlen
expr_stmt|;
block|}
if|if
condition|(
name|outlen
operator|!=
name|len
condition|)
name|ba
operator|->
name|truncate
argument_list|(
name|outlen
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|q_fromPercentEncoding
name|void
name|q_fromPercentEncoding
parameter_list|(
name|QByteArray
modifier|*
name|ba
parameter_list|)
block|{
name|q_fromPercentEncoding
argument_list|(
name|ba
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns a decoded copy of the URI/URL-style percent-encoded \a input.     The \a percent parameter allows you to replace the '%' character for     another (for instance, '_' or '=').      For example:     \code         QByteArray text = QByteArray::fromPercentEncoding("Qt%20is%20great%33");         text.data();            // returns "Qt is great!"     \endcode      \sa toPercentEncoding(), QUrl::fromPercentEncoding() */
end_comment
begin_function
DECL|function|fromPercentEncoding
name|QByteArray
name|QByteArray
operator|::
name|fromPercentEncoding
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|input
parameter_list|,
name|char
name|percent
parameter_list|)
block|{
if|if
condition|(
name|input
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QByteArray
argument_list|()
return|;
comment|// preserve null
if|if
condition|(
name|input
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QByteArray
argument_list|(
name|input
operator|.
name|data
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
name|QByteArray
name|tmp
init|=
name|input
decl_stmt|;
name|q_fromPercentEncoding
argument_list|(
operator|&
name|tmp
argument_list|,
name|percent
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function
begin_function
DECL|function|q_strchr
specifier|static
specifier|inline
name|bool
name|q_strchr
parameter_list|(
specifier|const
name|char
name|str
index|[]
parameter_list|,
name|char
name|chr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|str
condition|)
return|return
literal|false
return|;
specifier|const
name|char
modifier|*
name|ptr
init|=
name|str
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|ptr
operator|++
operator|)
condition|)
if|if
condition|(
name|c
operator|==
name|chr
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|toHexHelper
specifier|static
specifier|inline
name|char
name|toHexHelper
parameter_list|(
name|char
name|c
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|hexnumbers
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
return|return
name|hexnumbers
index|[
name|c
operator|&
literal|0xf
index|]
return|;
block|}
end_function
begin_function
DECL|function|q_toPercentEncoding
specifier|static
name|void
name|q_toPercentEncoding
parameter_list|(
name|QByteArray
modifier|*
name|ba
parameter_list|,
specifier|const
name|char
modifier|*
name|dontEncode
parameter_list|,
specifier|const
name|char
modifier|*
name|alsoEncode
parameter_list|,
name|char
name|percent
parameter_list|)
block|{
if|if
condition|(
name|ba
operator|->
name|isEmpty
argument_list|()
condition|)
return|return;
name|QByteArray
name|input
init|=
operator|*
name|ba
decl_stmt|;
name|int
name|len
init|=
name|input
operator|.
name|count
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|inputData
init|=
name|input
operator|.
name|constData
argument_list|()
decl_stmt|;
name|char
modifier|*
name|output
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|inputData
operator|++
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|c
operator|>=
literal|0x61
operator|&&
name|c
operator|<=
literal|0x7A
operator|)
comment|// ALPHA
operator|||
operator|(
name|c
operator|>=
literal|0x41
operator|&&
name|c
operator|<=
literal|0x5A
operator|)
comment|// ALPHA
operator|||
operator|(
name|c
operator|>=
literal|0x30
operator|&&
name|c
operator|<=
literal|0x39
operator|)
comment|// DIGIT
operator|||
name|c
operator|==
literal|0x2D
comment|// -
operator|||
name|c
operator|==
literal|0x2E
comment|// .
operator|||
name|c
operator|==
literal|0x5F
comment|// _
operator|||
name|c
operator|==
literal|0x7E
comment|// ~
operator|||
name|q_strchr
argument_list|(
name|dontEncode
argument_list|,
name|c
argument_list|)
operator|)
operator|&&
operator|!
name|q_strchr
argument_list|(
name|alsoEncode
argument_list|,
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|output
condition|)
name|output
index|[
name|length
index|]
operator|=
name|c
expr_stmt|;
operator|++
name|length
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|output
condition|)
block|{
comment|// detach now
name|ba
operator|->
name|resize
argument_list|(
name|len
operator|*
literal|3
argument_list|)
expr_stmt|;
comment|// worst case
name|output
operator|=
name|ba
operator|->
name|data
argument_list|()
expr_stmt|;
block|}
name|output
index|[
name|length
operator|++
index|]
operator|=
name|percent
expr_stmt|;
name|output
index|[
name|length
operator|++
index|]
operator|=
name|toHexHelper
argument_list|(
operator|(
name|c
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|output
index|[
name|length
operator|++
index|]
operator|=
name|toHexHelper
argument_list|(
name|c
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|output
condition|)
name|ba
operator|->
name|truncate
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|q_toPercentEncoding
name|void
name|q_toPercentEncoding
parameter_list|(
name|QByteArray
modifier|*
name|ba
parameter_list|,
specifier|const
name|char
modifier|*
name|exclude
parameter_list|,
specifier|const
name|char
modifier|*
name|include
parameter_list|)
block|{
name|q_toPercentEncoding
argument_list|(
name|ba
argument_list|,
name|exclude
argument_list|,
name|include
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|q_normalizePercentEncoding
name|void
name|q_normalizePercentEncoding
parameter_list|(
name|QByteArray
modifier|*
name|ba
parameter_list|,
specifier|const
name|char
modifier|*
name|exclude
parameter_list|)
block|{
name|q_fromPercentEncoding
argument_list|(
name|ba
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
name|q_toPercentEncoding
argument_list|(
name|ba
argument_list|,
name|exclude
argument_list|,
literal|0
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns a URI/URL-style percent-encoded copy of this byte array. The     \a percent parameter allows you to override the default '%'     character for another.      By default, this function will encode all characters that are not     one of the following:          ALPHA ("a" to "z" and "A" to "Z") / DIGIT (0 to 9) / "-" / "." / "_" / "~"      To prevent characters from being encoded pass them to \a     exclude. To force characters to be encoded pass them to \a     include. The \a percent character is always encoded.      Example:      \code          QByteArray text = "{a fishy string?}";          QByteArray ba = text.toPercentEncoding("{}", "s");          qDebug(ba.constData());          // prints "{a fi%73hy %73tring%3F}"     \endcode      The hex encoding uses the numbers 0-9 and the uppercase letters A-F.      \sa fromPercentEncoding(), QUrl::toPercentEncoding() */
end_comment
begin_function
DECL|function|toPercentEncoding
name|QByteArray
name|QByteArray
operator|::
name|toPercentEncoding
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|exclude
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|include
parameter_list|,
name|char
name|percent
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|QByteArray
argument_list|()
return|;
comment|// preserve null
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
name|QByteArray
argument_list|(
name|data
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
name|QByteArray
name|include2
init|=
name|include
decl_stmt|;
if|if
condition|(
name|percent
operator|!=
literal|'%'
condition|)
comment|// the default
if|if
condition|(
operator|(
name|percent
operator|>=
literal|0x61
operator|&&
name|percent
operator|<=
literal|0x7A
operator|)
comment|// ALPHA
operator|||
operator|(
name|percent
operator|>=
literal|0x41
operator|&&
name|percent
operator|<=
literal|0x5A
operator|)
comment|// ALPHA
operator|||
operator|(
name|percent
operator|>=
literal|0x30
operator|&&
name|percent
operator|<=
literal|0x39
operator|)
comment|// DIGIT
operator|||
name|percent
operator|==
literal|0x2D
comment|// -
operator|||
name|percent
operator|==
literal|0x2E
comment|// .
operator|||
name|percent
operator|==
literal|0x5F
comment|// _
operator|||
name|percent
operator|==
literal|0x7E
condition|)
comment|// ~
name|include2
operator|+=
name|percent
expr_stmt|;
name|QByteArray
name|result
init|=
operator|*
name|this
decl_stmt|;
name|q_toPercentEncoding
argument_list|(
operator|&
name|result
argument_list|,
name|exclude
operator|.
name|nulTerminated
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|include2
operator|.
name|nulTerminated
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|percent
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*! \typedef QByteArray::ConstIterator     \internal */
end_comment
begin_comment
comment|/*! \typedef QByteArray::Iterator     \internal */
end_comment
begin_comment
comment|/*! \typedef QByteArray::const_iterator     \internal */
end_comment
begin_comment
comment|/*! \typedef QByteArray::iterator     \internal */
end_comment
begin_comment
comment|/*! \typedef QByteArray::const_reference     \internal */
end_comment
begin_comment
comment|/*! \typedef QByteArray::reference     \internal */
end_comment
begin_comment
comment|/*! \typedef QByteArray::value_type   \internal  */
end_comment
begin_comment
comment|/*!     \fn DataPtr&QByteArray::data_ptr()     \internal */
end_comment
begin_comment
comment|/*!     \typedef QByteArray::DataPtr     \internal */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
