begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 John Layt<jlayt@kde.org> ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtimezone.h"
end_include
begin_include
include|#
directive|include
file|"qtimezoneprivate_p.h"
end_include
begin_include
include|#
directive|include
file|"qtimezoneprivate_data_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|enum
type|{
DECL|enumerator|MSECS_TRAN_WINDOW
name|MSECS_TRAN_WINDOW
init|=
literal|21600000
end_decl_stmt
begin_comment
DECL|enumerator|MSECS_TRAN_WINDOW
comment|// 6 hour window for possible recent transitions
end_comment
begin_comment
unit|};
comment|/*     Static utilities for looking up Windows ID tables */
end_comment
begin_decl_stmt
DECL|variable|windowsDataTableSize
specifier|static
specifier|const
name|int
name|windowsDataTableSize
init|=
sizeof|sizeof
argument_list|(
name|windowsDataTable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|QWindowsData
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|zoneDataTableSize
specifier|static
specifier|const
name|int
name|zoneDataTableSize
init|=
sizeof|sizeof
argument_list|(
name|zoneDataTable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|QZoneData
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|utcDataTableSize
specifier|static
specifier|const
name|int
name|utcDataTableSize
init|=
sizeof|sizeof
argument_list|(
name|utcDataTable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|QUtcData
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|zoneData
specifier|static
specifier|const
name|QZoneData
modifier|*
name|zoneData
parameter_list|(
name|quint16
name|index
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|index
operator|<
name|zoneDataTableSize
argument_list|)
expr_stmt|;
return|return
operator|&
name|zoneDataTable
index|[
name|index
index|]
return|;
block|}
end_function
begin_function
DECL|function|windowsData
specifier|static
specifier|const
name|QWindowsData
modifier|*
name|windowsData
parameter_list|(
name|quint16
name|index
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|index
operator|<
name|windowsDataTableSize
argument_list|)
expr_stmt|;
return|return
operator|&
name|windowsDataTable
index|[
name|index
index|]
return|;
block|}
end_function
begin_function
DECL|function|utcData
specifier|static
specifier|const
name|QUtcData
modifier|*
name|utcData
parameter_list|(
name|quint16
name|index
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|index
operator|<
name|utcDataTableSize
argument_list|)
expr_stmt|;
return|return
operator|&
name|utcDataTable
index|[
name|index
index|]
return|;
block|}
end_function
begin_comment
comment|// Return the Windows ID literal for a given QWindowsData
end_comment
begin_function
DECL|function|windowsId
specifier|static
name|QByteArray
name|windowsId
parameter_list|(
specifier|const
name|QWindowsData
modifier|*
name|windowsData
parameter_list|)
block|{
return|return
operator|(
name|windowsIdData
operator|+
name|windowsData
operator|->
name|windowsIdIndex
operator|)
return|;
block|}
end_function
begin_comment
comment|// Return the Olsen ID literal for a given QWindowsData
end_comment
begin_function
DECL|function|olsenId
specifier|static
name|QByteArray
name|olsenId
parameter_list|(
specifier|const
name|QWindowsData
modifier|*
name|windowsData
parameter_list|)
block|{
return|return
operator|(
name|olsenIdData
operator|+
name|windowsData
operator|->
name|olsenIdIndex
operator|)
return|;
block|}
end_function
begin_comment
comment|// Return the Olsen ID literal for a given QZoneData
end_comment
begin_function
DECL|function|olsenId
specifier|static
name|QByteArray
name|olsenId
parameter_list|(
specifier|const
name|QZoneData
modifier|*
name|zoneData
parameter_list|)
block|{
return|return
operator|(
name|olsenIdData
operator|+
name|zoneData
operator|->
name|olsenIdIndex
operator|)
return|;
block|}
end_function
begin_function
DECL|function|utcId
specifier|static
name|QByteArray
name|utcId
parameter_list|(
specifier|const
name|QUtcData
modifier|*
name|utcData
parameter_list|)
block|{
return|return
operator|(
name|olsenIdData
operator|+
name|utcData
operator|->
name|olsenIdIndex
operator|)
return|;
block|}
end_function
begin_function
DECL|function|toWindowsIdKey
specifier|static
name|quint16
name|toWindowsIdKey
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|winId
parameter_list|)
block|{
for|for
control|(
name|quint16
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windowsDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QWindowsData
modifier|*
name|data
init|=
name|windowsData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|windowsId
argument_list|(
name|data
argument_list|)
operator|==
name|winId
condition|)
return|return
name|data
operator|->
name|windowsIdKey
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|toWindowsIdLiteral
specifier|static
name|QByteArray
name|toWindowsIdLiteral
parameter_list|(
name|quint16
name|windowsIdKey
parameter_list|)
block|{
for|for
control|(
name|quint16
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windowsDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QWindowsData
modifier|*
name|data
init|=
name|windowsData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|windowsIdKey
operator|==
name|windowsIdKey
condition|)
return|return
name|windowsId
argument_list|(
name|data
argument_list|)
return|;
block|}
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*     Base class implementing common utility routines, only intantiate for a null tz. */
end_comment
begin_constructor
DECL|function|QTimeZonePrivate
name|QTimeZonePrivate
operator|::
name|QTimeZonePrivate
parameter_list|()
block|{ }
end_constructor
begin_constructor
DECL|function|QTimeZonePrivate
name|QTimeZonePrivate
operator|::
name|QTimeZonePrivate
parameter_list|(
specifier|const
name|QTimeZonePrivate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|QSharedData
argument_list|(
name|other
argument_list|)
member_init_list|,
name|m_id
argument_list|(
name|other
operator|.
name|m_id
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QTimeZonePrivate
name|QTimeZonePrivate
operator|::
name|~
name|QTimeZonePrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|clone
name|QTimeZonePrivate
modifier|*
name|QTimeZonePrivate
operator|::
name|clone
parameter_list|()
block|{
return|return
operator|new
name|QTimeZonePrivate
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|operator ==
name|bool
name|QTimeZonePrivate
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QTimeZonePrivate
modifier|&
name|other
parameter_list|)
specifier|const
block|{
comment|// TODO Too simple, but need to solve problem of comparing different derived classes
comment|// Should work for all System and ICU classes as names guaranteed unique, but not for Simple.
comment|// Perhaps once all classes have working transitions can compare full list?
return|return
operator|(
name|m_id
operator|==
name|other
operator|.
name|m_id
operator|)
return|;
block|}
end_function
begin_function
DECL|function|operator !=
name|bool
name|QTimeZonePrivate
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QTimeZonePrivate
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|other
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isValid
name|bool
name|QTimeZonePrivate
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|m_id
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|id
name|QByteArray
name|QTimeZonePrivate
operator|::
name|id
parameter_list|()
specifier|const
block|{
return|return
name|m_id
return|;
block|}
end_function
begin_function
DECL|function|country
name|QLocale
operator|::
name|Country
name|QTimeZonePrivate
operator|::
name|country
parameter_list|()
specifier|const
block|{
comment|// Default fall-back mode, use the zoneTable to find Region of known Zones
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zoneDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QZoneData
modifier|*
name|data
init|=
name|zoneData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|olsenId
argument_list|(
name|data
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
operator|.
name|contains
argument_list|(
name|m_id
argument_list|)
condition|)
return|return
operator|(
name|QLocale
operator|::
name|Country
operator|)
name|data
operator|->
name|country
return|;
block|}
return|return
name|QLocale
operator|::
name|AnyCountry
return|;
block|}
end_function
begin_function
DECL|function|comment
name|QString
name|QTimeZonePrivate
operator|::
name|comment
parameter_list|()
specifier|const
block|{
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|displayName
name|QString
name|QTimeZonePrivate
operator|::
name|displayName
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|,
name|QTimeZone
operator|::
name|NameType
name|nameType
parameter_list|,
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|nameType
operator|==
name|QTimeZone
operator|::
name|OffsetName
condition|)
return|return
name|isoOffsetFormat
argument_list|(
name|offsetFromUtc
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|isDaylightTime
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
condition|)
return|return
name|displayName
argument_list|(
name|QTimeZone
operator|::
name|DaylightTime
argument_list|,
name|nameType
argument_list|,
name|locale
argument_list|)
return|;
else|else
return|return
name|displayName
argument_list|(
name|QTimeZone
operator|::
name|StandardTime
argument_list|,
name|nameType
argument_list|,
name|locale
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|displayName
name|QString
name|QTimeZonePrivate
operator|::
name|displayName
parameter_list|(
name|QTimeZone
operator|::
name|TimeType
name|timeType
parameter_list|,
name|QTimeZone
operator|::
name|NameType
name|nameType
parameter_list|,
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|timeType
argument_list|)
name|Q_UNUSED
argument_list|(
argument|nameType
argument_list|)
name|Q_UNUSED
argument_list|(
argument|locale
argument_list|)
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|abbreviation
name|QString
name|QTimeZonePrivate
operator|::
name|abbreviation
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|offsetFromUtc
name|int
name|QTimeZonePrivate
operator|::
name|offsetFromUtc
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
return|return
name|standardTimeOffset
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
operator|+
name|daylightTimeOffset
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|standardTimeOffset
name|int
name|QTimeZonePrivate
operator|::
name|standardTimeOffset
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
name|invalidSeconds
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|daylightTimeOffset
name|int
name|QTimeZonePrivate
operator|::
name|daylightTimeOffset
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
name|invalidSeconds
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|hasDaylightTime
name|bool
name|QTimeZonePrivate
operator|::
name|hasDaylightTime
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|isDaylightTime
name|bool
name|QTimeZonePrivate
operator|::
name|isDaylightTime
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|data
name|QTimeZonePrivate
operator|::
name|Data
name|QTimeZonePrivate
operator|::
name|data
parameter_list|(
name|qint64
name|forMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|forMSecsSinceEpoch
argument_list|)
return|return
name|invalidData
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// Private only method for use by QDateTime to convert local msecs to epoch msecs
end_comment
begin_comment
comment|// TODO Could be platform optimised if needed
end_comment
begin_function
DECL|function|dataForLocalTime
name|QTimeZonePrivate
operator|::
name|Data
name|QTimeZonePrivate
operator|::
name|dataForLocalTime
parameter_list|(
name|qint64
name|forLocalMSecs
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|hasDaylightTime
argument_list|()
operator|||
operator|!
name|hasTransitions
argument_list|()
condition|)
block|{
comment|// No daylight time means same offset for all local msecs
comment|// Having daylight time but no transitions means we can't calculate, so use nearest
return|return
name|data
argument_list|(
name|forLocalMSecs
operator|-
operator|(
name|standardTimeOffset
argument_list|(
name|forLocalMSecs
argument_list|)
operator|*
literal|1000
operator|)
argument_list|)
return|;
block|}
comment|// Get the transition for the local msecs which most of the time should be the right one
comment|// Only around the transition times might it not be the right one
name|Data
name|tran
init|=
name|previousTransition
argument_list|(
name|forLocalMSecs
argument_list|)
decl_stmt|;
name|Data
name|nextTran
decl_stmt|;
comment|// If the local msecs is less than the real local time of the transition
comment|// then get the previous transition to use instead
if|if
condition|(
name|forLocalMSecs
operator|<
name|tran
operator|.
name|atMSecsSinceEpoch
operator|+
operator|(
name|tran
operator|.
name|offsetFromUtc
operator|*
literal|1000
operator|)
condition|)
block|{
while|while
condition|(
name|tran
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
operator|&&
name|forLocalMSecs
operator|<
name|tran
operator|.
name|atMSecsSinceEpoch
operator|+
operator|(
name|tran
operator|.
name|offsetFromUtc
operator|*
literal|1000
operator|)
condition|)
block|{
name|nextTran
operator|=
name|tran
expr_stmt|;
name|tran
operator|=
name|previousTransition
argument_list|(
name|tran
operator|.
name|atMSecsSinceEpoch
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// The zone msecs is after the transition, so check it is before the next tran
comment|// If not try use the next transition instead
name|nextTran
operator|=
name|nextTransition
argument_list|(
name|tran
operator|.
name|atMSecsSinceEpoch
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextTran
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
operator|&&
name|forLocalMSecs
operator|>=
name|nextTran
operator|.
name|atMSecsSinceEpoch
operator|+
operator|(
name|nextTran
operator|.
name|offsetFromUtc
operator|*
literal|1000
operator|)
condition|)
block|{
name|tran
operator|=
name|nextTran
expr_stmt|;
name|nextTran
operator|=
name|nextTransition
argument_list|(
name|tran
operator|.
name|atMSecsSinceEpoch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tran
operator|.
name|daylightTimeOffset
operator|==
literal|0
condition|)
block|{
comment|// If tran is in StandardTime, then need to check if falls close either daylight transition
comment|// If it does, then it may need adjusting for missing hour or for second occurrence
name|qint64
name|diffPrevTran
init|=
name|forLocalMSecs
operator|-
operator|(
name|tran
operator|.
name|atMSecsSinceEpoch
operator|+
operator|(
name|tran
operator|.
name|offsetFromUtc
operator|*
literal|1000
operator|)
operator|)
decl_stmt|;
name|qint64
name|diffNextTran
init|=
name|nextTran
operator|.
name|atMSecsSinceEpoch
operator|+
operator|(
name|nextTran
operator|.
name|offsetFromUtc
operator|*
literal|1000
operator|)
operator|-
name|forLocalMSecs
decl_stmt|;
if|if
condition|(
name|diffPrevTran
operator|>=
literal|0
operator|&&
name|diffPrevTran
operator|<
name|MSECS_TRAN_WINDOW
condition|)
block|{
comment|// If tran picked is for standard time check if changed from daylight in last 6 hours,
comment|// as the local msecs may be ambiguous and represent two valid utc msecs.
comment|// If in last 6 hours then get prev tran and if diff falls within the daylight offset
comment|// then use the prev tran as we default to the FirstOccurrence
comment|// TODO Check if faster to just always get prev tran, or if faster using 6 hour check.
name|Data
name|dstTran
init|=
name|previousTransition
argument_list|(
name|tran
operator|.
name|atMSecsSinceEpoch
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstTran
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
operator|&&
name|dstTran
operator|.
name|daylightTimeOffset
operator|>
literal|0
operator|&&
name|diffPrevTran
operator|<
operator|(
name|dstTran
operator|.
name|daylightTimeOffset
operator|*
literal|1000
operator|)
condition|)
name|tran
operator|=
name|dstTran
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diffNextTran
operator|>=
literal|0
operator|&&
name|diffNextTran
operator|<=
operator|(
name|nextTran
operator|.
name|daylightTimeOffset
operator|*
literal|1000
operator|)
condition|)
block|{
comment|// If time falls within last hour of standard time then is actually the missing hour
comment|// So return the next tran instead and adjust the local time to be valid
name|tran
operator|=
name|nextTran
expr_stmt|;
name|forLocalMSecs
operator|=
name|forLocalMSecs
operator|+
operator|(
name|nextTran
operator|.
name|daylightTimeOffset
operator|*
literal|1000
operator|)
expr_stmt|;
block|}
block|}
comment|// tran should now hold the right transition offset to use
name|tran
operator|.
name|atMSecsSinceEpoch
operator|=
name|forLocalMSecs
operator|-
operator|(
name|tran
operator|.
name|offsetFromUtc
operator|*
literal|1000
operator|)
expr_stmt|;
return|return
name|tran
return|;
block|}
end_function
begin_function
DECL|function|hasTransitions
name|bool
name|QTimeZonePrivate
operator|::
name|hasTransitions
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|nextTransition
name|QTimeZonePrivate
operator|::
name|Data
name|QTimeZonePrivate
operator|::
name|nextTransition
parameter_list|(
name|qint64
name|afterMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|afterMSecsSinceEpoch
argument_list|)
return|return
name|invalidData
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|previousTransition
name|QTimeZonePrivate
operator|::
name|Data
name|QTimeZonePrivate
operator|::
name|previousTransition
parameter_list|(
name|qint64
name|beforeMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|beforeMSecsSinceEpoch
argument_list|)
return|return
name|invalidData
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|transitions
name|QTimeZonePrivate
operator|::
name|DataList
name|QTimeZonePrivate
operator|::
name|transitions
parameter_list|(
name|qint64
name|fromMSecsSinceEpoch
parameter_list|,
name|qint64
name|toMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|DataList
name|list
decl_stmt|;
if|if
condition|(
name|toMSecsSinceEpoch
operator|>=
name|fromMSecsSinceEpoch
condition|)
block|{
comment|// fromMSecsSinceEpoch is inclusive but nextTransitionTime() is exclusive so go back 1 msec
name|Data
name|next
init|=
name|nextTransition
argument_list|(
name|fromMSecsSinceEpoch
operator|-
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
name|next
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
operator|&&
name|next
operator|.
name|atMSecsSinceEpoch
operator|<=
name|toMSecsSinceEpoch
condition|)
block|{
name|list
operator|.
name|append
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|nextTransition
argument_list|(
name|next
operator|.
name|atMSecsSinceEpoch
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|systemTimeZoneId
name|QByteArray
name|QTimeZonePrivate
operator|::
name|systemTimeZoneId
parameter_list|()
specifier|const
block|{
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|QTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|()
specifier|const
block|{
return|return
name|QSet
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|QTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|(
name|QLocale
operator|::
name|Country
name|country
parameter_list|)
specifier|const
block|{
comment|// Default fall-back mode, use the zoneTable to find Region of know Zones
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|regionSet
decl_stmt|;
comment|// First get all Zones in the Zones table belonging to the Region
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zoneDataTableSize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|zoneData
argument_list|(
name|i
argument_list|)
operator|->
name|country
operator|==
name|country
condition|)
name|regionSet
operator|+=
name|olsenId
argument_list|(
name|zoneData
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
operator|.
name|toSet
argument_list|()
expr_stmt|;
block|}
comment|// Then select just those that are available
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|set
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|olsenId
decl|,
name|availableTimeZoneIds
argument_list|()
control|)
block|{
if|if
condition|(
name|regionSet
operator|.
name|contains
argument_list|(
name|olsenId
argument_list|)
condition|)
name|set
operator|<<
name|olsenId
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|QTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|(
name|int
name|offsetFromUtc
parameter_list|)
specifier|const
block|{
comment|// Default fall-back mode, use the zoneTable to find Offset of know Zones
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|offsetSet
decl_stmt|;
comment|// First get all Zones in the table using the Offset
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windowsDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QWindowsData
modifier|*
name|winData
init|=
name|windowsData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|winData
operator|->
name|offsetFromUtc
operator|==
name|offsetFromUtc
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|zoneDataTableSize
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|QZoneData
modifier|*
name|data
init|=
name|zoneData
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|windowsIdKey
operator|==
name|winData
operator|->
name|windowsIdKey
condition|)
name|offsetSet
operator|+=
name|olsenId
argument_list|(
name|data
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
operator|.
name|toSet
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Then select just those that are available
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|set
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|olsenId
decl|,
name|availableTimeZoneIds
argument_list|()
control|)
block|{
if|if
condition|(
name|offsetSet
operator|.
name|contains
argument_list|(
name|olsenId
argument_list|)
condition|)
name|set
operator|<<
name|olsenId
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_function
DECL|function|serialize
name|void
name|QTimeZonePrivate
operator|::
name|serialize
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|)
specifier|const
block|{
name|ds
operator|<<
name|QString
operator|::
name|fromUtf8
argument_list|(
name|m_id
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|// Static Utility Methods
end_comment
begin_function
DECL|function|invalidData
name|QTimeZonePrivate
operator|::
name|Data
name|QTimeZonePrivate
operator|::
name|invalidData
parameter_list|()
block|{
name|Data
name|data
decl_stmt|;
name|data
operator|.
name|atMSecsSinceEpoch
operator|=
name|invalidMSecs
argument_list|()
expr_stmt|;
name|data
operator|.
name|offsetFromUtc
operator|=
name|invalidSeconds
argument_list|()
expr_stmt|;
name|data
operator|.
name|standardTimeOffset
operator|=
name|invalidSeconds
argument_list|()
expr_stmt|;
name|data
operator|.
name|daylightTimeOffset
operator|=
name|invalidSeconds
argument_list|()
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_function
DECL|function|invalidOffsetData
name|QTimeZone
operator|::
name|OffsetData
name|QTimeZonePrivate
operator|::
name|invalidOffsetData
parameter_list|()
block|{
name|QTimeZone
operator|::
name|OffsetData
name|offsetData
decl_stmt|;
name|offsetData
operator|.
name|atUtc
operator|=
name|QDateTime
argument_list|()
expr_stmt|;
name|offsetData
operator|.
name|offsetFromUtc
operator|=
name|invalidSeconds
argument_list|()
expr_stmt|;
name|offsetData
operator|.
name|standardTimeOffset
operator|=
name|invalidSeconds
argument_list|()
expr_stmt|;
name|offsetData
operator|.
name|daylightTimeOffset
operator|=
name|invalidSeconds
argument_list|()
expr_stmt|;
return|return
name|offsetData
return|;
block|}
end_function
begin_function
DECL|function|toOffsetData
name|QTimeZone
operator|::
name|OffsetData
name|QTimeZonePrivate
operator|::
name|toOffsetData
parameter_list|(
specifier|const
name|QTimeZonePrivate
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
name|QTimeZone
operator|::
name|OffsetData
name|offsetData
init|=
name|invalidOffsetData
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
condition|)
block|{
name|offsetData
operator|.
name|atUtc
operator|=
name|QDateTime
operator|::
name|fromMSecsSinceEpoch
argument_list|(
name|data
operator|.
name|atMSecsSinceEpoch
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
expr_stmt|;
name|offsetData
operator|.
name|offsetFromUtc
operator|=
name|data
operator|.
name|offsetFromUtc
expr_stmt|;
name|offsetData
operator|.
name|standardTimeOffset
operator|=
name|data
operator|.
name|standardTimeOffset
expr_stmt|;
name|offsetData
operator|.
name|daylightTimeOffset
operator|=
name|data
operator|.
name|daylightTimeOffset
expr_stmt|;
name|offsetData
operator|.
name|abbreviation
operator|=
name|data
operator|.
name|abbreviation
expr_stmt|;
block|}
return|return
name|offsetData
return|;
block|}
end_function
begin_comment
comment|// If the format of the ID is valid
end_comment
begin_function
DECL|function|isValidId
name|bool
name|QTimeZonePrivate
operator|::
name|isValidId
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|olsenId
parameter_list|)
block|{
comment|// Rules for defining TZ/Olsen names as per ftp://ftp.iana.org/tz/code/Theory
comment|// * Use only valid POSIX file name components
comment|// * Within a file name component, use only ASCII letters, `.', `-' and `_'.
comment|// * Do not use digits
comment|// * A file name component must not exceed 14 characters or start with `-'
comment|// Aliases such as "Etc/GMT+7" and "SystemV/EST5EDT" are valid so we need to accept digits
if|if
condition|(
name|olsenId
operator|.
name|contains
argument_list|(
literal|' '
argument_list|)
condition|)
return|return
literal|false
return|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|parts
init|=
name|olsenId
operator|.
name|split
argument_list|(
literal|'\\'
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|part
decl|,
name|parts
control|)
block|{
if|if
condition|(
name|part
operator|.
name|size
argument_list|()
operator|>
literal|14
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|part
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'-'
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|part
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|ch
init|=
name|part
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
operator|)
operator|&&
operator|!
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
operator|)
operator|&&
operator|!
operator|(
name|ch
operator|==
literal|'_'
operator|)
operator|&&
operator|!
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|&&
operator|!
operator|(
name|ch
operator|==
literal|'-'
operator|)
operator|&&
operator|!
operator|(
name|ch
operator|==
literal|'.'
operator|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|isoOffsetFormat
name|QString
name|QTimeZonePrivate
operator|::
name|isoOffsetFormat
parameter_list|(
name|int
name|offsetFromUtc
parameter_list|)
block|{
specifier|const
name|int
name|mins
init|=
name|offsetFromUtc
operator|/
literal|60
decl_stmt|;
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"UTC%1%2:%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|mins
operator|>=
literal|0
condition|?
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
else|:
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|qAbs
argument_list|(
name|mins
argument_list|)
operator|/
literal|60
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|qAbs
argument_list|(
name|mins
argument_list|)
operator|%
literal|60
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ianaIdToWindowsId
name|QByteArray
name|QTimeZonePrivate
operator|::
name|ianaIdToWindowsId
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|id
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zoneDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QZoneData
modifier|*
name|data
init|=
name|zoneData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|olsenId
argument_list|(
name|data
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
operator|.
name|contains
argument_list|(
name|id
argument_list|)
condition|)
return|return
name|toWindowsIdLiteral
argument_list|(
name|data
operator|->
name|windowsIdKey
argument_list|)
return|;
block|}
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|windowsIdToDefaultIanaId
name|QByteArray
name|QTimeZonePrivate
operator|::
name|windowsIdToDefaultIanaId
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|windowsId
parameter_list|)
block|{
specifier|const
name|quint16
name|windowsIdKey
init|=
name|toWindowsIdKey
argument_list|(
name|windowsId
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windowsDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QWindowsData
modifier|*
name|data
init|=
name|windowsData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|windowsIdKey
operator|==
name|windowsIdKey
condition|)
return|return
name|olsenId
argument_list|(
name|data
argument_list|)
return|;
block|}
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|windowsIdToDefaultIanaId
name|QByteArray
name|QTimeZonePrivate
operator|::
name|windowsIdToDefaultIanaId
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|windowsId
parameter_list|,
name|QLocale
operator|::
name|Country
name|country
parameter_list|)
block|{
specifier|const
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
init|=
name|windowsIdToIanaIds
argument_list|(
name|windowsId
argument_list|,
name|country
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
return|return
name|list
operator|.
name|first
argument_list|()
return|;
else|else
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|windowsIdToIanaIds
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QTimeZonePrivate
operator|::
name|windowsIdToIanaIds
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|windowsId
parameter_list|)
block|{
specifier|const
name|quint16
name|windowsIdKey
init|=
name|toWindowsIdKey
argument_list|(
name|windowsId
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zoneDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QZoneData
modifier|*
name|data
init|=
name|zoneData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|windowsIdKey
operator|==
name|windowsIdKey
condition|)
name|list
operator|<<
name|olsenId
argument_list|(
name|data
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|// Return the full list in alpha order
name|std
operator|::
name|sort
argument_list|(
name|list
operator|.
name|begin
argument_list|()
argument_list|,
name|list
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|windowsIdToIanaIds
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QTimeZonePrivate
operator|::
name|windowsIdToIanaIds
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|windowsId
parameter_list|,
name|QLocale
operator|::
name|Country
name|country
parameter_list|)
block|{
specifier|const
name|quint16
name|windowsIdKey
init|=
name|toWindowsIdKey
argument_list|(
name|windowsId
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zoneDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QZoneData
modifier|*
name|data
init|=
name|zoneData
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Return the region matches in preference order
if|if
condition|(
name|data
operator|->
name|windowsIdKey
operator|==
name|windowsIdKey
operator|&&
name|data
operator|->
name|country
operator|==
operator|(
name|quint16
operator|)
name|country
condition|)
return|return
name|olsenId
argument_list|(
name|data
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
return|;
block|}
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// Define template for derived classes to reimplement so QSharedDataPointer clone() works correctly
end_comment
begin_function
DECL|function|clone
template|template
parameter_list|<>
name|QTimeZonePrivate
modifier|*
name|QSharedDataPointer
argument_list|<
name|QTimeZonePrivate
argument_list|>
operator|::
name|clone
parameter_list|()
block|{
return|return
name|d
operator|->
name|clone
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*     UTC Offset implementation, used when QT_NO_SYSTEMLOCALE set and QT_USE_ICU not set,     or for QDateTimes with a Qt:Spec of Qt::OffsetFromUtc. */
end_comment
begin_comment
comment|// Create default UTC time zone
end_comment
begin_constructor
DECL|function|QUtcTimeZonePrivate
name|QUtcTimeZonePrivate
operator|::
name|QUtcTimeZonePrivate
parameter_list|()
block|{
specifier|const
name|QString
name|name
init|=
name|QStringLiteral
argument_list|(
literal|"UTC"
argument_list|)
decl_stmt|;
name|init
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"UTC"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|QLocale
operator|::
name|AnyCountry
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|// Create a named UTC time zone
end_comment
begin_constructor
DECL|function|QUtcTimeZonePrivate
name|QUtcTimeZonePrivate
operator|::
name|QUtcTimeZonePrivate
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|id
parameter_list|)
block|{
comment|// Look for the name in the UTC list, if found set the values
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|utcDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QUtcData
modifier|*
name|data
init|=
name|utcData
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|QByteArray
name|uid
init|=
name|utcId
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|uid
operator|==
name|id
condition|)
block|{
name|QString
name|name
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|init
argument_list|(
name|id
argument_list|,
name|data
operator|->
name|offsetFromUtc
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|QLocale
operator|::
name|AnyCountry
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_constructor
begin_comment
comment|// Create offset from UTC
end_comment
begin_constructor
DECL|function|QUtcTimeZonePrivate
name|QUtcTimeZonePrivate
operator|::
name|QUtcTimeZonePrivate
parameter_list|(
name|qint32
name|offsetSeconds
parameter_list|)
block|{
name|QString
name|utcId
decl_stmt|;
if|if
condition|(
name|offsetSeconds
operator|==
literal|0
condition|)
name|utcId
operator|=
name|QStringLiteral
argument_list|(
literal|"UTC"
argument_list|)
expr_stmt|;
else|else
name|utcId
operator|=
name|isoOffsetFormat
argument_list|(
name|offsetSeconds
argument_list|)
expr_stmt|;
name|init
argument_list|(
name|utcId
operator|.
name|toUtf8
argument_list|()
argument_list|,
name|offsetSeconds
argument_list|,
name|utcId
argument_list|,
name|utcId
argument_list|,
name|QLocale
operator|::
name|AnyCountry
argument_list|,
name|utcId
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QUtcTimeZonePrivate
name|QUtcTimeZonePrivate
operator|::
name|QUtcTimeZonePrivate
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|zoneId
parameter_list|,
name|int
name|offsetSeconds
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|abbreviation
parameter_list|,
name|QLocale
operator|::
name|Country
name|country
parameter_list|,
specifier|const
name|QString
modifier|&
name|comment
parameter_list|)
block|{
name|init
argument_list|(
name|zoneId
argument_list|,
name|offsetSeconds
argument_list|,
name|name
argument_list|,
name|abbreviation
argument_list|,
name|country
argument_list|,
name|comment
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QUtcTimeZonePrivate
name|QUtcTimeZonePrivate
operator|::
name|QUtcTimeZonePrivate
parameter_list|(
specifier|const
name|QUtcTimeZonePrivate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|QTimeZonePrivate
argument_list|(
name|other
argument_list|)
member_init_list|,
name|m_offsetFromUtc
argument_list|(
name|other
operator|.
name|m_offsetFromUtc
argument_list|)
member_init_list|,
name|m_name
argument_list|(
name|other
operator|.
name|m_name
argument_list|)
member_init_list|,
name|m_abbreviation
argument_list|(
name|other
operator|.
name|m_abbreviation
argument_list|)
member_init_list|,
name|m_country
argument_list|(
name|other
operator|.
name|m_country
argument_list|)
member_init_list|,
name|m_comment
argument_list|(
name|other
operator|.
name|m_comment
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QUtcTimeZonePrivate
name|QUtcTimeZonePrivate
operator|::
name|~
name|QUtcTimeZonePrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|clone
name|QTimeZonePrivate
modifier|*
name|QUtcTimeZonePrivate
operator|::
name|clone
parameter_list|()
block|{
return|return
operator|new
name|QUtcTimeZonePrivate
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QUtcTimeZonePrivate
operator|::
name|init
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|zoneId
parameter_list|)
block|{
name|m_id
operator|=
name|zoneId
expr_stmt|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QUtcTimeZonePrivate
operator|::
name|init
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|zoneId
parameter_list|,
name|int
name|offsetSeconds
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|abbreviation
parameter_list|,
name|QLocale
operator|::
name|Country
name|country
parameter_list|,
specifier|const
name|QString
modifier|&
name|comment
parameter_list|)
block|{
name|m_id
operator|=
name|zoneId
expr_stmt|;
name|m_offsetFromUtc
operator|=
name|offsetSeconds
expr_stmt|;
name|m_name
operator|=
name|name
expr_stmt|;
name|m_abbreviation
operator|=
name|abbreviation
expr_stmt|;
name|m_country
operator|=
name|country
expr_stmt|;
name|m_comment
operator|=
name|comment
expr_stmt|;
block|}
end_function
begin_function
DECL|function|country
name|QLocale
operator|::
name|Country
name|QUtcTimeZonePrivate
operator|::
name|country
parameter_list|()
specifier|const
block|{
return|return
name|m_country
return|;
block|}
end_function
begin_function
DECL|function|comment
name|QString
name|QUtcTimeZonePrivate
operator|::
name|comment
parameter_list|()
specifier|const
block|{
return|return
name|m_comment
return|;
block|}
end_function
begin_function
DECL|function|displayName
name|QString
name|QUtcTimeZonePrivate
operator|::
name|displayName
parameter_list|(
name|QTimeZone
operator|::
name|TimeType
name|timeType
parameter_list|,
name|QTimeZone
operator|::
name|NameType
name|nameType
parameter_list|,
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|timeType
argument_list|)
name|Q_UNUSED
argument_list|(
argument|locale
argument_list|)
if|if
condition|(
name|nameType
operator|==
name|QTimeZone
operator|::
name|ShortName
condition|)
return|return
name|m_abbreviation
return|;
elseif|else
if|if
condition|(
name|nameType
operator|==
name|QTimeZone
operator|::
name|OffsetName
condition|)
return|return
name|isoOffsetFormat
argument_list|(
name|m_offsetFromUtc
argument_list|)
return|;
return|return
name|m_name
return|;
block|}
end_function
begin_function
DECL|function|abbreviation
name|QString
name|QUtcTimeZonePrivate
operator|::
name|abbreviation
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
name|m_abbreviation
return|;
block|}
end_function
begin_function
DECL|function|standardTimeOffset
name|qint32
name|QUtcTimeZonePrivate
operator|::
name|standardTimeOffset
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
name|m_offsetFromUtc
return|;
block|}
end_function
begin_function
DECL|function|daylightTimeOffset
name|qint32
name|QUtcTimeZonePrivate
operator|::
name|daylightTimeOffset
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|systemTimeZoneId
name|QByteArray
name|QUtcTimeZonePrivate
operator|::
name|systemTimeZoneId
parameter_list|()
specifier|const
block|{
return|return
name|QByteArrayLiteral
argument_list|(
literal|"UTC"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|QUtcTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|()
specifier|const
block|{
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|set
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|utcDataTableSize
condition|;
operator|++
name|i
control|)
name|set
operator|<<
name|utcId
argument_list|(
name|utcData
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|QUtcTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|(
name|QLocale
operator|::
name|Country
name|country
parameter_list|)
specifier|const
block|{
comment|// If AnyCountry then is request for all non-region offset codes
if|if
condition|(
name|country
operator|==
name|QLocale
operator|::
name|AnyCountry
condition|)
return|return
name|availableTimeZoneIds
argument_list|()
return|;
return|return
name|QSet
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|QUtcTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|(
name|qint32
name|offsetSeconds
parameter_list|)
specifier|const
block|{
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|set
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|utcDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QUtcData
modifier|*
name|data
init|=
name|utcData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|offsetFromUtc
operator|==
name|offsetSeconds
condition|)
name|set
operator|<<
name|utcId
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_function
DECL|function|serialize
name|void
name|QUtcTimeZonePrivate
operator|::
name|serialize
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|)
specifier|const
block|{
name|ds
operator|<<
name|QStringLiteral
argument_list|(
literal|"OffsetFromUtc"
argument_list|)
operator|<<
name|QString
operator|::
name|fromUtf8
argument_list|(
name|m_id
argument_list|)
operator|<<
name|m_offsetFromUtc
operator|<<
name|m_name
operator|<<
name|m_abbreviation
operator|<<
operator|(
name|qint32
operator|)
name|m_country
operator|<<
name|m_comment
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
