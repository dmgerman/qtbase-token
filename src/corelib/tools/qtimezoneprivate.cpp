begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 John Layt<jlayt@kde.org> ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtimezone.h"
end_include
begin_include
include|#
directive|include
file|"qtimezoneprivate_p.h"
end_include
begin_include
include|#
directive|include
file|"qtimezoneprivate_data_p.h"
end_include
begin_include
include|#
directive|include
file|<qdatastream.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|enum
type|{
DECL|enumerator|MSECS_TRAN_WINDOW
name|MSECS_TRAN_WINDOW
init|=
literal|21600000
end_decl_stmt
begin_comment
DECL|enumerator|MSECS_TRAN_WINDOW
comment|// 6 hour window for possible recent transitions
end_comment
begin_comment
unit|};
comment|/*     Static utilities for looking up Windows ID tables */
end_comment
begin_decl_stmt
DECL|variable|windowsDataTableSize
specifier|static
specifier|const
name|int
name|windowsDataTableSize
init|=
sizeof|sizeof
argument_list|(
name|windowsDataTable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|QWindowsData
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|zoneDataTableSize
specifier|static
specifier|const
name|int
name|zoneDataTableSize
init|=
sizeof|sizeof
argument_list|(
name|zoneDataTable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|QZoneData
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|utcDataTableSize
specifier|static
specifier|const
name|int
name|utcDataTableSize
init|=
sizeof|sizeof
argument_list|(
name|utcDataTable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|QUtcData
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|zoneData
specifier|static
specifier|const
name|QZoneData
modifier|*
name|zoneData
parameter_list|(
name|quint16
name|index
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|index
operator|<
name|zoneDataTableSize
argument_list|)
expr_stmt|;
return|return
operator|&
name|zoneDataTable
index|[
name|index
index|]
return|;
block|}
end_function
begin_function
DECL|function|windowsData
specifier|static
specifier|const
name|QWindowsData
modifier|*
name|windowsData
parameter_list|(
name|quint16
name|index
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|index
operator|<
name|windowsDataTableSize
argument_list|)
expr_stmt|;
return|return
operator|&
name|windowsDataTable
index|[
name|index
index|]
return|;
block|}
end_function
begin_function
DECL|function|utcData
specifier|static
specifier|const
name|QUtcData
modifier|*
name|utcData
parameter_list|(
name|quint16
name|index
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|index
operator|<
name|utcDataTableSize
argument_list|)
expr_stmt|;
return|return
operator|&
name|utcDataTable
index|[
name|index
index|]
return|;
block|}
end_function
begin_comment
comment|// Return the Windows ID literal for a given QWindowsData
end_comment
begin_function
DECL|function|windowsId
specifier|static
name|QByteArray
name|windowsId
parameter_list|(
specifier|const
name|QWindowsData
modifier|*
name|windowsData
parameter_list|)
block|{
return|return
operator|(
name|windowsIdData
operator|+
name|windowsData
operator|->
name|windowsIdIndex
operator|)
return|;
block|}
end_function
begin_comment
comment|// Return the IANA ID literal for a given QWindowsData
end_comment
begin_function
DECL|function|ianaId
specifier|static
name|QByteArray
name|ianaId
parameter_list|(
specifier|const
name|QWindowsData
modifier|*
name|windowsData
parameter_list|)
block|{
return|return
operator|(
name|ianaIdData
operator|+
name|windowsData
operator|->
name|ianaIdIndex
operator|)
return|;
block|}
end_function
begin_comment
comment|// Return the IANA ID literal for a given QZoneData
end_comment
begin_function
DECL|function|ianaId
specifier|static
name|QByteArray
name|ianaId
parameter_list|(
specifier|const
name|QZoneData
modifier|*
name|zoneData
parameter_list|)
block|{
return|return
operator|(
name|ianaIdData
operator|+
name|zoneData
operator|->
name|ianaIdIndex
operator|)
return|;
block|}
end_function
begin_function
DECL|function|utcId
specifier|static
name|QByteArray
name|utcId
parameter_list|(
specifier|const
name|QUtcData
modifier|*
name|utcData
parameter_list|)
block|{
return|return
operator|(
name|ianaIdData
operator|+
name|utcData
operator|->
name|ianaIdIndex
operator|)
return|;
block|}
end_function
begin_function
DECL|function|toWindowsIdKey
specifier|static
name|quint16
name|toWindowsIdKey
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|winId
parameter_list|)
block|{
for|for
control|(
name|quint16
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windowsDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QWindowsData
modifier|*
name|data
init|=
name|windowsData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|windowsId
argument_list|(
name|data
argument_list|)
operator|==
name|winId
condition|)
return|return
name|data
operator|->
name|windowsIdKey
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|toWindowsIdLiteral
specifier|static
name|QByteArray
name|toWindowsIdLiteral
parameter_list|(
name|quint16
name|windowsIdKey
parameter_list|)
block|{
for|for
control|(
name|quint16
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windowsDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QWindowsData
modifier|*
name|data
init|=
name|windowsData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|windowsIdKey
operator|==
name|windowsIdKey
condition|)
return|return
name|windowsId
argument_list|(
name|data
argument_list|)
return|;
block|}
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*     Base class implementing common utility routines, only intantiate for a null tz. */
end_comment
begin_constructor
DECL|function|QTimeZonePrivate
name|QTimeZonePrivate
operator|::
name|QTimeZonePrivate
parameter_list|()
block|{ }
end_constructor
begin_constructor
DECL|function|QTimeZonePrivate
name|QTimeZonePrivate
operator|::
name|QTimeZonePrivate
parameter_list|(
specifier|const
name|QTimeZonePrivate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|QSharedData
argument_list|(
name|other
argument_list|)
member_init_list|,
name|m_id
argument_list|(
name|other
operator|.
name|m_id
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QTimeZonePrivate
name|QTimeZonePrivate
operator|::
name|~
name|QTimeZonePrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|clone
name|QTimeZonePrivate
modifier|*
name|QTimeZonePrivate
operator|::
name|clone
parameter_list|()
block|{
return|return
operator|new
name|QTimeZonePrivate
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|operator ==
name|bool
name|QTimeZonePrivate
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QTimeZonePrivate
modifier|&
name|other
parameter_list|)
specifier|const
block|{
comment|// TODO Too simple, but need to solve problem of comparing different derived classes
comment|// Should work for all System and ICU classes as names guaranteed unique, but not for Simple.
comment|// Perhaps once all classes have working transitions can compare full list?
return|return
operator|(
name|m_id
operator|==
name|other
operator|.
name|m_id
operator|)
return|;
block|}
end_function
begin_function
DECL|function|operator !=
name|bool
name|QTimeZonePrivate
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QTimeZonePrivate
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|!
operator|(
operator|*
name|this
operator|==
name|other
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isValid
name|bool
name|QTimeZonePrivate
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|m_id
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|id
name|QByteArray
name|QTimeZonePrivate
operator|::
name|id
parameter_list|()
specifier|const
block|{
return|return
name|m_id
return|;
block|}
end_function
begin_function
DECL|function|country
name|QLocale
operator|::
name|Country
name|QTimeZonePrivate
operator|::
name|country
parameter_list|()
specifier|const
block|{
comment|// Default fall-back mode, use the zoneTable to find Region of known Zones
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zoneDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QZoneData
modifier|*
name|data
init|=
name|zoneData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ianaId
argument_list|(
name|data
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
operator|.
name|contains
argument_list|(
name|m_id
argument_list|)
condition|)
return|return
operator|(
name|QLocale
operator|::
name|Country
operator|)
name|data
operator|->
name|country
return|;
block|}
return|return
name|QLocale
operator|::
name|AnyCountry
return|;
block|}
end_function
begin_function
DECL|function|comment
name|QString
name|QTimeZonePrivate
operator|::
name|comment
parameter_list|()
specifier|const
block|{
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|displayName
name|QString
name|QTimeZonePrivate
operator|::
name|displayName
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|,
name|QTimeZone
operator|::
name|NameType
name|nameType
parameter_list|,
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|nameType
operator|==
name|QTimeZone
operator|::
name|OffsetName
condition|)
return|return
name|isoOffsetFormat
argument_list|(
name|offsetFromUtc
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|isDaylightTime
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
condition|)
return|return
name|displayName
argument_list|(
name|QTimeZone
operator|::
name|DaylightTime
argument_list|,
name|nameType
argument_list|,
name|locale
argument_list|)
return|;
else|else
return|return
name|displayName
argument_list|(
name|QTimeZone
operator|::
name|StandardTime
argument_list|,
name|nameType
argument_list|,
name|locale
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|displayName
name|QString
name|QTimeZonePrivate
operator|::
name|displayName
parameter_list|(
name|QTimeZone
operator|::
name|TimeType
name|timeType
parameter_list|,
name|QTimeZone
operator|::
name|NameType
name|nameType
parameter_list|,
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|timeType
argument_list|)
name|Q_UNUSED
argument_list|(
argument|nameType
argument_list|)
name|Q_UNUSED
argument_list|(
argument|locale
argument_list|)
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|abbreviation
name|QString
name|QTimeZonePrivate
operator|::
name|abbreviation
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|offsetFromUtc
name|int
name|QTimeZonePrivate
operator|::
name|offsetFromUtc
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
return|return
name|standardTimeOffset
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
operator|+
name|daylightTimeOffset
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|standardTimeOffset
name|int
name|QTimeZonePrivate
operator|::
name|standardTimeOffset
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
name|invalidSeconds
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|daylightTimeOffset
name|int
name|QTimeZonePrivate
operator|::
name|daylightTimeOffset
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
name|invalidSeconds
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|hasDaylightTime
name|bool
name|QTimeZonePrivate
operator|::
name|hasDaylightTime
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|isDaylightTime
name|bool
name|QTimeZonePrivate
operator|::
name|isDaylightTime
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|data
name|QTimeZonePrivate
operator|::
name|Data
name|QTimeZonePrivate
operator|::
name|data
parameter_list|(
name|qint64
name|forMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|forMSecsSinceEpoch
argument_list|)
return|return
name|invalidData
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// Private only method for use by QDateTime to convert local msecs to epoch msecs
end_comment
begin_comment
comment|// TODO Could be platform optimised if needed
end_comment
begin_function
DECL|function|dataForLocalTime
name|QTimeZonePrivate
operator|::
name|Data
name|QTimeZonePrivate
operator|::
name|dataForLocalTime
parameter_list|(
name|qint64
name|forLocalMSecs
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|hasDaylightTime
argument_list|()
operator|||
operator|!
name|hasTransitions
argument_list|()
condition|)
block|{
comment|// No DST means same offset for all local msecs
comment|// Having DST but no transitions means we can't calculate, so use nearest
return|return
name|data
argument_list|(
name|forLocalMSecs
operator|-
operator|(
name|standardTimeOffset
argument_list|(
name|forLocalMSecs
argument_list|)
operator|*
literal|1000
operator|)
argument_list|)
return|;
block|}
comment|// Get the transition for the local msecs which most of the time should be the right one
comment|// Only around the transition times might it not be the right one
name|Data
name|tran
init|=
name|previousTransition
argument_list|(
name|forLocalMSecs
argument_list|)
decl_stmt|;
name|Data
name|nextTran
decl_stmt|;
comment|// If the local msecs is less than the real local time of the transition
comment|// then get the previous transition to use instead
if|if
condition|(
name|forLocalMSecs
operator|<
name|tran
operator|.
name|atMSecsSinceEpoch
operator|+
operator|(
name|tran
operator|.
name|offsetFromUtc
operator|*
literal|1000
operator|)
condition|)
block|{
while|while
condition|(
name|tran
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
operator|&&
name|forLocalMSecs
operator|<
name|tran
operator|.
name|atMSecsSinceEpoch
operator|+
operator|(
name|tran
operator|.
name|offsetFromUtc
operator|*
literal|1000
operator|)
condition|)
block|{
name|nextTran
operator|=
name|tran
expr_stmt|;
name|tran
operator|=
name|previousTransition
argument_list|(
name|tran
operator|.
name|atMSecsSinceEpoch
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// The zone msecs is after the transition, so check it is before the next tran
comment|// If not try use the next transition instead
name|nextTran
operator|=
name|nextTransition
argument_list|(
name|tran
operator|.
name|atMSecsSinceEpoch
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextTran
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
operator|&&
name|forLocalMSecs
operator|>=
name|nextTran
operator|.
name|atMSecsSinceEpoch
operator|+
operator|(
name|nextTran
operator|.
name|offsetFromUtc
operator|*
literal|1000
operator|)
condition|)
block|{
name|tran
operator|=
name|nextTran
expr_stmt|;
name|nextTran
operator|=
name|nextTransition
argument_list|(
name|tran
operator|.
name|atMSecsSinceEpoch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tran
operator|.
name|daylightTimeOffset
operator|==
literal|0
condition|)
block|{
comment|// If tran is in StandardTime, then need to check if falls close to either DST transition.
comment|// If it does, then it may need adjusting for missing hour or for second occurrence
name|qint64
name|diffPrevTran
init|=
name|forLocalMSecs
operator|-
operator|(
name|tran
operator|.
name|atMSecsSinceEpoch
operator|+
operator|(
name|tran
operator|.
name|offsetFromUtc
operator|*
literal|1000
operator|)
operator|)
decl_stmt|;
name|qint64
name|diffNextTran
init|=
name|nextTran
operator|.
name|atMSecsSinceEpoch
operator|+
operator|(
name|nextTran
operator|.
name|offsetFromUtc
operator|*
literal|1000
operator|)
operator|-
name|forLocalMSecs
decl_stmt|;
if|if
condition|(
name|diffPrevTran
operator|>=
literal|0
operator|&&
name|diffPrevTran
operator|<
name|MSECS_TRAN_WINDOW
condition|)
block|{
comment|// If tran picked is for standard time check if changed from DST in last 6 hours,
comment|// as the local msecs may be ambiguous and represent two valid utc msecs.
comment|// If in last 6 hours then get prev tran and if diff falls within the DST offset
comment|// then use the prev tran as we default to the FirstOccurrence
comment|// TODO Check if faster to just always get prev tran, or if faster using 6 hour check.
name|Data
name|dstTran
init|=
name|previousTransition
argument_list|(
name|tran
operator|.
name|atMSecsSinceEpoch
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstTran
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
operator|&&
name|dstTran
operator|.
name|daylightTimeOffset
operator|>
literal|0
operator|&&
name|diffPrevTran
operator|<
operator|(
name|dstTran
operator|.
name|daylightTimeOffset
operator|*
literal|1000
operator|)
condition|)
name|tran
operator|=
name|dstTran
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diffNextTran
operator|>=
literal|0
operator|&&
name|diffNextTran
operator|<=
operator|(
name|nextTran
operator|.
name|daylightTimeOffset
operator|*
literal|1000
operator|)
condition|)
block|{
comment|// If time falls within last hour of standard time then is actually the missing hour
comment|// So return the next tran instead and adjust the local time to be valid
name|tran
operator|=
name|nextTran
expr_stmt|;
name|forLocalMSecs
operator|=
name|forLocalMSecs
operator|+
operator|(
name|nextTran
operator|.
name|daylightTimeOffset
operator|*
literal|1000
operator|)
expr_stmt|;
block|}
block|}
comment|// tran should now hold the right transition offset to use
name|tran
operator|.
name|atMSecsSinceEpoch
operator|=
name|forLocalMSecs
operator|-
operator|(
name|tran
operator|.
name|offsetFromUtc
operator|*
literal|1000
operator|)
expr_stmt|;
return|return
name|tran
return|;
block|}
end_function
begin_function
DECL|function|hasTransitions
name|bool
name|QTimeZonePrivate
operator|::
name|hasTransitions
parameter_list|()
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|nextTransition
name|QTimeZonePrivate
operator|::
name|Data
name|QTimeZonePrivate
operator|::
name|nextTransition
parameter_list|(
name|qint64
name|afterMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|afterMSecsSinceEpoch
argument_list|)
return|return
name|invalidData
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|previousTransition
name|QTimeZonePrivate
operator|::
name|Data
name|QTimeZonePrivate
operator|::
name|previousTransition
parameter_list|(
name|qint64
name|beforeMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|beforeMSecsSinceEpoch
argument_list|)
return|return
name|invalidData
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|transitions
name|QTimeZonePrivate
operator|::
name|DataList
name|QTimeZonePrivate
operator|::
name|transitions
parameter_list|(
name|qint64
name|fromMSecsSinceEpoch
parameter_list|,
name|qint64
name|toMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|DataList
name|list
decl_stmt|;
if|if
condition|(
name|toMSecsSinceEpoch
operator|>=
name|fromMSecsSinceEpoch
condition|)
block|{
comment|// fromMSecsSinceEpoch is inclusive but nextTransitionTime() is exclusive so go back 1 msec
name|Data
name|next
init|=
name|nextTransition
argument_list|(
name|fromMSecsSinceEpoch
operator|-
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
name|next
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
operator|&&
name|next
operator|.
name|atMSecsSinceEpoch
operator|<=
name|toMSecsSinceEpoch
condition|)
block|{
name|list
operator|.
name|append
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|nextTransition
argument_list|(
name|next
operator|.
name|atMSecsSinceEpoch
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|systemTimeZoneId
name|QByteArray
name|QTimeZonePrivate
operator|::
name|systemTimeZoneId
parameter_list|()
specifier|const
block|{
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|()
specifier|const
block|{
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|(
name|QLocale
operator|::
name|Country
name|country
parameter_list|)
specifier|const
block|{
comment|// Default fall-back mode, use the zoneTable to find Region of know Zones
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|regions
decl_stmt|;
comment|// First get all Zones in the Zones table belonging to the Region
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zoneDataTableSize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|zoneData
argument_list|(
name|i
argument_list|)
operator|->
name|country
operator|==
name|country
condition|)
name|regions
operator|+=
name|ianaId
argument_list|(
name|zoneData
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|std
operator|::
name|sort
argument_list|(
name|regions
operator|.
name|begin
argument_list|()
argument_list|,
name|regions
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|regions
operator|.
name|erase
argument_list|(
name|std
operator|::
name|unique
argument_list|(
name|regions
operator|.
name|begin
argument_list|()
argument_list|,
name|regions
operator|.
name|end
argument_list|()
argument_list|)
argument_list|,
name|regions
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Then select just those that are available
specifier|const
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|all
init|=
name|availableTimeZoneIds
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|qMin
argument_list|(
name|all
operator|.
name|size
argument_list|()
argument_list|,
name|regions
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|std
operator|::
name|set_intersection
argument_list|(
name|all
operator|.
name|begin
argument_list|()
argument_list|,
name|all
operator|.
name|end
argument_list|()
argument_list|,
name|regions
operator|.
name|cbegin
argument_list|()
argument_list|,
name|regions
operator|.
name|cend
argument_list|()
argument_list|,
name|std
operator|::
name|back_inserter
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|(
name|int
name|offsetFromUtc
parameter_list|)
specifier|const
block|{
comment|// Default fall-back mode, use the zoneTable to find Offset of know Zones
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|offsets
decl_stmt|;
comment|// First get all Zones in the table using the Offset
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windowsDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QWindowsData
modifier|*
name|winData
init|=
name|windowsData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|winData
operator|->
name|offsetFromUtc
operator|==
name|offsetFromUtc
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|zoneDataTableSize
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|QZoneData
modifier|*
name|data
init|=
name|zoneData
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|windowsIdKey
operator|==
name|winData
operator|->
name|windowsIdKey
condition|)
name|offsets
operator|+=
name|ianaId
argument_list|(
name|data
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|std
operator|::
name|sort
argument_list|(
name|offsets
operator|.
name|begin
argument_list|()
argument_list|,
name|offsets
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|offsets
operator|.
name|erase
argument_list|(
name|std
operator|::
name|unique
argument_list|(
name|offsets
operator|.
name|begin
argument_list|()
argument_list|,
name|offsets
operator|.
name|end
argument_list|()
argument_list|)
argument_list|,
name|offsets
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Then select just those that are available
specifier|const
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|all
init|=
name|availableTimeZoneIds
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|qMin
argument_list|(
name|all
operator|.
name|size
argument_list|()
argument_list|,
name|offsets
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|std
operator|::
name|set_intersection
argument_list|(
name|all
operator|.
name|begin
argument_list|()
argument_list|,
name|all
operator|.
name|end
argument_list|()
argument_list|,
name|offsets
operator|.
name|cbegin
argument_list|()
argument_list|,
name|offsets
operator|.
name|cend
argument_list|()
argument_list|,
name|std
operator|::
name|back_inserter
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_function
DECL|function|serialize
name|void
name|QTimeZonePrivate
operator|::
name|serialize
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|)
specifier|const
block|{
name|ds
operator|<<
name|QString
operator|::
name|fromUtf8
argument_list|(
name|m_id
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|// Static Utility Methods
end_comment
begin_function
DECL|function|invalidData
name|QTimeZonePrivate
operator|::
name|Data
name|QTimeZonePrivate
operator|::
name|invalidData
parameter_list|()
block|{
name|Data
name|data
decl_stmt|;
name|data
operator|.
name|atMSecsSinceEpoch
operator|=
name|invalidMSecs
argument_list|()
expr_stmt|;
name|data
operator|.
name|offsetFromUtc
operator|=
name|invalidSeconds
argument_list|()
expr_stmt|;
name|data
operator|.
name|standardTimeOffset
operator|=
name|invalidSeconds
argument_list|()
expr_stmt|;
name|data
operator|.
name|daylightTimeOffset
operator|=
name|invalidSeconds
argument_list|()
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_function
DECL|function|invalidOffsetData
name|QTimeZone
operator|::
name|OffsetData
name|QTimeZonePrivate
operator|::
name|invalidOffsetData
parameter_list|()
block|{
name|QTimeZone
operator|::
name|OffsetData
name|offsetData
decl_stmt|;
name|offsetData
operator|.
name|atUtc
operator|=
name|QDateTime
argument_list|()
expr_stmt|;
name|offsetData
operator|.
name|offsetFromUtc
operator|=
name|invalidSeconds
argument_list|()
expr_stmt|;
name|offsetData
operator|.
name|standardTimeOffset
operator|=
name|invalidSeconds
argument_list|()
expr_stmt|;
name|offsetData
operator|.
name|daylightTimeOffset
operator|=
name|invalidSeconds
argument_list|()
expr_stmt|;
return|return
name|offsetData
return|;
block|}
end_function
begin_function
DECL|function|toOffsetData
name|QTimeZone
operator|::
name|OffsetData
name|QTimeZonePrivate
operator|::
name|toOffsetData
parameter_list|(
specifier|const
name|QTimeZonePrivate
operator|::
name|Data
modifier|&
name|data
parameter_list|)
block|{
name|QTimeZone
operator|::
name|OffsetData
name|offsetData
init|=
name|invalidOffsetData
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|atMSecsSinceEpoch
operator|!=
name|invalidMSecs
argument_list|()
condition|)
block|{
name|offsetData
operator|.
name|atUtc
operator|=
name|QDateTime
operator|::
name|fromMSecsSinceEpoch
argument_list|(
name|data
operator|.
name|atMSecsSinceEpoch
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
expr_stmt|;
name|offsetData
operator|.
name|offsetFromUtc
operator|=
name|data
operator|.
name|offsetFromUtc
expr_stmt|;
name|offsetData
operator|.
name|standardTimeOffset
operator|=
name|data
operator|.
name|standardTimeOffset
expr_stmt|;
name|offsetData
operator|.
name|daylightTimeOffset
operator|=
name|data
operator|.
name|daylightTimeOffset
expr_stmt|;
name|offsetData
operator|.
name|abbreviation
operator|=
name|data
operator|.
name|abbreviation
expr_stmt|;
block|}
return|return
name|offsetData
return|;
block|}
end_function
begin_comment
comment|// Is the format of the ID valid ?
end_comment
begin_function
DECL|function|isValidId
name|bool
name|QTimeZonePrivate
operator|::
name|isValidId
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|ianaId
parameter_list|)
block|{
comment|/*       Main rules for defining TZ/IANA names as per ftp://ftp.iana.org/tz/code/Theory        1. Use only valid POSIX file name components        2. Within a file name component, use only ASCII letters, `.', `-' and `_'.        3. Do not use digits (except in a [+-]\d+ suffix, when used).        4. A file name component must not exceed 14 characters or start with `-'       However, the rules are really guidelines - a later one says        - Do not change established names if they only marginally violate the          above rules.       We may, therefore, need to be a bit slack in our check here, if we hit       legitimate exceptions in real time-zone databases.        In particular, aliases such as "Etc/GMT+7" and "SystemV/EST5EDT" are valid       so we need to accept digits, ':', and '+'; aliases typically have the form       of POSIX TZ strings, which allow a suffix to a proper IANA name.  A POSIX       suffix starts with an offset (as in GMT+7) and may continue with another       name (as in EST5EDT, giving the DST name of the zone); a further offset is       allowed (for DST).  The ("hard to describe and [...] error-prone in       practice") POSIX form even allows a suffix giving the dates (and       optionally times) of the annual DST transitions.  Hopefully, no TZ aliases       go that far, but we at least need to accept an offset and (single       fragment) DST-name.        But for the legacy complications, the following would be preferable if       QRegExp would work on QByteArrays directly:           const QRegExp rx(QStringLiteral("[a-z+._][a-z+._-]{,13}"                                       "(?:/[a-z+._][a-z+._-]{,13})*"                                           // Optional suffix:                                           "(?:[+-]?\d{1,2}(?::\d{1,2}){,2}" // offset                                              // one name fragment (DST):                                              "(?:[a-z+._][a-z+._-]{,13})?)"),                            Qt::CaseInsensitive);           return rx.exactMatch(ianaId);     */
comment|// Somewhat slack hand-rolled version:
specifier|const
name|int
name|MinSectionLength
init|=
literal|1
decl_stmt|;
specifier|const
name|int
name|MaxSectionLength
init|=
literal|14
decl_stmt|;
name|int
name|sectionLength
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|char
modifier|*
name|it
init|=
name|ianaId
operator|.
name|begin
argument_list|()
init|,
modifier|*
init|const
name|end
init|=
name|ianaId
operator|.
name|end
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
operator|,
operator|++
name|sectionLength
control|)
block|{
specifier|const
name|char
name|ch
init|=
operator|*
name|it
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|sectionLength
argument_list|<
name|MinSectionLength
operator|||
name|sectionLength
argument_list|>
name|MaxSectionLength
condition|)
return|return
literal|false
return|;
comment|// violates (4)
name|sectionLength
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|sectionLength
operator|==
literal|0
condition|)
return|return
literal|false
return|;
comment|// violates (4)
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
operator|)
operator|&&
operator|!
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
operator|)
operator|&&
operator|!
operator|(
name|ch
operator|==
literal|'_'
operator|)
operator|&&
operator|!
operator|(
name|ch
operator|==
literal|'.'
operator|)
comment|// Should ideally check these only happen as an offset:
operator|&&
operator|!
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|&&
operator|!
operator|(
name|ch
operator|==
literal|'+'
operator|)
operator|&&
operator|!
operator|(
name|ch
operator|==
literal|':'
operator|)
condition|)
block|{
return|return
literal|false
return|;
comment|// violates (2)
block|}
block|}
if|if
condition|(
name|sectionLength
argument_list|<
name|MinSectionLength
operator|||
name|sectionLength
argument_list|>
name|MaxSectionLength
condition|)
return|return
literal|false
return|;
comment|// violates (4)
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|isoOffsetFormat
name|QString
name|QTimeZonePrivate
operator|::
name|isoOffsetFormat
parameter_list|(
name|int
name|offsetFromUtc
parameter_list|)
block|{
specifier|const
name|int
name|mins
init|=
name|offsetFromUtc
operator|/
literal|60
decl_stmt|;
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"UTC%1%2:%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|mins
operator|>=
literal|0
condition|?
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
else|:
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|qAbs
argument_list|(
name|mins
argument_list|)
operator|/
literal|60
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|qAbs
argument_list|(
name|mins
argument_list|)
operator|%
literal|60
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ianaIdToWindowsId
name|QByteArray
name|QTimeZonePrivate
operator|::
name|ianaIdToWindowsId
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|id
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zoneDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QZoneData
modifier|*
name|data
init|=
name|zoneData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ianaId
argument_list|(
name|data
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
operator|.
name|contains
argument_list|(
name|id
argument_list|)
condition|)
return|return
name|toWindowsIdLiteral
argument_list|(
name|data
operator|->
name|windowsIdKey
argument_list|)
return|;
block|}
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|windowsIdToDefaultIanaId
name|QByteArray
name|QTimeZonePrivate
operator|::
name|windowsIdToDefaultIanaId
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|windowsId
parameter_list|)
block|{
specifier|const
name|quint16
name|windowsIdKey
init|=
name|toWindowsIdKey
argument_list|(
name|windowsId
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|windowsDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QWindowsData
modifier|*
name|data
init|=
name|windowsData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|windowsIdKey
operator|==
name|windowsIdKey
condition|)
return|return
name|ianaId
argument_list|(
name|data
argument_list|)
return|;
block|}
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|windowsIdToDefaultIanaId
name|QByteArray
name|QTimeZonePrivate
operator|::
name|windowsIdToDefaultIanaId
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|windowsId
parameter_list|,
name|QLocale
operator|::
name|Country
name|country
parameter_list|)
block|{
specifier|const
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
init|=
name|windowsIdToIanaIds
argument_list|(
name|windowsId
argument_list|,
name|country
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
return|return
name|list
operator|.
name|first
argument_list|()
return|;
else|else
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|windowsIdToIanaIds
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QTimeZonePrivate
operator|::
name|windowsIdToIanaIds
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|windowsId
parameter_list|)
block|{
specifier|const
name|quint16
name|windowsIdKey
init|=
name|toWindowsIdKey
argument_list|(
name|windowsId
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zoneDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QZoneData
modifier|*
name|data
init|=
name|zoneData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|windowsIdKey
operator|==
name|windowsIdKey
condition|)
name|list
operator|<<
name|ianaId
argument_list|(
name|data
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|// Return the full list in alpha order
name|std
operator|::
name|sort
argument_list|(
name|list
operator|.
name|begin
argument_list|()
argument_list|,
name|list
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|windowsIdToIanaIds
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QTimeZonePrivate
operator|::
name|windowsIdToIanaIds
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|windowsId
parameter_list|,
name|QLocale
operator|::
name|Country
name|country
parameter_list|)
block|{
specifier|const
name|quint16
name|windowsIdKey
init|=
name|toWindowsIdKey
argument_list|(
name|windowsId
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zoneDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QZoneData
modifier|*
name|data
init|=
name|zoneData
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Return the region matches in preference order
if|if
condition|(
name|data
operator|->
name|windowsIdKey
operator|==
name|windowsIdKey
operator|&&
name|data
operator|->
name|country
operator|==
operator|(
name|quint16
operator|)
name|country
condition|)
return|return
name|ianaId
argument_list|(
name|data
argument_list|)
operator|.
name|split
argument_list|(
literal|' '
argument_list|)
return|;
block|}
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// Define template for derived classes to reimplement so QSharedDataPointer clone() works correctly
end_comment
begin_function
DECL|function|clone
template|template
parameter_list|<>
name|QTimeZonePrivate
modifier|*
name|QSharedDataPointer
argument_list|<
name|QTimeZonePrivate
argument_list|>
operator|::
name|clone
parameter_list|()
block|{
return|return
name|d
operator|->
name|clone
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*     UTC Offset implementation, used when QT_NO_SYSTEMLOCALE set and QT_USE_ICU not set,     or for QDateTimes with a Qt:Spec of Qt::OffsetFromUtc. */
end_comment
begin_comment
comment|// Create default UTC time zone
end_comment
begin_constructor
DECL|function|QUtcTimeZonePrivate
name|QUtcTimeZonePrivate
operator|::
name|QUtcTimeZonePrivate
parameter_list|()
block|{
specifier|const
name|QString
name|name
init|=
name|utcQString
argument_list|()
decl_stmt|;
name|init
argument_list|(
name|utcQByteArray
argument_list|()
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|QLocale
operator|::
name|AnyCountry
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|// Create a named UTC time zone
end_comment
begin_constructor
DECL|function|QUtcTimeZonePrivate
name|QUtcTimeZonePrivate
operator|::
name|QUtcTimeZonePrivate
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|id
parameter_list|)
block|{
comment|// Look for the name in the UTC list, if found set the values
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|utcDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QUtcData
modifier|*
name|data
init|=
name|utcData
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|QByteArray
name|uid
init|=
name|utcId
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|uid
operator|==
name|id
condition|)
block|{
name|QString
name|name
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|init
argument_list|(
name|id
argument_list|,
name|data
operator|->
name|offsetFromUtc
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|QLocale
operator|::
name|AnyCountry
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_constructor
begin_comment
comment|// Create offset from UTC
end_comment
begin_constructor
DECL|function|QUtcTimeZonePrivate
name|QUtcTimeZonePrivate
operator|::
name|QUtcTimeZonePrivate
parameter_list|(
name|qint32
name|offsetSeconds
parameter_list|)
block|{
name|QString
name|utcId
decl_stmt|;
if|if
condition|(
name|offsetSeconds
operator|==
literal|0
condition|)
name|utcId
operator|=
name|utcQString
argument_list|()
expr_stmt|;
else|else
name|utcId
operator|=
name|isoOffsetFormat
argument_list|(
name|offsetSeconds
argument_list|)
expr_stmt|;
name|init
argument_list|(
name|utcId
operator|.
name|toUtf8
argument_list|()
argument_list|,
name|offsetSeconds
argument_list|,
name|utcId
argument_list|,
name|utcId
argument_list|,
name|QLocale
operator|::
name|AnyCountry
argument_list|,
name|utcId
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QUtcTimeZonePrivate
name|QUtcTimeZonePrivate
operator|::
name|QUtcTimeZonePrivate
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|zoneId
parameter_list|,
name|int
name|offsetSeconds
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|abbreviation
parameter_list|,
name|QLocale
operator|::
name|Country
name|country
parameter_list|,
specifier|const
name|QString
modifier|&
name|comment
parameter_list|)
block|{
name|init
argument_list|(
name|zoneId
argument_list|,
name|offsetSeconds
argument_list|,
name|name
argument_list|,
name|abbreviation
argument_list|,
name|country
argument_list|,
name|comment
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QUtcTimeZonePrivate
name|QUtcTimeZonePrivate
operator|::
name|QUtcTimeZonePrivate
parameter_list|(
specifier|const
name|QUtcTimeZonePrivate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|QTimeZonePrivate
argument_list|(
name|other
argument_list|)
member_init_list|,
name|m_name
argument_list|(
name|other
operator|.
name|m_name
argument_list|)
member_init_list|,
name|m_abbreviation
argument_list|(
name|other
operator|.
name|m_abbreviation
argument_list|)
member_init_list|,
name|m_comment
argument_list|(
name|other
operator|.
name|m_comment
argument_list|)
member_init_list|,
name|m_country
argument_list|(
name|other
operator|.
name|m_country
argument_list|)
member_init_list|,
name|m_offsetFromUtc
argument_list|(
name|other
operator|.
name|m_offsetFromUtc
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QUtcTimeZonePrivate
name|QUtcTimeZonePrivate
operator|::
name|~
name|QUtcTimeZonePrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|clone
name|QTimeZonePrivate
modifier|*
name|QUtcTimeZonePrivate
operator|::
name|clone
parameter_list|()
block|{
return|return
operator|new
name|QUtcTimeZonePrivate
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|data
name|QTimeZonePrivate
operator|::
name|Data
name|QUtcTimeZonePrivate
operator|::
name|data
parameter_list|(
name|qint64
name|forMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Data
name|d
init|=
name|invalidData
argument_list|()
decl_stmt|;
name|d
operator|.
name|abbreviation
operator|=
name|m_abbreviation
expr_stmt|;
name|d
operator|.
name|atMSecsSinceEpoch
operator|=
name|forMSecsSinceEpoch
expr_stmt|;
name|d
operator|.
name|offsetFromUtc
operator|=
name|m_offsetFromUtc
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QUtcTimeZonePrivate
operator|::
name|init
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|zoneId
parameter_list|)
block|{
name|m_id
operator|=
name|zoneId
expr_stmt|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QUtcTimeZonePrivate
operator|::
name|init
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|zoneId
parameter_list|,
name|int
name|offsetSeconds
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|abbreviation
parameter_list|,
name|QLocale
operator|::
name|Country
name|country
parameter_list|,
specifier|const
name|QString
modifier|&
name|comment
parameter_list|)
block|{
name|m_id
operator|=
name|zoneId
expr_stmt|;
name|m_offsetFromUtc
operator|=
name|offsetSeconds
expr_stmt|;
name|m_name
operator|=
name|name
expr_stmt|;
name|m_abbreviation
operator|=
name|abbreviation
expr_stmt|;
name|m_country
operator|=
name|country
expr_stmt|;
name|m_comment
operator|=
name|comment
expr_stmt|;
block|}
end_function
begin_function
DECL|function|country
name|QLocale
operator|::
name|Country
name|QUtcTimeZonePrivate
operator|::
name|country
parameter_list|()
specifier|const
block|{
return|return
name|m_country
return|;
block|}
end_function
begin_function
DECL|function|comment
name|QString
name|QUtcTimeZonePrivate
operator|::
name|comment
parameter_list|()
specifier|const
block|{
return|return
name|m_comment
return|;
block|}
end_function
begin_function
DECL|function|displayName
name|QString
name|QUtcTimeZonePrivate
operator|::
name|displayName
parameter_list|(
name|QTimeZone
operator|::
name|TimeType
name|timeType
parameter_list|,
name|QTimeZone
operator|::
name|NameType
name|nameType
parameter_list|,
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|timeType
argument_list|)
name|Q_UNUSED
argument_list|(
argument|locale
argument_list|)
if|if
condition|(
name|nameType
operator|==
name|QTimeZone
operator|::
name|ShortName
condition|)
return|return
name|m_abbreviation
return|;
elseif|else
if|if
condition|(
name|nameType
operator|==
name|QTimeZone
operator|::
name|OffsetName
condition|)
return|return
name|isoOffsetFormat
argument_list|(
name|m_offsetFromUtc
argument_list|)
return|;
return|return
name|m_name
return|;
block|}
end_function
begin_function
DECL|function|abbreviation
name|QString
name|QUtcTimeZonePrivate
operator|::
name|abbreviation
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
name|m_abbreviation
return|;
block|}
end_function
begin_function
DECL|function|standardTimeOffset
name|qint32
name|QUtcTimeZonePrivate
operator|::
name|standardTimeOffset
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
name|m_offsetFromUtc
return|;
block|}
end_function
begin_function
DECL|function|daylightTimeOffset
name|qint32
name|QUtcTimeZonePrivate
operator|::
name|daylightTimeOffset
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
argument|atMSecsSinceEpoch
argument_list|)
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|systemTimeZoneId
name|QByteArray
name|QUtcTimeZonePrivate
operator|::
name|systemTimeZoneId
parameter_list|()
specifier|const
block|{
return|return
name|utcQByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtcTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|utcDataTableSize
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|utcDataTableSize
condition|;
operator|++
name|i
control|)
name|result
operator|<<
name|utcId
argument_list|(
name|utcData
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|result
operator|.
name|begin
argument_list|()
argument_list|,
name|result
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// ### or already sorted??
comment|// ### assuming no duplicates
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtcTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|(
name|QLocale
operator|::
name|Country
name|country
parameter_list|)
specifier|const
block|{
comment|// If AnyCountry then is request for all non-region offset codes
if|if
condition|(
name|country
operator|==
name|QLocale
operator|::
name|AnyCountry
condition|)
return|return
name|availableTimeZoneIds
argument_list|()
return|;
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QUtcTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|(
name|qint32
name|offsetSeconds
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|result
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|utcDataTableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QUtcData
modifier|*
name|data
init|=
name|utcData
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|offsetFromUtc
operator|==
name|offsetSeconds
condition|)
name|result
operator|<<
name|utcId
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
name|std
operator|::
name|sort
argument_list|(
name|result
operator|.
name|begin
argument_list|()
argument_list|,
name|result
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// ### or already sorted??
comment|// ### assuming no duplicates
return|return
name|result
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_function
DECL|function|serialize
name|void
name|QUtcTimeZonePrivate
operator|::
name|serialize
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|)
specifier|const
block|{
name|ds
operator|<<
name|QStringLiteral
argument_list|(
literal|"OffsetFromUtc"
argument_list|)
operator|<<
name|QString
operator|::
name|fromUtf8
argument_list|(
name|m_id
argument_list|)
operator|<<
name|m_offsetFromUtc
operator|<<
name|m_name
operator|<<
name|m_abbreviation
operator|<<
operator|(
name|qint32
operator|)
name|m_country
operator|<<
name|m_comment
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
