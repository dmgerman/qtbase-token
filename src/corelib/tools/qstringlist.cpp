begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qset.h>
end_include
begin_include
include|#
directive|include
file|<qregularexpression.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*! \typedef QStringListIterator     \relates QStringList      The QStringListIterator type definition provides a Java-style const     iterator for QStringList.      QStringList provides both \l{Java-style iterators} and     \l{STL-style iterators}. The Java-style const iterator is simply     a type definition for QListIterator<QString>.      \sa QMutableStringListIterator, QStringList::const_iterator */
end_comment
begin_comment
comment|/*! \typedef QMutableStringListIterator     \relates QStringList      The QStringListIterator type definition provides a Java-style     non-const iterator for QStringList.      QStringList provides both \l{Java-style iterators} and     \l{STL-style iterators}. The Java-style non-const iterator is     simply a type definition for QMutableListIterator<QString>.      \sa QStringListIterator, QStringList::iterator */
end_comment
begin_comment
comment|/*!     \class QStringList     \inmodule QtCore     \brief The QStringList class provides a list of strings.      \ingroup tools     \ingroup shared     \ingroup string-processing      \reentrant      QStringList inherits from QList<QString>. Like QList, QStringList is     \l{implicitly shared}. It provides fast index-based access as well as fast     insertions and removals. Passing string lists as value parameters is both     fast and safe.      All of QList's functionality also applies to QStringList. For example, you     can use isEmpty() to test whether the list is empty, and you can call     functions like append(), prepend(), insert(), replace(), removeAll(),     removeAt(), removeFirst(), removeLast(), and removeOne() to modify a     QStringList. In addition, QStringList provides a few convenience     functions that make handling lists of strings easier:      \tableofcontents      \section1 Adding Strings      Strings can be added to a list using the \l     {QList::append()}{append()}, \l     {QList::operator+=()}{operator+=()} and \l     {QStringList::operator<<()}{operator<<()} functions. For example:      \snippet qstringlist/main.cpp 0      \section1 Iterating Over the Strings      To iterate over a list, you can either use index positions or     QList's Java-style and STL-style iterator types:      Indexing:      \snippet qstringlist/main.cpp 1      Java-style iterator:      \snippet qstringlist/main.cpp 2      STL-style iterator:      \snippet qstringlist/main.cpp 3      The QStringListIterator class is simply a type definition for     QListIterator<QString>. QStringList also provide the     QMutableStringListIterator class which is a type definition for     QMutableListIterator<QString>.      \section1 Manipulating the Strings      QStringList provides several functions allowing you to manipulate     the contents of a list. You can concatenate all the strings in a     string list into a single string (with an optional separator)     using the join() function. For example:      \snippet qstringlist/main.cpp 4      The argument to join can be a single character or a string.      To break up a string into a string list, use the QString::split()     function:      \snippet qstringlist/main.cpp 6      The argument to split can be a single character, a string, or a     QRegExp.      In addition, the \l {QStringList::operator+()}{operator+()}     function allows you to concatenate two string lists into one. To     sort a string list, use the sort() function.      QString list also provides the filter() function which lets you     to extract a new list which contains only those strings which     contain a particular substring (or match a particular regular     expression):      \snippet qstringlist/main.cpp 7      The contains() function tells you whether the list contains a     given string, while the indexOf() function returns the index of     the first occurrence of the given string. The lastIndexOf()     function on the other hand, returns the index of the last     occurrence of the string.      Finally, the replaceInStrings() function calls QString::replace()     on each string in the string list in turn. For example:      \snippet qstringlist/main.cpp 8      \sa QString */
end_comment
begin_comment
comment|/*!     \fn QStringList::QStringList()      Constructs an empty string list. */
end_comment
begin_comment
comment|/*!     \fn QStringList::QStringList(const QString&str)      Constructs a string list that contains the given string, \a     str. Longer lists are easily created like this:      \snippet qstringlist/main.cpp 9      \sa append() */
end_comment
begin_comment
comment|/*!     \fn QStringList::QStringList(const QList<QString>&other)      Constructs a copy of \a other.      This operation takes \l{constant time}, because QStringList is     \l{implicitly shared}. This makes returning a QStringList from a     function very fast. If a shared instance is modified, it will be     copied (copy-on-write), and that takes \l{linear time}.      \sa operator=() */
end_comment
begin_comment
comment|/*!     \fn QStringList::QStringList(QList<QString>&&other)     \overload     \since 5.4      Move-constructs from QList<QString>.      After a successful construction, \a other will be empty. */
end_comment
begin_comment
comment|/*!     \fn QStringList&QStringList::operator=(const QList<QString>&other)     \since 5.4      Copy assignment operator from QList<QString>. Assigns the \a other     list of strings to this string list.      After the operation, \a other and \c *this will be equal. */
end_comment
begin_comment
comment|/*!     \fn QStringList&QStringList::operator=(QList<QString>&&other)     \overload     \since 5.4      Move assignment operator from QList<QString>. Moves the \a other     list of strings to this string list.      After the operation, \a other will be empty. */
end_comment
begin_comment
comment|/*!     \fn void QStringList::sort(Qt::CaseSensitivity cs)      Sorts the list of strings in ascending order.     If \a cs is \l Qt::CaseSensitive (the default), the string comparison     is case sensitive; otherwise the comparison is case insensitive.      Sorting is performed using the STL's std::sort() algorithm,     which averages \l{linear-logarithmic time}, i.e. O(\e{n} log \e{n}).      If you want to sort your strings in an arbitrary order, consider     using the QMap class. For example, you could use a QMap<QString,     QString> to create a case-insensitive ordering (e.g. with the keys     being lower-case versions of the strings, and the values being the     strings), or a QMap<int, QString> to sort the strings by some     integer index. */
end_comment
begin_namespace
namespace|namespace
block|{
DECL|struct|CaseInsensitiveLessThan
struct|struct
name|CaseInsensitiveLessThan
block|{
DECL|typedef|result_type
typedef|typedef
name|bool
name|result_type
typedef|;
DECL|function|operator ()
name|result_type
name|operator
name|()
parameter_list|(
specifier|const
name|QString
modifier|&
name|s1
parameter_list|,
specifier|const
name|QString
modifier|&
name|s2
parameter_list|)
specifier|const
block|{
return|return
name|s1
operator|.
name|compare
argument_list|(
name|s2
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|<
literal|0
return|;
block|}
block|}
struct|;
block|}
end_namespace
begin_function
DECL|function|QStringList_sort
name|void
name|QtPrivate
operator|::
name|QStringList_sort
parameter_list|(
name|QStringList
modifier|*
name|that
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
name|std
operator|::
name|sort
argument_list|(
name|that
operator|->
name|begin
argument_list|()
argument_list|,
name|that
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|std
operator|::
name|sort
argument_list|(
name|that
operator|->
name|begin
argument_list|()
argument_list|,
name|that
operator|->
name|end
argument_list|()
argument_list|,
name|CaseInsensitiveLessThan
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QStringList QStringList::filter(const QString&str, Qt::CaseSensitivity cs) const      Returns a list of all the strings containing the substring \a str.      If \a cs is \l Qt::CaseSensitive (the default), the string     comparison is case sensitive; otherwise the comparison is case     insensitive.      \snippet qstringlist/main.cpp 5     \snippet qstringlist/main.cpp 10      This is equivalent to      \snippet qstringlist/main.cpp 11     \snippet qstringlist/main.cpp 12      \sa contains() */
end_comment
begin_function
DECL|function|QStringList_filter
name|QStringList
name|QtPrivate
operator|::
name|QStringList_filter
parameter_list|(
specifier|const
name|QStringList
modifier|*
name|that
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
name|QStringMatcher
name|matcher
argument_list|(
name|str
argument_list|,
name|cs
argument_list|)
decl_stmt|;
name|QStringList
name|res
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|that
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|matcher
operator|.
name|indexIn
argument_list|(
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|res
operator|<<
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QStringList::contains(const QString&str, Qt::CaseSensitivity cs) const      Returns \c true if the list contains the string \a str; otherwise     returns \c false. The search is case insensitive if \a cs is     Qt::CaseInsensitive; the search is case sensitive by default.      \sa indexOf(), lastIndexOf(), QString::contains()  */
end_comment
begin_function
DECL|function|QStringList_contains
name|bool
name|QtPrivate
operator|::
name|QStringList_contains
parameter_list|(
specifier|const
name|QStringList
modifier|*
name|that
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|that
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
modifier|&
name|string
init|=
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|string
operator|.
name|length
argument_list|()
operator|==
name|str
operator|.
name|length
argument_list|()
operator|&&
name|str
operator|.
name|compare
argument_list|(
name|string
argument_list|,
name|cs
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_comment
comment|/*!     \fn QStringList QStringList::filter(const QRegExp&rx) const      \overload      Returns a list of all the strings that match the regular     expression \a rx. */
end_comment
begin_function
DECL|function|QStringList_filter
name|QStringList
name|QtPrivate
operator|::
name|QStringList_filter
parameter_list|(
specifier|const
name|QStringList
modifier|*
name|that
parameter_list|,
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|)
block|{
name|QStringList
name|res
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|that
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|contains
argument_list|(
name|rx
argument_list|)
condition|)
name|res
operator|<<
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGULAREXPRESSION
end_ifndef
begin_comment
comment|/*!     \fn QStringList QStringList::filter(const QRegularExpression&re) const     \overload     \since 5.0      Returns a list of all the strings that match the regular     expression \a re. */
end_comment
begin_function
DECL|function|QStringList_filter
name|QStringList
name|QtPrivate
operator|::
name|QStringList_filter
parameter_list|(
specifier|const
name|QStringList
modifier|*
name|that
parameter_list|,
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|)
block|{
name|QStringList
name|res
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|that
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|contains
argument_list|(
name|re
argument_list|)
condition|)
name|res
operator|<<
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGULAREXPRESSION
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BOOTSTRAPPED
end_comment
begin_comment
comment|/*!     \fn QStringList&QStringList::replaceInStrings(const QString&before, const QString&after, Qt::CaseSensitivity cs)      Returns a string list where every string has had the \a before     text replaced with the \a after text wherever the \a before text     is found. The \a before text is matched case-sensitively or not     depending on the \a cs flag.      For example:      \snippet qstringlist/main.cpp 5     \snippet qstringlist/main.cpp 13      \sa QString::replace() */
end_comment
begin_function
DECL|function|QStringList_replaceInStrings
name|void
name|QtPrivate
operator|::
name|QStringList_replaceInStrings
parameter_list|(
name|QStringList
modifier|*
name|that
parameter_list|,
specifier|const
name|QString
modifier|&
name|before
parameter_list|,
specifier|const
name|QString
modifier|&
name|after
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|that
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
operator|(
operator|*
name|that
operator|)
index|[
name|i
index|]
operator|.
name|replace
argument_list|(
name|before
argument_list|,
name|after
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_comment
comment|/*!     \fn QStringList&QStringList::replaceInStrings(const QRegExp&rx, const QString&after)     \overload      Replaces every occurrence of the regexp \a rx, in each of the     string lists's strings, with \a after. Returns a reference to the     string list.      For example:      \snippet qstringlist/main.cpp 5     \snippet qstringlist/main.cpp 14      For regular expressions that contain \l{capturing parentheses},     occurrences of \b{\\1}, \b{\\2}, ..., in \a after are     replaced with \a{rx}.cap(1), \a{rx}.cap(2), ...      For example:      \snippet qstringlist/main.cpp 5     \snippet qstringlist/main.cpp 15 */
end_comment
begin_function
DECL|function|QStringList_replaceInStrings
name|void
name|QtPrivate
operator|::
name|QStringList_replaceInStrings
parameter_list|(
name|QStringList
modifier|*
name|that
parameter_list|,
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|,
specifier|const
name|QString
modifier|&
name|after
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|that
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
operator|(
operator|*
name|that
operator|)
index|[
name|i
index|]
operator|.
name|replace
argument_list|(
name|rx
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGULAREXPRESSION
end_ifndef
begin_comment
comment|/*!     \fn QStringList&QStringList::replaceInStrings(const QRegularExpression&re, const QString&after)     \overload     \since 5.0      Replaces every occurrence of the regular expression \a re, in each of the     string lists's strings, with \a after. Returns a reference to the string     list.      For example:      \snippet qstringlist/main.cpp 5     \snippet qstringlist/main.cpp 16      For regular expressions that contain capturing groups,     occurrences of \b{\\1}, \b{\\2}, ..., in \a after are     replaced with the string captured by the corresponding capturing group.      For example:      \snippet qstringlist/main.cpp 5     \snippet qstringlist/main.cpp 17 */
end_comment
begin_function
DECL|function|QStringList_replaceInStrings
name|void
name|QtPrivate
operator|::
name|QStringList_replaceInStrings
parameter_list|(
name|QStringList
modifier|*
name|that
parameter_list|,
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
specifier|const
name|QString
modifier|&
name|after
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|that
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
operator|(
operator|*
name|that
operator|)
index|[
name|i
index|]
operator|.
name|replace
argument_list|(
name|re
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGULAREXPRESSION
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BOOTSTRAPPED
end_comment
begin_comment
comment|/*!     \fn QString QStringList::join(const QString&separator) const      Joins all the string list's strings into a single string with each     element separated by the given \a separator (which can be an     empty string).      \sa QString::split() */
end_comment
begin_comment
comment|/*!     \fn QString QStringList::join(QChar separator) const     \since 5.0     \overload join() */
end_comment
begin_function
DECL|function|QStringList_join
name|QString
name|QtPrivate
operator|::
name|QStringList_join
parameter_list|(
specifier|const
name|QStringList
modifier|*
name|that
parameter_list|,
specifier|const
name|QChar
modifier|*
name|sep
parameter_list|,
name|int
name|seplen
parameter_list|)
block|{
name|int
name|totalLength
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|size
init|=
name|that
operator|->
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
name|totalLength
operator|+=
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|totalLength
operator|+=
name|seplen
operator|*
operator|(
name|size
operator|-
literal|1
operator|)
expr_stmt|;
name|QString
name|res
decl_stmt|;
if|if
condition|(
name|totalLength
operator|==
literal|0
condition|)
return|return
name|res
return|;
name|res
operator|.
name|reserve
argument_list|(
name|totalLength
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
name|res
operator|.
name|append
argument_list|(
name|sep
argument_list|,
name|seplen
argument_list|)
expr_stmt|;
name|res
operator|+=
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QStringList QStringList::operator+(const QStringList&other) const      Returns a string list that is the concatenation of this string     list with the \a other string list.      \sa append() */
end_comment
begin_comment
comment|/*!     \fn QStringList&QStringList::operator<<(const QString&str)      Appends the given string, \a str, to this string list and returns     a reference to the string list.      \sa append() */
end_comment
begin_comment
comment|/*!     \fn QStringList&QStringList::operator<<(const QStringList&other)      \overload      Appends the \a other string list to the string list and returns a reference to     the latter string list. */
end_comment
begin_comment
comment|/*!     \fn QStringList&QStringList::operator<<(const QList<QString>&other)     \since 5.4      \overload      Appends the \a other string list to the string list and returns a reference to     the latter string list. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_function
DECL|function|indexOfMutating
specifier|static
name|int
name|indexOfMutating
parameter_list|(
specifier|const
name|QStringList
modifier|*
name|that
parameter_list|,
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|int
name|from
parameter_list|)
block|{
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|=
name|qMax
argument_list|(
name|from
operator|+
name|that
operator|->
name|size
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|<
name|that
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rx
operator|.
name|exactMatch
argument_list|(
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|lastIndexOfMutating
specifier|static
name|int
name|lastIndexOfMutating
parameter_list|(
specifier|const
name|QStringList
modifier|*
name|that
parameter_list|,
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|int
name|from
parameter_list|)
block|{
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|+=
name|that
operator|->
name|size
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|>=
name|that
operator|->
name|size
argument_list|()
condition|)
name|from
operator|=
name|that
operator|->
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|rx
operator|.
name|exactMatch
argument_list|(
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QStringList::indexOf(const QRegExp&rx, int from) const      Returns the index position of the first exact match of \a rx in     the list, searching forward from index position \a from. Returns     -1 if no item matched.      By default, this function is case sensitive.      \sa lastIndexOf(), contains(), QRegExp::exactMatch() */
end_comment
begin_function
DECL|function|QStringList_indexOf
name|int
name|QtPrivate
operator|::
name|QStringList_indexOf
parameter_list|(
specifier|const
name|QStringList
modifier|*
name|that
parameter_list|,
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|QRegExp
name|rx2
argument_list|(
name|rx
argument_list|)
decl_stmt|;
return|return
name|indexOfMutating
argument_list|(
name|that
argument_list|,
name|rx2
argument_list|,
name|from
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QStringList::indexOf(QRegExp&rx, int from) const     \overload indexOf()     \since 4.5      Returns the index position of the first exact match of \a rx in     the list, searching forward from index position \a from. Returns     -1 if no item matched.      By default, this function is case sensitive.      If an item matched, the \a rx regular expression will contain the     matched objects (see QRegExp::matchedLength, QRegExp::cap).      \sa lastIndexOf(), contains(), QRegExp::exactMatch() */
end_comment
begin_function
DECL|function|QStringList_indexOf
name|int
name|QtPrivate
operator|::
name|QStringList_indexOf
parameter_list|(
specifier|const
name|QStringList
modifier|*
name|that
parameter_list|,
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|int
name|from
parameter_list|)
block|{
return|return
name|indexOfMutating
argument_list|(
name|that
argument_list|,
name|rx
argument_list|,
name|from
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QStringList::lastIndexOf(const QRegExp&rx, int from) const      Returns the index position of the last exact match of \a rx in     the list, searching backward from index position \a from. If \a     from is -1 (the default), the search starts at the last item.     Returns -1 if no item matched.      By default, this function is case sensitive.      \sa indexOf(), contains(), QRegExp::exactMatch() */
end_comment
begin_function
DECL|function|QStringList_lastIndexOf
name|int
name|QtPrivate
operator|::
name|QStringList_lastIndexOf
parameter_list|(
specifier|const
name|QStringList
modifier|*
name|that
parameter_list|,
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|QRegExp
name|rx2
argument_list|(
name|rx
argument_list|)
decl_stmt|;
return|return
name|lastIndexOfMutating
argument_list|(
name|that
argument_list|,
name|rx2
argument_list|,
name|from
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QStringList::lastIndexOf(QRegExp&rx, int from) const     \overload lastIndexOf()     \since 4.5      Returns the index position of the last exact match of \a rx in     the list, searching backward from index position \a from. If \a     from is -1 (the default), the search starts at the last item.     Returns -1 if no item matched.      By default, this function is case sensitive.      If an item matched, the \a rx regular expression will contain the     matched objects (see QRegExp::matchedLength, QRegExp::cap).      \sa indexOf(), contains(), QRegExp::exactMatch() */
end_comment
begin_function
DECL|function|QStringList_lastIndexOf
name|int
name|QtPrivate
operator|::
name|QStringList_lastIndexOf
parameter_list|(
specifier|const
name|QStringList
modifier|*
name|that
parameter_list|,
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|int
name|from
parameter_list|)
block|{
return|return
name|lastIndexOfMutating
argument_list|(
name|that
argument_list|,
name|rx
argument_list|,
name|from
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGULAREXPRESSION
end_ifndef
begin_comment
comment|/*!     \fn int QStringList::indexOf(const QRegularExpression&re, int from) const     \overload     \since 5.0      Returns the index position of the first match of \a re in     the list, searching forward from index position \a from. Returns     -1 if no item matched.      \sa lastIndexOf() */
end_comment
begin_function
DECL|function|QStringList_indexOf
name|int
name|QtPrivate
operator|::
name|QStringList_indexOf
parameter_list|(
specifier|const
name|QStringList
modifier|*
name|that
parameter_list|,
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
name|int
name|from
parameter_list|)
block|{
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|=
name|qMax
argument_list|(
name|from
operator|+
name|that
operator|->
name|size
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QString
name|exactPattern
init|=
name|QLatin1String
argument_list|(
literal|"\\A(?:"
argument_list|)
operator|+
name|re
operator|.
name|pattern
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|")\\z"
argument_list|)
decl_stmt|;
name|QRegularExpression
name|exactRe
argument_list|(
name|exactPattern
argument_list|,
name|re
operator|.
name|patternOptions
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|<
name|that
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QRegularExpressionMatch
name|m
init|=
name|exactRe
operator|.
name|match
argument_list|(
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|hasMatch
argument_list|()
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QStringList::lastIndexOf(const QRegularExpression&re, int from) const     \overload     \since 5.0      Returns the index position of the last exact match of \a re in     the list, searching backward from index position \a from. If \a     from is -1 (the default), the search starts at the last item.     Returns -1 if no item matched.      \sa indexOf() */
end_comment
begin_function
DECL|function|QStringList_lastIndexOf
name|int
name|QtPrivate
operator|::
name|QStringList_lastIndexOf
parameter_list|(
specifier|const
name|QStringList
modifier|*
name|that
parameter_list|,
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
name|int
name|from
parameter_list|)
block|{
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|+=
name|that
operator|->
name|size
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|>=
name|that
operator|->
name|size
argument_list|()
condition|)
name|from
operator|=
name|that
operator|->
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
name|QString
name|exactPattern
init|=
name|QLatin1String
argument_list|(
literal|"\\A(?:"
argument_list|)
operator|+
name|re
operator|.
name|pattern
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|")\\z"
argument_list|)
decl_stmt|;
name|QRegularExpression
name|exactRe
argument_list|(
name|exactPattern
argument_list|,
name|re
operator|.
name|patternOptions
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QRegularExpressionMatch
name|m
init|=
name|exactRe
operator|.
name|match
argument_list|(
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|hasMatch
argument_list|()
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGULAREXPRESSION
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BOOTSTRAPPED
end_comment
begin_comment
comment|/*!     \fn int QStringList::removeDuplicates()      \since  4.5      This function removes duplicate entries from a list.     The entries do not have to be sorted. They will retain their     original order.      Returns the number of removed entries. */
end_comment
begin_function
DECL|function|QStringList_removeDuplicates
name|int
name|QtPrivate
operator|::
name|QStringList_removeDuplicates
parameter_list|(
name|QStringList
modifier|*
name|that
parameter_list|)
block|{
name|int
name|n
init|=
name|that
operator|->
name|size
argument_list|()
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|seen
decl_stmt|;
name|seen
operator|.
name|reserve
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|int
name|setSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
modifier|&
name|s
init|=
name|that
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|seen
operator|.
name|insert
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|setSize
operator|==
name|seen
operator|.
name|size
argument_list|()
condition|)
comment|// unchanged size => was already seen
continue|continue;
operator|++
name|setSize
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|i
condition|)
name|that
operator|->
name|swap
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
name|j
condition|)
name|that
operator|->
name|erase
argument_list|(
name|that
operator|->
name|begin
argument_list|()
operator|+
name|j
argument_list|,
name|that
operator|->
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|n
operator|-
name|j
return|;
block|}
end_function
begin_comment
comment|/*! \fn QStringList::QStringList(std::initializer_list<QString> args)     \since 4.8      Construct a list from a std::initializer_list given by \a args.      This constructor is only enabled if the compiler supports C++11 initializer     lists. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
