begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtimeline.h"
end_include
begin_include
include|#
directive|include
file|<private/qobject_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qcoreevent.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmath.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qelapsedtimer.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QTimeLinePrivate
class|class
name|QTimeLinePrivate
super|:
specifier|public
name|QObjectPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QTimeLine
parameter_list|)
specifier|public
private|:
DECL|function|QTimeLinePrivate
specifier|inline
name|QTimeLinePrivate
parameter_list|()
member_init_list|:
name|startTime
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|duration
argument_list|(
literal|1000
argument_list|)
member_init_list|,
name|startFrame
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|endFrame
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|updateInterval
argument_list|(
literal|1000
operator|/
literal|25
argument_list|)
member_init_list|,
name|totalLoopCount
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|currentLoopCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|currentTime
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|timerId
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|direction
argument_list|(
name|QTimeLine
operator|::
name|Forward
argument_list|)
member_init_list|,
name|easingCurve
argument_list|(
name|QEasingCurve
operator|::
name|InOutSine
argument_list|)
member_init_list|,
name|state
argument_list|(
name|QTimeLine
operator|::
name|NotRunning
argument_list|)
block|{ }
DECL|member|startTime
name|int
name|startTime
decl_stmt|;
DECL|member|duration
name|int
name|duration
decl_stmt|;
DECL|member|startFrame
name|int
name|startFrame
decl_stmt|;
DECL|member|endFrame
name|int
name|endFrame
decl_stmt|;
DECL|member|updateInterval
name|int
name|updateInterval
decl_stmt|;
DECL|member|totalLoopCount
name|int
name|totalLoopCount
decl_stmt|;
DECL|member|currentLoopCount
name|int
name|currentLoopCount
decl_stmt|;
DECL|member|currentTime
name|int
name|currentTime
decl_stmt|;
DECL|member|timerId
name|int
name|timerId
decl_stmt|;
DECL|member|timer
name|QElapsedTimer
name|timer
decl_stmt|;
DECL|member|direction
name|QTimeLine
operator|::
name|Direction
name|direction
decl_stmt|;
DECL|member|easingCurve
name|QEasingCurve
name|easingCurve
decl_stmt|;
DECL|member|state
name|QTimeLine
operator|::
name|State
name|state
decl_stmt|;
DECL|function|setState
specifier|inline
name|void
name|setState
parameter_list|(
name|QTimeLine
operator|::
name|State
name|newState
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|newState
operator|!=
name|state
condition|)
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|state
operator|=
name|newState
argument_list|)
emit|;
block|}
name|void
name|setCurrentTime
parameter_list|(
name|int
name|msecs
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setCurrentTime
name|void
name|QTimeLinePrivate
operator|::
name|setCurrentTime
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
name|qreal
name|lastValue
init|=
name|q
operator|->
name|currentValue
argument_list|()
decl_stmt|;
name|int
name|lastFrame
init|=
name|q
operator|->
name|currentFrame
argument_list|()
decl_stmt|;
comment|// Determine if we are looping.
name|int
name|elapsed
init|=
operator|(
name|direction
operator|==
name|QTimeLine
operator|::
name|Backward
operator|)
condition|?
operator|(
operator|-
name|msecs
operator|+
name|duration
operator|)
else|:
name|msecs
decl_stmt|;
name|int
name|loopCount
init|=
name|elapsed
operator|/
name|duration
decl_stmt|;
name|bool
name|looping
init|=
operator|(
name|loopCount
operator|!=
name|currentLoopCount
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QTIMELINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QTimeLinePrivate::setCurrentTime:"
operator|<<
name|msecs
operator|<<
name|duration
operator|<<
literal|"with loopCount"
operator|<<
name|loopCount
operator|<<
literal|"currentLoopCount"
operator|<<
name|currentLoopCount
operator|<<
literal|"looping"
operator|<<
name|looping
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|looping
condition|)
name|currentLoopCount
operator|=
name|loopCount
expr_stmt|;
comment|// Normalize msecs to be between 0 and duration, inclusive.
name|currentTime
operator|=
name|elapsed
operator|%
name|duration
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|QTimeLine
operator|::
name|Backward
condition|)
name|currentTime
operator|=
name|duration
operator|-
name|currentTime
expr_stmt|;
comment|// Check if we have reached the end of loopcount.
name|bool
name|finished
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|totalLoopCount
operator|&&
name|currentLoopCount
operator|>=
name|totalLoopCount
condition|)
block|{
name|finished
operator|=
literal|true
expr_stmt|;
name|currentTime
operator|=
operator|(
name|direction
operator|==
name|QTimeLine
operator|::
name|Backward
operator|)
condition|?
literal|0
else|:
name|duration
expr_stmt|;
name|currentLoopCount
operator|=
name|totalLoopCount
operator|-
literal|1
expr_stmt|;
block|}
name|int
name|currentFrame
init|=
name|q
operator|->
name|frameForTime
argument_list|(
name|currentTime
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QTIMELINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QTimeLinePrivate::setCurrentTime: frameForTime"
operator|<<
name|currentTime
operator|<<
name|currentFrame
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|qFuzzyCompare
argument_list|(
name|lastValue
argument_list|,
name|q
operator|->
name|currentValue
argument_list|()
argument_list|)
condition|)
emit|emit
name|q
operator|->
name|valueChanged
argument_list|(
name|q
operator|->
name|currentValue
argument_list|()
argument_list|)
emit|;
if|if
condition|(
name|lastFrame
operator|!=
name|currentFrame
condition|)
block|{
specifier|const
name|int
name|transitionframe
init|=
operator|(
name|direction
operator|==
name|QTimeLine
operator|::
name|Forward
condition|?
name|endFrame
else|:
name|startFrame
operator|)
decl_stmt|;
if|if
condition|(
name|looping
operator|&&
operator|!
name|finished
operator|&&
name|transitionframe
operator|!=
name|currentFrame
condition|)
block|{
ifdef|#
directive|ifdef
name|QTIMELINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QTimeLinePrivate::setCurrentTime: transitionframe"
expr_stmt|;
endif|#
directive|endif
emit|emit
name|q
operator|->
name|frameChanged
argument_list|(
name|transitionframe
argument_list|)
emit|;
block|}
ifdef|#
directive|ifdef
name|QTIMELINE_DEBUG
else|else
block|{
name|QByteArray
name|reason
decl_stmt|;
if|if
condition|(
operator|!
name|looping
condition|)
name|reason
operator|+=
literal|" not looping"
expr_stmt|;
if|if
condition|(
name|finished
condition|)
block|{
if|if
condition|(
operator|!
name|reason
operator|.
name|isEmpty
argument_list|()
condition|)
name|reason
operator|+=
literal|" and"
expr_stmt|;
name|reason
operator|+=
literal|" finished"
expr_stmt|;
block|}
if|if
condition|(
name|transitionframe
operator|==
name|currentFrame
condition|)
block|{
if|if
condition|(
operator|!
name|reason
operator|.
name|isEmpty
argument_list|()
condition|)
name|reason
operator|+=
literal|" and"
expr_stmt|;
name|reason
operator|+=
literal|" transitionframe is equal to currentFrame: "
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|currentFrame
argument_list|)
expr_stmt|;
block|}
name|qDebug
argument_list|(
literal|"QTimeLinePrivate::setCurrentTime: not transitionframe because %s"
argument_list|,
name|reason
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
emit|emit
name|q
operator|->
name|frameChanged
argument_list|(
name|currentFrame
argument_list|)
emit|;
block|}
if|if
condition|(
name|finished
operator|&&
name|state
operator|==
name|QTimeLine
operator|::
name|Running
condition|)
block|{
name|q
operator|->
name|stop
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|finished
argument_list|()
emit|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QTimeLine     \brief The QTimeLine class provides a timeline for controlling animations.     \since 4.2     \ingroup animation      It's most commonly used to animate a GUI control by calling a slot     periodically. You can construct a timeline by passing its duration in     milliseconds to QTimeLine's constructor. The timeline's duration describes     for how long the animation will run. Then you set a suitable frame range     by calling setFrameRange(). Finally connect the frameChanged() signal to a     suitable slot in the widget you wish to animate (e.g., setValue() in     QProgressBar). When you proceed to calling start(), QTimeLine will enter     Running state, and start emitting frameChanged() at regular intervals,     causing your widget's connected property's value to grow from the lower     end to the upper and of your frame range, at a steady rate. You can     specify the update interval by calling setUpdateInterval(). When done,     QTimeLine enters NotRunning state, and emits finished().      Example:      \snippet code/src_corelib_tools_qtimeline.cpp 0      You can also use QTimeLine with the     \l{Graphics View}{Graphics View framework} for     animations. The QGraphicsItemAnimation class implements animation     of \l{QGraphicsItem}{QGraphicsItems} with a timeline.      By default the timeline runs once, from the beginning and towards the end,     upon which you must call start() again to restart from the beginning. To     make the timeline loop, you can call setLoopCount(), passing the number of     times the timeline should run before finishing. The direction can also be     changed, causing the timeline to run backward, by calling     setDirection(). You can also pause and unpause the timeline while it's     running by calling setPaused(). For interactive control, the     setCurrentTime() function is provided, which sets the time position of the     time line directly. Although most useful in NotRunning state, (e.g.,     connected to a valueChanged() signal in a QSlider,) this function can be     called at any time.      The frame interface is useful for standard widgets, but QTimeLine can be     used to control any type of animation. The heart of QTimeLine lies in the     valueForTime() function, which generates a \e value between 0 and 1 for a     given time. This value is typically used to describe the steps of an     animation, where 0 is the first step of an animation, and 1 is the last     step. When running, QTimeLine generates values between 0 and 1 by calling     valueForTime() and emitting valueChanged(). By default, valueForTime()     applies an interpolation algorithm to generate these value. You can choose     from a set of predefined timeline algorithms by calling     setCurveShape().      Note that by default, QTimeLine uses the EaseInOut curve shape,     which provides a value that grows slowly, then grows steadily, and     finally grows slowly. For a custom timeline, you can reimplement     valueForTime(), in which case QTimeLine's curveShape property is ignored.      \sa QProgressBar, QProgressDialog, QGraphicsItemAnimation */
end_comment
begin_comment
comment|/*!     \enum QTimeLine::State      This enum describes the state of the timeline.      \value NotRunning The timeline is not running. This is the initial state     of QTimeLine, and the state QTimeLine reenters when finished. The current     time, frame and value remain unchanged until either setCurrentTime() is     called, or the timeline is started by calling start().      \value Paused The timeline is paused (i.e., temporarily     suspended). Calling setPaused(false) will resume timeline activity.      \value Running The timeline is running. While control is in the event     loop, QTimeLine will update its current time at regular intervals,     emitting valueChanged() and frameChanged() when appropriate.      \sa state(), stateChanged() */
end_comment
begin_comment
comment|/*!     \enum QTimeLine::Direction      This enum describes the direction of the timeline when in \l Running state.      \value Forward The current time of the timeline increases with time (i.e.,     moves from 0 and towards the end / duration).      \value Backward The current time of the timeline decreases with time (i.e.,     moves from the end / duration and towards 0).      \sa setDirection() */
end_comment
begin_comment
comment|/*!     \enum QTimeLine::CurveShape      This enum describes the default shape of QTimeLine's value curve. The     default, shape is EaseInOutCurve. The curve defines the relation     between the value and the timeline.      \value EaseInCurve The value starts growing slowly, then increases in speed.     \value EaseOutCurve The value starts growing steadily, then ends slowly.     \value EaseInOutCurve The value starts growing slowly, then runs steadily, then grows slowly again.     \value LinearCurve The value grows linearly (e.g., if the duration is 1000 ms,            the value at time 500 ms is 0.5).     \value SineCurve The value grows sinusoidally.     \value CosineCurve The value grows cosinusoidally.      \sa setCurveShape() */
end_comment
begin_comment
comment|/*!     \fn QTimeLine::valueChanged(qreal value)      QTimeLine emits this signal at regular intervals when in \l Running state,     but only if the current value changes. \a value is the current value. \a value is     a number between 0.0 and 1.0      \sa QTimeLine::setDuration(), QTimeLine::valueForTime(), QTimeLine::updateInterval */
end_comment
begin_comment
comment|/*!     \fn QTimeLine::frameChanged(int frame)      QTimeLine emits this signal at regular intervals when in \l Running state,     but only if the current frame changes. \a frame is the current frame number.      \sa QTimeLine::setFrameRange(), QTimeLine::updateInterval */
end_comment
begin_comment
comment|/*!     \fn QTimeLine::stateChanged(QTimeLine::State newState)      This signal is emitted whenever QTimeLine's state changes. The new state     is \a newState. */
end_comment
begin_comment
comment|/*!     \fn QTimeLine::finished()      This signal is emitted when QTimeLine finishes (i.e., reaches the end of     its time line), and does not loop. */
end_comment
begin_comment
comment|/*!     Constructs a timeline with a duration of \a duration milliseconds. \a     parent is passed to QObject's constructor. The default duration is 1000     milliseconds.  */
end_comment
begin_constructor
DECL|function|QTimeLine
name|QTimeLine
operator|::
name|QTimeLine
parameter_list|(
name|int
name|duration
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QTimeLinePrivate
argument_list|,
name|parent
argument_list|)
block|{
name|setDuration
argument_list|(
name|duration
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the timeline.  */
end_comment
begin_destructor
DECL|function|~QTimeLine
name|QTimeLine
operator|::
name|~
name|QTimeLine
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|Running
condition|)
name|stop
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns the state of the timeline.      \sa start(), setPaused(), stop() */
end_comment
begin_function
DECL|function|state
name|QTimeLine
operator|::
name|State
name|QTimeLine
operator|::
name|state
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|state
return|;
block|}
end_function
begin_comment
comment|/*!     \property QTimeLine::loopCount     \brief the number of times the timeline should loop before it's finished.      A loop count of of 0 means that the timeline will loop forever.      By default, this property contains a value of 1. */
end_comment
begin_function
DECL|function|loopCount
name|int
name|QTimeLine
operator|::
name|loopCount
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|totalLoopCount
return|;
block|}
end_function
begin_function
DECL|function|setLoopCount
name|void
name|QTimeLine
operator|::
name|setLoopCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
name|d
operator|->
name|totalLoopCount
operator|=
name|count
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTimeLine::direction     \brief the direction of the timeline when QTimeLine is in \l Running     state.      This direction indicates whether the time moves from 0 towards the     timeline duration, or from the value of the duration and towards 0 after     start() has been called.      By default, this property is set to \l Forward. */
end_comment
begin_function
DECL|function|direction
name|QTimeLine
operator|::
name|Direction
name|QTimeLine
operator|::
name|direction
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|direction
return|;
block|}
end_function
begin_function
DECL|function|setDirection
name|void
name|QTimeLine
operator|::
name|setDirection
parameter_list|(
name|Direction
name|direction
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
name|d
operator|->
name|direction
operator|=
name|direction
expr_stmt|;
name|d
operator|->
name|startTime
operator|=
name|d
operator|->
name|currentTime
expr_stmt|;
name|d
operator|->
name|timer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTimeLine::duration     \brief the total duration of the timeline in milliseconds.      By default, this value is 1000 (i.e., 1 second), but you can change this     by either passing a duration to QTimeLine's constructor, or by calling     setDuration(). The duration must be larger than 0.      \note Changing the duration does not cause the current time to be reset     to zero or the new duration. You also need to call setCurrentTime() with     the desired value. */
end_comment
begin_function
DECL|function|duration
name|int
name|QTimeLine
operator|::
name|duration
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|duration
return|;
block|}
end_function
begin_function
DECL|function|setDuration
name|void
name|QTimeLine
operator|::
name|setDuration
parameter_list|(
name|int
name|duration
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|duration
operator|<=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTimeLine::setDuration: cannot set duration<= 0"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|duration
operator|=
name|duration
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the start frame, which is the frame corresponding to the start of     the timeline (i.e., the frame for which the current value is 0).      \sa setStartFrame(), setFrameRange() */
end_comment
begin_function
DECL|function|startFrame
name|int
name|QTimeLine
operator|::
name|startFrame
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|startFrame
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the start frame, which is the frame corresponding to the start of the     timeline (i.e., the frame for which the current value is 0), to \a frame.      \sa startFrame(), endFrame(), setFrameRange() */
end_comment
begin_function
DECL|function|setStartFrame
name|void
name|QTimeLine
operator|::
name|setStartFrame
parameter_list|(
name|int
name|frame
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
name|d
operator|->
name|startFrame
operator|=
name|frame
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the end frame, which is the frame corresponding to the end of the     timeline (i.e., the frame for which the current value is 1).      \sa setEndFrame(), setFrameRange() */
end_comment
begin_function
DECL|function|endFrame
name|int
name|QTimeLine
operator|::
name|endFrame
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|endFrame
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the end frame, which is the frame corresponding to the end of the     timeline (i.e., the frame for which the current value is 1), to \a frame.      \sa endFrame(), startFrame(), setFrameRange() */
end_comment
begin_function
DECL|function|setEndFrame
name|void
name|QTimeLine
operator|::
name|setEndFrame
parameter_list|(
name|int
name|frame
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
name|d
operator|->
name|endFrame
operator|=
name|frame
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the timeline's frame counter to start at \a startFrame, and end and     \a endFrame. For each time value, QTimeLine will find the corresponding     frame when you call currentFrame() or frameForTime() by interpolating,     using the return value of valueForTime().      When in Running state, QTimeLine also emits the frameChanged() signal when     the frame changes.      \sa startFrame(), endFrame(), start(), currentFrame() */
end_comment
begin_function
DECL|function|setFrameRange
name|void
name|QTimeLine
operator|::
name|setFrameRange
parameter_list|(
name|int
name|startFrame
parameter_list|,
name|int
name|endFrame
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
name|d
operator|->
name|startFrame
operator|=
name|startFrame
expr_stmt|;
name|d
operator|->
name|endFrame
operator|=
name|endFrame
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTimeLine::updateInterval     \brief the time in milliseconds between each time QTimeLine updates its     current time.      When updating the current time, QTimeLine will emit valueChanged() if the     current value changed, and frameChanged() if the frame changed.      By default, the interval is 40 ms, which corresponds to a rate of 25     updates per second. */
end_comment
begin_function
DECL|function|updateInterval
name|int
name|QTimeLine
operator|::
name|updateInterval
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|updateInterval
return|;
block|}
end_function
begin_function
DECL|function|setUpdateInterval
name|void
name|QTimeLine
operator|::
name|setUpdateInterval
parameter_list|(
name|int
name|interval
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
name|d
operator|->
name|updateInterval
operator|=
name|interval
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTimeLine::curveShape     \brief the shape of the timeline curve.      The curve shape describes the relation between the time and value for the     base implementation of valueForTime().      If you have reimplemented valueForTime(), this value is ignored.      By default, this property is set to \l EaseInOutCurve.      \sa valueForTime() */
end_comment
begin_function
DECL|function|curveShape
name|QTimeLine
operator|::
name|CurveShape
name|QTimeLine
operator|::
name|curveShape
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|easingCurve
operator|.
name|type
argument_list|()
condition|)
block|{
default|default:
case|case
name|QEasingCurve
operator|::
name|InOutSine
case|:
return|return
name|EaseInOutCurve
return|;
case|case
name|QEasingCurve
operator|::
name|InCurve
case|:
return|return
name|EaseInCurve
return|;
case|case
name|QEasingCurve
operator|::
name|OutCurve
case|:
return|return
name|EaseOutCurve
return|;
case|case
name|QEasingCurve
operator|::
name|Linear
case|:
return|return
name|LinearCurve
return|;
case|case
name|QEasingCurve
operator|::
name|SineCurve
case|:
return|return
name|SineCurve
return|;
case|case
name|QEasingCurve
operator|::
name|CosineCurve
case|:
return|return
name|CosineCurve
return|;
block|}
return|return
name|EaseInOutCurve
return|;
block|}
end_function
begin_function
DECL|function|setCurveShape
name|void
name|QTimeLine
operator|::
name|setCurveShape
parameter_list|(
name|CurveShape
name|shape
parameter_list|)
block|{
switch|switch
condition|(
name|shape
condition|)
block|{
default|default:
case|case
name|EaseInOutCurve
case|:
name|setEasingCurve
argument_list|(
name|QEasingCurve
argument_list|(
name|QEasingCurve
operator|::
name|InOutSine
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EaseInCurve
case|:
name|setEasingCurve
argument_list|(
name|QEasingCurve
argument_list|(
name|QEasingCurve
operator|::
name|InCurve
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EaseOutCurve
case|:
name|setEasingCurve
argument_list|(
name|QEasingCurve
argument_list|(
name|QEasingCurve
operator|::
name|OutCurve
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LinearCurve
case|:
name|setEasingCurve
argument_list|(
name|QEasingCurve
argument_list|(
name|QEasingCurve
operator|::
name|Linear
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SineCurve
case|:
name|setEasingCurve
argument_list|(
name|QEasingCurve
argument_list|(
name|QEasingCurve
operator|::
name|SineCurve
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CosineCurve
case|:
name|setEasingCurve
argument_list|(
name|QEasingCurve
argument_list|(
name|QEasingCurve
operator|::
name|CosineCurve
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     \property QTimeLine::easingCurve      \since 4.6      Specifies the easing curve that the timeline will use.     If both easing curve and curveShape are set, the last set property will     override the previous one. (If valueForTime() is reimplemented it will     override both) */
end_comment
begin_function
DECL|function|easingCurve
name|QEasingCurve
name|QTimeLine
operator|::
name|easingCurve
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|easingCurve
return|;
block|}
end_function
begin_function
DECL|function|setEasingCurve
name|void
name|QTimeLine
operator|::
name|setEasingCurve
parameter_list|(
specifier|const
name|QEasingCurve
modifier|&
name|curve
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
name|d
operator|->
name|easingCurve
operator|=
name|curve
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \property QTimeLine::currentTime     \brief the current time of the time line.      When QTimeLine is in Running state, this value is updated continuously as     a function of the duration and direction of the timeline. Otherwise, it is     value that was current when stop() was called last, or the value set by     setCurrentTime().      By default, this property contains a value of 0. */
end_comment
begin_function
DECL|function|currentTime
name|int
name|QTimeLine
operator|::
name|currentTime
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|currentTime
return|;
block|}
end_function
begin_function
DECL|function|setCurrentTime
name|void
name|QTimeLine
operator|::
name|setCurrentTime
parameter_list|(
name|int
name|msec
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
name|d
operator|->
name|startTime
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|currentLoopCount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|timer
operator|.
name|restart
argument_list|()
expr_stmt|;
name|d
operator|->
name|setCurrentTime
argument_list|(
name|msec
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the frame corresponding to the current time.      \sa currentTime(), frameForTime(), setFrameRange() */
end_comment
begin_function
DECL|function|currentFrame
name|int
name|QTimeLine
operator|::
name|currentFrame
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
return|return
name|frameForTime
argument_list|(
name|d
operator|->
name|currentTime
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the value corresponding to the current time.      \sa valueForTime(), currentFrame() */
end_comment
begin_function
DECL|function|currentValue
name|qreal
name|QTimeLine
operator|::
name|currentValue
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
return|return
name|valueForTime
argument_list|(
name|d
operator|->
name|currentTime
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the frame corresponding to the time \a msec. This value is     calculated using a linear interpolation of the start and end frame, based     on the value returned by valueForTime().      \sa valueForTime(), setFrameRange() */
end_comment
begin_function
DECL|function|frameForTime
name|int
name|QTimeLine
operator|::
name|frameForTime
parameter_list|(
name|int
name|msec
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|direction
operator|==
name|Forward
condition|)
return|return
name|d
operator|->
name|startFrame
operator|+
name|int
argument_list|(
operator|(
name|d
operator|->
name|endFrame
operator|-
name|d
operator|->
name|startFrame
operator|)
operator|*
name|valueForTime
argument_list|(
name|msec
argument_list|)
argument_list|)
return|;
return|return
name|d
operator|->
name|startFrame
operator|+
name|qCeil
argument_list|(
operator|(
name|d
operator|->
name|endFrame
operator|-
name|d
operator|->
name|startFrame
operator|)
operator|*
name|valueForTime
argument_list|(
name|msec
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the timeline value for the time \a msec. The returned value, which     varies depending on the curve shape, is always between 0 and 1. If \a msec     is 0, the default implementation always returns 0.      Reimplement this function to provide a custom curve shape for your     timeline.      \sa CurveShape, frameForTime() */
end_comment
begin_function
DECL|function|valueForTime
name|qreal
name|QTimeLine
operator|::
name|valueForTime
parameter_list|(
name|int
name|msec
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTimeLine
argument_list|)
expr_stmt|;
name|msec
operator|=
name|qMin
argument_list|(
name|qMax
argument_list|(
name|msec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|d
operator|->
name|duration
argument_list|)
expr_stmt|;
name|qreal
name|value
init|=
name|msec
operator|/
name|qreal
argument_list|(
name|d
operator|->
name|duration
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|easingCurve
operator|.
name|valueForProgress
argument_list|(
name|value
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Starts the timeline. QTimeLine will enter Running state, and once it     enters the event loop, it will update its current time, frame and value at     regular intervals. The default interval is 40 ms (i.e., 25 times per     second). You can change the update interval by calling     setUpdateInterval().      The timeline will start from position 0, or the end if going backward.     If you want to resume a stopped timeline without restarting, you can call     resume() instead.      \sa resume(), updateInterval(), frameChanged(), valueChanged() */
end_comment
begin_function
DECL|function|start
name|void
name|QTimeLine
operator|::
name|start
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|timerId
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTimeLine::start: already running"
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|curTime
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|direction
operator|==
name|Backward
condition|)
name|curTime
operator|=
name|d
operator|->
name|duration
expr_stmt|;
name|d
operator|->
name|timerId
operator|=
name|startTimer
argument_list|(
name|d
operator|->
name|updateInterval
argument_list|)
expr_stmt|;
name|d
operator|->
name|startTime
operator|=
name|curTime
expr_stmt|;
name|d
operator|->
name|currentLoopCount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|timer
operator|.
name|start
argument_list|()
expr_stmt|;
name|d
operator|->
name|setState
argument_list|(
name|Running
argument_list|)
expr_stmt|;
name|d
operator|->
name|setCurrentTime
argument_list|(
name|curTime
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Resumes the timeline from the current time. QTimeLine will reenter Running     state, and once it enters the event loop, it will update its current time,     frame and value at regular intervals.      In contrast to start(), this function does not restart the timeline before     it resumes.      \sa start(), updateInterval(), frameChanged(), valueChanged() */
end_comment
begin_function
DECL|function|resume
name|void
name|QTimeLine
operator|::
name|resume
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|timerId
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTimeLine::resume: already running"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|timerId
operator|=
name|startTimer
argument_list|(
name|d
operator|->
name|updateInterval
argument_list|)
expr_stmt|;
name|d
operator|->
name|startTime
operator|=
name|d
operator|->
name|currentTime
expr_stmt|;
name|d
operator|->
name|timer
operator|.
name|start
argument_list|()
expr_stmt|;
name|d
operator|->
name|setState
argument_list|(
name|Running
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Stops the timeline, causing QTimeLine to enter NotRunning state.      \sa start() */
end_comment
begin_function
DECL|function|stop
name|void
name|QTimeLine
operator|::
name|stop
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|timerId
condition|)
name|killTimer
argument_list|(
name|d
operator|->
name|timerId
argument_list|)
expr_stmt|;
name|d
operator|->
name|setState
argument_list|(
name|NotRunning
argument_list|)
expr_stmt|;
name|d
operator|->
name|timerId
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     If \a paused is true, the timeline is paused, causing QTimeLine to enter     Paused state. No updates will be signaled until either start() or     setPaused(false) is called. If \a paused is false, the timeline is resumed     and continues where it left.      \sa state(), start() */
end_comment
begin_function
DECL|function|setPaused
name|void
name|QTimeLine
operator|::
name|setPaused
parameter_list|(
name|bool
name|paused
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|NotRunning
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTimeLine::setPaused: Not running"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|paused
operator|&&
name|d
operator|->
name|state
operator|!=
name|Paused
condition|)
block|{
name|d
operator|->
name|startTime
operator|=
name|d
operator|->
name|currentTime
expr_stmt|;
name|killTimer
argument_list|(
name|d
operator|->
name|timerId
argument_list|)
expr_stmt|;
name|d
operator|->
name|timerId
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|setState
argument_list|(
name|Paused
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|paused
operator|&&
name|d
operator|->
name|state
operator|==
name|Paused
condition|)
block|{
name|d
operator|->
name|timerId
operator|=
name|startTimer
argument_list|(
name|d
operator|->
name|updateInterval
argument_list|)
expr_stmt|;
name|d
operator|->
name|setState
argument_list|(
name|Running
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Toggles the direction of the timeline. If the direction was Forward, it     becomes Backward, and vice verca.      \sa setDirection() */
end_comment
begin_function
DECL|function|toggleDirection
name|void
name|QTimeLine
operator|::
name|toggleDirection
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
name|setDirection
argument_list|(
name|d
operator|->
name|direction
operator|==
name|Forward
condition|?
name|Backward
else|:
name|Forward
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|timerEvent
name|void
name|QTimeLine
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTimeLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|timerId
argument_list|()
operator|!=
name|d
operator|->
name|timerId
condition|)
block|{
name|event
operator|->
name|ignore
argument_list|()
expr_stmt|;
return|return;
block|}
name|event
operator|->
name|accept
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|direction
operator|==
name|Forward
condition|)
block|{
name|d
operator|->
name|setCurrentTime
argument_list|(
name|d
operator|->
name|startTime
operator|+
name|d
operator|->
name|timer
operator|.
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|setCurrentTime
argument_list|(
name|d
operator|->
name|startTime
operator|-
name|d
operator|->
name|timer
operator|.
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
