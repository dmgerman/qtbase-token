begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qline.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qmath.h"
end_include
begin_include
include|#
directive|include
file|<private/qnumeric_p.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QLine     \inmodule QtCore     \ingroup painting      \brief The QLine class provides a two-dimensional vector using     integer precision.      A QLine describes a finite length line (or a line segment) on a     two-dimensional surface. The start and end points of the line are     specified using integer point accuracy for coordinates. Use the     QLineF constructor to retrieve a floating point copy.      \table     \row         \li \inlineimage qline-point.png         \li \inlineimage qline-coordinates.png     \endtable      The positions of the line's start and end points can be retrieved     using the p1(), x1(), y1(), p2(), x2(), and y2() functions. The     dx() and dy() functions return the horizontal and vertical     components of the line. Use isNull() to determine whether the     QLine represents a valid line or a null line.      Finally, the line can be translated a given offset using the     translate() function.      \sa QLineF, QPolygon, QRect */
comment|/*!     \fn QLine::QLine()      Constructs a null line. */
comment|/*!     \fn QLine::QLine(const QPoint&p1, const QPoint&p2)      Constructs a line object that represents the line between \a p1 and     \a p2. */
comment|/*!     \fn QLine::QLine(int x1, int y1, int x2, int y2)      Constructs a line object that represents the line between (\a x1, \a y1) and     (\a x2, \a y2). */
comment|/*!     \fn bool QLine::isNull() const      Returns true if the line is not set up with valid start and end point;     otherwise returns false. */
comment|/*!     \fn QPoint QLine::p1() const      Returns the line's start point.      \sa x1(), y1(), p2() */
comment|/*!     \fn QPoint QLine::p2() const      Returns the line's end point.      \sa x2(), y2(), p1() */
comment|/*!     \fn int QLine::x1() const      Returns the x-coordinate of the line's start point.      \sa p1() */
comment|/*!     \fn int QLine::y1() const      Returns the y-coordinate of the line's start point.      \sa p1() */
comment|/*!     \fn int QLine::x2() const      Returns the x-coordinate of the line's end point.      \sa p2() */
comment|/*!     \fn int QLine::y2() const      Returns the y-coordinate of the line's end point.      \sa p2() */
comment|/*!     \fn int QLine::dx() const      Returns the horizontal component of the line's vector.      \sa dy() */
comment|/*!     \fn int QLine::dy() const      Returns the vertical component of the line's vector.      \sa dx() */
comment|/*!     \fn bool QLine::operator!=(const QLine&line) const      Returns true if the given \a line is not the same as \e this line.      A line is different from another line if any of their start or     end points differ, or the internal order of the points is different. */
comment|/*!     \fn bool QLine::operator==(const QLine&line) const      Returns true if the given \a line is the same as \e this line.      A line is identical to another line if the start and end points     are identical, and the internal order of the points is the same. */
comment|/*!     \fn void QLine::translate(const QPoint&offset)      Translates this line by the given \a offset. */
comment|/*!     \fn void QLine::translate(int dx, int dy)     \overload      Translates this line the distance specified by \a dx and \a dy. */
comment|/*!     \fn QLine QLine::translated(const QPoint&offset) const      \since 4.4      Returns this line translated by the given \a offset. */
comment|/*!     \fn QLine QLine::translated(int dx, int dy) const     \overload     \since 4.4      Returns this line translated the distance specified by \a dx and \a dy. */
comment|/*!     \fn void QLine::setP1(const QPoint&p1)     \since 4.4      Sets the starting point of this line to \a p1.      \sa setP2(), p1() */
comment|/*!     \fn void QLine::setP2(const QPoint&p2)     \since 4.4      Sets the end point of this line to \a p2.      \sa setP1(), p2() */
comment|/*!     \fn void QLine::setPoints(const QPoint&p1, const QPoint&p2)     \since 4.4      Sets the start point of this line to \a p1 and the end point of this line to \a p2.      \sa setP1(), setP2(), p1(), p2() */
comment|/*!     \fn void QLine::setLine(int x1, int y1, int x2, int y2)     \since 4.4      Sets this line to the start in \a x1, \a y1 and end in \a x2, \a y2.      \sa setP1(), setP2(), p1(), p2() */
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|d
parameter_list|,
specifier|const
name|QLine
modifier|&
name|p
parameter_list|)
block|{
name|d
operator|<<
literal|"QLine("
operator|<<
name|p
operator|.
name|p1
argument_list|()
operator|<<
literal|','
operator|<<
name|p
operator|.
name|p2
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \relates QLine      Writes the given \a line to the given \a stream and returns a     reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
specifier|const
name|QLine
modifier|&
name|line
parameter_list|)
block|{
name|stream
operator|<<
name|line
operator|.
name|p1
argument_list|()
operator|<<
name|line
operator|.
name|p2
argument_list|()
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QLine      Reads a line from the given \a stream into the given \a line and     returns a reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
name|QLine
modifier|&
name|line
parameter_list|)
block|{
name|QPoint
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|stream
operator|>>
name|p1
expr_stmt|;
name|stream
operator|>>
name|p2
expr_stmt|;
name|line
operator|=
name|QLine
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|M_2PI
end_ifndef
begin_define
DECL|macro|M_2PI
define|#
directive|define
name|M_2PI
value|6.28318530717958647692528676655900576
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \class QLineF     \inmodule QtCore     \ingroup painting      \brief The QLineF class provides a two-dimensional vector using     floating point precision.      A QLineF describes a finite length line (or line segment) on a     two-dimensional surface. QLineF defines the start and end points     of the line using floating point accuracy for coordinates.  Use     the toLine() function to retrieve an integer based copy of this     line.      \table     \row         \li \inlineimage qline-point.png         \li \inlineimage qline-coordinates.png     \endtable      The positions of the line's start and end points can be retrieved     using the p1(), x1(), y1(), p2(), x2(), and y2() functions. The     dx() and dy() functions return the horizontal and vertical     components of the line, respectively.      The line's length can be retrieved using the length() function,     and altered using the setLength() function.  Similarly, angle()     and setAngle() are respectively used for retrieving and altering     the angle of the line. Use the isNull()     function to determine whether the QLineF represents a valid line     or a null line.      The intersect() function determines the IntersectType for this     line and a given line, while the angle() function returns the     angle between the lines. In addition, the unitVector() function     returns a line that has the same starting point as this line, but     with a length of only 1, while the normalVector() function returns     a line that is perpendicular to this line with the same starting     point and length.      Finally, the line can be translated a given offset using the     translate() function, and can be traversed using the pointAt()     function.      \sa QLine, QPolygonF, QRectF */
end_comment
begin_comment
comment|/*!     \enum QLineF::IntersectType      Describes the intersection between two lines.      \table     \row     \li \inlineimage qlinef-unbounded.png     \li \inlineimage qlinef-bounded.png     \row     \li QLineF::UnboundedIntersection     \li QLineF::BoundedIntersection     \endtable      \value NoIntersection Indicates that the lines do not intersect;     i.e. they are parallel.      \value UnboundedIntersection The two lines intersect, but not     within the range defined by their lengths. This will be the case     if the lines are not parallel.      intersect() will also return this value if the intersect point is     within the start and end point of only one of the lines.      \value BoundedIntersection The two lines intersect with each other     within the start and end points of each line.      \sa intersect() */
end_comment
begin_comment
comment|/*!     \fn QLineF::QLineF()      Constructs a null line. */
end_comment
begin_comment
comment|/*!     \fn QLineF::QLineF(const QPointF&p1, const QPointF&p2)      Constructs a line object that represents the line between \a p1 and     \a p2. */
end_comment
begin_comment
comment|/*!     \fn QLineF::QLineF(qreal x1, qreal y1, qreal x2, qreal y2)      Constructs a line object that represents the line between (\a x1, \a y1) and     (\a x2, \a y2). */
end_comment
begin_comment
comment|/*!     \fn QLineF::QLineF(const QLine&line)      Construct a QLineF object from the given integer-based \a line.      \sa toLine() */
end_comment
begin_comment
comment|/*!     \fn bool QLineF::isNull() const      Returns true if the line is not set up with valid start and end point;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QPointF QLineF::p1() const      Returns the line's start point.      \sa x1(), y1(), p2() */
end_comment
begin_comment
comment|/*!     \fn QPointF QLineF::p2() const      Returns the line's end point.      \sa x2(), y2(), p1() */
end_comment
begin_comment
comment|/*!     \fn QLine QLineF::toLine() const      Returns an integer based copy of this line.      Note that the returned line's start and end points are rounded to     the nearest integer.      \sa QLineF() */
end_comment
begin_comment
comment|/*!     \fn qreal QLineF::x1() const      Returns the x-coordinate of the line's start point.      \sa p1() */
end_comment
begin_comment
comment|/*!     \fn qreal QLineF::y1() const      Returns the y-coordinate of the line's start point.      \sa p1() */
end_comment
begin_comment
comment|/*!     \fn qreal QLineF::x2() const      Returns the x-coordinate of the line's end point.      \sa p2() */
end_comment
begin_comment
comment|/*!     \fn qreal QLineF::y2() const      Returns the y-coordinate of the line's end point.      \sa p2() */
end_comment
begin_comment
comment|/*!     \fn qreal QLineF::dx() const      Returns the horizontal component of the line's vector.      \sa dy(), pointAt() */
end_comment
begin_comment
comment|/*!     \fn qreal QLineF::dy() const      Returns the vertical component of the line's vector.      \sa dx(), pointAt() */
end_comment
begin_comment
comment|/*!     \fn QLineF::setLength(qreal length)      Sets the length of the line to the given \a length. QLineF will     move the end point - p2() - of the line to give the line its new length.      If the line is a null line, the length will remain zero regardless     of the length specified.      \sa length(), isNull() */
end_comment
begin_comment
comment|/*!     \fn QLineF QLineF::normalVector() const      Returns a line that is perpendicular to this line with the same starting     point and length.      \image qlinef-normalvector.png      \sa unitVector() */
end_comment
begin_comment
comment|/*!     \fn bool QLineF::operator!=(const QLineF&line) const      Returns true if the given \a line is not the same as \e this line.      A line is different from another line if their start or end points     differ, or the internal order of the points is different. */
end_comment
begin_comment
comment|/*!     \fn bool QLineF::operator==(const QLineF&line) const      Returns true if the given \a line is the same as this line.      A line is identical to another line if the start and end points     are identical, and the internal order of the points is the same. */
end_comment
begin_comment
comment|/*!   \fn qreal QLineF::pointAt(qreal t) const    Returns the point at the parameterized position specified by \a   t. The function returns the line's start point if t = 0, and its end   point if t = 1.    \sa dx(), dy() */
end_comment
begin_comment
comment|/*!     Returns the length of the line.      \sa setLength() */
end_comment
begin_function
DECL|function|length
name|qreal
name|QLineF
operator|::
name|length
parameter_list|()
specifier|const
block|{
name|qreal
name|x
init|=
name|pt2
operator|.
name|x
argument_list|()
operator|-
name|pt1
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|pt2
operator|.
name|y
argument_list|()
operator|-
name|pt1
operator|.
name|y
argument_list|()
decl_stmt|;
return|return
name|qSqrt
argument_list|(
name|x
operator|*
name|x
operator|+
name|y
operator|*
name|y
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the angle of the line in degrees.      The return value will be in the range of values from 0.0 up to but not     including 360.0. The angles are measured counter-clockwise from a point     on the x-axis to the right of the origin (x> 0).      \sa setAngle() */
end_comment
begin_function
DECL|function|angle
name|qreal
name|QLineF
operator|::
name|angle
parameter_list|()
specifier|const
block|{
specifier|const
name|qreal
name|dx
init|=
name|pt2
operator|.
name|x
argument_list|()
operator|-
name|pt1
operator|.
name|x
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|dy
init|=
name|pt2
operator|.
name|y
argument_list|()
operator|-
name|pt1
operator|.
name|y
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|theta
init|=
name|qAtan2
argument_list|(
operator|-
name|dy
argument_list|,
name|dx
argument_list|)
operator|*
literal|360.0
operator|/
name|M_2PI
decl_stmt|;
specifier|const
name|qreal
name|theta_normalized
init|=
name|theta
operator|<
literal|0
condition|?
name|theta
operator|+
literal|360
else|:
name|theta
decl_stmt|;
if|if
condition|(
name|qFuzzyCompare
argument_list|(
name|theta_normalized
argument_list|,
name|qreal
argument_list|(
literal|360
argument_list|)
argument_list|)
condition|)
return|return
name|qreal
argument_list|(
literal|0
argument_list|)
return|;
else|else
return|return
name|theta_normalized
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the angle of the line to the given \a angle (in degrees).     This will change the position of the second point of the line such that     the line has the given angle.      Positive values for the angles mean counter-clockwise while negative values     mean the clockwise direction. Zero degrees is at the 3 o'clock position.      \sa angle() */
end_comment
begin_function
DECL|function|setAngle
name|void
name|QLineF
operator|::
name|setAngle
parameter_list|(
name|qreal
name|angle
parameter_list|)
block|{
specifier|const
name|qreal
name|angleR
init|=
name|angle
operator|*
name|M_2PI
operator|/
literal|360.0
decl_stmt|;
specifier|const
name|qreal
name|l
init|=
name|length
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|dx
init|=
name|qCos
argument_list|(
name|angleR
argument_list|)
operator|*
name|l
decl_stmt|;
specifier|const
name|qreal
name|dy
init|=
operator|-
name|qSin
argument_list|(
name|angleR
argument_list|)
operator|*
name|l
decl_stmt|;
name|pt2
operator|.
name|rx
argument_list|()
operator|=
name|pt1
operator|.
name|x
argument_list|()
operator|+
name|dx
expr_stmt|;
name|pt2
operator|.
name|ry
argument_list|()
operator|=
name|pt1
operator|.
name|y
argument_list|()
operator|+
name|dy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns a QLineF with the given \a length and \a angle.      The first point of the line will be on the origin.      Positive values for the angles mean counter-clockwise while negative values     mean the clockwise direction. Zero degrees is at the 3 o'clock position. */
end_comment
begin_function
DECL|function|fromPolar
name|QLineF
name|QLineF
operator|::
name|fromPolar
parameter_list|(
name|qreal
name|length
parameter_list|,
name|qreal
name|angle
parameter_list|)
block|{
specifier|const
name|qreal
name|angleR
init|=
name|angle
operator|*
name|M_2PI
operator|/
literal|360.0
decl_stmt|;
return|return
name|QLineF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|qCos
argument_list|(
name|angleR
argument_list|)
operator|*
name|length
argument_list|,
operator|-
name|qSin
argument_list|(
name|angleR
argument_list|)
operator|*
name|length
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the unit vector for this line, i.e a line starting at the     same point as \e this line with a length of 1.0.      \sa normalVector() */
end_comment
begin_function
DECL|function|unitVector
name|QLineF
name|QLineF
operator|::
name|unitVector
parameter_list|()
specifier|const
block|{
name|qreal
name|x
init|=
name|pt2
operator|.
name|x
argument_list|()
operator|-
name|pt1
operator|.
name|x
argument_list|()
decl_stmt|;
name|qreal
name|y
init|=
name|pt2
operator|.
name|y
argument_list|()
operator|-
name|pt1
operator|.
name|y
argument_list|()
decl_stmt|;
name|qreal
name|len
init|=
name|qSqrt
argument_list|(
name|x
operator|*
name|x
operator|+
name|y
operator|*
name|y
argument_list|)
decl_stmt|;
name|QLineF
name|f
argument_list|(
name|p1
argument_list|()
argument_list|,
name|QPointF
argument_list|(
name|pt1
operator|.
name|x
argument_list|()
operator|+
name|x
operator|/
name|len
argument_list|,
name|pt1
operator|.
name|y
argument_list|()
operator|+
name|y
operator|/
name|len
argument_list|)
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|qAbs
argument_list|(
name|f
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|>=
literal|0.001
condition|)
name|qWarning
argument_list|(
literal|"QLine::unitVector: New line does not have unit length"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|f
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QLineF::IntersectType QLineF::intersect(const QLineF&line, QPointF *intersectionPoint) const      Returns a value indicating whether or not \e this line intersects     with the given \a line.      The actual intersection point is extracted to \a intersectionPoint     (if the pointer is valid). If the lines are parallel, the     intersection point is undefined. */
end_comment
begin_function
DECL|function|intersect
name|QLineF
operator|::
name|IntersectType
name|QLineF
operator|::
name|intersect
parameter_list|(
specifier|const
name|QLineF
modifier|&
name|l
parameter_list|,
name|QPointF
modifier|*
name|intersectionPoint
parameter_list|)
specifier|const
block|{
comment|// ipmlementation is based on Graphics Gems III's "Faster Line Segment Intersection"
specifier|const
name|QPointF
name|a
init|=
name|pt2
operator|-
name|pt1
decl_stmt|;
specifier|const
name|QPointF
name|b
init|=
name|l
operator|.
name|pt1
operator|-
name|l
operator|.
name|pt2
decl_stmt|;
specifier|const
name|QPointF
name|c
init|=
name|pt1
operator|-
name|l
operator|.
name|pt1
decl_stmt|;
specifier|const
name|qreal
name|denominator
init|=
name|a
operator|.
name|y
argument_list|()
operator|*
name|b
operator|.
name|x
argument_list|()
operator|-
name|a
operator|.
name|x
argument_list|()
operator|*
name|b
operator|.
name|y
argument_list|()
decl_stmt|;
if|if
condition|(
name|denominator
operator|==
literal|0
operator|||
operator|!
name|qt_is_finite
argument_list|(
name|denominator
argument_list|)
condition|)
return|return
name|NoIntersection
return|;
specifier|const
name|qreal
name|reciprocal
init|=
literal|1
operator|/
name|denominator
decl_stmt|;
specifier|const
name|qreal
name|na
init|=
operator|(
name|b
operator|.
name|y
argument_list|()
operator|*
name|c
operator|.
name|x
argument_list|()
operator|-
name|b
operator|.
name|x
argument_list|()
operator|*
name|c
operator|.
name|y
argument_list|()
operator|)
operator|*
name|reciprocal
decl_stmt|;
if|if
condition|(
name|intersectionPoint
condition|)
operator|*
name|intersectionPoint
operator|=
name|pt1
operator|+
name|a
operator|*
name|na
expr_stmt|;
if|if
condition|(
name|na
argument_list|<
literal|0
operator|||
name|na
argument_list|>
literal|1
condition|)
return|return
name|UnboundedIntersection
return|;
specifier|const
name|qreal
name|nb
init|=
operator|(
name|a
operator|.
name|x
argument_list|()
operator|*
name|c
operator|.
name|y
argument_list|()
operator|-
name|a
operator|.
name|y
argument_list|()
operator|*
name|c
operator|.
name|x
argument_list|()
operator|)
operator|*
name|reciprocal
decl_stmt|;
if|if
condition|(
name|nb
argument_list|<
literal|0
operator|||
name|nb
argument_list|>
literal|1
condition|)
return|return
name|UnboundedIntersection
return|;
return|return
name|BoundedIntersection
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QLineF::translate(const QPointF&offset)      Translates this line by the given \a offset. */
end_comment
begin_comment
comment|/*!     \fn void QLineF::translate(qreal dx, qreal dy)     \overload      Translates this line the distance specified by \a dx and \a dy. */
end_comment
begin_comment
comment|/*!     \fn QLineF QLineF::translated(const QPointF&offset) const      \since 4.4      Returns this line translated by the given \a offset. */
end_comment
begin_comment
comment|/*!     \fn QLineF QLineF::translated(qreal dx, qreal dy) const     \overload     \since 4.4      Returns this line translated the distance specified by \a dx and \a dy. */
end_comment
begin_comment
comment|/*!     \fn void QLineF::setP1(const QPointF&p1)     \since 4.4      Sets the starting point of this line to \a p1.      \sa setP2(), p1() */
end_comment
begin_comment
comment|/*!     \fn void QLineF::setP2(const QPointF&p2)     \since 4.4      Sets the end point of this line to \a p2.      \sa setP1(), p2() */
end_comment
begin_comment
comment|/*!     \fn void QLineF::setPoints(const QPointF&p1, const QPointF&p2)     \since 4.4      Sets the start point of this line to \a p1 and the end point of this line to \a p2.      \sa setP1(), setP2(), p1(), p2() */
end_comment
begin_comment
comment|/*!     \fn void QLineF::setLine(qreal x1, qreal y1, qreal x2, qreal y2)     \since 4.4      Sets this line to the start in \a x1, \a y1 and end in \a x2, \a y2.      \sa setP1(), setP2(), p1(), p2() */
end_comment
begin_comment
comment|/*!   \fn qreal QLineF::angleTo(const QLineF&line) const    \since 4.4    Returns the angle (in degrees) from this line to the given \a   line, taking the direction of the lines into account. If the lines   do not intersect within their range, it is the intersection point of   the extended lines that serves as origin (see   QLineF::UnboundedIntersection).    The returned value represents the number of degrees you need to add   to this line to make it have the same angle as the given \a line,   going counter-clockwise.    \sa intersect() */
end_comment
begin_function
DECL|function|angleTo
name|qreal
name|QLineF
operator|::
name|angleTo
parameter_list|(
specifier|const
name|QLineF
modifier|&
name|l
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
operator|||
name|l
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
specifier|const
name|qreal
name|a1
init|=
name|angle
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|a2
init|=
name|l
operator|.
name|angle
argument_list|()
decl_stmt|;
specifier|const
name|qreal
name|delta
init|=
name|a2
operator|-
name|a1
decl_stmt|;
specifier|const
name|qreal
name|delta_normalized
init|=
name|delta
operator|<
literal|0
condition|?
name|delta
operator|+
literal|360
else|:
name|delta
decl_stmt|;
if|if
condition|(
name|qFuzzyCompare
argument_list|(
name|delta
argument_list|,
name|qreal
argument_list|(
literal|360
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|delta_normalized
return|;
block|}
end_function
begin_comment
comment|/*!   \fn qreal QLineF::angle(const QLineF&line) const    \obsolete    Returns the angle (in degrees) between this line and the given \a   line, taking the direction of the lines into account. If the lines   do not intersect within their range, it is the intersection point of   the extended lines that serves as origin (see   QLineF::UnboundedIntersection).    \table   \row   \li \inlineimage qlinef-angle-identicaldirection.png   \li \inlineimage qlinef-angle-oppositedirection.png   \endtable    When the lines are parallel, this function returns 0 if they have   the same direction; otherwise it returns 180.    \sa intersect() */
end_comment
begin_function
DECL|function|angle
name|qreal
name|QLineF
operator|::
name|angle
parameter_list|(
specifier|const
name|QLineF
modifier|&
name|l
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
operator|||
name|l
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|qreal
name|cos_line
init|=
operator|(
name|dx
argument_list|()
operator|*
name|l
operator|.
name|dx
argument_list|()
operator|+
name|dy
argument_list|()
operator|*
name|l
operator|.
name|dy
argument_list|()
operator|)
operator|/
operator|(
name|length
argument_list|()
operator|*
name|l
operator|.
name|length
argument_list|()
operator|)
decl_stmt|;
name|qreal
name|rad
init|=
literal|0
decl_stmt|;
comment|// only accept cos_line in the range [-1,1], if it is outside, use 0 (we return 0 rather than PI for those cases)
if|if
condition|(
name|cos_line
operator|>=
operator|-
literal|1.0
operator|&&
name|cos_line
operator|<=
literal|1.0
condition|)
name|rad
operator|=
name|qAcos
argument_list|(
name|cos_line
argument_list|)
expr_stmt|;
return|return
name|rad
operator|*
literal|360
operator|/
name|M_2PI
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|d
parameter_list|,
specifier|const
name|QLineF
modifier|&
name|p
parameter_list|)
block|{
name|d
operator|<<
literal|"QLineF("
operator|<<
name|p
operator|.
name|p1
argument_list|()
operator|<<
literal|','
operator|<<
name|p
operator|.
name|p2
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \relates QLineF      Writes the given \a line to the given \a stream and returns a     reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
specifier|const
name|QLineF
modifier|&
name|line
parameter_list|)
block|{
name|stream
operator|<<
name|line
operator|.
name|p1
argument_list|()
operator|<<
name|line
operator|.
name|p2
argument_list|()
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QLineF      Reads a line from the given \a stream into the given \a line and     returns a reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
name|QLineF
modifier|&
name|line
parameter_list|)
block|{
name|QPointF
name|start
decl_stmt|,
name|end
decl_stmt|;
name|stream
operator|>>
name|start
expr_stmt|;
name|stream
operator|>>
name|end
expr_stmt|;
name|line
operator|=
name|QLineF
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
