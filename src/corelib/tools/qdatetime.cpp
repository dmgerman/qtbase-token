begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"private/qdatetime_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qdatetimeparser_p.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qset.h"
end_include
begin_include
include|#
directive|include
file|"qlocale.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qregexp.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_WIN
end_ifndef
begin_include
include|#
directive|include
file|<locale.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<cmath>
end_include
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_include
include|#
directive|include
file|<qt_windows.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WINCE
end_ifdef
begin_include
include|#
directive|include
file|"qfunctions_wince.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_include
include|#
directive|include
file|<private/qcore_mac_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|enum
type|{
DECL|enumerator|SECS_PER_DAY
name|SECS_PER_DAY
init|=
literal|86400
decl_stmt|,
DECL|enumerator|MSECS_PER_DAY
name|MSECS_PER_DAY
init|=
literal|86400000
decl_stmt|,
DECL|enumerator|SECS_PER_HOUR
name|SECS_PER_HOUR
init|=
literal|3600
decl_stmt|,
DECL|enumerator|MSECS_PER_HOUR
name|MSECS_PER_HOUR
init|=
literal|3600000
decl_stmt|,
DECL|enumerator|SECS_PER_MIN
name|SECS_PER_MIN
init|=
literal|60
decl_stmt|,
DECL|enumerator|MSECS_PER_MIN
name|MSECS_PER_MIN
init|=
literal|60000
decl_stmt|,
DECL|enumerator|JULIAN_DAY_FOR_EPOCH
name|JULIAN_DAY_FOR_EPOCH
init|=
literal|2440588
end_decl_stmt
begin_comment
DECL|enumerator|JULIAN_DAY_FOR_EPOCH
comment|// result of julianDayFromDate(1970, 1, 1)
end_comment
begin_function
DECL|enumerator|JULIAN_DAY_FOR_EPOCH
unit|};
DECL|function|fixedDate
specifier|static
specifier|inline
name|QDate
name|fixedDate
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|QDate
name|result
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|result
operator|.
name|setDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|qMin
argument_list|(
name|d
argument_list|,
name|result
operator|.
name|daysInMonth
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|floordiv
specifier|static
specifier|inline
name|qint64
name|floordiv
parameter_list|(
name|qint64
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|-
operator|(
name|a
operator|<
literal|0
condition|?
name|b
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
operator|/
name|b
return|;
block|}
end_function
begin_function
DECL|function|floordiv
specifier|static
specifier|inline
name|int
name|floordiv
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|-
operator|(
name|a
operator|<
literal|0
condition|?
name|b
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
operator|/
name|b
return|;
block|}
end_function
begin_function
DECL|function|julianDayFromDate
specifier|static
specifier|inline
name|qint64
name|julianDayFromDate
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
comment|// Adjust for no year 0
if|if
condition|(
name|year
operator|<
literal|0
condition|)
operator|++
name|year
expr_stmt|;
comment|/*  * Math from The Calendar FAQ at http://www.tondering.dk/claus/cal/julperiod.php  * This formula is correct for all julian days, when using mathematical integer  * division (round to negative infinity), not c++11 integer division (round to zero)  */
name|int
name|a
init|=
name|floordiv
argument_list|(
literal|14
operator|-
name|month
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|qint64
name|y
init|=
operator|(
name|qint64
operator|)
name|year
operator|+
literal|4800
operator|-
name|a
decl_stmt|;
name|int
name|m
init|=
name|month
operator|+
literal|12
operator|*
name|a
operator|-
literal|3
decl_stmt|;
return|return
name|day
operator|+
name|floordiv
argument_list|(
literal|153
operator|*
name|m
operator|+
literal|2
argument_list|,
literal|5
argument_list|)
operator|+
literal|365
operator|*
name|y
operator|+
name|floordiv
argument_list|(
name|y
argument_list|,
literal|4
argument_list|)
operator|-
name|floordiv
argument_list|(
name|y
argument_list|,
literal|100
argument_list|)
operator|+
name|floordiv
argument_list|(
name|y
argument_list|,
literal|400
argument_list|)
operator|-
literal|32045
return|;
block|}
end_function
begin_function
DECL|function|getDateFromJulianDay
specifier|static
name|void
name|getDateFromJulianDay
parameter_list|(
name|qint64
name|julianDay
parameter_list|,
name|int
modifier|*
name|yearp
parameter_list|,
name|int
modifier|*
name|monthp
parameter_list|,
name|int
modifier|*
name|dayp
parameter_list|)
block|{
comment|/*  * Math from The Calendar FAQ at http://www.tondering.dk/claus/cal/julperiod.php  * This formula is correct for all julian days, when using mathematical integer  * division (round to negative infinity), not c++11 integer division (round to zero)  */
name|qint64
name|a
init|=
name|julianDay
operator|+
literal|32044
decl_stmt|;
name|qint64
name|b
init|=
name|floordiv
argument_list|(
literal|4
operator|*
name|a
operator|+
literal|3
argument_list|,
literal|146097
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|a
operator|-
name|floordiv
argument_list|(
literal|146097
operator|*
name|b
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|int
name|d
init|=
name|floordiv
argument_list|(
literal|4
operator|*
name|c
operator|+
literal|3
argument_list|,
literal|1461
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|c
operator|-
name|floordiv
argument_list|(
literal|1461
operator|*
name|d
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|int
name|m
init|=
name|floordiv
argument_list|(
literal|5
operator|*
name|e
operator|+
literal|2
argument_list|,
literal|153
argument_list|)
decl_stmt|;
name|int
name|day
init|=
name|e
operator|-
name|floordiv
argument_list|(
literal|153
operator|*
name|m
operator|+
literal|2
argument_list|,
literal|5
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|month
init|=
name|m
operator|+
literal|3
operator|-
literal|12
operator|*
name|floordiv
argument_list|(
name|m
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|int
name|year
init|=
literal|100
operator|*
name|b
operator|+
name|d
operator|-
literal|4800
operator|+
name|floordiv
argument_list|(
name|m
argument_list|,
literal|10
argument_list|)
decl_stmt|;
comment|// Adjust for no year 0
if|if
condition|(
name|year
operator|<=
literal|0
condition|)
operator|--
name|year
expr_stmt|;
if|if
condition|(
name|yearp
condition|)
operator|*
name|yearp
operator|=
name|year
expr_stmt|;
if|if
condition|(
name|monthp
condition|)
operator|*
name|monthp
operator|=
name|month
expr_stmt|;
if|if
condition|(
name|dayp
condition|)
operator|*
name|dayp
operator|=
name|day
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|monthDays
specifier|static
specifier|const
name|char
name|monthDays
index|[]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_decl_stmt
DECL|variable|qt_shortMonthNames
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|qt_shortMonthNames
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_monthNumberFromShortName
name|int
name|qt_monthNumberFromShortName
parameter_list|(
specifier|const
name|QString
modifier|&
name|shortName
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|qt_shortMonthNames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|qt_shortMonthNames
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|shortName
operator|==
name|QLatin1String
argument_list|(
name|qt_shortMonthNames
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
operator|+
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function_decl
specifier|static
name|void
name|rfcDateImpl
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|QDate
modifier|*
name|dd
init|=
literal|0
parameter_list|,
name|QTime
modifier|*
name|dt
init|=
literal|0
parameter_list|,
name|int
modifier|*
name|utfcOffset
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|static
name|QDateTimePrivate
operator|::
name|Spec
name|utcToLocal
parameter_list|(
name|QDate
modifier|&
name|date
parameter_list|,
name|QTime
modifier|&
name|time
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|utcToOffset
parameter_list|(
name|QDate
modifier|*
name|date
parameter_list|,
name|QTime
modifier|*
name|time
parameter_list|,
name|qint32
name|offset
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QDate
name|adjustDate
parameter_list|(
name|QDate
name|date
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// Return offset in [+-]HH:MM format
end_comment
begin_comment
comment|// Qt::ISODate puts : between the hours and minutes, but Qt:TextDate does not
end_comment
begin_function
DECL|function|toOffsetString
specifier|static
name|QString
name|toOffsetString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|Qt
operator|::
name|TextDate
condition|)
name|result
operator|=
name|QStringLiteral
argument_list|(
literal|"%1%2%3"
argument_list|)
expr_stmt|;
else|else
comment|// Qt::ISODate
name|result
operator|=
name|QStringLiteral
argument_list|(
literal|"%1%2:%3"
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|arg
argument_list|(
name|offset
operator|>=
literal|0
condition|?
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
else|:
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|qAbs
argument_list|(
name|offset
argument_list|)
operator|/
name|SECS_PER_HOUR
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
operator|(
name|offset
operator|/
literal|60
operator|)
operator|%
literal|60
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// Parse offset in [+-]HH[:]MM format
end_comment
begin_function
DECL|function|fromOffsetString
specifier|static
name|int
name|fromOffsetString
parameter_list|(
specifier|const
name|QString
modifier|&
name|offsetString
parameter_list|,
name|bool
modifier|*
name|valid
parameter_list|)
block|{
operator|*
name|valid
operator|=
literal|false
expr_stmt|;
specifier|const
name|int
name|size
init|=
name|offsetString
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|<
literal|2
operator|||
name|size
argument_list|>
literal|6
condition|)
return|return
literal|0
return|;
comment|// First char must be + or -
specifier|const
name|QChar
name|sign
init|=
name|offsetString
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sign
operator|!=
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
operator|&&
name|sign
operator|!=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
condition|)
return|return
literal|0
return|;
comment|// Split the hour and minute parts
name|QStringList
name|parts
init|=
name|offsetString
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// [+-]HHMM format
name|parts
operator|.
name|append
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|mid
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|left
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|bool
name|ok
init|=
literal|false
decl_stmt|;
specifier|const
name|int
name|hour
init|=
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
specifier|const
name|int
name|minute
init|=
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
operator|||
name|minute
argument_list|<
literal|0
operator|||
name|minute
argument_list|>
literal|59
condition|)
return|return
literal|0
return|;
operator|*
name|valid
operator|=
literal|true
expr_stmt|;
return|return
operator|(
operator|(
name|hour
operator|*
literal|60
operator|)
operator|+
name|minute
operator|)
operator|*
literal|60
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_comment
comment|// Calls the platform variant of mktime for the given date and time,
end_comment
begin_comment
comment|// and updates the date, time, spec and abbreviation with the returned values
end_comment
begin_comment
comment|// If the date falls outside the 1970 to 2037 range supported by mktime / time_t
end_comment
begin_comment
comment|// then null date/time will be returned, you should call adjustDate() first if
end_comment
begin_comment
comment|// you need a guaranteed result.
end_comment
begin_function
DECL|function|qt_mktime
specifier|static
name|time_t
name|qt_mktime
parameter_list|(
name|QDate
modifier|*
name|date
parameter_list|,
name|QTime
modifier|*
name|time
parameter_list|,
name|QDateTimePrivate
operator|::
name|Spec
modifier|*
name|spec
parameter_list|,
name|QString
modifier|*
name|abbreviation
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
name|int
name|yy
decl_stmt|,
name|mm
decl_stmt|,
name|dd
decl_stmt|;
name|date
operator|->
name|getDate
argument_list|(
operator|&
name|yy
argument_list|,
operator|&
name|mm
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
name|tm
name|local
decl_stmt|;
name|local
operator|.
name|tm_sec
operator|=
name|time
operator|->
name|second
argument_list|()
expr_stmt|;
name|local
operator|.
name|tm_min
operator|=
name|time
operator|->
name|minute
argument_list|()
expr_stmt|;
name|local
operator|.
name|tm_hour
operator|=
name|time
operator|->
name|hour
argument_list|()
expr_stmt|;
name|local
operator|.
name|tm_mday
operator|=
name|dd
expr_stmt|;
name|local
operator|.
name|tm_mon
operator|=
name|mm
operator|-
literal|1
expr_stmt|;
name|local
operator|.
name|tm_year
operator|=
name|yy
operator|-
literal|1900
expr_stmt|;
name|local
operator|.
name|tm_wday
operator|=
literal|0
expr_stmt|;
name|local
operator|.
name|tm_yday
operator|=
literal|0
expr_stmt|;
name|local
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|_tzset
argument_list|()
expr_stmt|;
else|#
directive|else
name|tzset
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Q_OS_WIN
specifier|const
name|time_t
name|secsSinceEpoch
init|=
name|mktime
argument_list|(
operator|&
name|local
argument_list|)
decl_stmt|;
if|if
condition|(
name|secsSinceEpoch
operator|!=
name|time_t
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
operator|*
name|date
operator|=
name|QDate
argument_list|(
name|local
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|local
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|local
operator|.
name|tm_mday
argument_list|)
expr_stmt|;
operator|*
name|time
operator|=
name|QTime
argument_list|(
name|local
operator|.
name|tm_hour
argument_list|,
name|local
operator|.
name|tm_min
argument_list|,
name|local
operator|.
name|tm_sec
argument_list|,
name|time
operator|->
name|msec
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
operator|.
name|tm_isdst
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|spec
condition|)
operator|*
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalDST
expr_stmt|;
if|if
condition|(
name|abbreviation
condition|)
operator|*
name|abbreviation
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|tzname
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local
operator|.
name|tm_isdst
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|spec
condition|)
operator|*
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalStandard
expr_stmt|;
if|if
condition|(
name|abbreviation
condition|)
operator|*
name|abbreviation
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|tzname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|spec
condition|)
operator|*
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
if|if
condition|(
name|abbreviation
condition|)
operator|*
name|abbreviation
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|tzname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
operator|*
name|date
operator|=
name|QDate
argument_list|()
expr_stmt|;
operator|*
name|time
operator|=
name|QTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|spec
condition|)
operator|*
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
if|if
condition|(
name|abbreviation
condition|)
operator|*
name|abbreviation
operator|=
name|QString
argument_list|()
expr_stmt|;
block|}
return|return
name|secsSinceEpoch
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !Q_OS_WINCE
end_comment
begin_comment
comment|/*****************************************************************************   QDate member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \since 4.5      \enum QDate::MonthNameType      This enum describes the types of the string representation used     for the month name.      \value DateFormat This type of name can be used for date-to-string formatting.     \value StandaloneFormat This type is used when you need to enumerate months or weekdays.            Usually standalone names are represented in singular forms with            capitalized first letter. */
end_comment
begin_comment
comment|/*!     \class QDate     \inmodule QtCore     \reentrant     \brief The QDate class provides date functions.       A QDate object contains a calendar date, i.e. year, month, and day     numbers, in the Gregorian calendar. It can read the current date     from the system clock. It provides functions for comparing dates,     and for manipulating dates. For example, it is possible to add     and subtract days, months, and years to dates.      A QDate object is typically created by giving the year,     month, and day numbers explicitly. Note that QDate interprets two     digit years as is, i.e., years 0 - 99. A QDate can also be     constructed with the static function currentDate(), which creates     a QDate object containing the system clock's date.  An explicit     date can also be set using setDate(). The fromString() function     returns a QDate given a string and a date format which is used to     interpret the date within the string.      The year(), month(), and day() functions provide access to the     year, month, and day numbers. Also, dayOfWeek() and dayOfYear()     functions are provided. The same information is provided in     textual format by the toString(), shortDayName(), longDayName(),     shortMonthName(), and longMonthName() functions.      QDate provides a full set of operators to compare two QDate     objects where smaller means earlier, and larger means later.      You can increment (or decrement) a date by a given number of days     using addDays(). Similarly you can use addMonths() and addYears().     The daysTo() function returns the number of days between two     dates.      The daysInMonth() and daysInYear() functions return how many days     there are in this date's month and year, respectively. The     isLeapYear() function indicates whether a date is in a leap year.      \section1      \section2 No Year 0      There is no year 0. Dates in that year are considered invalid. The     year -1 is the year "1 before Christ" or "1 before current era."     The day before 1 January 1 CE is 31 December 1 BCE.      \section2 Range of Valid Dates      Dates are stored internally as a Julian Day number, an integer count of     every day in a contiguous range, with 24 November 4714 BCE in the Gregorian     calendar being Julian Day 0 (1 January 4713 BCE in the Julian calendar).     As well as being an efficient and accurate way of storing an absolute date,     it is suitable for converting a Date into other calendar systems such as     Hebrew, Islamic or Chinese. The Julian Day number can be obtained using     QDate::toJulianDay() and can be set using QDate::fromJulianDay().      The range of dates able to be stored by QDate as a Julian Day number is     for technical reasons limited to between -784350574879 and 784354017364,     which means from before 2 billion BCE to after 2 billion CE.      \sa QTime, QDateTime, QDateEdit, QDateTimeEdit, QCalendarWidget */
end_comment
begin_comment
comment|/*!     \fn QDate::QDate()      Constructs a null date. Null dates are invalid.      \sa isNull(), isValid() */
end_comment
begin_comment
comment|/*!     Constructs a date with year \a y, month \a m and day \a d.      If the specified date is invalid, the date is not set and     isValid() returns false.      \warning Years 1 to 99 are interpreted as is. Year 0 is invalid.      \sa isValid() */
end_comment
begin_constructor
DECL|function|QDate
name|QDate
operator|::
name|QDate
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|setDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn bool QDate::isNull() const      Returns true if the date is null; otherwise returns false. A null     date is invalid.      \note The behavior of this function is equivalent to isValid().      \sa isValid() */
end_comment
begin_comment
comment|/*!     \fn bool QDate::isValid() const      Returns true if this date is valid; otherwise returns false.      \sa isNull() */
end_comment
begin_comment
comment|/*!     Returns the year of this date. Negative numbers indicate years     before 1 CE, such that year -44 is 44 BCE.      Returns 0 if the date is invalid.      \sa month(), day() */
end_comment
begin_function
DECL|function|year
name|int
name|QDate
operator|::
name|year
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|y
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number corresponding to the month of this date, using     the following convention:      \list     \li 1 = "January"     \li 2 = "February"     \li 3 = "March"     \li 4 = "April"     \li 5 = "May"     \li 6 = "June"     \li 7 = "July"     \li 8 = "August"     \li 9 = "September"     \li 10 = "October"     \li 11 = "November"     \li 12 = "December"     \endlist      Returns 0 if the date is invalid.      \sa year(), day() */
end_comment
begin_function
DECL|function|month
name|int
name|QDate
operator|::
name|month
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|m
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
literal|0
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the day of the month (1 to 31) of this date.      Returns 0 if the date is invalid.      \sa year(), month(), dayOfWeek() */
end_comment
begin_function
DECL|function|day
name|int
name|QDate
operator|::
name|day
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the weekday (1 = Monday to 7 = Sunday) for this date.      Returns 0 if the date is invalid.      \sa day(), dayOfYear(), Qt::DayOfWeek */
end_comment
begin_function
DECL|function|dayOfWeek
name|int
name|QDate
operator|::
name|dayOfWeek
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|jd
operator|>=
literal|0
condition|)
return|return
operator|(
name|jd
operator|%
literal|7
operator|)
operator|+
literal|1
return|;
else|else
return|return
operator|(
operator|(
name|jd
operator|+
literal|1
operator|)
operator|%
literal|7
operator|)
operator|+
literal|7
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the day of the year (1 to 365 or 366 on leap years) for     this date.      Returns 0 if the date is invalid.      \sa day(), dayOfWeek() */
end_comment
begin_function
DECL|function|dayOfYear
name|int
name|QDate
operator|::
name|dayOfYear
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|jd
operator|-
name|julianDayFromDate
argument_list|(
name|year
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days in the month (28 to 31) for this date.      Returns 0 if the date is invalid.      \sa day(), daysInYear() */
end_comment
begin_function
DECL|function|daysInMonth
name|int
name|QDate
operator|::
name|daysInMonth
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|y
decl_stmt|,
name|m
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|2
operator|&&
name|isLeapYear
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|29
return|;
else|else
return|return
name|monthDays
index|[
name|m
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days in the year (365 or 366) for this date.      Returns 0 if the date is invalid.      \sa day(), daysInMonth() */
end_comment
begin_function
DECL|function|daysInYear
name|int
name|QDate
operator|::
name|daysInYear
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|y
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|isLeapYear
argument_list|(
name|y
argument_list|)
condition|?
literal|366
else|:
literal|365
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the week number (1 to 53), and stores the year in     *\a{yearNumber} unless \a yearNumber is null (the default).      Returns 0 if the date is invalid.      In accordance with ISO 8601, weeks start on Monday and the first     Thursday of a year is always in week 1 of that year. Most years     have 52 weeks, but some have 53.      *\a{yearNumber} is not always the same as year(). For example, 1     January 2000 has week number 52 in the year 1999, and 31 December     2002 has week number 1 in the year 2003.      \legalese     Copyright (c) 1989 The Regents of the University of California.     All rights reserved.      Redistribution and use in source and binary forms are permitted     provided that the above copyright notice and this paragraph are     duplicated in all such forms and that any documentation,     advertising materials, and other materials related to such     distribution and use acknowledge that the software was developed     by the University of California, Berkeley.  The name of the     University may not be used to endorse or promote products derived     from this software without specific prior written permission.     THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR     IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.      \sa isValid() */
end_comment
begin_function
DECL|function|weekNumber
name|int
name|QDate
operator|::
name|weekNumber
parameter_list|(
name|int
modifier|*
name|yearNumber
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|year
init|=
name|QDate
operator|::
name|year
argument_list|()
decl_stmt|;
name|int
name|yday
init|=
name|dayOfYear
argument_list|()
operator|-
literal|1
decl_stmt|;
name|int
name|wday
init|=
name|dayOfWeek
argument_list|()
decl_stmt|;
if|if
condition|(
name|wday
operator|==
literal|7
condition|)
name|wday
operator|=
literal|0
expr_stmt|;
name|int
name|w
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|bot
decl_stmt|;
name|int
name|top
decl_stmt|;
name|len
operator|=
name|isLeapYear
argument_list|(
name|year
argument_list|)
condition|?
literal|366
else|:
literal|365
expr_stmt|;
comment|/*         ** What yday (-3 ... 3) does         ** the ISO year begin on?         */
name|bot
operator|=
operator|(
operator|(
name|yday
operator|+
literal|11
operator|-
name|wday
operator|)
operator|%
literal|7
operator|)
operator|-
literal|3
expr_stmt|;
comment|/*         ** What yday does the NEXT         ** ISO year begin on?         */
name|top
operator|=
name|bot
operator|-
operator|(
name|len
operator|%
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|top
operator|<
operator|-
literal|3
condition|)
name|top
operator|+=
literal|7
expr_stmt|;
name|top
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|yday
operator|>=
name|top
condition|)
block|{
operator|++
name|year
expr_stmt|;
name|w
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|yday
operator|>=
name|bot
condition|)
block|{
name|w
operator|=
literal|1
operator|+
operator|(
operator|(
name|yday
operator|-
name|bot
operator|)
operator|/
literal|7
operator|)
expr_stmt|;
break|break;
block|}
operator|--
name|year
expr_stmt|;
name|yday
operator|+=
name|isLeapYear
argument_list|(
name|year
argument_list|)
condition|?
literal|366
else|:
literal|365
expr_stmt|;
block|}
if|if
condition|(
name|yearNumber
operator|!=
literal|0
condition|)
operator|*
name|yearNumber
operator|=
name|year
expr_stmt|;
return|return
name|w
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_comment
comment|/*!     \since 4.5      Returns the short name of the \a month for the representation specified     by \a type.      The months are enumerated using the following convention:      \list     \li 1 = "Jan"     \li 2 = "Feb"     \li 3 = "Mar"     \li 4 = "Apr"     \li 5 = "May"     \li 6 = "Jun"     \li 7 = "Jul"     \li 8 = "Aug"     \li 9 = "Sep"     \li 10 = "Oct"     \li 11 = "Nov"     \li 12 = "Dec"     \endlist      The month names will be localized according to the system's     locale settings, i.e. using QLocale::system().      Returns an empty string if the date is invalid.      \sa toString(), longMonthName(), shortDayName(), longDayName() */
end_comment
begin_function
DECL|function|shortMonthName
name|QString
name|QDate
operator|::
name|shortMonthName
parameter_list|(
name|int
name|month
parameter_list|,
name|QDate
operator|::
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|month
argument_list|<
literal|1
operator|||
name|month
argument_list|>
literal|12
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneMonthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the long name of the \a month for the representation specified     by \a type.      The months are enumerated using the following convention:      \list     \li 1 = "January"     \li 2 = "February"     \li 3 = "March"     \li 4 = "April"     \li 5 = "May"     \li 6 = "June"     \li 7 = "July"     \li 8 = "August"     \li 9 = "September"     \li 10 = "October"     \li 11 = "November"     \li 12 = "December"     \endlist      The month names will be localized according to the system's     locale settings, i.e. using QLocale::system().      Returns an empty string if the date is invalid.      \sa toString(), shortMonthName(), shortDayName(), longDayName() */
end_comment
begin_function
DECL|function|longMonthName
name|QString
name|QDate
operator|::
name|longMonthName
parameter_list|(
name|int
name|month
parameter_list|,
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|month
argument_list|<
literal|1
operator|||
name|month
argument_list|>
literal|12
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneMonthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the short name of the \a weekday for the representation specified     by \a type.      The days are enumerated using the following convention:      \list     \li 1 = "Mon"     \li 2 = "Tue"     \li 3 = "Wed"     \li 4 = "Thu"     \li 5 = "Fri"     \li 6 = "Sat"     \li 7 = "Sun"     \endlist      The day names will be localized according to the system's     locale settings, i.e. using QLocale::system().      Returns an empty string if the date is invalid.      \sa toString(), shortMonthName(), longMonthName(), longDayName() */
end_comment
begin_function
DECL|function|shortDayName
name|QString
name|QDate
operator|::
name|shortDayName
parameter_list|(
name|int
name|weekday
parameter_list|,
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|weekday
argument_list|<
literal|1
operator|||
name|weekday
argument_list|>
literal|7
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneDayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the long name of the \a weekday for the representation specified     by \a type.      The days are enumerated using the following convention:      \list     \li 1 = "Monday"     \li 2 = "Tuesday"     \li 3 = "Wednesday"     \li 4 = "Thursday"     \li 5 = "Friday"     \li 6 = "Saturday"     \li 7 = "Sunday"     \endlist      The day names will be localized according to the system's     locale settings, i.e. using QLocale::system().      Returns an empty string if the date is invalid.      \sa toString(), shortDayName(), shortMonthName(), longMonthName() */
end_comment
begin_function
DECL|function|longDayName
name|QString
name|QDate
operator|::
name|longDayName
parameter_list|(
name|int
name|weekday
parameter_list|,
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|weekday
argument_list|<
literal|1
operator|||
name|weekday
argument_list|>
literal|7
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneDayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_TEXTDATE
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \fn QString QDate::toString(Qt::DateFormat format) const      \overload      Returns the date as a string. The \a format parameter determines     the format of the string.      If the \a format is Qt::TextDate, the string is formatted in     the default way. QDate::shortDayName() and QDate::shortMonthName()     are used to generate the string, so the day and month names will     be localized names using the system locale, i.e. QLocale::system(). An     example of this formatting is "Sat May 20 1995".      If the \a format is Qt::ISODate, the string format corresponds     to the ISO 8601 extended specification for representations of     dates and times, taking the form YYYY-MM-DD, where YYYY is the     year, MM is the month of the year (between 01 and 12), and DD is     the day of the month between 01 and 31.      If the \a format is Qt::SystemLocaleShortDate or     Qt::SystemLocaleLongDate, the string format depends on the locale     settings of the system. Identical to calling     QLocale::system().toString(date, QLocale::ShortFormat) or     QLocale::system().toString(date, QLocale::LongFormat).      If the \a format is Qt::DefaultLocaleShortDate or     Qt::DefaultLocaleLongDate, the string format depends on the     default application locale. This is the locale set with     QLocale::setDefault(), or the system locale if no default locale     has been set. Identical to calling QLocale().toString(date,     QLocale::ShortFormat) or QLocale().toString(date,     QLocale::LongFormat).      If the \a format is Qt::RFC2822Date, the string is formatted in     an \l{RFC 2822} compatible way. An example of this formatting is     "20 May 1995".      If the date is invalid, an empty string will be returned.      \warning The Qt::ISODate format is only valid for years in the     range 0 to 9999. This restriction may apply to locale-aware     formats as well, depending on the locale settings.      \sa shortDayName(), shortMonthName() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDate
operator|::
name|toString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|int
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
return|return
name|toString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"dd MMM yyyy"
argument_list|)
argument_list|)
return|;
default|default:
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
case|case
name|Qt
operator|::
name|TextDate
case|:
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"%1 %2 %3 %4"
argument_list|)
operator|.
name|arg
argument_list|(
name|shortDayName
argument_list|(
name|dayOfWeek
argument_list|()
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|shortMonthName
argument_list|(
name|m
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|d
argument_list|)
operator|.
name|arg
argument_list|(
name|y
argument_list|)
return|;
endif|#
directive|endif
case|case
name|Qt
operator|::
name|ISODate
case|:
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
argument_list|<
literal|0
operator|||
name|y
argument_list|>
literal|9999
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"%1-%2-%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|y
argument_list|,
literal|4
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|m
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|d
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the date as a string. The \a format parameter determines     the format of the result string.      These expressions may be used:      \table     \header \li Expression \li Output     \row \li d \li the day as number without a leading zero (1 to 31)     \row \li dd \li the day as number with a leading zero (01 to 31)     \row \li ddd          \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li dddd          \li the long localized day name (e.g. 'Monday' to 'Sunday').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li M \li the month as number without a leading zero (1 to 12)     \row \li MM \li the month as number with a leading zero (01 to 12)     \row \li MMM          \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li MMMM          \li the long localized month name (e.g. 'January' to 'December').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li yy \li the year as two digit number (00 to 99)     \row \li yyyy \li the year as four digit number. If the year is negative,             a minus sign is prepended in addition.     \endtable      All other input characters will be ignored. Any sequence of characters that     are enclosed in single quotes will be treated as text and not be used as an     expression. Two consecutive single quotes ("''") are replaced by a singlequote     in the output. Formats without separators (e.g. "ddMM") are currently not supported.      Example format strings (assuming that the QDate is the 20 July     1969):      \table     \header \li Format            \li Result     \row    \li dd.MM.yyyy        \li 20.07.1969     \row    \li ddd MMMM d yy     \li Sun July 20 69     \row    \li 'The day is' dddd \li The day is Sunday     \endtable      If the datetime is invalid, an empty string will be returned.      \sa QDateTime::toString(), QTime::toString(), QLocale::toString()  */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDate
operator|::
name|toString
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
block|{
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \fn bool QDate::setYMD(int y, int m, int d)      \deprecated in 5.0, use setDate() instead.      Sets the date's year \a y, month \a m, and day \a d.      If \a y is in the range 0 to 99, it is interpreted as 1900 to     1999.     Returns \c false if the date is invalid.      Use setDate() instead. */
end_comment
begin_comment
comment|/*!     \since 4.2      Sets the date's \a year, \a month, and \a day. Returns true if     the date is valid; otherwise returns false.      If the specified date is invalid, the QDate object is set to be     invalid.      \sa isValid() */
end_comment
begin_function
DECL|function|setDate
name|bool
name|QDate
operator|::
name|setDate
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
condition|)
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
else|else
name|jd
operator|=
name|nullJd
argument_list|()
expr_stmt|;
return|return
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Extracts the date's year, month, and day, and assigns them to     *\a year, *\a month, and *\a day. The pointers may be null.      Returns 0 if the date is invalid.      \sa year(), month(), day(), isValid() */
end_comment
begin_function
DECL|function|getDate
name|void
name|QDate
operator|::
name|getDate
parameter_list|(
name|int
modifier|*
name|year
parameter_list|,
name|int
modifier|*
name|month
parameter_list|,
name|int
modifier|*
name|day
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|()
condition|)
block|{
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|year
condition|)
operator|*
name|year
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|month
condition|)
operator|*
name|month
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|day
condition|)
operator|*
name|day
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns a QDate object containing a date \a ndays later than the     date of this object (or earlier if \a ndays is negative).      Returns a null date if the current date is invalid or the new date is     out of range.      \sa addMonths(), addYears(), daysTo() */
end_comment
begin_function
DECL|function|addDays
name|QDate
name|QDate
operator|::
name|addDays
parameter_list|(
name|qint64
name|ndays
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
comment|// Due to limits on minJd() and maxJd() we know that any overflow
comment|// will be invalid and caught by fromJulianDay().
return|return
name|fromJulianDay
argument_list|(
name|jd
operator|+
name|ndays
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDate object containing a date \a nmonths later than the     date of this object (or earlier if \a nmonths is negative).      \note If the ending day/month combination does not exist in the     resulting month/year, this function will return a date that is the     latest valid date.      \sa addDays(), addYears() */
end_comment
begin_function
DECL|function|addMonths
name|QDate
name|QDate
operator|::
name|addMonths
parameter_list|(
name|int
name|nmonths
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
if|if
condition|(
operator|!
name|nmonths
condition|)
return|return
operator|*
name|this
return|;
name|int
name|old_y
decl_stmt|,
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|old_y
operator|=
name|y
expr_stmt|;
name|bool
name|increasing
init|=
name|nmonths
operator|>
literal|0
decl_stmt|;
while|while
condition|(
name|nmonths
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nmonths
operator|<
literal|0
operator|&&
name|nmonths
operator|+
literal|12
operator|<=
literal|0
condition|)
block|{
name|y
operator|--
expr_stmt|;
name|nmonths
operator|+=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmonths
operator|<
literal|0
condition|)
block|{
name|m
operator|+=
name|nmonths
expr_stmt|;
name|nmonths
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0
condition|)
block|{
operator|--
name|y
expr_stmt|;
name|m
operator|+=
literal|12
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nmonths
operator|-
literal|12
operator|>=
literal|0
condition|)
block|{
name|y
operator|++
expr_stmt|;
name|nmonths
operator|-=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
literal|12
condition|)
block|{
name|y
operator|++
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|m
operator|+=
name|nmonths
expr_stmt|;
name|nmonths
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|12
condition|)
block|{
operator|++
name|y
expr_stmt|;
name|m
operator|-=
literal|12
expr_stmt|;
block|}
block|}
block|}
comment|// was there a sign change?
if|if
condition|(
operator|(
name|old_y
operator|>
literal|0
operator|&&
name|y
operator|<=
literal|0
operator|)
operator|||
operator|(
name|old_y
operator|<
literal|0
operator|&&
name|y
operator|>=
literal|0
operator|)
condition|)
comment|// yes, adjust the date by +1 or -1 years
name|y
operator|+=
name|increasing
condition|?
operator|+
literal|1
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|fixedDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDate object containing a date \a nyears later than the     date of this object (or earlier if \a nyears is negative).      \note If the ending day/month combination does not exist in the     resulting year (i.e., if the date was Feb 29 and the final year is     not a leap year), this function will return a date that is the     latest valid date (that is, Feb 28).      \sa addDays(), addMonths() */
end_comment
begin_function
DECL|function|addYears
name|QDate
name|QDate
operator|::
name|addYears
parameter_list|(
name|int
name|nyears
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
name|int
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|int
name|old_y
init|=
name|y
decl_stmt|;
name|y
operator|+=
name|nyears
expr_stmt|;
comment|// was there a sign change?
if|if
condition|(
operator|(
name|old_y
operator|>
literal|0
operator|&&
name|y
operator|<=
literal|0
operator|)
operator|||
operator|(
name|old_y
operator|<
literal|0
operator|&&
name|y
operator|>=
literal|0
operator|)
condition|)
comment|// yes, adjust the date by +1 or -1 years
name|y
operator|+=
name|nyears
operator|>
literal|0
condition|?
operator|+
literal|1
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|fixedDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days from this date to \a d (which is     negative if \a d is earlier than this date).      Returns 0 if either date is invalid.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 0      \sa addDays() */
end_comment
begin_function
DECL|function|daysTo
name|qint64
name|QDate
operator|::
name|daysTo
parameter_list|(
specifier|const
name|QDate
modifier|&
name|d
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
operator|||
name|d
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// Due to limits on minJd() and maxJd() we know this will never overflow
return|return
name|d
operator|.
name|jd
operator|-
name|jd
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDate::operator==(const QDate&d) const      Returns true if this date is equal to \a d; otherwise returns     false.  */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator!=(const QDate&d) const      Returns true if this date is different from \a d; otherwise     returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator<(const QDate&d) const      Returns true if this date is earlier than \a d; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator<=(const QDate&d) const      Returns true if this date is earlier than or equal to \a d;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator>(const QDate&d) const      Returns true if this date is later than \a d; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator>=(const QDate&d) const      Returns true if this date is later than or equal to \a d;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QDate::currentDate()     Returns the current date, as reported by the system clock.      \sa QTime::currentTime(), QDateTime::currentDateTime() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \fn QDate QDate::fromString(const QString&string, Qt::DateFormat format)      Returns the QDate represented by the \a string, using the     \a format given, or an invalid date if the string cannot be     parsed.      Note for Qt::TextDate: It is recommended that you use the     English short month names (e.g. "Jan"). Although localized month     names can also be used, they depend on the user's locale settings. */
end_comment
begin_function
DECL|function|fromString
name|QDate
name|QDate
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
block|{
if|if
condition|(
name|string
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toDate
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toDate
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toDate
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toDate
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
block|{
name|QDate
name|date
decl_stmt|;
name|rfcDateImpl
argument_list|(
name|string
argument_list|,
operator|&
name|date
argument_list|)
expr_stmt|;
return|return
name|date
return|;
block|}
default|default:
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
case|case
name|Qt
operator|::
name|TextDate
case|:
block|{
name|QStringList
name|parts
init|=
name|string
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|!=
literal|4
condition|)
return|return
name|QDate
argument_list|()
return|;
name|QString
name|monthName
init|=
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|month
init|=
operator|-
literal|1
decl_stmt|;
comment|// Assume that English monthnames are the default
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QLatin1String
argument_list|(
name|qt_shortMonthNames
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|month
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|// If English names can't be found, search the localized ones
if|if
condition|(
name|month
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QDate
operator|::
name|shortMonthName
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|month
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|month
operator|==
operator|-
literal|1
condition|)
comment|// Month name matches neither English nor other localised name.
return|return
name|QDate
argument_list|()
return|;
block|}
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|int
name|year
init|=
name|parts
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDate
argument_list|()
return|;
return|return
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|// QT_NO_TEXTDATE
case|case
name|Qt
operator|::
name|ISODate
case|:
block|{
specifier|const
name|int
name|year
init|=
name|string
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|year
operator|<=
literal|0
operator|||
name|year
operator|>
literal|9999
condition|)
return|return
name|QDate
argument_list|()
return|;
return|return
name|QDate
argument_list|(
name|year
argument_list|,
name|string
operator|.
name|mid
argument_list|(
literal|5
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|,
name|string
operator|.
name|mid
argument_list|(
literal|8
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
return|;
block|}
block|}
return|return
name|QDate
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDate::fromString(const QString&string, const QString&format)      Returns the QDate represented by the \a string, using the \a     format given, or an invalid date if the string cannot be parsed.      These expressions may be used for the format:      \table     \header \li Expression \li Output     \row \li d \li The day as a number without a leading zero (1 to 31)     \row \li dd \li The day as a number with a leading zero (01 to 31)     \row \li ddd          \li The abbreviated localized day name (e.g. 'Mon' to 'Sun').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li dddd          \li The long localized day name (e.g. 'Monday' to 'Sunday').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li M \li The month as a number without a leading zero (1 to 12)     \row \li MM \li The month as a number with a leading zero (01 to 12)     \row \li MMM          \li The abbreviated localized month name (e.g. 'Jan' to 'Dec').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li MMMM          \li The long localized month name (e.g. 'January' to 'December').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li yy \li The year as two digit number (00 to 99)     \row \li yyyy \li The year as four digit number. If the year is negative,             a minus sign is prepended in addition.     \endtable      All other input characters will be treated as text. Any sequence     of characters that are enclosed in single quotes will also be     treated as text and will not be used as an expression. For example:      \snippet code/src_corelib_tools_qdatetime.cpp 1      If the format is not satisfied, an invalid QDate is returned. The     expressions that don't expect leading zeroes (d, M) will be     greedy. This means that they will use two digits even if this     will put them outside the accepted range of values and leaves too     few digits for other sections. For example, the following format     string could have meant January 30 but the M will grab two     digits, resulting in an invalid date:      \snippet code/src_corelib_tools_qdatetime.cpp 2      For any field that is not represented in the format the following     defaults are used:      \table     \header \li Field  \li Default value     \row    \li Year   \li 1900     \row    \li Month  \li 1     \row    \li Day    \li 1     \endtable      The following examples demonstrate the default values:      \snippet code/src_corelib_tools_qdatetime.cpp 3      \sa QDateTime::fromString(), QTime::fromString(), QDate::toString(),         QDateTime::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|fromString
name|QDate
name|QDate
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
name|QDate
name|date
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QDateTimeParser
name|dt
argument_list|(
name|QVariant
operator|::
name|Date
argument_list|,
name|QDateTimeParser
operator|::
name|FromString
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|parseFormat
argument_list|(
name|format
argument_list|)
condition|)
name|dt
operator|.
name|fromString
argument_list|(
name|string
argument_list|,
operator|&
name|date
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|date
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \overload      Returns true if the specified date (\a year, \a month, and \a     day) is valid; otherwise returns false.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 4      \sa isNull(), setDate() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QDate
operator|::
name|isValid
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
comment|// there is no year 0 in the Gregorian calendar
if|if
condition|(
name|year
operator|==
literal|0
condition|)
return|return
literal|false
return|;
return|return
operator|(
name|day
operator|>
literal|0
operator|&&
name|month
operator|>
literal|0
operator|&&
name|month
operator|<=
literal|12
operator|)
operator|&&
operator|(
name|day
operator|<=
name|monthDays
index|[
name|month
index|]
operator|||
operator|(
name|day
operator|==
literal|29
operator|&&
name|month
operator|==
literal|2
operator|&&
name|isLeapYear
argument_list|(
name|year
argument_list|)
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDate::isLeapYear(int year)      Returns true if the specified \a year is a leap year; otherwise     returns false. */
end_comment
begin_function
DECL|function|isLeapYear
name|bool
name|QDate
operator|::
name|isLeapYear
parameter_list|(
name|int
name|y
parameter_list|)
block|{
comment|// No year 0 in Gregorian calendar, so -1, -5, -9 etc are leap years
if|if
condition|(
name|y
operator|<
literal|1
condition|)
operator|++
name|y
expr_stmt|;
return|return
operator|(
name|y
operator|%
literal|4
operator|==
literal|0
operator|&&
name|y
operator|%
literal|100
operator|!=
literal|0
operator|)
operator|||
name|y
operator|%
literal|400
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \fn static QDate QDate::fromJulianDay(qint64 jd)      Converts the Julian day \a jd to a QDate.      \sa toJulianDay() */
end_comment
begin_comment
comment|/*! \fn int QDate::toJulianDay() const      Converts the date to a Julian day.      \sa fromJulianDay() */
end_comment
begin_comment
comment|/*****************************************************************************   QTime member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QTime     \inmodule QtCore     \reentrant      \brief The QTime class provides clock time functions.       A QTime object contains a clock time, i.e. the number of hours,     minutes, seconds, and milliseconds since midnight. It can read the     current time from the system clock and measure a span of elapsed     time. It provides functions for comparing times and for     manipulating a time by adding a number of milliseconds.      QTime uses the 24-hour clock format; it has no concept of AM/PM.     Unlike QDateTime, QTime knows nothing about time zones or     daylight savings time (DST).      A QTime object is typically created either by giving the number     of hours, minutes, seconds, and milliseconds explicitly, or by     using the static function currentTime(), which creates a QTime     object that contains the system's local time. Note that the     accuracy depends on the accuracy of the underlying operating     system; not all systems provide 1-millisecond accuracy.      The hour(), minute(), second(), and msec() functions provide     access to the number of hours, minutes, seconds, and milliseconds     of the time. The same information is provided in textual format by     the toString() function.      QTime provides a full set of operators to compare two QTime     objects. QTime A is considered smaller than QTime B if A is     earlier than B.      The addSecs() and addMSecs() functions provide the time a given     number of seconds or milliseconds later than a given time.     Correspondingly, the number of seconds or milliseconds     between two times can be found using secsTo() or msecsTo().      QTime can be used to measure a span of elapsed time using the     start(), restart(), and elapsed() functions.      \sa QDate, QDateTime */
end_comment
begin_comment
comment|/*!     \fn QTime::QTime()      Constructs a null time object. A null time can be a QTime(0, 0, 0, 0)     (i.e., midnight) object, except that isNull() returns true and isValid()     returns false.      \sa isNull(), isValid() */
end_comment
begin_comment
comment|/*!     Constructs a time with hour \a h, minute \a m, seconds \a s and     milliseconds \a ms.      \a h must be in the range 0 to 23, \a m and \a s must be in the     range 0 to 59, and \a ms must be in the range 0 to 999.      \sa isValid() */
end_comment
begin_constructor
DECL|function|QTime
name|QTime
operator|::
name|QTime
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
name|setHMS
argument_list|(
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn bool QTime::isNull() const      Returns true if the time is null (i.e., the QTime object was     constructed using the default constructor); otherwise returns     false. A null time is also an invalid time.      \sa isValid() */
end_comment
begin_comment
comment|/*!     Returns true if the time is valid; otherwise returns false. For example,     the time 23:30:55.746 is valid, but 24:12:30 is invalid.      \sa isNull() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QTime
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|mds
operator|>
name|NullTime
operator|&&
name|mds
operator|<
name|MSECS_PER_DAY
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the hour part (0 to 23) of the time.      Returns -1 if the time is invalid.      \sa minute(), second(), msec() */
end_comment
begin_function
DECL|function|hour
name|int
name|QTime
operator|::
name|hour
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ds
argument_list|()
operator|/
name|MSECS_PER_HOUR
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the minute part (0 to 59) of the time.      Returns -1 if the time is invalid.      \sa hour(), second(), msec() */
end_comment
begin_function
DECL|function|minute
name|int
name|QTime
operator|::
name|minute
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|ds
argument_list|()
operator|%
name|MSECS_PER_HOUR
operator|)
operator|/
name|MSECS_PER_MIN
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the second part (0 to 59) of the time.      Returns -1 if the time is invalid.      \sa hour(), minute(), msec() */
end_comment
begin_function
DECL|function|second
name|int
name|QTime
operator|::
name|second
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|ds
argument_list|()
operator|/
literal|1000
operator|)
operator|%
name|SECS_PER_MIN
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the millisecond part (0 to 999) of the time.      Returns -1 if the time is invalid.      \sa hour(), minute(), second() */
end_comment
begin_function
DECL|function|msec
name|int
name|QTime
operator|::
name|msec
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ds
argument_list|()
operator|%
literal|1000
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \overload      Returns the time as a string. The \a format parameter determines     the format of the string.      If \a format is Qt::TextDate, the string format is HH:MM:SS.zzz;     e.g. 1 second before midnight would be "23:59:59.000".      If \a format is Qt::ISODate, the string format corresponds to the     ISO 8601 extended specification (with decimal fractions) for     representations of dates; also HH:MM:SS.zzz.      If the \a format is Qt::SystemLocaleShortDate or     Qt::SystemLocaleLongDate, the string format depends on the locale     settings of the system. Identical to calling     QLocale::system().toString(time, QLocale::ShortFormat) or     QLocale::system().toString(time, QLocale::LongFormat).      If the \a format is Qt::DefaultLocaleShortDate or     Qt::DefaultLocaleLongDate, the string format depends on the     default application locale. This is the locale set with     QLocale::setDefault(), or the system locale if no default locale     has been set. Identical to calling QLocale().toString(time,     QLocale::ShortFormat) or QLocale().toString(time,     QLocale::LongFormat).      If the \a format is Qt::RFC2822Date, the string is formatted in     an \l{RFC 2822} compatible way. An example of this formatting is     "23:59:20".      If the time is invalid, an empty string will be returned.      \sa QDate::toString(), QDateTime::toString() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QTime
operator|::
name|toString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1:%2:%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|hour
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|minute
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|second
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
case|case
name|Qt
operator|::
name|ISODate
case|:
case|case
name|Qt
operator|::
name|TextDate
case|:
default|default:
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"%1:%2:%3.%4"
argument_list|)
operator|.
name|arg
argument_list|(
name|hour
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|minute
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|second
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|msec
argument_list|()
argument_list|,
literal|3
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the time as a string. The \a format parameter determines     the format of the result string.      These expressions may be used:      \table     \header \li Expression \li Output     \row \li h          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li H          \li the hour without a leading zero (0 to 23, even with AM/PM display)     \row \li HH          \li the hour with a leading zero (00 to 23, even with AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP or A          \li use AM/PM display. \e A/AP will be replaced by either "AM" or "PM".     \row \li ap or a          \li use am/pm display. \e a/ap will be replaced by either "am" or "pm".     \row \li t \li the timezone (for example "CEST")     \endtable      All other input characters will be ignored. Any sequence of characters that     are enclosed in single quotes will be treated as text and not be used as an     expression. Two consecutive single quotes ("''") are replaced by a singlequote     in the output. Formats without separators (e.g. "HHmm") are currently not supported.      Example format strings (assuming that the QTime is 14:13:09.042)      \table     \header \li Format \li Result     \row \li hh:mm:ss.zzz \li 14:13:09.042     \row \li h:m:s ap     \li 2:13:9 pm     \row \li H:m:s a      \li 14:13:9 pm     \endtable      If the time is invalid, an empty string will be returned.     If \a format is empty, the default format "hh:mm:ss" is used.      \sa QDate::toString(), QDateTime::toString(), QLocale::toString() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QTime
operator|::
name|toString
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
block|{
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     Sets the time to hour \a h, minute \a m, seconds \a s and     milliseconds \a ms.      \a h must be in the range 0 to 23, \a m and \a s must be in the     range 0 to 59, and \a ms must be in the range 0 to 999.     Returns true if the set time is valid; otherwise returns false.      \sa isValid() */
end_comment
begin_function
DECL|function|setHMS
name|bool
name|QTime
operator|::
name|setHMS
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|startTick
operator|=
name|NullTime
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|isValid
argument_list|(
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|,
name|ms
argument_list|)
condition|)
block|{
name|mds
operator|=
name|NullTime
expr_stmt|;
comment|// make this invalid
return|return
literal|false
return|;
block|}
name|mds
operator|=
operator|(
name|h
operator|*
name|SECS_PER_HOUR
operator|+
name|m
operator|*
name|SECS_PER_MIN
operator|+
name|s
operator|)
operator|*
literal|1000
operator|+
name|ms
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QTime object containing a time \a s seconds later     than the time of this object (or earlier if \a s is negative).      Note that the time will wrap if it passes midnight.      Returns a null time if this time is invalid.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 5      \sa addMSecs(), secsTo(), QDateTime::addSecs() */
end_comment
begin_function
DECL|function|addSecs
name|QTime
name|QTime
operator|::
name|addSecs
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
return|return
name|addMSecs
argument_list|(
name|s
operator|*
literal|1000
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of seconds from this time to \a t.     If \a t is earlier than this time, the number of seconds returned     is negative.      Because QTime measures time within a day and there are 86400     seconds in a day, the result is always between -86400 and 86400.      secsTo() does not take into account any milliseconds.      Returns 0 if either time is invalid.      \sa addSecs(), QDateTime::secsTo() */
end_comment
begin_function
DECL|function|secsTo
name|int
name|QTime
operator|::
name|secsTo
parameter_list|(
specifier|const
name|QTime
modifier|&
name|t
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|t
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// Truncate milliseconds as we do not want to consider them.
name|int
name|ourSeconds
init|=
name|ds
argument_list|()
operator|/
literal|1000
decl_stmt|;
name|int
name|theirSeconds
init|=
name|t
operator|.
name|ds
argument_list|()
operator|/
literal|1000
decl_stmt|;
return|return
name|theirSeconds
operator|-
name|ourSeconds
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QTime object containing a time \a ms milliseconds later     than the time of this object (or earlier if \a ms is negative).      Note that the time will wrap if it passes midnight. See addSecs()     for an example.      Returns a null time if this time is invalid.      \sa addSecs(), msecsTo(), QDateTime::addMSecs() */
end_comment
begin_function
DECL|function|addMSecs
name|QTime
name|QTime
operator|::
name|addMSecs
parameter_list|(
name|int
name|ms
parameter_list|)
specifier|const
block|{
name|QTime
name|t
decl_stmt|;
if|if
condition|(
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|ms
operator|<
literal|0
condition|)
block|{
comment|// % not well-defined for -ve, but / is.
name|int
name|negdays
init|=
operator|(
name|MSECS_PER_DAY
operator|-
name|ms
operator|)
operator|/
name|MSECS_PER_DAY
decl_stmt|;
name|t
operator|.
name|mds
operator|=
operator|(
name|ds
argument_list|()
operator|+
name|ms
operator|+
name|negdays
operator|*
name|MSECS_PER_DAY
operator|)
operator|%
name|MSECS_PER_DAY
expr_stmt|;
block|}
else|else
block|{
name|t
operator|.
name|mds
operator|=
operator|(
name|ds
argument_list|()
operator|+
name|ms
operator|)
operator|%
name|MSECS_PER_DAY
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
name|startTick
operator|>
name|NullTime
condition|)
name|t
operator|.
name|startTick
operator|=
operator|(
name|startTick
operator|+
name|ms
operator|)
operator|%
name|MSECS_PER_DAY
expr_stmt|;
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of milliseconds from this time to \a t.     If \a t is earlier than this time, the number of milliseconds returned     is negative.      Because QTime measures time within a day and there are 86400     seconds in a day, the result is always between -86400000 and     86400000 ms.      Returns 0 if either time is invalid.      \sa secsTo(), addMSecs(), QDateTime::msecsTo() */
end_comment
begin_function
DECL|function|msecsTo
name|int
name|QTime
operator|::
name|msecsTo
parameter_list|(
specifier|const
name|QTime
modifier|&
name|t
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|t
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
comment|// GetLocalTime() for Windows CE has no milliseconds resolution
if|if
condition|(
name|t
operator|.
name|startTick
operator|>
name|NullTime
operator|&&
name|startTick
operator|>
name|NullTime
condition|)
return|return
name|t
operator|.
name|startTick
operator|-
name|startTick
return|;
else|else
endif|#
directive|endif
return|return
name|t
operator|.
name|ds
argument_list|()
operator|-
name|ds
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTime::operator==(const QTime&t) const      Returns true if this time is equal to \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator!=(const QTime&t) const      Returns true if this time is different from \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator<(const QTime&t) const      Returns true if this time is earlier than \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator<=(const QTime&t) const      Returns true if this time is earlier than or equal to \a t;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator>(const QTime&t) const      Returns true if this time is later than \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator>=(const QTime&t) const      Returns true if this time is later than or equal to \a t;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QTime::currentTime()      Returns the current time as reported by the system clock.      Note that the accuracy depends on the accuracy of the underlying     operating system; not all systems provide 1-millisecond accuracy. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function
DECL|function|fromIsoTimeString
specifier|static
name|QTime
name|fromIsoTimeString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|,
name|bool
modifier|*
name|isMidnight24
parameter_list|)
block|{
if|if
condition|(
name|isMidnight24
condition|)
operator|*
name|isMidnight24
operator|=
literal|false
expr_stmt|;
specifier|const
name|int
name|size
init|=
name|string
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|5
condition|)
return|return
name|QTime
argument_list|()
return|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|int
name|hour
init|=
name|string
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
specifier|const
name|int
name|minute
init|=
name|string
operator|.
name|mid
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
name|int
name|second
init|=
literal|0
decl_stmt|;
name|int
name|msec
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|5
condition|)
block|{
comment|// HH:MM format
name|second
operator|=
literal|0
expr_stmt|;
name|msec
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|string
operator|.
name|at
argument_list|(
literal|5
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|||
name|string
operator|.
name|at
argument_list|(
literal|5
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
condition|)
block|{
if|if
condition|(
name|format
operator|==
name|Qt
operator|::
name|TextDate
condition|)
return|return
name|QTime
argument_list|()
return|;
comment|// ISODate HH:MM.SSSSSS format
comment|// We only want 5 digits worth of fraction of minute. This follows the existing
comment|// behavior that determines how milliseconds are read; 4 millisecond digits are
comment|// read and then rounded to 3. If we read at most 5 digits for fraction of minute,
comment|// the maximum amount of millisecond digits it will expand to once converted to
comment|// seconds is 4. E.g. 12:34,99999 will expand to 12:34:59.9994. The milliseconds
comment|// will then be rounded up AND clamped to 999.
specifier|const
name|float
name|minuteFraction
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"0.%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|string
operator|.
name|mid
argument_list|(
literal|6
argument_list|,
literal|5
argument_list|)
argument_list|)
operator|.
name|toFloat
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
specifier|const
name|float
name|secondWithMs
init|=
name|minuteFraction
operator|*
literal|60
decl_stmt|;
specifier|const
name|float
name|secondNoMs
init|=
name|std
operator|::
name|floor
argument_list|(
name|secondWithMs
argument_list|)
decl_stmt|;
specifier|const
name|float
name|secondFraction
init|=
name|secondWithMs
operator|-
name|secondNoMs
decl_stmt|;
name|second
operator|=
name|secondNoMs
expr_stmt|;
name|msec
operator|=
name|qMin
argument_list|(
name|qRound
argument_list|(
name|secondFraction
operator|*
literal|1000.0
argument_list|)
argument_list|,
literal|999
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// HH:MM:SS or HH:MM:SS.sssss
name|second
operator|=
name|string
operator|.
name|mid
argument_list|(
literal|6
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
if|if
condition|(
name|size
operator|>
literal|8
operator|&&
operator|(
name|string
operator|.
name|at
argument_list|(
literal|8
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|||
name|string
operator|.
name|at
argument_list|(
literal|8
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|double
name|secondFraction
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"0.%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|string
operator|.
name|mid
argument_list|(
literal|9
argument_list|,
literal|4
argument_list|)
argument_list|)
operator|.
name|toDouble
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
name|msec
operator|=
name|qMin
argument_list|(
name|qRound
argument_list|(
name|secondFraction
operator|*
literal|1000.0
argument_list|)
argument_list|,
literal|999
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|format
operator|==
name|Qt
operator|::
name|ISODate
operator|&&
name|hour
operator|==
literal|24
operator|&&
name|minute
operator|==
literal|0
operator|&&
name|second
operator|==
literal|0
operator|&&
name|msec
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isMidnight24
condition|)
operator|*
name|isMidnight24
operator|=
literal|true
expr_stmt|;
name|hour
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|msec
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTime QTime::fromString(const QString&string, Qt::DateFormat format)      Returns the time represented in the \a string as a QTime using the     \a format given, or an invalid time if this is not possible.      Note that fromString() uses a "C" locale encoded string to convert     milliseconds to a float value. If the default locale is not "C",     this may result in two conversion attempts (if the conversion     fails for the default locale). This should be considered an     implementation detail. */
end_comment
begin_function
DECL|function|fromString
name|QTime
name|QTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
block|{
if|if
condition|(
name|string
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QTime
argument_list|()
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
block|{
name|QTime
name|time
decl_stmt|;
name|rfcDateImpl
argument_list|(
name|string
argument_list|,
literal|0
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
return|return
name|time
return|;
block|}
case|case
name|Qt
operator|::
name|ISODate
case|:
case|case
name|Qt
operator|::
name|TextDate
case|:
default|default:
return|return
name|fromIsoTimeString
argument_list|(
name|string
argument_list|,
name|format
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QTime::fromString(const QString&string, const QString&format)      Returns the QTime represented by the \a string, using the \a     format given, or an invalid time if the string cannot be parsed.      These expressions may be used for the format:      \table     \header \li Expression \li Output     \row \li h          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP          \li interpret as an AM/PM time. \e AP must be either "AM" or "PM".     \row \li ap          \li Interpret as an AM/PM time. \e ap must be either "am" or "pm".     \endtable      All other input characters will be treated as text. Any sequence     of characters that are enclosed in single quotes will also be     treated as text and not be used as an expression.      \snippet code/src_corelib_tools_qdatetime.cpp 6      If the format is not satisfied, an invalid QTime is returned.     Expressions that do not expect leading zeroes to be given (h, m, s     and z) are greedy. This means that they will use two digits even if     this puts them outside the range of accepted values and leaves too     few digits for other sections. For example, the following string     could have meant 00:07:10, but the m will grab two digits, resulting     in an invalid time:      \snippet code/src_corelib_tools_qdatetime.cpp 7      Any field that is not represented in the format will be set to zero.     For example:      \snippet code/src_corelib_tools_qdatetime.cpp 8      \sa QDateTime::fromString(), QDate::fromString(), QDate::toString(),     QDateTime::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|fromString
name|QTime
name|QTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
name|QTime
name|time
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QDateTimeParser
name|dt
argument_list|(
name|QVariant
operator|::
name|Time
argument_list|,
name|QDateTimeParser
operator|::
name|FromString
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|parseFormat
argument_list|(
name|format
argument_list|)
condition|)
name|dt
operator|.
name|fromString
argument_list|(
name|string
argument_list|,
literal|0
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|time
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \overload      Returns true if the specified time is valid; otherwise returns     false.      The time is valid if \a h is in the range 0 to 23, \a m and     \a s are in the range 0 to 59, and \a ms is in the range 0 to 999.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 9 */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QTime
operator|::
name|isValid
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
return|return
operator|(
name|uint
operator|)
name|h
operator|<
literal|24
operator|&&
operator|(
name|uint
operator|)
name|m
operator|<
literal|60
operator|&&
operator|(
name|uint
operator|)
name|s
operator|<
literal|60
operator|&&
operator|(
name|uint
operator|)
name|ms
operator|<
literal|1000
return|;
block|}
end_function
begin_comment
comment|/*!     Sets this time to the current time. This is practical for timing:      \snippet code/src_corelib_tools_qdatetime.cpp 10      \sa restart(), elapsed(), currentTime() */
end_comment
begin_function
DECL|function|start
name|void
name|QTime
operator|::
name|start
parameter_list|()
block|{
operator|*
name|this
operator|=
name|currentTime
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets this time to the current time and returns the number of     milliseconds that have elapsed since the last time start() or     restart() was called.      This function is guaranteed to be atomic and is thus very handy     for repeated measurements. Call start() to start the first     measurement, and restart() for each later measurement.      Note that the counter wraps to zero 24 hours after the last call     to start() or restart().      \warning If the system's clock setting has been changed since the     last time start() or restart() was called, the result is     undefined. This can happen when daylight savings time is turned on     or off.      \sa start(), elapsed(), currentTime() */
end_comment
begin_function
DECL|function|restart
name|int
name|QTime
operator|::
name|restart
parameter_list|()
block|{
name|QTime
name|t
init|=
name|currentTime
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|msecsTo
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|// passed midnight
name|n
operator|+=
literal|86400
operator|*
literal|1000
expr_stmt|;
operator|*
name|this
operator|=
name|t
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of milliseconds that have elapsed since the     last time start() or restart() was called.      Note that the counter wraps to zero 24 hours after the last call     to start() or restart.      Note that the accuracy depends on the accuracy of the underlying     operating system; not all systems provide 1-millisecond accuracy.      \warning If the system's clock setting has been changed since the     last time start() or restart() was called, the result is     undefined. This can happen when daylight savings time is turned on     or off.      \sa start(), restart() */
end_comment
begin_function
DECL|function|elapsed
name|int
name|QTime
operator|::
name|elapsed
parameter_list|()
specifier|const
block|{
name|int
name|n
init|=
name|msecsTo
argument_list|(
name|currentTime
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|// passed midnight
name|n
operator|+=
literal|86400
operator|*
literal|1000
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QDateTime member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QDateTime     \inmodule QtCore     \ingroup shared     \reentrant     \brief The QDateTime class provides date and time functions.       A QDateTime object contains a calendar date and a clock time (a     "datetime"). It is a combination of the QDate and QTime classes.     It can read the current datetime from the system clock. It     provides functions for comparing datetimes and for manipulating a     datetime by adding a number of seconds, days, months, or years.      A QDateTime object is typically created either by giving a date     and time explicitly in the constructor, or by using the static     function currentDateTime() that returns a QDateTime object set     to the system clock's time. The date and time can be changed with     setDate() and setTime(). A datetime can also be set using the     setTime_t() function that takes a POSIX-standard "number of     seconds since 00:00:00 on January 1, 1970" value. The fromString()     function returns a QDateTime, given a string and a date format     used to interpret the date within the string.      The date() and time() functions provide access to the date and     time parts of the datetime. The same information is provided in     textual format by the toString() function.      QDateTime provides a full set of operators to compare two     QDateTime objects, where smaller means earlier and larger means     later.      You can increment (or decrement) a datetime by a given number of     milliseconds using addMSecs(), seconds using addSecs(), or days     using addDays(). Similarly, you can use addMonths() and addYears().     The daysTo() function returns the number of days between two datetimes,     secsTo() returns the number of seconds between two datetimes, and     msecsTo() returns the number of milliseconds between two datetimes.      QDateTime can store datetimes as \l{Qt::LocalTime}{local time} or     as \l{Qt::UTC}{UTC}. QDateTime::currentDateTime() returns a     QDateTime expressed as local time; use toUTC() to convert it to     UTC. You can also use timeSpec() to find out if a QDateTime     object stores a UTC time or a local time. Operations such as     addSecs() and secsTo() are aware of daylight saving time (DST).      \note QDateTime does not account for leap seconds.      \section1      \section2 No Year 0      There is no year 0. Dates in that year are considered invalid. The     year -1 is the year "1 before Christ" or "1 before current era."     The day before 1 January 1 CE is 31 December 1 BCE.      \section2 Range of Valid Dates      Dates are stored internally as a Julian Day number, an integer count of     every day in a contiguous range, with 24 November 4714 BCE in the Gregorian     calendar being Julian Day 0 (1 January 4713 BCE in the Julian calendar).     As well as being an efficient and accurate way of storing an absolute date,     it is suitable for converting a Date into other calendar systems such as     Hebrew, Islamic or Chinese. The Julian Day number can be obtained using     QDate::toJulianDay() and can be set using QDate::fromJulianDay().      The range of dates able to be stored by QDate as a Julian Day number is     for technical reasons limited to between -784350574879 and 784354017364,     which means from before 2 billion BCE to after 2 billion CE.      \section2     Use of System Timezone      QDateTime uses the system's time zone information to determine the     offset of local time from UTC. If the system is not configured     correctly or not up-to-date, QDateTime will give wrong results as     well.      \section2 Daylight Savings Time (DST)      QDateTime takes into account the system's time zone information     when dealing with DST. On modern Unix systems, this means it     applies the correct historical DST data whenever possible. On     Windows and Windows CE, where the system doesn't support     historical DST data, historical accuracy is not maintained with     respect to DST.      The range of valid dates taking DST into account is 1970-01-01 to     the present, and rules are in place for handling DST correctly     until 2037-12-31, but these could change. For dates falling     outside that range, QDateTime makes a \e{best guess} using the     rules for year 1970 or 2037, but we can't guarantee accuracy. This     means QDateTime doesn't take into account changes in a locale's     time zone before 1970, even if the system's time zone database     supports that information.      \section2 Offset From UTC      A Qt::TimeSpec of Qt::OffsetFromUTC is also supported. This allows you     to define a QDateTime relative to UTC at a fixed offset of a given number     of seconds from UTC.  For example, an offset of +3600 seconds is one hour     ahead of UTC and is usually written in ISO standard notation as     "UTC+01:00".  Daylight Savings Time never applies with this TimeSpec.      There is no explicit size restriction to the offset seconds, but there is     an implicit limit imposed when using the toString() and fromString()     methods which use a format of [+|-]hh:mm, effectively limiting the range     to +/- 99 hours and 59 minutes and whole minutes only.  Note that currently     no time zone lies outside the range of +/- 14 hours.      \sa QDate, QTime, QDateTimeEdit */
end_comment
begin_comment
comment|/*!     Constructs a null datetime (i.e. null date and null time). A null     datetime is invalid, since the date is invalid.      \sa isValid() */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a datetime with the given \a date, a valid     time(00:00:00.000), and sets the timeSpec() to Qt::LocalTime. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|(
name|date
argument_list|,
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|,
literal|0
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a datetime with the given \a date and \a time, using     the time specification defined by \a spec.      If \a date is valid and \a time is not, the time will be set to midnight.      If \a spec is Qt::OffsetFromUTC then it will be set to Qt::UTC, i.e. an     offset of 0 seconds. To create a Qt::OffsetFromUTC datetime use the     correct constructor. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|spec
argument_list|,
literal|0
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \since 5.2      Constructs a datetime with the given \a date and \a time, using     the time specification defined by \a spec and \a offsetSeconds seconds.      If \a date is valid and \a time is not, the time will be set to midnight.      If the \a spec is not Qt::OffsetFromUTC then \a offsetSeconds will be ignored.      If the \a spec is Qt::OffsetFromUTC and \a offsetSeconds is 0 then the     timeSpec() will be set to Qt::UTC, i.e. an offset of 0 seconds. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|,
name|int
name|offsetSeconds
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|spec
argument_list|,
name|offsetSeconds
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal     \since 5.2      Private.      Create a datetime with the given \a date, \a time, \a spec and \a offsetSeconds */
end_comment
begin_constructor
DECL|function|QDateTimePrivate
name|QDateTimePrivate
operator|::
name|QDateTimePrivate
parameter_list|(
specifier|const
name|QDate
modifier|&
name|toDate
parameter_list|,
specifier|const
name|QTime
modifier|&
name|toTime
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|toSpec
parameter_list|,
name|int
name|offsetSeconds
parameter_list|)
block|{
name|date
operator|=
name|toDate
expr_stmt|;
if|if
condition|(
operator|!
name|toTime
operator|.
name|isValid
argument_list|()
operator|&&
name|toDate
operator|.
name|isValid
argument_list|()
condition|)
name|time
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|time
operator|=
name|toTime
expr_stmt|;
name|m_offsetFromUtc
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|toSpec
condition|)
block|{
case|case
name|Qt
operator|::
name|UTC
case|:
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
if|if
condition|(
name|offsetSeconds
operator|==
literal|0
condition|)
block|{
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
block|}
else|else
block|{
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
expr_stmt|;
name|m_offsetFromUtc
operator|=
name|offsetSeconds
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|LocalTime
case|:
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of the \a other datetime. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the datetime. */
end_comment
begin_destructor
DECL|function|~QDateTime
name|QDateTime
operator|::
name|~
name|QDateTime
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Makes a copy of the \a other datetime and returns a reference to the     copy. */
end_comment
begin_function
DECL|function|operator =
name|QDateTime
modifier|&
name|QDateTime
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QDateTime::swap(QDateTime&other)     \since 5.0      Swaps this datetime with \a other. This operation is very fast     and never fails. */
end_comment
begin_comment
comment|/*!     Returns true if both the date and the time are null; otherwise     returns false. A null datetime is invalid.      \sa QDate::isNull(), QTime::isNull(), isValid() */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QDateTime
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|date
operator|.
name|isNull
argument_list|()
operator|&&
name|d
operator|->
name|time
operator|.
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if both the date and the time are valid; otherwise     returns false.      \sa QDate::isValid(), QTime::isValid() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QDateTime
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|date
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|time
operator|.
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the date part of the datetime.      \sa setDate(), time(), timeSpec() */
end_comment
begin_function
DECL|function|date
name|QDate
name|QDateTime
operator|::
name|date
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|date
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the time part of the datetime.      \sa setTime(), date(), timeSpec() */
end_comment
begin_function
DECL|function|time
name|QTime
name|QDateTime
operator|::
name|time
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|time
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the time specification of the datetime.      \sa setTimeSpec(), date(), time(), Qt::TimeSpec */
end_comment
begin_function
DECL|function|timeSpec
name|Qt
operator|::
name|TimeSpec
name|QDateTime
operator|::
name|timeSpec
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|d
operator|->
name|spec
condition|)
block|{
case|case
name|QDateTimePrivate
operator|::
name|UTC
case|:
return|return
name|Qt
operator|::
name|UTC
return|;
case|case
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
case|:
return|return
name|Qt
operator|::
name|OffsetFromUTC
return|;
default|default:
return|return
name|Qt
operator|::
name|LocalTime
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Returns the current Offset From UTC in seconds.      If the timeSpec() is Qt::OffsetFromUTC this will be the value originally set.      If the timeSpec() is Qt::LocalTime this will be the difference between the     Local Time and UTC including any Daylight Saving Offset.      If the timeSpec() is Qt::UTC this will be 0.      \sa setOffsetFromUtc() */
end_comment
begin_function
DECL|function|offsetFromUtc
name|int
name|QDateTime
operator|::
name|offsetFromUtc
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|d
operator|->
name|spec
condition|)
block|{
case|case
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
case|:
return|return
name|d
operator|->
name|m_offsetFromUtc
return|;
case|case
name|QDateTimePrivate
operator|::
name|UTC
case|:
return|return
literal|0
return|;
default|default:
comment|// Any Qt::LocalTime
specifier|const
name|QDateTime
name|fakeDate
argument_list|(
name|d
operator|->
name|date
argument_list|,
name|d
operator|->
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
return|return
operator|(
name|fakeDate
operator|.
name|toMSecsSinceEpoch
argument_list|()
operator|-
name|toMSecsSinceEpoch
argument_list|()
operator|)
operator|/
literal|1000
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Returns the Time Zone Abbreviation for the datetime.      If the timeSpec() is Qt::UTC this will be "UTC".      If the timeSpec() is Qt::OffsetFromUTC this will be in the format     "UTC[+-]00:00".      If the timeSpec() is Qt::LocalTime then the host system is queried for the     correct abbreviation.      Note that abbreviations may or may not be localized.      Note too that the abbreviation is not guaranteed to be a unique value,     i.e. different time zones may have the same abbreviation.      \sa timeSpec() */
end_comment
begin_function
DECL|function|timeZoneAbbreviation
name|QString
name|QDateTime
operator|::
name|timeZoneAbbreviation
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|d
operator|->
name|spec
condition|)
block|{
case|case
name|QDateTimePrivate
operator|::
name|UTC
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"UTC"
argument_list|)
return|;
case|case
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
case|:
return|return
name|QLatin1String
argument_list|(
literal|"UTC"
argument_list|)
operator|+
name|toOffsetString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|,
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
return|;
default|default:
block|{
comment|// Any Qt::LocalTime
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
comment|// TODO Stub to enable compilation on WinCE
return|return
name|QString
argument_list|()
return|;
else|#
directive|else
name|QDate
name|dt
init|=
name|adjustDate
argument_list|(
name|d
operator|->
name|date
argument_list|)
decl_stmt|;
name|QTime
name|tm
init|=
name|d
operator|->
name|time
decl_stmt|;
name|QString
name|abbrev
decl_stmt|;
name|qt_mktime
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
operator|&
name|abbrev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|abbrev
return|;
endif|#
directive|endif
comment|// !Q_OS_WINCE
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Sets the date part of this datetime to \a date.     If no time is set, it is set to midnight.      \sa date(), setTime(), setTimeSpec() */
end_comment
begin_function
DECL|function|setDate
name|void
name|QDateTime
operator|::
name|setDate
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|date
operator|=
name|date
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|LocalStandard
operator|||
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|LocalDST
condition|)
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
if|if
condition|(
name|date
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|time
operator|.
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|time
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the time part of this datetime to \a time.      \sa time(), setDate(), setTimeSpec() */
end_comment
begin_function
DECL|function|setTime
name|void
name|QDateTime
operator|::
name|setTime
parameter_list|(
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|LocalStandard
operator|||
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|LocalDST
condition|)
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
name|d
operator|->
name|time
operator|=
name|time
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the time specification used in this datetime to \a spec.     The datetime will refer to a different point in time.      If \a spec is Qt::OffsetFromUTC then the timeSpec() will be set     to Qt::UTC, i.e. an effective offset of 0.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 19      \sa timeSpec(), setDate(), setTime(), Qt::TimeSpec */
end_comment
begin_function
DECL|function|setTimeSpec
name|void
name|QDateTime
operator|::
name|setTimeSpec
parameter_list|(
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|m_offsetFromUtc
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|spec
condition|)
block|{
case|case
name|Qt
operator|::
name|UTC
case|:
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
break|break;
default|default:
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Sets the timeSpec() to Qt::OffsetFromUTC and the offset to \a offsetSeconds.     The datetime will refer to a different point in time.      The maximum and minimum offset is 14 positive or negative hours.  If     \a offsetSeconds is larger or smaller than that, then the result is     undefined.      If \a offsetSeconds is 0 then the timeSpec() will be set to Qt::UTC.      \sa isValid(), offsetFromUtc() */
end_comment
begin_function
DECL|function|setOffsetFromUtc
name|void
name|QDateTime
operator|::
name|setOffsetFromUtc
parameter_list|(
name|int
name|offsetSeconds
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|offsetSeconds
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
name|d
operator|->
name|m_offsetFromUtc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
expr_stmt|;
name|d
operator|->
name|m_offsetFromUtc
operator|=
name|offsetSeconds
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|toMSecsSinceEpoch_helper
name|qint64
name|toMSecsSinceEpoch_helper
parameter_list|(
name|qint64
name|jd
parameter_list|,
name|int
name|msecs
parameter_list|)
block|{
name|qint64
name|days
init|=
name|jd
operator|-
name|JULIAN_DAY_FOR_EPOCH
decl_stmt|;
name|qint64
name|retval
init|=
operator|(
name|days
operator|*
name|MSECS_PER_DAY
operator|)
operator|+
name|msecs
decl_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the datetime as the number of milliseconds that have passed     since 1970-01-01T00:00:00.000, Coordinated Universal Time (Qt::UTC).      On systems that do not support time zones, this function will     behave as if local time were Qt::UTC.      The behavior for this function is undefined if the datetime stored in     this object is not valid. However, for all valid dates, this function     returns a unique value.      \sa toTime_t(), setMSecsSinceEpoch() */
end_comment
begin_function
DECL|function|toMSecsSinceEpoch
name|qint64
name|QDateTime
operator|::
name|toMSecsSinceEpoch
parameter_list|()
specifier|const
block|{
name|QDate
name|utcDate
decl_stmt|;
name|QTime
name|utcTime
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|utcDate
argument_list|,
name|utcTime
argument_list|)
expr_stmt|;
return|return
name|toMSecsSinceEpoch_helper
argument_list|(
name|utcDate
operator|.
name|toJulianDay
argument_list|()
argument_list|,
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|msecsTo
argument_list|(
name|utcTime
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the datetime as the number of seconds that have passed     since 1970-01-01T00:00:00, Coordinated Universal Time (Qt::UTC).      On systems that do not support time zones, this function will     behave as if local time were Qt::UTC.      \note This function returns a 32-bit unsigned integer, so it does not     support dates before 1970, but it does support dates after     2038-01-19T03:14:06, which may not be valid time_t values. Be careful     when passing those time_t values to system functions, which could     interpret them as negative dates.      If the date is outside the range 1970-01-01T00:00:00 to     2106-02-07T06:28:14, this function returns -1 cast to an unsigned integer     (i.e., 0xFFFFFFFF).      To get an extended range, use toMSecsSinceEpoch().      \sa toMSecsSinceEpoch(), setTime_t() */
end_comment
begin_function
DECL|function|toTime_t
name|uint
name|QDateTime
operator|::
name|toTime_t
parameter_list|()
specifier|const
block|{
name|qint64
name|retval
init|=
name|toMSecsSinceEpoch
argument_list|()
operator|/
literal|1000
decl_stmt|;
if|if
condition|(
name|quint64
argument_list|(
name|retval
argument_list|)
operator|>=
name|Q_UINT64_C
argument_list|(
literal|0xFFFFFFFF
argument_list|)
condition|)
return|return
name|uint
argument_list|(
operator|-
literal|1
argument_list|)
return|;
return|return
name|uint
argument_list|(
name|retval
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Sets the date and time given the number of milliseconds \a msecs that have     passed since 1970-01-01T00:00:00.000, Coordinated Universal Time     (Qt::UTC). On systems that do not support time zones this function     will behave as if local time were Qt::UTC.      Note that passing the minimum of \c qint64     (\c{std::numeric_limits<qint64>::min()}) to \a msecs will result in     undefined behavior.      \sa toMSecsSinceEpoch(), setTime_t() */
end_comment
begin_function
DECL|function|setMSecsSinceEpoch
name|void
name|QDateTime
operator|::
name|setMSecsSinceEpoch
parameter_list|(
name|qint64
name|msecs
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|qint64
name|ddays
init|=
name|msecs
operator|/
name|MSECS_PER_DAY
decl_stmt|;
name|msecs
operator|%=
name|MSECS_PER_DAY
expr_stmt|;
if|if
condition|(
name|msecs
operator|<
literal|0
condition|)
block|{
comment|// negative
operator|--
name|ddays
expr_stmt|;
name|msecs
operator|+=
name|MSECS_PER_DAY
expr_stmt|;
block|}
name|d
operator|->
name|date
operator|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|.
name|addDays
argument_list|(
name|ddays
argument_list|)
expr_stmt|;
name|d
operator|->
name|time
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|addMSecs
argument_list|(
name|msecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
name|utcToOffset
argument_list|(
operator|&
name|d
operator|->
name|date
argument_list|,
operator|&
name|d
operator|->
name|time
argument_list|,
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|spec
operator|!=
name|QDateTimePrivate
operator|::
name|UTC
condition|)
name|utcToLocal
argument_list|(
name|d
operator|->
name|date
argument_list|,
name|d
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QDateTime::setTime_t(uint seconds)      Sets the date and time given the number of \a seconds that have     passed since 1970-01-01T00:00:00, Coordinated Universal Time     (Qt::UTC). On systems that do not support time zones this function     will behave as if local time were Qt::UTC.      \sa toTime_t() */
end_comment
begin_function
DECL|function|setTime_t
name|void
name|QDateTime
operator|::
name|setTime_t
parameter_list|(
name|uint
name|secsSince1Jan1970UTC
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|date
operator|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|.
name|addDays
argument_list|(
name|secsSince1Jan1970UTC
operator|/
name|SECS_PER_DAY
argument_list|)
expr_stmt|;
name|d
operator|->
name|time
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|addSecs
argument_list|(
name|secsSince1Jan1970UTC
operator|%
name|SECS_PER_DAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
name|utcToOffset
argument_list|(
operator|&
name|d
operator|->
name|date
argument_list|,
operator|&
name|d
operator|->
name|time
argument_list|,
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|spec
operator|!=
name|QDateTimePrivate
operator|::
name|UTC
condition|)
name|utcToLocal
argument_list|(
name|d
operator|->
name|date
argument_list|,
name|d
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \fn QString QDateTime::toString(Qt::DateFormat format) const      \overload      Returns the datetime as a string in the \a format given.      If the \a format is Qt::TextDate, the string is formatted in     the default way. QDate::shortDayName(), QDate::shortMonthName(),     and QTime::toString() are used to generate the string, so the     day and month names will be localized names using the system locale,     i.e. QLocale::system(). An example of this formatting is     "Wed May 20 03:40:13.456 1998".      If the \a format is Qt::ISODate, the string format corresponds     to the ISO 8601 extended specification (with decimal fractions) for     representations of dates and times, taking the form     YYYY-MM-DDTHH:MM:SS.zzz[Z|[+|-]HH:MM], depending on the timeSpec()     of the QDateTime. If the timeSpec() is Qt::UTC, Z will be appended     to the string; if the timeSpec() is Qt::OffsetFromUTC, the offset     in hours and minutes from UTC will be appended to the string.      If the \a format is Qt::SystemLocaleShortDate or     Qt::SystemLocaleLongDate, the string format depends on the locale     settings of the system. Identical to calling     QLocale::system().toString(datetime, QLocale::ShortFormat) or     QLocale::system().toString(datetime, QLocale::LongFormat).      If the \a format is Qt::DefaultLocaleShortDate or     Qt::DefaultLocaleLongDate, the string format depends on the     default application locale. This is the locale set with     QLocale::setDefault(), or the system locale if no default locale     has been set. Identical to calling QLocale().toString(datetime,     QLocale::ShortFormat) or QLocale().toString(datetime,     QLocale::LongFormat).      If the \a format is Qt::RFC2822Date, the string is formatted     following \l{RFC 2822}.      If the datetime is invalid, an empty string will be returned.      \warning The Qt::ISODate format is only valid for years in the     range 0 to 9999. This restriction may apply to locale-aware     formats as well, depending on the locale settings.      \sa QDate::toString(), QTime::toString(), Qt::DateFormat */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDateTime
operator|::
name|toString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
specifier|const
block|{
name|QString
name|buf
decl_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|buf
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
block|{
name|buf
operator|=
name|toString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"dd MMM yyyy hh:mm:ss "
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|utcOffset
init|=
name|d
operator|->
name|m_offsetFromUtc
decl_stmt|;
if|if
condition|(
name|timeSpec
argument_list|()
operator|==
name|Qt
operator|::
name|LocalTime
condition|)
block|{
name|QDateTime
name|utc
init|=
name|toUTC
argument_list|()
decl_stmt|;
name|utc
operator|.
name|setTimeSpec
argument_list|(
name|timeSpec
argument_list|()
argument_list|)
expr_stmt|;
name|utcOffset
operator|=
name|utc
operator|.
name|secsTo
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
specifier|const
name|int
name|offset
init|=
name|qAbs
argument_list|(
name|utcOffset
argument_list|)
decl_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
operator|(
name|offset
operator|==
name|utcOffset
operator|)
condition|?
literal|'+'
else|:
literal|'-'
argument_list|)
expr_stmt|;
specifier|const
name|int
name|hour
init|=
name|offset
operator|/
literal|3600
decl_stmt|;
if|if
condition|(
name|hour
operator|<
literal|10
condition|)
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|hour
argument_list|)
expr_stmt|;
specifier|const
name|int
name|min
init|=
operator|(
name|offset
operator|-
operator|(
name|hour
operator|*
literal|3600
operator|)
operator|)
operator|/
literal|60
decl_stmt|;
if|if
condition|(
name|min
operator|<
literal|10
condition|)
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|min
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
default|default:
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
case|case
name|Qt
operator|::
name|TextDate
case|:
comment|//We cant use date.toString(Qt::TextDate) as we need to insert the time before the year
name|buf
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"%1 %2 %3 %4 %5"
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|date
operator|.
name|shortDayName
argument_list|(
name|d
operator|->
name|date
operator|.
name|dayOfWeek
argument_list|()
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|date
operator|.
name|shortMonthName
argument_list|(
name|d
operator|->
name|date
operator|.
name|month
argument_list|()
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|date
operator|.
name|day
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|time
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|TextDate
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|date
operator|.
name|year
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeSpec
argument_list|()
operator|!=
name|Qt
operator|::
name|LocalTime
condition|)
block|{
name|buf
operator|+=
name|QStringLiteral
argument_list|(
literal|" GMT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
name|buf
operator|+=
name|toOffsetString
argument_list|(
name|Qt
operator|::
name|TextDate
argument_list|,
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
endif|#
directive|endif
case|case
name|Qt
operator|::
name|ISODate
case|:
name|buf
operator|=
name|d
operator|->
name|date
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// failed to convert
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|d
operator|->
name|time
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|spec
condition|)
block|{
case|case
name|QDateTimePrivate
operator|::
name|UTC
case|:
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
case|:
name|buf
operator|+=
name|toOffsetString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|,
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|buf
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the datetime as a string. The \a format parameter     determines the format of the result string.      These expressions may be used for the date:      \table     \header \li Expression \li Output     \row \li d \li the day as number without a leading zero (1 to 31)     \row \li dd \li the day as number with a leading zero (01 to 31)     \row \li ddd             \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').             Uses the system locale to localize the name, i.e. QLocale::system().     \row \li dddd             \li the long localized day name (e.g. 'Monday' to 'Qt::Sunday').             Uses the system locale to localize the name, i.e. QLocale::system().     \row \li M \li the month as number without a leading zero (1-12)     \row \li MM \li the month as number with a leading zero (01-12)     \row \li MMM             \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').             Uses the system locale to localize the name, i.e. QLocale::system().     \row \li MMMM             \li the long localized month name (e.g. 'January' to 'December').             Uses the system locale to localize the name, i.e. QLocale::system().     \row \li yy \li the year as two digit number (00-99)     \row \li yyyy \li the year as four digit number     \endtable      These expressions may be used for the time:      \table     \header \li Expression \li Output     \row \li h          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li H          \li the hour without a leading zero (0 to 23, even with AM/PM display)     \row \li HH          \li the hour with a leading zero (00 to 23, even with AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP or A          \li use AM/PM display. \e A/AP will be replaced by either "AM" or "PM".     \row \li ap or a          \li use am/pm display. \e a/ap will be replaced by either "am" or "pm".     \row \li t \li the timezone (for example "CEST")     \endtable      All other input characters will be ignored. Any sequence of characters that     are enclosed in single quotes will be treated as text and not be used as an     expression. Two consecutive single quotes ("''") are replaced by a singlequote     in the output. Formats without separators (e.g. "HHmm") are currently not supported.      Example format strings (assumed that the QDateTime is 21 May 2001     14:13:09):      \table     \header \li Format       \li Result     \row \li dd.MM.yyyy      \li 21.05.2001     \row \li ddd MMMM d yy   \li Tue May 21 01     \row \li hh:mm:ss.zzz    \li 14:13:09.042     \row \li h:m:s ap        \li 2:13:9 pm     \endtable      If the datetime is invalid, an empty string will be returned.      \sa QDate::toString(), QTime::toString(), QLocale::toString() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDateTime
operator|::
name|toString
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
block|{
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a ndays days     later than the datetime of this object (or earlier if \a ndays is     negative).      \sa daysTo(), addMonths(), addYears(), addSecs() */
end_comment
begin_function
DECL|function|addDays
name|QDateTime
name|QDateTime
operator|::
name|addDays
parameter_list|(
name|qint64
name|ndays
parameter_list|)
specifier|const
block|{
name|QDateTime
name|dt
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|dt
operator|.
name|detach
argument_list|()
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|date
operator|=
name|d
operator|->
name|date
operator|.
name|addDays
argument_list|(
name|ndays
argument_list|)
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a nmonths months     later than the datetime of this object (or earlier if \a nmonths     is negative).      \sa daysTo(), addDays(), addYears(), addSecs() */
end_comment
begin_function
DECL|function|addMonths
name|QDateTime
name|QDateTime
operator|::
name|addMonths
parameter_list|(
name|int
name|nmonths
parameter_list|)
specifier|const
block|{
name|QDateTime
name|dt
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|dt
operator|.
name|detach
argument_list|()
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|date
operator|=
name|d
operator|->
name|date
operator|.
name|addMonths
argument_list|(
name|nmonths
argument_list|)
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a nyears years     later than the datetime of this object (or earlier if \a nyears is     negative).      \sa daysTo(), addDays(), addMonths(), addSecs() */
end_comment
begin_function
DECL|function|addYears
name|QDateTime
name|QDateTime
operator|::
name|addYears
parameter_list|(
name|int
name|nyears
parameter_list|)
specifier|const
block|{
name|QDateTime
name|dt
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|dt
operator|.
name|detach
argument_list|()
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|date
operator|=
name|d
operator|->
name|date
operator|.
name|addYears
argument_list|(
name|nyears
argument_list|)
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_function
DECL|function|addMSecs
name|QDateTime
name|QDateTimePrivate
operator|::
name|addMSecs
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|dt
parameter_list|,
name|qint64
name|msecs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dt
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|QDate
name|utcDate
decl_stmt|;
name|QTime
name|utcTime
decl_stmt|;
name|dt
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|utcDate
argument_list|,
name|utcTime
argument_list|)
expr_stmt|;
name|addMSecs
argument_list|(
name|utcDate
argument_list|,
name|utcTime
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
name|QDateTime
name|utc
argument_list|(
name|utcDate
argument_list|,
name|utcTime
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|timeSpec
argument_list|()
operator|==
name|Qt
operator|::
name|OffsetFromUTC
condition|)
return|return
name|utc
operator|.
name|toOffsetFromUtc
argument_list|(
name|dt
operator|.
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
return|;
else|else
return|return
name|utc
operator|.
name|toTimeSpec
argument_list|(
name|dt
operator|.
name|timeSpec
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!  Adds \a msecs to utcDate and \a utcTime as appropriate. It is assumed that  utcDate and utcTime are adjusted to UTC.   \since 4.5  \internal  */
end_comment
begin_function
DECL|function|addMSecs
name|void
name|QDateTimePrivate
operator|::
name|addMSecs
parameter_list|(
name|QDate
modifier|&
name|utcDate
parameter_list|,
name|QTime
modifier|&
name|utcTime
parameter_list|,
name|qint64
name|msecs
parameter_list|)
block|{
name|qint64
name|dd
init|=
name|utcDate
operator|.
name|toJulianDay
argument_list|()
decl_stmt|;
name|int
name|tt
init|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|msecsTo
argument_list|(
name|utcTime
argument_list|)
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|msecs
operator|<
literal|0
condition|)
block|{
name|msecs
operator|=
operator|-
name|msecs
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|msecs
operator|>=
name|int
argument_list|(
name|MSECS_PER_DAY
argument_list|)
condition|)
block|{
name|dd
operator|+=
name|sign
operator|*
operator|(
name|msecs
operator|/
name|MSECS_PER_DAY
operator|)
expr_stmt|;
name|msecs
operator|%=
name|MSECS_PER_DAY
expr_stmt|;
block|}
name|tt
operator|+=
name|sign
operator|*
name|msecs
expr_stmt|;
if|if
condition|(
name|tt
operator|<
literal|0
condition|)
block|{
name|tt
operator|=
name|MSECS_PER_DAY
operator|-
name|tt
operator|-
literal|1
expr_stmt|;
name|dd
operator|-=
name|tt
operator|/
name|MSECS_PER_DAY
expr_stmt|;
name|tt
operator|=
name|tt
operator|%
name|MSECS_PER_DAY
expr_stmt|;
name|tt
operator|=
name|MSECS_PER_DAY
operator|-
name|tt
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tt
operator|>=
name|int
argument_list|(
name|MSECS_PER_DAY
argument_list|)
condition|)
block|{
name|dd
operator|+=
name|tt
operator|/
name|MSECS_PER_DAY
expr_stmt|;
name|tt
operator|=
name|tt
operator|%
name|MSECS_PER_DAY
expr_stmt|;
block|}
name|utcDate
operator|=
name|QDate
operator|::
name|fromJulianDay
argument_list|(
name|dd
argument_list|)
expr_stmt|;
name|utcTime
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|addMSecs
argument_list|(
name|tt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a s seconds     later than the datetime of this object (or earlier if \a s is     negative).      If this datetime is invalid, an invalid datetime will be returned.      \sa addMSecs(), secsTo(), addDays(), addMonths(), addYears() */
end_comment
begin_function
DECL|function|addSecs
name|QDateTime
name|QDateTime
operator|::
name|addSecs
parameter_list|(
name|qint64
name|s
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|addMSecs
argument_list|(
operator|*
name|this
argument_list|,
name|s
operator|*
literal|1000
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a msecs miliseconds     later than the datetime of this object (or earlier if \a msecs is     negative).      If this datetime is invalid, an invalid datetime will be returned.      \sa addSecs(), msecsTo(), addDays(), addMonths(), addYears() */
end_comment
begin_function
DECL|function|addMSecs
name|QDateTime
name|QDateTime
operator|::
name|addMSecs
parameter_list|(
name|qint64
name|msecs
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|addMSecs
argument_list|(
operator|*
name|this
argument_list|,
name|msecs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days from this datetime to the \a other     datetime. The number of days is counted as the number of times     midnight is reached between this datetime to the \a other     datetime. This means that a 10 minute difference from 23:55 to     0:05 the next day counts as one day.      If the \a other datetime is earlier than this datetime,     the value returned is negative.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 15      \sa addDays(), secsTo(), msecsTo() */
end_comment
begin_function
DECL|function|daysTo
name|qint64
name|QDateTime
operator|::
name|daysTo
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|date
operator|.
name|daysTo
argument_list|(
name|other
operator|.
name|d
operator|->
name|date
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of seconds from this datetime to the \a other     datetime. If the \a other datetime is earlier than this datetime,     the value returned is negative.      Before performing the comparison, the two datetimes are converted     to Qt::UTC to ensure that the result is correct if one of the two     datetimes has daylight saving time (DST) and the other doesn't.      Returns 0 if either datetime is invalid.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 11      \sa addSecs(), daysTo(), QTime::secsTo() */
end_comment
begin_function
DECL|function|secsTo
name|qint64
name|QDateTime
operator|::
name|secsTo
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|other
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|QDate
name|date1
decl_stmt|,
name|date2
decl_stmt|;
name|QTime
name|time1
decl_stmt|,
name|time2
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|date1
argument_list|,
name|time1
argument_list|)
expr_stmt|;
name|other
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|date2
argument_list|,
name|time2
argument_list|)
expr_stmt|;
return|return
operator|(
name|date1
operator|.
name|daysTo
argument_list|(
name|date2
argument_list|)
operator|*
name|SECS_PER_DAY
operator|)
operator|+
name|time1
operator|.
name|secsTo
argument_list|(
name|time2
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of milliseconds from this datetime to the \a other     datetime. If the \a other datetime is earlier than this datetime,     the value returned is negative.      Before performing the comparison, the two datetimes are converted     to Qt::UTC to ensure that the result is correct if one of the two     datetimes has daylight saving time (DST) and the other doesn't.      Returns 0 if either datetime is invalid.      \sa addMSecs(), daysTo(), QTime::msecsTo() */
end_comment
begin_function
DECL|function|msecsTo
name|qint64
name|QDateTime
operator|::
name|msecsTo
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|other
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|QDate
name|selfDate
decl_stmt|;
name|QDate
name|otherDate
decl_stmt|;
name|QTime
name|selfTime
decl_stmt|;
name|QTime
name|otherTime
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|selfDate
argument_list|,
name|selfTime
argument_list|)
expr_stmt|;
name|other
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|otherDate
argument_list|,
name|otherTime
argument_list|)
expr_stmt|;
return|return
operator|(
cast|static_cast
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|selfDate
operator|.
name|daysTo
argument_list|(
name|otherDate
argument_list|)
argument_list|)
operator|*
cast|static_cast
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|MSECS_PER_DAY
argument_list|)
operator|)
operator|+
cast|static_cast
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|selfTime
operator|.
name|msecsTo
argument_list|(
name|otherTime
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDateTime QDateTime::toTimeSpec(Qt::TimeSpec spec) const      Returns a copy of this datetime converted to the given time     \a spec.      If \a spec is Qt::OffsetFromUTC then it is set to Qt::UTC.  To set to a     spec of Qt::OffsetFromUTC use toOffsetFromUtc().      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 16      \sa timeSpec(), toUTC(), toLocalTime() */
end_comment
begin_function
DECL|function|toTimeSpec
name|QDateTime
name|QDateTime
operator|::
name|toTimeSpec
parameter_list|(
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|spec
operator|==
name|Qt
operator|::
name|UTC
operator|||
name|spec
operator|==
name|Qt
operator|::
name|OffsetFromUTC
condition|)
block|{
name|QDate
name|date
decl_stmt|;
name|QTime
name|time
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|QDateTime
name|ret
decl_stmt|;
name|ret
operator|.
name|d
operator|->
name|spec
operator|=
name|d
operator|->
name|getLocal
argument_list|(
name|ret
operator|.
name|d
operator|->
name|date
argument_list|,
name|ret
operator|.
name|d
operator|->
name|time
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2      \fn QDateTime QDateTime::toOffsetFromUtc(int offsetSeconds) const      Returns a copy of this datetime converted to a spec of Qt::OffsetFromUTC     with the given \a offsetSeconds.      If the \a offsetSeconds equals 0 then a UTC datetime will be returned      \sa setOffsetFromUtc(), offsetFromUtc(), toTimeSpec() */
end_comment
begin_function
DECL|function|toOffsetFromUtc
name|QDateTime
name|QDateTime
operator|::
name|toOffsetFromUtc
parameter_list|(
name|int
name|offsetSeconds
parameter_list|)
specifier|const
block|{
name|QDate
name|date
decl_stmt|;
name|QTime
name|time
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|d
operator|->
name|addMSecs
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|offsetSeconds
operator|*
literal|1000
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|OffsetFromUTC
argument_list|,
name|offsetSeconds
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this datetime is equal to the \a other datetime;     otherwise returns false.      \sa operator!=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QDateTime
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|other
operator|.
name|d
operator|->
name|spec
operator|&&
name|d
operator|->
name|m_offsetFromUtc
operator|==
name|other
operator|.
name|d
operator|->
name|m_offsetFromUtc
condition|)
return|return
name|d
operator|->
name|time
operator|==
name|other
operator|.
name|d
operator|->
name|time
operator|&&
name|d
operator|->
name|date
operator|==
name|other
operator|.
name|d
operator|->
name|date
return|;
else|else
block|{
name|QDate
name|date1
decl_stmt|,
name|date2
decl_stmt|;
name|QTime
name|time1
decl_stmt|,
name|time2
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|date1
argument_list|,
name|time1
argument_list|)
expr_stmt|;
name|other
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|date2
argument_list|,
name|time2
argument_list|)
expr_stmt|;
return|return
name|time1
operator|==
name|time2
operator|&&
name|date1
operator|==
name|date2
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn bool QDateTime::operator!=(const QDateTime&other) const      Returns true if this datetime is different from the \a other     datetime; otherwise returns false.      Two datetimes are different if either the date, the time, or the     time zone components are different.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns true if this datetime is earlier than the \a other     datetime; otherwise returns false. */
end_comment
begin_function
DECL|function|operator <
name|bool
name|QDateTime
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|other
operator|.
name|d
operator|->
name|spec
operator|&&
name|d
operator|->
name|spec
operator|!=
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|date
operator|!=
name|other
operator|.
name|d
operator|->
name|date
condition|)
return|return
name|d
operator|->
name|date
operator|<
name|other
operator|.
name|d
operator|->
name|date
return|;
return|return
name|d
operator|->
name|time
operator|<
name|other
operator|.
name|d
operator|->
name|time
return|;
block|}
else|else
block|{
name|QDate
name|date1
decl_stmt|,
name|date2
decl_stmt|;
name|QTime
name|time1
decl_stmt|,
name|time2
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|date1
argument_list|,
name|time1
argument_list|)
expr_stmt|;
name|other
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|date2
argument_list|,
name|time2
argument_list|)
expr_stmt|;
if|if
condition|(
name|date1
operator|!=
name|date2
condition|)
return|return
name|date1
operator|<
name|date2
return|;
return|return
name|time1
operator|<
name|time2
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn bool QDateTime::operator<=(const QDateTime&other) const      Returns true if this datetime is earlier than or equal to the     \a other datetime; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDateTime::operator>(const QDateTime&other) const      Returns true if this datetime is later than the \a other datetime;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDateTime::operator>=(const QDateTime&other) const      Returns true if this datetime is later than or equal to the     \a other datetime; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::currentDateTime()     Returns the current datetime, as reported by the system clock, in     the local time zone.      \sa currentDateTimeUtc(), QDate::currentDate(), QTime::currentTime(), toTimeSpec() */
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::currentDateTimeUtc()     \since 4.7     Returns the current datetime, as reported by the system clock, in     UTC.      \sa currentDateTime(), QDate::currentDate(), QTime::currentTime(), toTimeSpec() */
end_comment
begin_comment
comment|/*!     \fn qint64 QDateTime::currentMSecsSinceEpoch()     \since 4.7      Returns the number of milliseconds since 1970-01-01T00:00:00 Universal     Coordinated Time. This number is like the POSIX time_t variable, but     expressed in milliseconds instead.      \sa currentDateTime(), currentDateTimeUtc(), toTime_t(), toTimeSpec() */
end_comment
begin_function
DECL|function|msecsFromDecomposed
specifier|static
specifier|inline
name|uint
name|msecsFromDecomposed
parameter_list|(
name|int
name|hour
parameter_list|,
name|int
name|minute
parameter_list|,
name|int
name|sec
parameter_list|,
name|int
name|msec
init|=
literal|0
parameter_list|)
block|{
return|return
name|MSECS_PER_HOUR
operator|*
name|hour
operator|+
name|MSECS_PER_MIN
operator|*
name|minute
operator|+
literal|1000
operator|*
name|sec
operator|+
name|msec
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_function
DECL|function|currentDate
name|QDate
name|QDate
operator|::
name|currentDate
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetLocalTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|currentTime
name|QTime
name|QTime
operator|::
name|currentTime
parameter_list|()
block|{
name|QTime
name|ct
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetLocalTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|ct
operator|.
name|setHMS
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|ct
operator|.
name|startTick
operator|=
name|GetTickCount
argument_list|()
operator|%
name|MSECS_PER_DAY
expr_stmt|;
endif|#
directive|endif
return|return
name|ct
return|;
block|}
end_function
begin_function
DECL|function|currentDateTime
name|QDateTime
name|QDateTime
operator|::
name|currentDateTime
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetLocalTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
expr_stmt|;
name|t
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|d
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|currentDateTimeUtc
name|QDateTime
name|QDateTime
operator|::
name|currentDateTimeUtc
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetSystemTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
expr_stmt|;
name|t
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|d
argument_list|,
name|t
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
return|;
block|}
end_function
begin_function
name|qint64
name|QDateTime
operator|::
name|currentMSecsSinceEpoch
parameter_list|()
name|Q_DECL_NOTHROW
block|{
name|QDate
name|d
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetSystemTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
return|return
name|msecsFromDecomposed
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
operator|+
name|qint64
argument_list|(
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
operator|-
name|julianDayFromDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|Q_INT64_C
argument_list|(
literal|86400000
argument_list|)
return|;
block|}
end_function
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
end_elif
begin_function
DECL|function|currentDate
name|QDate
name|QDate
operator|::
name|currentDate
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
comment|// posix compliant system
name|time_t
name|ltime
decl_stmt|;
name|time
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
name|struct
name|tm
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|tzset
argument_list|()
expr_stmt|;
name|struct
name|tm
name|res
decl_stmt|;
name|t
operator|=
name|localtime_r
argument_list|(
operator|&
name|ltime
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_THREAD&& _POSIX_THREAD_SAFE_FUNCTIONS
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|currentTime
name|QTime
name|QTime
operator|::
name|currentTime
parameter_list|()
block|{
name|QTime
name|ct
decl_stmt|;
comment|// posix compliant system
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|time_t
name|ltime
init|=
name|tv
operator|.
name|tv_sec
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|tzset
argument_list|()
expr_stmt|;
name|struct
name|tm
name|res
decl_stmt|;
name|t
operator|=
name|localtime_r
argument_list|(
operator|&
name|ltime
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_CHECK_PTR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ct
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|,
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
return|return
name|ct
return|;
block|}
end_function
begin_function
DECL|function|currentDateTime
name|QDateTime
name|QDateTime
operator|::
name|currentDateTime
parameter_list|()
block|{
comment|// posix compliant system
comment|// we have milliseconds
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|time_t
name|ltime
init|=
name|tv
operator|.
name|tv_sec
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|tzset
argument_list|()
expr_stmt|;
name|struct
name|tm
name|res
decl_stmt|;
name|t
operator|=
name|localtime_r
argument_list|(
operator|&
name|ltime
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QDateTime
name|dt
decl_stmt|;
name|dt
operator|.
name|d
operator|->
name|time
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|,
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|date
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|spec
operator|=
name|t
operator|->
name|tm_isdst
operator|>
literal|0
condition|?
name|QDateTimePrivate
operator|::
name|LocalDST
else|:
name|t
operator|->
name|tm_isdst
operator|==
literal|0
condition|?
name|QDateTimePrivate
operator|::
name|LocalStandard
else|:
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_function
DECL|function|currentDateTimeUtc
name|QDateTime
name|QDateTime
operator|::
name|currentDateTimeUtc
parameter_list|()
block|{
comment|// posix compliant system
comment|// we have milliseconds
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|time_t
name|ltime
init|=
name|tv
operator|.
name|tv_sec
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|struct
name|tm
name|res
decl_stmt|;
name|t
operator|=
name|gmtime_r
argument_list|(
operator|&
name|ltime
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QDateTime
name|dt
decl_stmt|;
name|dt
operator|.
name|d
operator|->
name|time
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|,
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|date
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_function
name|qint64
name|QDateTime
operator|::
name|currentMSecsSinceEpoch
parameter_list|()
name|Q_DECL_NOTHROW
block|{
comment|// posix compliant system
comment|// we have milliseconds
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|qint64
argument_list|(
name|tv
operator|.
name|tv_sec
argument_list|)
operator|*
name|Q_INT64_C
argument_list|(
literal|1000
argument_list|)
operator|+
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
literal|"What system is this?"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \since 4.2    Returns a datetime whose date and time are the number of \a seconds   that have passed since 1970-01-01T00:00:00, Coordinated Universal   Time (Qt::UTC) and converted to Qt::LocalTime.  On systems that do not   support time zones, the time will be set as if local time were Qt::UTC.    \sa toTime_t(), setTime_t() */
end_comment
begin_function
DECL|function|fromTime_t
name|QDateTime
name|QDateTime
operator|::
name|fromTime_t
parameter_list|(
name|uint
name|seconds
parameter_list|)
block|{
return|return
name|fromMSecsSinceEpoch
argument_list|(
operator|(
name|qint64
operator|)
name|seconds
operator|*
literal|1000
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 5.2    Returns a datetime whose date and time are the number of \a seconds   that have passed since 1970-01-01T00:00:00, Coordinated Universal   Time (Qt::UTC) and converted to the given \a spec.    If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.    \sa toTime_t(), setTime_t() */
end_comment
begin_function
DECL|function|fromTime_t
name|QDateTime
name|QDateTime
operator|::
name|fromTime_t
parameter_list|(
name|uint
name|seconds
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|,
name|int
name|offsetSeconds
parameter_list|)
block|{
return|return
name|fromMSecsSinceEpoch
argument_list|(
operator|(
name|qint64
operator|)
name|seconds
operator|*
literal|1000
argument_list|,
name|spec
argument_list|,
name|offsetSeconds
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.7    Returns a datetime whose date and time are the number of milliseconds, \a msecs,   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal   Time (Qt::UTC), and converted to Qt::LocalTime.  On systems that do not   support time zones, the time will be set as if local time were Qt::UTC.    Note that there are possible values for \a msecs that lie outside the valid   range of QDateTime, both negative and positive. The behavior of this   function is undefined for those values.    \sa toTime_t(), setTime_t() */
end_comment
begin_function
DECL|function|fromMSecsSinceEpoch
name|QDateTime
name|QDateTime
operator|::
name|fromMSecsSinceEpoch
parameter_list|(
name|qint64
name|msecs
parameter_list|)
block|{
return|return
name|fromMSecsSinceEpoch
argument_list|(
name|msecs
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 5.2    Returns a datetime whose date and time are the number of milliseconds \a msecs   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal   Time (Qt::UTC) and converted to the given \a spec.    Note that there are possible values for \a msecs that lie outside the valid   range of QDateTime, both negative and positive. The behavior of this   function is undefined for those values.    If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.    \sa fromTime_t() */
end_comment
begin_function
DECL|function|fromMSecsSinceEpoch
name|QDateTime
name|QDateTime
operator|::
name|fromMSecsSinceEpoch
parameter_list|(
name|qint64
name|msecs
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|,
name|int
name|offsetSeconds
parameter_list|)
block|{
name|QDate
name|newDate
init|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|QTime
name|newTime
init|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QDateTimePrivate
operator|::
name|addMSecs
argument_list|(
name|newDate
argument_list|,
name|newTime
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|spec
condition|)
block|{
case|case
name|Qt
operator|::
name|UTC
case|:
return|return
name|QDateTime
argument_list|(
name|newDate
argument_list|,
name|newTime
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
return|;
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
name|utcToOffset
argument_list|(
operator|&
name|newDate
argument_list|,
operator|&
name|newTime
argument_list|,
name|offsetSeconds
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|newDate
argument_list|,
name|newTime
argument_list|,
name|Qt
operator|::
name|OffsetFromUTC
argument_list|,
name|offsetSeconds
argument_list|)
return|;
default|default:
name|utcToLocal
argument_list|(
name|newDate
argument_list|,
name|newTime
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|newDate
argument_list|,
name|newTime
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|)
return|;
block|}
block|}
end_function
begin_if
if|#
directive|if
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|2
argument_list|)
end_if
begin_comment
comment|/*!     \since 4.4     \internal     \obsolete      This method was added in 4.4 but never documented as public. It was replaced     in 5.2 with public method setOffsetFromUtc() for consistency with QTimeZone.      This method should never be made public.      \sa setOffsetFromUtc()  */
end_comment
begin_function
DECL|function|setUtcOffset
name|void
name|QDateTime
operator|::
name|setUtcOffset
parameter_list|(
name|int
name|seconds
parameter_list|)
block|{
name|setOffsetFromUtc
argument_list|(
name|seconds
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     \internal     \obsolete      This method was added in 4.4 but never documented as public. It was replaced     in 5.1 with public method offsetFromUTC() for consistency with QTimeZone.      This method should never be made public.      \sa offsetFromUTC() */
end_comment
begin_function
DECL|function|utcOffset
name|int
name|QDateTime
operator|::
name|utcOffset
parameter_list|()
specifier|const
block|{
return|return
name|offsetFromUtc
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_DEPRECATED_SINCE
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function
DECL|function|fromShortMonthName
specifier|static
name|int
name|fromShortMonthName
parameter_list|(
specifier|const
name|QString
modifier|&
name|monthName
parameter_list|)
block|{
comment|// Assume that English monthnames are the default
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QLatin1String
argument_list|(
name|qt_shortMonthNames
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
operator|+
literal|1
return|;
block|}
comment|// If English names can't be found, search the localized ones
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QDate
operator|::
name|shortMonthName
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDateTime QDateTime::fromString(const QString&string, Qt::DateFormat format)      Returns the QDateTime represented by the \a string, using the     \a format given, or an invalid datetime if this is not possible.      Note for Qt::TextDate: It is recommended that you use the     English short month names (e.g. "Jan"). Although localized month     names can also be used, they depend on the user's locale settings. */
end_comment
begin_function
DECL|function|fromString
name|QDateTime
name|QDateTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
block|{
if|if
condition|(
name|string
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toDateTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toDateTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toDateTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toDateTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
block|{
name|QDate
name|date
decl_stmt|;
name|QTime
name|time
decl_stmt|;
name|int
name|utcOffset
init|=
literal|0
decl_stmt|;
name|rfcDateImpl
argument_list|(
name|string
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|,
operator|&
name|utcOffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|date
operator|.
name|isValid
argument_list|()
operator|||
operator|!
name|time
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|QDateTime
name|dateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
name|dateTime
operator|.
name|setOffsetFromUtc
argument_list|(
name|utcOffset
argument_list|)
expr_stmt|;
return|return
name|dateTime
return|;
block|}
case|case
name|Qt
operator|::
name|ISODate
case|:
block|{
specifier|const
name|int
name|size
init|=
name|string
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|10
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|QString
name|isoString
init|=
name|string
decl_stmt|;
name|Qt
operator|::
name|TimeSpec
name|spec
init|=
name|Qt
operator|::
name|LocalTime
decl_stmt|;
name|QDate
name|date
init|=
name|QDate
operator|::
name|fromString
argument_list|(
name|isoString
operator|.
name|left
argument_list|(
literal|10
argument_list|)
argument_list|,
name|Qt
operator|::
name|ISODate
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|date
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
if|if
condition|(
name|size
operator|==
literal|10
condition|)
return|return
name|QDateTime
argument_list|(
name|date
argument_list|)
return|;
name|isoString
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|// Check end of string for Time Zone definition, either Z for UTC or [+-]HH:MM for Offset
if|if
condition|(
name|isoString
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'Z'
argument_list|)
argument_list|)
condition|)
block|{
name|spec
operator|=
name|Qt
operator|::
name|UTC
expr_stmt|;
name|isoString
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|signIndex
init|=
name|isoString
operator|.
name|indexOf
argument_list|(
name|QRegExp
argument_list|(
name|QStringLiteral
argument_list|(
literal|"[+-]"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|signIndex
operator|>=
literal|0
condition|)
block|{
name|bool
name|ok
decl_stmt|;
name|offset
operator|=
name|fromOffsetString
argument_list|(
name|isoString
operator|.
name|mid
argument_list|(
name|signIndex
argument_list|)
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|isoString
operator|=
name|isoString
operator|.
name|left
argument_list|(
name|signIndex
argument_list|)
expr_stmt|;
name|spec
operator|=
name|Qt
operator|::
name|OffsetFromUTC
expr_stmt|;
block|}
block|}
comment|// Might be end of day (24:00, including variants), which QTime considers invalid.
comment|// ISO 8601 (section 4.2.3) says that 24:00 is equivalent to 00:00 the next day.
name|bool
name|isMidnight24
init|=
literal|false
decl_stmt|;
name|QTime
name|time
init|=
name|fromIsoTimeString
argument_list|(
name|isoString
argument_list|,
name|Qt
operator|::
name|ISODate
argument_list|,
operator|&
name|isMidnight24
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|time
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
if|if
condition|(
name|isMidnight24
condition|)
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|spec
argument_list|,
name|offset
argument_list|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_TEXTDATE
argument_list|)
case|case
name|Qt
operator|::
name|TextDate
case|:
block|{
name|QStringList
name|parts
init|=
name|string
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|parts
operator|.
name|count
argument_list|()
operator|<
literal|5
operator|)
operator|||
operator|(
name|parts
operator|.
name|count
argument_list|()
operator|>
literal|6
operator|)
condition|)
return|return
name|QDateTime
argument_list|()
return|;
comment|// Accept "Sun Dec 1 13:02:00 1974" and "Sun 1. Dec 13:02:00 1974"
name|int
name|month
init|=
literal|0
decl_stmt|;
name|int
name|day
init|=
literal|0
decl_stmt|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
comment|// First try month then day
name|month
operator|=
name|fromShortMonthName
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|month
condition|)
name|day
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
comment|// If failed try day then month
if|if
condition|(
operator|!
name|month
operator|||
operator|!
name|day
condition|)
block|{
name|month
operator|=
name|fromShortMonthName
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|month
condition|)
block|{
name|QString
name|dayStr
init|=
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|dayStr
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
block|{
name|dayStr
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|day
operator|=
name|dayStr
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// If both failed, give up
if|if
condition|(
operator|!
name|month
operator|||
operator|!
name|day
condition|)
return|return
name|QDateTime
argument_list|()
return|;
comment|// Year can be before or after time, "Sun Dec 1 1974 13:02:00" or "Sun Dec 1 13:02:00 1974"
comment|// Guess which by looking for ':' in the time
name|int
name|year
init|=
literal|0
decl_stmt|;
name|int
name|yearPart
init|=
literal|0
decl_stmt|;
name|int
name|timePart
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
block|{
name|yearPart
operator|=
literal|4
expr_stmt|;
name|timePart
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parts
operator|.
name|at
argument_list|(
literal|4
argument_list|)
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
block|{
name|yearPart
operator|=
literal|3
expr_stmt|;
name|timePart
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|year
operator|=
name|parts
operator|.
name|at
argument_list|(
name|yearPart
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|QDate
name|date
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|date
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|QStringList
name|timeParts
init|=
name|parts
operator|.
name|at
argument_list|(
name|timePart
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeParts
operator|.
name|count
argument_list|()
operator|<
literal|2
operator|||
name|timeParts
operator|.
name|count
argument_list|()
operator|>
literal|3
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|int
name|hour
init|=
name|timeParts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|int
name|minute
init|=
name|timeParts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|int
name|second
init|=
literal|0
decl_stmt|;
name|int
name|millisecond
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|timeParts
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|QStringList
name|secondParts
init|=
name|timeParts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|secondParts
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|second
operator|=
name|secondParts
operator|.
name|first
argument_list|()
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
if|if
condition|(
name|secondParts
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|millisecond
operator|=
name|secondParts
operator|.
name|last
argument_list|()
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
block|}
block|}
name|QTime
name|time
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|millisecond
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|time
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|==
literal|5
condition|)
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|)
return|;
name|QString
name|tz
init|=
name|parts
operator|.
name|at
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tz
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"GMT"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|tz
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tz
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|offset
init|=
name|fromOffsetString
argument_list|(
name|tz
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|OffsetFromUTC
argument_list|,
name|offset
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
comment|//QT_NO_TEXTDATE
block|}
return|return
name|QDateTime
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDateTime::fromString(const QString&string, const QString&format)      Returns the QDateTime represented by the \a string, using the \a     format given, or an invalid datetime if the string cannot be parsed.      These expressions may be used for the date part of the format string:      \table     \header \li Expression \li Output     \row \li d \li the day as number without a leading zero (1 to 31)     \row \li dd \li the day as number with a leading zero (01 to 31)     \row \li ddd             \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').             Uses QDate::shortDayName().     \row \li dddd             \li the long localized day name (e.g. 'Monday' to 'Sunday').             Uses QDate::longDayName().     \row \li M \li the month as number without a leading zero (1-12)     \row \li MM \li the month as number with a leading zero (01-12)     \row \li MMM             \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').             Uses QDate::shortMonthName().     \row \li MMMM             \li the long localized month name (e.g. 'January' to 'December').             Uses QDate::longMonthName().     \row \li yy \li the year as two digit number (00-99)     \row \li yyyy \li the year as four digit number     \endtable      \note Unlike the other version of this function, day and month names must     be given in the user's local language. It is only possible to use the English     names if the user's language is English.      These expressions may be used for the time part of the format string:      \table     \header \li Expression \li Output     \row \li h             \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh             \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li H             \li the hour without a leading zero (0 to 23, even with AM/PM display)     \row \li HH             \li the hour with a leading zero (00 to 23, even with AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP or A          \li interpret as an AM/PM time. \e AP must be either "AM" or "PM".     \row \li ap or a          \li Interpret as an AM/PM time. \e ap must be either "am" or "pm".     \endtable      All other input characters will be treated as text. Any sequence     of characters that are enclosed in single quotes will also be     treated as text and not be used as an expression.      \snippet code/src_corelib_tools_qdatetime.cpp 12      If the format is not satisfied, an invalid QDateTime is returned.     The expressions that don't have leading zeroes (d, M, h, m, s, z) will be     greedy. This means that they will use two digits even if this will     put them outside the range and/or leave too few digits for other     sections.      \snippet code/src_corelib_tools_qdatetime.cpp 13      This could have meant 1 January 00:30.00 but the M will grab     two digits.      Incorrectly specified fields of the \a string will cause an invalid     QDateTime to be returned. For example, consider the following code,     where the two digit year 12 is read as 1912 (see the table below for all     field defaults); the resulting datetime is invalid because 23 April 1912     was a Tuesday, not a Monday:      \snippet code/src_corelib_tools_qdatetime.cpp 20      The correct code is:      \snippet code/src_corelib_tools_qdatetime.cpp 21      For any field that is not represented in the format, the following     defaults are used:      \table     \header \li Field  \li Default value     \row    \li Year   \li 1900     \row    \li Month  \li 1 (January)     \row    \li Day    \li 1     \row    \li Hour   \li 0     \row    \li Minute \li 0     \row    \li Second \li 0     \endtable      For example:      \snippet code/src_corelib_tools_qdatetime.cpp 14      \sa QDate::fromString(), QTime::fromString(), QDate::toString(),     QDateTime::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|fromString
name|QDateTime
name|QDateTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QTime
name|time
decl_stmt|;
name|QDate
name|date
decl_stmt|;
name|QDateTimeParser
name|dt
argument_list|(
name|QVariant
operator|::
name|DateTime
argument_list|,
name|QDateTimeParser
operator|::
name|FromString
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|parseFormat
argument_list|(
name|format
argument_list|)
operator|&&
name|dt
operator|.
name|fromString
argument_list|(
name|string
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|)
condition|)
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|QDateTime
argument_list|(
name|QDate
argument_list|()
argument_list|,
name|QTime
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::toLocalTime() const      Returns a datetime containing the date and time information in     this datetime, but specified using the Qt::LocalTime definition.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 17      \sa toTimeSpec() */
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::toUTC() const      Returns a datetime containing the date and time information in     this datetime, but specified using the Qt::UTC definition.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 18      \sa toTimeSpec() */
end_comment
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|detach
name|void
name|QDateTime
operator|::
name|detach
parameter_list|()
block|{
name|d
operator|.
name|detach
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   Date/time stream functions  *****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \relates QDate      Writes the \a date to stream \a out.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
block|{
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_5_0
condition|)
return|return
name|out
operator|<<
name|quint32
argument_list|(
name|date
operator|.
name|jd
argument_list|)
return|;
else|else
return|return
name|out
operator|<<
name|qint64
argument_list|(
name|date
operator|.
name|jd
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QDate      Reads a date from stream \a in into the \a date.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QDate
modifier|&
name|date
parameter_list|)
block|{
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_5_0
condition|)
block|{
name|quint32
name|jd
decl_stmt|;
name|in
operator|>>
name|jd
expr_stmt|;
comment|// Older versions consider 0 an invalid jd.
name|date
operator|.
name|jd
operator|=
operator|(
name|jd
operator|!=
literal|0
condition|?
name|jd
else|:
name|QDate
operator|::
name|nullJd
argument_list|()
operator|)
expr_stmt|;
block|}
else|else
block|{
name|qint64
name|jd
decl_stmt|;
name|in
operator|>>
name|jd
expr_stmt|;
name|date
operator|.
name|jd
operator|=
name|jd
expr_stmt|;
block|}
return|return
name|in
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTime      Writes \a time to stream \a out.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
return|return
name|out
operator|<<
name|quint32
argument_list|(
name|time
operator|.
name|mds
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTime      Reads a time from stream \a in into the given \a time.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|quint32
name|ds
decl_stmt|;
name|in
operator|>>
name|ds
expr_stmt|;
name|time
operator|.
name|mds
operator|=
name|int
argument_list|(
name|ds
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QDateTime      Writes \a dateTime to the \a out stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|dateTime
parameter_list|)
block|{
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|==
name|QDataStream
operator|::
name|Qt_5_0
condition|)
block|{
if|if
condition|(
name|dateTime
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// This approach is wrong and should not be used again; it breaks
comment|// the guarantee that a deserialised local datetime is the same time
comment|// of day, regardless of which timezone it was serialised in.
name|QDateTime
name|asUTC
init|=
name|dateTime
operator|.
name|toUTC
argument_list|()
decl_stmt|;
name|out
operator|<<
name|asUTC
operator|.
name|d
operator|->
name|date
operator|<<
name|asUTC
operator|.
name|d
operator|->
name|time
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
name|dateTime
operator|.
name|d
operator|->
name|date
operator|<<
name|dateTime
operator|.
name|d
operator|->
name|time
expr_stmt|;
block|}
name|out
operator|<<
operator|(
name|qint8
operator|)
name|dateTime
operator|.
name|timeSpec
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
name|dateTime
operator|.
name|d
operator|->
name|date
operator|<<
name|dateTime
operator|.
name|d
operator|->
name|time
expr_stmt|;
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_0
condition|)
name|out
operator|<<
operator|(
name|qint8
operator|)
name|dateTime
operator|.
name|d
operator|->
name|spec
expr_stmt|;
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_5_2
operator|&&
name|dateTime
operator|.
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
block|{
name|out
operator|<<
name|qint32
argument_list|(
name|dateTime
operator|.
name|offsetFromUtc
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QDateTime      Reads a datetime from the stream \a in into \a dateTime.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QDateTime
modifier|&
name|dateTime
parameter_list|)
block|{
name|dateTime
operator|.
name|detach
argument_list|()
expr_stmt|;
name|in
operator|>>
name|dateTime
operator|.
name|d
operator|->
name|date
operator|>>
name|dateTime
operator|.
name|d
operator|->
name|time
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|==
name|QDataStream
operator|::
name|Qt_5_0
condition|)
block|{
name|qint8
name|ts
init|=
literal|0
decl_stmt|;
name|in
operator|>>
name|ts
expr_stmt|;
if|if
condition|(
name|dateTime
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// We incorrectly stored the datetime as UTC in Qt_5_0.
name|dateTime
operator|.
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
name|dateTime
operator|=
name|dateTime
operator|.
name|toTimeSpec
argument_list|(
cast|static_cast
argument_list|<
name|Qt
operator|::
name|TimeSpec
argument_list|>
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|qint8
name|ts
init|=
operator|(
name|qint8
operator|)
name|QDateTimePrivate
operator|::
name|LocalUnknown
decl_stmt|;
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_0
condition|)
name|in
operator|>>
name|ts
expr_stmt|;
name|qint32
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_5_2
operator|&&
name|ts
operator|==
name|qint8
argument_list|(
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
argument_list|)
condition|)
name|in
operator|>>
name|offset
expr_stmt|;
name|dateTime
operator|.
name|d
operator|->
name|spec
operator|=
operator|(
name|QDateTimePrivate
operator|::
name|Spec
operator|)
name|ts
expr_stmt|;
name|dateTime
operator|.
name|d
operator|->
name|m_offsetFromUtc
operator|=
name|offset
expr_stmt|;
block|}
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*****************************************************************************   Some static function used by QDate, QTime and QDateTime *****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function
DECL|function|rfcDateImpl
specifier|static
name|void
name|rfcDateImpl
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|QDate
modifier|*
name|dd
parameter_list|,
name|QTime
modifier|*
name|dt
parameter_list|,
name|int
modifier|*
name|utcOffset
parameter_list|)
block|{
name|int
name|day
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|month
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|year
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hour
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|min
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|sec
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hourOffset
init|=
literal|0
decl_stmt|;
name|int
name|minOffset
init|=
literal|0
decl_stmt|;
name|bool
name|positiveOffset
init|=
literal|false
decl_stmt|;
comment|// Matches "Wdy, DD Mon YYYY HH:MM:SS hhmm" (Wdy, being optional)
name|QRegExp
name|rex
argument_list|(
name|QStringLiteral
argument_list|(
literal|"^(?:[A-Z][a-z]+,)?[ \\t]*(\\d{1,2})[ \\t]+([A-Z][a-z]+)[ \\t]+(\\d\\d\\d\\d)(?:[ \\t]+(\\d\\d):(\\d\\d)(?::(\\d\\d))?)?[ \\t]*(?:([+-])(\\d\\d)(\\d\\d))?"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|indexOf
argument_list|(
name|rex
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dd
condition|)
block|{
name|day
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|month
operator|=
name|qt_monthNumberFromShortName
argument_list|(
name|rex
operator|.
name|cap
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|year
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|3
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
operator|!
name|rex
operator|.
name|cap
argument_list|(
literal|4
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|hour
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|4
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|min
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|5
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|sec
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|6
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
name|positiveOffset
operator|=
operator|(
name|rex
operator|.
name|cap
argument_list|(
literal|7
argument_list|)
operator|==
name|QStringLiteral
argument_list|(
literal|"+"
argument_list|)
operator|)
expr_stmt|;
name|hourOffset
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|8
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|minOffset
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|9
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|utcOffset
condition|)
operator|*
name|utcOffset
operator|=
operator|(
operator|(
name|hourOffset
operator|*
literal|60
operator|+
name|minOffset
operator|)
operator|*
operator|(
name|positiveOffset
condition|?
literal|60
else|:
operator|-
literal|60
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Matches "Wdy Mon DD HH:MM:SS YYYY"
name|QRegExp
name|rex
argument_list|(
name|QStringLiteral
argument_list|(
literal|"^[A-Z][a-z]+[ \\t]+([A-Z][a-z]+)[ \\t]+(\\d\\d)(?:[ \\t]+(\\d\\d):(\\d\\d):(\\d\\d))?[ \\t]+(\\d\\d\\d\\d)[ \\t]*(?:([+-])(\\d\\d)(\\d\\d))?"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|indexOf
argument_list|(
name|rex
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dd
condition|)
block|{
name|month
operator|=
name|qt_monthNumberFromShortName
argument_list|(
name|rex
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|day
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|year
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|6
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
operator|!
name|rex
operator|.
name|cap
argument_list|(
literal|3
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|hour
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|3
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|min
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|4
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|sec
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|5
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
name|positiveOffset
operator|=
operator|(
name|rex
operator|.
name|cap
argument_list|(
literal|7
argument_list|)
operator|==
name|QStringLiteral
argument_list|(
literal|"+"
argument_list|)
operator|)
expr_stmt|;
name|hourOffset
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|8
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|minOffset
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|9
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|utcOffset
condition|)
operator|*
name|utcOffset
operator|=
operator|(
operator|(
name|hourOffset
operator|*
literal|60
operator|+
name|minOffset
operator|)
operator|*
operator|(
name|positiveOffset
condition|?
literal|60
else|:
operator|-
literal|60
operator|)
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dd
condition|)
operator|*
name|dd
operator|=
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt
condition|)
operator|*
name|dt
operator|=
name|QTime
argument_list|(
name|hour
argument_list|,
name|min
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_decl_stmt
DECL|variable|LowerYear
specifier|static
specifier|const
name|int
name|LowerYear
init|=
literal|1980
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|variable|LowerYear
specifier|static
specifier|const
name|int
name|LowerYear
init|=
literal|1970
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|UpperYear
specifier|static
specifier|const
name|int
name|UpperYear
init|=
literal|2037
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|adjustDate
specifier|static
name|QDate
name|adjustDate
parameter_list|(
name|QDate
name|date
parameter_list|)
block|{
name|QDate
name|lowerLimit
argument_list|(
name|LowerYear
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|QDate
name|upperLimit
argument_list|(
name|UpperYear
argument_list|,
literal|12
argument_list|,
literal|30
argument_list|)
decl_stmt|;
if|if
condition|(
name|date
operator|>
name|lowerLimit
operator|&&
name|date
operator|<
name|upperLimit
condition|)
return|return
name|date
return|;
name|int
name|month
init|=
name|date
operator|.
name|month
argument_list|()
decl_stmt|;
name|int
name|day
init|=
name|date
operator|.
name|day
argument_list|()
decl_stmt|;
comment|// neither 1970 nor 2037 are leap years, so make sure date isn't Feb 29
if|if
condition|(
name|month
operator|==
literal|2
operator|&&
name|day
operator|==
literal|29
condition|)
operator|--
name|day
expr_stmt|;
if|if
condition|(
name|date
operator|<
name|lowerLimit
condition|)
name|date
operator|.
name|setDate
argument_list|(
name|LowerYear
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
else|else
name|date
operator|.
name|setDate
argument_list|(
name|UpperYear
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
return|return
name|date
return|;
block|}
end_function
begin_comment
comment|// Convert passed in UTC datetime into LocalTime and return spec
end_comment
begin_function
DECL|function|utcToLocal
specifier|static
name|QDateTimePrivate
operator|::
name|Spec
name|utcToLocal
parameter_list|(
name|QDate
modifier|&
name|date
parameter_list|,
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|QDate
name|fakeDate
init|=
name|adjustDate
argument_list|(
name|date
argument_list|)
decl_stmt|;
comment|// won't overflow because of fakeDate
name|time_t
name|secsSince1Jan1970UTC
init|=
name|toMSecsSinceEpoch_helper
argument_list|(
name|fakeDate
operator|.
name|toJulianDay
argument_list|()
argument_list|,
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|msecsTo
argument_list|(
name|time
argument_list|)
argument_list|)
operator|/
literal|1000
decl_stmt|;
name|tm
modifier|*
name|brokenDown
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|tm
name|res
decl_stmt|;
name|FILETIME
name|utcTime
init|=
name|time_tToFt
argument_list|(
name|secsSince1Jan1970UTC
argument_list|)
decl_stmt|;
name|FILETIME
name|resultTime
decl_stmt|;
name|FileTimeToLocalFileTime
argument_list|(
operator|&
name|utcTime
argument_list|,
operator|&
name|resultTime
argument_list|)
expr_stmt|;
name|SYSTEMTIME
name|sysTime
decl_stmt|;
name|FileTimeToSystemTime
argument_list|(
operator|&
name|resultTime
argument_list|,
operator|&
name|sysTime
argument_list|)
expr_stmt|;
name|res
operator|.
name|tm_sec
operator|=
name|sysTime
operator|.
name|wSecond
expr_stmt|;
name|res
operator|.
name|tm_min
operator|=
name|sysTime
operator|.
name|wMinute
expr_stmt|;
name|res
operator|.
name|tm_hour
operator|=
name|sysTime
operator|.
name|wHour
expr_stmt|;
name|res
operator|.
name|tm_mday
operator|=
name|sysTime
operator|.
name|wDay
expr_stmt|;
name|res
operator|.
name|tm_mon
operator|=
name|sysTime
operator|.
name|wMonth
operator|-
literal|1
expr_stmt|;
name|res
operator|.
name|tm_year
operator|=
name|sysTime
operator|.
name|wYear
operator|-
literal|1900
expr_stmt|;
name|brokenDown
operator|=
operator|&
name|res
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|tzset
argument_list|()
expr_stmt|;
name|tm
name|res
decl_stmt|;
name|brokenDown
operator|=
name|localtime_r
argument_list|(
operator|&
name|secsSince1Jan1970UTC
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
name|tm
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|_localtime64_s
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|secsSince1Jan1970UTC
argument_list|)
condition|)
name|brokenDown
operator|=
operator|&
name|res
expr_stmt|;
else|#
directive|else
name|brokenDown
operator|=
name|localtime
argument_list|(
operator|&
name|secsSince1Jan1970UTC
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|brokenDown
condition|)
block|{
name|date
operator|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|time
operator|=
name|QTime
argument_list|()
expr_stmt|;
return|return
name|QDateTimePrivate
operator|::
name|LocalUnknown
return|;
block|}
else|else
block|{
name|qint64
name|deltaDays
init|=
name|fakeDate
operator|.
name|daysTo
argument_list|(
name|date
argument_list|)
decl_stmt|;
name|date
operator|=
name|QDate
argument_list|(
name|brokenDown
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|brokenDown
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|brokenDown
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|time
operator|=
name|QTime
argument_list|(
name|brokenDown
operator|->
name|tm_hour
argument_list|,
name|brokenDown
operator|->
name|tm_min
argument_list|,
name|brokenDown
operator|->
name|tm_sec
argument_list|,
name|time
operator|.
name|msec
argument_list|()
argument_list|)
expr_stmt|;
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
name|deltaDays
argument_list|)
expr_stmt|;
if|if
condition|(
name|brokenDown
operator|->
name|tm_isdst
operator|>
literal|0
condition|)
return|return
name|QDateTimePrivate
operator|::
name|LocalDST
return|;
elseif|else
if|if
condition|(
name|brokenDown
operator|->
name|tm_isdst
operator|<
literal|0
condition|)
return|return
name|QDateTimePrivate
operator|::
name|LocalUnknown
return|;
else|else
return|return
name|QDateTimePrivate
operator|::
name|LocalStandard
return|;
block|}
block|}
end_function
begin_comment
comment|// Convert passed in LocalTime datetime into UTC
end_comment
begin_function
DECL|function|localToUtc
specifier|static
name|void
name|localToUtc
parameter_list|(
name|QDate
modifier|&
name|date
parameter_list|,
name|QTime
modifier|&
name|time
parameter_list|,
name|int
name|isdst
parameter_list|)
block|{
if|if
condition|(
operator|!
name|date
operator|.
name|isValid
argument_list|()
condition|)
return|return;
name|QDate
name|fakeDate
init|=
name|adjustDate
argument_list|(
name|date
argument_list|)
decl_stmt|;
name|tm
name|localTM
decl_stmt|;
name|localTM
operator|.
name|tm_sec
operator|=
name|time
operator|.
name|second
argument_list|()
expr_stmt|;
name|localTM
operator|.
name|tm_min
operator|=
name|time
operator|.
name|minute
argument_list|()
expr_stmt|;
name|localTM
operator|.
name|tm_hour
operator|=
name|time
operator|.
name|hour
argument_list|()
expr_stmt|;
name|localTM
operator|.
name|tm_mday
operator|=
name|fakeDate
operator|.
name|day
argument_list|()
expr_stmt|;
name|localTM
operator|.
name|tm_mon
operator|=
name|fakeDate
operator|.
name|month
argument_list|()
operator|-
literal|1
expr_stmt|;
name|localTM
operator|.
name|tm_year
operator|=
name|fakeDate
operator|.
name|year
argument_list|()
operator|-
literal|1900
expr_stmt|;
name|localTM
operator|.
name|tm_isdst
operator|=
operator|(
name|int
operator|)
name|isdst
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|time_t
name|secsSince1Jan1970UTC
init|=
operator|(
name|toMSecsSinceEpoch_helper
argument_list|(
name|fakeDate
operator|.
name|toJulianDay
argument_list|()
argument_list|,
name|QTime
argument_list|()
operator|.
name|msecsTo
argument_list|(
name|time
argument_list|)
argument_list|)
operator|/
literal|1000
operator|)
decl_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|_tzset
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|time_t
name|secsSince1Jan1970UTC
init|=
name|mktime
argument_list|(
operator|&
name|localTM
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_QNX
comment|//mktime sometimes fails on QNX. Following workaround converts the date and time then manually
if|if
condition|(
name|secsSince1Jan1970UTC
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
name|QDateTime
name|tempTime
init|=
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
empty_stmt|;
name|tempTime
operator|=
name|tempTime
operator|.
name|addMSecs
argument_list|(
name|timezone
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|date
operator|=
name|tempTime
operator|.
name|date
argument_list|()
expr_stmt|;
name|time
operator|=
name|tempTime
operator|.
name|time
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|tm
modifier|*
name|brokenDown
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|tm
name|res
decl_stmt|;
name|FILETIME
name|localTime
init|=
name|time_tToFt
argument_list|(
name|secsSince1Jan1970UTC
argument_list|)
decl_stmt|;
name|SYSTEMTIME
name|sysTime
decl_stmt|;
name|FileTimeToSystemTime
argument_list|(
operator|&
name|localTime
argument_list|,
operator|&
name|sysTime
argument_list|)
expr_stmt|;
name|FILETIME
name|resultTime
decl_stmt|;
name|LocalFileTimeToFileTime
argument_list|(
operator|&
name|localTime
argument_list|,
operator|&
name|resultTime
argument_list|)
expr_stmt|;
name|FileTimeToSystemTime
argument_list|(
operator|&
name|resultTime
argument_list|,
operator|&
name|sysTime
argument_list|)
expr_stmt|;
name|res
operator|.
name|tm_sec
operator|=
name|sysTime
operator|.
name|wSecond
expr_stmt|;
name|res
operator|.
name|tm_min
operator|=
name|sysTime
operator|.
name|wMinute
expr_stmt|;
name|res
operator|.
name|tm_hour
operator|=
name|sysTime
operator|.
name|wHour
expr_stmt|;
name|res
operator|.
name|tm_mday
operator|=
name|sysTime
operator|.
name|wDay
expr_stmt|;
name|res
operator|.
name|tm_mon
operator|=
name|sysTime
operator|.
name|wMonth
operator|-
literal|1
expr_stmt|;
name|res
operator|.
name|tm_year
operator|=
name|sysTime
operator|.
name|wYear
operator|-
literal|1900
expr_stmt|;
name|res
operator|.
name|tm_isdst
operator|=
operator|(
name|int
operator|)
name|isdst
expr_stmt|;
name|brokenDown
operator|=
operator|&
name|res
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of gmtime() where available
name|tm
name|res
decl_stmt|;
name|brokenDown
operator|=
name|gmtime_r
argument_list|(
operator|&
name|secsSince1Jan1970UTC
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
name|tm
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|_gmtime64_s
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|secsSince1Jan1970UTC
argument_list|)
condition|)
name|brokenDown
operator|=
operator|&
name|res
expr_stmt|;
else|#
directive|else
name|brokenDown
operator|=
name|gmtime
argument_list|(
operator|&
name|secsSince1Jan1970UTC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_THREAD&& _POSIX_THREAD_SAFE_FUNCTIONS
if|if
condition|(
operator|!
name|brokenDown
condition|)
block|{
name|date
operator|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|time
operator|=
name|QTime
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|qint64
name|deltaDays
init|=
name|fakeDate
operator|.
name|daysTo
argument_list|(
name|date
argument_list|)
decl_stmt|;
name|date
operator|=
name|QDate
argument_list|(
name|brokenDown
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|brokenDown
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|brokenDown
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|time
operator|=
name|QTime
argument_list|(
name|brokenDown
operator|->
name|tm_hour
argument_list|,
name|brokenDown
operator|->
name|tm_min
argument_list|,
name|brokenDown
operator|->
name|tm_sec
argument_list|,
name|time
operator|.
name|msec
argument_list|()
argument_list|)
expr_stmt|;
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
name|deltaDays
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Convert passed in OffsetFromUTC datetime and offset into UTC
end_comment
begin_function
DECL|function|offsetToUtc
specifier|static
name|void
name|offsetToUtc
parameter_list|(
name|QDate
modifier|*
name|outDate
parameter_list|,
name|QTime
modifier|*
name|outTime
parameter_list|,
name|qint32
name|offset
parameter_list|)
block|{
name|QDateTimePrivate
operator|::
name|addMSecs
argument_list|(
operator|*
name|outDate
argument_list|,
operator|*
name|outTime
argument_list|,
operator|-
operator|(
name|qint64
argument_list|(
name|offset
argument_list|)
operator|*
literal|1000
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Convert passed in UTC datetime and offset into OffsetFromUTC
end_comment
begin_function
DECL|function|utcToOffset
specifier|static
name|void
name|utcToOffset
parameter_list|(
name|QDate
modifier|*
name|outDate
parameter_list|,
name|QTime
modifier|*
name|outTime
parameter_list|,
name|qint32
name|offset
parameter_list|)
block|{
name|QDateTimePrivate
operator|::
name|addMSecs
argument_list|(
operator|*
name|outDate
argument_list|,
operator|*
name|outTime
argument_list|,
operator|(
name|qint64
argument_list|(
name|offset
argument_list|)
operator|*
literal|1000
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Get current date/time in LocalTime and put result in outDate and outTime
end_comment
begin_function
DECL|function|getLocal
name|QDateTimePrivate
operator|::
name|Spec
name|QDateTimePrivate
operator|::
name|getLocal
parameter_list|(
name|QDate
modifier|&
name|outDate
parameter_list|,
name|QTime
modifier|&
name|outTime
parameter_list|)
specifier|const
block|{
name|outDate
operator|=
name|date
expr_stmt|;
name|outTime
operator|=
name|time
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|UTC
condition|)
return|return
name|utcToLocal
argument_list|(
name|outDate
argument_list|,
name|outTime
argument_list|)
return|;
if|if
condition|(
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
block|{
name|offsetToUtc
argument_list|(
operator|&
name|outDate
argument_list|,
operator|&
name|outTime
argument_list|,
name|m_offsetFromUtc
argument_list|)
expr_stmt|;
return|return
name|utcToLocal
argument_list|(
name|outDate
argument_list|,
name|outTime
argument_list|)
return|;
block|}
return|return
name|spec
return|;
block|}
end_function
begin_comment
comment|// Get current date/time in UTC and put result in outDate and outTime
end_comment
begin_function
DECL|function|getUTC
name|void
name|QDateTimePrivate
operator|::
name|getUTC
parameter_list|(
name|QDate
modifier|&
name|outDate
parameter_list|,
name|QTime
modifier|&
name|outTime
parameter_list|)
specifier|const
block|{
name|outDate
operator|=
name|date
expr_stmt|;
name|outTime
operator|=
name|time
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
name|offsetToUtc
argument_list|(
operator|&
name|outDate
argument_list|,
operator|&
name|outTime
argument_list|,
name|m_offsetFromUtc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|spec
operator|!=
name|QDateTimePrivate
operator|::
name|UTC
condition|)
name|localToUtc
argument_list|(
name|outDate
argument_list|,
name|outTime
argument_list|,
operator|(
name|int
operator|)
name|spec
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_DATESTRING
argument_list|)
end_if
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QDate("
operator|<<
name|date
operator|.
name|toString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"yyyy-MM-dd"
argument_list|)
argument_list|)
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QTime("
operator|<<
name|time
operator|.
name|toString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"HH:mm:ss.zzz"
argument_list|)
argument_list|)
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|date
parameter_list|)
block|{
name|QString
name|spec
decl_stmt|;
switch|switch
condition|(
name|date
operator|.
name|d
operator|->
name|spec
condition|)
block|{
case|case
name|QDateTimePrivate
operator|::
name|UTC
case|:
name|spec
operator|=
name|QStringLiteral
argument_list|(
literal|" Qt::UTC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
case|:
name|spec
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|" Qt::OffsetFromUTC %1s"
argument_list|)
operator|.
name|arg
argument_list|(
name|date
operator|.
name|offsetFromUtc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDateTimePrivate
operator|::
name|LocalDST
case|:
case|case
name|QDateTimePrivate
operator|::
name|LocalStandard
case|:
case|case
name|QDateTimePrivate
operator|::
name|LocalUnknown
case|:
default|default :
name|spec
operator|=
name|QStringLiteral
argument_list|(
literal|" Qt::LocalTime"
argument_list|)
expr_stmt|;
block|}
name|QString
name|output
init|=
name|date
operator|.
name|toString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"yyyy-MM-dd HH:mm:ss.zzz t"
argument_list|)
argument_list|)
operator|+
name|spec
decl_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QDateTime("
operator|<<
name|output
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \fn uint qHash(const QDateTime&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_function
DECL|function|qHash
name|uint
name|qHash
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
block|{
comment|// Use to toMSecsSinceEpoch instead of individual qHash functions for
comment|// QDate/QTime/spec/offset because QDateTime::operator== converts both arguments
comment|// to the same timezone. If we don't, qHash would return different hashes for
comment|// two QDateTimes that are equivalent once converted to the same timezone.
return|return
name|qHash
argument_list|(
name|key
operator|.
name|toMSecsSinceEpoch
argument_list|()
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn uint qHash(const QDate&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_function
name|uint
name|qHash
parameter_list|(
specifier|const
name|QDate
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|qHash
argument_list|(
name|key
operator|.
name|toJulianDay
argument_list|()
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn uint qHash(const QTime&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_function
name|uint
name|qHash
parameter_list|(
specifier|const
name|QTime
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|qHash
argument_list|(
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|msecsTo
argument_list|(
name|key
argument_list|)
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
