begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"private/qdatetime_p.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qset.h"
end_include
begin_include
include|#
directive|include
file|"qlocale.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qregexp.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_WIN
end_ifndef
begin_include
include|#
directive|include
file|<locale.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<cmath>
end_include
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_include
include|#
directive|include
file|<qt_windows.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WINCE
end_ifdef
begin_include
include|#
directive|include
file|"qfunctions_wince.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//#define QDATETIMEPARSER_DEBUG
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QDATETIMEPARSER_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
end_if
begin_define
DECL|macro|QDTPDEBUG
define|#
directive|define
name|QDTPDEBUG
value|qDebug()<< QString("%1:%2").arg(__FILE__).arg(__LINE__)
end_define
begin_define
DECL|macro|QDTPDEBUGN
define|#
directive|define
name|QDTPDEBUGN
value|qDebug
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QDTPDEBUG
define|#
directive|define
name|QDTPDEBUG
value|if (false) qDebug()
end_define
begin_define
DECL|macro|QDTPDEBUGN
define|#
directive|define
name|QDTPDEBUGN
value|if (false) qDebug
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_include
include|#
directive|include
file|<private/qcore_mac_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|enum
type|{
DECL|enumerator|SECS_PER_DAY
name|SECS_PER_DAY
init|=
literal|86400
decl_stmt|,
DECL|enumerator|MSECS_PER_DAY
name|MSECS_PER_DAY
init|=
literal|86400000
decl_stmt|,
DECL|enumerator|SECS_PER_HOUR
name|SECS_PER_HOUR
init|=
literal|3600
decl_stmt|,
DECL|enumerator|MSECS_PER_HOUR
name|MSECS_PER_HOUR
init|=
literal|3600000
decl_stmt|,
DECL|enumerator|SECS_PER_MIN
name|SECS_PER_MIN
init|=
literal|60
decl_stmt|,
DECL|enumerator|MSECS_PER_MIN
name|MSECS_PER_MIN
init|=
literal|60000
decl_stmt|,
DECL|enumerator|JULIAN_DAY_FOR_EPOCH
name|JULIAN_DAY_FOR_EPOCH
init|=
literal|2440588
end_decl_stmt
begin_comment
DECL|enumerator|JULIAN_DAY_FOR_EPOCH
comment|// result of julianDayFromDate(1970, 1, 1)
end_comment
begin_function
DECL|enumerator|JULIAN_DAY_FOR_EPOCH
unit|};
DECL|function|fixedDate
specifier|static
specifier|inline
name|QDate
name|fixedDate
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|QDate
name|result
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|result
operator|.
name|setDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|qMin
argument_list|(
name|d
argument_list|,
name|result
operator|.
name|daysInMonth
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|julianDayFromDate
specifier|static
specifier|inline
name|qint64
name|julianDayFromDate
parameter_list|(
name|qint64
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
comment|// Gregorian calendar
comment|// Algorithm from Henry F. Fliegel and Thomas C. Van Flandern
if|if
condition|(
name|year
operator|<
literal|0
condition|)
operator|++
name|year
expr_stmt|;
return|return
operator|(
literal|1461
operator|*
operator|(
name|year
operator|+
literal|4800
operator|+
operator|(
name|month
operator|-
literal|14
operator|)
operator|/
literal|12
operator|)
operator|)
operator|/
literal|4
operator|+
operator|(
literal|367
operator|*
operator|(
name|month
operator|-
literal|2
operator|-
literal|12
operator|*
operator|(
operator|(
name|month
operator|-
literal|14
operator|)
operator|/
literal|12
operator|)
operator|)
operator|)
operator|/
literal|12
operator|-
operator|(
literal|3
operator|*
operator|(
operator|(
name|year
operator|+
literal|4900
operator|+
operator|(
name|month
operator|-
literal|14
operator|)
operator|/
literal|12
operator|)
operator|/
literal|100
operator|)
operator|)
operator|/
literal|4
operator|+
name|day
operator|-
literal|32075
return|;
block|}
end_function
begin_function
DECL|function|getDateFromJulianDay
specifier|static
name|void
name|getDateFromJulianDay
parameter_list|(
name|qint64
name|julianDay
parameter_list|,
name|int
modifier|*
name|year
parameter_list|,
name|int
modifier|*
name|month
parameter_list|,
name|int
modifier|*
name|day
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
comment|// Gregorian calendar
comment|// This algorithm is from Henry F. Fliegel and Thomas C. Van Flandern
name|qint64
name|ell
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|//TODO These will need to be bigger to prevent overflow!!!
name|ell
operator|=
name|julianDay
operator|+
literal|68569
expr_stmt|;
name|n
operator|=
operator|(
literal|4
operator|*
name|ell
operator|)
operator|/
literal|146097
expr_stmt|;
name|ell
operator|=
name|ell
operator|-
operator|(
literal|146097
operator|*
name|n
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|i
operator|=
operator|(
literal|4000
operator|*
operator|(
name|ell
operator|+
literal|1
operator|)
operator|)
operator|/
literal|1461001
expr_stmt|;
name|ell
operator|=
name|ell
operator|-
operator|(
literal|1461
operator|*
name|i
operator|)
operator|/
literal|4
operator|+
literal|31
expr_stmt|;
name|j
operator|=
operator|(
literal|80
operator|*
name|ell
operator|)
operator|/
literal|2447
expr_stmt|;
name|d
operator|=
name|ell
operator|-
operator|(
literal|2447
operator|*
name|j
operator|)
operator|/
literal|80
expr_stmt|;
name|ell
operator|=
name|j
operator|/
literal|11
expr_stmt|;
name|m
operator|=
name|j
operator|+
literal|2
operator|-
operator|(
literal|12
operator|*
name|ell
operator|)
expr_stmt|;
name|y
operator|=
literal|100
operator|*
operator|(
name|n
operator|-
literal|49
operator|)
operator|+
name|i
operator|+
name|ell
expr_stmt|;
if|if
condition|(
name|y
operator|<=
literal|0
condition|)
operator|--
name|y
expr_stmt|;
if|if
condition|(
name|year
condition|)
operator|*
name|year
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|month
condition|)
operator|*
name|month
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|day
condition|)
operator|*
name|day
operator|=
name|d
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|monthDays
specifier|static
specifier|const
name|char
name|monthDays
index|[]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_decl_stmt
DECL|variable|qt_shortMonthNames
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|qt_shortMonthNames
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function_decl
specifier|static
name|QString
name|fmtDateTime
parameter_list|(
specifier|const
name|QString
modifier|&
name|f
parameter_list|,
specifier|const
name|QTime
modifier|*
name|dt
init|=
literal|0
parameter_list|,
specifier|const
name|QDate
modifier|*
name|dd
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*****************************************************************************   QDate member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \since 4.5      \enum QDate::MonthNameType      This enum describes the types of the string representation used     for the month name.      \value DateFormat This type of name can be used for date-to-string formatting.     \value StandaloneFormat This type is used when you need to enumerate months or weekdays.            Usually standalone names are represented in singular forms with            capitalized first letter. */
end_comment
begin_comment
comment|/*!     \class QDate     \reentrant     \brief The QDate class provides date functions.       A QDate object contains a calendar date, i.e. year, month, and day     numbers, in the Gregorian calendar. It can read the current date     from the system clock. It provides functions for comparing dates,     and for manipulating dates. For example, it is possible to add     and subtract days, months, and years to dates.      A QDate object is typically created either by giving the year,     month, and day numbers explicitly. Note that QDate interprets two     digit years as is, i.e., years 0 - 99. A QDate can also be     constructed with the static function currentDate(), which creates     a QDate object containing the system clock's date.  An explicit     date can also be set using setDate(). The fromString() function     returns a QDate given a string and a date format which is used to     interpret the date within the string.      The year(), month(), and day() functions provide access to the     year, month, and day numbers. Also, dayOfWeek() and dayOfYear()     functions are provided. The same information is provided in     textual format by the toString(), shortDayName(), longDayName(),     shortMonthName(), and longMonthName() functions.      QDate provides a full set of operators to compare two QDate     objects where smaller means earlier, and larger means later.      You can increment (or decrement) a date by a given number of days     using addDays(). Similarly you can use addMonths() and addYears().     The daysTo() function returns the number of days between two     dates.      The daysInMonth() and daysInYear() functions return how many days     there are in this date's month and year, respectively. The     isLeapYear() function indicates whether a date is in a leap year.      \section1      \section2 No Year 0      There is no year 0. Dates in that year are considered invalid. The     year -1 is the year "1 before Christ" or "1 before current era."     The day before 1 January 1 CE is 31 December 1 BCE.      \section2 Range of Valid Dates      Dates are stored internally as a Julian Day number, an interger count of     every day in a contiguous range, with 24 November 4714 BCE in the Gregorian     calendar being Julian Day 0 (1 January 4713 BCE in the Julian calendar).     As well as being an efficient and accurate way of storing an absolute date,     it is suitable for converting a Date into other calendar systems such as     Hebrew, Islamic or Chinese. The Julian Day number can be obtained using     QDate::toJulianDay() and can be set using QDate::fromJulianDay().      The range of dates able to be stored by QDate as a Julian Day number is     limited for convenience from std::numeric_limits<qint64>::min() / 2 to     std::numeric_limits<qint64>::max() / 2, which on most platforms means     from around 2.5 quadrillion BCE to around 2.5 quadrillion CE, effectively     covering the full range of astronomical time. The range of Julian Days     able to be accurately converted to and from valid YMD form Dates is     restricted to 1 January 4800 BCE to 31 December 1400000 CE due to     shortcomings in the available conversion formulas. Conversions outside this     range are not guaranteed to be correct. This may change in the future.      \sa QTime, QDateTime, QDateEdit, QDateTimeEdit, QCalendarWidget */
end_comment
begin_comment
comment|/*!     \fn QDate::QDate()      Constructs a null date. Null dates are invalid.      \sa isNull(), isValid() */
end_comment
begin_comment
comment|/*!     Constructs a date with year \a y, month \a m and day \a d.      If the specified date is invalid, the date is not set and     isValid() returns false.      \warning Years 0 to 99 are interpreted as is, i.e., years              0-99.      \sa isValid() */
end_comment
begin_constructor
DECL|function|QDate
name|QDate
operator|::
name|QDate
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|setDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn bool QDate::isNull() const      Returns true if the date is null; otherwise returns false. A null     date is invalid.      \note The behavior of this function is equivalent to isValid().      \sa isValid() */
end_comment
begin_comment
comment|/*!     \fn bool isValid() const      Returns true if this date is valid; otherwise returns false.      \sa isNull() */
end_comment
begin_comment
comment|/*!     Returns the year of this date. Negative numbers indicate years     before 1 CE, such that year -44 is 44 BCE.      Returns 0 if the date is invalid.      \sa month(), day() */
end_comment
begin_function
DECL|function|year
name|int
name|QDate
operator|::
name|year
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|y
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number corresponding to the month of this date, using     the following convention:      \list     \li 1 = "January"     \li 2 = "February"     \li 3 = "March"     \li 4 = "April"     \li 5 = "May"     \li 6 = "June"     \li 7 = "July"     \li 8 = "August"     \li 9 = "September"     \li 10 = "October"     \li 11 = "November"     \li 12 = "December"     \endlist      Returns 0 if the date is invalid.      \sa year(), day() */
end_comment
begin_function
DECL|function|month
name|int
name|QDate
operator|::
name|month
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|m
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
literal|0
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the day of the month (1 to 31) of this date.      Returns 0 if the date is invalid.      \sa year(), month(), dayOfWeek() */
end_comment
begin_function
DECL|function|day
name|int
name|QDate
operator|::
name|day
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the weekday (1 = Monday to 7 = Sunday) for this date.      Returns 0 if the date is invalid.      \sa day(), dayOfYear(), Qt::DayOfWeek */
end_comment
begin_function
DECL|function|dayOfWeek
name|int
name|QDate
operator|::
name|dayOfWeek
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|jd
operator|>=
literal|0
condition|)
return|return
operator|(
name|jd
operator|%
literal|7
operator|)
operator|+
literal|1
return|;
else|else
return|return
operator|(
operator|(
name|jd
operator|+
literal|1
operator|)
operator|%
literal|7
operator|)
operator|+
literal|7
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the day of the year (1 to 365 or 366 on leap years) for     this date.      Returns 0 if the date is invalid.      \sa day(), dayOfWeek() */
end_comment
begin_function
DECL|function|dayOfYear
name|int
name|QDate
operator|::
name|dayOfYear
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|jd
operator|-
name|julianDayFromDate
argument_list|(
name|year
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days in the month (28 to 31) for this date.      Returns 0 if the date is invalid.      \sa day(), daysInYear() */
end_comment
begin_function
DECL|function|daysInMonth
name|int
name|QDate
operator|::
name|daysInMonth
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|y
decl_stmt|,
name|m
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|2
operator|&&
name|isLeapYear
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|29
return|;
elseif|else
if|if
condition|(
name|m
argument_list|<
literal|1
operator|||
name|m
argument_list|>
literal|12
condition|)
return|return
literal|0
return|;
else|else
return|return
name|monthDays
index|[
name|m
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days in the year (365 or 366) for this date.      Returns 0 if the date is invalid.      \sa day(), daysInMonth() */
end_comment
begin_function
DECL|function|daysInYear
name|int
name|QDate
operator|::
name|daysInYear
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|y
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|isLeapYear
argument_list|(
name|y
argument_list|)
condition|?
literal|366
else|:
literal|365
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the week number (1 to 53), and stores the year in     *\a{yearNumber} unless \a yearNumber is null (the default).      Returns 0 if the date is invalid.      In accordance with ISO 8601, weeks start on Monday and the first     Thursday of a year is always in week 1 of that year. Most years     have 52 weeks, but some have 53.      *\a{yearNumber} is not always the same as year(). For example, 1     January 2000 has week number 52 in the year 1999, and 31 December     2002 has week number 1 in the year 2003.      \legalese     Copyright (c) 1989 The Regents of the University of California.     All rights reserved.      Redistribution and use in source and binary forms are permitted     provided that the above copyright notice and this paragraph are     duplicated in all such forms and that any documentation,     advertising materials, and other materials related to such     distribution and use acknowledge that the software was developed     by the University of California, Berkeley.  The name of the     University may not be used to endorse or promote products derived     from this software without specific prior written permission.     THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR     IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.      \sa isValid() */
end_comment
begin_function
DECL|function|weekNumber
name|int
name|QDate
operator|::
name|weekNumber
parameter_list|(
name|int
modifier|*
name|yearNumber
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|year
init|=
name|QDate
operator|::
name|year
argument_list|()
decl_stmt|;
name|int
name|yday
init|=
name|dayOfYear
argument_list|()
operator|-
literal|1
decl_stmt|;
name|int
name|wday
init|=
name|dayOfWeek
argument_list|()
decl_stmt|;
if|if
condition|(
name|wday
operator|==
literal|7
condition|)
name|wday
operator|=
literal|0
expr_stmt|;
name|int
name|w
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|bot
decl_stmt|;
name|int
name|top
decl_stmt|;
name|len
operator|=
name|isLeapYear
argument_list|(
name|year
argument_list|)
condition|?
literal|366
else|:
literal|365
expr_stmt|;
comment|/*         ** What yday (-3 ... 3) does         ** the ISO year begin on?         */
name|bot
operator|=
operator|(
operator|(
name|yday
operator|+
literal|11
operator|-
name|wday
operator|)
operator|%
literal|7
operator|)
operator|-
literal|3
expr_stmt|;
comment|/*         ** What yday does the NEXT         ** ISO year begin on?         */
name|top
operator|=
name|bot
operator|-
operator|(
name|len
operator|%
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|top
operator|<
operator|-
literal|3
condition|)
name|top
operator|+=
literal|7
expr_stmt|;
name|top
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|yday
operator|>=
name|top
condition|)
block|{
operator|++
name|year
expr_stmt|;
name|w
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|yday
operator|>=
name|bot
condition|)
block|{
name|w
operator|=
literal|1
operator|+
operator|(
operator|(
name|yday
operator|-
name|bot
operator|)
operator|/
literal|7
operator|)
expr_stmt|;
break|break;
block|}
operator|--
name|year
expr_stmt|;
name|yday
operator|+=
name|isLeapYear
argument_list|(
name|year
argument_list|)
condition|?
literal|366
else|:
literal|365
expr_stmt|;
block|}
if|if
condition|(
name|yearNumber
operator|!=
literal|0
condition|)
operator|*
name|yearNumber
operator|=
name|year
expr_stmt|;
return|return
name|w
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_comment
comment|/*!     \since 4.5      Returns the short name of the \a month for the representation specified     by \a type.      The months are enumerated using the following convention:      \list     \li 1 = "Jan"     \li 2 = "Feb"     \li 3 = "Mar"     \li 4 = "Apr"     \li 5 = "May"     \li 6 = "Jun"     \li 7 = "Jul"     \li 8 = "Aug"     \li 9 = "Sep"     \li 10 = "Oct"     \li 11 = "Nov"     \li 12 = "Dec"     \endlist      The month names will be localized according to the system's locale     settings.      Returns an empty string if the date is invalid.      \sa toString(), longMonthName(), shortDayName(), longDayName() */
end_comment
begin_function
DECL|function|shortMonthName
name|QString
name|QDate
operator|::
name|shortMonthName
parameter_list|(
name|int
name|month
parameter_list|,
name|QDate
operator|::
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|month
argument_list|<
literal|1
operator|||
name|month
argument_list|>
literal|12
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneMonthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the long name of the \a month for the representation specified     by \a type.      The months are enumerated using the following convention:      \list     \li 1 = "January"     \li 2 = "February"     \li 3 = "March"     \li 4 = "April"     \li 5 = "May"     \li 6 = "June"     \li 7 = "July"     \li 8 = "August"     \li 9 = "September"     \li 10 = "October"     \li 11 = "November"     \li 12 = "December"     \endlist      The month names will be localized according to the system's locale     settings.      Returns an empty string if the date is invalid.      \sa toString(), shortMonthName(), shortDayName(), longDayName() */
end_comment
begin_function
DECL|function|longMonthName
name|QString
name|QDate
operator|::
name|longMonthName
parameter_list|(
name|int
name|month
parameter_list|,
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|month
argument_list|<
literal|1
operator|||
name|month
argument_list|>
literal|12
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneMonthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the short name of the \a weekday for the representation specified     by \a type.      The days are enumerated using the following convention:      \list     \li 1 = "Mon"     \li 2 = "Tue"     \li 3 = "Wed"     \li 4 = "Thu"     \li 5 = "Fri"     \li 6 = "Sat"     \li 7 = "Sun"     \endlist      The day names will be localized according to the system's locale     settings.      Returns an empty string if the date is invalid.      \sa toString(), shortMonthName(), longMonthName(), longDayName() */
end_comment
begin_function
DECL|function|shortDayName
name|QString
name|QDate
operator|::
name|shortDayName
parameter_list|(
name|int
name|weekday
parameter_list|,
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|weekday
argument_list|<
literal|1
operator|||
name|weekday
argument_list|>
literal|7
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneDayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the long name of the \a weekday for the representation specified     by \a type.      The days are enumerated using the following convention:      \list     \li 1 = "Monday"     \li 2 = "Tuesday"     \li 3 = "Wednesday"     \li 4 = "Thursday"     \li 5 = "Friday"     \li 6 = "Saturday"     \li 7 = "Sunday"     \endlist      The day names will be localized according to the system's locale     settings.      Returns an empty string if the date is invalid.      \sa toString(), shortDayName(), shortMonthName(), longMonthName() */
end_comment
begin_function
DECL|function|longDayName
name|QString
name|QDate
operator|::
name|longDayName
parameter_list|(
name|int
name|weekday
parameter_list|,
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|weekday
argument_list|<
literal|1
operator|||
name|weekday
argument_list|>
literal|7
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneDayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_TEXTDATE
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \fn QString QDate::toString(Qt::DateFormat format) const      \overload      Returns the date as a string. The \a format parameter determines     the format of the string.      If the \a format is Qt::TextDate, the string is formatted in     the default way. QDate::shortDayName() and QDate::shortMonthName()     are used to generate the string, so the day and month names will     be localized names. An example of this formatting is     "Sat May 20 1995".      If the \a format is Qt::ISODate, the string format corresponds     to the ISO 8601 extended specification for representations of     dates and times, taking the form YYYY-MM-DD, where YYYY is the     year, MM is the month of the year (between 01 and 12), and DD is     the day of the month between 01 and 31.      If the \a format is Qt::SystemLocaleShortDate or     Qt::SystemLocaleLongDate, the string format depends on the locale     settings of the system. Identical to calling     QLocale::system().toString(date, QLocale::ShortFormat) or     QLocale::system().toString(date, QLocale::LongFormat).      If the \a format is Qt::DefaultLocaleShortDate or     Qt::DefaultLocaleLongDate, the string format depends on the     default application locale. This is the locale set with     QLocale::setDefault(), or the system locale if no default locale     has been set. Identical to calling QLocale().toString(date,     QLocale::ShortFormat) or QLocale().toString(date,     QLocale::LongFormat).      If the date is invalid, an empty string will be returned.      \warning The Qt::ISODate format is only valid for years in the     range 0 to 9999. This restriction may apply to locale-aware     formats as well, depending on the locale settings.      \sa shortDayName(), shortMonthName() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDate
operator|::
name|toString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|f
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|int
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|f
operator|==
name|Qt
operator|::
name|SystemLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|f
operator|==
name|Qt
operator|::
name|DefaultLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
default|default:
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
case|case
name|Qt
operator|::
name|TextDate
case|:
block|{
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%0 %1 %2 %3"
argument_list|)
operator|.
name|arg
argument_list|(
name|shortDayName
argument_list|(
name|dayOfWeek
argument_list|()
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|shortMonthName
argument_list|(
name|m
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|d
argument_list|)
operator|.
name|arg
argument_list|(
name|y
argument_list|)
return|;
block|}
endif|#
directive|endif
case|case
name|Qt
operator|::
name|ISODate
case|:
block|{
if|if
condition|(
name|year
argument_list|()
operator|<
literal|0
operator|||
name|year
argument_list|()
operator|>
literal|9999
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|year
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|y
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|4
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|month
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|m
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|day
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|d
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|year
operator|+
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|month
operator|+
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|day
return|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the date as a string. The \a format parameter determines     the format of the result string.      These expressions may be used:      \table     \header \li Expression \li Output     \row \li d \li the day as number without a leading zero (1 to 31)     \row \li dd \li the day as number with a leading zero (01 to 31)     \row \li ddd          \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').             Uses QDate::shortDayName().     \row \li dddd          \li the long localized day name (e.g. 'Monday' to 'Sunday').             Uses QDate::longDayName().     \row \li M \li the month as number without a leading zero (1 to 12)     \row \li MM \li the month as number with a leading zero (01 to 12)     \row \li MMM          \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').             Uses QDate::shortMonthName().     \row \li MMMM          \li the long localized month name (e.g. 'January' to 'December').             Uses QDate::longMonthName().     \row \li yy \li the year as two digit number (00 to 99)     \row \li yyyy \li the year as four digit number. If the year is negative,             a minus sign is prepended in addition.     \endtable      All other input characters will be ignored. Any sequence of characters that     are enclosed in singlequotes will be treated as text and not be used as an     expression. Two consecutive singlequotes ("''") are replaced by a singlequote     in the output.      Example format strings (assuming that the QDate is the 20 July     1969):      \table     \header \li Format            \li Result     \row    \li dd.MM.yyyy        \li 20.07.1969     \row    \li ddd MMMM d yy     \li Sun July 20 69     \row    \li 'The day is' dddd \li The day is Sunday     \endtable      If the datetime is invalid, an empty string will be returned.      \warning The Qt::ISODate format is only valid for years in the     range 0 to 9999. This restriction may apply to locale-aware     formats as well, depending on the locale settings.      \sa QDateTime::toString(), QTime::toString()  */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDate
operator|::
name|toString
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|year
argument_list|()
operator|>
literal|9999
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|fmtDateTime
argument_list|(
name|format
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \fn bool QDate::setYMD(int y, int m, int d)      \deprecated in 5.0, use setDate() instead.      Sets the date's year \a y, month \a m, and day \a d.      If \a y is in the range 0 to 99, it is interpreted as 1900 to     1999.      Use setDate() instead. */
end_comment
begin_comment
comment|/*!     \since 4.2      Sets the date's \a year, \a month, and \a day. Returns true if     the date is valid; otherwise returns false.      If the specified date is invalid, the QDate object is set to be     invalid.      Note that any date before 4800 BCE or after about 1.4 million CE     may not be accurately stored.      \sa isValid() */
end_comment
begin_function
DECL|function|setDate
name|bool
name|QDate
operator|::
name|setDate
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
condition|)
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
else|else
name|jd
operator|=
name|nullJd
argument_list|()
expr_stmt|;
return|return
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Extracts the date's year, month, and day, and assigns them to     *\a year, *\a month, and *\a day. The pointers may be null.      Returns 0 if the date is invalid.      Note that any date before 4800 BCE or after about 1.4 million CE     may not be accurately stored.      \sa year(), month(), day(), isValid() */
end_comment
begin_function
DECL|function|getDate
name|void
name|QDate
operator|::
name|getDate
parameter_list|(
name|int
modifier|*
name|year
parameter_list|,
name|int
modifier|*
name|month
parameter_list|,
name|int
modifier|*
name|day
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|()
condition|)
block|{
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|year
condition|)
operator|*
name|year
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|month
condition|)
operator|*
name|month
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|day
condition|)
operator|*
name|day
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns a QDate object containing a date \a ndays later than the     date of this object (or earlier if \a ndays is negative).      Returns a null date if the current date is invalid or the new date is     out-of-range.      \sa addMonths(), addYears(), daysTo() */
end_comment
begin_function
DECL|function|addDays
name|QDate
name|QDate
operator|::
name|addDays
parameter_list|(
name|qint64
name|ndays
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
name|QDate
name|d
decl_stmt|;
name|quint64
name|diff
init|=
literal|0
decl_stmt|;
comment|// this is basically "d.jd = jd + ndays" with checks for integer overflow
comment|// Due to limits on minJd() and maxJd() we know diff will never overflow
if|if
condition|(
name|ndays
operator|>=
literal|0
condition|)
name|diff
operator|=
name|maxJd
argument_list|()
operator|-
name|jd
expr_stmt|;
else|else
name|diff
operator|=
name|jd
operator|-
name|minJd
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|quint64
operator|)
name|qAbs
argument_list|(
name|ndays
argument_list|)
operator|<=
name|diff
condition|)
name|d
operator|.
name|jd
operator|=
name|jd
operator|+
name|ndays
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDate object containing a date \a nmonths later than the     date of this object (or earlier if \a nmonths is negative).      \note If the ending day/month combination does not exist in the     resulting month/year, this function will return a date that is the     latest valid date.      \sa addDays(), addYears() */
end_comment
begin_function
DECL|function|addMonths
name|QDate
name|QDate
operator|::
name|addMonths
parameter_list|(
name|int
name|nmonths
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
if|if
condition|(
operator|!
name|nmonths
condition|)
return|return
operator|*
name|this
return|;
name|int
name|old_y
decl_stmt|,
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|old_y
operator|=
name|y
expr_stmt|;
name|bool
name|increasing
init|=
name|nmonths
operator|>
literal|0
decl_stmt|;
while|while
condition|(
name|nmonths
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nmonths
operator|<
literal|0
operator|&&
name|nmonths
operator|+
literal|12
operator|<=
literal|0
condition|)
block|{
name|y
operator|--
expr_stmt|;
name|nmonths
operator|+=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmonths
operator|<
literal|0
condition|)
block|{
name|m
operator|+=
name|nmonths
expr_stmt|;
name|nmonths
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0
condition|)
block|{
operator|--
name|y
expr_stmt|;
name|m
operator|+=
literal|12
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nmonths
operator|-
literal|12
operator|>=
literal|0
condition|)
block|{
name|y
operator|++
expr_stmt|;
name|nmonths
operator|-=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
literal|12
condition|)
block|{
name|y
operator|++
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|m
operator|+=
name|nmonths
expr_stmt|;
name|nmonths
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|12
condition|)
block|{
operator|++
name|y
expr_stmt|;
name|m
operator|-=
literal|12
expr_stmt|;
block|}
block|}
block|}
comment|// was there a sign change?
if|if
condition|(
operator|(
name|old_y
operator|>
literal|0
operator|&&
name|y
operator|<=
literal|0
operator|)
operator|||
operator|(
name|old_y
operator|<
literal|0
operator|&&
name|y
operator|>=
literal|0
operator|)
condition|)
comment|// yes, adjust the date by +1 or -1 years
name|y
operator|+=
name|increasing
condition|?
operator|+
literal|1
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|fixedDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDate object containing a date \a nyears later than the     date of this object (or earlier if \a nyears is negative).      \note If the ending day/month combination does not exist in the     resulting year (i.e., if the date was Feb 29 and the final year is     not a leap year), this function will return a date that is the     latest valid date (that is, Feb 28).      \sa addDays(), addMonths() */
end_comment
begin_function
DECL|function|addYears
name|QDate
name|QDate
operator|::
name|addYears
parameter_list|(
name|int
name|nyears
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
name|int
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|int
name|old_y
init|=
name|y
decl_stmt|;
name|y
operator|+=
name|nyears
expr_stmt|;
comment|// was there a sign change?
if|if
condition|(
operator|(
name|old_y
operator|>
literal|0
operator|&&
name|y
operator|<=
literal|0
operator|)
operator|||
operator|(
name|old_y
operator|<
literal|0
operator|&&
name|y
operator|>=
literal|0
operator|)
condition|)
comment|// yes, adjust the date by +1 or -1 years
name|y
operator|+=
name|nyears
operator|>
literal|0
condition|?
operator|+
literal|1
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|fixedDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days from this date to \a d (which is     negative if \a d is earlier than this date).      Returns 0 if either date is invalid.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 0      \sa addDays() */
end_comment
begin_function
DECL|function|daysTo
name|qint64
name|QDate
operator|::
name|daysTo
parameter_list|(
specifier|const
name|QDate
modifier|&
name|d
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
operator|||
name|d
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// Due to limits on minJd() and maxJd() we know this will never overflow
return|return
name|d
operator|.
name|jd
operator|-
name|jd
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDate::operator==(const QDate&d) const      Returns true if this date is equal to \a d; otherwise returns     false.  */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator!=(const QDate&d) const      Returns true if this date is different from \a d; otherwise     returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator<(const QDate&d) const      Returns true if this date is earlier than \a d; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator<=(const QDate&d) const      Returns true if this date is earlier than or equal to \a d;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator>(const QDate&d) const      Returns true if this date is later than \a d; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator>=(const QDate&d) const      Returns true if this date is later than or equal to \a d;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QDate::currentDate()     Returns the current date, as reported by the system clock.      \sa QTime::currentTime(), QDateTime::currentDateTime() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \fn QDate QDate::fromString(const QString&string, Qt::DateFormat format)      Returns the QDate represented by the \a string, using the     \a format given, or an invalid date if the string cannot be     parsed.      Note for Qt::TextDate: It is recommended that you use the     English short month names (e.g. "Jan"). Although localized month     names can also be used, they depend on the user's locale settings. */
end_comment
begin_function
DECL|function|fromString
name|QDate
name|QDate
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|f
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|Qt
operator|::
name|ISODate
case|:
block|{
name|int
name|year
argument_list|(
name|s
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|month
argument_list|(
name|s
operator|.
name|mid
argument_list|(
literal|5
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|day
argument_list|(
name|s
operator|.
name|mid
argument_list|(
literal|8
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|year
operator|&&
name|month
operator|&&
name|day
condition|)
return|return
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
return|;
block|}
break|break;
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|fromString
argument_list|(
name|s
argument_list|,
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dateFormat
argument_list|(
name|f
operator|==
name|Qt
operator|::
name|SystemLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|fromString
argument_list|(
name|s
argument_list|,
name|QLocale
argument_list|()
operator|.
name|dateFormat
argument_list|(
name|f
operator|==
name|Qt
operator|::
name|DefaultLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
argument_list|)
return|;
default|default:
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
case|case
name|Qt
operator|::
name|TextDate
case|:
block|{
name|QStringList
name|parts
init|=
name|s
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|!=
literal|4
condition|)
block|{
return|return
name|QDate
argument_list|()
return|;
block|}
name|QString
name|monthName
init|=
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|month
init|=
operator|-
literal|1
decl_stmt|;
comment|// Assume that English monthnames are the default
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QLatin1String
argument_list|(
name|qt_shortMonthNames
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|month
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|// If English names can't be found, search the localized ones
if|if
condition|(
name|month
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QDate
operator|::
name|shortMonthName
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|month
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|month
argument_list|<
literal|1
operator|||
name|month
argument_list|>
literal|12
condition|)
block|{
return|return
name|QDate
argument_list|()
return|;
block|}
name|bool
name|ok
decl_stmt|;
name|int
name|day
init|=
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDate
argument_list|()
return|;
block|}
name|int
name|year
init|=
name|parts
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDate
argument_list|()
return|;
block|}
return|return
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
return|;
block|}
else|#
directive|else
break|break;
endif|#
directive|endif
block|}
return|return
name|QDate
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDate::fromString(const QString&string, const QString&format)      Returns the QDate represented by the \a string, using the \a     format given, or an invalid date if the string cannot be parsed.      These expressions may be used for the format:      \table     \header \li Expression \li Output     \row \li d \li The day as a number without a leading zero (1 to 31)     \row \li dd \li The day as a number with a leading zero (01 to 31)     \row \li ddd          \li The abbreviated localized day name (e.g. 'Mon' to 'Sun').             Uses QDate::shortDayName().     \row \li dddd          \li The long localized day name (e.g. 'Monday' to 'Sunday').             Uses QDate::longDayName().     \row \li M \li The month as a number without a leading zero (1 to 12)     \row \li MM \li The month as a number with a leading zero (01 to 12)     \row \li MMM          \li The abbreviated localized month name (e.g. 'Jan' to 'Dec').             Uses QDate::shortMonthName().     \row \li MMMM          \li The long localized month name (e.g. 'January' to 'December').             Uses QDate::longMonthName().     \row \li yy \li The year as two digit number (00 to 99)     \row \li yyyy \li The year as four digit number. If the year is negative,             a minus sign is prepended in addition.     \endtable      All other input characters will be treated as text. Any sequence     of characters that are enclosed in single quotes will also be     treated as text and will not be used as an expression. For example:      \snippet code/src_corelib_tools_qdatetime.cpp 1      If the format is not satisfied, an invalid QDate is returned. The     expressions that don't expect leading zeroes (d, M) will be     greedy. This means that they will use two digits even if this     will put them outside the accepted range of values and leaves too     few digits for other sections. For example, the following format     string could have meant January 30 but the M will grab two     digits, resulting in an invalid date:      \snippet code/src_corelib_tools_qdatetime.cpp 2      For any field that is not represented in the format the following     defaults are used:      \table     \header \li Field  \li Default value     \row    \li Year   \li 1900     \row    \li Month  \li 1     \row    \li Day    \li 1     \endtable      The following examples demonstrate the default values:      \snippet code/src_corelib_tools_qdatetime.cpp 3      \sa QDateTime::fromString(), QTime::fromString(), QDate::toString(),         QDateTime::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|fromString
name|QDate
name|QDate
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
name|QDate
name|date
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QDateTimeParser
name|dt
argument_list|(
name|QVariant
operator|::
name|Date
argument_list|,
name|QDateTimeParser
operator|::
name|FromString
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|parseFormat
argument_list|(
name|format
argument_list|)
condition|)
name|dt
operator|.
name|fromString
argument_list|(
name|string
argument_list|,
operator|&
name|date
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|date
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \overload      Returns true if the specified date (\a year, \a month, and \a     day) is valid; otherwise returns false.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 4      \sa isNull(), setDate() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QDate
operator|::
name|isValid
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
comment|// there is no year 0 in the Gregorian calendar
if|if
condition|(
name|year
operator|==
literal|0
condition|)
return|return
literal|false
return|;
return|return
operator|(
name|day
operator|>
literal|0
operator|&&
name|month
operator|>
literal|0
operator|&&
name|month
operator|<=
literal|12
operator|)
operator|&&
operator|(
name|day
operator|<=
name|monthDays
index|[
name|month
index|]
operator|||
operator|(
name|day
operator|==
literal|29
operator|&&
name|month
operator|==
literal|2
operator|&&
name|isLeapYear
argument_list|(
name|year
argument_list|)
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDate::isLeapYear(int year)      Returns true if the specified \a year is a leap year; otherwise     returns false. */
end_comment
begin_function
DECL|function|isLeapYear
name|bool
name|QDate
operator|::
name|isLeapYear
parameter_list|(
name|int
name|y
parameter_list|)
block|{
comment|// No year 0 in Gregorian calendar, so -1, -5, -9 etc are leap years
if|if
condition|(
name|y
operator|<
literal|1
condition|)
operator|++
name|y
expr_stmt|;
return|return
operator|(
name|y
operator|%
literal|4
operator|==
literal|0
operator|&&
name|y
operator|%
literal|100
operator|!=
literal|0
operator|)
operator|||
name|y
operator|%
literal|400
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \fn static QDate QDate::fromJulianDay(qint64 jd)      Converts the Julian day \a jd to a QDate.      \sa toJulianDay() */
end_comment
begin_comment
comment|/*! \fn int QDate::toJulianDay() const      Converts the date to a Julian day.      \sa fromJulianDay() */
end_comment
begin_comment
comment|/*****************************************************************************   QTime member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QTime     \reentrant      \brief The QTime class provides clock time functions.       A QTime object contains a clock time, i.e. the number of hours,     minutes, seconds, and milliseconds since midnight. It can read the     current time from the system clock and measure a span of elapsed     time. It provides functions for comparing times and for     manipulating a time by adding a number of milliseconds.      QTime uses the 24-hour clock format; it has no concept of AM/PM.     Unlike QDateTime, QTime knows nothing about time zones or     daylight savings time (DST).      A QTime object is typically created either by giving the number     of hours, minutes, seconds, and milliseconds explicitly, or by     using the static function currentTime(), which creates a QTime     object that contains the system's local time. Note that the     accuracy depends on the accuracy of the underlying operating     system; not all systems provide 1-millisecond accuracy.      The hour(), minute(), second(), and msec() functions provide     access to the number of hours, minutes, seconds, and milliseconds     of the time. The same information is provided in textual format by     the toString() function.      QTime provides a full set of operators to compare two QTime     objects. One time is considered smaller than another if it is     earlier than the other.      The time a given number of seconds or milliseconds later than a     given time can be found using the addSecs() or addMSecs()     functions. Correspondingly, the number of seconds or milliseconds     between two times can be found using secsTo() or msecsTo().      QTime can be used to measure a span of elapsed time using the     start(), restart(), and elapsed() functions.      \sa QDate, QDateTime */
end_comment
begin_comment
comment|/*!     \fn QTime::QTime()      Constructs a null time object. A null time can be a QTime(0, 0, 0, 0)     (i.e., midnight) object, except that isNull() returns true and isValid()     returns false.      \sa isNull(), isValid() */
end_comment
begin_comment
comment|/*!     Constructs a time with hour \a h, minute \a m, seconds \a s and     milliseconds \a ms.      \a h must be in the range 0 to 23, \a m and \a s must be in the     range 0 to 59, and \a ms must be in the range 0 to 999.      \sa isValid() */
end_comment
begin_constructor
DECL|function|QTime
name|QTime
operator|::
name|QTime
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
name|setHMS
argument_list|(
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn bool QTime::isNull() const      Returns true if the time is null (i.e., the QTime object was     constructed using the default constructor); otherwise returns     false. A null time is also an invalid time.      \sa isValid() */
end_comment
begin_comment
comment|/*!     Returns true if the time is valid; otherwise returns false. For example,     the time 23:30:55.746 is valid, but 24:12:30 is invalid.      \sa isNull() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QTime
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|mds
operator|>
name|NullTime
operator|&&
name|mds
operator|<
name|MSECS_PER_DAY
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the hour part (0 to 23) of the time.      Returns -1 if the time is invalid.      \sa minute(), second(), msec() */
end_comment
begin_function
DECL|function|hour
name|int
name|QTime
operator|::
name|hour
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ds
argument_list|()
operator|/
name|MSECS_PER_HOUR
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the minute part (0 to 59) of the time.      Returns -1 if the time is invalid.      \sa hour(), second(), msec() */
end_comment
begin_function
DECL|function|minute
name|int
name|QTime
operator|::
name|minute
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|ds
argument_list|()
operator|%
name|MSECS_PER_HOUR
operator|)
operator|/
name|MSECS_PER_MIN
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the second part (0 to 59) of the time.      Returns -1 if the time is invalid.      \sa hour(), minute(), msec() */
end_comment
begin_function
DECL|function|second
name|int
name|QTime
operator|::
name|second
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|ds
argument_list|()
operator|/
literal|1000
operator|)
operator|%
name|SECS_PER_MIN
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the millisecond part (0 to 999) of the time.      Returns -1 if the time is invalid.      \sa hour(), minute(), second() */
end_comment
begin_function
DECL|function|msec
name|int
name|QTime
operator|::
name|msec
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ds
argument_list|()
operator|%
literal|1000
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \overload      Returns the time as a string. Milliseconds are not included. The     \a format parameter determines the format of the string.      If \a format is Qt::TextDate, the string format is HH:MM:SS; e.g. 1     second before midnight would be "23:59:59".      If \a format is Qt::ISODate, the string format corresponds to the     ISO 8601 extended specification for representations of dates,     which is also HH:MM:SS. (However, contrary to ISO 8601, dates     before 15 October 1582 are handled as Julian dates, not Gregorian     dates. See \l{QDate G and J} {Use of Gregorian and Julian     Calendars}. This might change in a future version of Qt.)      If the \a format is Qt::SystemLocaleShortDate or     Qt::SystemLocaleLongDate, the string format depends on the locale     settings of the system. Identical to calling     QLocale::system().toString(time, QLocale::ShortFormat) or     QLocale::system().toString(time, QLocale::LongFormat).      If the \a format is Qt::DefaultLocaleShortDate or     Qt::DefaultLocaleLongDate, the string format depends on the     default application locale. This is the locale set with     QLocale::setDefault(), or the system locale if no default locale     has been set. Identical to calling QLocale().toString(time,     QLocale::ShortFormat) or QLocale().toString(time,     QLocale::LongFormat).      If the time is invalid, an empty string will be returned. */
end_comment
begin_function
DECL|function|toString
name|QString
name|QTime
operator|::
name|toString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|format
operator|==
name|Qt
operator|::
name|SystemLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|format
operator|==
name|Qt
operator|::
name|DefaultLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
default|default:
case|case
name|Qt
operator|::
name|ISODate
case|:
case|case
name|Qt
operator|::
name|TextDate
case|:
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1:%2:%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|hour
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|minute
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|second
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the time as a string. The \a format parameter determines     the format of the result string.      These expressions may be used:      \table     \header \li Expression \li Output     \row \li h          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li H          \li the hour without a leading zero (0 to 23, even with AM/PM display)     \row \li HH          \li the hour with a leading zero (00 to 23, even with AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP or A          \li use AM/PM display. \e AP will be replaced by either "AM" or "PM".     \row \li ap or a          \li use am/pm display. \e ap will be replaced by either "am" or "pm".     \row \li t \li the timezone (for example "CEST")     \endtable      All other input characters will be ignored. Any sequence of characters that     are enclosed in singlequotes will be treated as text and not be used as an     expression. Two consecutive singlequotes ("''") are replaced by a singlequote     in the output.      Example format strings (assuming that the QTime is 14:13:09.042)      \table     \header \li Format \li Result     \row \li hh:mm:ss.zzz \li 14:13:09.042     \row \li h:m:s ap     \li 2:13:9 pm     \row \li H:m:s a      \li 14:13:9 pm     \endtable      If the datetime is invalid, an empty string will be returned.     If \a format is empty, the default format "hh:mm:ss" is used.      \sa QDate::toString(), QDateTime::toString() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QTime
operator|::
name|toString
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
block|{
return|return
name|fmtDateTime
argument_list|(
name|format
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     Sets the time to hour \a h, minute \a m, seconds \a s and     milliseconds \a ms.      \a h must be in the range 0 to 23, \a m and \a s must be in the     range 0 to 59, and \a ms must be in the range 0 to 999.     Returns true if the set time is valid; otherwise returns false.      \sa isValid() */
end_comment
begin_function
DECL|function|setHMS
name|bool
name|QTime
operator|::
name|setHMS
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|startTick
operator|=
name|NullTime
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|isValid
argument_list|(
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|,
name|ms
argument_list|)
condition|)
block|{
name|mds
operator|=
name|NullTime
expr_stmt|;
comment|// make this invalid
return|return
literal|false
return|;
block|}
name|mds
operator|=
operator|(
name|h
operator|*
name|SECS_PER_HOUR
operator|+
name|m
operator|*
name|SECS_PER_MIN
operator|+
name|s
operator|)
operator|*
literal|1000
operator|+
name|ms
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QTime object containing a time \a s seconds later     than the time of this object (or earlier if \a s is negative).      Note that the time will wrap if it passes midnight.      Returns a null time if this time is invalid.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 5      \sa addMSecs(), secsTo(), QDateTime::addSecs() */
end_comment
begin_function
DECL|function|addSecs
name|QTime
name|QTime
operator|::
name|addSecs
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
return|return
name|addMSecs
argument_list|(
name|s
operator|*
literal|1000
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of seconds from this time to \a t.     If \a t is earlier than this time, the number of seconds returned     is negative.      Because QTime measures time within a day and there are 86400     seconds in a day, the result is always between -86400 and 86400.      secsTo() does not take into account any milliseconds.      Returns 0 if either time is invalid.      \sa addSecs(), QDateTime::secsTo() */
end_comment
begin_function
DECL|function|secsTo
name|int
name|QTime
operator|::
name|secsTo
parameter_list|(
specifier|const
name|QTime
modifier|&
name|t
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|t
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|t
operator|.
name|ds
argument_list|()
operator|-
name|ds
argument_list|()
operator|)
operator|/
literal|1000
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QTime object containing a time \a ms milliseconds later     than the time of this object (or earlier if \a ms is negative).      Note that the time will wrap if it passes midnight. See addSecs()     for an example.      Returns a null time if this time is invalid.      \sa addSecs(), msecsTo(), QDateTime::addMSecs() */
end_comment
begin_function
DECL|function|addMSecs
name|QTime
name|QTime
operator|::
name|addMSecs
parameter_list|(
name|int
name|ms
parameter_list|)
specifier|const
block|{
name|QTime
name|t
decl_stmt|;
if|if
condition|(
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|ms
operator|<
literal|0
condition|)
block|{
comment|// % not well-defined for -ve, but / is.
name|int
name|negdays
init|=
operator|(
name|MSECS_PER_DAY
operator|-
name|ms
operator|)
operator|/
name|MSECS_PER_DAY
decl_stmt|;
name|t
operator|.
name|mds
operator|=
operator|(
name|ds
argument_list|()
operator|+
name|ms
operator|+
name|negdays
operator|*
name|MSECS_PER_DAY
operator|)
operator|%
name|MSECS_PER_DAY
expr_stmt|;
block|}
else|else
block|{
name|t
operator|.
name|mds
operator|=
operator|(
name|ds
argument_list|()
operator|+
name|ms
operator|)
operator|%
name|MSECS_PER_DAY
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
name|startTick
operator|>
name|NullTime
condition|)
name|t
operator|.
name|startTick
operator|=
operator|(
name|startTick
operator|+
name|ms
operator|)
operator|%
name|MSECS_PER_DAY
expr_stmt|;
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of milliseconds from this time to \a t.     If \a t is earlier than this time, the number of milliseconds returned     is negative.      Because QTime measures time within a day and there are 86400     seconds in a day, the result is always between -86400000 and     86400000 ms.      Returns 0 if either time is invalid.      \sa secsTo(), addMSecs(), QDateTime::msecsTo() */
end_comment
begin_function
DECL|function|msecsTo
name|int
name|QTime
operator|::
name|msecsTo
parameter_list|(
specifier|const
name|QTime
modifier|&
name|t
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|t
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
comment|// GetLocalTime() for Windows CE has no milliseconds resolution
if|if
condition|(
name|t
operator|.
name|startTick
operator|>
name|NullTime
operator|&&
name|startTick
operator|>
name|NullTime
condition|)
return|return
name|t
operator|.
name|startTick
operator|-
name|startTick
return|;
else|else
endif|#
directive|endif
return|return
name|t
operator|.
name|ds
argument_list|()
operator|-
name|ds
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTime::operator==(const QTime&t) const      Returns true if this time is equal to \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator!=(const QTime&t) const      Returns true if this time is different from \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator<(const QTime&t) const      Returns true if this time is earlier than \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator<=(const QTime&t) const      Returns true if this time is earlier than or equal to \a t;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator>(const QTime&t) const      Returns true if this time is later than \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator>=(const QTime&t) const      Returns true if this time is later than or equal to \a t;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QTime::currentTime()      Returns the current time as reported by the system clock.      Note that the accuracy depends on the accuracy of the underlying     operating system; not all systems provide 1-millisecond accuracy. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|// These anonymous functions tidy up QDateTime::fromString()
end_comment
begin_comment
comment|// and avoid confusion of responsibility between it and QTime::fromString().
end_comment
begin_namespace
namespace|namespace
block|{
DECL|function|isMidnight
specifier|inline
name|bool
name|isMidnight
parameter_list|(
name|int
name|hour
parameter_list|,
name|int
name|minute
parameter_list|,
name|int
name|second
parameter_list|,
name|int
name|msec
parameter_list|)
block|{
return|return
name|hour
operator|==
literal|24
operator|&&
name|minute
operator|==
literal|0
operator|&&
name|second
operator|==
literal|0
operator|&&
name|msec
operator|==
literal|0
return|;
block|}
DECL|function|fromStringImpl
name|QTime
name|fromStringImpl
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|f
parameter_list|,
name|bool
modifier|&
name|isMidnight24
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Return a null time.
return|return
name|QTime
argument_list|()
return|;
block|}
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
block|{
name|QLocale
operator|::
name|FormatType
name|formatType
argument_list|(
name|Qt
operator|::
name|SystemLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
decl_stmt|;
return|return
name|QTime
operator|::
name|fromString
argument_list|(
name|s
argument_list|,
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|timeFormat
argument_list|(
name|formatType
argument_list|)
argument_list|)
return|;
block|}
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
block|{
name|QLocale
operator|::
name|FormatType
name|formatType
argument_list|(
name|f
operator|==
name|Qt
operator|::
name|DefaultLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
decl_stmt|;
return|return
name|QTime
operator|::
name|fromString
argument_list|(
name|s
argument_list|,
name|QLocale
argument_list|()
operator|.
name|timeFormat
argument_list|(
name|formatType
argument_list|)
argument_list|)
return|;
block|}
case|case
name|Qt
operator|::
name|TextDate
case|:
case|case
name|Qt
operator|::
name|ISODate
case|:
block|{
name|bool
name|ok
init|=
literal|true
decl_stmt|;
specifier|const
name|int
name|hour
argument_list|(
name|s
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
specifier|const
name|int
name|minute
argument_list|(
name|s
operator|.
name|mid
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
if|if
condition|(
name|f
operator|==
name|Qt
operator|::
name|ISODate
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|size
argument_list|()
operator|==
literal|5
condition|)
block|{
comment|// Do not need to specify seconds if using ISO format.
return|return
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|s
operator|.
name|size
argument_list|()
operator|>
literal|6
operator|&&
name|s
index|[
literal|5
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|)
operator|||
name|s
index|[
literal|5
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
condition|)
block|{
comment|// Possibly specifying fraction of a minute.
comment|// We only want 5 digits worth of fraction of minute. This follows the existing
comment|// behaviour that determines how milliseconds are read; 4 millisecond digits are
comment|// read and then rounded to 3. If we read at most 5 digits for fraction of minute,
comment|// the maximum amount of millisecond digits it will expand to once converted to
comment|// seconds is 4. E.g. 12:34,99999 will expand to 12:34:59.9994. The milliseconds
comment|// will then be rounded up AND clamped to 999.
specifier|const
name|QString
name|minuteFractionStr
argument_list|(
name|QLatin1String
argument_list|(
literal|"0."
argument_list|)
operator|+
name|s
operator|.
name|mid
argument_list|(
literal|6
argument_list|,
literal|5
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|float
name|minuteFraction
init|=
name|minuteFractionStr
operator|.
name|toFloat
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
specifier|const
name|float
name|secondWithMs
init|=
name|minuteFraction
operator|*
literal|60
decl_stmt|;
specifier|const
name|float
name|second
init|=
name|std
operator|::
name|floor
argument_list|(
name|secondWithMs
argument_list|)
decl_stmt|;
specifier|const
name|float
name|millisecond
init|=
literal|1000
operator|*
operator|(
name|secondWithMs
operator|-
name|second
operator|)
decl_stmt|;
specifier|const
name|int
name|millisecondRounded
init|=
name|qMin
argument_list|(
name|qRound
argument_list|(
name|millisecond
argument_list|)
argument_list|,
literal|999
argument_list|)
decl_stmt|;
if|if
condition|(
name|isMidnight
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|millisecondRounded
argument_list|)
condition|)
block|{
name|isMidnight24
operator|=
literal|true
expr_stmt|;
return|return
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|millisecondRounded
argument_list|)
return|;
block|}
block|}
specifier|const
name|int
name|second
argument_list|(
name|s
operator|.
name|mid
argument_list|(
literal|6
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
specifier|const
name|QString
name|msec_s
argument_list|(
name|QLatin1String
argument_list|(
literal|"0."
argument_list|)
operator|+
name|s
operator|.
name|mid
argument_list|(
literal|9
argument_list|,
literal|4
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|double
name|msec
argument_list|(
name|msec_s
operator|.
name|toDouble
argument_list|(
operator|&
name|ok
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|f
operator|==
name|Qt
operator|::
name|ISODate
condition|)
block|{
if|if
condition|(
name|isMidnight
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|msec
argument_list|)
condition|)
block|{
name|isMidnight24
operator|=
literal|true
expr_stmt|;
return|return
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
return|return
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|qMin
argument_list|(
name|qRound
argument_list|(
name|msec
operator|*
literal|1000.0
argument_list|)
argument_list|,
literal|999
argument_list|)
argument_list|)
return|;
block|}
block|}
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|QTime
argument_list|()
return|;
block|}
block|}
end_namespace
begin_comment
comment|/*!     \fn QTime QTime::fromString(const QString&string, Qt::DateFormat format)      Returns the time represented in the \a string as a QTime using the     \a format given, or an invalid time if this is not possible.      Note that fromString() uses a "C" locale encoded string to convert     milliseconds to a float value. If the default locale is not "C",     this may result in two conversion attempts (if the conversion     fails for the default locale). This should be considered an     implementation detail. */
end_comment
begin_function
DECL|function|fromString
name|QTime
name|QTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|f
parameter_list|)
block|{
name|bool
name|unused
decl_stmt|;
return|return
name|fromStringImpl
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|unused
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTime::fromString(const QString&string, const QString&format)      Returns the QTime represented by the \a string, using the \a     format given, or an invalid time if the string cannot be parsed.      These expressions may be used for the format:      \table     \header \li Expression \li Output     \row \li h          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP          \li interpret as an AM/PM time. \e AP must be either "AM" or "PM".     \row \li ap          \li Interpret as an AM/PM time. \e ap must be either "am" or "pm".     \endtable      All other input characters will be treated as text. Any sequence     of characters that are enclosed in single quotes will also be     treated as text and not be used as an expression.      \snippet code/src_corelib_tools_qdatetime.cpp 6      If the format is not satisfied an invalid QTime is returned.     Expressions that do not expect leading zeroes to be given (h, m, s     and z) are greedy. This means that they will use two digits even if     this puts them outside the range of accepted values and leaves too     few digits for other sections. For example, the following string     could have meant 00:07:10, but the m will grab two digits, resulting     in an invalid time:      \snippet code/src_corelib_tools_qdatetime.cpp 7      Any field that is not represented in the format will be set to zero.     For example:      \snippet code/src_corelib_tools_qdatetime.cpp 8      \sa QDateTime::fromString(), QDate::fromString(), QDate::toString(),     QDateTime::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|fromString
name|QTime
name|QTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
name|QTime
name|time
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QDateTimeParser
name|dt
argument_list|(
name|QVariant
operator|::
name|Time
argument_list|,
name|QDateTimeParser
operator|::
name|FromString
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|parseFormat
argument_list|(
name|format
argument_list|)
condition|)
name|dt
operator|.
name|fromString
argument_list|(
name|string
argument_list|,
literal|0
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|time
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \overload      Returns true if the specified time is valid; otherwise returns     false.      The time is valid if \a h is in the range 0 to 23, \a m and     \a s are in the range 0 to 59, and \a ms is in the range 0 to 999.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 9 */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QTime
operator|::
name|isValid
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
return|return
operator|(
name|uint
operator|)
name|h
operator|<
literal|24
operator|&&
operator|(
name|uint
operator|)
name|m
operator|<
literal|60
operator|&&
operator|(
name|uint
operator|)
name|s
operator|<
literal|60
operator|&&
operator|(
name|uint
operator|)
name|ms
operator|<
literal|1000
return|;
block|}
end_function
begin_comment
comment|/*!     Sets this time to the current time. This is practical for timing:      \snippet code/src_corelib_tools_qdatetime.cpp 10      \sa restart(), elapsed(), currentTime() */
end_comment
begin_function
DECL|function|start
name|void
name|QTime
operator|::
name|start
parameter_list|()
block|{
operator|*
name|this
operator|=
name|currentTime
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets this time to the current time and returns the number of     milliseconds that have elapsed since the last time start() or     restart() was called.      This function is guaranteed to be atomic and is thus very handy     for repeated measurements. Call start() to start the first     measurement, and restart() for each later measurement.      Note that the counter wraps to zero 24 hours after the last call     to start() or restart().      \warning If the system's clock setting has been changed since the     last time start() or restart() was called, the result is     undefined. This can happen when daylight savings time is turned on     or off.      \sa start(), elapsed(), currentTime() */
end_comment
begin_function
DECL|function|restart
name|int
name|QTime
operator|::
name|restart
parameter_list|()
block|{
name|QTime
name|t
init|=
name|currentTime
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|msecsTo
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|// passed midnight
name|n
operator|+=
literal|86400
operator|*
literal|1000
expr_stmt|;
operator|*
name|this
operator|=
name|t
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of milliseconds that have elapsed since the     last time start() or restart() was called.      Note that the counter wraps to zero 24 hours after the last call     to start() or restart.      Note that the accuracy depends on the accuracy of the underlying     operating system; not all systems provide 1-millisecond accuracy.      \warning If the system's clock setting has been changed since the     last time start() or restart() was called, the result is     undefined. This can happen when daylight savings time is turned on     or off.      \sa start(), restart() */
end_comment
begin_function
DECL|function|elapsed
name|int
name|QTime
operator|::
name|elapsed
parameter_list|()
specifier|const
block|{
name|int
name|n
init|=
name|msecsTo
argument_list|(
name|currentTime
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|// passed midnight
name|n
operator|+=
literal|86400
operator|*
literal|1000
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QDateTime member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QDateTime     \reentrant     \brief The QDateTime class provides date and time functions.       A QDateTime object contains a calendar date and a clock time (a     "datetime"). It is a combination of the QDate and QTime classes.     It can read the current datetime from the system clock. It     provides functions for comparing datetimes and for manipulating a     datetime by adding a number of seconds, days, months, or years.      A QDateTime object is typically created either by giving a date     and time explicitly in the constructor, or by using the static     function currentDateTime() that returns a QDateTime object set     to the system clock's time. The date and time can be changed with     setDate() and setTime(). A datetime can also be set using the     setTime_t() function that takes a POSIX-standard "number of     seconds since 00:00:00 on January 1, 1970" value. The fromString()     function returns a QDateTime, given a string and a date format     used to interpret the date within the string.      The date() and time() functions provide access to the date and     time parts of the datetime. The same information is provided in     textual format by the toString() function.      QDateTime provides a full set of operators to compare two     QDateTime objects where smaller means earlier and larger means     later.      You can increment (or decrement) a datetime by a given number of     milliseconds using addMSecs(), seconds using addSecs(), or days     using addDays(). Similarly you can use addMonths() and addYears().     The daysTo() function returns the number of days between two datetimes,     secsTo() returns the number of seconds between two datetimes, and     msecsTo() returns the number of milliseconds between two datetimes.      QDateTime can store datetimes as \l{Qt::LocalTime}{local time} or     as \l{Qt::UTC}{UTC}. QDateTime::currentDateTime() returns a     QDateTime expressed as local time; use toUTC() to convert it to     UTC. You can also use timeSpec() to find out if a QDateTime     object stores a UTC time or a local time. Operations such as     addSecs() and secsTo() are aware of daylight saving time (DST).      \note QDateTime does not account for leap seconds.      \section1      \section2 No Year 0      There is no year 0. Dates in that year are considered invalid. The     year -1 is the year "1 before Christ" or "1 before current era."     The day before 1 January 1 CE is 31 December 1 BCE.      \section2 Range of Valid Dates      Dates are stored internally as a Julian Day number, an interger count of     every day in a contiguous range, with 24 November 4714 BCE in the Gregorian     calendar being Julian Day 0 (1 January 4713 BCE in the Julian calendar).     As well as being an efficient and accurate way of storing an absolute date,     it is suitable for converting a Date into other calendar systems such as     Hebrew, Islamic or Chinese. The Julian Day number can be obtained using     QDate::toJulianDay() and can be set using QDate::fromJulianDay().      The range of dates able to be stored by QDate as a Julian Day number is     limited for convenience from std::numeric_limits<qint64>::min() / 2 to     std::numeric_limits<qint64>::max() / 2, which on most platforms means     from around 2.5 quadrillion BCE to around 2.5 quadrillion CE, effectively     covering the full range of astronomical time. The range of Julian Days     able to be accurately converted to and from valid YMD form Dates is     restricted to 1 January 4800 BCE to 31 December 1400000 CE due to     shortcomings in the available conversion formulas. Conversions outside this     range are not guaranteed to be correct. This may change in the future.      \section2     Use of System Timezone      QDateTime uses the system's time zone information to determine the     offset of local time from UTC. If the system is not configured     correctly or not up-to-date, QDateTime will give wrong results as     well.      \section2 Daylight Savings Time (DST)      QDateTime takes into account the system's time zone information     when dealing with DST. On modern Unix systems, this means it     applies the correct historical DST data whenever possible. On     Windows and Windows CE, where the system doesn't support     historical DST data, historical accuracy is not maintained with     respect to DST.      The range of valid dates taking DST into account is 1970-01-01 to     the present, and rules are in place for handling DST correctly     until 2037-12-31, but these could change. For dates falling     outside that range, QDateTime makes a \e{best guess} using the     rules for year 1970 or 2037, but we can't guarantee accuracy. This     means QDateTime doesn't take into account changes in a locale's     time zone before 1970, even if the system's time zone database     supports that information.      \sa QDate, QTime, QDateTimeEdit */
end_comment
begin_comment
comment|/*!     Constructs a null datetime (i.e. null date and null time). A null     datetime is invalid, since the date is invalid.      \sa isValid() */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a datetime with the given \a date, a valid     time(00:00:00.000), and sets the timeSpec() to Qt::LocalTime. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|)
block|{
name|d
operator|->
name|date
operator|=
name|date
expr_stmt|;
name|d
operator|->
name|time
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a datetime with the given \a date and \a time, using     the time specification defined by \a spec.      If \a date is valid and \a time is not, the time will be set to midnight. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|)
block|{
name|d
operator|->
name|date
operator|=
name|date
expr_stmt|;
name|d
operator|->
name|time
operator|=
name|date
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|time
operator|.
name|isValid
argument_list|()
condition|?
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
else|:
name|time
expr_stmt|;
name|d
operator|->
name|spec
operator|=
operator|(
name|spec
operator|==
name|Qt
operator|::
name|UTC
operator|)
condition|?
name|QDateTimePrivate
operator|::
name|UTC
else|:
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of the \a other datetime. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the datetime. */
end_comment
begin_destructor
DECL|function|~QDateTime
name|QDateTime
operator|::
name|~
name|QDateTime
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Makes a copy of the \a other datetime and returns a reference to the     copy. */
end_comment
begin_function
DECL|function|operator =
name|QDateTime
modifier|&
name|QDateTime
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QDateTime::swap(QDateTime&other)     \since 5.0      Swaps this date-time with \a other. This operation is very fast     and never fails. */
end_comment
begin_comment
comment|/*!     Returns true if both the date and the time are null; otherwise     returns false. A null datetime is invalid.      \sa QDate::isNull(), QTime::isNull(), isValid() */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QDateTime
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|date
operator|.
name|isNull
argument_list|()
operator|&&
name|d
operator|->
name|time
operator|.
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if both the date and the time are valid; otherwise     returns false.      \sa QDate::isValid(), QTime::isValid() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QDateTime
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|date
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|time
operator|.
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the date part of the datetime.      \sa setDate(), time(), timeSpec() */
end_comment
begin_function
DECL|function|date
name|QDate
name|QDateTime
operator|::
name|date
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|date
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the time part of the datetime.      \sa setTime(), date(), timeSpec() */
end_comment
begin_function
DECL|function|time
name|QTime
name|QDateTime
operator|::
name|time
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|time
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the time specification of the datetime.      \sa setTimeSpec(), date(), time(), Qt::TimeSpec */
end_comment
begin_function
DECL|function|timeSpec
name|Qt
operator|::
name|TimeSpec
name|QDateTime
operator|::
name|timeSpec
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|d
operator|->
name|spec
condition|)
block|{
case|case
name|QDateTimePrivate
operator|::
name|UTC
case|:
return|return
name|Qt
operator|::
name|UTC
return|;
case|case
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
case|:
return|return
name|Qt
operator|::
name|OffsetFromUTC
return|;
default|default:
return|return
name|Qt
operator|::
name|LocalTime
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Sets the date part of this datetime to \a date.     If no time is set, it is set to midnight.      \sa date(), setTime(), setTimeSpec() */
end_comment
begin_function
DECL|function|setDate
name|void
name|QDateTime
operator|::
name|setDate
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|date
operator|=
name|date
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|LocalStandard
operator|||
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|LocalDST
condition|)
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
if|if
condition|(
name|date
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|time
operator|.
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|time
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the time part of this datetime to \a time.      \sa time(), setDate(), setTimeSpec() */
end_comment
begin_function
DECL|function|setTime
name|void
name|QDateTime
operator|::
name|setTime
parameter_list|(
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|LocalStandard
operator|||
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|LocalDST
condition|)
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
name|d
operator|->
name|time
operator|=
name|time
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the time specification used in this datetime to \a spec.      \sa timeSpec(), setDate(), setTime(), Qt::TimeSpec */
end_comment
begin_function
DECL|function|setTimeSpec
name|void
name|QDateTime
operator|::
name|setTimeSpec
parameter_list|(
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|spec
condition|)
block|{
case|case
name|Qt
operator|::
name|UTC
case|:
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
expr_stmt|;
break|break;
default|default:
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|toMSecsSinceEpoch_helper
name|qint64
name|toMSecsSinceEpoch_helper
parameter_list|(
name|qint64
name|jd
parameter_list|,
name|int
name|msecs
parameter_list|)
block|{
name|qint64
name|days
init|=
name|jd
operator|-
name|JULIAN_DAY_FOR_EPOCH
decl_stmt|;
name|qint64
name|retval
init|=
operator|(
name|days
operator|*
name|MSECS_PER_DAY
operator|)
operator|+
name|msecs
decl_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the datetime as the number of milliseconds that have passed     since 1970-01-01T00:00:00.000, Coordinated Universal Time (Qt::UTC).      On systems that do not support time zones, this function will     behave as if local time were Qt::UTC.      The behavior for this function is undefined if the datetime stored in     this object is not valid. However, for all valid dates, this function     returns a unique value.      \sa toTime_t(), setMSecsSinceEpoch() */
end_comment
begin_function
DECL|function|toMSecsSinceEpoch
name|qint64
name|QDateTime
operator|::
name|toMSecsSinceEpoch
parameter_list|()
specifier|const
block|{
name|QDate
name|utcDate
decl_stmt|;
name|QTime
name|utcTime
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|utcDate
argument_list|,
name|utcTime
argument_list|)
expr_stmt|;
return|return
name|toMSecsSinceEpoch_helper
argument_list|(
name|utcDate
operator|.
name|toJulianDay
argument_list|()
argument_list|,
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|msecsTo
argument_list|(
name|utcTime
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the datetime as the number of seconds that have passed     since 1970-01-01T00:00:00, Coordinated Universal Time (Qt::UTC).      On systems that do not support time zones, this function will     behave as if local time were Qt::UTC.      \note This function returns a 32-bit unsigned integer, so it does not     support dates before 1970, but it does support dates after     2038-01-19T03:14:06, which may not be valid time_t values. Be careful     when passing those time_t values to system functions, which could     interpret them as negative dates.      If the date is outside the range 1970-01-01T00:00:00 to     2106-02-07T06:28:14, this function returns -1 cast to an unsigned integer     (i.e., 0xFFFFFFFF).      To get an extended range, use toMSecsSinceEpoch().      \sa toMSecsSinceEpoch(), setTime_t() */
end_comment
begin_function
DECL|function|toTime_t
name|uint
name|QDateTime
operator|::
name|toTime_t
parameter_list|()
specifier|const
block|{
name|qint64
name|retval
init|=
name|toMSecsSinceEpoch
argument_list|()
operator|/
literal|1000
decl_stmt|;
if|if
condition|(
name|quint64
argument_list|(
name|retval
argument_list|)
operator|>=
name|Q_UINT64_C
argument_list|(
literal|0xFFFFFFFF
argument_list|)
condition|)
return|return
name|uint
argument_list|(
operator|-
literal|1
argument_list|)
return|;
return|return
name|uint
argument_list|(
name|retval
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Sets the date and time given the number of milliseconds,\a msecs, that have     passed since 1970-01-01T00:00:00.000, Coordinated Universal Time     (Qt::UTC). On systems that do not support time zones this function     will behave as if local time were Qt::UTC.      Note that there are possible values for \a msecs that lie outside the     valid range of QDateTime, both negative and positive. The behavior of     this function is undefined for those values.      \sa toMSecsSinceEpoch(), setTime_t() */
end_comment
begin_function
DECL|function|setMSecsSinceEpoch
name|void
name|QDateTime
operator|::
name|setMSecsSinceEpoch
parameter_list|(
name|qint64
name|msecs
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|QDateTimePrivate
operator|::
name|Spec
name|oldSpec
init|=
name|d
operator|->
name|spec
decl_stmt|;
name|int
name|ddays
init|=
name|msecs
operator|/
name|MSECS_PER_DAY
decl_stmt|;
name|msecs
operator|%=
name|MSECS_PER_DAY
expr_stmt|;
if|if
condition|(
name|msecs
operator|<
literal|0
condition|)
block|{
comment|// negative
operator|--
name|ddays
expr_stmt|;
name|msecs
operator|+=
name|MSECS_PER_DAY
expr_stmt|;
block|}
name|d
operator|->
name|date
operator|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|.
name|addDays
argument_list|(
name|ddays
argument_list|)
expr_stmt|;
name|d
operator|->
name|time
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|addMSecs
argument_list|(
name|msecs
argument_list|)
expr_stmt|;
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
if|if
condition|(
name|oldSpec
operator|!=
name|QDateTimePrivate
operator|::
name|UTC
condition|)
name|d
operator|->
name|spec
operator|=
name|d
operator|->
name|getLocal
argument_list|(
name|d
operator|->
name|date
argument_list|,
name|d
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QDateTime::setTime_t(uint seconds)      Sets the date and time given the number of \a seconds that have     passed since 1970-01-01T00:00:00, Coordinated Universal Time     (Qt::UTC). On systems that do not support time zones this function     will behave as if local time were Qt::UTC.      \sa toTime_t() */
end_comment
begin_function
DECL|function|setTime_t
name|void
name|QDateTime
operator|::
name|setTime_t
parameter_list|(
name|uint
name|secsSince1Jan1970UTC
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|QDateTimePrivate
operator|::
name|Spec
name|oldSpec
init|=
name|d
operator|->
name|spec
decl_stmt|;
name|d
operator|->
name|date
operator|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|.
name|addDays
argument_list|(
name|secsSince1Jan1970UTC
operator|/
name|SECS_PER_DAY
argument_list|)
expr_stmt|;
name|d
operator|->
name|time
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|addSecs
argument_list|(
name|secsSince1Jan1970UTC
operator|%
name|SECS_PER_DAY
argument_list|)
expr_stmt|;
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
if|if
condition|(
name|oldSpec
operator|!=
name|QDateTimePrivate
operator|::
name|UTC
condition|)
name|d
operator|->
name|spec
operator|=
name|d
operator|->
name|getLocal
argument_list|(
name|d
operator|->
name|date
argument_list|,
name|d
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \fn QString QDateTime::toString(Qt::DateFormat format) const      \overload      Returns the datetime as a string in the \a format given.      If the \a format is Qt::TextDate, the string is formatted in     the default way. QDate::shortDayName(), QDate::shortMonthName(),     and QTime::toString() are used to generate the string, so the     day and month names will be localized names. An example of this     formatting is "Wed May 20 03:40:13 1998".      If the \a format is Qt::ISODate, the string format corresponds     to the ISO 8601 extended specification for representations of     dates and times, taking the form YYYY-MM-DDTHH:MM:SS[Z|[+|-]HH:MM],     depending on the timeSpec() of the QDateTime. If the timeSpec()     is Qt::UTC, Z will be appended to the string; if the timeSpec() is     Qt::OffsetFromUTC the offset in hours and minutes from UTC will     be appended to the string.      If the \a format is Qt::SystemLocaleShortDate or     Qt::SystemLocaleLongDate, the string format depends on the locale     settings of the system. Identical to calling     QLocale::system().toString(datetime, QLocale::ShortFormat) or     QLocale::system().toString(datetime, QLocale::LongFormat).      If the \a format is Qt::DefaultLocaleShortDate or     Qt::DefaultLocaleLongDate, the string format depends on the     default application locale. This is the locale set with     QLocale::setDefault(), or the system locale if no default locale     has been set. Identical to calling QLocale().toString(datetime,     QLocale::ShortFormat) or QLocale().toString(datetime,     QLocale::LongFormat).      If the datetime is invalid, an empty string will be returned.      \warning The Qt::ISODate format is only valid for years in the     range 0 to 9999. This restriction may apply to locale-aware     formats as well, depending on the locale settings.      \sa QDate::toString(), QTime::toString(), Qt::DateFormat */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDateTime
operator|::
name|toString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|f
parameter_list|)
specifier|const
block|{
name|QString
name|buf
decl_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|buf
return|;
if|if
condition|(
name|f
operator|==
name|Qt
operator|::
name|ISODate
condition|)
block|{
name|buf
operator|=
name|d
operator|->
name|date
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// failed to convert
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|d
operator|->
name|time
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|spec
condition|)
block|{
case|case
name|QDateTimePrivate
operator|::
name|UTC
case|:
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
case|:
block|{
name|int
name|sign
init|=
name|d
operator|->
name|utcOffset
operator|>=
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1%2:%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|sign
operator|==
literal|1
condition|?
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
else|:
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|utcOffset
operator|*
name|sign
operator|/
name|SECS_PER_HOUR
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
operator|(
name|d
operator|->
name|utcOffset
operator|/
literal|60
operator|)
operator|%
literal|60
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
elseif|else
if|if
condition|(
name|f
operator|==
name|Qt
operator|::
name|TextDate
condition|)
block|{
ifndef|#
directive|ifndef
name|Q_OS_WIN
name|buf
operator|=
name|d
operator|->
name|date
operator|.
name|shortDayName
argument_list|(
name|d
operator|->
name|date
operator|.
name|dayOfWeek
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|d
operator|->
name|date
operator|.
name|shortMonthName
argument_list|(
name|d
operator|->
name|date
operator|.
name|month
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|d
operator|->
name|date
operator|.
name|day
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|wchar_t
name|out
index|[
literal|255
index|]
decl_stmt|;
name|GetLocaleInfo
argument_list|(
name|LOCALE_USER_DEFAULT
argument_list|,
name|LOCALE_ILDATE
argument_list|,
name|out
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|QString
name|winstr
init|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|out
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|winstr
operator|.
name|toInt
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|buf
operator|=
name|d
operator|->
name|date
operator|.
name|shortDayName
argument_list|(
name|d
operator|->
name|date
operator|.
name|dayOfWeek
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|d
operator|->
name|date
operator|.
name|day
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1String
argument_list|(
literal|". "
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|d
operator|->
name|date
operator|.
name|shortMonthName
argument_list|(
name|d
operator|->
name|date
operator|.
name|month
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|buf
operator|=
name|d
operator|->
name|date
operator|.
name|shortDayName
argument_list|(
name|d
operator|->
name|date
operator|.
name|dayOfWeek
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|d
operator|->
name|date
operator|.
name|shortMonthName
argument_list|(
name|d
operator|->
name|date
operator|.
name|month
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|d
operator|->
name|date
operator|.
name|day
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|d
operator|->
name|time
operator|.
name|toString
argument_list|()
expr_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|d
operator|->
name|date
operator|.
name|year
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|buf
operator|=
name|d
operator|->
name|date
operator|.
name|toString
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// failed to convert
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|d
operator|->
name|time
operator|.
name|toString
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the datetime as a string. The \a format parameter     determines the format of the result string.      These expressions may be used for the date:      \table     \header \li Expression \li Output     \row \li d \li the day as number without a leading zero (1 to 31)     \row \li dd \li the day as number with a leading zero (01 to 31)     \row \li ddd             \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').             Uses QDate::shortDayName().     \row \li dddd             \li the long localized day name (e.g. 'Monday' to 'Qt::Sunday').             Uses QDate::longDayName().     \row \li M \li the month as number without a leading zero (1-12)     \row \li MM \li the month as number with a leading zero (01-12)     \row \li MMM             \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').             Uses QDate::shortMonthName().     \row \li MMMM             \li the long localized month name (e.g. 'January' to 'December').             Uses QDate::longMonthName().     \row \li yy \li the year as two digit number (00-99)     \row \li yyyy \li the year as four digit number     \endtable      These expressions may be used for the time:      \table     \header \li Expression \li Output     \row \li h          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP             \li use AM/PM display. \e AP will be replaced by either "AM" or "PM".     \row \li ap             \li use am/pm display. \e ap will be replaced by either "am" or "pm".     \endtable      All other input characters will be ignored. Any sequence of characters that     are enclosed in singlequotes will be treated as text and not be used as an     expression. Two consecutive singlequotes ("''") are replaced by a singlequote     in the output.      Example format strings (assumed that the QDateTime is 21 May 2001     14:13:09):      \table     \header \li Format       \li Result     \row \li dd.MM.yyyy      \li 21.05.2001     \row \li ddd MMMM d yy   \li Tue May 21 01     \row \li hh:mm:ss.zzz    \li 14:13:09.042     \row \li h:m:s ap        \li 2:13:9 pm     \endtable      If the datetime is invalid, an empty string will be returned.      \sa QDate::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDateTime
operator|::
name|toString
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
block|{
return|return
name|fmtDateTime
argument_list|(
name|format
argument_list|,
operator|&
name|d
operator|->
name|time
argument_list|,
operator|&
name|d
operator|->
name|date
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a ndays days     later than the datetime of this object (or earlier if \a ndays is     negative).      \sa daysTo(), addMonths(), addYears(), addSecs() */
end_comment
begin_function
DECL|function|addDays
name|QDateTime
name|QDateTime
operator|::
name|addDays
parameter_list|(
name|qint64
name|ndays
parameter_list|)
specifier|const
block|{
return|return
name|QDateTime
argument_list|(
name|d
operator|->
name|date
operator|.
name|addDays
argument_list|(
name|ndays
argument_list|)
argument_list|,
name|d
operator|->
name|time
argument_list|,
name|timeSpec
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a nmonths months     later than the datetime of this object (or earlier if \a nmonths     is negative).      \sa daysTo(), addDays(), addYears(), addSecs() */
end_comment
begin_function
DECL|function|addMonths
name|QDateTime
name|QDateTime
operator|::
name|addMonths
parameter_list|(
name|int
name|nmonths
parameter_list|)
specifier|const
block|{
return|return
name|QDateTime
argument_list|(
name|d
operator|->
name|date
operator|.
name|addMonths
argument_list|(
name|nmonths
argument_list|)
argument_list|,
name|d
operator|->
name|time
argument_list|,
name|timeSpec
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a nyears years     later than the datetime of this object (or earlier if \a nyears is     negative).      \sa daysTo(), addDays(), addMonths(), addSecs() */
end_comment
begin_function
DECL|function|addYears
name|QDateTime
name|QDateTime
operator|::
name|addYears
parameter_list|(
name|int
name|nyears
parameter_list|)
specifier|const
block|{
return|return
name|QDateTime
argument_list|(
name|d
operator|->
name|date
operator|.
name|addYears
argument_list|(
name|nyears
argument_list|)
argument_list|,
name|d
operator|->
name|time
argument_list|,
name|timeSpec
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addMSecs
name|QDateTime
name|QDateTimePrivate
operator|::
name|addMSecs
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|dt
parameter_list|,
name|qint64
name|msecs
parameter_list|)
block|{
name|QDate
name|utcDate
decl_stmt|;
name|QTime
name|utcTime
decl_stmt|;
name|dt
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|utcDate
argument_list|,
name|utcTime
argument_list|)
expr_stmt|;
name|addMSecs
argument_list|(
name|utcDate
argument_list|,
name|utcTime
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|utcDate
argument_list|,
name|utcTime
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
operator|.
name|toTimeSpec
argument_list|(
name|dt
operator|.
name|timeSpec
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!  Adds \a msecs to utcDate and \a utcTime as appropriate. It is assumed that  utcDate and utcTime are adjusted to UTC.   \since 4.5  \internal  */
end_comment
begin_function
DECL|function|addMSecs
name|void
name|QDateTimePrivate
operator|::
name|addMSecs
parameter_list|(
name|QDate
modifier|&
name|utcDate
parameter_list|,
name|QTime
modifier|&
name|utcTime
parameter_list|,
name|qint64
name|msecs
parameter_list|)
block|{
name|qint64
name|dd
init|=
name|utcDate
operator|.
name|toJulianDay
argument_list|()
decl_stmt|;
name|int
name|tt
init|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|msecsTo
argument_list|(
name|utcTime
argument_list|)
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|msecs
operator|<
literal|0
condition|)
block|{
name|msecs
operator|=
operator|-
name|msecs
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|msecs
operator|>=
name|int
argument_list|(
name|MSECS_PER_DAY
argument_list|)
condition|)
block|{
name|dd
operator|+=
name|sign
operator|*
operator|(
name|msecs
operator|/
name|MSECS_PER_DAY
operator|)
expr_stmt|;
name|msecs
operator|%=
name|MSECS_PER_DAY
expr_stmt|;
block|}
name|tt
operator|+=
name|sign
operator|*
name|msecs
expr_stmt|;
if|if
condition|(
name|tt
operator|<
literal|0
condition|)
block|{
name|tt
operator|=
name|MSECS_PER_DAY
operator|-
name|tt
operator|-
literal|1
expr_stmt|;
name|dd
operator|-=
name|tt
operator|/
name|MSECS_PER_DAY
expr_stmt|;
name|tt
operator|=
name|tt
operator|%
name|MSECS_PER_DAY
expr_stmt|;
name|tt
operator|=
name|MSECS_PER_DAY
operator|-
name|tt
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tt
operator|>=
name|int
argument_list|(
name|MSECS_PER_DAY
argument_list|)
condition|)
block|{
name|dd
operator|+=
name|tt
operator|/
name|MSECS_PER_DAY
expr_stmt|;
name|tt
operator|=
name|tt
operator|%
name|MSECS_PER_DAY
expr_stmt|;
block|}
name|utcDate
operator|=
name|QDate
operator|::
name|fromJulianDay
argument_list|(
name|dd
argument_list|)
expr_stmt|;
name|utcTime
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|addMSecs
argument_list|(
name|tt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a s seconds     later than the datetime of this object (or earlier if \a s is     negative).      \sa addMSecs(), secsTo(), addDays(), addMonths(), addYears() */
end_comment
begin_function
DECL|function|addSecs
name|QDateTime
name|QDateTime
operator|::
name|addSecs
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|addMSecs
argument_list|(
operator|*
name|this
argument_list|,
name|qint64
argument_list|(
name|s
argument_list|)
operator|*
literal|1000
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a msecs miliseconds     later than the datetime of this object (or earlier if \a msecs is     negative).      \sa addSecs(), msecsTo(), addDays(), addMonths(), addYears() */
end_comment
begin_function
DECL|function|addMSecs
name|QDateTime
name|QDateTime
operator|::
name|addMSecs
parameter_list|(
name|qint64
name|msecs
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|addMSecs
argument_list|(
operator|*
name|this
argument_list|,
name|msecs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days from this datetime to the \a other     datetime. If the \a other datetime is earlier than this datetime,     the value returned is negative.      \sa addDays(), secsTo(), msecsTo() */
end_comment
begin_function
DECL|function|daysTo
name|qint64
name|QDateTime
operator|::
name|daysTo
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|date
operator|.
name|daysTo
argument_list|(
name|other
operator|.
name|d
operator|->
name|date
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of seconds from this datetime to the \a other     datetime. If the \a other datetime is earlier than this datetime,     the value returned is negative.      Before performing the comparison, the two datetimes are converted     to Qt::UTC to ensure that the result is correct if one of the two     datetimes has daylight saving time (DST) and the other doesn't.      Returns 0 if either time is invalid.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 11      \sa addSecs(), daysTo(), QTime::secsTo() */
end_comment
begin_function
DECL|function|secsTo
name|int
name|QDateTime
operator|::
name|secsTo
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|other
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|QDate
name|date1
decl_stmt|,
name|date2
decl_stmt|;
name|QTime
name|time1
decl_stmt|,
name|time2
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|date1
argument_list|,
name|time1
argument_list|)
expr_stmt|;
name|other
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|date2
argument_list|,
name|time2
argument_list|)
expr_stmt|;
return|return
operator|(
name|date1
operator|.
name|daysTo
argument_list|(
name|date2
argument_list|)
operator|*
name|SECS_PER_DAY
operator|)
operator|+
name|time1
operator|.
name|secsTo
argument_list|(
name|time2
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of milliseconds from this datetime to the \a other     datetime. If the \a other datetime is earlier than this datetime,     the value returned is negative.      Before performing the comparison, the two datetimes are converted     to Qt::UTC to ensure that the result is correct if one of the two     datetimes has daylight saving time (DST) and the other doesn't.      Returns 0 if either time is null.      \sa addMSecs(), daysTo(), QTime::msecsTo() */
end_comment
begin_function
DECL|function|msecsTo
name|qint64
name|QDateTime
operator|::
name|msecsTo
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|other
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|QDate
name|selfDate
decl_stmt|;
name|QDate
name|otherDate
decl_stmt|;
name|QTime
name|selfTime
decl_stmt|;
name|QTime
name|otherTime
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|selfDate
argument_list|,
name|selfTime
argument_list|)
expr_stmt|;
name|other
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|otherDate
argument_list|,
name|otherTime
argument_list|)
expr_stmt|;
return|return
operator|(
cast|static_cast
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|selfDate
operator|.
name|daysTo
argument_list|(
name|otherDate
argument_list|)
argument_list|)
operator|*
cast|static_cast
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|MSECS_PER_DAY
argument_list|)
operator|)
operator|+
cast|static_cast
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|selfTime
operator|.
name|msecsTo
argument_list|(
name|otherTime
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDateTime QDateTime::toTimeSpec(Qt::TimeSpec specification) const      Returns a copy of this datetime configured to use the given time     \a specification.      \sa timeSpec(), toUTC(), toLocalTime() */
end_comment
begin_function
DECL|function|toTimeSpec
name|QDateTime
name|QDateTime
operator|::
name|toTimeSpec
parameter_list|(
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|UTC
operator|)
operator|==
operator|(
name|spec
operator|==
name|Qt
operator|::
name|UTC
operator|)
condition|)
return|return
operator|*
name|this
return|;
name|QDateTime
name|ret
decl_stmt|;
if|if
condition|(
name|spec
operator|==
name|Qt
operator|::
name|UTC
condition|)
block|{
name|d
operator|->
name|getUTC
argument_list|(
name|ret
operator|.
name|d
operator|->
name|date
argument_list|,
name|ret
operator|.
name|d
operator|->
name|time
argument_list|)
expr_stmt|;
name|ret
operator|.
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|d
operator|->
name|spec
operator|=
name|d
operator|->
name|getLocal
argument_list|(
name|ret
operator|.
name|d
operator|->
name|date
argument_list|,
name|ret
operator|.
name|d
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this datetime is equal to the \a other datetime;     otherwise returns false.      \sa operator!=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QDateTime
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|other
operator|.
name|d
operator|->
name|spec
operator|&&
name|d
operator|->
name|utcOffset
operator|==
name|other
operator|.
name|d
operator|->
name|utcOffset
condition|)
return|return
name|d
operator|->
name|time
operator|==
name|other
operator|.
name|d
operator|->
name|time
operator|&&
name|d
operator|->
name|date
operator|==
name|other
operator|.
name|d
operator|->
name|date
return|;
else|else
block|{
name|QDate
name|date1
decl_stmt|,
name|date2
decl_stmt|;
name|QTime
name|time1
decl_stmt|,
name|time2
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|date1
argument_list|,
name|time1
argument_list|)
expr_stmt|;
name|other
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|date2
argument_list|,
name|time2
argument_list|)
expr_stmt|;
return|return
name|time1
operator|==
name|time2
operator|&&
name|date1
operator|==
name|date2
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn bool QDateTime::operator!=(const QDateTime&other) const      Returns true if this datetime is different from the \a other     datetime; otherwise returns false.      Two datetimes are different if either the date, the time, or the     time zone components are different.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns true if this datetime is earlier than the \a other     datetime; otherwise returns false. */
end_comment
begin_function
DECL|function|operator <
name|bool
name|QDateTime
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|other
operator|.
name|d
operator|->
name|spec
operator|&&
name|d
operator|->
name|spec
operator|!=
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|date
operator|!=
name|other
operator|.
name|d
operator|->
name|date
condition|)
return|return
name|d
operator|->
name|date
operator|<
name|other
operator|.
name|d
operator|->
name|date
return|;
return|return
name|d
operator|->
name|time
operator|<
name|other
operator|.
name|d
operator|->
name|time
return|;
block|}
else|else
block|{
name|QDate
name|date1
decl_stmt|,
name|date2
decl_stmt|;
name|QTime
name|time1
decl_stmt|,
name|time2
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|date1
argument_list|,
name|time1
argument_list|)
expr_stmt|;
name|other
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|date2
argument_list|,
name|time2
argument_list|)
expr_stmt|;
if|if
condition|(
name|date1
operator|!=
name|date2
condition|)
return|return
name|date1
operator|<
name|date2
return|;
return|return
name|time1
operator|<
name|time2
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn bool QDateTime::operator<=(const QDateTime&other) const      Returns true if this datetime is earlier than or equal to the     \a other datetime; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDateTime::operator>(const QDateTime&other) const      Returns true if this datetime is later than the \a other datetime;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDateTime::operator>=(const QDateTime&other) const      Returns true if this datetime is later than or equal to the     \a other datetime; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::currentDateTime()     Returns the current datetime, as reported by the system clock, in     the local time zone.      \sa currentDateTimeUtc(), QDate::currentDate(), QTime::currentTime(), toTimeSpec() */
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::currentDateTimeUtc()     \since 4.7     Returns the current datetime, as reported by the system clock, in     UTC.      \sa currentDateTime(), QDate::currentDate(), QTime::currentTime(), toTimeSpec() */
end_comment
begin_comment
comment|/*!     \fn qint64 QDateTime::currentMSecsSinceEpoch()     \since 4.7      Returns the number of milliseconds since 1970-01-01T00:00:00 Universal     Coordinated Time. This number is like the POSIX time_t variable, but     expressed in milliseconds instead.      \sa currentDateTime(), currentDateTimeUtc(), toTime_t(), toTimeSpec() */
end_comment
begin_function
DECL|function|msecsFromDecomposed
specifier|static
specifier|inline
name|uint
name|msecsFromDecomposed
parameter_list|(
name|int
name|hour
parameter_list|,
name|int
name|minute
parameter_list|,
name|int
name|sec
parameter_list|,
name|int
name|msec
init|=
literal|0
parameter_list|)
block|{
return|return
name|MSECS_PER_HOUR
operator|*
name|hour
operator|+
name|MSECS_PER_MIN
operator|*
name|minute
operator|+
literal|1000
operator|*
name|sec
operator|+
name|msec
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_function
DECL|function|currentDate
name|QDate
name|QDate
operator|::
name|currentDate
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetLocalTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|currentTime
name|QTime
name|QTime
operator|::
name|currentTime
parameter_list|()
block|{
name|QTime
name|ct
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetLocalTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|ct
operator|.
name|setHMS
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|ct
operator|.
name|startTick
operator|=
name|GetTickCount
argument_list|()
operator|%
name|MSECS_PER_DAY
expr_stmt|;
endif|#
directive|endif
return|return
name|ct
return|;
block|}
end_function
begin_function
DECL|function|currentDateTime
name|QDateTime
name|QDateTime
operator|::
name|currentDateTime
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetLocalTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
expr_stmt|;
name|t
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|d
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|currentDateTimeUtc
name|QDateTime
name|QDateTime
operator|::
name|currentDateTimeUtc
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetSystemTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
expr_stmt|;
name|t
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|d
argument_list|,
name|t
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|currentMSecsSinceEpoch
name|qint64
name|QDateTime
operator|::
name|currentMSecsSinceEpoch
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetSystemTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
return|return
name|msecsFromDecomposed
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
operator|+
name|qint64
argument_list|(
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
operator|-
name|julianDayFromDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|Q_INT64_C
argument_list|(
literal|86400000
argument_list|)
return|;
block|}
end_function
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
end_elif
begin_function
DECL|function|currentDate
name|QDate
name|QDate
operator|::
name|currentDate
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
comment|// posix compliant system
name|time_t
name|ltime
decl_stmt|;
name|time
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
name|struct
name|tm
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|tzset
argument_list|()
expr_stmt|;
name|struct
name|tm
name|res
decl_stmt|;
name|t
operator|=
name|localtime_r
argument_list|(
operator|&
name|ltime
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_THREAD&& _POSIX_THREAD_SAFE_FUNCTIONS
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|currentTime
name|QTime
name|QTime
operator|::
name|currentTime
parameter_list|()
block|{
name|QTime
name|ct
decl_stmt|;
comment|// posix compliant system
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|time_t
name|ltime
init|=
name|tv
operator|.
name|tv_sec
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|tzset
argument_list|()
expr_stmt|;
name|struct
name|tm
name|res
decl_stmt|;
name|t
operator|=
name|localtime_r
argument_list|(
operator|&
name|ltime
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_CHECK_PTR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ct
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|,
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
return|return
name|ct
return|;
block|}
end_function
begin_function
DECL|function|currentDateTime
name|QDateTime
name|QDateTime
operator|::
name|currentDateTime
parameter_list|()
block|{
comment|// posix compliant system
comment|// we have milliseconds
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|time_t
name|ltime
init|=
name|tv
operator|.
name|tv_sec
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|tzset
argument_list|()
expr_stmt|;
name|struct
name|tm
name|res
decl_stmt|;
name|t
operator|=
name|localtime_r
argument_list|(
operator|&
name|ltime
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QDateTime
name|dt
decl_stmt|;
name|dt
operator|.
name|d
operator|->
name|time
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|,
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|date
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|spec
operator|=
name|t
operator|->
name|tm_isdst
operator|>
literal|0
condition|?
name|QDateTimePrivate
operator|::
name|LocalDST
else|:
name|t
operator|->
name|tm_isdst
operator|==
literal|0
condition|?
name|QDateTimePrivate
operator|::
name|LocalStandard
else|:
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_function
DECL|function|currentDateTimeUtc
name|QDateTime
name|QDateTime
operator|::
name|currentDateTimeUtc
parameter_list|()
block|{
comment|// posix compliant system
comment|// we have milliseconds
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|time_t
name|ltime
init|=
name|tv
operator|.
name|tv_sec
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|struct
name|tm
name|res
decl_stmt|;
name|t
operator|=
name|gmtime_r
argument_list|(
operator|&
name|ltime
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QDateTime
name|dt
decl_stmt|;
name|dt
operator|.
name|d
operator|->
name|time
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|,
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|date
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_function
DECL|function|currentMSecsSinceEpoch
name|qint64
name|QDateTime
operator|::
name|currentMSecsSinceEpoch
parameter_list|()
block|{
comment|// posix compliant system
comment|// we have milliseconds
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|qint64
argument_list|(
name|tv
operator|.
name|tv_sec
argument_list|)
operator|*
name|Q_INT64_C
argument_list|(
literal|1000
argument_list|)
operator|+
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
literal|"What system is this?"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \since 4.2    Returns a datetime whose date and time are the number of \a seconds   that have passed since 1970-01-01T00:00:00, Coordinated Universal   Time (Qt::UTC). On systems that do not support time zones, the time   will be set as if local time were Qt::UTC.    \sa toTime_t(), setTime_t() */
end_comment
begin_function
DECL|function|fromTime_t
name|QDateTime
name|QDateTime
operator|::
name|fromTime_t
parameter_list|(
name|uint
name|seconds
parameter_list|)
block|{
name|QDateTime
name|d
decl_stmt|;
name|d
operator|.
name|setTime_t
argument_list|(
name|seconds
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.7    Returns a datetime whose date and time are the number of milliseconds, \a msecs,   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal   Time (Qt::UTC). On systems that do not support time zones, the time   will be set as if local time were Qt::UTC.    Note that there are possible values for \a msecs that lie outside the valid   range of QDateTime, both negative and positive. The behavior of this   function is undefined for those values.    \sa toTime_t(), setTime_t() */
end_comment
begin_function
DECL|function|fromMSecsSinceEpoch
name|QDateTime
name|QDateTime
operator|::
name|fromMSecsSinceEpoch
parameter_list|(
name|qint64
name|msecs
parameter_list|)
block|{
name|QDateTime
name|d
decl_stmt|;
name|d
operator|.
name|setMSecsSinceEpoch
argument_list|(
name|msecs
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|/*!  \since 4.4  \internal   Sets the offset from UTC to \a seconds, and also sets timeSpec() to  Qt::OffsetFromUTC.   The maximum and minimum offset is 14 positive or negative hours.  If  \a seconds is larger or smaller than that, the result is undefined.   0 as offset is identical to UTC. Therefore, if \a seconds is 0, the  timeSpec() will be set to Qt::UTC. Hence the UTC offset always  relates to UTC, and can never relate to local time.   \sa isValid(), utcOffset()  */
end_comment
begin_function
DECL|function|setUtcOffset
name|void
name|QDateTime
operator|::
name|setUtcOffset
parameter_list|(
name|int
name|seconds
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
comment|/* The motivation to also setting d->spec is to ensure that the QDateTime      * instance stay in well-defined states all the time, instead of that      * we instruct the user to ensure it. */
if|if
condition|(
name|seconds
operator|==
literal|0
condition|)
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
else|else
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
expr_stmt|;
comment|/* Even if seconds is 0 we assign it to utcOffset. */
name|d
operator|->
name|utcOffset
operator|=
name|seconds
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  \since 4.4  \internal   Returns the UTC offset in seconds. If the timeSpec() isn't  Qt::OffsetFromUTC, 0 is returned. However, since 0 is a valid UTC  offset the return value of this function cannot be used to determine  whether a utcOffset() is used or is valid, timeSpec() must be  checked.   Likewise, if this QDateTime() is invalid or if timeSpec() isn't  Qt::OffsetFromUTC, 0 is returned.   The UTC offset only applies if the timeSpec() is Qt::OffsetFromUTC.   \sa isValid(), setUtcOffset()  */
end_comment
begin_function
DECL|function|utcOffset
name|int
name|QDateTime
operator|::
name|utcOffset
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
return|return
name|d
operator|->
name|utcOffset
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function
DECL|function|fromShortMonthName
specifier|static
name|int
name|fromShortMonthName
parameter_list|(
specifier|const
name|QString
modifier|&
name|monthName
parameter_list|)
block|{
comment|// Assume that English monthnames are the default
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QLatin1String
argument_list|(
name|qt_shortMonthNames
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
operator|+
literal|1
return|;
block|}
comment|// If English names can't be found, search the localized ones
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QDate
operator|::
name|shortMonthName
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDateTime QDateTime::fromString(const QString&string, Qt::DateFormat format)      Returns the QDateTime represented by the \a string, using the     \a format given, or an invalid datetime if this is not possible.      Note for Qt::TextDate: It is recommended that you use the     English short month names (e.g. "Jan"). Although localized month     names can also be used, they depend on the user's locale settings. */
end_comment
begin_function
DECL|function|fromString
name|QDateTime
name|QDateTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|f
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|Qt
operator|::
name|ISODate
case|:
block|{
name|QString
name|tmp
init|=
name|s
decl_stmt|;
name|Qt
operator|::
name|TimeSpec
name|ts
init|=
name|Qt
operator|::
name|LocalTime
decl_stmt|;
name|QDate
name|date
init|=
name|QDate
operator|::
name|fromString
argument_list|(
name|tmp
operator|.
name|left
argument_list|(
literal|10
argument_list|)
argument_list|,
name|Qt
operator|::
name|ISODate
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|size
argument_list|()
operator|==
literal|10
condition|)
return|return
name|QDateTime
argument_list|(
name|date
argument_list|)
return|;
name|tmp
operator|=
name|tmp
operator|.
name|mid
argument_list|(
literal|11
argument_list|)
expr_stmt|;
comment|// Recognize UTC specifications
if|if
condition|(
name|tmp
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'Z'
argument_list|)
argument_list|)
condition|)
block|{
name|ts
operator|=
name|Qt
operator|::
name|UTC
expr_stmt|;
name|tmp
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Recognize timezone specifications
name|QRegExp
name|rx
argument_list|(
name|QLatin1String
argument_list|(
literal|"[+-]"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|contains
argument_list|(
name|rx
argument_list|)
condition|)
block|{
name|int
name|idx
init|=
name|tmp
operator|.
name|indexOf
argument_list|(
name|rx
argument_list|)
decl_stmt|;
name|QString
name|tmp2
init|=
name|tmp
operator|.
name|mid
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|tmp
operator|.
name|left
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
name|int
name|ntzhour
init|=
literal|1
decl_stmt|;
name|int
name|ntzminute
init|=
literal|3
decl_stmt|;
if|if
condition|(
name|tmp2
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
operator|==
literal|3
condition|)
name|ntzminute
operator|=
literal|4
expr_stmt|;
specifier|const
name|int
name|tzhour
argument_list|(
name|tmp2
operator|.
name|mid
argument_list|(
name|ntzhour
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|int
name|tzminute
argument_list|(
name|tmp2
operator|.
name|mid
argument_list|(
name|ntzminute
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
argument_list|)
decl_stmt|;
name|QTime
name|tzt
argument_list|(
name|tzhour
argument_list|,
name|tzminute
argument_list|)
decl_stmt|;
name|int
name|utcOffset
init|=
operator|(
name|tzt
operator|.
name|hour
argument_list|()
operator|*
literal|60
operator|+
name|tzt
operator|.
name|minute
argument_list|()
operator|)
operator|*
literal|60
decl_stmt|;
if|if
condition|(
name|utcOffset
operator|!=
literal|0
condition|)
block|{
name|ts
operator|=
name|Qt
operator|::
name|OffsetFromUTC
expr_stmt|;
name|QDateTime
name|dt
argument_list|(
name|date
argument_list|,
name|QTime
operator|::
name|fromString
argument_list|(
name|tmp
argument_list|,
name|Qt
operator|::
name|ISODate
argument_list|)
argument_list|,
name|ts
argument_list|)
decl_stmt|;
name|dt
operator|.
name|setUtcOffset
argument_list|(
name|utcOffset
operator|*
operator|(
name|tmp2
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|dt
return|;
block|}
block|}
name|bool
name|isMidnight24
init|=
literal|false
decl_stmt|;
comment|// Might be end of day (24:00, including variants), which QTime considers invalid.
name|QTime
name|time
argument_list|(
name|fromStringImpl
argument_list|(
name|tmp
argument_list|,
name|Qt
operator|::
name|ISODate
argument_list|,
name|isMidnight24
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|isMidnight24
condition|)
block|{
comment|// ISO 8601 (section 4.2.3) says that 24:00 is equivalent to 00:00 the next day.
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|ts
argument_list|)
return|;
block|}
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|fromString
argument_list|(
name|s
argument_list|,
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dateTimeFormat
argument_list|(
name|f
operator|==
name|Qt
operator|::
name|SystemLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|fromString
argument_list|(
name|s
argument_list|,
name|QLocale
argument_list|()
operator|.
name|dateTimeFormat
argument_list|(
name|f
operator|==
name|Qt
operator|::
name|DefaultLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
argument_list|)
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_TEXTDATE
argument_list|)
case|case
name|Qt
operator|::
name|TextDate
case|:
block|{
name|QStringList
name|parts
init|=
name|s
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|parts
operator|.
name|count
argument_list|()
operator|<
literal|5
operator|)
operator|||
operator|(
name|parts
operator|.
name|count
argument_list|()
operator|>
literal|6
operator|)
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
comment|// Accept "Sun Dec 1 13:02:00 1974" and "Sun 1. Dec 13:02:00 1974"
name|int
name|month
init|=
operator|-
literal|1
decl_stmt|,
name|day
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|month
operator|=
name|fromShortMonthName
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|month
operator|!=
operator|-
literal|1
condition|)
block|{
name|day
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|day
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|month
operator|==
operator|-
literal|1
operator|||
name|day
operator|==
operator|-
literal|1
condition|)
block|{
comment|// first variant failed, lets try the other
name|month
operator|=
name|fromShortMonthName
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|month
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|dayStr
init|=
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|dayStr
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
block|{
name|dayStr
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|day
operator|=
name|dayStr
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|day
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|day
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|month
operator|==
operator|-
literal|1
operator|||
name|day
operator|==
operator|-
literal|1
condition|)
block|{
comment|// both variants failed, give up
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|int
name|year
decl_stmt|;
name|QStringList
name|timeParts
init|=
name|parts
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|timeParts
operator|.
name|count
argument_list|()
operator|==
literal|3
operator|)
operator|||
operator|(
name|timeParts
operator|.
name|count
argument_list|()
operator|==
literal|2
operator|)
condition|)
block|{
name|year
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|4
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
block|}
else|else
block|{
name|timeParts
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|4
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|timeParts
operator|.
name|count
argument_list|()
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|timeParts
operator|.
name|count
argument_list|()
operator|!=
literal|2
operator|)
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|year
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|int
name|hour
init|=
name|timeParts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|int
name|minute
init|=
name|timeParts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|int
name|second
init|=
operator|(
name|timeParts
operator|.
name|count
argument_list|()
operator|>
literal|2
operator|)
condition|?
name|timeParts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|QDate
name|date
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
decl_stmt|;
name|QTime
name|time
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|==
literal|5
condition|)
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|)
return|;
name|QString
name|tz
init|=
name|parts
operator|.
name|at
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tz
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"GMT"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|QDateTime
name|dt
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
if|if
condition|(
name|tz
operator|.
name|length
argument_list|()
operator|>
literal|3
condition|)
block|{
name|int
name|tzoffset
init|=
literal|0
decl_stmt|;
name|QChar
name|sign
init|=
name|tz
operator|.
name|at
argument_list|(
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sign
operator|!=
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
operator|)
operator|&&
operator|(
name|sign
operator|!=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|)
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|int
name|tzhour
init|=
name|tz
operator|.
name|mid
argument_list|(
literal|4
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|int
name|tzminute
init|=
name|tz
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|tzoffset
operator|=
operator|(
name|tzhour
operator|*
literal|60
operator|+
name|tzminute
operator|)
operator|*
literal|60
expr_stmt|;
if|if
condition|(
name|sign
operator|==
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
condition|)
name|tzoffset
operator|=
operator|-
name|tzoffset
expr_stmt|;
name|dt
operator|.
name|setUtcOffset
argument_list|(
name|tzoffset
argument_list|)
expr_stmt|;
block|}
return|return
name|dt
operator|.
name|toLocalTime
argument_list|()
return|;
block|}
endif|#
directive|endif
comment|//QT_NO_TEXTDATE
block|}
return|return
name|QDateTime
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDateTime::fromString(const QString&string, const QString&format)      Returns the QDateTime represented by the \a string, using the \a     format given, or an invalid datetime if the string cannot be parsed.      These expressions may be used for the date part of the format string:      \table     \header \li Expression \li Output     \row \li d \li the day as number without a leading zero (1 to 31)     \row \li dd \li the day as number with a leading zero (01 to 31)     \row \li ddd             \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').             Uses QDate::shortDayName().     \row \li dddd             \li the long localized day name (e.g. 'Monday' to 'Sunday').             Uses QDate::longDayName().     \row \li M \li the month as number without a leading zero (1-12)     \row \li MM \li the month as number with a leading zero (01-12)     \row \li MMM             \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').             Uses QDate::shortMonthName().     \row \li MMMM             \li the long localized month name (e.g. 'January' to 'December').             Uses QDate::longMonthName().     \row \li yy \li the year as two digit number (00-99)     \row \li yyyy \li the year as four digit number     \endtable      \note Unlike the other version of this function, day and month names must     be given in the user's local language. It is only possible to use the English     names if the user's language is English.      These expressions may be used for the time part of the format string:      \table     \header \li Expression \li Output     \row \li h             \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh             \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li H             \li the hour without a leading zero (0 to 23, even with AM/PM display)     \row \li HH             \li the hour with a leading zero (00 to 23, even with AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP or A          \li interpret as an AM/PM time. \e AP must be either "AM" or "PM".     \row \li ap or a          \li Interpret as an AM/PM time. \e ap must be either "am" or "pm".     \endtable      All other input characters will be treated as text. Any sequence     of characters that are enclosed in singlequotes will also be     treated as text and not be used as an expression.      \snippet code/src_corelib_tools_qdatetime.cpp 12      If the format is not satisfied an invalid QDateTime is returned.     The expressions that don't have leading zeroes (d, M, h, m, s, z) will be     greedy. This means that they will use two digits even if this will     put them outside the range and/or leave too few digits for other     sections.      \snippet code/src_corelib_tools_qdatetime.cpp 13      This could have meant 1 January 00:30.00 but the M will grab     two digits.      For any field that is not represented in the format the following     defaults are used:      \table     \header \li Field  \li Default value     \row    \li Year   \li 1900     \row    \li Month  \li 1 (January)     \row    \li Day    \li 1     \row    \li Hour   \li 0     \row    \li Minute \li 0     \row    \li Second \li 0     \endtable      For example:      \snippet code/src_corelib_tools_qdatetime.cpp 14      \sa QDate::fromString(), QTime::fromString(), QDate::toString(),     QDateTime::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|fromString
name|QDateTime
name|QDateTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QTime
name|time
decl_stmt|;
name|QDate
name|date
decl_stmt|;
name|QDateTimeParser
name|dt
argument_list|(
name|QVariant
operator|::
name|DateTime
argument_list|,
name|QDateTimeParser
operator|::
name|FromString
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|parseFormat
argument_list|(
name|format
argument_list|)
operator|&&
name|dt
operator|.
name|fromString
argument_list|(
name|string
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|)
condition|)
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|QDateTime
argument_list|(
name|QDate
argument_list|()
argument_list|,
name|QTime
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::toLocalTime() const      Returns a datetime containing the date and time information in     this datetime, but specified using the Qt::LocalTime definition.      \sa toTimeSpec() */
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::toUTC() const      Returns a datetime containing the date and time information in     this datetime, but specified using the Qt::UTC definition.      \sa toTimeSpec() */
end_comment
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|detach
name|void
name|QDateTime
operator|::
name|detach
parameter_list|()
block|{
name|d
operator|.
name|detach
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   Date/time stream functions  *****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \relates QDate      Writes the \a date to stream \a out.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
block|{
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_5_0
condition|)
return|return
name|out
operator|<<
name|quint32
argument_list|(
name|date
operator|.
name|jd
argument_list|)
return|;
else|else
return|return
name|out
operator|<<
name|qint64
argument_list|(
name|date
operator|.
name|jd
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QDate      Reads a date from stream \a in into the \a date.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QDate
modifier|&
name|date
parameter_list|)
block|{
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_5_0
condition|)
block|{
name|quint32
name|jd
decl_stmt|;
name|in
operator|>>
name|jd
expr_stmt|;
name|date
operator|.
name|jd
operator|=
name|jd
expr_stmt|;
block|}
else|else
block|{
name|qint64
name|jd
decl_stmt|;
name|in
operator|>>
name|jd
expr_stmt|;
name|date
operator|.
name|jd
operator|=
name|jd
expr_stmt|;
block|}
return|return
name|in
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTime      Writes \a time to stream \a out.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
return|return
name|out
operator|<<
name|quint32
argument_list|(
name|time
operator|.
name|mds
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTime      Reads a time from stream \a in into the given \a time.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|quint32
name|ds
decl_stmt|;
name|in
operator|>>
name|ds
expr_stmt|;
name|time
operator|.
name|mds
operator|=
name|int
argument_list|(
name|ds
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QDateTime      Writes \a dateTime to the \a out stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|dateTime
parameter_list|)
block|{
name|out
operator|<<
name|dateTime
operator|.
name|d
operator|->
name|date
operator|<<
name|dateTime
operator|.
name|d
operator|->
name|time
expr_stmt|;
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|>=
literal|7
condition|)
name|out
operator|<<
operator|(
name|qint8
operator|)
name|dateTime
operator|.
name|d
operator|->
name|spec
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QDateTime      Reads a datetime from the stream \a in into \a dateTime.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QDateTime
modifier|&
name|dateTime
parameter_list|)
block|{
name|dateTime
operator|.
name|detach
argument_list|()
expr_stmt|;
name|qint8
name|ts
init|=
operator|(
name|qint8
operator|)
name|QDateTimePrivate
operator|::
name|LocalUnknown
decl_stmt|;
name|in
operator|>>
name|dateTime
operator|.
name|d
operator|->
name|date
operator|>>
name|dateTime
operator|.
name|d
operator|->
name|time
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|>=
literal|7
condition|)
name|in
operator|>>
name|ts
expr_stmt|;
name|dateTime
operator|.
name|d
operator|->
name|spec
operator|=
operator|(
name|QDateTimePrivate
operator|::
name|Spec
operator|)
name|ts
expr_stmt|;
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|// checks if there is an unqoted 'AP' or 'ap' in the string
end_comment
begin_function
DECL|function|hasUnquotedAP
specifier|static
name|bool
name|hasUnquotedAP
parameter_list|(
specifier|const
name|QString
modifier|&
name|f
parameter_list|)
block|{
specifier|const
name|QLatin1Char
name|quote
argument_list|(
literal|'\''
argument_list|)
decl_stmt|;
name|bool
name|inquote
init|=
literal|false
decl_stmt|;
specifier|const
name|int
name|max
init|=
name|f
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|quote
condition|)
block|{
name|inquote
operator|=
operator|!
name|inquote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|inquote
operator|&&
name|f
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toUpper
argument_list|()
operator|==
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*****************************************************************************   Some static function used by QDate, QTime and QDateTime *****************************************************************************/
end_comment
begin_comment
comment|// Replaces tokens by their value. See QDateTime::toString() for a list of valid tokens
end_comment
begin_function
DECL|function|getFmtString
specifier|static
name|QString
name|getFmtString
parameter_list|(
specifier|const
name|QString
modifier|&
name|f
parameter_list|,
specifier|const
name|QTime
modifier|*
name|dt
init|=
literal|0
parameter_list|,
specifier|const
name|QDate
modifier|*
name|dd
init|=
literal|0
parameter_list|,
name|bool
name|am_pm
init|=
literal|false
parameter_list|)
block|{
if|if
condition|(
name|f
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|buf
init|=
name|f
decl_stmt|;
name|int
name|removed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"hh"
argument_list|)
argument_list|)
operator|||
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"HH"
argument_list|)
argument_list|)
condition|)
block|{
specifier|const
name|bool
name|hour12
init|=
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'h'
argument_list|)
operator|&&
name|am_pm
decl_stmt|;
if|if
condition|(
name|hour12
operator|&&
name|dt
operator|->
name|hour
argument_list|()
operator|>
literal|12
condition|)
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|hour
argument_list|()
operator|-
literal|12
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hour12
operator|&&
name|dt
operator|->
name|hour
argument_list|()
operator|==
literal|0
condition|)
name|buf
operator|=
name|QLatin1String
argument_list|(
literal|"12"
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|hour
argument_list|()
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'h'
argument_list|)
operator|||
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'H'
argument_list|)
condition|)
block|{
specifier|const
name|bool
name|hour12
init|=
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'h'
argument_list|)
operator|&&
name|am_pm
decl_stmt|;
if|if
condition|(
name|hour12
operator|&&
name|dt
operator|->
name|hour
argument_list|()
operator|>
literal|12
condition|)
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|hour
argument_list|()
operator|-
literal|12
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hour12
operator|&&
name|dt
operator|->
name|hour
argument_list|()
operator|==
literal|0
condition|)
name|buf
operator|=
name|QLatin1String
argument_list|(
literal|"12"
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|hour
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"mm"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|minute
argument_list|()
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
operator|(
name|QLatin1Char
argument_list|(
literal|'m'
argument_list|)
operator|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|minute
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"ss"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|second
argument_list|()
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'s'
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|second
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"zzz"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|msec
argument_list|()
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|3
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'z'
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|msec
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toUpper
argument_list|()
operator|==
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
condition|)
block|{
specifier|const
name|bool
name|upper
init|=
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
decl_stmt|;
name|buf
operator|=
name|dt
operator|->
name|hour
argument_list|()
operator|<
literal|12
condition|?
name|QLatin1String
argument_list|(
literal|"am"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"pm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|upper
condition|)
name|buf
operator|=
name|buf
operator|.
name|toUpper
argument_list|()
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|&&
name|f
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toUpper
argument_list|()
operator|==
name|QLatin1Char
argument_list|(
literal|'P'
argument_list|)
operator|&&
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isUpper
argument_list|()
operator|==
name|f
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|isUpper
argument_list|()
condition|)
block|{
name|removed
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|removed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dd
condition|)
block|{
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"dddd"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|dd
operator|->
name|longDayName
argument_list|(
name|dd
operator|->
name|dayOfWeek
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"ddd"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|dd
operator|->
name|shortDayName
argument_list|(
name|dd
operator|->
name|dayOfWeek
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"dd"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dd
operator|->
name|day
argument_list|()
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'d'
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dd
operator|->
name|day
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"MMMM"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|dd
operator|->
name|longMonthName
argument_list|(
name|dd
operator|->
name|month
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"MMM"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|dd
operator|->
name|shortMonthName
argument_list|(
name|dd
operator|->
name|month
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"MM"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dd
operator|->
name|month
argument_list|()
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'M'
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dd
operator|->
name|month
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"yyyy"
argument_list|)
argument_list|)
condition|)
block|{
specifier|const
name|int
name|year
init|=
name|dd
operator|->
name|year
argument_list|()
decl_stmt|;
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|qAbs
argument_list|(
name|year
argument_list|)
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|4
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|year
operator|>
literal|0
condition|)
name|removed
operator|=
literal|4
expr_stmt|;
else|else
block|{
name|buf
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|5
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"yy"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dd
operator|->
name|year
argument_list|()
argument_list|)
operator|.
name|right
argument_list|(
literal|2
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|removed
operator|==
literal|0
operator|||
name|removed
operator|>=
name|f
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|buf
return|;
block|}
return|return
name|buf
operator|+
name|getFmtString
argument_list|(
name|f
operator|.
name|mid
argument_list|(
name|removed
argument_list|)
argument_list|,
name|dt
argument_list|,
name|dd
argument_list|,
name|am_pm
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// Parses the format string and uses getFmtString to get the values for the tokens. Ret
end_comment
begin_function
DECL|function|fmtDateTime
specifier|static
name|QString
name|fmtDateTime
parameter_list|(
specifier|const
name|QString
modifier|&
name|f
parameter_list|,
specifier|const
name|QTime
modifier|*
name|dt
parameter_list|,
specifier|const
name|QDate
modifier|*
name|dd
parameter_list|)
block|{
name|QString
name|buf
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|buf
return|;
if|if
condition|(
name|dt
operator|&&
operator|!
name|dt
operator|->
name|isValid
argument_list|()
condition|)
return|return
name|buf
return|;
if|if
condition|(
name|dd
operator|&&
operator|!
name|dd
operator|->
name|isValid
argument_list|()
condition|)
return|return
name|buf
return|;
specifier|const
name|bool
name|ap
init|=
name|hasUnquotedAP
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|QString
name|frm
decl_stmt|;
name|uint
name|status
init|=
literal|'0'
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|f
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QChar
name|c
init|=
name|f
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|uint
name|cc
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|cc
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|cc
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|f
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|unicode
argument_list|()
operator|==
name|cc
condition|)
name|buf
operator|+=
name|c
expr_stmt|;
name|status
operator|=
literal|'0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|frm
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|buf
operator|+=
name|getFmtString
argument_list|(
name|frm
argument_list|,
name|dt
argument_list|,
name|dd
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|frm
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|status
operator|=
name|cc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
operator|==
literal|'\''
condition|)
block|{
name|buf
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|status
condition|)
block|{
if|if
condition|(
name|ap
operator|&&
operator|(
name|cc
operator|==
literal|'P'
operator|||
name|cc
operator|==
literal|'p'
operator|)
condition|)
name|status
operator|=
literal|'0'
expr_stmt|;
name|frm
operator|+=
name|c
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|+=
name|getFmtString
argument_list|(
name|frm
argument_list|,
name|dt
argument_list|,
name|dd
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|frm
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|'h'
operator|||
name|cc
operator|==
literal|'m'
operator|||
name|cc
operator|==
literal|'H'
operator|||
name|cc
operator|==
literal|'s'
operator|||
name|cc
operator|==
literal|'z'
condition|)
block|{
name|status
operator|=
name|cc
expr_stmt|;
name|frm
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
literal|'d'
operator|||
name|cc
operator|==
literal|'M'
operator|||
name|cc
operator|==
literal|'y'
condition|)
block|{
name|status
operator|=
name|cc
expr_stmt|;
name|frm
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|&&
name|cc
operator|==
literal|'A'
condition|)
block|{
name|status
operator|=
literal|'P'
expr_stmt|;
name|frm
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|&&
name|cc
operator|==
literal|'a'
condition|)
block|{
name|status
operator|=
literal|'p'
expr_stmt|;
name|frm
operator|+=
name|c
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|+=
name|c
expr_stmt|;
name|status
operator|=
literal|'0'
expr_stmt|;
block|}
block|}
block|}
name|buf
operator|+=
name|getFmtString
argument_list|(
name|frm
argument_list|,
name|dt
argument_list|,
name|dd
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_decl_stmt
DECL|variable|LowerYear
specifier|static
specifier|const
name|int
name|LowerYear
init|=
literal|1980
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|variable|LowerYear
specifier|static
specifier|const
name|int
name|LowerYear
init|=
literal|1970
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|UpperYear
specifier|static
specifier|const
name|int
name|UpperYear
init|=
literal|2037
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|adjustDate
specifier|static
name|QDate
name|adjustDate
parameter_list|(
name|QDate
name|date
parameter_list|)
block|{
name|QDate
name|lowerLimit
argument_list|(
name|LowerYear
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|QDate
name|upperLimit
argument_list|(
name|UpperYear
argument_list|,
literal|12
argument_list|,
literal|30
argument_list|)
decl_stmt|;
if|if
condition|(
name|date
operator|>
name|lowerLimit
operator|&&
name|date
operator|<
name|upperLimit
condition|)
return|return
name|date
return|;
name|int
name|month
init|=
name|date
operator|.
name|month
argument_list|()
decl_stmt|;
name|int
name|day
init|=
name|date
operator|.
name|day
argument_list|()
decl_stmt|;
comment|// neither 1970 nor 2037 are leap years, so make sure date isn't Feb 29
if|if
condition|(
name|month
operator|==
literal|2
operator|&&
name|day
operator|==
literal|29
condition|)
operator|--
name|day
expr_stmt|;
if|if
condition|(
name|date
operator|<
name|lowerLimit
condition|)
name|date
operator|.
name|setDate
argument_list|(
name|LowerYear
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
else|else
name|date
operator|.
name|setDate
argument_list|(
name|UpperYear
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
return|return
name|date
return|;
block|}
end_function
begin_function
DECL|function|utcToLocal
specifier|static
name|QDateTimePrivate
operator|::
name|Spec
name|utcToLocal
parameter_list|(
name|QDate
modifier|&
name|date
parameter_list|,
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|QDate
name|fakeDate
init|=
name|adjustDate
argument_list|(
name|date
argument_list|)
decl_stmt|;
comment|// won't overflow because of fakeDate
name|time_t
name|secsSince1Jan1970UTC
init|=
name|toMSecsSinceEpoch_helper
argument_list|(
name|fakeDate
operator|.
name|toJulianDay
argument_list|()
argument_list|,
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|msecsTo
argument_list|(
name|time
argument_list|)
argument_list|)
operator|/
literal|1000
decl_stmt|;
name|tm
modifier|*
name|brokenDown
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|tm
name|res
decl_stmt|;
name|FILETIME
name|utcTime
init|=
name|time_tToFt
argument_list|(
name|secsSince1Jan1970UTC
argument_list|)
decl_stmt|;
name|FILETIME
name|resultTime
decl_stmt|;
name|FileTimeToLocalFileTime
argument_list|(
operator|&
name|utcTime
argument_list|,
operator|&
name|resultTime
argument_list|)
expr_stmt|;
name|SYSTEMTIME
name|sysTime
decl_stmt|;
name|FileTimeToSystemTime
argument_list|(
operator|&
name|resultTime
argument_list|,
operator|&
name|sysTime
argument_list|)
expr_stmt|;
name|res
operator|.
name|tm_sec
operator|=
name|sysTime
operator|.
name|wSecond
expr_stmt|;
name|res
operator|.
name|tm_min
operator|=
name|sysTime
operator|.
name|wMinute
expr_stmt|;
name|res
operator|.
name|tm_hour
operator|=
name|sysTime
operator|.
name|wHour
expr_stmt|;
name|res
operator|.
name|tm_mday
operator|=
name|sysTime
operator|.
name|wDay
expr_stmt|;
name|res
operator|.
name|tm_mon
operator|=
name|sysTime
operator|.
name|wMonth
operator|-
literal|1
expr_stmt|;
name|res
operator|.
name|tm_year
operator|=
name|sysTime
operator|.
name|wYear
operator|-
literal|1900
expr_stmt|;
name|brokenDown
operator|=
operator|&
name|res
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|tzset
argument_list|()
expr_stmt|;
name|tm
name|res
decl_stmt|;
name|brokenDown
operator|=
name|localtime_r
argument_list|(
operator|&
name|secsSince1Jan1970UTC
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
name|tm
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|_localtime64_s
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|secsSince1Jan1970UTC
argument_list|)
condition|)
name|brokenDown
operator|=
operator|&
name|res
expr_stmt|;
else|#
directive|else
name|brokenDown
operator|=
name|localtime
argument_list|(
operator|&
name|secsSince1Jan1970UTC
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|brokenDown
condition|)
block|{
name|date
operator|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|time
operator|=
name|QTime
argument_list|()
expr_stmt|;
return|return
name|QDateTimePrivate
operator|::
name|LocalUnknown
return|;
block|}
else|else
block|{
name|int
name|deltaDays
init|=
name|fakeDate
operator|.
name|daysTo
argument_list|(
name|date
argument_list|)
decl_stmt|;
name|date
operator|=
name|QDate
argument_list|(
name|brokenDown
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|brokenDown
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|brokenDown
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|time
operator|=
name|QTime
argument_list|(
name|brokenDown
operator|->
name|tm_hour
argument_list|,
name|brokenDown
operator|->
name|tm_min
argument_list|,
name|brokenDown
operator|->
name|tm_sec
argument_list|,
name|time
operator|.
name|msec
argument_list|()
argument_list|)
expr_stmt|;
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
name|deltaDays
argument_list|)
expr_stmt|;
if|if
condition|(
name|brokenDown
operator|->
name|tm_isdst
operator|>
literal|0
condition|)
return|return
name|QDateTimePrivate
operator|::
name|LocalDST
return|;
elseif|else
if|if
condition|(
name|brokenDown
operator|->
name|tm_isdst
operator|<
literal|0
condition|)
return|return
name|QDateTimePrivate
operator|::
name|LocalUnknown
return|;
else|else
return|return
name|QDateTimePrivate
operator|::
name|LocalStandard
return|;
block|}
block|}
end_function
begin_function
DECL|function|localToUtc
specifier|static
name|void
name|localToUtc
parameter_list|(
name|QDate
modifier|&
name|date
parameter_list|,
name|QTime
modifier|&
name|time
parameter_list|,
name|int
name|isdst
parameter_list|)
block|{
if|if
condition|(
operator|!
name|date
operator|.
name|isValid
argument_list|()
condition|)
return|return;
name|QDate
name|fakeDate
init|=
name|adjustDate
argument_list|(
name|date
argument_list|)
decl_stmt|;
name|tm
name|localTM
decl_stmt|;
name|localTM
operator|.
name|tm_sec
operator|=
name|time
operator|.
name|second
argument_list|()
expr_stmt|;
name|localTM
operator|.
name|tm_min
operator|=
name|time
operator|.
name|minute
argument_list|()
expr_stmt|;
name|localTM
operator|.
name|tm_hour
operator|=
name|time
operator|.
name|hour
argument_list|()
expr_stmt|;
name|localTM
operator|.
name|tm_mday
operator|=
name|fakeDate
operator|.
name|day
argument_list|()
expr_stmt|;
name|localTM
operator|.
name|tm_mon
operator|=
name|fakeDate
operator|.
name|month
argument_list|()
operator|-
literal|1
expr_stmt|;
name|localTM
operator|.
name|tm_year
operator|=
name|fakeDate
operator|.
name|year
argument_list|()
operator|-
literal|1900
expr_stmt|;
name|localTM
operator|.
name|tm_isdst
operator|=
operator|(
name|int
operator|)
name|isdst
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|time_t
name|secsSince1Jan1970UTC
init|=
operator|(
name|toMSecsSinceEpoch_helper
argument_list|(
name|fakeDate
operator|.
name|toJulianDay
argument_list|()
argument_list|,
name|QTime
argument_list|()
operator|.
name|msecsTo
argument_list|(
name|time
argument_list|)
argument_list|)
operator|/
literal|1000
operator|)
decl_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|_tzset
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|time_t
name|secsSince1Jan1970UTC
init|=
name|mktime
argument_list|(
operator|&
name|localTM
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|tm
modifier|*
name|brokenDown
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|tm
name|res
decl_stmt|;
name|FILETIME
name|localTime
init|=
name|time_tToFt
argument_list|(
name|secsSince1Jan1970UTC
argument_list|)
decl_stmt|;
name|SYSTEMTIME
name|sysTime
decl_stmt|;
name|FileTimeToSystemTime
argument_list|(
operator|&
name|localTime
argument_list|,
operator|&
name|sysTime
argument_list|)
expr_stmt|;
name|FILETIME
name|resultTime
decl_stmt|;
name|LocalFileTimeToFileTime
argument_list|(
operator|&
name|localTime
argument_list|,
operator|&
name|resultTime
argument_list|)
expr_stmt|;
name|FileTimeToSystemTime
argument_list|(
operator|&
name|resultTime
argument_list|,
operator|&
name|sysTime
argument_list|)
expr_stmt|;
name|res
operator|.
name|tm_sec
operator|=
name|sysTime
operator|.
name|wSecond
expr_stmt|;
name|res
operator|.
name|tm_min
operator|=
name|sysTime
operator|.
name|wMinute
expr_stmt|;
name|res
operator|.
name|tm_hour
operator|=
name|sysTime
operator|.
name|wHour
expr_stmt|;
name|res
operator|.
name|tm_mday
operator|=
name|sysTime
operator|.
name|wDay
expr_stmt|;
name|res
operator|.
name|tm_mon
operator|=
name|sysTime
operator|.
name|wMonth
operator|-
literal|1
expr_stmt|;
name|res
operator|.
name|tm_year
operator|=
name|sysTime
operator|.
name|wYear
operator|-
literal|1900
expr_stmt|;
name|res
operator|.
name|tm_isdst
operator|=
operator|(
name|int
operator|)
name|isdst
expr_stmt|;
name|brokenDown
operator|=
operator|&
name|res
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of gmtime() where available
name|tm
name|res
decl_stmt|;
name|brokenDown
operator|=
name|gmtime_r
argument_list|(
operator|&
name|secsSince1Jan1970UTC
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
name|tm
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|_gmtime64_s
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|secsSince1Jan1970UTC
argument_list|)
condition|)
name|brokenDown
operator|=
operator|&
name|res
expr_stmt|;
else|#
directive|else
name|brokenDown
operator|=
name|gmtime
argument_list|(
operator|&
name|secsSince1Jan1970UTC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_THREAD&& _POSIX_THREAD_SAFE_FUNCTIONS
if|if
condition|(
operator|!
name|brokenDown
condition|)
block|{
name|date
operator|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|time
operator|=
name|QTime
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|deltaDays
init|=
name|fakeDate
operator|.
name|daysTo
argument_list|(
name|date
argument_list|)
decl_stmt|;
name|date
operator|=
name|QDate
argument_list|(
name|brokenDown
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|brokenDown
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|brokenDown
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|time
operator|=
name|QTime
argument_list|(
name|brokenDown
operator|->
name|tm_hour
argument_list|,
name|brokenDown
operator|->
name|tm_min
argument_list|,
name|brokenDown
operator|->
name|tm_sec
argument_list|,
name|time
operator|.
name|msec
argument_list|()
argument_list|)
expr_stmt|;
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
name|deltaDays
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|getLocal
name|QDateTimePrivate
operator|::
name|Spec
name|QDateTimePrivate
operator|::
name|getLocal
parameter_list|(
name|QDate
modifier|&
name|outDate
parameter_list|,
name|QTime
modifier|&
name|outTime
parameter_list|)
specifier|const
block|{
name|outDate
operator|=
name|date
expr_stmt|;
name|outTime
operator|=
name|time
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|UTC
condition|)
return|return
name|utcToLocal
argument_list|(
name|outDate
argument_list|,
name|outTime
argument_list|)
return|;
return|return
name|spec
return|;
block|}
end_function
begin_function
DECL|function|getUTC
name|void
name|QDateTimePrivate
operator|::
name|getUTC
parameter_list|(
name|QDate
modifier|&
name|outDate
parameter_list|,
name|QTime
modifier|&
name|outTime
parameter_list|)
specifier|const
block|{
name|outDate
operator|=
name|date
expr_stmt|;
name|outTime
operator|=
name|time
expr_stmt|;
specifier|const
name|bool
name|isOffset
init|=
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
decl_stmt|;
if|if
condition|(
name|spec
operator|!=
name|QDateTimePrivate
operator|::
name|UTC
operator|&&
operator|!
name|isOffset
condition|)
name|localToUtc
argument_list|(
name|outDate
argument_list|,
name|outTime
argument_list|,
operator|(
name|int
operator|)
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOffset
condition|)
name|addMSecs
argument_list|(
name|outDate
argument_list|,
name|outTime
argument_list|,
operator|-
operator|(
name|qint64
argument_list|(
name|utcOffset
argument_list|)
operator|*
literal|1000
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_DATESTRING
argument_list|)
end_if
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QDate("
operator|<<
name|date
operator|.
name|toString
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QTime("
operator|<<
name|time
operator|.
name|toString
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|date
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QDateTime("
operator|<<
name|date
operator|.
name|toString
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \fn uint qHash(const QDateTime&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_function
DECL|function|qHash
name|uint
name|qHash
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
block|{
comment|// Use to toMSecsSinceEpoch instead of individual qHash functions for
comment|// QDate/QTime/spec/offset because QDateTime::operator== converts both arguments
comment|// to the same timezone. If we don't, qHash would return different hashes for
comment|// two QDateTimes that are equivalent once converted to the same timezone.
return|return
name|qHash
argument_list|(
name|key
operator|.
name|toMSecsSinceEpoch
argument_list|()
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn uint qHash(const QDate&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_function
DECL|function|qHash
name|uint
name|qHash
parameter_list|(
specifier|const
name|QDate
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
block|{
return|return
name|qHash
argument_list|(
name|key
operator|.
name|toJulianDay
argument_list|()
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn uint qHash(const QTime&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_function
DECL|function|qHash
name|uint
name|qHash
parameter_list|(
specifier|const
name|QTime
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
block|{
return|return
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|msecsTo
argument_list|(
name|key
argument_list|)
operator|^
name|seed
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_comment
comment|/*!   \internal   Gets the digit from a datetime. E.g.    QDateTime var(QDate(2004, 02, 02));   int digit = getDigit(var, Year);   // digit = 2004 */
end_comment
begin_function
DECL|function|getDigit
name|int
name|QDateTimeParser
operator|::
name|getDigit
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|t
parameter_list|,
name|int
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|sectionNodes
operator|.
name|size
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
name|qWarning
argument_list|(
literal|"QDateTimeParser::getDigit() Internal error (%s %d)"
argument_list|,
name|qPrintable
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"QDateTimeParser::getDigit() Internal error (%d)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
specifier|const
name|SectionNode
modifier|&
name|node
init|=
name|sectionNodes
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
return|;
case|case
name|MinuteSection
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|minute
argument_list|()
return|;
case|case
name|SecondSection
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|second
argument_list|()
return|;
case|case
name|MSecSection
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|msec
argument_list|()
return|;
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
return|return
name|t
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
return|;
case|case
name|MonthSection
case|:
return|return
name|t
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
return|;
case|case
name|DaySection
case|:
return|return
name|t
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
return|;
case|case
name|DayOfWeekSection
case|:
return|return
name|t
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
return|;
case|case
name|AmPmSection
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
operator|>
literal|11
condition|?
literal|1
else|:
literal|0
return|;
default|default:
break|break;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
name|qWarning
argument_list|(
literal|"QDateTimeParser::getDigit() Internal error 2 (%s %d)"
argument_list|,
name|qPrintable
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"QDateTimeParser::getDigit() Internal error 2 (%d)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Sets a digit in a datetime. E.g.    QDateTime var(QDate(2004, 02, 02));   int digit = getDigit(var, Year);   // digit = 2004   setDigit(&var, Year, 2005);   digit = getDigit(var, Year);   // digit = 2005 */
end_comment
begin_function
DECL|function|setDigit
name|bool
name|QDateTimeParser
operator|::
name|setDigit
parameter_list|(
name|QDateTime
modifier|&
name|v
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|newVal
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|sectionNodes
operator|.
name|size
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
name|qWarning
argument_list|(
literal|"QDateTimeParser::setDigit() Internal error (%s %d %d)"
argument_list|,
name|qPrintable
argument_list|(
name|v
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|index
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"QDateTimeParser::setDigit() Internal error (%d %d)"
argument_list|,
name|index
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
specifier|const
name|SectionNode
modifier|&
name|node
init|=
name|sectionNodes
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|,
name|msec
decl_stmt|;
name|year
operator|=
name|v
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
expr_stmt|;
name|month
operator|=
name|v
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
expr_stmt|;
name|day
operator|=
name|v
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
expr_stmt|;
name|hour
operator|=
name|v
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
expr_stmt|;
name|minute
operator|=
name|v
operator|.
name|time
argument_list|()
operator|.
name|minute
argument_list|()
expr_stmt|;
name|second
operator|=
name|v
operator|.
name|time
argument_list|()
operator|.
name|second
argument_list|()
expr_stmt|;
name|msec
operator|=
name|v
operator|.
name|time
argument_list|()
operator|.
name|msec
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|node
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
name|hour
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|MinuteSection
case|:
name|minute
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|SecondSection
case|:
name|second
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|MSecSection
case|:
name|msec
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
name|year
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|MonthSection
case|:
name|month
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|DaySection
case|:
case|case
name|DayOfWeekSection
case|:
if|if
condition|(
name|newVal
operator|>
literal|31
condition|)
block|{
comment|// have to keep legacy behavior. setting the
comment|// date to 32 should return false. Setting it
comment|// to 31 for february should return true
return|return
literal|false
return|;
block|}
name|day
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|AmPmSection
case|:
name|hour
operator|=
operator|(
name|newVal
operator|==
literal|0
condition|?
name|hour
operator|%
literal|12
else|:
operator|(
name|hour
operator|%
literal|12
operator|)
operator|+
literal|12
operator|)
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::setDigit() Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|node
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|node
operator|.
name|type
operator|&
operator|(
name|DaySection
operator||
name|DayOfWeekSection
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|day
operator|<
name|cachedDay
condition|)
name|day
operator|=
name|cachedDay
expr_stmt|;
specifier|const
name|int
name|max
init|=
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
literal|1
argument_list|)
operator|.
name|daysInMonth
argument_list|()
decl_stmt|;
if|if
condition|(
name|day
operator|>
name|max
condition|)
block|{
name|day
operator|=
name|max
expr_stmt|;
block|}
block|}
if|if
condition|(
name|QDate
operator|::
name|isValid
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
operator|&&
name|QTime
operator|::
name|isValid
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|msec
argument_list|)
condition|)
block|{
name|v
operator|=
name|QDateTime
argument_list|(
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
argument_list|,
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|msec
argument_list|)
argument_list|,
name|spec
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \    Returns the absolute maximum for a section */
end_comment
begin_function
DECL|function|absoluteMax
name|int
name|QDateTimeParser
operator|::
name|absoluteMax
parameter_list|(
name|int
name|s
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|cur
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|s
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
return|return
literal|23
return|;
comment|// this is special-cased in
comment|// parseSection. We want it to be
comment|// 23 for the stepBy case.
case|case
name|MinuteSection
case|:
case|case
name|SecondSection
case|:
return|return
literal|59
return|;
case|case
name|MSecSection
case|:
return|return
literal|999
return|;
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
return|return
literal|9999
return|;
comment|// sectionMaxSize will prevent
comment|// people from typing in a larger
comment|// number in count == 2 sections.
comment|// stepBy() will work on real years anyway
case|case
name|MonthSection
case|:
return|return
literal|12
return|;
case|case
name|DaySection
case|:
case|case
name|DayOfWeekSection
case|:
return|return
name|cur
operator|.
name|isValid
argument_list|()
condition|?
name|cur
operator|.
name|date
argument_list|()
operator|.
name|daysInMonth
argument_list|()
else|:
literal|31
return|;
case|case
name|AmPmSection
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
name|qWarning
argument_list|(
literal|"QDateTimeParser::absoluteMax() Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the absolute minimum for a section */
end_comment
begin_function
DECL|function|absoluteMin
name|int
name|QDateTimeParser
operator|::
name|absoluteMin
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|s
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
case|case
name|MinuteSection
case|:
case|case
name|SecondSection
case|:
case|case
name|MSecSection
case|:
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
return|return
literal|0
return|;
case|case
name|MonthSection
case|:
case|case
name|DaySection
case|:
case|case
name|DayOfWeekSection
case|:
return|return
literal|1
return|;
case|case
name|AmPmSection
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
name|qWarning
argument_list|(
literal|"QDateTimeParser::absoluteMin() Internal error (%s, %0x)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|,
name|sn
operator|.
name|type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the sectionNode for the Section \a s. */
end_comment
begin_function
DECL|function|sectionNode
specifier|const
name|QDateTimeParser
operator|::
name|SectionNode
modifier|&
name|QDateTimeParser
operator|::
name|sectionNode
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|sectionIndex
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|sectionIndex
condition|)
block|{
case|case
name|FirstSectionIndex
case|:
return|return
name|first
return|;
case|case
name|LastSectionIndex
case|:
return|return
name|last
return|;
case|case
name|NoSectionIndex
case|:
return|return
name|none
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sectionIndex
operator|<
name|sectionNodes
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|sectionNodes
operator|.
name|at
argument_list|(
name|sectionIndex
argument_list|)
return|;
block|}
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionNode() Internal error (%d)"
argument_list|,
name|sectionIndex
argument_list|)
expr_stmt|;
return|return
name|none
return|;
block|}
end_function
begin_function
DECL|function|sectionType
name|QDateTimeParser
operator|::
name|Section
name|QDateTimeParser
operator|::
name|sectionType
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
return|return
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
operator|.
name|type
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the starting position for section \a s. */
end_comment
begin_function
DECL|function|sectionPos
name|int
name|QDateTimeParser
operator|::
name|sectionPos
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
return|return
name|sectionPos
argument_list|(
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sectionPos
name|int
name|QDateTimeParser
operator|::
name|sectionPos
parameter_list|(
specifier|const
name|SectionNode
modifier|&
name|sn
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|FirstSection
case|:
return|return
literal|0
return|;
case|case
name|LastSection
case|:
return|return
name|displayText
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|sn
operator|.
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionPos Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|sn
operator|.
name|pos
return|;
block|}
end_function
begin_comment
comment|/*!   \internal helper function for parseFormat. removes quotes that are   not escaped and removes the escaping on those that are escaped  */
end_comment
begin_function
DECL|function|unquote
specifier|static
name|QString
name|unquote
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
specifier|const
name|QChar
name|quote
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QChar
name|slash
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QChar
name|zero
argument_list|(
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|ret
decl_stmt|;
name|QChar
name|status
argument_list|(
name|zero
argument_list|)
decl_stmt|;
specifier|const
name|int
name|max
init|=
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|quote
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|quote
condition|)
block|{
name|status
operator|=
name|quote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ret
operator|.
name|isEmpty
argument_list|()
operator|&&
name|str
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|==
name|slash
condition|)
block|{
name|ret
index|[
name|ret
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
operator|=
name|quote
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|zero
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|+=
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Parses the format \a newFormat. If successful, returns true and   sets up the format. Else keeps the old format and returns false.  */
end_comment
begin_function
DECL|function|countRepeat
specifier|static
specifier|inline
name|int
name|countRepeat
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|maxCount
parameter_list|)
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
specifier|const
name|QChar
name|ch
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|int
name|max
init|=
name|qMin
argument_list|(
name|index
operator|+
name|maxCount
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|index
operator|+
name|count
operator|<
name|max
operator|&&
name|str
operator|.
name|at
argument_list|(
name|index
operator|+
name|count
argument_list|)
operator|==
name|ch
condition|)
block|{
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function
begin_function
DECL|function|appendSeparator
specifier|static
specifier|inline
name|void
name|appendSeparator
parameter_list|(
name|QStringList
modifier|*
name|list
parameter_list|,
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|lastQuote
parameter_list|)
block|{
name|QString
name|str
argument_list|(
name|string
operator|.
name|mid
argument_list|(
name|from
argument_list|,
name|size
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastQuote
operator|>=
name|from
condition|)
name|str
operator|=
name|unquote
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|list
operator|->
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseFormat
name|bool
name|QDateTimeParser
operator|::
name|parseFormat
parameter_list|(
specifier|const
name|QString
modifier|&
name|newFormat
parameter_list|)
block|{
specifier|const
name|QLatin1Char
name|quote
argument_list|(
literal|'\''
argument_list|)
decl_stmt|;
specifier|const
name|QLatin1Char
name|slash
argument_list|(
literal|'\\'
argument_list|)
decl_stmt|;
specifier|const
name|QLatin1Char
name|zero
argument_list|(
literal|'0'
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFormat
operator|==
name|displayFormat
operator|&&
operator|!
name|newFormat
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|QDTPDEBUGN
argument_list|(
literal|"parseFormat: %s"
argument_list|,
name|newFormat
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|SectionNode
argument_list|>
name|newSectionNodes
decl_stmt|;
name|Sections
name|newDisplay
init|=
literal|0
decl_stmt|;
name|QStringList
name|newSeparators
decl_stmt|;
name|int
name|i
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
name|int
name|add
init|=
literal|0
decl_stmt|;
name|QChar
name|status
argument_list|(
name|zero
argument_list|)
decl_stmt|;
specifier|const
name|int
name|max
init|=
name|newFormat
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|lastQuote
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|newFormat
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|quote
condition|)
block|{
name|lastQuote
operator|=
name|i
expr_stmt|;
operator|++
name|add
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|quote
condition|)
block|{
name|status
operator|=
name|quote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newFormat
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|!=
name|slash
condition|)
block|{
name|status
operator|=
name|zero
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|quote
condition|)
block|{
specifier|const
name|char
name|sect
init|=
name|newFormat
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|sect
condition|)
block|{
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|Section
name|hour
init|=
operator|(
name|sect
operator|==
literal|'h'
operator|)
condition|?
name|Hour12Section
else|:
name|Hour24Section
decl_stmt|;
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|hour
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
argument|newFormat
argument_list|,
argument|i
argument_list|,
literal|2
argument_list|)
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|hour
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|MinuteSection
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
argument|newFormat
argument_list|,
argument|i
argument_list|,
literal|2
argument_list|)
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|MinuteSection
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|SecondSection
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
argument|newFormat
argument_list|,
argument|i
argument_list|,
literal|2
argument_list|)
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|SecondSection
expr_stmt|;
block|}
break|break;
case|case
literal|'z'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|MSecSection
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
operator|?
literal|1
operator|:
literal|3
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|MSecSection
expr_stmt|;
block|}
break|break;
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|bool
name|cap
init|=
operator|(
name|sect
operator|==
literal|'A'
operator|)
decl_stmt|;
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|AmPmSection
block|,
name|i
operator|-
name|add
block|,
operator|(
name|cap
operator|?
literal|1
operator|:
literal|0
operator|)
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|newDisplay
operator||=
name|AmPmSection
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|newFormat
operator|.
name|size
argument_list|()
operator|&&
name|newFormat
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
operator|(
name|cap
condition|?
name|QLatin1Char
argument_list|(
literal|'P'
argument_list|)
else|:
name|QLatin1Char
argument_list|(
literal|'p'
argument_list|)
operator|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'y'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Time
condition|)
block|{
specifier|const
name|int
name|repeat
init|=
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|repeat
operator|>=
literal|2
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|repeat
operator|==
literal|4
operator|?
name|YearSection
operator|:
name|YearSection2Digits
block|,
name|i
operator|-
name|add
block|,
name|repeat
operator|==
literal|4
operator|?
literal|4
operator|:
literal|2
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|sn
operator|.
name|type
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Time
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|MonthSection
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
argument|newFormat
argument_list|,
argument|i
argument_list|,
literal|4
argument_list|)
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|newSeparators
operator|.
name|append
argument_list|(
name|unquote
argument_list|(
name|newFormat
operator|.
name|mid
argument_list|(
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|MonthSection
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Time
condition|)
block|{
specifier|const
name|int
name|repeat
init|=
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|repeat
operator|>=
literal|3
operator|?
name|DayOfWeekSection
operator|:
name|DaySection
block|,
name|i
operator|-
name|add
block|,
name|repeat
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|sn
operator|.
name|type
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
if|if
condition|(
name|newSectionNodes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|context
operator|==
name|DateTimeEdit
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|newDisplay
operator|&
operator|(
name|AmPmSection
operator||
name|Hour12Section
operator|)
operator|)
operator|==
name|Hour12Section
condition|)
block|{
specifier|const
name|int
name|max
init|=
name|newSectionNodes
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
name|SectionNode
modifier|&
name|node
init|=
name|newSectionNodes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|type
operator|==
name|Hour12Section
condition|)
name|node
operator|.
name|type
operator|=
name|Hour24Section
expr_stmt|;
block|}
block|}
if|if
condition|(
name|index
operator|<
name|newFormat
operator|.
name|size
argument_list|()
condition|)
block|{
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|index
operator|-
name|max
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newSeparators
operator|.
name|append
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|displayFormat
operator|=
name|newFormat
expr_stmt|;
name|separators
operator|=
name|newSeparators
expr_stmt|;
name|sectionNodes
operator|=
name|newSectionNodes
expr_stmt|;
name|display
operator|=
name|newDisplay
expr_stmt|;
name|last
operator|.
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
comment|//     for (int i=0; i<sectionNodes.size(); ++i) {
comment|//         QDTPDEBUG<< sectionName(sectionNodes.at(i).type)<< sectionNodes.at(i).count;
comment|//     }
name|QDTPDEBUG
operator|<<
name|newFormat
operator|<<
name|displayFormat
expr_stmt|;
name|QDTPDEBUGN
argument_list|(
literal|"separators:\n'%s'"
argument_list|,
name|separators
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the size of section \a s. */
end_comment
begin_function
DECL|function|sectionSize
name|int
name|QDateTimeParser
operator|::
name|sectionSize
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|sectionIndex
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sectionIndex
operator|>=
name|sectionNodes
operator|.
name|size
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionSize Internal error (%d)"
argument_list|,
name|sectionIndex
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|sectionIndex
operator|==
name|sectionNodes
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
return|return
name|displayText
argument_list|()
operator|.
name|size
argument_list|()
operator|-
name|sectionPos
argument_list|(
name|sectionIndex
argument_list|)
operator|-
name|separators
operator|.
name|last
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|sectionPos
argument_list|(
name|sectionIndex
operator|+
literal|1
argument_list|)
operator|-
name|sectionPos
argument_list|(
name|sectionIndex
argument_list|)
operator|-
name|separators
operator|.
name|at
argument_list|(
name|sectionIndex
operator|+
literal|1
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
block|}
end_function
begin_function
DECL|function|sectionMaxSize
name|int
name|QDateTimeParser
operator|::
name|sectionMaxSize
parameter_list|(
name|Section
name|s
parameter_list|,
name|int
name|count
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
name|int
name|mcount
init|=
literal|12
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|FirstSection
case|:
case|case
name|NoSection
case|:
case|case
name|LastSection
case|:
return|return
literal|0
return|;
case|case
name|AmPmSection
case|:
block|{
specifier|const
name|int
name|lowerMax
init|=
name|qMin
argument_list|(
name|getAmPmText
argument_list|(
name|AmText
argument_list|,
name|LowerCase
argument_list|)
operator|.
name|size
argument_list|()
argument_list|,
name|getAmPmText
argument_list|(
name|PmText
argument_list|,
name|LowerCase
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|upperMax
init|=
name|qMin
argument_list|(
name|getAmPmText
argument_list|(
name|AmText
argument_list|,
name|UpperCase
argument_list|)
operator|.
name|size
argument_list|()
argument_list|,
name|getAmPmText
argument_list|(
name|PmText
argument_list|,
name|UpperCase
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|qMin
argument_list|(
literal|4
argument_list|,
name|qMin
argument_list|(
name|lowerMax
argument_list|,
name|upperMax
argument_list|)
argument_list|)
return|;
block|}
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
case|case
name|MinuteSection
case|:
case|case
name|SecondSection
case|:
case|case
name|DaySection
case|:
return|return
literal|2
return|;
case|case
name|DayOfWeekSection
case|:
ifdef|#
directive|ifdef
name|QT_NO_TEXTDATE
return|return
literal|2
return|;
else|#
directive|else
name|mcount
operator|=
literal|7
expr_stmt|;
comment|// fall through
endif|#
directive|endif
case|case
name|MonthSection
case|:
if|if
condition|(
name|count
operator|<=
literal|2
condition|)
return|return
literal|2
return|;
ifdef|#
directive|ifdef
name|QT_NO_TEXTDATE
return|return
literal|2
return|;
else|#
directive|else
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|QLocale
name|l
init|=
name|locale
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|mcount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
name|str
init|=
operator|(
name|s
operator|==
name|MonthSection
condition|?
name|l
operator|.
name|monthName
argument_list|(
name|i
argument_list|,
name|count
operator|==
literal|4
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
else|:
name|l
operator|.
name|dayName
argument_list|(
name|i
argument_list|,
name|count
operator|==
literal|4
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
operator|)
decl_stmt|;
name|ret
operator|=
name|qMax
argument_list|(
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
endif|#
directive|endif
case|case
name|MSecSection
case|:
return|return
literal|3
return|;
case|case
name|YearSection
case|:
return|return
literal|4
return|;
case|case
name|YearSection2Digits
case|:
return|return
literal|2
return|;
case|case
name|CalendarPopupSection
case|:
case|case
name|Internal
case|:
case|case
name|TimeSectionMask
case|:
case|case
name|DateSectionMask
case|:
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionMaxSize: Invalid section %s"
argument_list|,
name|sectionName
argument_list|(
name|s
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|NoSectionIndex
case|:
case|case
name|FirstSectionIndex
case|:
case|case
name|LastSectionIndex
case|:
case|case
name|CalendarPopupIndex
case|:
comment|// these cases can't happen
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|sectionMaxSize
name|int
name|QDateTimeParser
operator|::
name|sectionMaxSize
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|sectionMaxSize
argument_list|(
name|sn
operator|.
name|type
argument_list|,
name|sn
operator|.
name|count
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the text of section \a s. This function operates on the   arg text rather than edit->text(). */
end_comment
begin_function
DECL|function|sectionText
name|QString
name|QDateTimeParser
operator|::
name|sectionText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|int
name|sectionIndex
parameter_list|,
name|int
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|NoSectionIndex
case|:
case|case
name|FirstSectionIndex
case|:
case|case
name|LastSectionIndex
case|:
return|return
name|QString
argument_list|()
return|;
default|default:
break|break;
block|}
return|return
name|text
operator|.
name|mid
argument_list|(
name|index
argument_list|,
name|sectionSize
argument_list|(
name|sectionIndex
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sectionText
name|QString
name|QDateTimeParser
operator|::
name|sectionText
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|NoSectionIndex
case|:
case|case
name|FirstSectionIndex
case|:
case|case
name|LastSectionIndex
case|:
return|return
name|QString
argument_list|()
return|;
default|default:
break|break;
block|}
return|return
name|displayText
argument_list|()
operator|.
name|mid
argument_list|(
name|sn
operator|.
name|pos
argument_list|,
name|sectionSize
argument_list|(
name|sectionIndex
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_comment
comment|/*!   \internal:skipToNextSection    Parses the part of \a text that corresponds to \a s and returns   the value of that field. Sets *stateptr to the right state if   stateptr != 0. */
end_comment
begin_function
DECL|function|parseSection
name|int
name|QDateTimeParser
operator|::
name|parseSection
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|currentValue
parameter_list|,
name|int
name|sectionIndex
parameter_list|,
name|QString
modifier|&
name|text
parameter_list|,
name|int
modifier|&
name|cursorPosition
parameter_list|,
name|int
name|index
parameter_list|,
name|State
modifier|&
name|state
parameter_list|,
name|int
modifier|*
name|usedptr
parameter_list|)
specifier|const
block|{
name|state
operator|=
name|Invalid
expr_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sn
operator|.
name|type
operator|&
name|Internal
operator|)
operator|==
name|Internal
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::parseSection Internal error (%s %d)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|,
name|sectionIndex
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
specifier|const
name|int
name|sectionmaxsize
init|=
name|sectionMaxSize
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
name|QString
name|sectiontext
init|=
name|text
operator|.
name|mid
argument_list|(
name|index
argument_list|,
name|sectionmaxsize
argument_list|)
decl_stmt|;
name|int
name|sectiontextSize
init|=
name|sectiontext
operator|.
name|size
argument_list|()
decl_stmt|;
name|QDTPDEBUG
operator|<<
literal|"sectionValue for"
operator|<<
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
operator|<<
literal|"with text"
operator|<<
name|text
operator|<<
literal|"and st"
operator|<<
name|sectiontext
operator|<<
name|text
operator|.
name|mid
argument_list|(
name|index
argument_list|,
name|sectionmaxsize
argument_list|)
operator|<<
name|index
expr_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|AmPmSection
case|:
block|{
specifier|const
name|int
name|ampm
init|=
name|findAmPm
argument_list|(
name|sectiontext
argument_list|,
name|sectionIndex
argument_list|,
operator|&
name|used
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ampm
condition|)
block|{
case|case
name|AM
case|:
comment|// sectiontext == AM
case|case
name|PM
case|:
comment|// sectiontext == PM
name|num
operator|=
name|ampm
expr_stmt|;
name|state
operator|=
name|Acceptable
expr_stmt|;
break|break;
case|case
name|PossibleAM
case|:
comment|// sectiontext => AM
case|case
name|PossiblePM
case|:
comment|// sectiontext => PM
name|num
operator|=
name|ampm
operator|-
literal|2
expr_stmt|;
name|state
operator|=
name|Intermediate
expr_stmt|;
break|break;
case|case
name|PossibleBoth
case|:
comment|// sectiontext => AM|PM
name|num
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|Intermediate
expr_stmt|;
break|break;
case|case
name|Neither
case|:
name|state
operator|=
name|Invalid
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"invalid because findAmPm("
operator|<<
name|sectiontext
operator|<<
literal|") returned -1"
expr_stmt|;
break|break;
default|default:
name|QDTPDEBUGN
argument_list|(
literal|"This should never happen (findAmPm returned %d)"
argument_list|,
name|ampm
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|state
operator|!=
name|Invalid
condition|)
block|{
name|QString
name|str
init|=
name|text
decl_stmt|;
name|text
operator|.
name|replace
argument_list|(
name|index
argument_list|,
name|used
argument_list|,
name|sectiontext
operator|.
name|left
argument_list|(
name|used
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MonthSection
case|:
case|case
name|DayOfWeekSection
case|:
if|if
condition|(
name|sn
operator|.
name|count
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|sn
operator|.
name|type
operator|==
name|MonthSection
condition|)
block|{
name|int
name|min
init|=
literal|1
decl_stmt|;
specifier|const
name|QDate
name|minDate
init|=
name|getMinimum
argument_list|()
operator|.
name|date
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
operator|==
name|minDate
operator|.
name|year
argument_list|()
condition|)
block|{
name|min
operator|=
name|minDate
operator|.
name|month
argument_list|()
expr_stmt|;
block|}
name|num
operator|=
name|findMonth
argument_list|(
name|sectiontext
operator|.
name|toLower
argument_list|()
argument_list|,
name|min
argument_list|,
name|sectionIndex
argument_list|,
operator|&
name|sectiontext
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|=
name|findDay
argument_list|(
name|sectiontext
operator|.
name|toLower
argument_list|()
argument_list|,
literal|1
argument_list|,
name|sectionIndex
argument_list|,
operator|&
name|sectiontext
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
name|state
operator|=
operator|(
name|used
operator|==
name|sectiontext
operator|.
name|size
argument_list|()
condition|?
name|Acceptable
else|:
name|Intermediate
operator|)
expr_stmt|;
name|QString
name|str
init|=
name|text
decl_stmt|;
name|text
operator|.
name|replace
argument_list|(
name|index
argument_list|,
name|used
argument_list|,
name|sectiontext
operator|.
name|left
argument_list|(
name|used
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|Intermediate
expr_stmt|;
block|}
break|break;
block|}
comment|// fall through
case|case
name|DaySection
case|:
case|case
name|YearSection
case|:
case|case
name|YearSection2Digits
case|:
case|case
name|Hour12Section
case|:
case|case
name|Hour24Section
case|:
case|case
name|MinuteSection
case|:
case|case
name|SecondSection
case|:
case|case
name|MSecSection
case|:
block|{
if|if
condition|(
name|sectiontextSize
operator|==
literal|0
condition|)
block|{
name|num
operator|=
literal|0
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|Intermediate
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|absMax
init|=
name|absoluteMax
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
name|QLocale
name|loc
decl_stmt|;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
name|int
name|last
init|=
operator|-
literal|1
decl_stmt|;
name|used
operator|=
operator|-
literal|1
expr_stmt|;
name|QString
name|digitsStr
argument_list|(
name|sectiontext
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sectiontextSize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|digitsStr
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|sectiontextSize
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
specifier|const
name|int
name|max
init|=
name|qMin
argument_list|(
name|sectionmaxsize
argument_list|,
name|sectiontextSize
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|digits
init|=
name|max
init|;
name|digits
operator|>=
literal|1
condition|;
operator|--
name|digits
control|)
block|{
name|digitsStr
operator|.
name|truncate
argument_list|(
name|digits
argument_list|)
expr_stmt|;
name|int
name|tmp
init|=
operator|(
name|int
operator|)
name|loc
operator|.
name|toUInt
argument_list|(
name|digitsStr
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
operator|&&
name|sn
operator|.
name|type
operator|==
name|Hour12Section
condition|)
block|{
if|if
condition|(
name|tmp
operator|>
literal|12
condition|)
block|{
name|tmp
operator|=
operator|-
literal|1
expr_stmt|;
name|ok
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmp
operator|==
literal|12
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ok
operator|&&
name|tmp
operator|<=
name|absMax
condition|)
block|{
name|QDTPDEBUG
operator|<<
name|sectiontext
operator|.
name|left
argument_list|(
name|digits
argument_list|)
operator|<<
name|tmp
operator|<<
name|digits
expr_stmt|;
name|last
operator|=
name|tmp
expr_stmt|;
name|used
operator|=
name|digits
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
block|{
name|QChar
name|first
argument_list|(
name|sectiontext
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|separators
operator|.
name|at
argument_list|(
name|sectionIndex
operator|+
literal|1
argument_list|)
operator|.
name|startsWith
argument_list|(
name|first
argument_list|)
condition|)
block|{
name|used
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|Intermediate
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|Invalid
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"invalid because"
operator|<<
name|sectiontext
operator|<<
literal|"can't become a uint"
operator|<<
name|last
operator|<<
name|ok
expr_stmt|;
block|}
block|}
else|else
block|{
name|num
operator|+=
name|last
expr_stmt|;
specifier|const
name|FieldInfo
name|fi
init|=
name|fieldInfo
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|done
init|=
operator|(
name|used
operator|==
name|sectionmaxsize
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|done
operator|&&
name|fi
operator|&
name|Fraction
condition|)
block|{
comment|// typing 2 in a zzz field should be .200, not .002
for|for
control|(
name|int
name|i
init|=
name|used
init|;
name|i
operator|<
name|sectionmaxsize
condition|;
operator|++
name|i
control|)
block|{
name|num
operator|*=
literal|10
expr_stmt|;
block|}
block|}
specifier|const
name|int
name|absMin
init|=
name|absoluteMin
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|<
name|absMin
condition|)
block|{
name|state
operator|=
name|done
condition|?
name|Invalid
else|:
name|Intermediate
expr_stmt|;
if|if
condition|(
name|done
condition|)
name|QDTPDEBUG
operator|<<
literal|"invalid because"
operator|<<
name|num
operator|<<
literal|"is less than absoluteMin"
operator|<<
name|absMin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num
operator|>
name|absMax
condition|)
block|{
name|state
operator|=
name|Intermediate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|done
operator|&&
operator|(
name|fi
operator|&
operator|(
name|FixedWidth
operator||
name|Numeric
operator|)
operator|)
operator|==
operator|(
name|FixedWidth
operator||
name|Numeric
operator|)
condition|)
block|{
if|if
condition|(
name|skipToNextSection
argument_list|(
name|sectionIndex
argument_list|,
name|currentValue
argument_list|,
name|digitsStr
argument_list|)
condition|)
block|{
name|state
operator|=
name|Acceptable
expr_stmt|;
specifier|const
name|int
name|missingZeroes
init|=
name|sectionmaxsize
operator|-
name|digitsStr
operator|.
name|size
argument_list|()
decl_stmt|;
name|text
operator|.
name|insert
argument_list|(
name|index
argument_list|,
name|QString
argument_list|()
operator|.
name|fill
argument_list|(
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
name|missingZeroes
argument_list|)
argument_list|)
expr_stmt|;
name|used
operator|=
name|sectionmaxsize
expr_stmt|;
name|cursorPosition
operator|+=
name|missingZeroes
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|Intermediate
expr_stmt|;
empty_stmt|;
block|}
block|}
else|else
block|{
name|state
operator|=
name|Acceptable
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::parseSection Internal error (%s %d)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|,
name|sectionIndex
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|usedptr
condition|)
operator|*
name|usedptr
operator|=
name|used
expr_stmt|;
return|return
operator|(
name|state
operator|!=
name|Invalid
condition|?
name|num
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTDATE
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|parse
name|QDateTimeParser
operator|::
name|StateNode
name|QDateTimeParser
operator|::
name|parse
parameter_list|(
name|QString
modifier|&
name|input
parameter_list|,
name|int
modifier|&
name|cursorPosition
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|currentValue
parameter_list|,
name|bool
name|fixup
parameter_list|)
specifier|const
block|{
specifier|const
name|QDateTime
name|minimum
init|=
name|getMinimum
argument_list|()
decl_stmt|;
specifier|const
name|QDateTime
name|maximum
init|=
name|getMaximum
argument_list|()
decl_stmt|;
name|State
name|state
init|=
name|Acceptable
decl_stmt|;
name|QDateTime
name|newCurrentValue
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|bool
name|conflicts
init|=
literal|false
decl_stmt|;
specifier|const
name|int
name|sectionNodesCount
init|=
name|sectionNodes
operator|.
name|size
argument_list|()
decl_stmt|;
name|QDTPDEBUG
operator|<<
literal|"parse"
operator|<<
name|input
expr_stmt|;
block|{
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hour12
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|,
name|msec
decl_stmt|,
name|ampm
decl_stmt|,
name|dayofweek
decl_stmt|,
name|year2digits
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|toJulianDay
argument_list|()
argument_list|,
operator|&
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|)
expr_stmt|;
name|year2digits
operator|=
name|year
operator|%
literal|100
expr_stmt|;
name|hour
operator|=
name|currentValue
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
expr_stmt|;
name|hour12
operator|=
operator|-
literal|1
expr_stmt|;
name|minute
operator|=
name|currentValue
operator|.
name|time
argument_list|()
operator|.
name|minute
argument_list|()
expr_stmt|;
name|second
operator|=
name|currentValue
operator|.
name|time
argument_list|()
operator|.
name|second
argument_list|()
expr_stmt|;
name|msec
operator|=
name|currentValue
operator|.
name|time
argument_list|()
operator|.
name|msec
argument_list|()
expr_stmt|;
name|dayofweek
operator|=
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|dayOfWeek
argument_list|()
expr_stmt|;
name|ampm
operator|=
operator|-
literal|1
expr_stmt|;
name|Sections
name|isSet
init|=
name|NoSection
decl_stmt|;
name|int
name|num
decl_stmt|;
name|State
name|tmpstate
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|state
operator|!=
name|Invalid
operator|&&
name|index
operator|<
name|sectionNodesCount
condition|;
operator|++
name|index
control|)
block|{
if|if
condition|(
name|QStringRef
argument_list|(
operator|&
name|input
argument_list|,
name|pos
argument_list|,
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
operator|!=
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"invalid because"
operator|<<
name|input
operator|.
name|mid
argument_list|(
name|pos
argument_list|,
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
operator|<<
literal|"!="
operator|<<
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|<<
name|index
operator|<<
name|pos
operator|<<
name|currentSectionIndex
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|pos
operator|+=
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
name|sectionNodes
index|[
name|index
index|]
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
name|int
modifier|*
name|current
init|=
literal|0
decl_stmt|;
specifier|const
name|SectionNode
name|sn
init|=
name|sectionNodes
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|used
decl_stmt|;
name|num
operator|=
name|parseSection
argument_list|(
name|currentValue
argument_list|,
name|index
argument_list|,
name|input
argument_list|,
name|cursorPosition
argument_list|,
name|pos
argument_list|,
name|tmpstate
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"sectionValue"
operator|<<
name|sectionName
argument_list|(
name|sectionType
argument_list|(
name|index
argument_list|)
argument_list|)
operator|<<
name|input
operator|<<
literal|"pos"
operator|<<
name|pos
operator|<<
literal|"used"
operator|<<
name|used
operator|<<
name|stateName
argument_list|(
name|tmpstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixup
operator|&&
name|tmpstate
operator|==
name|Intermediate
operator|&&
name|used
operator|<
name|sn
operator|.
name|count
condition|)
block|{
specifier|const
name|FieldInfo
name|fi
init|=
name|fieldInfo
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|fi
operator|&
operator|(
name|Numeric
operator||
name|FixedWidth
operator|)
operator|)
operator|==
operator|(
name|Numeric
operator||
name|FixedWidth
operator|)
condition|)
block|{
specifier|const
name|QString
name|newText
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|num
argument_list|,
name|sn
operator|.
name|count
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
decl_stmt|;
name|input
operator|.
name|replace
argument_list|(
name|pos
argument_list|,
name|used
argument_list|,
name|newText
argument_list|)
expr_stmt|;
name|used
operator|=
name|sn
operator|.
name|count
expr_stmt|;
block|}
block|}
name|pos
operator|+=
name|qMax
argument_list|(
literal|0
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|state
operator|=
name|qMin
argument_list|<
name|State
argument_list|>
argument_list|(
name|state
argument_list|,
name|tmpstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|Intermediate
operator|&&
name|context
operator|==
name|FromString
condition|)
block|{
name|state
operator|=
name|Invalid
expr_stmt|;
break|break;
block|}
name|QDTPDEBUG
operator|<<
name|index
operator|<<
name|sectionName
argument_list|(
name|sectionType
argument_list|(
name|index
argument_list|)
argument_list|)
operator|<<
literal|"is set to"
operator|<<
name|pos
operator|<<
literal|"state is"
operator|<<
name|stateName
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|Invalid
condition|)
block|{
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
name|current
operator|=
operator|&
name|hour
expr_stmt|;
break|break;
case|case
name|Hour12Section
case|:
name|current
operator|=
operator|&
name|hour12
expr_stmt|;
break|break;
case|case
name|MinuteSection
case|:
name|current
operator|=
operator|&
name|minute
expr_stmt|;
break|break;
case|case
name|SecondSection
case|:
name|current
operator|=
operator|&
name|second
expr_stmt|;
break|break;
case|case
name|MSecSection
case|:
name|current
operator|=
operator|&
name|msec
expr_stmt|;
break|break;
case|case
name|YearSection
case|:
name|current
operator|=
operator|&
name|year
expr_stmt|;
break|break;
case|case
name|YearSection2Digits
case|:
name|current
operator|=
operator|&
name|year2digits
expr_stmt|;
break|break;
case|case
name|MonthSection
case|:
name|current
operator|=
operator|&
name|month
expr_stmt|;
break|break;
case|case
name|DayOfWeekSection
case|:
name|current
operator|=
operator|&
name|dayofweek
expr_stmt|;
break|break;
case|case
name|DaySection
case|:
name|current
operator|=
operator|&
name|day
expr_stmt|;
name|num
operator|=
name|qMax
argument_list|<
name|int
argument_list|>
argument_list|(
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
name|AmPmSection
case|:
name|current
operator|=
operator|&
name|ampm
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::parse Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|current
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::parse Internal error 2"
argument_list|)
expr_stmt|;
return|return
name|StateNode
argument_list|()
return|;
block|}
if|if
condition|(
name|isSet
operator|&
name|sn
operator|.
name|type
operator|&&
operator|*
name|current
operator|!=
name|num
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"CONFLICT "
operator|<<
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
operator|<<
operator|*
name|current
operator|<<
name|num
expr_stmt|;
name|conflicts
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|index
operator|!=
name|currentSectionIndex
operator|||
name|num
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
operator|*
name|current
operator|=
name|num
expr_stmt|;
name|isSet
operator||=
name|sn
operator|.
name|type
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
operator|!=
name|Invalid
operator|&&
name|QStringRef
argument_list|(
operator|&
name|input
argument_list|,
name|pos
argument_list|,
name|input
operator|.
name|size
argument_list|()
operator|-
name|pos
argument_list|)
operator|!=
name|separators
operator|.
name|last
argument_list|()
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"invalid because"
operator|<<
name|input
operator|.
name|mid
argument_list|(
name|pos
argument_list|)
operator|<<
literal|"!="
operator|<<
name|separators
operator|.
name|last
argument_list|()
operator|<<
name|pos
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|!=
name|Invalid
condition|)
block|{
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Time
condition|)
block|{
if|if
condition|(
name|year
operator|%
literal|100
operator|!=
name|year2digits
condition|)
block|{
switch|switch
condition|(
name|isSet
operator|&
operator|(
name|YearSection2Digits
operator||
name|YearSection
operator|)
condition|)
block|{
case|case
name|YearSection2Digits
case|:
name|year
operator|=
operator|(
name|year
operator|/
literal|100
operator|)
operator|*
literal|100
expr_stmt|;
name|year
operator|+=
name|year2digits
expr_stmt|;
break|break;
case|case
operator|(
operator|(
name|uint
operator|)
name|YearSection2Digits
operator||
operator|(
name|uint
operator|)
name|YearSection
operator|)
case|:
block|{
name|conflicts
operator|=
literal|true
expr_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|currentSectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|==
name|YearSection2Digits
condition|)
block|{
name|year
operator|=
operator|(
name|year
operator|/
literal|100
operator|)
operator|*
literal|100
expr_stmt|;
name|year
operator|+=
name|year2digits
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
specifier|const
name|QDate
name|date
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
decl_stmt|;
specifier|const
name|int
name|diff
init|=
name|dayofweek
operator|-
name|date
operator|.
name|dayOfWeek
argument_list|()
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
operator|&&
name|state
operator|==
name|Acceptable
operator|&&
name|isSet
operator|&
name|DayOfWeekSection
condition|)
block|{
name|conflicts
operator|=
name|isSet
operator|&
name|DaySection
expr_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|currentSectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|==
name|DayOfWeekSection
operator|||
name|currentSectionIndex
operator|==
operator|-
literal|1
condition|)
block|{
comment|// dayofweek should be preferred
name|day
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
name|day
operator|<=
literal|0
condition|)
block|{
name|day
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|day
operator|>
name|date
operator|.
name|daysInMonth
argument_list|()
condition|)
block|{
name|day
operator|-=
literal|7
expr_stmt|;
block|}
name|QDTPDEBUG
operator|<<
name|year
operator|<<
name|month
operator|<<
name|day
operator|<<
name|dayofweek
operator|<<
name|diff
operator|<<
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
operator|.
name|dayOfWeek
argument_list|()
expr_stmt|;
block|}
block|}
name|bool
name|needfixday
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|sectionType
argument_list|(
name|currentSectionIndex
argument_list|)
operator|&
operator|(
name|DaySection
operator||
name|DayOfWeekSection
operator|)
condition|)
block|{
name|cachedDay
operator|=
name|day
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cachedDay
operator|>
name|day
condition|)
block|{
name|day
operator|=
name|cachedDay
expr_stmt|;
name|needfixday
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|QDate
operator|::
name|isValid
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
condition|)
block|{
if|if
condition|(
name|day
operator|<
literal|32
condition|)
block|{
name|cachedDay
operator|=
name|day
expr_stmt|;
block|}
if|if
condition|(
name|day
operator|>
literal|28
operator|&&
name|QDate
operator|::
name|isValid
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|needfixday
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needfixday
condition|)
block|{
if|if
condition|(
name|context
operator|==
name|FromString
condition|)
block|{
name|state
operator|=
name|Invalid
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|state
operator|==
name|Acceptable
operator|&&
name|fixday
condition|)
block|{
name|day
operator|=
name|qMin
argument_list|<
name|int
argument_list|>
argument_list|(
name|day
argument_list|,
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
literal|1
argument_list|)
operator|.
name|daysInMonth
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|QLocale
name|loc
init|=
name|locale
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sectionNodesCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sectionType
argument_list|(
name|i
argument_list|)
operator|&
operator|(
name|DaySection
operator||
name|DayOfWeekSection
operator|)
condition|)
block|{
name|input
operator|.
name|replace
argument_list|(
name|sectionPos
argument_list|(
name|i
argument_list|)
argument_list|,
name|sectionSize
argument_list|(
name|i
argument_list|)
argument_list|,
name|loc
operator|.
name|toString
argument_list|(
name|day
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|state
operator|=
name|qMin
argument_list|(
name|Intermediate
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
if|if
condition|(
name|isSet
operator|&
name|Hour12Section
condition|)
block|{
specifier|const
name|bool
name|hasHour
init|=
name|isSet
operator|&
name|Hour24Section
decl_stmt|;
if|if
condition|(
name|ampm
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|hasHour
condition|)
block|{
name|ampm
operator|=
operator|(
name|hour
operator|<
literal|12
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ampm
operator|=
literal|0
expr_stmt|;
comment|// no way to tell if this is am or pm so I assume am
block|}
block|}
name|hour12
operator|=
operator|(
name|ampm
operator|==
literal|0
condition|?
name|hour12
operator|%
literal|12
else|:
operator|(
name|hour12
operator|%
literal|12
operator|)
operator|+
literal|12
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasHour
condition|)
block|{
name|hour
operator|=
name|hour12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hour
operator|!=
name|hour12
condition|)
block|{
name|conflicts
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ampm
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isSet
operator|&
operator|(
name|Hour24Section
operator|)
operator|)
condition|)
block|{
name|hour
operator|=
operator|(
literal|12
operator|*
name|ampm
operator|)
expr_stmt|;
comment|// special case. Only ap section
block|}
elseif|else
if|if
condition|(
operator|(
name|ampm
operator|==
literal|0
operator|)
operator|!=
operator|(
name|hour
operator|<
literal|12
operator|)
condition|)
block|{
name|conflicts
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|newCurrentValue
operator|=
name|QDateTime
argument_list|(
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
argument_list|,
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|msec
argument_list|)
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
name|year
operator|<<
name|month
operator|<<
name|day
operator|<<
name|hour
operator|<<
name|minute
operator|<<
name|second
operator|<<
name|msec
expr_stmt|;
block|}
name|QDTPDEBUGN
argument_list|(
literal|"'%s' => '%s'(%s)"
argument_list|,
name|input
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|newCurrentValue
operator|.
name|toString
argument_list|(
name|QLatin1String
argument_list|(
literal|"yyyy/MM/dd hh:mm:ss.zzz"
argument_list|)
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|stateName
argument_list|(
name|state
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|newCurrentValue
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|context
operator|!=
name|FromString
operator|&&
name|state
operator|!=
name|Invalid
operator|&&
name|newCurrentValue
operator|<
name|minimum
condition|)
block|{
specifier|const
name|QLatin1Char
name|space
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|newCurrentValue
operator|>=
name|minimum
condition|)
name|qWarning
argument_list|(
literal|"QDateTimeParser::parse Internal error 3 (%s %s)"
argument_list|,
name|qPrintable
argument_list|(
name|newCurrentValue
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|minimum
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|done
init|=
literal|false
decl_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sectionNodesCount
operator|&&
operator|!
name|done
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNodes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QString
name|t
init|=
name|sectionText
argument_list|(
name|input
argument_list|,
name|i
argument_list|,
name|sn
operator|.
name|pos
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|.
name|size
argument_list|()
operator|<
name|sectionMaxSize
argument_list|(
name|i
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|int
operator|)
name|fieldInfo
argument_list|(
name|i
argument_list|)
operator|&
operator|(
name|FixedWidth
operator||
name|Numeric
operator|)
operator|)
operator|!=
name|Numeric
operator|)
operator|)
operator|||
name|t
operator|.
name|contains
argument_list|(
name|space
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|AmPmSection
case|:
switch|switch
condition|(
name|findAmPm
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
block|{
case|case
name|AM
case|:
case|case
name|PM
case|:
name|state
operator|=
name|Acceptable
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Neither
case|:
name|state
operator|=
name|Invalid
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|PossibleAM
case|:
case|case
name|PossiblePM
case|:
case|case
name|PossibleBoth
case|:
block|{
specifier|const
name|QDateTime
name|copy
argument_list|(
name|newCurrentValue
operator|.
name|addSecs
argument_list|(
literal|12
operator|*
literal|60
operator|*
literal|60
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy
operator|>=
name|minimum
operator|&&
name|copy
operator|<=
name|maximum
condition|)
block|{
name|state
operator|=
name|Intermediate
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
block|}
case|case
name|MonthSection
case|:
if|if
condition|(
name|sn
operator|.
name|count
operator|>=
literal|3
condition|)
block|{
name|int
name|tmp
init|=
name|newCurrentValue
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
decl_stmt|;
comment|// I know the first possible month makes the date too early
while|while
condition|(
operator|(
name|tmp
operator|=
name|findMonth
argument_list|(
name|t
argument_list|,
name|tmp
operator|+
literal|1
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
specifier|const
name|QDateTime
name|copy
argument_list|(
name|newCurrentValue
operator|.
name|addMonths
argument_list|(
name|tmp
operator|-
name|newCurrentValue
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy
operator|>=
name|minimum
operator|&&
name|copy
operator|<=
name|maximum
condition|)
break|break;
comment|// break out of while
block|}
if|if
condition|(
name|tmp
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|state
operator|=
name|Intermediate
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
comment|// fallthrough
default|default:
block|{
name|int
name|toMin
decl_stmt|;
name|int
name|toMax
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|&
name|TimeSectionMask
condition|)
block|{
if|if
condition|(
name|newCurrentValue
operator|.
name|daysTo
argument_list|(
name|minimum
argument_list|)
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|toMin
operator|=
name|newCurrentValue
operator|.
name|time
argument_list|()
operator|.
name|msecsTo
argument_list|(
name|minimum
operator|.
name|time
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newCurrentValue
operator|.
name|daysTo
argument_list|(
name|maximum
argument_list|)
operator|>
literal|0
condition|)
block|{
name|toMax
operator|=
operator|-
literal|1
expr_stmt|;
comment|// can't get to max
block|}
else|else
block|{
name|toMax
operator|=
name|newCurrentValue
operator|.
name|time
argument_list|()
operator|.
name|msecsTo
argument_list|(
name|maximum
operator|.
name|time
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|toMin
operator|=
name|newCurrentValue
operator|.
name|daysTo
argument_list|(
name|minimum
argument_list|)
expr_stmt|;
name|toMax
operator|=
name|newCurrentValue
operator|.
name|daysTo
argument_list|(
name|maximum
argument_list|)
expr_stmt|;
block|}
specifier|const
name|int
name|maxChange
init|=
name|QDateTimeParser
operator|::
name|maxChange
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|toMin
operator|>
name|maxChange
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"invalid because toMin> maxChange"
operator|<<
name|toMin
operator|<<
name|maxChange
operator|<<
name|t
operator|<<
name|newCurrentValue
operator|<<
name|minimum
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|toMax
operator|>
name|maxChange
condition|)
block|{
name|toMax
operator|=
operator|-
literal|1
expr_stmt|;
comment|// can't get to max
block|}
specifier|const
name|int
name|min
init|=
name|getDigit
argument_list|(
name|minimum
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|min
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::parse Internal error 4 (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|int
name|max
init|=
name|toMax
operator|!=
operator|-
literal|1
condition|?
name|getDigit
argument_list|(
name|maximum
argument_list|,
name|i
argument_list|)
else|:
name|absoluteMax
argument_list|(
name|i
argument_list|,
name|newCurrentValue
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|cursorPosition
operator|-
name|sn
operator|.
name|pos
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>=
name|t
operator|.
name|size
argument_list|()
condition|)
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|potentialValue
argument_list|(
name|t
operator|.
name|simplified
argument_list|()
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|i
argument_list|,
name|newCurrentValue
argument_list|,
name|pos
argument_list|)
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"invalid because potentialValue("
operator|<<
name|t
operator|.
name|simplified
argument_list|()
operator|<<
name|min
operator|<<
name|max
operator|<<
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
operator|<<
literal|"returned"
operator|<<
name|toMax
operator|<<
name|toMin
operator|<<
name|pos
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|state
operator|=
name|Intermediate
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|context
operator|==
name|FromString
condition|)
block|{
comment|// optimization
name|Q_ASSERT
argument_list|(
name|getMaximum
argument_list|()
operator|.
name|date
argument_list|()
operator|.
name|toJulianDay
argument_list|()
operator|==
literal|4642999
argument_list|)
expr_stmt|;
if|if
condition|(
name|newCurrentValue
operator|.
name|date
argument_list|()
operator|.
name|toJulianDay
argument_list|()
operator|>
literal|4642999
condition|)
name|state
operator|=
name|Invalid
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|newCurrentValue
operator|>
name|getMaximum
argument_list|()
condition|)
name|state
operator|=
name|Invalid
expr_stmt|;
block|}
name|QDTPDEBUG
operator|<<
literal|"not checking intermediate because newCurrentValue is"
operator|<<
name|newCurrentValue
operator|<<
name|getMinimum
argument_list|()
operator|<<
name|getMaximum
argument_list|()
expr_stmt|;
block|}
block|}
name|StateNode
name|node
decl_stmt|;
name|node
operator|.
name|input
operator|=
name|input
expr_stmt|;
name|node
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|node
operator|.
name|conflicts
operator|=
name|conflicts
expr_stmt|;
name|node
operator|.
name|value
operator|=
name|newCurrentValue
operator|.
name|toTimeSpec
argument_list|(
name|spec
argument_list|)
expr_stmt|;
name|text
operator|=
name|input
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_comment
comment|/*!   \internal finds the first possible monthname that \a str1 can   match. Starting from \a index; str should already by lowered */
end_comment
begin_function
DECL|function|findMonth
name|int
name|QDateTimeParser
operator|::
name|findMonth
parameter_list|(
specifier|const
name|QString
modifier|&
name|str1
parameter_list|,
name|int
name|startMonth
parameter_list|,
name|int
name|sectionIndex
parameter_list|,
name|QString
modifier|*
name|usedMonth
parameter_list|,
name|int
modifier|*
name|used
parameter_list|)
specifier|const
block|{
name|int
name|bestMatch
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bestCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|str1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|!=
name|MonthSection
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::findMonth Internal error"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|QLocale
operator|::
name|FormatType
name|type
init|=
name|sn
operator|.
name|count
operator|==
literal|3
condition|?
name|QLocale
operator|::
name|ShortFormat
else|:
name|QLocale
operator|::
name|LongFormat
decl_stmt|;
name|QLocale
name|l
init|=
name|locale
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|month
init|=
name|startMonth
init|;
name|month
operator|<=
literal|12
condition|;
operator|++
name|month
control|)
block|{
name|QString
name|str2
init|=
name|l
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|type
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|str1
operator|.
name|startsWith
argument_list|(
name|str2
argument_list|)
condition|)
block|{
if|if
condition|(
name|used
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"used is set to"
operator|<<
name|str2
operator|.
name|size
argument_list|()
expr_stmt|;
operator|*
name|used
operator|=
name|str2
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|usedMonth
condition|)
operator|*
name|usedMonth
operator|=
name|l
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|month
return|;
block|}
if|if
condition|(
name|context
operator|==
name|FromString
condition|)
continue|continue;
specifier|const
name|int
name|limit
init|=
name|qMin
argument_list|(
name|str1
operator|.
name|size
argument_list|()
argument_list|,
name|str2
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|QDTPDEBUG
operator|<<
literal|"limit is"
operator|<<
name|limit
operator|<<
name|str1
operator|<<
name|str2
expr_stmt|;
name|bool
name|equal
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|str1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|str2
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|equal
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|bestCount
condition|)
block|{
name|bestCount
operator|=
name|i
expr_stmt|;
name|bestMatch
operator|=
name|month
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|equal
condition|)
block|{
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|usedMonth
condition|)
operator|*
name|usedMonth
operator|=
name|l
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|month
return|;
block|}
block|}
if|if
condition|(
name|usedMonth
operator|&&
name|bestMatch
operator|!=
operator|-
literal|1
condition|)
operator|*
name|usedMonth
operator|=
name|l
operator|.
name|monthName
argument_list|(
name|bestMatch
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|used
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"used is set to"
operator|<<
name|bestCount
expr_stmt|;
operator|*
name|used
operator|=
name|bestCount
expr_stmt|;
block|}
return|return
name|bestMatch
return|;
block|}
end_function
begin_function
DECL|function|findDay
name|int
name|QDateTimeParser
operator|::
name|findDay
parameter_list|(
specifier|const
name|QString
modifier|&
name|str1
parameter_list|,
name|int
name|startDay
parameter_list|,
name|int
name|sectionIndex
parameter_list|,
name|QString
modifier|*
name|usedDay
parameter_list|,
name|int
modifier|*
name|used
parameter_list|)
specifier|const
block|{
name|int
name|bestMatch
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bestCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|str1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sn
operator|.
name|type
operator|&
operator|(
name|DaySection
operator||
name|DayOfWeekSection
operator|)
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::findDay Internal error"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
specifier|const
name|QLocale
name|l
init|=
name|locale
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|day
init|=
name|startDay
init|;
name|day
operator|<=
literal|7
condition|;
operator|++
name|day
control|)
block|{
specifier|const
name|QString
name|str2
init|=
name|l
operator|.
name|dayName
argument_list|(
name|day
argument_list|,
name|sn
operator|.
name|count
operator|==
literal|4
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|str1
operator|.
name|startsWith
argument_list|(
name|str2
operator|.
name|toLower
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|str2
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|usedDay
condition|)
block|{
operator|*
name|usedDay
operator|=
name|str2
expr_stmt|;
block|}
return|return
name|day
return|;
block|}
if|if
condition|(
name|context
operator|==
name|FromString
condition|)
continue|continue;
specifier|const
name|int
name|limit
init|=
name|qMin
argument_list|(
name|str1
operator|.
name|size
argument_list|()
argument_list|,
name|str2
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|found
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|str1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|str2
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|str1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|bestCount
condition|)
block|{
name|bestCount
operator|=
name|i
expr_stmt|;
name|bestMatch
operator|=
name|day
expr_stmt|;
block|}
name|found
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|usedDay
condition|)
operator|*
name|usedDay
operator|=
name|str2
expr_stmt|;
return|return
name|day
return|;
block|}
block|}
if|if
condition|(
name|usedDay
operator|&&
name|bestMatch
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|usedDay
operator|=
name|l
operator|.
name|dayName
argument_list|(
name|bestMatch
argument_list|,
name|sn
operator|.
name|count
operator|==
literal|4
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|bestCount
expr_stmt|;
return|return
name|bestMatch
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTDATE
end_comment
begin_comment
comment|/*!   \internal    returns   0 if str == QDateTimeEdit::tr("AM")   1 if str == QDateTimeEdit::tr("PM")   2 if str can become QDateTimeEdit::tr("AM")   3 if str can become QDateTimeEdit::tr("PM")   4 if str can become QDateTimeEdit::tr("PM") and can become QDateTimeEdit::tr("AM")   -1 can't become anything sensible  */
end_comment
begin_function
DECL|function|findAmPm
name|int
name|QDateTimeParser
operator|::
name|findAmPm
parameter_list|(
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|index
parameter_list|,
name|int
modifier|*
name|used
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|s
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|type
operator|!=
name|AmPmSection
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::findAmPm Internal error"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|str
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|trimmed
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|PossibleBoth
return|;
block|}
specifier|const
name|QLatin1Char
name|space
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|sectionMaxSize
argument_list|(
name|index
argument_list|)
decl_stmt|;
enum|enum
block|{
name|amindex
init|=
literal|0
block|,
name|pmindex
init|=
literal|1
block|}
enum|;
name|QString
name|ampm
index|[
literal|2
index|]
decl_stmt|;
name|ampm
index|[
name|amindex
index|]
operator|=
name|getAmPmText
argument_list|(
name|AmText
argument_list|,
name|s
operator|.
name|count
operator|==
literal|1
condition|?
name|UpperCase
else|:
name|LowerCase
argument_list|)
expr_stmt|;
name|ampm
index|[
name|pmindex
index|]
operator|=
name|getAmPmText
argument_list|(
name|PmText
argument_list|,
name|s
operator|.
name|count
operator|==
literal|1
condition|?
name|UpperCase
else|:
name|LowerCase
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
name|ampm
index|[
name|i
index|]
operator|.
name|truncate
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"findAmPm"
operator|<<
name|str
operator|<<
name|ampm
index|[
literal|0
index|]
operator|<<
name|ampm
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|indexOf
argument_list|(
name|ampm
index|[
name|amindex
index|]
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
condition|)
block|{
name|str
operator|=
name|ampm
index|[
name|amindex
index|]
expr_stmt|;
return|return
name|AM
return|;
block|}
elseif|else
if|if
condition|(
name|str
operator|.
name|indexOf
argument_list|(
name|ampm
index|[
name|pmindex
index|]
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
condition|)
block|{
name|str
operator|=
name|ampm
index|[
name|pmindex
index|]
expr_stmt|;
return|return
name|PM
return|;
block|}
elseif|else
if|if
condition|(
name|context
operator|==
name|FromString
operator|||
operator|(
name|str
operator|.
name|count
argument_list|(
name|space
argument_list|)
operator|==
literal|0
operator|&&
name|str
operator|.
name|size
argument_list|()
operator|>=
name|size
operator|)
condition|)
block|{
return|return
name|Neither
return|;
block|}
name|size
operator|=
name|qMin
argument_list|(
name|size
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|broken
index|[
literal|2
index|]
init|=
block|{
literal|false
block|,
literal|false
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|space
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
name|broken
index|[
name|j
index|]
condition|)
block|{
name|int
name|index
init|=
name|ampm
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|QDTPDEBUG
operator|<<
literal|"looking for"
operator|<<
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|<<
literal|"in"
operator|<<
name|ampm
index|[
name|j
index|]
operator|<<
literal|"and got"
operator|<<
name|index
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|category
argument_list|()
operator|==
name|QChar
operator|::
name|Letter_Uppercase
condition|)
block|{
name|index
operator|=
name|ampm
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLower
argument_list|()
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"trying with"
operator|<<
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLower
argument_list|()
operator|<<
literal|"in"
operator|<<
name|ampm
index|[
name|j
index|]
operator|<<
literal|"and got"
operator|<<
name|index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|category
argument_list|()
operator|==
name|QChar
operator|::
name|Letter_Lowercase
condition|)
block|{
name|index
operator|=
name|ampm
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toUpper
argument_list|()
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"trying with"
operator|<<
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toUpper
argument_list|()
operator|<<
literal|"in"
operator|<<
name|ampm
index|[
name|j
index|]
operator|<<
literal|"and got"
operator|<<
name|index
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|broken
index|[
name|j
index|]
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|broken
index|[
name|amindex
index|]
operator|&&
name|broken
index|[
name|pmindex
index|]
condition|)
block|{
name|QDTPDEBUG
operator|<<
name|str
operator|<<
literal|"didn't make it"
expr_stmt|;
return|return
name|Neither
return|;
block|}
continue|continue;
block|}
else|else
block|{
name|str
index|[
name|i
index|]
operator|=
name|ampm
index|[
name|j
index|]
operator|.
name|at
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|// fix case
block|}
block|}
name|ampm
index|[
name|j
index|]
operator|.
name|remove
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|broken
index|[
name|pmindex
index|]
operator|&&
operator|!
name|broken
index|[
name|amindex
index|]
condition|)
return|return
name|PossibleBoth
return|;
return|return
operator|(
operator|!
name|broken
index|[
name|amindex
index|]
condition|?
name|PossibleAM
else|:
name|PossiblePM
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Max number of units that can be changed by this section. */
end_comment
begin_function
DECL|function|maxChange
name|int
name|QDateTimeParser
operator|::
name|maxChange
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
comment|// Time. unit is msec
case|case
name|MSecSection
case|:
return|return
literal|999
return|;
case|case
name|SecondSection
case|:
return|return
literal|59
operator|*
literal|1000
return|;
case|case
name|MinuteSection
case|:
return|return
literal|59
operator|*
literal|60
operator|*
literal|1000
return|;
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
return|return
literal|59
operator|*
literal|60
operator|*
literal|60
operator|*
literal|1000
return|;
comment|// Date. unit is day
case|case
name|DayOfWeekSection
case|:
return|return
literal|7
return|;
case|case
name|DaySection
case|:
return|return
literal|30
return|;
case|case
name|MonthSection
case|:
return|return
literal|365
operator|-
literal|31
return|;
case|case
name|YearSection
case|:
return|return
literal|9999
operator|*
literal|365
return|;
case|case
name|YearSection2Digits
case|:
return|return
literal|100
operator|*
literal|365
return|;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::maxChange() Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sectionType
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|fieldInfo
name|QDateTimeParser
operator|::
name|FieldInfo
name|QDateTimeParser
operator|::
name|fieldInfo
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|FieldInfo
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|const
name|Section
name|s
init|=
name|sn
operator|.
name|type
decl_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|MSecSection
case|:
name|ret
operator||=
name|Fraction
expr_stmt|;
comment|// fallthrough
case|case
name|SecondSection
case|:
case|case
name|MinuteSection
case|:
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
case|case
name|YearSection
case|:
case|case
name|YearSection2Digits
case|:
name|ret
operator||=
name|Numeric
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|YearSection
condition|)
block|{
name|ret
operator||=
name|AllowPartial
expr_stmt|;
block|}
if|if
condition|(
name|sn
operator|.
name|count
operator|!=
literal|1
condition|)
block|{
name|ret
operator||=
name|FixedWidth
expr_stmt|;
block|}
break|break;
case|case
name|MonthSection
case|:
case|case
name|DaySection
case|:
switch|switch
condition|(
name|sn
operator|.
name|count
condition|)
block|{
case|case
literal|2
case|:
name|ret
operator||=
name|FixedWidth
expr_stmt|;
comment|// fallthrough
case|case
literal|1
case|:
name|ret
operator||=
operator|(
name|Numeric
operator||
name|AllowPartial
operator|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DayOfWeekSection
case|:
if|if
condition|(
name|sn
operator|.
name|count
operator|==
literal|3
condition|)
name|ret
operator||=
name|FixedWidth
expr_stmt|;
break|break;
case|case
name|AmPmSection
case|:
name|ret
operator||=
name|FixedWidth
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::fieldInfo Internal error 2 (%d %s %d)"
argument_list|,
name|index
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|,
name|sn
operator|.
name|count
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!   \internal Get a number that str can become which is between min   and max or -1 if this is not possible. */
end_comment
begin_function
DECL|function|sectionFormat
name|QString
name|QDateTimeParser
operator|::
name|sectionFormat
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|sectionFormat
argument_list|(
name|sn
operator|.
name|type
argument_list|,
name|sn
operator|.
name|count
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sectionFormat
name|QString
name|QDateTimeParser
operator|::
name|sectionFormat
parameter_list|(
name|Section
name|s
parameter_list|,
name|int
name|count
parameter_list|)
specifier|const
block|{
name|QChar
name|fillChar
decl_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|AmPmSection
case|:
return|return
name|count
operator|==
literal|1
condition|?
name|QLatin1String
argument_list|(
literal|"AP"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"ap"
argument_list|)
return|;
case|case
name|MSecSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'z'
argument_list|)
expr_stmt|;
break|break;
case|case
name|SecondSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
break|break;
case|case
name|MinuteSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'m'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Hour24Section
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'H'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Hour12Section
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'h'
argument_list|)
expr_stmt|;
break|break;
case|case
name|DayOfWeekSection
case|:
case|case
name|DaySection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
break|break;
case|case
name|MonthSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
break|break;
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'y'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionFormat Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
if|if
condition|(
name|fillChar
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionFormat Internal error 2"
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QString
name|str
decl_stmt|;
name|str
operator|.
name|fill
argument_list|(
name|fillChar
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function
begin_comment
comment|/*! \internal Returns true if str can be modified to represent a   number that is within min and max. */
end_comment
begin_function
DECL|function|potentialValue
name|bool
name|QDateTimeParser
operator|::
name|potentialValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|currentValue
parameter_list|,
name|int
name|insert
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|const
name|int
name|size
init|=
name|sectionMaxSize
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|val
init|=
operator|(
name|int
operator|)
name|locale
argument_list|()
operator|.
name|toUInt
argument_list|(
name|str
argument_list|)
decl_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|==
name|YearSection2Digits
condition|)
block|{
name|val
operator|+=
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
operator|-
operator|(
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
operator|%
literal|100
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|>=
name|min
operator|&&
name|val
operator|<=
name|max
operator|&&
name|str
operator|.
name|size
argument_list|()
operator|==
name|size
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|val
operator|>
name|max
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|str
operator|.
name|size
argument_list|()
operator|==
name|size
operator|&&
name|val
operator|<
name|min
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|const
name|int
name|len
init|=
name|size
operator|-
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|potentialValue
argument_list|(
name|str
operator|+
name|QLatin1Char
argument_list|(
literal|'0'
operator|+
name|j
argument_list|)
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|index
argument_list|,
name|currentValue
argument_list|,
name|insert
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|insert
operator|>=
literal|0
condition|)
block|{
name|QString
name|tmp
init|=
name|str
decl_stmt|;
name|tmp
operator|.
name|insert
argument_list|(
name|insert
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
operator|+
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|potentialValue
argument_list|(
name|tmp
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|index
argument_list|,
name|currentValue
argument_list|,
name|insert
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|skipToNextSection
name|bool
name|QDateTimeParser
operator|::
name|skipToNextSection
parameter_list|(
name|int
name|index
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|current
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|current
operator|>=
name|getMinimum
argument_list|()
operator|&&
name|current
operator|<=
name|getMaximum
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|SectionNode
modifier|&
name|node
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|text
operator|.
name|size
argument_list|()
operator|<
name|sectionMaxSize
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|QDateTime
name|maximum
init|=
name|getMaximum
argument_list|()
decl_stmt|;
specifier|const
name|QDateTime
name|minimum
init|=
name|getMinimum
argument_list|()
decl_stmt|;
name|QDateTime
name|tmp
init|=
name|current
decl_stmt|;
name|int
name|min
init|=
name|absoluteMin
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|setDigit
argument_list|(
name|tmp
argument_list|,
name|index
argument_list|,
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|minimum
condition|)
block|{
name|min
operator|=
name|getDigit
argument_list|(
name|minimum
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|max
init|=
name|absoluteMax
argument_list|(
name|index
argument_list|,
name|current
argument_list|)
decl_stmt|;
name|setDigit
argument_list|(
name|tmp
argument_list|,
name|index
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|maximum
condition|)
block|{
name|max
operator|=
name|getDigit
argument_list|(
name|maximum
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|pos
init|=
name|cursorPosition
argument_list|()
operator|-
name|node
operator|.
name|pos
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>=
name|text
operator|.
name|size
argument_list|()
condition|)
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
specifier|const
name|bool
name|potential
init|=
name|potentialValue
argument_list|(
name|text
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|index
argument_list|,
name|current
argument_list|,
name|pos
argument_list|)
decl_stmt|;
return|return
operator|!
name|potential
return|;
comment|/* If the value potentially can become another valid entry we      * don't want to skip to the next. E.g. In a M field (month      * without leading 0 if you type 1 we don't want to autoskip but      * if you type 3 we do     */
block|}
end_function
begin_comment
comment|/*!   \internal   For debugging. Returns the name of the section \a s. */
end_comment
begin_function
DECL|function|sectionName
name|QString
name|QDateTimeParser
operator|::
name|sectionName
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|QDateTimeParser
operator|::
name|AmPmSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"AmPmSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|DaySection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"DaySection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|DayOfWeekSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"DayOfWeekSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|Hour24Section
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Hour24Section"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|Hour12Section
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Hour12Section"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|MSecSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"MSecSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|MinuteSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"MinuteSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|MonthSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"MonthSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|SecondSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"SecondSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|YearSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"YearSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|YearSection2Digits
case|:
return|return
name|QLatin1String
argument_list|(
literal|"YearSection2Digits"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|NoSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"NoSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|FirstSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"FirstSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|LastSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"LastSection"
argument_list|)
return|;
default|default:
return|return
name|QLatin1String
argument_list|(
literal|"Unknown section "
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   \internal   For debugging. Returns the name of the state \a s. */
end_comment
begin_function
DECL|function|stateName
name|QString
name|QDateTimeParser
operator|::
name|stateName
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|Invalid
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Invalid"
argument_list|)
return|;
case|case
name|Intermediate
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Intermediate"
argument_list|)
return|;
case|case
name|Acceptable
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Acceptable"
argument_list|)
return|;
default|default:
return|return
name|QLatin1String
argument_list|(
literal|"Unknown state "
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function
DECL|function|fromString
name|bool
name|QDateTimeParser
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|,
name|QDate
modifier|*
name|date
parameter_list|,
name|QTime
modifier|*
name|time
parameter_list|)
specifier|const
block|{
name|QDateTime
name|val
argument_list|(
name|QDate
argument_list|(
literal|1900
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|QDATETIMEEDIT_TIME_MIN
argument_list|)
decl_stmt|;
name|QString
name|text
init|=
name|t
decl_stmt|;
name|int
name|copy
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|StateNode
name|tmp
init|=
name|parse
argument_list|(
name|text
argument_list|,
name|copy
argument_list|,
name|val
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|state
operator|!=
name|Acceptable
operator|||
name|tmp
operator|.
name|conflicts
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|time
condition|)
block|{
specifier|const
name|QTime
name|t
init|=
name|tmp
operator|.
name|value
operator|.
name|time
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|time
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|date
condition|)
block|{
specifier|const
name|QDate
name|d
init|=
name|tmp
operator|.
name|value
operator|.
name|date
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|date
operator|=
name|d
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_function
DECL|function|getMinimum
name|QDateTime
name|QDateTimeParser
operator|::
name|getMinimum
parameter_list|()
specifier|const
block|{
return|return
name|QDateTime
argument_list|(
name|QDATETIMEEDIT_DATE_MIN
argument_list|,
name|QDATETIMEEDIT_TIME_MIN
argument_list|,
name|spec
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getMaximum
name|QDateTime
name|QDateTimeParser
operator|::
name|getMaximum
parameter_list|()
specifier|const
block|{
return|return
name|QDateTime
argument_list|(
name|QDATETIMEEDIT_DATE_MAX
argument_list|,
name|QDATETIMEEDIT_TIME_MAX
argument_list|,
name|spec
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getAmPmText
name|QString
name|QDateTimeParser
operator|::
name|getAmPmText
parameter_list|(
name|AmPm
name|ap
parameter_list|,
name|Case
name|cs
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|ap
operator|==
name|AmText
condition|)
block|{
return|return
operator|(
name|cs
operator|==
name|UpperCase
condition|?
name|QLatin1String
argument_list|(
literal|"AM"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"am"
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|cs
operator|==
name|UpperCase
condition|?
name|QLatin1String
argument_list|(
literal|"PM"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"pm"
argument_list|)
operator|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*   \internal    I give arg2 preference because arg1 is always a QDateTime. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QDateTimeParser
operator|::
name|SectionNode
modifier|&
name|s1
parameter_list|,
specifier|const
name|QDateTimeParser
operator|::
name|SectionNode
modifier|&
name|s2
parameter_list|)
block|{
return|return
operator|(
name|s1
operator|.
name|type
operator|==
name|s2
operator|.
name|type
operator|)
operator|&&
operator|(
name|s1
operator|.
name|pos
operator|==
name|s2
operator|.
name|pos
operator|)
operator|&&
operator|(
name|s1
operator|.
name|count
operator|==
name|s2
operator|.
name|count
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BOOTSTRAPPED
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
