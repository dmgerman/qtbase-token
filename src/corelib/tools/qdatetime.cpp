begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"private/qdatetime_p.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qset.h"
end_include
begin_include
include|#
directive|include
file|"qlocale.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qregexp.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_WIN
end_ifndef
begin_include
include|#
directive|include
file|<locale.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<cmath>
end_include
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_include
include|#
directive|include
file|<qt_windows.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WINCE
end_ifdef
begin_include
include|#
directive|include
file|"qfunctions_wince.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//#define QDATETIMEPARSER_DEBUG
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QDATETIMEPARSER_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
end_if
begin_define
DECL|macro|QDTPDEBUG
define|#
directive|define
name|QDTPDEBUG
value|qDebug()<< QString("%1:%2").arg(__FILE__).arg(__LINE__)
end_define
begin_define
DECL|macro|QDTPDEBUGN
define|#
directive|define
name|QDTPDEBUGN
value|qDebug
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QDTPDEBUG
define|#
directive|define
name|QDTPDEBUG
value|if (false) qDebug()
end_define
begin_define
DECL|macro|QDTPDEBUGN
define|#
directive|define
name|QDTPDEBUGN
value|if (false) qDebug
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_include
include|#
directive|include
file|<private/qcore_mac_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|enum
type|{
DECL|enumerator|SECS_PER_DAY
name|SECS_PER_DAY
init|=
literal|86400
decl_stmt|,
DECL|enumerator|MSECS_PER_DAY
name|MSECS_PER_DAY
init|=
literal|86400000
decl_stmt|,
DECL|enumerator|SECS_PER_HOUR
name|SECS_PER_HOUR
init|=
literal|3600
decl_stmt|,
DECL|enumerator|MSECS_PER_HOUR
name|MSECS_PER_HOUR
init|=
literal|3600000
decl_stmt|,
DECL|enumerator|SECS_PER_MIN
name|SECS_PER_MIN
init|=
literal|60
decl_stmt|,
DECL|enumerator|MSECS_PER_MIN
name|MSECS_PER_MIN
init|=
literal|60000
decl_stmt|,
DECL|enumerator|JULIAN_DAY_FOR_EPOCH
name|JULIAN_DAY_FOR_EPOCH
init|=
literal|2440588
end_decl_stmt
begin_comment
DECL|enumerator|JULIAN_DAY_FOR_EPOCH
comment|// result of julianDayFromDate(1970, 1, 1)
end_comment
begin_function
DECL|enumerator|JULIAN_DAY_FOR_EPOCH
unit|};
DECL|function|fixedDate
specifier|static
specifier|inline
name|QDate
name|fixedDate
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|QDate
name|result
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|result
operator|.
name|setDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|qMin
argument_list|(
name|d
argument_list|,
name|result
operator|.
name|daysInMonth
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|floordiv
specifier|static
specifier|inline
name|qint64
name|floordiv
parameter_list|(
name|qint64
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|-
operator|(
name|a
operator|<
literal|0
condition|?
name|b
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
operator|/
name|b
return|;
block|}
end_function
begin_function
DECL|function|floordiv
specifier|static
specifier|inline
name|int
name|floordiv
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|-
operator|(
name|a
operator|<
literal|0
condition|?
name|b
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
operator|/
name|b
return|;
block|}
end_function
begin_function
DECL|function|julianDayFromDate
specifier|static
specifier|inline
name|qint64
name|julianDayFromDate
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
comment|// Adjust for no year 0
if|if
condition|(
name|year
operator|<
literal|0
condition|)
operator|++
name|year
expr_stmt|;
comment|/*  * Math from The Calendar FAQ at http://www.tondering.dk/claus/cal/julperiod.php  * This formula is correct for all julian days, when using mathematical integer  * division (round to negative infinity), not c++11 integer division (round to zero)  */
name|int
name|a
init|=
name|floordiv
argument_list|(
literal|14
operator|-
name|month
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|qint64
name|y
init|=
operator|(
name|qint64
operator|)
name|year
operator|+
literal|4800
operator|-
name|a
decl_stmt|;
name|int
name|m
init|=
name|month
operator|+
literal|12
operator|*
name|a
operator|-
literal|3
decl_stmt|;
return|return
name|day
operator|+
name|floordiv
argument_list|(
literal|153
operator|*
name|m
operator|+
literal|2
argument_list|,
literal|5
argument_list|)
operator|+
literal|365
operator|*
name|y
operator|+
name|floordiv
argument_list|(
name|y
argument_list|,
literal|4
argument_list|)
operator|-
name|floordiv
argument_list|(
name|y
argument_list|,
literal|100
argument_list|)
operator|+
name|floordiv
argument_list|(
name|y
argument_list|,
literal|400
argument_list|)
operator|-
literal|32045
return|;
block|}
end_function
begin_function
DECL|function|getDateFromJulianDay
specifier|static
name|void
name|getDateFromJulianDay
parameter_list|(
name|qint64
name|julianDay
parameter_list|,
name|int
modifier|*
name|yearp
parameter_list|,
name|int
modifier|*
name|monthp
parameter_list|,
name|int
modifier|*
name|dayp
parameter_list|)
block|{
comment|/*  * Math from The Calendar FAQ at http://www.tondering.dk/claus/cal/julperiod.php  * This formula is correct for all julian days, when using mathematical integer  * division (round to negative infinity), not c++11 integer division (round to zero)  */
name|qint64
name|a
init|=
name|julianDay
operator|+
literal|32044
decl_stmt|;
name|qint64
name|b
init|=
name|floordiv
argument_list|(
literal|4
operator|*
name|a
operator|+
literal|3
argument_list|,
literal|146097
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|a
operator|-
name|floordiv
argument_list|(
literal|146097
operator|*
name|b
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|int
name|d
init|=
name|floordiv
argument_list|(
literal|4
operator|*
name|c
operator|+
literal|3
argument_list|,
literal|1461
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|c
operator|-
name|floordiv
argument_list|(
literal|1461
operator|*
name|d
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|int
name|m
init|=
name|floordiv
argument_list|(
literal|5
operator|*
name|e
operator|+
literal|2
argument_list|,
literal|153
argument_list|)
decl_stmt|;
name|int
name|day
init|=
name|e
operator|-
name|floordiv
argument_list|(
literal|153
operator|*
name|m
operator|+
literal|2
argument_list|,
literal|5
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|month
init|=
name|m
operator|+
literal|3
operator|-
literal|12
operator|*
name|floordiv
argument_list|(
name|m
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|int
name|year
init|=
literal|100
operator|*
name|b
operator|+
name|d
operator|-
literal|4800
operator|+
name|floordiv
argument_list|(
name|m
argument_list|,
literal|10
argument_list|)
decl_stmt|;
comment|// Adjust for no year 0
if|if
condition|(
name|year
operator|<=
literal|0
condition|)
operator|--
name|year
expr_stmt|;
if|if
condition|(
name|yearp
condition|)
operator|*
name|yearp
operator|=
name|year
expr_stmt|;
if|if
condition|(
name|monthp
condition|)
operator|*
name|monthp
operator|=
name|month
expr_stmt|;
if|if
condition|(
name|dayp
condition|)
operator|*
name|dayp
operator|=
name|day
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|monthDays
specifier|static
specifier|const
name|char
name|monthDays
index|[]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_decl_stmt
DECL|variable|qt_shortMonthNames
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|qt_shortMonthNames
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_monthNumberFromShortName
name|int
name|qt_monthNumberFromShortName
parameter_list|(
specifier|const
name|QString
modifier|&
name|shortName
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|qt_shortMonthNames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|qt_shortMonthNames
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|shortName
operator|==
name|QLatin1String
argument_list|(
name|qt_shortMonthNames
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
operator|+
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function_decl
specifier|static
name|QString
name|fmtDateTime
parameter_list|(
specifier|const
name|QString
modifier|&
name|f
parameter_list|,
specifier|const
name|QTime
modifier|*
name|dt
init|=
literal|0
parameter_list|,
specifier|const
name|QDate
modifier|*
name|dd
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|rfcDateImpl
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|QDate
modifier|*
name|dd
init|=
literal|0
parameter_list|,
name|QTime
modifier|*
name|dt
init|=
literal|0
parameter_list|,
name|int
modifier|*
name|utfcOffset
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|static
name|QDateTimePrivate
operator|::
name|Spec
name|utcToLocal
parameter_list|(
name|QDate
modifier|&
name|date
parameter_list|,
name|QTime
modifier|&
name|time
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|utcToOffset
parameter_list|(
name|QDate
modifier|*
name|date
parameter_list|,
name|QTime
modifier|*
name|time
parameter_list|,
name|qint32
name|offset
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QDate
name|adjustDate
parameter_list|(
name|QDate
name|date
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// Return offset in [+-]HH:MM format
end_comment
begin_comment
comment|// Qt::ISODate puts : between the hours and minutes, but Qt:TextDate does not
end_comment
begin_function
DECL|function|toOffsetString
specifier|static
name|QString
name|toOffsetString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|Qt
operator|::
name|TextDate
condition|)
name|result
operator|=
name|QStringLiteral
argument_list|(
literal|"%1%2%3"
argument_list|)
expr_stmt|;
else|else
comment|// Qt::ISODate
name|result
operator|=
name|QStringLiteral
argument_list|(
literal|"%1%2:%3"
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|arg
argument_list|(
name|offset
operator|>=
literal|0
condition|?
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
else|:
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|qAbs
argument_list|(
name|offset
argument_list|)
operator|/
name|SECS_PER_HOUR
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
operator|(
name|offset
operator|/
literal|60
operator|)
operator|%
literal|60
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// Parse offset in [+-]HH[:]MM format
end_comment
begin_function
DECL|function|fromOffsetString
specifier|static
name|int
name|fromOffsetString
parameter_list|(
specifier|const
name|QString
modifier|&
name|offsetString
parameter_list|,
name|bool
modifier|*
name|valid
parameter_list|)
block|{
operator|*
name|valid
operator|=
literal|false
expr_stmt|;
specifier|const
name|int
name|size
init|=
name|offsetString
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|<
literal|2
operator|||
name|size
argument_list|>
literal|6
condition|)
return|return
literal|0
return|;
comment|// First char must be + or -
specifier|const
name|QChar
name|sign
init|=
name|offsetString
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sign
operator|!=
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
operator|&&
name|sign
operator|!=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
condition|)
return|return
literal|0
return|;
comment|// Split the hour and minute parts
name|QStringList
name|parts
init|=
name|offsetString
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// [+-]HHMM format
name|parts
operator|.
name|append
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|mid
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|left
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|bool
name|ok
init|=
literal|false
decl_stmt|;
specifier|const
name|int
name|hour
init|=
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
specifier|const
name|int
name|minute
init|=
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
operator|||
name|minute
argument_list|<
literal|0
operator|||
name|minute
argument_list|>
literal|59
condition|)
return|return
literal|0
return|;
operator|*
name|valid
operator|=
literal|true
expr_stmt|;
return|return
operator|(
operator|(
name|hour
operator|*
literal|60
operator|)
operator|+
name|minute
operator|)
operator|*
literal|60
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_comment
comment|// Calls the platform variant of mktime for the given date and time,
end_comment
begin_comment
comment|// and updates the date, time, spec and abbreviation with the returned values
end_comment
begin_comment
comment|// If the date falls outside the 1970 to 2037 range supported by mktime / time_t
end_comment
begin_comment
comment|// then null date/time will be returned, you should call adjustDate() first if
end_comment
begin_comment
comment|// you need a guaranteed result.
end_comment
begin_function
DECL|function|qt_mktime
specifier|static
name|time_t
name|qt_mktime
parameter_list|(
name|QDate
modifier|*
name|date
parameter_list|,
name|QTime
modifier|*
name|time
parameter_list|,
name|QDateTimePrivate
operator|::
name|Spec
modifier|*
name|spec
parameter_list|,
name|QString
modifier|*
name|abbreviation
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
name|int
name|yy
decl_stmt|,
name|mm
decl_stmt|,
name|dd
decl_stmt|;
name|date
operator|->
name|getDate
argument_list|(
operator|&
name|yy
argument_list|,
operator|&
name|mm
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
name|tm
name|local
decl_stmt|;
name|local
operator|.
name|tm_sec
operator|=
name|time
operator|->
name|second
argument_list|()
expr_stmt|;
name|local
operator|.
name|tm_min
operator|=
name|time
operator|->
name|minute
argument_list|()
expr_stmt|;
name|local
operator|.
name|tm_hour
operator|=
name|time
operator|->
name|hour
argument_list|()
expr_stmt|;
name|local
operator|.
name|tm_mday
operator|=
name|dd
expr_stmt|;
name|local
operator|.
name|tm_mon
operator|=
name|mm
operator|-
literal|1
expr_stmt|;
name|local
operator|.
name|tm_year
operator|=
name|yy
operator|-
literal|1900
expr_stmt|;
name|local
operator|.
name|tm_wday
operator|=
literal|0
expr_stmt|;
name|local
operator|.
name|tm_yday
operator|=
literal|0
expr_stmt|;
name|local
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|_tzset
argument_list|()
expr_stmt|;
else|#
directive|else
name|tzset
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Q_OS_WIN
specifier|const
name|time_t
name|secsSinceEpoch
init|=
name|mktime
argument_list|(
operator|&
name|local
argument_list|)
decl_stmt|;
if|if
condition|(
name|secsSinceEpoch
operator|!=
operator|(
name|uint
operator|)
operator|-
literal|1
condition|)
block|{
operator|*
name|date
operator|=
name|QDate
argument_list|(
name|local
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|local
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|local
operator|.
name|tm_mday
argument_list|)
expr_stmt|;
operator|*
name|time
operator|=
name|QTime
argument_list|(
name|local
operator|.
name|tm_hour
argument_list|,
name|local
operator|.
name|tm_min
argument_list|,
name|local
operator|.
name|tm_sec
argument_list|,
name|time
operator|->
name|msec
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
operator|.
name|tm_isdst
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|spec
condition|)
operator|*
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalDST
expr_stmt|;
if|if
condition|(
name|abbreviation
condition|)
operator|*
name|abbreviation
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|tzname
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local
operator|.
name|tm_isdst
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|spec
condition|)
operator|*
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalStandard
expr_stmt|;
if|if
condition|(
name|abbreviation
condition|)
operator|*
name|abbreviation
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|tzname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|spec
condition|)
operator|*
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
if|if
condition|(
name|abbreviation
condition|)
operator|*
name|abbreviation
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|tzname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
operator|*
name|date
operator|=
name|QDate
argument_list|()
expr_stmt|;
operator|*
name|time
operator|=
name|QTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|spec
condition|)
operator|*
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
if|if
condition|(
name|abbreviation
condition|)
operator|*
name|abbreviation
operator|=
name|QString
argument_list|()
expr_stmt|;
block|}
return|return
name|secsSinceEpoch
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !Q_OS_WINCE
end_comment
begin_comment
comment|/*****************************************************************************   QDate member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \since 4.5      \enum QDate::MonthNameType      This enum describes the types of the string representation used     for the month name.      \value DateFormat This type of name can be used for date-to-string formatting.     \value StandaloneFormat This type is used when you need to enumerate months or weekdays.            Usually standalone names are represented in singular forms with            capitalized first letter. */
end_comment
begin_comment
comment|/*!     \class QDate     \inmodule QtCore     \reentrant     \brief The QDate class provides date functions.       A QDate object contains a calendar date, i.e. year, month, and day     numbers, in the Gregorian calendar. It can read the current date     from the system clock. It provides functions for comparing dates,     and for manipulating dates. For example, it is possible to add     and subtract days, months, and years to dates.      A QDate object is typically created by giving the year,     month, and day numbers explicitly. Note that QDate interprets two     digit years as is, i.e., years 0 - 99. A QDate can also be     constructed with the static function currentDate(), which creates     a QDate object containing the system clock's date.  An explicit     date can also be set using setDate(). The fromString() function     returns a QDate given a string and a date format which is used to     interpret the date within the string.      The year(), month(), and day() functions provide access to the     year, month, and day numbers. Also, dayOfWeek() and dayOfYear()     functions are provided. The same information is provided in     textual format by the toString(), shortDayName(), longDayName(),     shortMonthName(), and longMonthName() functions.      QDate provides a full set of operators to compare two QDate     objects where smaller means earlier, and larger means later.      You can increment (or decrement) a date by a given number of days     using addDays(). Similarly you can use addMonths() and addYears().     The daysTo() function returns the number of days between two     dates.      The daysInMonth() and daysInYear() functions return how many days     there are in this date's month and year, respectively. The     isLeapYear() function indicates whether a date is in a leap year.      \section1      \section2 No Year 0      There is no year 0. Dates in that year are considered invalid. The     year -1 is the year "1 before Christ" or "1 before current era."     The day before 1 January 1 CE is 31 December 1 BCE.      \section2 Range of Valid Dates      Dates are stored internally as a Julian Day number, an integer count of     every day in a contiguous range, with 24 November 4714 BCE in the Gregorian     calendar being Julian Day 0 (1 January 4713 BCE in the Julian calendar).     As well as being an efficient and accurate way of storing an absolute date,     it is suitable for converting a Date into other calendar systems such as     Hebrew, Islamic or Chinese. The Julian Day number can be obtained using     QDate::toJulianDay() and can be set using QDate::fromJulianDay().      The range of dates able to be stored by QDate as a Julian Day number is     for technical reasons limited to between -784350574879 and 784354017364,     which means from before 2 billion BCE to after 2 billion CE.      \sa QTime, QDateTime, QDateEdit, QDateTimeEdit, QCalendarWidget */
end_comment
begin_comment
comment|/*!     \fn QDate::QDate()      Constructs a null date. Null dates are invalid.      \sa isNull(), isValid() */
end_comment
begin_comment
comment|/*!     Constructs a date with year \a y, month \a m and day \a d.      If the specified date is invalid, the date is not set and     isValid() returns false.      \warning Years 1 to 99 are interpreted as is. Year 0 is invalid.      \sa isValid() */
end_comment
begin_constructor
DECL|function|QDate
name|QDate
operator|::
name|QDate
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|setDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn bool QDate::isNull() const      Returns true if the date is null; otherwise returns false. A null     date is invalid.      \note The behavior of this function is equivalent to isValid().      \sa isValid() */
end_comment
begin_comment
comment|/*!     \fn bool QDate::isValid() const      Returns true if this date is valid; otherwise returns false.      \sa isNull() */
end_comment
begin_comment
comment|/*!     Returns the year of this date. Negative numbers indicate years     before 1 CE, such that year -44 is 44 BCE.      Returns 0 if the date is invalid.      \sa month(), day() */
end_comment
begin_function
DECL|function|year
name|int
name|QDate
operator|::
name|year
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|y
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number corresponding to the month of this date, using     the following convention:      \list     \li 1 = "January"     \li 2 = "February"     \li 3 = "March"     \li 4 = "April"     \li 5 = "May"     \li 6 = "June"     \li 7 = "July"     \li 8 = "August"     \li 9 = "September"     \li 10 = "October"     \li 11 = "November"     \li 12 = "December"     \endlist      Returns 0 if the date is invalid.      \sa year(), day() */
end_comment
begin_function
DECL|function|month
name|int
name|QDate
operator|::
name|month
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|m
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
literal|0
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the day of the month (1 to 31) of this date.      Returns 0 if the date is invalid.      \sa year(), month(), dayOfWeek() */
end_comment
begin_function
DECL|function|day
name|int
name|QDate
operator|::
name|day
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the weekday (1 = Monday to 7 = Sunday) for this date.      Returns 0 if the date is invalid.      \sa day(), dayOfYear(), Qt::DayOfWeek */
end_comment
begin_function
DECL|function|dayOfWeek
name|int
name|QDate
operator|::
name|dayOfWeek
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|jd
operator|>=
literal|0
condition|)
return|return
operator|(
name|jd
operator|%
literal|7
operator|)
operator|+
literal|1
return|;
else|else
return|return
operator|(
operator|(
name|jd
operator|+
literal|1
operator|)
operator|%
literal|7
operator|)
operator|+
literal|7
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the day of the year (1 to 365 or 366 on leap years) for     this date.      Returns 0 if the date is invalid.      \sa day(), dayOfWeek() */
end_comment
begin_function
DECL|function|dayOfYear
name|int
name|QDate
operator|::
name|dayOfYear
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|jd
operator|-
name|julianDayFromDate
argument_list|(
name|year
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days in the month (28 to 31) for this date.      Returns 0 if the date is invalid.      \sa day(), daysInYear() */
end_comment
begin_function
DECL|function|daysInMonth
name|int
name|QDate
operator|::
name|daysInMonth
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|y
decl_stmt|,
name|m
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|2
operator|&&
name|isLeapYear
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|29
return|;
else|else
return|return
name|monthDays
index|[
name|m
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days in the year (365 or 366) for this date.      Returns 0 if the date is invalid.      \sa day(), daysInMonth() */
end_comment
begin_function
DECL|function|daysInYear
name|int
name|QDate
operator|::
name|daysInYear
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|y
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|isLeapYear
argument_list|(
name|y
argument_list|)
condition|?
literal|366
else|:
literal|365
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the week number (1 to 53), and stores the year in     *\a{yearNumber} unless \a yearNumber is null (the default).      Returns 0 if the date is invalid.      In accordance with ISO 8601, weeks start on Monday and the first     Thursday of a year is always in week 1 of that year. Most years     have 52 weeks, but some have 53.      *\a{yearNumber} is not always the same as year(). For example, 1     January 2000 has week number 52 in the year 1999, and 31 December     2002 has week number 1 in the year 2003.      \legalese     Copyright (c) 1989 The Regents of the University of California.     All rights reserved.      Redistribution and use in source and binary forms are permitted     provided that the above copyright notice and this paragraph are     duplicated in all such forms and that any documentation,     advertising materials, and other materials related to such     distribution and use acknowledge that the software was developed     by the University of California, Berkeley.  The name of the     University may not be used to endorse or promote products derived     from this software without specific prior written permission.     THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR     IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.      \sa isValid() */
end_comment
begin_function
DECL|function|weekNumber
name|int
name|QDate
operator|::
name|weekNumber
parameter_list|(
name|int
modifier|*
name|yearNumber
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|year
init|=
name|QDate
operator|::
name|year
argument_list|()
decl_stmt|;
name|int
name|yday
init|=
name|dayOfYear
argument_list|()
operator|-
literal|1
decl_stmt|;
name|int
name|wday
init|=
name|dayOfWeek
argument_list|()
decl_stmt|;
if|if
condition|(
name|wday
operator|==
literal|7
condition|)
name|wday
operator|=
literal|0
expr_stmt|;
name|int
name|w
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|bot
decl_stmt|;
name|int
name|top
decl_stmt|;
name|len
operator|=
name|isLeapYear
argument_list|(
name|year
argument_list|)
condition|?
literal|366
else|:
literal|365
expr_stmt|;
comment|/*         ** What yday (-3 ... 3) does         ** the ISO year begin on?         */
name|bot
operator|=
operator|(
operator|(
name|yday
operator|+
literal|11
operator|-
name|wday
operator|)
operator|%
literal|7
operator|)
operator|-
literal|3
expr_stmt|;
comment|/*         ** What yday does the NEXT         ** ISO year begin on?         */
name|top
operator|=
name|bot
operator|-
operator|(
name|len
operator|%
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|top
operator|<
operator|-
literal|3
condition|)
name|top
operator|+=
literal|7
expr_stmt|;
name|top
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|yday
operator|>=
name|top
condition|)
block|{
operator|++
name|year
expr_stmt|;
name|w
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|yday
operator|>=
name|bot
condition|)
block|{
name|w
operator|=
literal|1
operator|+
operator|(
operator|(
name|yday
operator|-
name|bot
operator|)
operator|/
literal|7
operator|)
expr_stmt|;
break|break;
block|}
operator|--
name|year
expr_stmt|;
name|yday
operator|+=
name|isLeapYear
argument_list|(
name|year
argument_list|)
condition|?
literal|366
else|:
literal|365
expr_stmt|;
block|}
if|if
condition|(
name|yearNumber
operator|!=
literal|0
condition|)
operator|*
name|yearNumber
operator|=
name|year
expr_stmt|;
return|return
name|w
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_comment
comment|/*!     \since 4.5      Returns the short name of the \a month for the representation specified     by \a type.      The months are enumerated using the following convention:      \list     \li 1 = "Jan"     \li 2 = "Feb"     \li 3 = "Mar"     \li 4 = "Apr"     \li 5 = "May"     \li 6 = "Jun"     \li 7 = "Jul"     \li 8 = "Aug"     \li 9 = "Sep"     \li 10 = "Oct"     \li 11 = "Nov"     \li 12 = "Dec"     \endlist      The month names will be localized according to the system's default     locale settings.      Returns an empty string if the date is invalid.      \sa toString(), longMonthName(), shortDayName(), longDayName() */
end_comment
begin_function
DECL|function|shortMonthName
name|QString
name|QDate
operator|::
name|shortMonthName
parameter_list|(
name|int
name|month
parameter_list|,
name|QDate
operator|::
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|month
argument_list|<
literal|1
operator|||
name|month
argument_list|>
literal|12
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneMonthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the long name of the \a month for the representation specified     by \a type.      The months are enumerated using the following convention:      \list     \li 1 = "January"     \li 2 = "February"     \li 3 = "March"     \li 4 = "April"     \li 5 = "May"     \li 6 = "June"     \li 7 = "July"     \li 8 = "August"     \li 9 = "September"     \li 10 = "October"     \li 11 = "November"     \li 12 = "December"     \endlist      The month names will be localized according to the system's default     locale settings.      Returns an empty string if the date is invalid.      \sa toString(), shortMonthName(), shortDayName(), longDayName() */
end_comment
begin_function
DECL|function|longMonthName
name|QString
name|QDate
operator|::
name|longMonthName
parameter_list|(
name|int
name|month
parameter_list|,
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|month
argument_list|<
literal|1
operator|||
name|month
argument_list|>
literal|12
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneMonthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the short name of the \a weekday for the representation specified     by \a type.      The days are enumerated using the following convention:      \list     \li 1 = "Mon"     \li 2 = "Tue"     \li 3 = "Wed"     \li 4 = "Thu"     \li 5 = "Fri"     \li 6 = "Sat"     \li 7 = "Sun"     \endlist      The day names will be localized according to the system's default     locale settings.      Returns an empty string if the date is invalid.      \sa toString(), shortMonthName(), longMonthName(), longDayName() */
end_comment
begin_function
DECL|function|shortDayName
name|QString
name|QDate
operator|::
name|shortDayName
parameter_list|(
name|int
name|weekday
parameter_list|,
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|weekday
argument_list|<
literal|1
operator|||
name|weekday
argument_list|>
literal|7
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneDayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the long name of the \a weekday for the representation specified     by \a type.      The days are enumerated using the following convention:      \list     \li 1 = "Monday"     \li 2 = "Tuesday"     \li 3 = "Wednesday"     \li 4 = "Thursday"     \li 5 = "Friday"     \li 6 = "Saturday"     \li 7 = "Sunday"     \endlist      The day names will be localized according to the system's default     locale settings.      Returns an empty string if the date is invalid.      \sa toString(), shortDayName(), shortMonthName(), longMonthName() */
end_comment
begin_function
DECL|function|longDayName
name|QString
name|QDate
operator|::
name|longDayName
parameter_list|(
name|int
name|weekday
parameter_list|,
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|weekday
argument_list|<
literal|1
operator|||
name|weekday
argument_list|>
literal|7
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneDayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_TEXTDATE
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \fn QString QDate::toString(Qt::DateFormat format) const      \overload      Returns the date as a string. The \a format parameter determines     the format of the string.      If the \a format is Qt::TextDate, the string is formatted in     the default way. QDate::shortDayName() and QDate::shortMonthName()     are used to generate the string, so the day and month names will     be localized names using the default locale from the system. An     example of this formatting is "Sat May 20 1995".      If the \a format is Qt::ISODate, the string format corresponds     to the ISO 8601 extended specification for representations of     dates and times, taking the form YYYY-MM-DD, where YYYY is the     year, MM is the month of the year (between 01 and 12), and DD is     the day of the month between 01 and 31.      If the \a format is Qt::SystemLocaleShortDate or     Qt::SystemLocaleLongDate, the string format depends on the locale     settings of the system. Identical to calling     QLocale::system().toString(date, QLocale::ShortFormat) or     QLocale::system().toString(date, QLocale::LongFormat).      If the \a format is Qt::DefaultLocaleShortDate or     Qt::DefaultLocaleLongDate, the string format depends on the     default application locale. This is the locale set with     QLocale::setDefault(), or the system locale if no default locale     has been set. Identical to calling QLocale().toString(date,     QLocale::ShortFormat) or QLocale().toString(date,     QLocale::LongFormat).      If the \a format is Qt::RFC2822Date, the string is formatted in     an \l{RFC 2822} compatible way. An example of this formatting is     "20 May 1995".      If the date is invalid, an empty string will be returned.      \warning The Qt::ISODate format is only valid for years in the     range 0 to 9999. This restriction may apply to locale-aware     formats as well, depending on the locale settings.      \sa shortDayName(), shortMonthName() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDate
operator|::
name|toString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|f
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|int
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|f
operator|==
name|Qt
operator|::
name|SystemLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|f
operator|==
name|Qt
operator|::
name|DefaultLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
default|default:
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
case|case
name|Qt
operator|::
name|TextDate
case|:
block|{
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%0 %1 %2 %3"
argument_list|)
operator|.
name|arg
argument_list|(
name|shortDayName
argument_list|(
name|dayOfWeek
argument_list|()
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|shortMonthName
argument_list|(
name|m
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|d
argument_list|)
operator|.
name|arg
argument_list|(
name|y
argument_list|)
return|;
block|}
endif|#
directive|endif
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
return|return
name|toString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"dd MMM yyyy"
argument_list|)
argument_list|)
return|;
case|case
name|Qt
operator|::
name|ISODate
case|:
block|{
if|if
condition|(
name|year
argument_list|()
operator|<
literal|0
operator|||
name|year
argument_list|()
operator|>
literal|9999
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|year
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|y
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|4
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|month
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|m
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|day
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|d
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|year
operator|+
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|month
operator|+
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|day
return|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the date as a string. The \a format parameter determines     the format of the result string.      These expressions may be used:      \table     \header \li Expression \li Output     \row \li d \li the day as number without a leading zero (1 to 31)     \row \li dd \li the day as number with a leading zero (01 to 31)     \row \li ddd          \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').             Uses QDate::shortDayName().     \row \li dddd          \li the long localized day name (e.g. 'Monday' to 'Sunday').             Uses QDate::longDayName().     \row \li M \li the month as number without a leading zero (1 to 12)     \row \li MM \li the month as number with a leading zero (01 to 12)     \row \li MMM          \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').             Uses QDate::shortMonthName().     \row \li MMMM          \li the long localized month name (e.g. 'January' to 'December').             Uses QDate::longMonthName().     \row \li yy \li the year as two digit number (00 to 99)     \row \li yyyy \li the year as four digit number. If the year is negative,             a minus sign is prepended in addition.     \endtable      All other input characters will be ignored. Any sequence of characters that     are enclosed in single quotes will be treated as text and not be used as an     expression. Two consecutive single quotes ("''") are replaced by a singlequote     in the output. Formats without separators (e.g. "ddMM") are currently not supported.      Example format strings (assuming that the QDate is the 20 July     1969):      \table     \header \li Format            \li Result     \row    \li dd.MM.yyyy        \li 20.07.1969     \row    \li ddd MMMM d yy     \li Sun July 20 69     \row    \li 'The day is' dddd \li The day is Sunday     \endtable      If the datetime is invalid, an empty string will be returned.      \warning The Qt::ISODate format is only valid for years in the     range 0 to 9999. This restriction may apply to locale-aware     formats as well, depending on the locale settings.      \sa QDateTime::toString(), QTime::toString()  */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDate
operator|::
name|toString
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|year
argument_list|()
operator|>
literal|9999
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|fmtDateTime
argument_list|(
name|format
argument_list|,
literal|0
argument_list|,
name|this
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \fn bool QDate::setYMD(int y, int m, int d)      \deprecated in 5.0, use setDate() instead.      Sets the date's year \a y, month \a m, and day \a d.      If \a y is in the range 0 to 99, it is interpreted as 1900 to     1999.     Returns \c false if the date is invalid.      Use setDate() instead. */
end_comment
begin_comment
comment|/*!     \since 4.2      Sets the date's \a year, \a month, and \a day. Returns true if     the date is valid; otherwise returns false.      If the specified date is invalid, the QDate object is set to be     invalid.      \sa isValid() */
end_comment
begin_function
DECL|function|setDate
name|bool
name|QDate
operator|::
name|setDate
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
condition|)
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
else|else
name|jd
operator|=
name|nullJd
argument_list|()
expr_stmt|;
return|return
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Extracts the date's year, month, and day, and assigns them to     *\a year, *\a month, and *\a day. The pointers may be null.      Returns 0 if the date is invalid.      \sa year(), month(), day(), isValid() */
end_comment
begin_function
DECL|function|getDate
name|void
name|QDate
operator|::
name|getDate
parameter_list|(
name|int
modifier|*
name|year
parameter_list|,
name|int
modifier|*
name|month
parameter_list|,
name|int
modifier|*
name|day
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|()
condition|)
block|{
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|year
condition|)
operator|*
name|year
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|month
condition|)
operator|*
name|month
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|day
condition|)
operator|*
name|day
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns a QDate object containing a date \a ndays later than the     date of this object (or earlier if \a ndays is negative).      Returns a null date if the current date is invalid or the new date is     out of range.      \sa addMonths(), addYears(), daysTo() */
end_comment
begin_function
DECL|function|addDays
name|QDate
name|QDate
operator|::
name|addDays
parameter_list|(
name|qint64
name|ndays
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
comment|// Due to limits on minJd() and maxJd() we know that any overflow
comment|// will be invalid and caught by fromJulianDay().
return|return
name|fromJulianDay
argument_list|(
name|jd
operator|+
name|ndays
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDate object containing a date \a nmonths later than the     date of this object (or earlier if \a nmonths is negative).      \note If the ending day/month combination does not exist in the     resulting month/year, this function will return a date that is the     latest valid date.      \sa addDays(), addYears() */
end_comment
begin_function
DECL|function|addMonths
name|QDate
name|QDate
operator|::
name|addMonths
parameter_list|(
name|int
name|nmonths
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
if|if
condition|(
operator|!
name|nmonths
condition|)
return|return
operator|*
name|this
return|;
name|int
name|old_y
decl_stmt|,
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|old_y
operator|=
name|y
expr_stmt|;
name|bool
name|increasing
init|=
name|nmonths
operator|>
literal|0
decl_stmt|;
while|while
condition|(
name|nmonths
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nmonths
operator|<
literal|0
operator|&&
name|nmonths
operator|+
literal|12
operator|<=
literal|0
condition|)
block|{
name|y
operator|--
expr_stmt|;
name|nmonths
operator|+=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmonths
operator|<
literal|0
condition|)
block|{
name|m
operator|+=
name|nmonths
expr_stmt|;
name|nmonths
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0
condition|)
block|{
operator|--
name|y
expr_stmt|;
name|m
operator|+=
literal|12
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nmonths
operator|-
literal|12
operator|>=
literal|0
condition|)
block|{
name|y
operator|++
expr_stmt|;
name|nmonths
operator|-=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
literal|12
condition|)
block|{
name|y
operator|++
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|m
operator|+=
name|nmonths
expr_stmt|;
name|nmonths
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|12
condition|)
block|{
operator|++
name|y
expr_stmt|;
name|m
operator|-=
literal|12
expr_stmt|;
block|}
block|}
block|}
comment|// was there a sign change?
if|if
condition|(
operator|(
name|old_y
operator|>
literal|0
operator|&&
name|y
operator|<=
literal|0
operator|)
operator|||
operator|(
name|old_y
operator|<
literal|0
operator|&&
name|y
operator|>=
literal|0
operator|)
condition|)
comment|// yes, adjust the date by +1 or -1 years
name|y
operator|+=
name|increasing
condition|?
operator|+
literal|1
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|fixedDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDate object containing a date \a nyears later than the     date of this object (or earlier if \a nyears is negative).      \note If the ending day/month combination does not exist in the     resulting year (i.e., if the date was Feb 29 and the final year is     not a leap year), this function will return a date that is the     latest valid date (that is, Feb 28).      \sa addDays(), addMonths() */
end_comment
begin_function
DECL|function|addYears
name|QDate
name|QDate
operator|::
name|addYears
parameter_list|(
name|int
name|nyears
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
name|int
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|int
name|old_y
init|=
name|y
decl_stmt|;
name|y
operator|+=
name|nyears
expr_stmt|;
comment|// was there a sign change?
if|if
condition|(
operator|(
name|old_y
operator|>
literal|0
operator|&&
name|y
operator|<=
literal|0
operator|)
operator|||
operator|(
name|old_y
operator|<
literal|0
operator|&&
name|y
operator|>=
literal|0
operator|)
condition|)
comment|// yes, adjust the date by +1 or -1 years
name|y
operator|+=
name|nyears
operator|>
literal|0
condition|?
operator|+
literal|1
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|fixedDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days from this date to \a d (which is     negative if \a d is earlier than this date).      Returns 0 if either date is invalid.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 0      \sa addDays() */
end_comment
begin_function
DECL|function|daysTo
name|qint64
name|QDate
operator|::
name|daysTo
parameter_list|(
specifier|const
name|QDate
modifier|&
name|d
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
operator|||
name|d
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// Due to limits on minJd() and maxJd() we know this will never overflow
return|return
name|d
operator|.
name|jd
operator|-
name|jd
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDate::operator==(const QDate&d) const      Returns true if this date is equal to \a d; otherwise returns     false.  */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator!=(const QDate&d) const      Returns true if this date is different from \a d; otherwise     returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator<(const QDate&d) const      Returns true if this date is earlier than \a d; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator<=(const QDate&d) const      Returns true if this date is earlier than or equal to \a d;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator>(const QDate&d) const      Returns true if this date is later than \a d; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator>=(const QDate&d) const      Returns true if this date is later than or equal to \a d;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QDate::currentDate()     Returns the current date, as reported by the system clock.      \sa QTime::currentTime(), QDateTime::currentDateTime() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \fn QDate QDate::fromString(const QString&string, Qt::DateFormat format)      Returns the QDate represented by the \a string, using the     \a format given, or an invalid date if the string cannot be     parsed.      Note for Qt::TextDate: It is recommended that you use the     English short month names (e.g. "Jan"). Although localized month     names can also be used, they depend on the user's locale settings. */
end_comment
begin_function
DECL|function|fromString
name|QDate
name|QDate
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|f
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|Qt
operator|::
name|ISODate
case|:
block|{
name|int
name|year
argument_list|(
name|s
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|month
argument_list|(
name|s
operator|.
name|mid
argument_list|(
literal|5
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|day
argument_list|(
name|s
operator|.
name|mid
argument_list|(
literal|8
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|year
operator|&&
name|month
operator|&&
name|day
condition|)
return|return
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
return|;
block|}
break|break;
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|fromString
argument_list|(
name|s
argument_list|,
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dateFormat
argument_list|(
name|f
operator|==
name|Qt
operator|::
name|SystemLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|fromString
argument_list|(
name|s
argument_list|,
name|QLocale
argument_list|()
operator|.
name|dateFormat
argument_list|(
name|f
operator|==
name|Qt
operator|::
name|DefaultLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
block|{
name|QDate
name|date
decl_stmt|;
name|rfcDateImpl
argument_list|(
name|s
argument_list|,
operator|&
name|date
argument_list|)
expr_stmt|;
return|return
name|date
return|;
block|}
default|default:
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
case|case
name|Qt
operator|::
name|TextDate
case|:
block|{
name|QStringList
name|parts
init|=
name|s
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|!=
literal|4
condition|)
block|{
return|return
name|QDate
argument_list|()
return|;
block|}
name|QString
name|monthName
init|=
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|month
init|=
operator|-
literal|1
decl_stmt|;
comment|// Assume that English monthnames are the default
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QLatin1String
argument_list|(
name|qt_shortMonthNames
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|month
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|// If English names can't be found, search the localized ones
if|if
condition|(
name|month
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QDate
operator|::
name|shortMonthName
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|month
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|month
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Month name matches neither English nor other localised name.
return|return
name|QDate
argument_list|()
return|;
block|}
block|}
name|bool
name|ok
decl_stmt|;
name|int
name|day
init|=
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDate
argument_list|()
return|;
block|}
name|int
name|year
init|=
name|parts
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDate
argument_list|()
return|;
block|}
return|return
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
return|;
block|}
else|#
directive|else
break|break;
endif|#
directive|endif
block|}
return|return
name|QDate
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDate::fromString(const QString&string, const QString&format)      Returns the QDate represented by the \a string, using the \a     format given, or an invalid date if the string cannot be parsed.      These expressions may be used for the format:      \table     \header \li Expression \li Output     \row \li d \li The day as a number without a leading zero (1 to 31)     \row \li dd \li The day as a number with a leading zero (01 to 31)     \row \li ddd          \li The abbreviated localized day name (e.g. 'Mon' to 'Sun').             Uses QDate::shortDayName().     \row \li dddd          \li The long localized day name (e.g. 'Monday' to 'Sunday').             Uses QDate::longDayName().     \row \li M \li The month as a number without a leading zero (1 to 12)     \row \li MM \li The month as a number with a leading zero (01 to 12)     \row \li MMM          \li The abbreviated localized month name (e.g. 'Jan' to 'Dec').             Uses QDate::shortMonthName().     \row \li MMMM          \li The long localized month name (e.g. 'January' to 'December').             Uses QDate::longMonthName().     \row \li yy \li The year as two digit number (00 to 99)     \row \li yyyy \li The year as four digit number. If the year is negative,             a minus sign is prepended in addition.     \endtable      All other input characters will be treated as text. Any sequence     of characters that are enclosed in single quotes will also be     treated as text and will not be used as an expression. For example:      \snippet code/src_corelib_tools_qdatetime.cpp 1      If the format is not satisfied, an invalid QDate is returned. The     expressions that don't expect leading zeroes (d, M) will be     greedy. This means that they will use two digits even if this     will put them outside the accepted range of values and leaves too     few digits for other sections. For example, the following format     string could have meant January 30 but the M will grab two     digits, resulting in an invalid date:      \snippet code/src_corelib_tools_qdatetime.cpp 2      For any field that is not represented in the format the following     defaults are used:      \table     \header \li Field  \li Default value     \row    \li Year   \li 1900     \row    \li Month  \li 1     \row    \li Day    \li 1     \endtable      The following examples demonstrate the default values:      \snippet code/src_corelib_tools_qdatetime.cpp 3      \sa QDateTime::fromString(), QTime::fromString(), QDate::toString(),         QDateTime::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|fromString
name|QDate
name|QDate
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
name|QDate
name|date
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QDateTimeParser
name|dt
argument_list|(
name|QVariant
operator|::
name|Date
argument_list|,
name|QDateTimeParser
operator|::
name|FromString
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|parseFormat
argument_list|(
name|format
argument_list|)
condition|)
name|dt
operator|.
name|fromString
argument_list|(
name|string
argument_list|,
operator|&
name|date
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|date
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \overload      Returns true if the specified date (\a year, \a month, and \a     day) is valid; otherwise returns false.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 4      \sa isNull(), setDate() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QDate
operator|::
name|isValid
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
comment|// there is no year 0 in the Gregorian calendar
if|if
condition|(
name|year
operator|==
literal|0
condition|)
return|return
literal|false
return|;
return|return
operator|(
name|day
operator|>
literal|0
operator|&&
name|month
operator|>
literal|0
operator|&&
name|month
operator|<=
literal|12
operator|)
operator|&&
operator|(
name|day
operator|<=
name|monthDays
index|[
name|month
index|]
operator|||
operator|(
name|day
operator|==
literal|29
operator|&&
name|month
operator|==
literal|2
operator|&&
name|isLeapYear
argument_list|(
name|year
argument_list|)
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDate::isLeapYear(int year)      Returns true if the specified \a year is a leap year; otherwise     returns false. */
end_comment
begin_function
DECL|function|isLeapYear
name|bool
name|QDate
operator|::
name|isLeapYear
parameter_list|(
name|int
name|y
parameter_list|)
block|{
comment|// No year 0 in Gregorian calendar, so -1, -5, -9 etc are leap years
if|if
condition|(
name|y
operator|<
literal|1
condition|)
operator|++
name|y
expr_stmt|;
return|return
operator|(
name|y
operator|%
literal|4
operator|==
literal|0
operator|&&
name|y
operator|%
literal|100
operator|!=
literal|0
operator|)
operator|||
name|y
operator|%
literal|400
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \fn static QDate QDate::fromJulianDay(qint64 jd)      Converts the Julian day \a jd to a QDate.      \sa toJulianDay() */
end_comment
begin_comment
comment|/*! \fn int QDate::toJulianDay() const      Converts the date to a Julian day.      \sa fromJulianDay() */
end_comment
begin_comment
comment|/*****************************************************************************   QTime member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QTime     \inmodule QtCore     \reentrant      \brief The QTime class provides clock time functions.       A QTime object contains a clock time, i.e. the number of hours,     minutes, seconds, and milliseconds since midnight. It can read the     current time from the system clock and measure a span of elapsed     time. It provides functions for comparing times and for     manipulating a time by adding a number of milliseconds.      QTime uses the 24-hour clock format; it has no concept of AM/PM.     Unlike QDateTime, QTime knows nothing about time zones or     daylight savings time (DST).      A QTime object is typically created either by giving the number     of hours, minutes, seconds, and milliseconds explicitly, or by     using the static function currentTime(), which creates a QTime     object that contains the system's local time. Note that the     accuracy depends on the accuracy of the underlying operating     system; not all systems provide 1-millisecond accuracy.      The hour(), minute(), second(), and msec() functions provide     access to the number of hours, minutes, seconds, and milliseconds     of the time. The same information is provided in textual format by     the toString() function.      QTime provides a full set of operators to compare two QTime     objects. QTime A is considered smaller than QTime B if A is     earlier than B.      The addSecs() and addMSecs() functions provide the time a given     number of seconds or milliseconds later than a given time.     Correspondingly, the number of seconds or milliseconds     between two times can be found using secsTo() or msecsTo().      QTime can be used to measure a span of elapsed time using the     start(), restart(), and elapsed() functions.      \sa QDate, QDateTime */
end_comment
begin_comment
comment|/*!     \fn QTime::QTime()      Constructs a null time object. A null time can be a QTime(0, 0, 0, 0)     (i.e., midnight) object, except that isNull() returns true and isValid()     returns false.      \sa isNull(), isValid() */
end_comment
begin_comment
comment|/*!     Constructs a time with hour \a h, minute \a m, seconds \a s and     milliseconds \a ms.      \a h must be in the range 0 to 23, \a m and \a s must be in the     range 0 to 59, and \a ms must be in the range 0 to 999.      \sa isValid() */
end_comment
begin_constructor
DECL|function|QTime
name|QTime
operator|::
name|QTime
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
name|setHMS
argument_list|(
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn bool QTime::isNull() const      Returns true if the time is null (i.e., the QTime object was     constructed using the default constructor); otherwise returns     false. A null time is also an invalid time.      \sa isValid() */
end_comment
begin_comment
comment|/*!     Returns true if the time is valid; otherwise returns false. For example,     the time 23:30:55.746 is valid, but 24:12:30 is invalid.      \sa isNull() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QTime
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|mds
operator|>
name|NullTime
operator|&&
name|mds
operator|<
name|MSECS_PER_DAY
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the hour part (0 to 23) of the time.      Returns -1 if the time is invalid.      \sa minute(), second(), msec() */
end_comment
begin_function
DECL|function|hour
name|int
name|QTime
operator|::
name|hour
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ds
argument_list|()
operator|/
name|MSECS_PER_HOUR
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the minute part (0 to 59) of the time.      Returns -1 if the time is invalid.      \sa hour(), second(), msec() */
end_comment
begin_function
DECL|function|minute
name|int
name|QTime
operator|::
name|minute
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|ds
argument_list|()
operator|%
name|MSECS_PER_HOUR
operator|)
operator|/
name|MSECS_PER_MIN
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the second part (0 to 59) of the time.      Returns -1 if the time is invalid.      \sa hour(), minute(), msec() */
end_comment
begin_function
DECL|function|second
name|int
name|QTime
operator|::
name|second
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|ds
argument_list|()
operator|/
literal|1000
operator|)
operator|%
name|SECS_PER_MIN
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the millisecond part (0 to 999) of the time.      Returns -1 if the time is invalid.      \sa hour(), minute(), second() */
end_comment
begin_function
DECL|function|msec
name|int
name|QTime
operator|::
name|msec
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ds
argument_list|()
operator|%
literal|1000
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \overload      Returns the time as a string. The \a format parameter determines     the format of the string.      If \a format is Qt::TextDate, the string format is HH:MM:SS.zzz;     e.g. 1 second before midnight would be "23:59:59.000".      If \a format is Qt::ISODate, the string format corresponds to the     ISO 8601 extended specification (with decimal fractions) for     representations of dates; also HH:MM:SS.zzz.      If the \a format is Qt::SystemLocaleShortDate or     Qt::SystemLocaleLongDate, the string format depends on the locale     settings of the system. Identical to calling     QLocale::system().toString(time, QLocale::ShortFormat) or     QLocale::system().toString(time, QLocale::LongFormat).      If the \a format is Qt::DefaultLocaleShortDate or     Qt::DefaultLocaleLongDate, the string format depends on the     default application locale. This is the locale set with     QLocale::setDefault(), or the system locale if no default locale     has been set. Identical to calling QLocale().toString(time,     QLocale::ShortFormat) or QLocale().toString(time,     QLocale::LongFormat).      If the \a format is Qt::RFC2822Date, the string is formatted in     an \l{RFC 2822} compatible way. An example of this formatting is     "23:59:20".      If the time is invalid, an empty string will be returned. */
end_comment
begin_function
DECL|function|toString
name|QString
name|QTime
operator|::
name|toString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|format
operator|==
name|Qt
operator|::
name|SystemLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|format
operator|==
name|Qt
operator|::
name|DefaultLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1:%2:%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|hour
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|minute
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|second
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
default|default:
case|case
name|Qt
operator|::
name|ISODate
case|:
case|case
name|Qt
operator|::
name|TextDate
case|:
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1:%2:%3.%4"
argument_list|)
operator|.
name|arg
argument_list|(
name|hour
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|minute
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|second
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|msec
argument_list|()
argument_list|,
literal|3
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the time as a string. The \a format parameter determines     the format of the result string.      These expressions may be used:      \table     \header \li Expression \li Output     \row \li h          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li H          \li the hour without a leading zero (0 to 23, even with AM/PM display)     \row \li HH          \li the hour with a leading zero (00 to 23, even with AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP or A          \li use AM/PM display. \e A/AP will be replaced by either "AM" or "PM".     \row \li ap or a          \li use am/pm display. \e a/ap will be replaced by either "am" or "pm".     \row \li t \li the timezone (for example "CEST")     \endtable      All other input characters will be ignored. Any sequence of characters that     are enclosed in single quotes will be treated as text and not be used as an     expression. Two consecutive single quotes ("''") are replaced by a singlequote     in the output. Formats without separators (e.g. "HHmm") are currently not supported.      Example format strings (assuming that the QTime is 14:13:09.042)      \table     \header \li Format \li Result     \row \li hh:mm:ss.zzz \li 14:13:09.042     \row \li h:m:s ap     \li 2:13:9 pm     \row \li H:m:s a      \li 14:13:9 pm     \endtable      If the time is invalid, an empty string will be returned.     If \a format is empty, the default format "hh:mm:ss" is used.      \sa QDate::toString(), QDateTime::toString() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QTime
operator|::
name|toString
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
block|{
return|return
name|fmtDateTime
argument_list|(
name|format
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     Sets the time to hour \a h, minute \a m, seconds \a s and     milliseconds \a ms.      \a h must be in the range 0 to 23, \a m and \a s must be in the     range 0 to 59, and \a ms must be in the range 0 to 999.     Returns true if the set time is valid; otherwise returns false.      \sa isValid() */
end_comment
begin_function
DECL|function|setHMS
name|bool
name|QTime
operator|::
name|setHMS
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|startTick
operator|=
name|NullTime
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|isValid
argument_list|(
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|,
name|ms
argument_list|)
condition|)
block|{
name|mds
operator|=
name|NullTime
expr_stmt|;
comment|// make this invalid
return|return
literal|false
return|;
block|}
name|mds
operator|=
operator|(
name|h
operator|*
name|SECS_PER_HOUR
operator|+
name|m
operator|*
name|SECS_PER_MIN
operator|+
name|s
operator|)
operator|*
literal|1000
operator|+
name|ms
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QTime object containing a time \a s seconds later     than the time of this object (or earlier if \a s is negative).      Note that the time will wrap if it passes midnight.      Returns a null time if this time is invalid.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 5      \sa addMSecs(), secsTo(), QDateTime::addSecs() */
end_comment
begin_function
DECL|function|addSecs
name|QTime
name|QTime
operator|::
name|addSecs
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
return|return
name|addMSecs
argument_list|(
name|s
operator|*
literal|1000
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of seconds from this time to \a t.     If \a t is earlier than this time, the number of seconds returned     is negative.      Because QTime measures time within a day and there are 86400     seconds in a day, the result is always between -86400 and 86400.      secsTo() does not take into account any milliseconds.      Returns 0 if either time is invalid.      \sa addSecs(), QDateTime::secsTo() */
end_comment
begin_function
DECL|function|secsTo
name|int
name|QTime
operator|::
name|secsTo
parameter_list|(
specifier|const
name|QTime
modifier|&
name|t
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|t
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// Truncate milliseconds as we do not want to consider them.
name|int
name|ourSeconds
init|=
name|ds
argument_list|()
operator|/
literal|1000
decl_stmt|;
name|int
name|theirSeconds
init|=
name|t
operator|.
name|ds
argument_list|()
operator|/
literal|1000
decl_stmt|;
return|return
name|theirSeconds
operator|-
name|ourSeconds
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QTime object containing a time \a ms milliseconds later     than the time of this object (or earlier if \a ms is negative).      Note that the time will wrap if it passes midnight. See addSecs()     for an example.      Returns a null time if this time is invalid.      \sa addSecs(), msecsTo(), QDateTime::addMSecs() */
end_comment
begin_function
DECL|function|addMSecs
name|QTime
name|QTime
operator|::
name|addMSecs
parameter_list|(
name|int
name|ms
parameter_list|)
specifier|const
block|{
name|QTime
name|t
decl_stmt|;
if|if
condition|(
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|ms
operator|<
literal|0
condition|)
block|{
comment|// % not well-defined for -ve, but / is.
name|int
name|negdays
init|=
operator|(
name|MSECS_PER_DAY
operator|-
name|ms
operator|)
operator|/
name|MSECS_PER_DAY
decl_stmt|;
name|t
operator|.
name|mds
operator|=
operator|(
name|ds
argument_list|()
operator|+
name|ms
operator|+
name|negdays
operator|*
name|MSECS_PER_DAY
operator|)
operator|%
name|MSECS_PER_DAY
expr_stmt|;
block|}
else|else
block|{
name|t
operator|.
name|mds
operator|=
operator|(
name|ds
argument_list|()
operator|+
name|ms
operator|)
operator|%
name|MSECS_PER_DAY
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
name|startTick
operator|>
name|NullTime
condition|)
name|t
operator|.
name|startTick
operator|=
operator|(
name|startTick
operator|+
name|ms
operator|)
operator|%
name|MSECS_PER_DAY
expr_stmt|;
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of milliseconds from this time to \a t.     If \a t is earlier than this time, the number of milliseconds returned     is negative.      Because QTime measures time within a day and there are 86400     seconds in a day, the result is always between -86400000 and     86400000 ms.      Returns 0 if either time is invalid.      \sa secsTo(), addMSecs(), QDateTime::msecsTo() */
end_comment
begin_function
DECL|function|msecsTo
name|int
name|QTime
operator|::
name|msecsTo
parameter_list|(
specifier|const
name|QTime
modifier|&
name|t
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|t
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
comment|// GetLocalTime() for Windows CE has no milliseconds resolution
if|if
condition|(
name|t
operator|.
name|startTick
operator|>
name|NullTime
operator|&&
name|startTick
operator|>
name|NullTime
condition|)
return|return
name|t
operator|.
name|startTick
operator|-
name|startTick
return|;
else|else
endif|#
directive|endif
return|return
name|t
operator|.
name|ds
argument_list|()
operator|-
name|ds
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTime::operator==(const QTime&t) const      Returns true if this time is equal to \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator!=(const QTime&t) const      Returns true if this time is different from \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator<(const QTime&t) const      Returns true if this time is earlier than \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator<=(const QTime&t) const      Returns true if this time is earlier than or equal to \a t;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator>(const QTime&t) const      Returns true if this time is later than \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator>=(const QTime&t) const      Returns true if this time is later than or equal to \a t;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QTime::currentTime()      Returns the current time as reported by the system clock.      Note that the accuracy depends on the accuracy of the underlying     operating system; not all systems provide 1-millisecond accuracy. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|// These anonymous functions tidy up QDateTime::fromString()
end_comment
begin_comment
comment|// and avoid confusion of responsibility between it and QTime::fromString().
end_comment
begin_namespace
namespace|namespace
block|{
DECL|function|isMidnight
specifier|inline
name|bool
name|isMidnight
parameter_list|(
name|int
name|hour
parameter_list|,
name|int
name|minute
parameter_list|,
name|int
name|second
parameter_list|,
name|int
name|msec
parameter_list|)
block|{
return|return
name|hour
operator|==
literal|24
operator|&&
name|minute
operator|==
literal|0
operator|&&
name|second
operator|==
literal|0
operator|&&
name|msec
operator|==
literal|0
return|;
block|}
DECL|function|fromStringImpl
name|QTime
name|fromStringImpl
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|f
parameter_list|,
name|bool
modifier|&
name|isMidnight24
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Return a null time.
return|return
name|QTime
argument_list|()
return|;
block|}
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
block|{
name|QLocale
operator|::
name|FormatType
name|formatType
argument_list|(
name|Qt
operator|::
name|SystemLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
decl_stmt|;
return|return
name|QTime
operator|::
name|fromString
argument_list|(
name|s
argument_list|,
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|timeFormat
argument_list|(
name|formatType
argument_list|)
argument_list|)
return|;
block|}
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
block|{
name|QLocale
operator|::
name|FormatType
name|formatType
argument_list|(
name|f
operator|==
name|Qt
operator|::
name|DefaultLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
decl_stmt|;
return|return
name|QTime
operator|::
name|fromString
argument_list|(
name|s
argument_list|,
name|QLocale
argument_list|()
operator|.
name|timeFormat
argument_list|(
name|formatType
argument_list|)
argument_list|)
return|;
block|}
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
block|{
name|QTime
name|time
decl_stmt|;
name|rfcDateImpl
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
return|return
name|time
return|;
block|}
case|case
name|Qt
operator|::
name|TextDate
case|:
case|case
name|Qt
operator|::
name|ISODate
case|:
block|{
name|bool
name|ok
init|=
literal|true
decl_stmt|;
specifier|const
name|int
name|hour
argument_list|(
name|s
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
specifier|const
name|int
name|minute
argument_list|(
name|s
operator|.
name|mid
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
if|if
condition|(
name|f
operator|==
name|Qt
operator|::
name|ISODate
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|size
argument_list|()
operator|==
literal|5
condition|)
block|{
comment|// Do not need to specify seconds if using ISO format.
return|return
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|s
operator|.
name|size
argument_list|()
operator|>
literal|6
operator|)
operator|&&
operator|(
name|s
index|[
literal|5
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|||
name|s
index|[
literal|5
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|)
condition|)
block|{
comment|// Possibly specifying fraction of a minute.
comment|// We only want 5 digits worth of fraction of minute. This follows the existing
comment|// behaviour that determines how milliseconds are read; 4 millisecond digits are
comment|// read and then rounded to 3. If we read at most 5 digits for fraction of minute,
comment|// the maximum amount of millisecond digits it will expand to once converted to
comment|// seconds is 4. E.g. 12:34,99999 will expand to 12:34:59.9994. The milliseconds
comment|// will then be rounded up AND clamped to 999.
specifier|const
name|QString
name|minuteFractionStr
argument_list|(
name|QLatin1String
argument_list|(
literal|"0."
argument_list|)
operator|+
name|s
operator|.
name|mid
argument_list|(
literal|6
argument_list|,
literal|5
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|float
name|minuteFraction
init|=
name|minuteFractionStr
operator|.
name|toFloat
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
specifier|const
name|float
name|secondWithMs
init|=
name|minuteFraction
operator|*
literal|60
decl_stmt|;
specifier|const
name|float
name|second
init|=
name|std
operator|::
name|floor
argument_list|(
name|secondWithMs
argument_list|)
decl_stmt|;
specifier|const
name|float
name|millisecond
init|=
literal|1000
operator|*
operator|(
name|secondWithMs
operator|-
name|second
operator|)
decl_stmt|;
specifier|const
name|int
name|millisecondRounded
init|=
name|qMin
argument_list|(
name|qRound
argument_list|(
name|millisecond
argument_list|)
argument_list|,
literal|999
argument_list|)
decl_stmt|;
if|if
condition|(
name|isMidnight
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|millisecondRounded
argument_list|)
condition|)
block|{
name|isMidnight24
operator|=
literal|true
expr_stmt|;
return|return
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|millisecondRounded
argument_list|)
return|;
block|}
block|}
specifier|const
name|int
name|second
argument_list|(
name|s
operator|.
name|mid
argument_list|(
literal|6
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
specifier|const
name|QString
name|msec_s
argument_list|(
name|QLatin1String
argument_list|(
literal|"0."
argument_list|)
operator|+
name|s
operator|.
name|mid
argument_list|(
literal|9
argument_list|,
literal|4
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|double
name|msec
argument_list|(
name|msec_s
operator|.
name|toDouble
argument_list|(
operator|&
name|ok
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|f
operator|==
name|Qt
operator|::
name|ISODate
condition|)
block|{
if|if
condition|(
name|isMidnight
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|msec
argument_list|)
condition|)
block|{
name|isMidnight24
operator|=
literal|true
expr_stmt|;
return|return
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
return|return
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|qMin
argument_list|(
name|qRound
argument_list|(
name|msec
operator|*
literal|1000.0
argument_list|)
argument_list|,
literal|999
argument_list|)
argument_list|)
return|;
block|}
block|}
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|QTime
argument_list|()
return|;
block|}
block|}
end_namespace
begin_comment
comment|/*!     \fn QTime QTime::fromString(const QString&string, Qt::DateFormat format)      Returns the time represented in the \a string as a QTime using the     \a format given, or an invalid time if this is not possible.      Note that fromString() uses a "C" locale encoded string to convert     milliseconds to a float value. If the default locale is not "C",     this may result in two conversion attempts (if the conversion     fails for the default locale). This should be considered an     implementation detail. */
end_comment
begin_function
DECL|function|fromString
name|QTime
name|QTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|f
parameter_list|)
block|{
name|bool
name|unused
decl_stmt|;
return|return
name|fromStringImpl
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|unused
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTime::fromString(const QString&string, const QString&format)      Returns the QTime represented by the \a string, using the \a     format given, or an invalid time if the string cannot be parsed.      These expressions may be used for the format:      \table     \header \li Expression \li Output     \row \li h          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP          \li interpret as an AM/PM time. \e AP must be either "AM" or "PM".     \row \li ap          \li Interpret as an AM/PM time. \e ap must be either "am" or "pm".     \endtable      All other input characters will be treated as text. Any sequence     of characters that are enclosed in single quotes will also be     treated as text and not be used as an expression.      \snippet code/src_corelib_tools_qdatetime.cpp 6      If the format is not satisfied, an invalid QTime is returned.     Expressions that do not expect leading zeroes to be given (h, m, s     and z) are greedy. This means that they will use two digits even if     this puts them outside the range of accepted values and leaves too     few digits for other sections. For example, the following string     could have meant 00:07:10, but the m will grab two digits, resulting     in an invalid time:      \snippet code/src_corelib_tools_qdatetime.cpp 7      Any field that is not represented in the format will be set to zero.     For example:      \snippet code/src_corelib_tools_qdatetime.cpp 8      \sa QDateTime::fromString(), QDate::fromString(), QDate::toString(),     QDateTime::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|fromString
name|QTime
name|QTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
name|QTime
name|time
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QDateTimeParser
name|dt
argument_list|(
name|QVariant
operator|::
name|Time
argument_list|,
name|QDateTimeParser
operator|::
name|FromString
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|parseFormat
argument_list|(
name|format
argument_list|)
condition|)
name|dt
operator|.
name|fromString
argument_list|(
name|string
argument_list|,
literal|0
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|time
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \overload      Returns true if the specified time is valid; otherwise returns     false.      The time is valid if \a h is in the range 0 to 23, \a m and     \a s are in the range 0 to 59, and \a ms is in the range 0 to 999.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 9 */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QTime
operator|::
name|isValid
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
return|return
operator|(
name|uint
operator|)
name|h
operator|<
literal|24
operator|&&
operator|(
name|uint
operator|)
name|m
operator|<
literal|60
operator|&&
operator|(
name|uint
operator|)
name|s
operator|<
literal|60
operator|&&
operator|(
name|uint
operator|)
name|ms
operator|<
literal|1000
return|;
block|}
end_function
begin_comment
comment|/*!     Sets this time to the current time. This is practical for timing:      \snippet code/src_corelib_tools_qdatetime.cpp 10      \sa restart(), elapsed(), currentTime() */
end_comment
begin_function
DECL|function|start
name|void
name|QTime
operator|::
name|start
parameter_list|()
block|{
operator|*
name|this
operator|=
name|currentTime
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets this time to the current time and returns the number of     milliseconds that have elapsed since the last time start() or     restart() was called.      This function is guaranteed to be atomic and is thus very handy     for repeated measurements. Call start() to start the first     measurement, and restart() for each later measurement.      Note that the counter wraps to zero 24 hours after the last call     to start() or restart().      \warning If the system's clock setting has been changed since the     last time start() or restart() was called, the result is     undefined. This can happen when daylight savings time is turned on     or off.      \sa start(), elapsed(), currentTime() */
end_comment
begin_function
DECL|function|restart
name|int
name|QTime
operator|::
name|restart
parameter_list|()
block|{
name|QTime
name|t
init|=
name|currentTime
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|msecsTo
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|// passed midnight
name|n
operator|+=
literal|86400
operator|*
literal|1000
expr_stmt|;
operator|*
name|this
operator|=
name|t
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of milliseconds that have elapsed since the     last time start() or restart() was called.      Note that the counter wraps to zero 24 hours after the last call     to start() or restart.      Note that the accuracy depends on the accuracy of the underlying     operating system; not all systems provide 1-millisecond accuracy.      \warning If the system's clock setting has been changed since the     last time start() or restart() was called, the result is     undefined. This can happen when daylight savings time is turned on     or off.      \sa start(), restart() */
end_comment
begin_function
DECL|function|elapsed
name|int
name|QTime
operator|::
name|elapsed
parameter_list|()
specifier|const
block|{
name|int
name|n
init|=
name|msecsTo
argument_list|(
name|currentTime
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|// passed midnight
name|n
operator|+=
literal|86400
operator|*
literal|1000
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QDateTime member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QDateTime     \inmodule QtCore     \ingroup shared     \reentrant     \brief The QDateTime class provides date and time functions.       A QDateTime object contains a calendar date and a clock time (a     "datetime"). It is a combination of the QDate and QTime classes.     It can read the current datetime from the system clock. It     provides functions for comparing datetimes and for manipulating a     datetime by adding a number of seconds, days, months, or years.      A QDateTime object is typically created either by giving a date     and time explicitly in the constructor, or by using the static     function currentDateTime() that returns a QDateTime object set     to the system clock's time. The date and time can be changed with     setDate() and setTime(). A datetime can also be set using the     setTime_t() function that takes a POSIX-standard "number of     seconds since 00:00:00 on January 1, 1970" value. The fromString()     function returns a QDateTime, given a string and a date format     used to interpret the date within the string.      The date() and time() functions provide access to the date and     time parts of the datetime. The same information is provided in     textual format by the toString() function.      QDateTime provides a full set of operators to compare two     QDateTime objects, where smaller means earlier and larger means     later.      You can increment (or decrement) a datetime by a given number of     milliseconds using addMSecs(), seconds using addSecs(), or days     using addDays(). Similarly, you can use addMonths() and addYears().     The daysTo() function returns the number of days between two datetimes,     secsTo() returns the number of seconds between two datetimes, and     msecsTo() returns the number of milliseconds between two datetimes.      QDateTime can store datetimes as \l{Qt::LocalTime}{local time} or     as \l{Qt::UTC}{UTC}. QDateTime::currentDateTime() returns a     QDateTime expressed as local time; use toUTC() to convert it to     UTC. You can also use timeSpec() to find out if a QDateTime     object stores a UTC time or a local time. Operations such as     addSecs() and secsTo() are aware of daylight saving time (DST).      \note QDateTime does not account for leap seconds.      \section1      \section2 No Year 0      There is no year 0. Dates in that year are considered invalid. The     year -1 is the year "1 before Christ" or "1 before current era."     The day before 1 January 1 CE is 31 December 1 BCE.      \section2 Range of Valid Dates      Dates are stored internally as a Julian Day number, an integer count of     every day in a contiguous range, with 24 November 4714 BCE in the Gregorian     calendar being Julian Day 0 (1 January 4713 BCE in the Julian calendar).     As well as being an efficient and accurate way of storing an absolute date,     it is suitable for converting a Date into other calendar systems such as     Hebrew, Islamic or Chinese. The Julian Day number can be obtained using     QDate::toJulianDay() and can be set using QDate::fromJulianDay().      The range of dates able to be stored by QDate as a Julian Day number is     for technical reasons limited to between -784350574879 and 784354017364,     which means from before 2 billion BCE to after 2 billion CE.      \section2     Use of System Timezone      QDateTime uses the system's time zone information to determine the     offset of local time from UTC. If the system is not configured     correctly or not up-to-date, QDateTime will give wrong results as     well.      \section2 Daylight Savings Time (DST)      QDateTime takes into account the system's time zone information     when dealing with DST. On modern Unix systems, this means it     applies the correct historical DST data whenever possible. On     Windows and Windows CE, where the system doesn't support     historical DST data, historical accuracy is not maintained with     respect to DST.      The range of valid dates taking DST into account is 1970-01-01 to     the present, and rules are in place for handling DST correctly     until 2037-12-31, but these could change. For dates falling     outside that range, QDateTime makes a \e{best guess} using the     rules for year 1970 or 2037, but we can't guarantee accuracy. This     means QDateTime doesn't take into account changes in a locale's     time zone before 1970, even if the system's time zone database     supports that information.      \section2 Offset From UTC      A Qt::TimeSpec of Qt::OffsetFromUTC is also supported. This allows you     to define a QDateTime relative to UTC at a fixed offset of a given number     of seconds from UTC.  For example, an offset of +3600 seconds is one hour     ahead of UTC and is usually written in ISO standard notation as     "UTC+01:00".  Daylight Savings Time never applies with this TimeSpec.      There is no explicit size restriction to the offset seconds, but there is     an implicit limit imposed when using the toString() and fromString()     methods which use a format of [+|-]hh:mm, effectively limiting the range     to +/- 99 hours and 59 minutes and whole minutes only.  Note that currently     no time zone lies outside the range of +/- 14 hours.      \sa QDate, QTime, QDateTimeEdit */
end_comment
begin_comment
comment|/*!     Constructs a null datetime (i.e. null date and null time). A null     datetime is invalid, since the date is invalid.      \sa isValid() */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a datetime with the given \a date, a valid     time(00:00:00.000), and sets the timeSpec() to Qt::LocalTime. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|(
name|date
argument_list|,
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|,
literal|0
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a datetime with the given \a date and \a time, using     the time specification defined by \a spec.      If \a date is valid and \a time is not, the time will be set to midnight.      If \a spec is Qt::OffsetFromUTC then it will be set to Qt::UTC, i.e. an     offset of 0 seconds. To create a Qt::OffsetFromUTC datetime use the     correct constructor. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|spec
argument_list|,
literal|0
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \since 5.2      Constructs a datetime with the given \a date and \a time, using     the time specification defined by \a spec and \a offsetSeconds seconds.      If \a date is valid and \a time is not, the time will be set to midnight.      If the \a spec is not Qt::OffsetFromUTC then \a offsetSeconds will be ignored.      If the \a spec is Qt::OffsetFromUTC and \a offsetSeconds is 0 then the     timeSpec() will be set to Qt::UTC, i.e. an offset of 0 seconds. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|,
name|int
name|offsetSeconds
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|spec
argument_list|,
name|offsetSeconds
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal     \since 5.2      Private.      Create a datetime with the given \a date, \a time, \a spec and \a offsetSeconds */
end_comment
begin_constructor
DECL|function|QDateTimePrivate
name|QDateTimePrivate
operator|::
name|QDateTimePrivate
parameter_list|(
specifier|const
name|QDate
modifier|&
name|toDate
parameter_list|,
specifier|const
name|QTime
modifier|&
name|toTime
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|toSpec
parameter_list|,
name|int
name|offsetSeconds
parameter_list|)
block|{
name|date
operator|=
name|toDate
expr_stmt|;
if|if
condition|(
operator|!
name|toTime
operator|.
name|isValid
argument_list|()
operator|&&
name|toDate
operator|.
name|isValid
argument_list|()
condition|)
name|time
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|time
operator|=
name|toTime
expr_stmt|;
name|m_offsetFromUtc
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|toSpec
condition|)
block|{
case|case
name|Qt
operator|::
name|UTC
case|:
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
if|if
condition|(
name|offsetSeconds
operator|==
literal|0
condition|)
block|{
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
block|}
else|else
block|{
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
expr_stmt|;
name|m_offsetFromUtc
operator|=
name|offsetSeconds
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|LocalTime
case|:
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of the \a other datetime. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the datetime. */
end_comment
begin_destructor
DECL|function|~QDateTime
name|QDateTime
operator|::
name|~
name|QDateTime
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Makes a copy of the \a other datetime and returns a reference to the     copy. */
end_comment
begin_function
DECL|function|operator =
name|QDateTime
modifier|&
name|QDateTime
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QDateTime::swap(QDateTime&other)     \since 5.0      Swaps this datetime with \a other. This operation is very fast     and never fails. */
end_comment
begin_comment
comment|/*!     Returns true if both the date and the time are null; otherwise     returns false. A null datetime is invalid.      \sa QDate::isNull(), QTime::isNull(), isValid() */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QDateTime
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|date
operator|.
name|isNull
argument_list|()
operator|&&
name|d
operator|->
name|time
operator|.
name|isNull
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if both the date and the time are valid; otherwise     returns false.      \sa QDate::isValid(), QTime::isValid() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QDateTime
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|date
operator|.
name|isValid
argument_list|()
operator|&&
name|d
operator|->
name|time
operator|.
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the date part of the datetime.      \sa setDate(), time(), timeSpec() */
end_comment
begin_function
DECL|function|date
name|QDate
name|QDateTime
operator|::
name|date
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|date
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the time part of the datetime.      \sa setTime(), date(), timeSpec() */
end_comment
begin_function
DECL|function|time
name|QTime
name|QDateTime
operator|::
name|time
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|time
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the time specification of the datetime.      \sa setTimeSpec(), date(), time(), Qt::TimeSpec */
end_comment
begin_function
DECL|function|timeSpec
name|Qt
operator|::
name|TimeSpec
name|QDateTime
operator|::
name|timeSpec
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|d
operator|->
name|spec
condition|)
block|{
case|case
name|QDateTimePrivate
operator|::
name|UTC
case|:
return|return
name|Qt
operator|::
name|UTC
return|;
case|case
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
case|:
return|return
name|Qt
operator|::
name|OffsetFromUTC
return|;
default|default:
return|return
name|Qt
operator|::
name|LocalTime
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Returns the current Offset From UTC in seconds.      If the timeSpec() is Qt::OffsetFromUTC this will be the value originally set.      If the timeSpec() is Qt::LocalTime this will be the difference between the     Local Time and UTC including any Daylight Saving Offset.      If the timeSpec() is Qt::UTC this will be 0.      \sa setOffsetFromUtc() */
end_comment
begin_function
DECL|function|offsetFromUtc
name|int
name|QDateTime
operator|::
name|offsetFromUtc
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|d
operator|->
name|spec
condition|)
block|{
case|case
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
case|:
return|return
name|d
operator|->
name|m_offsetFromUtc
return|;
case|case
name|QDateTimePrivate
operator|::
name|UTC
case|:
return|return
literal|0
return|;
default|default:
comment|// Any Qt::LocalTime
specifier|const
name|QDateTime
name|fakeDate
argument_list|(
name|d
operator|->
name|date
argument_list|,
name|d
operator|->
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
return|return
operator|(
name|fakeDate
operator|.
name|toMSecsSinceEpoch
argument_list|()
operator|-
name|toMSecsSinceEpoch
argument_list|()
operator|)
operator|/
literal|1000
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Returns the Time Zone Abbreviation for the datetime.      If the timeSpec() is Qt::UTC this will be "UTC".      If the timeSpec() is Qt::OffsetFromUTC this will be in the format     "UTC[+-]00:00".      If the timeSpec() is Qt::LocalTime then the host system is queried for the     correct abbreviation.      Note that abbreviations may or may not be localized.      Note too that the abbreviation is not guaranteed to be a unique value,     i.e. different time zones may have the same abbreviation.      \sa timeSpec() */
end_comment
begin_function
DECL|function|timeZoneAbbreviation
name|QString
name|QDateTime
operator|::
name|timeZoneAbbreviation
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|d
operator|->
name|spec
condition|)
block|{
case|case
name|QDateTimePrivate
operator|::
name|UTC
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"UTC"
argument_list|)
return|;
case|case
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
case|:
return|return
name|QLatin1String
argument_list|(
literal|"UTC"
argument_list|)
operator|+
name|toOffsetString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|,
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
return|;
default|default:
block|{
comment|// Any Qt::LocalTime
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
comment|// TODO Stub to enable compilation on WinCE
return|return
name|QString
argument_list|()
return|;
else|#
directive|else
name|QDate
name|dt
init|=
name|adjustDate
argument_list|(
name|d
operator|->
name|date
argument_list|)
decl_stmt|;
name|QTime
name|tm
init|=
name|d
operator|->
name|time
decl_stmt|;
name|QString
name|abbrev
decl_stmt|;
name|qt_mktime
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
operator|&
name|abbrev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|abbrev
return|;
endif|#
directive|endif
comment|// !Q_OS_WINCE
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Sets the date part of this datetime to \a date.     If no time is set, it is set to midnight.      \sa date(), setTime(), setTimeSpec() */
end_comment
begin_function
DECL|function|setDate
name|void
name|QDateTime
operator|::
name|setDate
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|date
operator|=
name|date
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|LocalStandard
operator|||
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|LocalDST
condition|)
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
if|if
condition|(
name|date
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|time
operator|.
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|time
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the time part of this datetime to \a time.      \sa time(), setDate(), setTimeSpec() */
end_comment
begin_function
DECL|function|setTime
name|void
name|QDateTime
operator|::
name|setTime
parameter_list|(
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|LocalStandard
operator|||
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|LocalDST
condition|)
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
name|d
operator|->
name|time
operator|=
name|time
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the time specification used in this datetime to \a spec.     The datetime will refer to a different point in time.      If \a spec is Qt::OffsetFromUTC then the timeSpec() will be set     to Qt::UTC, i.e. an effective offset of 0.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 19      \sa timeSpec(), setDate(), setTime(), Qt::TimeSpec */
end_comment
begin_function
DECL|function|setTimeSpec
name|void
name|QDateTime
operator|::
name|setTimeSpec
parameter_list|(
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|m_offsetFromUtc
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|spec
condition|)
block|{
case|case
name|Qt
operator|::
name|UTC
case|:
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
break|break;
default|default:
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Sets the timeSpec() to Qt::OffsetFromUTC and the offset to \a offsetSeconds.     The datetime will refer to a different point in time.      The maximum and minimum offset is 14 positive or negative hours.  If     \a offsetSeconds is larger or smaller than that, then the result is     undefined.      If \a offsetSeconds is 0 then the timeSpec() will be set to Qt::UTC.      \sa isValid(), offsetFromUtc() */
end_comment
begin_function
DECL|function|setOffsetFromUtc
name|void
name|QDateTime
operator|::
name|setOffsetFromUtc
parameter_list|(
name|int
name|offsetSeconds
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|offsetSeconds
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
name|d
operator|->
name|m_offsetFromUtc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
expr_stmt|;
name|d
operator|->
name|m_offsetFromUtc
operator|=
name|offsetSeconds
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|toMSecsSinceEpoch_helper
name|qint64
name|toMSecsSinceEpoch_helper
parameter_list|(
name|qint64
name|jd
parameter_list|,
name|int
name|msecs
parameter_list|)
block|{
name|qint64
name|days
init|=
name|jd
operator|-
name|JULIAN_DAY_FOR_EPOCH
decl_stmt|;
name|qint64
name|retval
init|=
operator|(
name|days
operator|*
name|MSECS_PER_DAY
operator|)
operator|+
name|msecs
decl_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the datetime as the number of milliseconds that have passed     since 1970-01-01T00:00:00.000, Coordinated Universal Time (Qt::UTC).      On systems that do not support time zones, this function will     behave as if local time were Qt::UTC.      The behavior for this function is undefined if the datetime stored in     this object is not valid. However, for all valid dates, this function     returns a unique value.      \sa toTime_t(), setMSecsSinceEpoch() */
end_comment
begin_function
DECL|function|toMSecsSinceEpoch
name|qint64
name|QDateTime
operator|::
name|toMSecsSinceEpoch
parameter_list|()
specifier|const
block|{
name|QDate
name|utcDate
decl_stmt|;
name|QTime
name|utcTime
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|utcDate
argument_list|,
name|utcTime
argument_list|)
expr_stmt|;
return|return
name|toMSecsSinceEpoch_helper
argument_list|(
name|utcDate
operator|.
name|toJulianDay
argument_list|()
argument_list|,
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|msecsTo
argument_list|(
name|utcTime
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the datetime as the number of seconds that have passed     since 1970-01-01T00:00:00, Coordinated Universal Time (Qt::UTC).      On systems that do not support time zones, this function will     behave as if local time were Qt::UTC.      \note This function returns a 32-bit unsigned integer, so it does not     support dates before 1970, but it does support dates after     2038-01-19T03:14:06, which may not be valid time_t values. Be careful     when passing those time_t values to system functions, which could     interpret them as negative dates.      If the date is outside the range 1970-01-01T00:00:00 to     2106-02-07T06:28:14, this function returns -1 cast to an unsigned integer     (i.e., 0xFFFFFFFF).      To get an extended range, use toMSecsSinceEpoch().      \sa toMSecsSinceEpoch(), setTime_t() */
end_comment
begin_function
DECL|function|toTime_t
name|uint
name|QDateTime
operator|::
name|toTime_t
parameter_list|()
specifier|const
block|{
name|qint64
name|retval
init|=
name|toMSecsSinceEpoch
argument_list|()
operator|/
literal|1000
decl_stmt|;
if|if
condition|(
name|quint64
argument_list|(
name|retval
argument_list|)
operator|>=
name|Q_UINT64_C
argument_list|(
literal|0xFFFFFFFF
argument_list|)
condition|)
return|return
name|uint
argument_list|(
operator|-
literal|1
argument_list|)
return|;
return|return
name|uint
argument_list|(
name|retval
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Sets the date and time given the number of milliseconds \a msecs that have     passed since 1970-01-01T00:00:00.000, Coordinated Universal Time     (Qt::UTC). On systems that do not support time zones this function     will behave as if local time were Qt::UTC.      Note that passing the minimum of \c qint64     (\c{std::numeric_limits<qint64>::min()}) to \a msecs will result in     undefined behavior.      \sa toMSecsSinceEpoch(), setTime_t() */
end_comment
begin_function
DECL|function|setMSecsSinceEpoch
name|void
name|QDateTime
operator|::
name|setMSecsSinceEpoch
parameter_list|(
name|qint64
name|msecs
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|qint64
name|ddays
init|=
name|msecs
operator|/
name|MSECS_PER_DAY
decl_stmt|;
name|msecs
operator|%=
name|MSECS_PER_DAY
expr_stmt|;
if|if
condition|(
name|msecs
operator|<
literal|0
condition|)
block|{
comment|// negative
operator|--
name|ddays
expr_stmt|;
name|msecs
operator|+=
name|MSECS_PER_DAY
expr_stmt|;
block|}
name|d
operator|->
name|date
operator|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|.
name|addDays
argument_list|(
name|ddays
argument_list|)
expr_stmt|;
name|d
operator|->
name|time
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|addMSecs
argument_list|(
name|msecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
name|utcToOffset
argument_list|(
operator|&
name|d
operator|->
name|date
argument_list|,
operator|&
name|d
operator|->
name|time
argument_list|,
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|spec
operator|!=
name|QDateTimePrivate
operator|::
name|UTC
condition|)
name|utcToLocal
argument_list|(
name|d
operator|->
name|date
argument_list|,
name|d
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QDateTime::setTime_t(uint seconds)      Sets the date and time given the number of \a seconds that have     passed since 1970-01-01T00:00:00, Coordinated Universal Time     (Qt::UTC). On systems that do not support time zones this function     will behave as if local time were Qt::UTC.      \sa toTime_t() */
end_comment
begin_function
DECL|function|setTime_t
name|void
name|QDateTime
operator|::
name|setTime_t
parameter_list|(
name|uint
name|secsSince1Jan1970UTC
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|date
operator|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|.
name|addDays
argument_list|(
name|secsSince1Jan1970UTC
operator|/
name|SECS_PER_DAY
argument_list|)
expr_stmt|;
name|d
operator|->
name|time
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|addSecs
argument_list|(
name|secsSince1Jan1970UTC
operator|%
name|SECS_PER_DAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
name|utcToOffset
argument_list|(
operator|&
name|d
operator|->
name|date
argument_list|,
operator|&
name|d
operator|->
name|time
argument_list|,
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|spec
operator|!=
name|QDateTimePrivate
operator|::
name|UTC
condition|)
name|utcToLocal
argument_list|(
name|d
operator|->
name|date
argument_list|,
name|d
operator|->
name|time
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \fn QString QDateTime::toString(Qt::DateFormat format) const      \overload      Returns the datetime as a string in the \a format given.      If the \a format is Qt::TextDate, the string is formatted in     the default way. QDate::shortDayName(), QDate::shortMonthName(),     and QTime::toString() are used to generate the string, so the     day and month names will be localized names. An example of this     formatting is "Wed May 20 03:40:13.456 1998".      If the \a format is Qt::ISODate, the string format corresponds     to the ISO 8601 extended specification (with decimal fractions) for     representations of dates and times, taking the form     YYYY-MM-DDTHH:MM:SS.zzz[Z|[+|-]HH:MM], depending on the timeSpec()     of the QDateTime. If the timeSpec() is Qt::UTC, Z will be appended     to the string; if the timeSpec() is Qt::OffsetFromUTC, the offset     in hours and minutes from UTC will be appended to the string.      If the \a format is Qt::SystemLocaleShortDate or     Qt::SystemLocaleLongDate, the string format depends on the locale     settings of the system. Identical to calling     QLocale::system().toString(datetime, QLocale::ShortFormat) or     QLocale::system().toString(datetime, QLocale::LongFormat).      If the \a format is Qt::DefaultLocaleShortDate or     Qt::DefaultLocaleLongDate, the string format depends on the     default application locale. This is the locale set with     QLocale::setDefault(), or the system locale if no default locale     has been set. Identical to calling QLocale().toString(datetime,     QLocale::ShortFormat) or QLocale().toString(datetime,     QLocale::LongFormat).      If the \a format is Qt::RFC2822Date, the string is formatted     following \l{RFC 2822}.      If the datetime is invalid, an empty string will be returned.      \warning The Qt::ISODate format is only valid for years in the     range 0 to 9999. This restriction may apply to locale-aware     formats as well, depending on the locale settings.      \sa QDate::toString(), QTime::toString(), Qt::DateFormat */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDateTime
operator|::
name|toString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|f
parameter_list|)
specifier|const
block|{
name|QString
name|buf
decl_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|buf
return|;
if|if
condition|(
name|f
operator|==
name|Qt
operator|::
name|ISODate
condition|)
block|{
name|buf
operator|=
name|d
operator|->
name|date
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// failed to convert
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|d
operator|->
name|time
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|spec
condition|)
block|{
case|case
name|QDateTimePrivate
operator|::
name|UTC
case|:
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
case|:
block|{
name|buf
operator|+=
name|toOffsetString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|,
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|==
name|Qt
operator|::
name|RFC2822Date
condition|)
block|{
name|buf
operator|=
name|toString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"dd MMM yyyy hh:mm:ss "
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|utcOffset
init|=
name|d
operator|->
name|m_offsetFromUtc
decl_stmt|;
if|if
condition|(
name|timeSpec
argument_list|()
operator|==
name|Qt
operator|::
name|LocalTime
condition|)
block|{
name|QDateTime
name|utc
init|=
name|toUTC
argument_list|()
decl_stmt|;
name|utc
operator|.
name|setTimeSpec
argument_list|(
name|timeSpec
argument_list|()
argument_list|)
expr_stmt|;
name|utcOffset
operator|=
name|utc
operator|.
name|secsTo
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
specifier|const
name|int
name|offset
init|=
name|qAbs
argument_list|(
name|utcOffset
argument_list|)
decl_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
operator|(
name|offset
operator|==
name|utcOffset
operator|)
condition|?
literal|'+'
else|:
literal|'-'
argument_list|)
expr_stmt|;
specifier|const
name|int
name|hour
init|=
name|offset
operator|/
literal|3600
decl_stmt|;
if|if
condition|(
name|hour
operator|<
literal|10
condition|)
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|hour
argument_list|)
expr_stmt|;
specifier|const
name|int
name|min
init|=
operator|(
name|offset
operator|-
operator|(
name|hour
operator|*
literal|3600
operator|)
operator|)
operator|/
literal|60
decl_stmt|;
if|if
condition|(
name|min
operator|<
literal|10
condition|)
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|min
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
elseif|else
if|if
condition|(
name|f
operator|==
name|Qt
operator|::
name|TextDate
condition|)
block|{
ifndef|#
directive|ifndef
name|Q_OS_WIN
name|buf
operator|=
name|d
operator|->
name|date
operator|.
name|shortDayName
argument_list|(
name|d
operator|->
name|date
operator|.
name|dayOfWeek
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|d
operator|->
name|date
operator|.
name|shortMonthName
argument_list|(
name|d
operator|->
name|date
operator|.
name|month
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|d
operator|->
name|date
operator|.
name|day
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|wchar_t
name|out
index|[
literal|255
index|]
decl_stmt|;
name|GetLocaleInfo
argument_list|(
name|LOCALE_USER_DEFAULT
argument_list|,
name|LOCALE_ILDATE
argument_list|,
name|out
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|QString
name|winstr
init|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|out
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|winstr
operator|.
name|toInt
argument_list|()
condition|)
block|{
case|case
literal|1
case|:
name|buf
operator|=
name|d
operator|->
name|date
operator|.
name|shortDayName
argument_list|(
name|d
operator|->
name|date
operator|.
name|dayOfWeek
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|d
operator|->
name|date
operator|.
name|day
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1String
argument_list|(
literal|". "
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|d
operator|->
name|date
operator|.
name|shortMonthName
argument_list|(
name|d
operator|->
name|date
operator|.
name|month
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|buf
operator|=
name|d
operator|->
name|date
operator|.
name|shortDayName
argument_list|(
name|d
operator|->
name|date
operator|.
name|dayOfWeek
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|d
operator|->
name|date
operator|.
name|shortMonthName
argument_list|(
name|d
operator|->
name|date
operator|.
name|month
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|d
operator|->
name|date
operator|.
name|day
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|d
operator|->
name|time
operator|.
name|toString
argument_list|()
expr_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|d
operator|->
name|date
operator|.
name|year
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|buf
operator|=
name|d
operator|->
name|date
operator|.
name|toString
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// failed to convert
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|d
operator|->
name|time
operator|.
name|toString
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the datetime as a string. The \a format parameter     determines the format of the result string.      These expressions may be used for the date:      \table     \header \li Expression \li Output     \row \li d \li the day as number without a leading zero (1 to 31)     \row \li dd \li the day as number with a leading zero (01 to 31)     \row \li ddd             \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').             Uses QDate::shortDayName().     \row \li dddd             \li the long localized day name (e.g. 'Monday' to 'Qt::Sunday').             Uses QDate::longDayName().     \row \li M \li the month as number without a leading zero (1-12)     \row \li MM \li the month as number with a leading zero (01-12)     \row \li MMM             \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').             Uses QDate::shortMonthName().     \row \li MMMM             \li the long localized month name (e.g. 'January' to 'December').             Uses QDate::longMonthName().     \row \li yy \li the year as two digit number (00-99)     \row \li yyyy \li the year as four digit number     \endtable      These expressions may be used for the time:      \table     \header \li Expression \li Output     \row \li h          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP             \li use AM/PM display. \e AP will be replaced by either "AM" or "PM".     \row \li ap             \li use am/pm display. \e ap will be replaced by either "am" or "pm".     \endtable      All other input characters will be ignored. Any sequence of characters that     are enclosed in single quotes will be treated as text and not be used as an     expression. Two consecutive single quotes ("''") are replaced by a singlequote     in the output. Formats without separators (e.g. "HHmm") are currently not supported.      Example format strings (assumed that the QDateTime is 21 May 2001     14:13:09):      \table     \header \li Format       \li Result     \row \li dd.MM.yyyy      \li 21.05.2001     \row \li ddd MMMM d yy   \li Tue May 21 01     \row \li hh:mm:ss.zzz    \li 14:13:09.042     \row \li h:m:s ap        \li 2:13:9 pm     \endtable      If the datetime is invalid, an empty string will be returned.      \sa QDate::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDateTime
operator|::
name|toString
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
block|{
return|return
name|fmtDateTime
argument_list|(
name|format
argument_list|,
operator|&
name|d
operator|->
name|time
argument_list|,
operator|&
name|d
operator|->
name|date
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a ndays days     later than the datetime of this object (or earlier if \a ndays is     negative).      \sa daysTo(), addMonths(), addYears(), addSecs() */
end_comment
begin_function
DECL|function|addDays
name|QDateTime
name|QDateTime
operator|::
name|addDays
parameter_list|(
name|qint64
name|ndays
parameter_list|)
specifier|const
block|{
name|QDateTime
name|dt
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|dt
operator|.
name|detach
argument_list|()
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|date
operator|=
name|d
operator|->
name|date
operator|.
name|addDays
argument_list|(
name|ndays
argument_list|)
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a nmonths months     later than the datetime of this object (or earlier if \a nmonths     is negative).      \sa daysTo(), addDays(), addYears(), addSecs() */
end_comment
begin_function
DECL|function|addMonths
name|QDateTime
name|QDateTime
operator|::
name|addMonths
parameter_list|(
name|int
name|nmonths
parameter_list|)
specifier|const
block|{
name|QDateTime
name|dt
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|dt
operator|.
name|detach
argument_list|()
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|date
operator|=
name|d
operator|->
name|date
operator|.
name|addMonths
argument_list|(
name|nmonths
argument_list|)
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a nyears years     later than the datetime of this object (or earlier if \a nyears is     negative).      \sa daysTo(), addDays(), addMonths(), addSecs() */
end_comment
begin_function
DECL|function|addYears
name|QDateTime
name|QDateTime
operator|::
name|addYears
parameter_list|(
name|int
name|nyears
parameter_list|)
specifier|const
block|{
name|QDateTime
name|dt
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|dt
operator|.
name|detach
argument_list|()
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|date
operator|=
name|d
operator|->
name|date
operator|.
name|addYears
argument_list|(
name|nyears
argument_list|)
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_function
DECL|function|addMSecs
name|QDateTime
name|QDateTimePrivate
operator|::
name|addMSecs
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|dt
parameter_list|,
name|qint64
name|msecs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dt
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|QDate
name|utcDate
decl_stmt|;
name|QTime
name|utcTime
decl_stmt|;
name|dt
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|utcDate
argument_list|,
name|utcTime
argument_list|)
expr_stmt|;
name|addMSecs
argument_list|(
name|utcDate
argument_list|,
name|utcTime
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
name|QDateTime
name|utc
argument_list|(
name|utcDate
argument_list|,
name|utcTime
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|timeSpec
argument_list|()
operator|==
name|Qt
operator|::
name|OffsetFromUTC
condition|)
return|return
name|utc
operator|.
name|toOffsetFromUtc
argument_list|(
name|dt
operator|.
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
return|;
else|else
return|return
name|utc
operator|.
name|toTimeSpec
argument_list|(
name|dt
operator|.
name|timeSpec
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!  Adds \a msecs to utcDate and \a utcTime as appropriate. It is assumed that  utcDate and utcTime are adjusted to UTC.   \since 4.5  \internal  */
end_comment
begin_function
DECL|function|addMSecs
name|void
name|QDateTimePrivate
operator|::
name|addMSecs
parameter_list|(
name|QDate
modifier|&
name|utcDate
parameter_list|,
name|QTime
modifier|&
name|utcTime
parameter_list|,
name|qint64
name|msecs
parameter_list|)
block|{
name|qint64
name|dd
init|=
name|utcDate
operator|.
name|toJulianDay
argument_list|()
decl_stmt|;
name|int
name|tt
init|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|msecsTo
argument_list|(
name|utcTime
argument_list|)
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|msecs
operator|<
literal|0
condition|)
block|{
name|msecs
operator|=
operator|-
name|msecs
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|msecs
operator|>=
name|int
argument_list|(
name|MSECS_PER_DAY
argument_list|)
condition|)
block|{
name|dd
operator|+=
name|sign
operator|*
operator|(
name|msecs
operator|/
name|MSECS_PER_DAY
operator|)
expr_stmt|;
name|msecs
operator|%=
name|MSECS_PER_DAY
expr_stmt|;
block|}
name|tt
operator|+=
name|sign
operator|*
name|msecs
expr_stmt|;
if|if
condition|(
name|tt
operator|<
literal|0
condition|)
block|{
name|tt
operator|=
name|MSECS_PER_DAY
operator|-
name|tt
operator|-
literal|1
expr_stmt|;
name|dd
operator|-=
name|tt
operator|/
name|MSECS_PER_DAY
expr_stmt|;
name|tt
operator|=
name|tt
operator|%
name|MSECS_PER_DAY
expr_stmt|;
name|tt
operator|=
name|MSECS_PER_DAY
operator|-
name|tt
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tt
operator|>=
name|int
argument_list|(
name|MSECS_PER_DAY
argument_list|)
condition|)
block|{
name|dd
operator|+=
name|tt
operator|/
name|MSECS_PER_DAY
expr_stmt|;
name|tt
operator|=
name|tt
operator|%
name|MSECS_PER_DAY
expr_stmt|;
block|}
name|utcDate
operator|=
name|QDate
operator|::
name|fromJulianDay
argument_list|(
name|dd
argument_list|)
expr_stmt|;
name|utcTime
operator|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|addMSecs
argument_list|(
name|tt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a s seconds     later than the datetime of this object (or earlier if \a s is     negative).      If this datetime is invalid, an invalid datetime will be returned.      \sa addMSecs(), secsTo(), addDays(), addMonths(), addYears() */
end_comment
begin_function
DECL|function|addSecs
name|QDateTime
name|QDateTime
operator|::
name|addSecs
parameter_list|(
name|qint64
name|s
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|addMSecs
argument_list|(
operator|*
name|this
argument_list|,
name|s
operator|*
literal|1000
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a msecs miliseconds     later than the datetime of this object (or earlier if \a msecs is     negative).      If this datetime is invalid, an invalid datetime will be returned.      \sa addSecs(), msecsTo(), addDays(), addMonths(), addYears() */
end_comment
begin_function
DECL|function|addMSecs
name|QDateTime
name|QDateTime
operator|::
name|addMSecs
parameter_list|(
name|qint64
name|msecs
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|addMSecs
argument_list|(
operator|*
name|this
argument_list|,
name|msecs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days from this datetime to the \a other     datetime. The number of days is counted as the number of times     midnight is reached between this datetime to the \a other     datetime. This means that a 10 minute difference from 23:55 to     0:05 the next day counts as one day.      If the \a other datetime is earlier than this datetime,     the value returned is negative.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 15      \sa addDays(), secsTo(), msecsTo() */
end_comment
begin_function
DECL|function|daysTo
name|qint64
name|QDateTime
operator|::
name|daysTo
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|date
operator|.
name|daysTo
argument_list|(
name|other
operator|.
name|d
operator|->
name|date
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of seconds from this datetime to the \a other     datetime. If the \a other datetime is earlier than this datetime,     the value returned is negative.      Before performing the comparison, the two datetimes are converted     to Qt::UTC to ensure that the result is correct if one of the two     datetimes has daylight saving time (DST) and the other doesn't.      Returns 0 if either datetime is invalid.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 11      \sa addSecs(), daysTo(), QTime::secsTo() */
end_comment
begin_function
DECL|function|secsTo
name|qint64
name|QDateTime
operator|::
name|secsTo
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|other
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|QDate
name|date1
decl_stmt|,
name|date2
decl_stmt|;
name|QTime
name|time1
decl_stmt|,
name|time2
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|date1
argument_list|,
name|time1
argument_list|)
expr_stmt|;
name|other
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|date2
argument_list|,
name|time2
argument_list|)
expr_stmt|;
return|return
operator|(
name|date1
operator|.
name|daysTo
argument_list|(
name|date2
argument_list|)
operator|*
name|SECS_PER_DAY
operator|)
operator|+
name|time1
operator|.
name|secsTo
argument_list|(
name|time2
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of milliseconds from this datetime to the \a other     datetime. If the \a other datetime is earlier than this datetime,     the value returned is negative.      Before performing the comparison, the two datetimes are converted     to Qt::UTC to ensure that the result is correct if one of the two     datetimes has daylight saving time (DST) and the other doesn't.      Returns 0 if either datetime is invalid.      \sa addMSecs(), daysTo(), QTime::msecsTo() */
end_comment
begin_function
DECL|function|msecsTo
name|qint64
name|QDateTime
operator|::
name|msecsTo
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|other
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|QDate
name|selfDate
decl_stmt|;
name|QDate
name|otherDate
decl_stmt|;
name|QTime
name|selfTime
decl_stmt|;
name|QTime
name|otherTime
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|selfDate
argument_list|,
name|selfTime
argument_list|)
expr_stmt|;
name|other
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|otherDate
argument_list|,
name|otherTime
argument_list|)
expr_stmt|;
return|return
operator|(
cast|static_cast
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|selfDate
operator|.
name|daysTo
argument_list|(
name|otherDate
argument_list|)
argument_list|)
operator|*
cast|static_cast
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|MSECS_PER_DAY
argument_list|)
operator|)
operator|+
cast|static_cast
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|selfTime
operator|.
name|msecsTo
argument_list|(
name|otherTime
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDateTime QDateTime::toTimeSpec(Qt::TimeSpec spec) const      Returns a copy of this datetime converted to the given time     \a spec.      If \a spec is Qt::OffsetFromUTC then it is set to Qt::UTC.  To set to a     spec of Qt::OffsetFromUTC use toOffsetFromUtc().      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 16      \sa timeSpec(), toUTC(), toLocalTime() */
end_comment
begin_function
DECL|function|toTimeSpec
name|QDateTime
name|QDateTime
operator|::
name|toTimeSpec
parameter_list|(
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|spec
operator|==
name|Qt
operator|::
name|UTC
operator|||
name|spec
operator|==
name|Qt
operator|::
name|OffsetFromUTC
condition|)
block|{
name|QDate
name|date
decl_stmt|;
name|QTime
name|time
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|QDateTime
name|ret
decl_stmt|;
name|ret
operator|.
name|d
operator|->
name|spec
operator|=
name|d
operator|->
name|getLocal
argument_list|(
name|ret
operator|.
name|d
operator|->
name|date
argument_list|,
name|ret
operator|.
name|d
operator|->
name|time
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2      \fn QDateTime QDateTime::toOffsetFromUtc(int offsetSeconds) const      Returns a copy of this datetime converted to a spec of Qt::OffsetFromUTC     with the given \a offsetSeconds.      If the \a offsetSeconds equals 0 then a UTC datetime will be returned      \sa setOffsetFromUtc(), offsetFromUtc(), toTimeSpec() */
end_comment
begin_function
DECL|function|toOffsetFromUtc
name|QDateTime
name|QDateTime
operator|::
name|toOffsetFromUtc
parameter_list|(
name|int
name|offsetSeconds
parameter_list|)
specifier|const
block|{
name|QDate
name|date
decl_stmt|;
name|QTime
name|time
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|d
operator|->
name|addMSecs
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|offsetSeconds
operator|*
literal|1000
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|OffsetFromUTC
argument_list|,
name|offsetSeconds
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this datetime is equal to the \a other datetime;     otherwise returns false.      \sa operator!=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QDateTime
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|other
operator|.
name|d
operator|->
name|spec
operator|&&
name|d
operator|->
name|m_offsetFromUtc
operator|==
name|other
operator|.
name|d
operator|->
name|m_offsetFromUtc
condition|)
return|return
name|d
operator|->
name|time
operator|==
name|other
operator|.
name|d
operator|->
name|time
operator|&&
name|d
operator|->
name|date
operator|==
name|other
operator|.
name|d
operator|->
name|date
return|;
else|else
block|{
name|QDate
name|date1
decl_stmt|,
name|date2
decl_stmt|;
name|QTime
name|time1
decl_stmt|,
name|time2
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|date1
argument_list|,
name|time1
argument_list|)
expr_stmt|;
name|other
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|date2
argument_list|,
name|time2
argument_list|)
expr_stmt|;
return|return
name|time1
operator|==
name|time2
operator|&&
name|date1
operator|==
name|date2
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn bool QDateTime::operator!=(const QDateTime&other) const      Returns true if this datetime is different from the \a other     datetime; otherwise returns false.      Two datetimes are different if either the date, the time, or the     time zone components are different.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns true if this datetime is earlier than the \a other     datetime; otherwise returns false. */
end_comment
begin_function
DECL|function|operator <
name|bool
name|QDateTime
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|spec
operator|==
name|other
operator|.
name|d
operator|->
name|spec
operator|&&
name|d
operator|->
name|spec
operator|!=
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|date
operator|!=
name|other
operator|.
name|d
operator|->
name|date
condition|)
return|return
name|d
operator|->
name|date
operator|<
name|other
operator|.
name|d
operator|->
name|date
return|;
return|return
name|d
operator|->
name|time
operator|<
name|other
operator|.
name|d
operator|->
name|time
return|;
block|}
else|else
block|{
name|QDate
name|date1
decl_stmt|,
name|date2
decl_stmt|;
name|QTime
name|time1
decl_stmt|,
name|time2
decl_stmt|;
name|d
operator|->
name|getUTC
argument_list|(
name|date1
argument_list|,
name|time1
argument_list|)
expr_stmt|;
name|other
operator|.
name|d
operator|->
name|getUTC
argument_list|(
name|date2
argument_list|,
name|time2
argument_list|)
expr_stmt|;
if|if
condition|(
name|date1
operator|!=
name|date2
condition|)
return|return
name|date1
operator|<
name|date2
return|;
return|return
name|time1
operator|<
name|time2
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn bool QDateTime::operator<=(const QDateTime&other) const      Returns true if this datetime is earlier than or equal to the     \a other datetime; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDateTime::operator>(const QDateTime&other) const      Returns true if this datetime is later than the \a other datetime;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDateTime::operator>=(const QDateTime&other) const      Returns true if this datetime is later than or equal to the     \a other datetime; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::currentDateTime()     Returns the current datetime, as reported by the system clock, in     the local time zone.      \sa currentDateTimeUtc(), QDate::currentDate(), QTime::currentTime(), toTimeSpec() */
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::currentDateTimeUtc()     \since 4.7     Returns the current datetime, as reported by the system clock, in     UTC.      \sa currentDateTime(), QDate::currentDate(), QTime::currentTime(), toTimeSpec() */
end_comment
begin_comment
comment|/*!     \fn qint64 QDateTime::currentMSecsSinceEpoch()     \since 4.7      Returns the number of milliseconds since 1970-01-01T00:00:00 Universal     Coordinated Time. This number is like the POSIX time_t variable, but     expressed in milliseconds instead.      \sa currentDateTime(), currentDateTimeUtc(), toTime_t(), toTimeSpec() */
end_comment
begin_function
DECL|function|msecsFromDecomposed
specifier|static
specifier|inline
name|uint
name|msecsFromDecomposed
parameter_list|(
name|int
name|hour
parameter_list|,
name|int
name|minute
parameter_list|,
name|int
name|sec
parameter_list|,
name|int
name|msec
init|=
literal|0
parameter_list|)
block|{
return|return
name|MSECS_PER_HOUR
operator|*
name|hour
operator|+
name|MSECS_PER_MIN
operator|*
name|minute
operator|+
literal|1000
operator|*
name|sec
operator|+
name|msec
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_function
DECL|function|currentDate
name|QDate
name|QDate
operator|::
name|currentDate
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetLocalTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|currentTime
name|QTime
name|QTime
operator|::
name|currentTime
parameter_list|()
block|{
name|QTime
name|ct
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetLocalTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|ct
operator|.
name|setHMS
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|ct
operator|.
name|startTick
operator|=
name|GetTickCount
argument_list|()
operator|%
name|MSECS_PER_DAY
expr_stmt|;
endif|#
directive|endif
return|return
name|ct
return|;
block|}
end_function
begin_function
DECL|function|currentDateTime
name|QDateTime
name|QDateTime
operator|::
name|currentDateTime
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetLocalTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
expr_stmt|;
name|t
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|d
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|currentDateTimeUtc
name|QDateTime
name|QDateTime
operator|::
name|currentDateTimeUtc
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetSystemTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
expr_stmt|;
name|t
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|d
argument_list|,
name|t
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
return|;
block|}
end_function
begin_function
name|qint64
name|QDateTime
operator|::
name|currentMSecsSinceEpoch
parameter_list|()
name|Q_DECL_NOTHROW
block|{
name|QDate
name|d
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetSystemTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
return|return
name|msecsFromDecomposed
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
operator|+
name|qint64
argument_list|(
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
operator|-
name|julianDayFromDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|Q_INT64_C
argument_list|(
literal|86400000
argument_list|)
return|;
block|}
end_function
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
end_elif
begin_function
DECL|function|currentDate
name|QDate
name|QDate
operator|::
name|currentDate
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
comment|// posix compliant system
name|time_t
name|ltime
decl_stmt|;
name|time
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
name|struct
name|tm
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|tzset
argument_list|()
expr_stmt|;
name|struct
name|tm
name|res
decl_stmt|;
name|t
operator|=
name|localtime_r
argument_list|(
operator|&
name|ltime
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_THREAD&& _POSIX_THREAD_SAFE_FUNCTIONS
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|currentTime
name|QTime
name|QTime
operator|::
name|currentTime
parameter_list|()
block|{
name|QTime
name|ct
decl_stmt|;
comment|// posix compliant system
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|time_t
name|ltime
init|=
name|tv
operator|.
name|tv_sec
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|tzset
argument_list|()
expr_stmt|;
name|struct
name|tm
name|res
decl_stmt|;
name|t
operator|=
name|localtime_r
argument_list|(
operator|&
name|ltime
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_CHECK_PTR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ct
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|,
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
return|return
name|ct
return|;
block|}
end_function
begin_function
DECL|function|currentDateTime
name|QDateTime
name|QDateTime
operator|::
name|currentDateTime
parameter_list|()
block|{
comment|// posix compliant system
comment|// we have milliseconds
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|time_t
name|ltime
init|=
name|tv
operator|.
name|tv_sec
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|tzset
argument_list|()
expr_stmt|;
name|struct
name|tm
name|res
decl_stmt|;
name|t
operator|=
name|localtime_r
argument_list|(
operator|&
name|ltime
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QDateTime
name|dt
decl_stmt|;
name|dt
operator|.
name|d
operator|->
name|time
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|,
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|date
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|spec
operator|=
name|t
operator|->
name|tm_isdst
operator|>
literal|0
condition|?
name|QDateTimePrivate
operator|::
name|LocalDST
else|:
name|t
operator|->
name|tm_isdst
operator|==
literal|0
condition|?
name|QDateTimePrivate
operator|::
name|LocalStandard
else|:
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_function
DECL|function|currentDateTimeUtc
name|QDateTime
name|QDateTime
operator|::
name|currentDateTimeUtc
parameter_list|()
block|{
comment|// posix compliant system
comment|// we have milliseconds
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|time_t
name|ltime
init|=
name|tv
operator|.
name|tv_sec
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|struct
name|tm
name|res
decl_stmt|;
name|t
operator|=
name|gmtime_r
argument_list|(
operator|&
name|ltime
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|gmtime
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QDateTime
name|dt
decl_stmt|;
name|dt
operator|.
name|d
operator|->
name|time
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|,
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|date
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|t
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_function
name|qint64
name|QDateTime
operator|::
name|currentMSecsSinceEpoch
parameter_list|()
name|Q_DECL_NOTHROW
block|{
comment|// posix compliant system
comment|// we have milliseconds
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|qint64
argument_list|(
name|tv
operator|.
name|tv_sec
argument_list|)
operator|*
name|Q_INT64_C
argument_list|(
literal|1000
argument_list|)
operator|+
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
literal|"What system is this?"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \since 4.2    Returns a datetime whose date and time are the number of \a seconds   that have passed since 1970-01-01T00:00:00, Coordinated Universal   Time (Qt::UTC) and converted to Qt::LocalTime.  On systems that do not   support time zones, the time will be set as if local time were Qt::UTC.    \sa toTime_t(), setTime_t() */
end_comment
begin_function
DECL|function|fromTime_t
name|QDateTime
name|QDateTime
operator|::
name|fromTime_t
parameter_list|(
name|uint
name|seconds
parameter_list|)
block|{
return|return
name|fromMSecsSinceEpoch
argument_list|(
operator|(
name|qint64
operator|)
name|seconds
operator|*
literal|1000
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 5.2    Returns a datetime whose date and time are the number of \a seconds   that have passed since 1970-01-01T00:00:00, Coordinated Universal   Time (Qt::UTC) and converted to the given \a spec.    If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.    \sa toTime_t(), setTime_t() */
end_comment
begin_function
DECL|function|fromTime_t
name|QDateTime
name|QDateTime
operator|::
name|fromTime_t
parameter_list|(
name|uint
name|seconds
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|,
name|int
name|offsetSeconds
parameter_list|)
block|{
return|return
name|fromMSecsSinceEpoch
argument_list|(
operator|(
name|qint64
operator|)
name|seconds
operator|*
literal|1000
argument_list|,
name|spec
argument_list|,
name|offsetSeconds
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.7    Returns a datetime whose date and time are the number of milliseconds, \a msecs,   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal   Time (Qt::UTC), and converted to Qt::LocalTime.  On systems that do not   support time zones, the time will be set as if local time were Qt::UTC.    Note that there are possible values for \a msecs that lie outside the valid   range of QDateTime, both negative and positive. The behavior of this   function is undefined for those values.    \sa toTime_t(), setTime_t() */
end_comment
begin_function
DECL|function|fromMSecsSinceEpoch
name|QDateTime
name|QDateTime
operator|::
name|fromMSecsSinceEpoch
parameter_list|(
name|qint64
name|msecs
parameter_list|)
block|{
return|return
name|fromMSecsSinceEpoch
argument_list|(
name|msecs
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 5.2    Returns a datetime whose date and time are the number of milliseconds \a msecs   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal   Time (Qt::UTC) and converted to the given \a spec.    Note that there are possible values for \a msecs that lie outside the valid   range of QDateTime, both negative and positive. The behavior of this   function is undefined for those values.    If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.    \sa fromTime_t() */
end_comment
begin_function
DECL|function|fromMSecsSinceEpoch
name|QDateTime
name|QDateTime
operator|::
name|fromMSecsSinceEpoch
parameter_list|(
name|qint64
name|msecs
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|,
name|int
name|offsetSeconds
parameter_list|)
block|{
name|QDate
name|newDate
init|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|QTime
name|newTime
init|=
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QDateTimePrivate
operator|::
name|addMSecs
argument_list|(
name|newDate
argument_list|,
name|newTime
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|spec
condition|)
block|{
case|case
name|Qt
operator|::
name|UTC
case|:
return|return
name|QDateTime
argument_list|(
name|newDate
argument_list|,
name|newTime
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
return|;
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
name|utcToOffset
argument_list|(
operator|&
name|newDate
argument_list|,
operator|&
name|newTime
argument_list|,
name|offsetSeconds
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|newDate
argument_list|,
name|newTime
argument_list|,
name|Qt
operator|::
name|OffsetFromUTC
argument_list|,
name|offsetSeconds
argument_list|)
return|;
default|default:
name|utcToLocal
argument_list|(
name|newDate
argument_list|,
name|newTime
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|newDate
argument_list|,
name|newTime
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|)
return|;
block|}
block|}
end_function
begin_if
if|#
directive|if
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|2
argument_list|)
end_if
begin_comment
comment|/*!     \since 4.4     \internal     \obsolete      This method was added in 4.4 but never documented as public. It was replaced     in 5.2 with public method setOffsetFromUtc() for consistency with QTimeZone.      This method should never be made public.      \sa setOffsetFromUtc()  */
end_comment
begin_function
DECL|function|setUtcOffset
name|void
name|QDateTime
operator|::
name|setUtcOffset
parameter_list|(
name|int
name|seconds
parameter_list|)
block|{
name|setOffsetFromUtc
argument_list|(
name|seconds
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     \internal     \obsolete      This method was added in 4.4 but never documented as public. It was replaced     in 5.1 with public method offsetFromUTC() for consistency with QTimeZone.      This method should never be made public.      \sa offsetFromUTC() */
end_comment
begin_function
DECL|function|utcOffset
name|int
name|QDateTime
operator|::
name|utcOffset
parameter_list|()
specifier|const
block|{
return|return
name|offsetFromUtc
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_DEPRECATED_SINCE
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function
DECL|function|fromShortMonthName
specifier|static
name|int
name|fromShortMonthName
parameter_list|(
specifier|const
name|QString
modifier|&
name|monthName
parameter_list|)
block|{
comment|// Assume that English monthnames are the default
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QLatin1String
argument_list|(
name|qt_shortMonthNames
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
operator|+
literal|1
return|;
block|}
comment|// If English names can't be found, search the localized ones
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QDate
operator|::
name|shortMonthName
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDateTime QDateTime::fromString(const QString&string, Qt::DateFormat format)      Returns the QDateTime represented by the \a string, using the     \a format given, or an invalid datetime if this is not possible.      Note for Qt::TextDate: It is recommended that you use the     English short month names (e.g. "Jan"). Although localized month     names can also be used, they depend on the user's locale settings. */
end_comment
begin_function
DECL|function|fromString
name|QDateTime
name|QDateTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|f
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|Qt
operator|::
name|ISODate
case|:
block|{
name|QString
name|tmp
init|=
name|s
decl_stmt|;
name|Qt
operator|::
name|TimeSpec
name|ts
init|=
name|Qt
operator|::
name|LocalTime
decl_stmt|;
name|QDate
name|date
init|=
name|QDate
operator|::
name|fromString
argument_list|(
name|tmp
operator|.
name|left
argument_list|(
literal|10
argument_list|)
argument_list|,
name|Qt
operator|::
name|ISODate
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|size
argument_list|()
operator|==
literal|10
condition|)
return|return
name|QDateTime
argument_list|(
name|date
argument_list|)
return|;
name|tmp
operator|=
name|tmp
operator|.
name|mid
argument_list|(
literal|11
argument_list|)
expr_stmt|;
comment|// Recognize UTC specifications
if|if
condition|(
name|tmp
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'Z'
argument_list|)
argument_list|)
condition|)
block|{
name|ts
operator|=
name|Qt
operator|::
name|UTC
expr_stmt|;
name|tmp
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Recognize timezone specifications
name|int
name|offset
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|signIndex
init|=
name|tmp
operator|.
name|indexOf
argument_list|(
name|QRegExp
argument_list|(
name|QStringLiteral
argument_list|(
literal|"[+-]"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|signIndex
operator|>=
literal|0
condition|)
block|{
name|bool
name|ok
decl_stmt|;
name|offset
operator|=
name|fromOffsetString
argument_list|(
name|tmp
operator|.
name|mid
argument_list|(
name|signIndex
argument_list|)
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|tmp
operator|=
name|tmp
operator|.
name|left
argument_list|(
name|signIndex
argument_list|)
expr_stmt|;
name|ts
operator|=
name|Qt
operator|::
name|OffsetFromUTC
expr_stmt|;
block|}
name|bool
name|isMidnight24
init|=
literal|false
decl_stmt|;
comment|// Might be end of day (24:00, including variants), which QTime considers invalid.
name|QTime
name|time
argument_list|(
name|fromStringImpl
argument_list|(
name|tmp
argument_list|,
name|Qt
operator|::
name|ISODate
argument_list|,
name|isMidnight24
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|isMidnight24
condition|)
block|{
comment|// ISO 8601 (section 4.2.3) says that 24:00 is equivalent to 00:00 the next day.
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|ts
argument_list|,
name|offset
argument_list|)
return|;
block|}
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
block|{
name|QDate
name|date
decl_stmt|;
name|QTime
name|time
decl_stmt|;
name|int
name|utcOffset
init|=
literal|0
decl_stmt|;
name|rfcDateImpl
argument_list|(
name|s
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|,
operator|&
name|utcOffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|date
operator|.
name|isValid
argument_list|()
operator|||
operator|!
name|time
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|QDateTime
name|dateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
name|dateTime
operator|.
name|setOffsetFromUtc
argument_list|(
name|utcOffset
argument_list|)
expr_stmt|;
return|return
name|dateTime
return|;
block|}
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|fromString
argument_list|(
name|s
argument_list|,
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dateTimeFormat
argument_list|(
name|f
operator|==
name|Qt
operator|::
name|SystemLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|fromString
argument_list|(
name|s
argument_list|,
name|QLocale
argument_list|()
operator|.
name|dateTimeFormat
argument_list|(
name|f
operator|==
name|Qt
operator|::
name|DefaultLocaleLongDate
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
argument_list|)
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_TEXTDATE
argument_list|)
case|case
name|Qt
operator|::
name|TextDate
case|:
block|{
name|QStringList
name|parts
init|=
name|s
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|parts
operator|.
name|count
argument_list|()
operator|<
literal|5
operator|)
operator|||
operator|(
name|parts
operator|.
name|count
argument_list|()
operator|>
literal|6
operator|)
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
comment|// Accept "Sun Dec 1 13:02:00 1974" and "Sun 1. Dec 13:02:00 1974"
name|int
name|month
init|=
operator|-
literal|1
decl_stmt|,
name|day
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|month
operator|=
name|fromShortMonthName
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|month
operator|!=
operator|-
literal|1
condition|)
block|{
name|day
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|day
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|month
operator|==
operator|-
literal|1
operator|||
name|day
operator|==
operator|-
literal|1
condition|)
block|{
comment|// first variant failed, lets try the other
name|month
operator|=
name|fromShortMonthName
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|month
operator|!=
operator|-
literal|1
condition|)
block|{
name|QString
name|dayStr
init|=
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|dayStr
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
block|{
name|dayStr
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|day
operator|=
name|dayStr
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|day
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|day
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|month
operator|==
operator|-
literal|1
operator|||
name|day
operator|==
operator|-
literal|1
condition|)
block|{
comment|// both variants failed, give up
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|int
name|year
decl_stmt|;
name|QStringList
name|timeParts
init|=
name|parts
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|timeParts
operator|.
name|count
argument_list|()
operator|==
literal|3
operator|)
operator|||
operator|(
name|timeParts
operator|.
name|count
argument_list|()
operator|==
literal|2
operator|)
condition|)
block|{
comment|// Year is after time, e.g. "Sun Dec 1 13:02:00 1974"
name|year
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|4
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
block|}
else|else
block|{
comment|// Year is before time, e.g. "Sun Dec 1 1974 13:02:00"
name|timeParts
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|4
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|timeParts
operator|.
name|count
argument_list|()
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|timeParts
operator|.
name|count
argument_list|()
operator|!=
literal|2
operator|)
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|year
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|int
name|hour
init|=
name|timeParts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|int
name|minute
init|=
name|timeParts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|int
name|second
init|=
literal|0
decl_stmt|;
name|int
name|millisecond
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|timeParts
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|QStringList
name|secondParts
init|=
name|timeParts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|secondParts
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|second
operator|=
name|secondParts
operator|.
name|first
argument_list|()
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
if|if
condition|(
name|secondParts
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|millisecond
operator|=
name|secondParts
operator|.
name|last
argument_list|()
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
block|}
block|}
name|QDate
name|date
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
decl_stmt|;
name|QTime
name|time
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|millisecond
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|==
literal|5
condition|)
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|)
return|;
name|QString
name|tz
init|=
name|parts
operator|.
name|at
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tz
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"GMT"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|tz
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tz
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|offset
init|=
name|fromOffsetString
argument_list|(
name|tz
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|OffsetFromUTC
argument_list|,
name|offset
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
comment|//QT_NO_TEXTDATE
block|}
return|return
name|QDateTime
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDateTime::fromString(const QString&string, const QString&format)      Returns the QDateTime represented by the \a string, using the \a     format given, or an invalid datetime if the string cannot be parsed.      These expressions may be used for the date part of the format string:      \table     \header \li Expression \li Output     \row \li d \li the day as number without a leading zero (1 to 31)     \row \li dd \li the day as number with a leading zero (01 to 31)     \row \li ddd             \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').             Uses QDate::shortDayName().     \row \li dddd             \li the long localized day name (e.g. 'Monday' to 'Sunday').             Uses QDate::longDayName().     \row \li M \li the month as number without a leading zero (1-12)     \row \li MM \li the month as number with a leading zero (01-12)     \row \li MMM             \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').             Uses QDate::shortMonthName().     \row \li MMMM             \li the long localized month name (e.g. 'January' to 'December').             Uses QDate::longMonthName().     \row \li yy \li the year as two digit number (00-99)     \row \li yyyy \li the year as four digit number     \endtable      \note Unlike the other version of this function, day and month names must     be given in the user's local language. It is only possible to use the English     names if the user's language is English.      These expressions may be used for the time part of the format string:      \table     \header \li Expression \li Output     \row \li h             \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh             \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li H             \li the hour without a leading zero (0 to 23, even with AM/PM display)     \row \li HH             \li the hour with a leading zero (00 to 23, even with AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP or A          \li interpret as an AM/PM time. \e AP must be either "AM" or "PM".     \row \li ap or a          \li Interpret as an AM/PM time. \e ap must be either "am" or "pm".     \endtable      All other input characters will be treated as text. Any sequence     of characters that are enclosed in single quotes will also be     treated as text and not be used as an expression.      \snippet code/src_corelib_tools_qdatetime.cpp 12      If the format is not satisfied, an invalid QDateTime is returned.     The expressions that don't have leading zeroes (d, M, h, m, s, z) will be     greedy. This means that they will use two digits even if this will     put them outside the range and/or leave too few digits for other     sections.      \snippet code/src_corelib_tools_qdatetime.cpp 13      This could have meant 1 January 00:30.00 but the M will grab     two digits.      Incorrectly specified fields of the \a string will cause an invalid     QDateTime to be returned. For example, consider the following code,     where the two digit year 12 is read as 1912 (see the table below for all     field defaults); the resulting datetime is invalid because 23 April 1912     was a Tuesday, not a Monday:      \snippet code/src_corelib_tools_qdatetime.cpp 20      The correct code is:      \snippet code/src_corelib_tools_qdatetime.cpp 21      For any field that is not represented in the format, the following     defaults are used:      \table     \header \li Field  \li Default value     \row    \li Year   \li 1900     \row    \li Month  \li 1 (January)     \row    \li Day    \li 1     \row    \li Hour   \li 0     \row    \li Minute \li 0     \row    \li Second \li 0     \endtable      For example:      \snippet code/src_corelib_tools_qdatetime.cpp 14      \sa QDate::fromString(), QTime::fromString(), QDate::toString(),     QDateTime::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|fromString
name|QDateTime
name|QDateTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QTime
name|time
decl_stmt|;
name|QDate
name|date
decl_stmt|;
name|QDateTimeParser
name|dt
argument_list|(
name|QVariant
operator|::
name|DateTime
argument_list|,
name|QDateTimeParser
operator|::
name|FromString
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|parseFormat
argument_list|(
name|format
argument_list|)
operator|&&
name|dt
operator|.
name|fromString
argument_list|(
name|string
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|)
condition|)
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|QDateTime
argument_list|(
name|QDate
argument_list|()
argument_list|,
name|QTime
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::toLocalTime() const      Returns a datetime containing the date and time information in     this datetime, but specified using the Qt::LocalTime definition.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 17      \sa toTimeSpec() */
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::toUTC() const      Returns a datetime containing the date and time information in     this datetime, but specified using the Qt::UTC definition.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 18      \sa toTimeSpec() */
end_comment
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|detach
name|void
name|QDateTime
operator|::
name|detach
parameter_list|()
block|{
name|d
operator|.
name|detach
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   Date/time stream functions  *****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \relates QDate      Writes the \a date to stream \a out.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
block|{
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_5_0
condition|)
return|return
name|out
operator|<<
name|quint32
argument_list|(
name|date
operator|.
name|jd
argument_list|)
return|;
else|else
return|return
name|out
operator|<<
name|qint64
argument_list|(
name|date
operator|.
name|jd
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QDate      Reads a date from stream \a in into the \a date.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QDate
modifier|&
name|date
parameter_list|)
block|{
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_5_0
condition|)
block|{
name|quint32
name|jd
decl_stmt|;
name|in
operator|>>
name|jd
expr_stmt|;
comment|// Older versions consider 0 an invalid jd.
name|date
operator|.
name|jd
operator|=
operator|(
name|jd
operator|!=
literal|0
condition|?
name|jd
else|:
name|QDate
operator|::
name|nullJd
argument_list|()
operator|)
expr_stmt|;
block|}
else|else
block|{
name|qint64
name|jd
decl_stmt|;
name|in
operator|>>
name|jd
expr_stmt|;
name|date
operator|.
name|jd
operator|=
name|jd
expr_stmt|;
block|}
return|return
name|in
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTime      Writes \a time to stream \a out.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
return|return
name|out
operator|<<
name|quint32
argument_list|(
name|time
operator|.
name|mds
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTime      Reads a time from stream \a in into the given \a time.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|quint32
name|ds
decl_stmt|;
name|in
operator|>>
name|ds
expr_stmt|;
name|time
operator|.
name|mds
operator|=
name|int
argument_list|(
name|ds
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QDateTime      Writes \a dateTime to the \a out stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|dateTime
parameter_list|)
block|{
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|==
name|QDataStream
operator|::
name|Qt_5_0
condition|)
block|{
if|if
condition|(
name|dateTime
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// This approach is wrong and should not be used again; it breaks
comment|// the guarantee that a deserialised local datetime is the same time
comment|// of day, regardless of which timezone it was serialised in.
name|QDateTime
name|asUTC
init|=
name|dateTime
operator|.
name|toUTC
argument_list|()
decl_stmt|;
name|out
operator|<<
name|asUTC
operator|.
name|d
operator|->
name|date
operator|<<
name|asUTC
operator|.
name|d
operator|->
name|time
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
name|dateTime
operator|.
name|d
operator|->
name|date
operator|<<
name|dateTime
operator|.
name|d
operator|->
name|time
expr_stmt|;
block|}
name|out
operator|<<
operator|(
name|qint8
operator|)
name|dateTime
operator|.
name|timeSpec
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|out
operator|<<
name|dateTime
operator|.
name|d
operator|->
name|date
operator|<<
name|dateTime
operator|.
name|d
operator|->
name|time
expr_stmt|;
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_0
condition|)
name|out
operator|<<
operator|(
name|qint8
operator|)
name|dateTime
operator|.
name|d
operator|->
name|spec
expr_stmt|;
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_5_2
operator|&&
name|dateTime
operator|.
name|d
operator|->
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
block|{
name|out
operator|<<
name|qint32
argument_list|(
name|dateTime
operator|.
name|offsetFromUtc
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QDateTime      Reads a datetime from the stream \a in into \a dateTime.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QDateTime
modifier|&
name|dateTime
parameter_list|)
block|{
name|dateTime
operator|.
name|detach
argument_list|()
expr_stmt|;
name|in
operator|>>
name|dateTime
operator|.
name|d
operator|->
name|date
operator|>>
name|dateTime
operator|.
name|d
operator|->
name|time
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|==
name|QDataStream
operator|::
name|Qt_5_0
condition|)
block|{
name|qint8
name|ts
init|=
literal|0
decl_stmt|;
name|in
operator|>>
name|ts
expr_stmt|;
if|if
condition|(
name|dateTime
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// We incorrectly stored the datetime as UTC in Qt_5_0.
name|dateTime
operator|.
name|d
operator|->
name|spec
operator|=
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
name|dateTime
operator|=
name|dateTime
operator|.
name|toTimeSpec
argument_list|(
cast|static_cast
argument_list|<
name|Qt
operator|::
name|TimeSpec
argument_list|>
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|qint8
name|ts
init|=
operator|(
name|qint8
operator|)
name|QDateTimePrivate
operator|::
name|LocalUnknown
decl_stmt|;
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_0
condition|)
name|in
operator|>>
name|ts
expr_stmt|;
name|qint32
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_5_2
operator|&&
name|ts
operator|==
name|qint8
argument_list|(
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
argument_list|)
condition|)
name|in
operator|>>
name|offset
expr_stmt|;
name|dateTime
operator|.
name|d
operator|->
name|spec
operator|=
operator|(
name|QDateTimePrivate
operator|::
name|Spec
operator|)
name|ts
expr_stmt|;
name|dateTime
operator|.
name|d
operator|->
name|m_offsetFromUtc
operator|=
name|offset
expr_stmt|;
block|}
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|// checks if there is an unquoted 'AP' or 'ap' in the string
end_comment
begin_function
DECL|function|hasUnquotedAP
specifier|static
name|bool
name|hasUnquotedAP
parameter_list|(
specifier|const
name|QString
modifier|&
name|f
parameter_list|)
block|{
specifier|const
name|QLatin1Char
name|quote
argument_list|(
literal|'\''
argument_list|)
decl_stmt|;
name|bool
name|inquote
init|=
literal|false
decl_stmt|;
specifier|const
name|int
name|max
init|=
name|f
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|quote
condition|)
block|{
name|inquote
operator|=
operator|!
name|inquote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|inquote
operator|&&
name|f
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toUpper
argument_list|()
operator|==
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*****************************************************************************   Some static function used by QDate, QTime and QDateTime *****************************************************************************/
end_comment
begin_comment
comment|// Replaces tokens by their value. See QDateTime::toString() for a list of valid tokens
end_comment
begin_function
DECL|function|getFmtString
specifier|static
name|QString
name|getFmtString
parameter_list|(
specifier|const
name|QString
modifier|&
name|f
parameter_list|,
specifier|const
name|QTime
modifier|*
name|dt
init|=
literal|0
parameter_list|,
specifier|const
name|QDate
modifier|*
name|dd
init|=
literal|0
parameter_list|,
name|bool
name|am_pm
init|=
literal|false
parameter_list|)
block|{
if|if
condition|(
name|f
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|buf
init|=
name|f
decl_stmt|;
name|int
name|removed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"hh"
argument_list|)
argument_list|)
operator|||
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"HH"
argument_list|)
argument_list|)
condition|)
block|{
specifier|const
name|bool
name|hour12
init|=
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'h'
argument_list|)
operator|&&
name|am_pm
decl_stmt|;
if|if
condition|(
name|hour12
operator|&&
name|dt
operator|->
name|hour
argument_list|()
operator|>
literal|12
condition|)
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|hour
argument_list|()
operator|-
literal|12
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hour12
operator|&&
name|dt
operator|->
name|hour
argument_list|()
operator|==
literal|0
condition|)
name|buf
operator|=
name|QLatin1String
argument_list|(
literal|"12"
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|hour
argument_list|()
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'h'
argument_list|)
operator|||
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'H'
argument_list|)
condition|)
block|{
specifier|const
name|bool
name|hour12
init|=
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'h'
argument_list|)
operator|&&
name|am_pm
decl_stmt|;
if|if
condition|(
name|hour12
operator|&&
name|dt
operator|->
name|hour
argument_list|()
operator|>
literal|12
condition|)
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|hour
argument_list|()
operator|-
literal|12
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hour12
operator|&&
name|dt
operator|->
name|hour
argument_list|()
operator|==
literal|0
condition|)
name|buf
operator|=
name|QLatin1String
argument_list|(
literal|"12"
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|hour
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"mm"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|minute
argument_list|()
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
operator|(
name|QLatin1Char
argument_list|(
literal|'m'
argument_list|)
operator|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|minute
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"ss"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|second
argument_list|()
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'s'
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|second
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"zzz"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|msec
argument_list|()
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|3
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'z'
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dt
operator|->
name|msec
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toUpper
argument_list|()
operator|==
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
condition|)
block|{
specifier|const
name|bool
name|upper
init|=
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'A'
argument_list|)
decl_stmt|;
name|buf
operator|=
name|dt
operator|->
name|hour
argument_list|()
operator|<
literal|12
condition|?
name|QLatin1String
argument_list|(
literal|"am"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"pm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|upper
condition|)
name|buf
operator|=
name|buf
operator|.
name|toUpper
argument_list|()
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|&&
name|f
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toUpper
argument_list|()
operator|==
name|QLatin1Char
argument_list|(
literal|'P'
argument_list|)
operator|&&
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|isUpper
argument_list|()
operator|==
name|f
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|isUpper
argument_list|()
condition|)
block|{
name|removed
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|removed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dd
condition|)
block|{
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"dddd"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|dd
operator|->
name|longDayName
argument_list|(
name|dd
operator|->
name|dayOfWeek
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"ddd"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|dd
operator|->
name|shortDayName
argument_list|(
name|dd
operator|->
name|dayOfWeek
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"dd"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dd
operator|->
name|day
argument_list|()
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'d'
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dd
operator|->
name|day
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"MMMM"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|dd
operator|->
name|longMonthName
argument_list|(
name|dd
operator|->
name|month
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"MMM"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|dd
operator|->
name|shortMonthName
argument_list|(
name|dd
operator|->
name|month
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"MM"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dd
operator|->
name|month
argument_list|()
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'M'
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dd
operator|->
name|month
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"yyyy"
argument_list|)
argument_list|)
condition|)
block|{
specifier|const
name|int
name|year
init|=
name|dd
operator|->
name|year
argument_list|()
decl_stmt|;
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|qAbs
argument_list|(
name|year
argument_list|)
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|4
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|year
operator|>
literal|0
condition|)
name|removed
operator|=
literal|4
expr_stmt|;
else|else
block|{
name|buf
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|5
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"yy"
argument_list|)
argument_list|)
condition|)
block|{
name|buf
operator|=
name|QString
operator|::
name|number
argument_list|(
name|dd
operator|->
name|year
argument_list|()
argument_list|)
operator|.
name|right
argument_list|(
literal|2
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|removed
operator|==
literal|0
operator|||
name|removed
operator|>=
name|f
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|buf
return|;
block|}
return|return
name|buf
operator|+
name|getFmtString
argument_list|(
name|f
operator|.
name|mid
argument_list|(
name|removed
argument_list|)
argument_list|,
name|dt
argument_list|,
name|dd
argument_list|,
name|am_pm
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// Parses the format string and uses getFmtString to get the values for the tokens. Ret
end_comment
begin_function
DECL|function|fmtDateTime
specifier|static
name|QString
name|fmtDateTime
parameter_list|(
specifier|const
name|QString
modifier|&
name|f
parameter_list|,
specifier|const
name|QTime
modifier|*
name|dt
parameter_list|,
specifier|const
name|QDate
modifier|*
name|dd
parameter_list|)
block|{
name|QString
name|buf
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|buf
return|;
if|if
condition|(
name|dt
operator|&&
operator|!
name|dt
operator|->
name|isValid
argument_list|()
condition|)
return|return
name|buf
return|;
if|if
condition|(
name|dd
operator|&&
operator|!
name|dd
operator|->
name|isValid
argument_list|()
condition|)
return|return
name|buf
return|;
specifier|const
name|bool
name|ap
init|=
name|hasUnquotedAP
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|QString
name|frm
decl_stmt|;
name|uint
name|status
init|=
literal|'0'
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
name|f
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QChar
name|c
init|=
name|f
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|uint
name|cc
init|=
name|c
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|cc
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|cc
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|f
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|unicode
argument_list|()
operator|==
name|cc
condition|)
name|buf
operator|+=
name|c
expr_stmt|;
name|status
operator|=
literal|'0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|frm
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|buf
operator|+=
name|getFmtString
argument_list|(
name|frm
argument_list|,
name|dt
argument_list|,
name|dd
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|frm
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|status
operator|=
name|cc
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
operator|==
literal|'\''
condition|)
block|{
name|buf
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|status
condition|)
block|{
if|if
condition|(
name|ap
operator|&&
operator|(
name|cc
operator|==
literal|'P'
operator|||
name|cc
operator|==
literal|'p'
operator|)
condition|)
name|status
operator|=
literal|'0'
expr_stmt|;
name|frm
operator|+=
name|c
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|+=
name|getFmtString
argument_list|(
name|frm
argument_list|,
name|dt
argument_list|,
name|dd
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|frm
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|'h'
operator|||
name|cc
operator|==
literal|'m'
operator|||
name|cc
operator|==
literal|'H'
operator|||
name|cc
operator|==
literal|'s'
operator|||
name|cc
operator|==
literal|'z'
condition|)
block|{
name|status
operator|=
name|cc
expr_stmt|;
name|frm
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
literal|'d'
operator|||
name|cc
operator|==
literal|'M'
operator|||
name|cc
operator|==
literal|'y'
condition|)
block|{
name|status
operator|=
name|cc
expr_stmt|;
name|frm
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|&&
name|cc
operator|==
literal|'A'
condition|)
block|{
name|status
operator|=
literal|'P'
expr_stmt|;
name|frm
operator|+=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|&&
name|cc
operator|==
literal|'a'
condition|)
block|{
name|status
operator|=
literal|'p'
expr_stmt|;
name|frm
operator|+=
name|c
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|+=
name|c
expr_stmt|;
name|status
operator|=
literal|'0'
expr_stmt|;
block|}
block|}
block|}
name|buf
operator|+=
name|getFmtString
argument_list|(
name|frm
argument_list|,
name|dt
argument_list|,
name|dd
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function
begin_function
DECL|function|rfcDateImpl
specifier|static
name|void
name|rfcDateImpl
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|QDate
modifier|*
name|dd
parameter_list|,
name|QTime
modifier|*
name|dt
parameter_list|,
name|int
modifier|*
name|utcOffset
parameter_list|)
block|{
name|int
name|day
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|month
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|year
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hour
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|min
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|sec
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hourOffset
init|=
literal|0
decl_stmt|;
name|int
name|minOffset
init|=
literal|0
decl_stmt|;
name|bool
name|positiveOffset
init|=
literal|false
decl_stmt|;
comment|// Matches "Wdy, DD Mon YYYY HH:MM:SS hhmm" (Wdy, being optional)
name|QRegExp
name|rex
argument_list|(
name|QStringLiteral
argument_list|(
literal|"^(?:[A-Z][a-z]+,)?[ \\t]*(\\d{1,2})[ \\t]+([A-Z][a-z]+)[ \\t]+(\\d\\d\\d\\d)(?:[ \\t]+(\\d\\d):(\\d\\d)(?::(\\d\\d))?)?[ \\t]*(?:([+-])(\\d\\d)(\\d\\d))?"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|indexOf
argument_list|(
name|rex
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dd
condition|)
block|{
name|day
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|month
operator|=
name|qt_monthNumberFromShortName
argument_list|(
name|rex
operator|.
name|cap
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|year
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|3
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
operator|!
name|rex
operator|.
name|cap
argument_list|(
literal|4
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|hour
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|4
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|min
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|5
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|sec
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|6
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
name|positiveOffset
operator|=
operator|(
name|rex
operator|.
name|cap
argument_list|(
literal|7
argument_list|)
operator|==
name|QStringLiteral
argument_list|(
literal|"+"
argument_list|)
operator|)
expr_stmt|;
name|hourOffset
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|8
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|minOffset
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|9
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|utcOffset
condition|)
operator|*
name|utcOffset
operator|=
operator|(
operator|(
name|hourOffset
operator|*
literal|60
operator|+
name|minOffset
operator|)
operator|*
operator|(
name|positiveOffset
condition|?
literal|60
else|:
operator|-
literal|60
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Matches "Wdy Mon DD HH:MM:SS YYYY"
name|QRegExp
name|rex
argument_list|(
name|QStringLiteral
argument_list|(
literal|"^[A-Z][a-z]+[ \\t]+([A-Z][a-z]+)[ \\t]+(\\d\\d)(?:[ \\t]+(\\d\\d):(\\d\\d):(\\d\\d))?[ \\t]+(\\d\\d\\d\\d)[ \\t]*(?:([+-])(\\d\\d)(\\d\\d))?"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|indexOf
argument_list|(
name|rex
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dd
condition|)
block|{
name|month
operator|=
name|qt_monthNumberFromShortName
argument_list|(
name|rex
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|day
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|year
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|6
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
operator|!
name|rex
operator|.
name|cap
argument_list|(
literal|3
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|hour
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|3
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|min
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|4
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|sec
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|5
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
name|positiveOffset
operator|=
operator|(
name|rex
operator|.
name|cap
argument_list|(
literal|7
argument_list|)
operator|==
name|QStringLiteral
argument_list|(
literal|"+"
argument_list|)
operator|)
expr_stmt|;
name|hourOffset
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|8
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|minOffset
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|9
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|utcOffset
condition|)
operator|*
name|utcOffset
operator|=
operator|(
operator|(
name|hourOffset
operator|*
literal|60
operator|+
name|minOffset
operator|)
operator|*
operator|(
name|positiveOffset
condition|?
literal|60
else|:
operator|-
literal|60
operator|)
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dd
condition|)
operator|*
name|dd
operator|=
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt
condition|)
operator|*
name|dt
operator|=
name|QTime
argument_list|(
name|hour
argument_list|,
name|min
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_decl_stmt
DECL|variable|LowerYear
specifier|static
specifier|const
name|int
name|LowerYear
init|=
literal|1980
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|variable|LowerYear
specifier|static
specifier|const
name|int
name|LowerYear
init|=
literal|1970
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|UpperYear
specifier|static
specifier|const
name|int
name|UpperYear
init|=
literal|2037
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|adjustDate
specifier|static
name|QDate
name|adjustDate
parameter_list|(
name|QDate
name|date
parameter_list|)
block|{
name|QDate
name|lowerLimit
argument_list|(
name|LowerYear
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|QDate
name|upperLimit
argument_list|(
name|UpperYear
argument_list|,
literal|12
argument_list|,
literal|30
argument_list|)
decl_stmt|;
if|if
condition|(
name|date
operator|>
name|lowerLimit
operator|&&
name|date
operator|<
name|upperLimit
condition|)
return|return
name|date
return|;
name|int
name|month
init|=
name|date
operator|.
name|month
argument_list|()
decl_stmt|;
name|int
name|day
init|=
name|date
operator|.
name|day
argument_list|()
decl_stmt|;
comment|// neither 1970 nor 2037 are leap years, so make sure date isn't Feb 29
if|if
condition|(
name|month
operator|==
literal|2
operator|&&
name|day
operator|==
literal|29
condition|)
operator|--
name|day
expr_stmt|;
if|if
condition|(
name|date
operator|<
name|lowerLimit
condition|)
name|date
operator|.
name|setDate
argument_list|(
name|LowerYear
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
else|else
name|date
operator|.
name|setDate
argument_list|(
name|UpperYear
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
return|return
name|date
return|;
block|}
end_function
begin_comment
comment|// Convert passed in UTC datetime into LocalTime and return spec
end_comment
begin_function
DECL|function|utcToLocal
specifier|static
name|QDateTimePrivate
operator|::
name|Spec
name|utcToLocal
parameter_list|(
name|QDate
modifier|&
name|date
parameter_list|,
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|QDate
name|fakeDate
init|=
name|adjustDate
argument_list|(
name|date
argument_list|)
decl_stmt|;
comment|// won't overflow because of fakeDate
name|time_t
name|secsSince1Jan1970UTC
init|=
name|toMSecsSinceEpoch_helper
argument_list|(
name|fakeDate
operator|.
name|toJulianDay
argument_list|()
argument_list|,
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|msecsTo
argument_list|(
name|time
argument_list|)
argument_list|)
operator|/
literal|1000
decl_stmt|;
name|tm
modifier|*
name|brokenDown
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|tm
name|res
decl_stmt|;
name|FILETIME
name|utcTime
init|=
name|time_tToFt
argument_list|(
name|secsSince1Jan1970UTC
argument_list|)
decl_stmt|;
name|FILETIME
name|resultTime
decl_stmt|;
name|FileTimeToLocalFileTime
argument_list|(
operator|&
name|utcTime
argument_list|,
operator|&
name|resultTime
argument_list|)
expr_stmt|;
name|SYSTEMTIME
name|sysTime
decl_stmt|;
name|FileTimeToSystemTime
argument_list|(
operator|&
name|resultTime
argument_list|,
operator|&
name|sysTime
argument_list|)
expr_stmt|;
name|res
operator|.
name|tm_sec
operator|=
name|sysTime
operator|.
name|wSecond
expr_stmt|;
name|res
operator|.
name|tm_min
operator|=
name|sysTime
operator|.
name|wMinute
expr_stmt|;
name|res
operator|.
name|tm_hour
operator|=
name|sysTime
operator|.
name|wHour
expr_stmt|;
name|res
operator|.
name|tm_mday
operator|=
name|sysTime
operator|.
name|wDay
expr_stmt|;
name|res
operator|.
name|tm_mon
operator|=
name|sysTime
operator|.
name|wMonth
operator|-
literal|1
expr_stmt|;
name|res
operator|.
name|tm_year
operator|=
name|sysTime
operator|.
name|wYear
operator|-
literal|1900
expr_stmt|;
name|brokenDown
operator|=
operator|&
name|res
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of localtime() where available
name|tzset
argument_list|()
expr_stmt|;
name|tm
name|res
decl_stmt|;
name|brokenDown
operator|=
name|localtime_r
argument_list|(
operator|&
name|secsSince1Jan1970UTC
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
name|tm
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|_localtime64_s
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|secsSince1Jan1970UTC
argument_list|)
condition|)
name|brokenDown
operator|=
operator|&
name|res
expr_stmt|;
else|#
directive|else
name|brokenDown
operator|=
name|localtime
argument_list|(
operator|&
name|secsSince1Jan1970UTC
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|brokenDown
condition|)
block|{
name|date
operator|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|time
operator|=
name|QTime
argument_list|()
expr_stmt|;
return|return
name|QDateTimePrivate
operator|::
name|LocalUnknown
return|;
block|}
else|else
block|{
name|qint64
name|deltaDays
init|=
name|fakeDate
operator|.
name|daysTo
argument_list|(
name|date
argument_list|)
decl_stmt|;
name|date
operator|=
name|QDate
argument_list|(
name|brokenDown
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|brokenDown
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|brokenDown
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|time
operator|=
name|QTime
argument_list|(
name|brokenDown
operator|->
name|tm_hour
argument_list|,
name|brokenDown
operator|->
name|tm_min
argument_list|,
name|brokenDown
operator|->
name|tm_sec
argument_list|,
name|time
operator|.
name|msec
argument_list|()
argument_list|)
expr_stmt|;
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
name|deltaDays
argument_list|)
expr_stmt|;
if|if
condition|(
name|brokenDown
operator|->
name|tm_isdst
operator|>
literal|0
condition|)
return|return
name|QDateTimePrivate
operator|::
name|LocalDST
return|;
elseif|else
if|if
condition|(
name|brokenDown
operator|->
name|tm_isdst
operator|<
literal|0
condition|)
return|return
name|QDateTimePrivate
operator|::
name|LocalUnknown
return|;
else|else
return|return
name|QDateTimePrivate
operator|::
name|LocalStandard
return|;
block|}
block|}
end_function
begin_comment
comment|// Convert passed in LocalTime datetime into UTC
end_comment
begin_function
DECL|function|localToUtc
specifier|static
name|void
name|localToUtc
parameter_list|(
name|QDate
modifier|&
name|date
parameter_list|,
name|QTime
modifier|&
name|time
parameter_list|,
name|int
name|isdst
parameter_list|)
block|{
if|if
condition|(
operator|!
name|date
operator|.
name|isValid
argument_list|()
condition|)
return|return;
name|QDate
name|fakeDate
init|=
name|adjustDate
argument_list|(
name|date
argument_list|)
decl_stmt|;
name|tm
name|localTM
decl_stmt|;
name|localTM
operator|.
name|tm_sec
operator|=
name|time
operator|.
name|second
argument_list|()
expr_stmt|;
name|localTM
operator|.
name|tm_min
operator|=
name|time
operator|.
name|minute
argument_list|()
expr_stmt|;
name|localTM
operator|.
name|tm_hour
operator|=
name|time
operator|.
name|hour
argument_list|()
expr_stmt|;
name|localTM
operator|.
name|tm_mday
operator|=
name|fakeDate
operator|.
name|day
argument_list|()
expr_stmt|;
name|localTM
operator|.
name|tm_mon
operator|=
name|fakeDate
operator|.
name|month
argument_list|()
operator|-
literal|1
expr_stmt|;
name|localTM
operator|.
name|tm_year
operator|=
name|fakeDate
operator|.
name|year
argument_list|()
operator|-
literal|1900
expr_stmt|;
name|localTM
operator|.
name|tm_isdst
operator|=
operator|(
name|int
operator|)
name|isdst
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|time_t
name|secsSince1Jan1970UTC
init|=
operator|(
name|toMSecsSinceEpoch_helper
argument_list|(
name|fakeDate
operator|.
name|toJulianDay
argument_list|()
argument_list|,
name|QTime
argument_list|()
operator|.
name|msecsTo
argument_list|(
name|time
argument_list|)
argument_list|)
operator|/
literal|1000
operator|)
decl_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|_tzset
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|time_t
name|secsSince1Jan1970UTC
init|=
name|mktime
argument_list|(
operator|&
name|localTM
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_QNX
comment|//mktime sometimes fails on QNX. Following workaround converts the date and time then manually
if|if
condition|(
name|secsSince1Jan1970UTC
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
name|QDateTime
name|tempTime
init|=
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
empty_stmt|;
name|tempTime
operator|=
name|tempTime
operator|.
name|addMSecs
argument_list|(
name|timezone
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|date
operator|=
name|tempTime
operator|.
name|date
argument_list|()
expr_stmt|;
name|time
operator|=
name|tempTime
operator|.
name|time
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|tm
modifier|*
name|brokenDown
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|tm
name|res
decl_stmt|;
name|FILETIME
name|localTime
init|=
name|time_tToFt
argument_list|(
name|secsSince1Jan1970UTC
argument_list|)
decl_stmt|;
name|SYSTEMTIME
name|sysTime
decl_stmt|;
name|FileTimeToSystemTime
argument_list|(
operator|&
name|localTime
argument_list|,
operator|&
name|sysTime
argument_list|)
expr_stmt|;
name|FILETIME
name|resultTime
decl_stmt|;
name|LocalFileTimeToFileTime
argument_list|(
operator|&
name|localTime
argument_list|,
operator|&
name|resultTime
argument_list|)
expr_stmt|;
name|FileTimeToSystemTime
argument_list|(
operator|&
name|resultTime
argument_list|,
operator|&
name|sysTime
argument_list|)
expr_stmt|;
name|res
operator|.
name|tm_sec
operator|=
name|sysTime
operator|.
name|wSecond
expr_stmt|;
name|res
operator|.
name|tm_min
operator|=
name|sysTime
operator|.
name|wMinute
expr_stmt|;
name|res
operator|.
name|tm_hour
operator|=
name|sysTime
operator|.
name|wHour
expr_stmt|;
name|res
operator|.
name|tm_mday
operator|=
name|sysTime
operator|.
name|wDay
expr_stmt|;
name|res
operator|.
name|tm_mon
operator|=
name|sysTime
operator|.
name|wMonth
operator|-
literal|1
expr_stmt|;
name|res
operator|.
name|tm_year
operator|=
name|sysTime
operator|.
name|wYear
operator|-
literal|1900
expr_stmt|;
name|res
operator|.
name|tm_isdst
operator|=
operator|(
name|int
operator|)
name|isdst
expr_stmt|;
name|brokenDown
operator|=
operator|&
name|res
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// use the reentrant version of gmtime() where available
name|tm
name|res
decl_stmt|;
name|brokenDown
operator|=
name|gmtime_r
argument_list|(
operator|&
name|secsSince1Jan1970UTC
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
name|tm
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|_gmtime64_s
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|secsSince1Jan1970UTC
argument_list|)
condition|)
name|brokenDown
operator|=
operator|&
name|res
expr_stmt|;
else|#
directive|else
name|brokenDown
operator|=
name|gmtime
argument_list|(
operator|&
name|secsSince1Jan1970UTC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// !QT_NO_THREAD&& _POSIX_THREAD_SAFE_FUNCTIONS
if|if
condition|(
operator|!
name|brokenDown
condition|)
block|{
name|date
operator|=
name|QDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|time
operator|=
name|QTime
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|qint64
name|deltaDays
init|=
name|fakeDate
operator|.
name|daysTo
argument_list|(
name|date
argument_list|)
decl_stmt|;
name|date
operator|=
name|QDate
argument_list|(
name|brokenDown
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|brokenDown
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|brokenDown
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|time
operator|=
name|QTime
argument_list|(
name|brokenDown
operator|->
name|tm_hour
argument_list|,
name|brokenDown
operator|->
name|tm_min
argument_list|,
name|brokenDown
operator|->
name|tm_sec
argument_list|,
name|time
operator|.
name|msec
argument_list|()
argument_list|)
expr_stmt|;
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
name|deltaDays
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Convert passed in OffsetFromUTC datetime and offset into UTC
end_comment
begin_function
DECL|function|offsetToUtc
specifier|static
name|void
name|offsetToUtc
parameter_list|(
name|QDate
modifier|*
name|outDate
parameter_list|,
name|QTime
modifier|*
name|outTime
parameter_list|,
name|qint32
name|offset
parameter_list|)
block|{
name|QDateTimePrivate
operator|::
name|addMSecs
argument_list|(
operator|*
name|outDate
argument_list|,
operator|*
name|outTime
argument_list|,
operator|-
operator|(
name|qint64
argument_list|(
name|offset
argument_list|)
operator|*
literal|1000
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Convert passed in UTC datetime and offset into OffsetFromUTC
end_comment
begin_function
DECL|function|utcToOffset
specifier|static
name|void
name|utcToOffset
parameter_list|(
name|QDate
modifier|*
name|outDate
parameter_list|,
name|QTime
modifier|*
name|outTime
parameter_list|,
name|qint32
name|offset
parameter_list|)
block|{
name|QDateTimePrivate
operator|::
name|addMSecs
argument_list|(
operator|*
name|outDate
argument_list|,
operator|*
name|outTime
argument_list|,
operator|(
name|qint64
argument_list|(
name|offset
argument_list|)
operator|*
literal|1000
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Get current date/time in LocalTime and put result in outDate and outTime
end_comment
begin_function
DECL|function|getLocal
name|QDateTimePrivate
operator|::
name|Spec
name|QDateTimePrivate
operator|::
name|getLocal
parameter_list|(
name|QDate
modifier|&
name|outDate
parameter_list|,
name|QTime
modifier|&
name|outTime
parameter_list|)
specifier|const
block|{
name|outDate
operator|=
name|date
expr_stmt|;
name|outTime
operator|=
name|time
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|UTC
condition|)
return|return
name|utcToLocal
argument_list|(
name|outDate
argument_list|,
name|outTime
argument_list|)
return|;
if|if
condition|(
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
block|{
name|offsetToUtc
argument_list|(
operator|&
name|outDate
argument_list|,
operator|&
name|outTime
argument_list|,
name|m_offsetFromUtc
argument_list|)
expr_stmt|;
return|return
name|utcToLocal
argument_list|(
name|outDate
argument_list|,
name|outTime
argument_list|)
return|;
block|}
return|return
name|spec
return|;
block|}
end_function
begin_comment
comment|// Get current date/time in UTC and put result in outDate and outTime
end_comment
begin_function
DECL|function|getUTC
name|void
name|QDateTimePrivate
operator|::
name|getUTC
parameter_list|(
name|QDate
modifier|&
name|outDate
parameter_list|,
name|QTime
modifier|&
name|outTime
parameter_list|)
specifier|const
block|{
name|outDate
operator|=
name|date
expr_stmt|;
name|outTime
operator|=
name|time
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
condition|)
name|offsetToUtc
argument_list|(
operator|&
name|outDate
argument_list|,
operator|&
name|outTime
argument_list|,
name|m_offsetFromUtc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|spec
operator|!=
name|QDateTimePrivate
operator|::
name|UTC
condition|)
name|localToUtc
argument_list|(
name|outDate
argument_list|,
name|outTime
argument_list|,
operator|(
name|int
operator|)
name|spec
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_DATESTRING
argument_list|)
end_if
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QDate("
operator|<<
name|date
operator|.
name|toString
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QTime("
operator|<<
name|time
operator|.
name|toString
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|date
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QDateTime("
operator|<<
name|date
operator|.
name|toString
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \fn uint qHash(const QDateTime&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_function
DECL|function|qHash
name|uint
name|qHash
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
block|{
comment|// Use to toMSecsSinceEpoch instead of individual qHash functions for
comment|// QDate/QTime/spec/offset because QDateTime::operator== converts both arguments
comment|// to the same timezone. If we don't, qHash would return different hashes for
comment|// two QDateTimes that are equivalent once converted to the same timezone.
return|return
name|qHash
argument_list|(
name|key
operator|.
name|toMSecsSinceEpoch
argument_list|()
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn uint qHash(const QDate&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_function
name|uint
name|qHash
parameter_list|(
specifier|const
name|QDate
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|qHash
argument_list|(
name|key
operator|.
name|toJulianDay
argument_list|()
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn uint qHash(const QTime&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_function
name|uint
name|qHash
parameter_list|(
specifier|const
name|QTime
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|qHash
argument_list|(
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|.
name|msecsTo
argument_list|(
name|key
argument_list|)
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_comment
comment|/*!   \internal   Gets the digit from a datetime. E.g.    QDateTime var(QDate(2004, 02, 02));   int digit = getDigit(var, Year);   // digit = 2004 */
end_comment
begin_function
DECL|function|getDigit
name|int
name|QDateTimeParser
operator|::
name|getDigit
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|t
parameter_list|,
name|int
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|sectionNodes
operator|.
name|size
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
name|qWarning
argument_list|(
literal|"QDateTimeParser::getDigit() Internal error (%s %d)"
argument_list|,
name|qPrintable
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"QDateTimeParser::getDigit() Internal error (%d)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
specifier|const
name|SectionNode
modifier|&
name|node
init|=
name|sectionNodes
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
return|;
case|case
name|MinuteSection
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|minute
argument_list|()
return|;
case|case
name|SecondSection
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|second
argument_list|()
return|;
case|case
name|MSecSection
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|msec
argument_list|()
return|;
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
return|return
name|t
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
return|;
case|case
name|MonthSection
case|:
return|return
name|t
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
return|;
case|case
name|DaySection
case|:
return|return
name|t
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
return|;
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
return|return
name|t
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
return|;
case|case
name|AmPmSection
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
operator|>
literal|11
condition|?
literal|1
else|:
literal|0
return|;
default|default:
break|break;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
name|qWarning
argument_list|(
literal|"QDateTimeParser::getDigit() Internal error 2 (%s %d)"
argument_list|,
name|qPrintable
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"QDateTimeParser::getDigit() Internal error 2 (%d)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Sets a digit in a datetime. E.g.    QDateTime var(QDate(2004, 02, 02));   int digit = getDigit(var, Year);   // digit = 2004   setDigit(&var, Year, 2005);   digit = getDigit(var, Year);   // digit = 2005 */
end_comment
begin_function
DECL|function|setDigit
name|bool
name|QDateTimeParser
operator|::
name|setDigit
parameter_list|(
name|QDateTime
modifier|&
name|v
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|newVal
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|sectionNodes
operator|.
name|size
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
name|qWarning
argument_list|(
literal|"QDateTimeParser::setDigit() Internal error (%s %d %d)"
argument_list|,
name|qPrintable
argument_list|(
name|v
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|index
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"QDateTimeParser::setDigit() Internal error (%d %d)"
argument_list|,
name|index
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
specifier|const
name|SectionNode
modifier|&
name|node
init|=
name|sectionNodes
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|,
name|msec
decl_stmt|;
name|year
operator|=
name|v
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
expr_stmt|;
name|month
operator|=
name|v
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
expr_stmt|;
name|day
operator|=
name|v
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
expr_stmt|;
name|hour
operator|=
name|v
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
expr_stmt|;
name|minute
operator|=
name|v
operator|.
name|time
argument_list|()
operator|.
name|minute
argument_list|()
expr_stmt|;
name|second
operator|=
name|v
operator|.
name|time
argument_list|()
operator|.
name|second
argument_list|()
expr_stmt|;
name|msec
operator|=
name|v
operator|.
name|time
argument_list|()
operator|.
name|msec
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|node
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
name|hour
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|MinuteSection
case|:
name|minute
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|SecondSection
case|:
name|second
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|MSecSection
case|:
name|msec
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
name|year
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|MonthSection
case|:
name|month
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|DaySection
case|:
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
if|if
condition|(
name|newVal
operator|>
literal|31
condition|)
block|{
comment|// have to keep legacy behavior. setting the
comment|// date to 32 should return false. Setting it
comment|// to 31 for february should return true
return|return
literal|false
return|;
block|}
name|day
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|AmPmSection
case|:
name|hour
operator|=
operator|(
name|newVal
operator|==
literal|0
condition|?
name|hour
operator|%
literal|12
else|:
operator|(
name|hour
operator|%
literal|12
operator|)
operator|+
literal|12
operator|)
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::setDigit() Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|node
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|node
operator|.
name|type
operator|&
operator|(
name|DaySection
operator||
name|DayOfWeekSectionShort
operator||
name|DayOfWeekSectionLong
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|day
operator|<
name|cachedDay
condition|)
name|day
operator|=
name|cachedDay
expr_stmt|;
specifier|const
name|int
name|max
init|=
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
literal|1
argument_list|)
operator|.
name|daysInMonth
argument_list|()
decl_stmt|;
if|if
condition|(
name|day
operator|>
name|max
condition|)
block|{
name|day
operator|=
name|max
expr_stmt|;
block|}
block|}
if|if
condition|(
name|QDate
operator|::
name|isValid
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
operator|&&
name|QTime
operator|::
name|isValid
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|msec
argument_list|)
condition|)
block|{
name|v
operator|=
name|QDateTime
argument_list|(
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
argument_list|,
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|msec
argument_list|)
argument_list|,
name|spec
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \    Returns the absolute maximum for a section */
end_comment
begin_function
DECL|function|absoluteMax
name|int
name|QDateTimeParser
operator|::
name|absoluteMax
parameter_list|(
name|int
name|s
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|cur
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|s
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
return|return
literal|23
return|;
comment|// this is special-cased in
comment|// parseSection. We want it to be
comment|// 23 for the stepBy case.
case|case
name|MinuteSection
case|:
case|case
name|SecondSection
case|:
return|return
literal|59
return|;
case|case
name|MSecSection
case|:
return|return
literal|999
return|;
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
return|return
literal|9999
return|;
comment|// sectionMaxSize will prevent
comment|// people from typing in a larger
comment|// number in count == 2 sections.
comment|// stepBy() will work on real years anyway
case|case
name|MonthSection
case|:
return|return
literal|12
return|;
case|case
name|DaySection
case|:
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
return|return
name|cur
operator|.
name|isValid
argument_list|()
condition|?
name|cur
operator|.
name|date
argument_list|()
operator|.
name|daysInMonth
argument_list|()
else|:
literal|31
return|;
case|case
name|AmPmSection
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
name|qWarning
argument_list|(
literal|"QDateTimeParser::absoluteMax() Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the absolute minimum for a section */
end_comment
begin_function
DECL|function|absoluteMin
name|int
name|QDateTimeParser
operator|::
name|absoluteMin
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|s
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
case|case
name|MinuteSection
case|:
case|case
name|SecondSection
case|:
case|case
name|MSecSection
case|:
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
return|return
literal|0
return|;
case|case
name|MonthSection
case|:
case|case
name|DaySection
case|:
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
return|return
literal|1
return|;
case|case
name|AmPmSection
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
name|qWarning
argument_list|(
literal|"QDateTimeParser::absoluteMin() Internal error (%s, %0x)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|,
name|sn
operator|.
name|type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the sectionNode for the Section \a s. */
end_comment
begin_function
DECL|function|sectionNode
specifier|const
name|QDateTimeParser
operator|::
name|SectionNode
modifier|&
name|QDateTimeParser
operator|::
name|sectionNode
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|sectionIndex
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|sectionIndex
condition|)
block|{
case|case
name|FirstSectionIndex
case|:
return|return
name|first
return|;
case|case
name|LastSectionIndex
case|:
return|return
name|last
return|;
case|case
name|NoSectionIndex
case|:
return|return
name|none
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sectionIndex
operator|<
name|sectionNodes
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|sectionNodes
operator|.
name|at
argument_list|(
name|sectionIndex
argument_list|)
return|;
block|}
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionNode() Internal error (%d)"
argument_list|,
name|sectionIndex
argument_list|)
expr_stmt|;
return|return
name|none
return|;
block|}
end_function
begin_function
DECL|function|sectionType
name|QDateTimeParser
operator|::
name|Section
name|QDateTimeParser
operator|::
name|sectionType
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
return|return
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
operator|.
name|type
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the starting position for section \a s. */
end_comment
begin_function
DECL|function|sectionPos
name|int
name|QDateTimeParser
operator|::
name|sectionPos
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
return|return
name|sectionPos
argument_list|(
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sectionPos
name|int
name|QDateTimeParser
operator|::
name|sectionPos
parameter_list|(
specifier|const
name|SectionNode
modifier|&
name|sn
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|FirstSection
case|:
return|return
literal|0
return|;
case|case
name|LastSection
case|:
return|return
name|displayText
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|sn
operator|.
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionPos Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|sn
operator|.
name|pos
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    helper function for parseFormat. removes quotes that are   not escaped and removes the escaping on those that are escaped  */
end_comment
begin_function
DECL|function|unquote
specifier|static
name|QString
name|unquote
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
specifier|const
name|QChar
name|quote
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QChar
name|slash
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QChar
name|zero
argument_list|(
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|ret
decl_stmt|;
name|QChar
name|status
argument_list|(
name|zero
argument_list|)
decl_stmt|;
specifier|const
name|int
name|max
init|=
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|quote
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|quote
condition|)
block|{
name|status
operator|=
name|quote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ret
operator|.
name|isEmpty
argument_list|()
operator|&&
name|str
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|==
name|slash
condition|)
block|{
name|ret
index|[
name|ret
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
operator|=
name|quote
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|zero
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|+=
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Parses the format \a newFormat. If successful, returns true and   sets up the format. Else keeps the old format and returns false.  */
end_comment
begin_function
DECL|function|countRepeat
specifier|static
specifier|inline
name|int
name|countRepeat
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|maxCount
parameter_list|)
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
specifier|const
name|QChar
name|ch
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|int
name|max
init|=
name|qMin
argument_list|(
name|index
operator|+
name|maxCount
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|index
operator|+
name|count
operator|<
name|max
operator|&&
name|str
operator|.
name|at
argument_list|(
name|index
operator|+
name|count
argument_list|)
operator|==
name|ch
condition|)
block|{
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function
begin_function
DECL|function|appendSeparator
specifier|static
specifier|inline
name|void
name|appendSeparator
parameter_list|(
name|QStringList
modifier|*
name|list
parameter_list|,
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|lastQuote
parameter_list|)
block|{
name|QString
name|str
argument_list|(
name|string
operator|.
name|mid
argument_list|(
name|from
argument_list|,
name|size
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastQuote
operator|>=
name|from
condition|)
name|str
operator|=
name|unquote
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|list
operator|->
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseFormat
name|bool
name|QDateTimeParser
operator|::
name|parseFormat
parameter_list|(
specifier|const
name|QString
modifier|&
name|newFormat
parameter_list|)
block|{
specifier|const
name|QLatin1Char
name|quote
argument_list|(
literal|'\''
argument_list|)
decl_stmt|;
specifier|const
name|QLatin1Char
name|slash
argument_list|(
literal|'\\'
argument_list|)
decl_stmt|;
specifier|const
name|QLatin1Char
name|zero
argument_list|(
literal|'0'
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFormat
operator|==
name|displayFormat
operator|&&
operator|!
name|newFormat
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|QDTPDEBUGN
argument_list|(
literal|"parseFormat: %s"
argument_list|,
name|newFormat
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|SectionNode
argument_list|>
name|newSectionNodes
decl_stmt|;
name|Sections
name|newDisplay
init|=
literal|0
decl_stmt|;
name|QStringList
name|newSeparators
decl_stmt|;
name|int
name|i
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
name|int
name|add
init|=
literal|0
decl_stmt|;
name|QChar
name|status
argument_list|(
name|zero
argument_list|)
decl_stmt|;
specifier|const
name|int
name|max
init|=
name|newFormat
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|lastQuote
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|newFormat
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|quote
condition|)
block|{
name|lastQuote
operator|=
name|i
expr_stmt|;
operator|++
name|add
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|quote
condition|)
block|{
name|status
operator|=
name|quote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newFormat
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|!=
name|slash
condition|)
block|{
name|status
operator|=
name|zero
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|quote
condition|)
block|{
specifier|const
name|char
name|sect
init|=
name|newFormat
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|sect
condition|)
block|{
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|Section
name|hour
init|=
operator|(
name|sect
operator|==
literal|'h'
operator|)
condition|?
name|Hour12Section
else|:
name|Hour24Section
decl_stmt|;
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|hour
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|hour
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|MinuteSection
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|MinuteSection
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|SecondSection
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|SecondSection
expr_stmt|;
block|}
break|break;
case|case
literal|'z'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|MSecSection
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
operator|?
literal|1
operator|:
literal|3
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|MSecSection
expr_stmt|;
block|}
break|break;
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|bool
name|cap
init|=
operator|(
name|sect
operator|==
literal|'A'
operator|)
decl_stmt|;
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|AmPmSection
block|,
name|i
operator|-
name|add
block|,
operator|(
name|cap
operator|?
literal|1
operator|:
literal|0
operator|)
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|newDisplay
operator||=
name|AmPmSection
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|newFormat
operator|.
name|size
argument_list|()
operator|&&
name|newFormat
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
operator|(
name|cap
condition|?
name|QLatin1Char
argument_list|(
literal|'P'
argument_list|)
else|:
name|QLatin1Char
argument_list|(
literal|'p'
argument_list|)
operator|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'y'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Time
condition|)
block|{
specifier|const
name|int
name|repeat
init|=
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|repeat
operator|>=
literal|2
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|repeat
operator|==
literal|4
operator|?
name|YearSection
operator|:
name|YearSection2Digits
block|,
name|i
operator|-
name|add
block|,
name|repeat
operator|==
literal|4
operator|?
literal|4
operator|:
literal|2
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|sn
operator|.
name|type
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Time
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|MonthSection
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|newSeparators
operator|.
name|append
argument_list|(
name|unquote
argument_list|(
name|newFormat
operator|.
name|mid
argument_list|(
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|MonthSection
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Time
condition|)
block|{
specifier|const
name|int
name|repeat
init|=
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|const
name|Section
name|sectionType
init|=
operator|(
name|repeat
operator|==
literal|4
condition|?
name|DayOfWeekSectionLong
else|:
operator|(
name|repeat
operator|==
literal|3
condition|?
name|DayOfWeekSectionShort
else|:
name|DaySection
operator|)
operator|)
decl_stmt|;
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|sectionType
block|,
name|i
operator|-
name|add
block|,
name|repeat
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|sn
operator|.
name|type
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
if|if
condition|(
name|newSectionNodes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|context
operator|==
name|DateTimeEdit
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|newDisplay
operator|&
operator|(
name|AmPmSection
operator||
name|Hour12Section
operator|)
operator|)
operator|==
name|Hour12Section
condition|)
block|{
specifier|const
name|int
name|max
init|=
name|newSectionNodes
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
name|SectionNode
modifier|&
name|node
init|=
name|newSectionNodes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|type
operator|==
name|Hour12Section
condition|)
name|node
operator|.
name|type
operator|=
name|Hour24Section
expr_stmt|;
block|}
block|}
if|if
condition|(
name|index
operator|<
name|newFormat
operator|.
name|size
argument_list|()
condition|)
block|{
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|index
operator|-
name|max
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newSeparators
operator|.
name|append
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|displayFormat
operator|=
name|newFormat
expr_stmt|;
name|separators
operator|=
name|newSeparators
expr_stmt|;
name|sectionNodes
operator|=
name|newSectionNodes
expr_stmt|;
name|display
operator|=
name|newDisplay
expr_stmt|;
name|last
operator|.
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
comment|//     for (int i=0; i<sectionNodes.size(); ++i) {
comment|//         QDTPDEBUG<< sectionName(sectionNodes.at(i).type)<< sectionNodes.at(i).count;
comment|//     }
name|QDTPDEBUG
operator|<<
name|newFormat
operator|<<
name|displayFormat
expr_stmt|;
name|QDTPDEBUGN
argument_list|(
literal|"separators:\n'%s'"
argument_list|,
name|separators
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the size of section \a s. */
end_comment
begin_function
DECL|function|sectionSize
name|int
name|QDateTimeParser
operator|::
name|sectionSize
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|sectionIndex
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sectionIndex
operator|>=
name|sectionNodes
operator|.
name|size
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionSize Internal error (%d)"
argument_list|,
name|sectionIndex
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|sectionIndex
operator|==
name|sectionNodes
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
comment|// In some cases there is a difference between displayText() and text.
comment|// e.g. when text is 2000/01/31 and displayText() is "2000/2/31" - text
comment|// is the previous value and displayText() is the new value.
comment|// The size difference is always due to leading zeroes.
name|int
name|sizeAdjustment
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|displayText
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|text
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// Any zeroes added before this section will affect our size.
name|int
name|preceedingZeroesAdded
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sectionNodes
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|&&
name|context
operator|==
name|DateTimeEdit
condition|)
block|{
for|for
control|(
name|QVector
argument_list|<
name|SectionNode
argument_list|>
operator|::
name|ConstIterator
name|sectionIt
init|=
name|sectionNodes
operator|.
name|constBegin
argument_list|()
init|;
name|sectionIt
operator|!=
name|sectionNodes
operator|.
name|constBegin
argument_list|()
operator|+
name|sectionIndex
condition|;
operator|++
name|sectionIt
control|)
block|{
name|preceedingZeroesAdded
operator|+=
name|sectionIt
operator|->
name|zeroesAdded
expr_stmt|;
block|}
block|}
name|sizeAdjustment
operator|=
name|preceedingZeroesAdded
expr_stmt|;
block|}
return|return
name|displayText
argument_list|()
operator|.
name|size
argument_list|()
operator|+
name|sizeAdjustment
operator|-
name|sectionPos
argument_list|(
name|sectionIndex
argument_list|)
operator|-
name|separators
operator|.
name|last
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|sectionPos
argument_list|(
name|sectionIndex
operator|+
literal|1
argument_list|)
operator|-
name|sectionPos
argument_list|(
name|sectionIndex
argument_list|)
operator|-
name|separators
operator|.
name|at
argument_list|(
name|sectionIndex
operator|+
literal|1
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
block|}
end_function
begin_function
DECL|function|sectionMaxSize
name|int
name|QDateTimeParser
operator|::
name|sectionMaxSize
parameter_list|(
name|Section
name|s
parameter_list|,
name|int
name|count
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
name|int
name|mcount
init|=
literal|12
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|FirstSection
case|:
case|case
name|NoSection
case|:
case|case
name|LastSection
case|:
return|return
literal|0
return|;
case|case
name|AmPmSection
case|:
block|{
specifier|const
name|int
name|lowerMax
init|=
name|qMin
argument_list|(
name|getAmPmText
argument_list|(
name|AmText
argument_list|,
name|LowerCase
argument_list|)
operator|.
name|size
argument_list|()
argument_list|,
name|getAmPmText
argument_list|(
name|PmText
argument_list|,
name|LowerCase
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|upperMax
init|=
name|qMin
argument_list|(
name|getAmPmText
argument_list|(
name|AmText
argument_list|,
name|UpperCase
argument_list|)
operator|.
name|size
argument_list|()
argument_list|,
name|getAmPmText
argument_list|(
name|PmText
argument_list|,
name|UpperCase
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|qMin
argument_list|(
literal|4
argument_list|,
name|qMin
argument_list|(
name|lowerMax
argument_list|,
name|upperMax
argument_list|)
argument_list|)
return|;
block|}
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
case|case
name|MinuteSection
case|:
case|case
name|SecondSection
case|:
case|case
name|DaySection
case|:
return|return
literal|2
return|;
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
ifdef|#
directive|ifdef
name|QT_NO_TEXTDATE
return|return
literal|2
return|;
else|#
directive|else
name|mcount
operator|=
literal|7
expr_stmt|;
comment|// fall through
endif|#
directive|endif
case|case
name|MonthSection
case|:
if|if
condition|(
name|count
operator|<=
literal|2
condition|)
return|return
literal|2
return|;
ifdef|#
directive|ifdef
name|QT_NO_TEXTDATE
return|return
literal|2
return|;
else|#
directive|else
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|QLocale
name|l
init|=
name|locale
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|mcount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
name|str
init|=
operator|(
name|s
operator|==
name|MonthSection
condition|?
name|l
operator|.
name|monthName
argument_list|(
name|i
argument_list|,
name|count
operator|==
literal|4
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
else|:
name|l
operator|.
name|dayName
argument_list|(
name|i
argument_list|,
name|count
operator|==
literal|4
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
operator|)
decl_stmt|;
name|ret
operator|=
name|qMax
argument_list|(
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
endif|#
directive|endif
case|case
name|MSecSection
case|:
return|return
literal|3
return|;
case|case
name|YearSection
case|:
return|return
literal|4
return|;
case|case
name|YearSection2Digits
case|:
return|return
literal|2
return|;
case|case
name|CalendarPopupSection
case|:
case|case
name|Internal
case|:
case|case
name|TimeSectionMask
case|:
case|case
name|DateSectionMask
case|:
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionMaxSize: Invalid section %s"
argument_list|,
name|sectionName
argument_list|(
name|s
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|NoSectionIndex
case|:
case|case
name|FirstSectionIndex
case|:
case|case
name|LastSectionIndex
case|:
case|case
name|CalendarPopupIndex
case|:
comment|// these cases can't happen
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|sectionMaxSize
name|int
name|QDateTimeParser
operator|::
name|sectionMaxSize
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|sectionMaxSize
argument_list|(
name|sn
operator|.
name|type
argument_list|,
name|sn
operator|.
name|count
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the text of section \a s. This function operates on the   arg text rather than edit->text(). */
end_comment
begin_function
DECL|function|sectionText
name|QString
name|QDateTimeParser
operator|::
name|sectionText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|int
name|sectionIndex
parameter_list|,
name|int
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|NoSectionIndex
case|:
case|case
name|FirstSectionIndex
case|:
case|case
name|LastSectionIndex
case|:
return|return
name|QString
argument_list|()
return|;
default|default:
break|break;
block|}
return|return
name|text
operator|.
name|mid
argument_list|(
name|index
argument_list|,
name|sectionSize
argument_list|(
name|sectionIndex
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sectionText
name|QString
name|QDateTimeParser
operator|::
name|sectionText
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|NoSectionIndex
case|:
case|case
name|FirstSectionIndex
case|:
case|case
name|LastSectionIndex
case|:
return|return
name|QString
argument_list|()
return|;
default|default:
break|break;
block|}
return|return
name|displayText
argument_list|()
operator|.
name|mid
argument_list|(
name|sn
operator|.
name|pos
argument_list|,
name|sectionSize
argument_list|(
name|sectionIndex
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_comment
comment|/*!   \internal:skipToNextSection    Parses the part of \a text that corresponds to \a s and returns   the value of that field. Sets *stateptr to the right state if   stateptr != 0. */
end_comment
begin_function
DECL|function|parseSection
name|int
name|QDateTimeParser
operator|::
name|parseSection
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|currentValue
parameter_list|,
name|int
name|sectionIndex
parameter_list|,
name|QString
modifier|&
name|text
parameter_list|,
name|int
modifier|&
name|cursorPosition
parameter_list|,
name|int
name|index
parameter_list|,
name|State
modifier|&
name|state
parameter_list|,
name|int
modifier|*
name|usedptr
parameter_list|)
specifier|const
block|{
name|state
operator|=
name|Invalid
expr_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sn
operator|.
name|type
operator|&
name|Internal
operator|)
operator|==
name|Internal
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::parseSection Internal error (%s %d)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|,
name|sectionIndex
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
specifier|const
name|int
name|sectionmaxsize
init|=
name|sectionMaxSize
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
name|QString
name|sectiontext
init|=
name|text
operator|.
name|mid
argument_list|(
name|index
argument_list|,
name|sectionmaxsize
argument_list|)
decl_stmt|;
name|int
name|sectiontextSize
init|=
name|sectiontext
operator|.
name|size
argument_list|()
decl_stmt|;
name|QDTPDEBUG
operator|<<
literal|"sectionValue for"
operator|<<
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
operator|<<
literal|"with text"
operator|<<
name|text
operator|<<
literal|"and st"
operator|<<
name|sectiontext
operator|<<
name|text
operator|.
name|mid
argument_list|(
name|index
argument_list|,
name|sectionmaxsize
argument_list|)
operator|<<
name|index
expr_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|AmPmSection
case|:
block|{
specifier|const
name|int
name|ampm
init|=
name|findAmPm
argument_list|(
name|sectiontext
argument_list|,
name|sectionIndex
argument_list|,
operator|&
name|used
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ampm
condition|)
block|{
case|case
name|AM
case|:
comment|// sectiontext == AM
case|case
name|PM
case|:
comment|// sectiontext == PM
name|num
operator|=
name|ampm
expr_stmt|;
name|state
operator|=
name|Acceptable
expr_stmt|;
break|break;
case|case
name|PossibleAM
case|:
comment|// sectiontext => AM
case|case
name|PossiblePM
case|:
comment|// sectiontext => PM
name|num
operator|=
name|ampm
operator|-
literal|2
expr_stmt|;
name|state
operator|=
name|Intermediate
expr_stmt|;
break|break;
case|case
name|PossibleBoth
case|:
comment|// sectiontext => AM|PM
name|num
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|Intermediate
expr_stmt|;
break|break;
case|case
name|Neither
case|:
name|state
operator|=
name|Invalid
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"invalid because findAmPm("
operator|<<
name|sectiontext
operator|<<
literal|") returned -1"
expr_stmt|;
break|break;
default|default:
name|QDTPDEBUGN
argument_list|(
literal|"This should never happen (findAmPm returned %d)"
argument_list|,
name|ampm
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|state
operator|!=
name|Invalid
condition|)
block|{
name|QString
name|str
init|=
name|text
decl_stmt|;
name|text
operator|.
name|replace
argument_list|(
name|index
argument_list|,
name|used
argument_list|,
name|sectiontext
operator|.
name|left
argument_list|(
name|used
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MonthSection
case|:
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
if|if
condition|(
name|sn
operator|.
name|count
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|sn
operator|.
name|type
operator|==
name|MonthSection
condition|)
block|{
name|int
name|min
init|=
literal|1
decl_stmt|;
specifier|const
name|QDate
name|minDate
init|=
name|getMinimum
argument_list|()
operator|.
name|date
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
operator|==
name|minDate
operator|.
name|year
argument_list|()
condition|)
block|{
name|min
operator|=
name|minDate
operator|.
name|month
argument_list|()
expr_stmt|;
block|}
name|num
operator|=
name|findMonth
argument_list|(
name|sectiontext
operator|.
name|toLower
argument_list|()
argument_list|,
name|min
argument_list|,
name|sectionIndex
argument_list|,
operator|&
name|sectiontext
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|=
name|findDay
argument_list|(
name|sectiontext
operator|.
name|toLower
argument_list|()
argument_list|,
literal|1
argument_list|,
name|sectionIndex
argument_list|,
operator|&
name|sectiontext
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
name|state
operator|=
operator|(
name|used
operator|==
name|sectiontext
operator|.
name|size
argument_list|()
condition|?
name|Acceptable
else|:
name|Intermediate
operator|)
expr_stmt|;
name|QString
name|str
init|=
name|text
decl_stmt|;
name|text
operator|.
name|replace
argument_list|(
name|index
argument_list|,
name|used
argument_list|,
name|sectiontext
operator|.
name|left
argument_list|(
name|used
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|Intermediate
expr_stmt|;
block|}
break|break;
block|}
comment|// fall through
case|case
name|DaySection
case|:
case|case
name|YearSection
case|:
case|case
name|YearSection2Digits
case|:
case|case
name|Hour12Section
case|:
case|case
name|Hour24Section
case|:
case|case
name|MinuteSection
case|:
case|case
name|SecondSection
case|:
case|case
name|MSecSection
case|:
block|{
if|if
condition|(
name|sectiontextSize
operator|==
literal|0
condition|)
block|{
name|num
operator|=
literal|0
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|Intermediate
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|absMax
init|=
name|absoluteMax
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
name|QLocale
name|loc
decl_stmt|;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
name|int
name|last
init|=
operator|-
literal|1
decl_stmt|;
name|used
operator|=
operator|-
literal|1
expr_stmt|;
name|QString
name|digitsStr
argument_list|(
name|sectiontext
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sectiontextSize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|digitsStr
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|sectiontextSize
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
specifier|const
name|int
name|max
init|=
name|qMin
argument_list|(
name|sectionmaxsize
argument_list|,
name|sectiontextSize
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|digits
init|=
name|max
init|;
name|digits
operator|>=
literal|1
condition|;
operator|--
name|digits
control|)
block|{
name|digitsStr
operator|.
name|truncate
argument_list|(
name|digits
argument_list|)
expr_stmt|;
name|int
name|tmp
init|=
operator|(
name|int
operator|)
name|loc
operator|.
name|toUInt
argument_list|(
name|digitsStr
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
operator|&&
name|sn
operator|.
name|type
operator|==
name|Hour12Section
condition|)
block|{
if|if
condition|(
name|tmp
operator|>
literal|12
condition|)
block|{
name|tmp
operator|=
operator|-
literal|1
expr_stmt|;
name|ok
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmp
operator|==
literal|12
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ok
operator|&&
name|tmp
operator|<=
name|absMax
condition|)
block|{
name|QDTPDEBUG
operator|<<
name|sectiontext
operator|.
name|left
argument_list|(
name|digits
argument_list|)
operator|<<
name|tmp
operator|<<
name|digits
expr_stmt|;
name|last
operator|=
name|tmp
expr_stmt|;
name|used
operator|=
name|digits
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
block|{
name|QChar
name|first
argument_list|(
name|sectiontext
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|separators
operator|.
name|at
argument_list|(
name|sectionIndex
operator|+
literal|1
argument_list|)
operator|.
name|startsWith
argument_list|(
name|first
argument_list|)
condition|)
block|{
name|used
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|Intermediate
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|Invalid
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"invalid because"
operator|<<
name|sectiontext
operator|<<
literal|"can't become a uint"
operator|<<
name|last
operator|<<
name|ok
expr_stmt|;
block|}
block|}
else|else
block|{
name|num
operator|+=
name|last
expr_stmt|;
specifier|const
name|FieldInfo
name|fi
init|=
name|fieldInfo
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|done
init|=
operator|(
name|used
operator|==
name|sectionmaxsize
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|done
operator|&&
name|fi
operator|&
name|Fraction
condition|)
block|{
comment|// typing 2 in a zzz field should be .200, not .002
for|for
control|(
name|int
name|i
init|=
name|used
init|;
name|i
operator|<
name|sectionmaxsize
condition|;
operator|++
name|i
control|)
block|{
name|num
operator|*=
literal|10
expr_stmt|;
block|}
block|}
specifier|const
name|int
name|absMin
init|=
name|absoluteMin
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|<
name|absMin
condition|)
block|{
name|state
operator|=
name|done
condition|?
name|Invalid
else|:
name|Intermediate
expr_stmt|;
if|if
condition|(
name|done
condition|)
name|QDTPDEBUG
operator|<<
literal|"invalid because"
operator|<<
name|num
operator|<<
literal|"is less than absoluteMin"
operator|<<
name|absMin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num
operator|>
name|absMax
condition|)
block|{
name|state
operator|=
name|Intermediate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|done
operator|&&
operator|(
name|fi
operator|&
operator|(
name|FixedWidth
operator||
name|Numeric
operator|)
operator|)
operator|==
operator|(
name|FixedWidth
operator||
name|Numeric
operator|)
condition|)
block|{
if|if
condition|(
name|skipToNextSection
argument_list|(
name|sectionIndex
argument_list|,
name|currentValue
argument_list|,
name|digitsStr
argument_list|)
condition|)
block|{
name|state
operator|=
name|Acceptable
expr_stmt|;
specifier|const
name|int
name|missingZeroes
init|=
name|sectionmaxsize
operator|-
name|digitsStr
operator|.
name|size
argument_list|()
decl_stmt|;
name|text
operator|.
name|insert
argument_list|(
name|index
argument_list|,
name|QString
argument_list|()
operator|.
name|fill
argument_list|(
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
name|missingZeroes
argument_list|)
argument_list|)
expr_stmt|;
name|used
operator|=
name|sectionmaxsize
expr_stmt|;
name|cursorPosition
operator|+=
name|missingZeroes
expr_stmt|;
operator|++
operator|(
cast|const_cast
argument_list|<
name|QDateTimeParser
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|sectionNodes
index|[
name|sectionIndex
index|]
operator|.
name|zeroesAdded
operator|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|Intermediate
expr_stmt|;
empty_stmt|;
block|}
block|}
else|else
block|{
name|state
operator|=
name|Acceptable
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::parseSection Internal error (%s %d)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|,
name|sectionIndex
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|usedptr
condition|)
operator|*
name|usedptr
operator|=
name|used
expr_stmt|;
return|return
operator|(
name|state
operator|!=
name|Invalid
condition|?
name|num
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTDATE
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|parse
name|QDateTimeParser
operator|::
name|StateNode
name|QDateTimeParser
operator|::
name|parse
parameter_list|(
name|QString
modifier|&
name|input
parameter_list|,
name|int
modifier|&
name|cursorPosition
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|currentValue
parameter_list|,
name|bool
name|fixup
parameter_list|)
specifier|const
block|{
specifier|const
name|QDateTime
name|minimum
init|=
name|getMinimum
argument_list|()
decl_stmt|;
specifier|const
name|QDateTime
name|maximum
init|=
name|getMaximum
argument_list|()
decl_stmt|;
name|State
name|state
init|=
name|Acceptable
decl_stmt|;
name|QDateTime
name|newCurrentValue
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|bool
name|conflicts
init|=
literal|false
decl_stmt|;
specifier|const
name|int
name|sectionNodesCount
init|=
name|sectionNodes
operator|.
name|size
argument_list|()
decl_stmt|;
name|QDTPDEBUG
operator|<<
literal|"parse"
operator|<<
name|input
expr_stmt|;
block|{
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hour12
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|,
name|msec
decl_stmt|,
name|ampm
decl_stmt|,
name|dayofweek
decl_stmt|,
name|year2digits
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|toJulianDay
argument_list|()
argument_list|,
operator|&
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|)
expr_stmt|;
name|year2digits
operator|=
name|year
operator|%
literal|100
expr_stmt|;
name|hour
operator|=
name|currentValue
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
expr_stmt|;
name|hour12
operator|=
operator|-
literal|1
expr_stmt|;
name|minute
operator|=
name|currentValue
operator|.
name|time
argument_list|()
operator|.
name|minute
argument_list|()
expr_stmt|;
name|second
operator|=
name|currentValue
operator|.
name|time
argument_list|()
operator|.
name|second
argument_list|()
expr_stmt|;
name|msec
operator|=
name|currentValue
operator|.
name|time
argument_list|()
operator|.
name|msec
argument_list|()
expr_stmt|;
name|dayofweek
operator|=
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|dayOfWeek
argument_list|()
expr_stmt|;
name|ampm
operator|=
operator|-
literal|1
expr_stmt|;
name|Sections
name|isSet
init|=
name|NoSection
decl_stmt|;
name|int
name|num
decl_stmt|;
name|State
name|tmpstate
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|state
operator|!=
name|Invalid
operator|&&
name|index
operator|<
name|sectionNodesCount
condition|;
operator|++
name|index
control|)
block|{
if|if
condition|(
name|QStringRef
argument_list|(
operator|&
name|input
argument_list|,
name|pos
argument_list|,
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
operator|!=
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"invalid because"
operator|<<
name|input
operator|.
name|mid
argument_list|(
name|pos
argument_list|,
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
operator|<<
literal|"!="
operator|<<
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|<<
name|index
operator|<<
name|pos
operator|<<
name|currentSectionIndex
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|pos
operator|+=
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
name|sectionNodes
index|[
name|index
index|]
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
name|int
modifier|*
name|current
init|=
literal|0
decl_stmt|;
specifier|const
name|SectionNode
name|sn
init|=
name|sectionNodes
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|used
decl_stmt|;
name|num
operator|=
name|parseSection
argument_list|(
name|currentValue
argument_list|,
name|index
argument_list|,
name|input
argument_list|,
name|cursorPosition
argument_list|,
name|pos
argument_list|,
name|tmpstate
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"sectionValue"
operator|<<
name|sectionName
argument_list|(
name|sectionType
argument_list|(
name|index
argument_list|)
argument_list|)
operator|<<
name|input
operator|<<
literal|"pos"
operator|<<
name|pos
operator|<<
literal|"used"
operator|<<
name|used
operator|<<
name|stateName
argument_list|(
name|tmpstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixup
operator|&&
name|tmpstate
operator|==
name|Intermediate
operator|&&
name|used
operator|<
name|sn
operator|.
name|count
condition|)
block|{
specifier|const
name|FieldInfo
name|fi
init|=
name|fieldInfo
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|fi
operator|&
operator|(
name|Numeric
operator||
name|FixedWidth
operator|)
operator|)
operator|==
operator|(
name|Numeric
operator||
name|FixedWidth
operator|)
condition|)
block|{
specifier|const
name|QString
name|newText
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|num
argument_list|,
name|sn
operator|.
name|count
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
decl_stmt|;
name|input
operator|.
name|replace
argument_list|(
name|pos
argument_list|,
name|used
argument_list|,
name|newText
argument_list|)
expr_stmt|;
name|used
operator|=
name|sn
operator|.
name|count
expr_stmt|;
block|}
block|}
name|pos
operator|+=
name|qMax
argument_list|(
literal|0
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|state
operator|=
name|qMin
argument_list|<
name|State
argument_list|>
argument_list|(
name|state
argument_list|,
name|tmpstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|Intermediate
operator|&&
name|context
operator|==
name|FromString
condition|)
block|{
name|state
operator|=
name|Invalid
expr_stmt|;
break|break;
block|}
name|QDTPDEBUG
operator|<<
name|index
operator|<<
name|sectionName
argument_list|(
name|sectionType
argument_list|(
name|index
argument_list|)
argument_list|)
operator|<<
literal|"is set to"
operator|<<
name|pos
operator|<<
literal|"state is"
operator|<<
name|stateName
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|Invalid
condition|)
block|{
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
name|current
operator|=
operator|&
name|hour
expr_stmt|;
break|break;
case|case
name|Hour12Section
case|:
name|current
operator|=
operator|&
name|hour12
expr_stmt|;
break|break;
case|case
name|MinuteSection
case|:
name|current
operator|=
operator|&
name|minute
expr_stmt|;
break|break;
case|case
name|SecondSection
case|:
name|current
operator|=
operator|&
name|second
expr_stmt|;
break|break;
case|case
name|MSecSection
case|:
name|current
operator|=
operator|&
name|msec
expr_stmt|;
break|break;
case|case
name|YearSection
case|:
name|current
operator|=
operator|&
name|year
expr_stmt|;
break|break;
case|case
name|YearSection2Digits
case|:
name|current
operator|=
operator|&
name|year2digits
expr_stmt|;
break|break;
case|case
name|MonthSection
case|:
name|current
operator|=
operator|&
name|month
expr_stmt|;
break|break;
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
name|current
operator|=
operator|&
name|dayofweek
expr_stmt|;
break|break;
case|case
name|DaySection
case|:
name|current
operator|=
operator|&
name|day
expr_stmt|;
name|num
operator|=
name|qMax
argument_list|<
name|int
argument_list|>
argument_list|(
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
name|AmPmSection
case|:
name|current
operator|=
operator|&
name|ampm
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::parse Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|current
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::parse Internal error 2"
argument_list|)
expr_stmt|;
return|return
name|StateNode
argument_list|()
return|;
block|}
if|if
condition|(
name|isSet
operator|&
name|sn
operator|.
name|type
operator|&&
operator|*
name|current
operator|!=
name|num
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"CONFLICT "
operator|<<
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
operator|<<
operator|*
name|current
operator|<<
name|num
expr_stmt|;
name|conflicts
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|index
operator|!=
name|currentSectionIndex
operator|||
name|num
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
operator|*
name|current
operator|=
name|num
expr_stmt|;
name|isSet
operator||=
name|sn
operator|.
name|type
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
operator|!=
name|Invalid
operator|&&
name|QStringRef
argument_list|(
operator|&
name|input
argument_list|,
name|pos
argument_list|,
name|input
operator|.
name|size
argument_list|()
operator|-
name|pos
argument_list|)
operator|!=
name|separators
operator|.
name|last
argument_list|()
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"invalid because"
operator|<<
name|input
operator|.
name|mid
argument_list|(
name|pos
argument_list|)
operator|<<
literal|"!="
operator|<<
name|separators
operator|.
name|last
argument_list|()
operator|<<
name|pos
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|!=
name|Invalid
condition|)
block|{
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Time
condition|)
block|{
if|if
condition|(
name|year
operator|%
literal|100
operator|!=
name|year2digits
condition|)
block|{
switch|switch
condition|(
name|isSet
operator|&
operator|(
name|YearSection2Digits
operator||
name|YearSection
operator|)
condition|)
block|{
case|case
name|YearSection2Digits
case|:
name|year
operator|=
operator|(
name|year
operator|/
literal|100
operator|)
operator|*
literal|100
expr_stmt|;
name|year
operator|+=
name|year2digits
expr_stmt|;
break|break;
case|case
operator|(
operator|(
name|uint
operator|)
name|YearSection2Digits
operator||
operator|(
name|uint
operator|)
name|YearSection
operator|)
case|:
block|{
name|conflicts
operator|=
literal|true
expr_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|currentSectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|==
name|YearSection2Digits
condition|)
block|{
name|year
operator|=
operator|(
name|year
operator|/
literal|100
operator|)
operator|*
literal|100
expr_stmt|;
name|year
operator|+=
name|year2digits
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
specifier|const
name|QDate
name|date
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
decl_stmt|;
specifier|const
name|int
name|diff
init|=
name|dayofweek
operator|-
name|date
operator|.
name|dayOfWeek
argument_list|()
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
operator|&&
name|state
operator|==
name|Acceptable
operator|&&
name|isSet
operator|&
operator|(
name|DayOfWeekSectionShort
operator||
name|DayOfWeekSectionLong
operator|)
condition|)
block|{
name|conflicts
operator|=
name|isSet
operator|&
name|DaySection
expr_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|currentSectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|&
operator|(
name|DayOfWeekSectionShort
operator||
name|DayOfWeekSectionLong
operator|)
operator|||
name|currentSectionIndex
operator|==
operator|-
literal|1
condition|)
block|{
comment|// dayofweek should be preferred
name|day
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
name|day
operator|<=
literal|0
condition|)
block|{
name|day
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|day
operator|>
name|date
operator|.
name|daysInMonth
argument_list|()
condition|)
block|{
name|day
operator|-=
literal|7
expr_stmt|;
block|}
name|QDTPDEBUG
operator|<<
name|year
operator|<<
name|month
operator|<<
name|day
operator|<<
name|dayofweek
operator|<<
name|diff
operator|<<
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
operator|.
name|dayOfWeek
argument_list|()
expr_stmt|;
block|}
block|}
name|bool
name|needfixday
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|sectionType
argument_list|(
name|currentSectionIndex
argument_list|)
operator|&
operator|(
name|DaySection
operator||
name|DayOfWeekSectionShort
operator||
name|DayOfWeekSectionLong
operator|)
condition|)
block|{
name|cachedDay
operator|=
name|day
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cachedDay
operator|>
name|day
condition|)
block|{
name|day
operator|=
name|cachedDay
expr_stmt|;
name|needfixday
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|QDate
operator|::
name|isValid
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
condition|)
block|{
if|if
condition|(
name|day
operator|<
literal|32
condition|)
block|{
name|cachedDay
operator|=
name|day
expr_stmt|;
block|}
if|if
condition|(
name|day
operator|>
literal|28
operator|&&
name|QDate
operator|::
name|isValid
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|needfixday
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needfixday
condition|)
block|{
if|if
condition|(
name|context
operator|==
name|FromString
condition|)
block|{
name|state
operator|=
name|Invalid
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|state
operator|==
name|Acceptable
operator|&&
name|fixday
condition|)
block|{
name|day
operator|=
name|qMin
argument_list|<
name|int
argument_list|>
argument_list|(
name|day
argument_list|,
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
literal|1
argument_list|)
operator|.
name|daysInMonth
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|QLocale
name|loc
init|=
name|locale
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sectionNodesCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Section
name|thisSectionType
init|=
name|sectionType
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|thisSectionType
operator|&
operator|(
name|DaySection
operator|)
condition|)
block|{
name|input
operator|.
name|replace
argument_list|(
name|sectionPos
argument_list|(
name|i
argument_list|)
argument_list|,
name|sectionSize
argument_list|(
name|i
argument_list|)
argument_list|,
name|loc
operator|.
name|toString
argument_list|(
name|day
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|thisSectionType
operator|&
operator|(
name|DayOfWeekSectionShort
operator||
name|DayOfWeekSectionLong
operator|)
condition|)
block|{
specifier|const
name|int
name|dayOfWeek
init|=
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
operator|.
name|dayOfWeek
argument_list|()
decl_stmt|;
specifier|const
name|QLocale
operator|::
name|FormatType
name|dayFormat
init|=
operator|(
name|thisSectionType
operator|==
name|DayOfWeekSectionShort
condition|?
name|QLocale
operator|::
name|ShortFormat
else|:
name|QLocale
operator|::
name|LongFormat
operator|)
decl_stmt|;
specifier|const
name|QString
name|dayName
argument_list|(
name|loc
operator|.
name|dayName
argument_list|(
name|dayOfWeek
argument_list|,
name|dayFormat
argument_list|)
argument_list|)
decl_stmt|;
name|input
operator|.
name|replace
argument_list|(
name|sectionPos
argument_list|(
name|i
argument_list|)
argument_list|,
name|sectionSize
argument_list|(
name|i
argument_list|)
argument_list|,
name|dayName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|state
operator|=
name|qMin
argument_list|(
name|Intermediate
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
if|if
condition|(
name|isSet
operator|&
name|Hour12Section
condition|)
block|{
specifier|const
name|bool
name|hasHour
init|=
name|isSet
operator|&
name|Hour24Section
decl_stmt|;
if|if
condition|(
name|ampm
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|hasHour
condition|)
block|{
name|ampm
operator|=
operator|(
name|hour
operator|<
literal|12
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ampm
operator|=
literal|0
expr_stmt|;
comment|// no way to tell if this is am or pm so I assume am
block|}
block|}
name|hour12
operator|=
operator|(
name|ampm
operator|==
literal|0
condition|?
name|hour12
operator|%
literal|12
else|:
operator|(
name|hour12
operator|%
literal|12
operator|)
operator|+
literal|12
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasHour
condition|)
block|{
name|hour
operator|=
name|hour12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hour
operator|!=
name|hour12
condition|)
block|{
name|conflicts
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ampm
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isSet
operator|&
operator|(
name|Hour24Section
operator|)
operator|)
condition|)
block|{
name|hour
operator|=
operator|(
literal|12
operator|*
name|ampm
operator|)
expr_stmt|;
comment|// special case. Only ap section
block|}
elseif|else
if|if
condition|(
operator|(
name|ampm
operator|==
literal|0
operator|)
operator|!=
operator|(
name|hour
operator|<
literal|12
operator|)
condition|)
block|{
name|conflicts
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|newCurrentValue
operator|=
name|QDateTime
argument_list|(
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
argument_list|,
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|msec
argument_list|)
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
name|year
operator|<<
name|month
operator|<<
name|day
operator|<<
name|hour
operator|<<
name|minute
operator|<<
name|second
operator|<<
name|msec
expr_stmt|;
block|}
name|QDTPDEBUGN
argument_list|(
literal|"'%s' => '%s'(%s)"
argument_list|,
name|input
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|newCurrentValue
operator|.
name|toString
argument_list|(
name|QLatin1String
argument_list|(
literal|"yyyy/MM/dd hh:mm:ss.zzz"
argument_list|)
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|stateName
argument_list|(
name|state
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|newCurrentValue
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|context
operator|!=
name|FromString
operator|&&
name|state
operator|!=
name|Invalid
operator|&&
name|newCurrentValue
operator|<
name|minimum
condition|)
block|{
specifier|const
name|QLatin1Char
name|space
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|newCurrentValue
operator|>=
name|minimum
condition|)
name|qWarning
argument_list|(
literal|"QDateTimeParser::parse Internal error 3 (%s %s)"
argument_list|,
name|qPrintable
argument_list|(
name|newCurrentValue
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|minimum
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|done
init|=
literal|false
decl_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sectionNodesCount
operator|&&
operator|!
name|done
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNodes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QString
name|t
init|=
name|sectionText
argument_list|(
name|input
argument_list|,
name|i
argument_list|,
name|sn
operator|.
name|pos
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|.
name|size
argument_list|()
operator|<
name|sectionMaxSize
argument_list|(
name|i
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|int
operator|)
name|fieldInfo
argument_list|(
name|i
argument_list|)
operator|&
operator|(
name|FixedWidth
operator||
name|Numeric
operator|)
operator|)
operator|!=
name|Numeric
operator|)
operator|)
operator|||
name|t
operator|.
name|contains
argument_list|(
name|space
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|AmPmSection
case|:
switch|switch
condition|(
name|findAmPm
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
block|{
case|case
name|AM
case|:
case|case
name|PM
case|:
name|state
operator|=
name|Acceptable
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Neither
case|:
name|state
operator|=
name|Invalid
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|PossibleAM
case|:
case|case
name|PossiblePM
case|:
case|case
name|PossibleBoth
case|:
block|{
specifier|const
name|QDateTime
name|copy
argument_list|(
name|newCurrentValue
operator|.
name|addSecs
argument_list|(
literal|12
operator|*
literal|60
operator|*
literal|60
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy
operator|>=
name|minimum
operator|&&
name|copy
operator|<=
name|maximum
condition|)
block|{
name|state
operator|=
name|Intermediate
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
block|}
case|case
name|MonthSection
case|:
if|if
condition|(
name|sn
operator|.
name|count
operator|>=
literal|3
condition|)
block|{
name|int
name|tmp
init|=
name|newCurrentValue
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
decl_stmt|;
comment|// I know the first possible month makes the date too early
while|while
condition|(
operator|(
name|tmp
operator|=
name|findMonth
argument_list|(
name|t
argument_list|,
name|tmp
operator|+
literal|1
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
specifier|const
name|QDateTime
name|copy
argument_list|(
name|newCurrentValue
operator|.
name|addMonths
argument_list|(
name|tmp
operator|-
name|newCurrentValue
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy
operator|>=
name|minimum
operator|&&
name|copy
operator|<=
name|maximum
condition|)
break|break;
comment|// break out of while
block|}
if|if
condition|(
name|tmp
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|state
operator|=
name|Intermediate
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
comment|// fallthrough
default|default:
block|{
name|int
name|toMin
decl_stmt|;
name|int
name|toMax
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|&
name|TimeSectionMask
condition|)
block|{
if|if
condition|(
name|newCurrentValue
operator|.
name|daysTo
argument_list|(
name|minimum
argument_list|)
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|toMin
operator|=
name|newCurrentValue
operator|.
name|time
argument_list|()
operator|.
name|msecsTo
argument_list|(
name|minimum
operator|.
name|time
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newCurrentValue
operator|.
name|daysTo
argument_list|(
name|maximum
argument_list|)
operator|>
literal|0
condition|)
block|{
name|toMax
operator|=
operator|-
literal|1
expr_stmt|;
comment|// can't get to max
block|}
else|else
block|{
name|toMax
operator|=
name|newCurrentValue
operator|.
name|time
argument_list|()
operator|.
name|msecsTo
argument_list|(
name|maximum
operator|.
name|time
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|toMin
operator|=
name|newCurrentValue
operator|.
name|daysTo
argument_list|(
name|minimum
argument_list|)
expr_stmt|;
name|toMax
operator|=
name|newCurrentValue
operator|.
name|daysTo
argument_list|(
name|maximum
argument_list|)
expr_stmt|;
block|}
specifier|const
name|int
name|maxChange
init|=
name|QDateTimeParser
operator|::
name|maxChange
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|toMin
operator|>
name|maxChange
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"invalid because toMin> maxChange"
operator|<<
name|toMin
operator|<<
name|maxChange
operator|<<
name|t
operator|<<
name|newCurrentValue
operator|<<
name|minimum
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|toMax
operator|>
name|maxChange
condition|)
block|{
name|toMax
operator|=
operator|-
literal|1
expr_stmt|;
comment|// can't get to max
block|}
specifier|const
name|int
name|min
init|=
name|getDigit
argument_list|(
name|minimum
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|min
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::parse Internal error 4 (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|int
name|max
init|=
name|toMax
operator|!=
operator|-
literal|1
condition|?
name|getDigit
argument_list|(
name|maximum
argument_list|,
name|i
argument_list|)
else|:
name|absoluteMax
argument_list|(
name|i
argument_list|,
name|newCurrentValue
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|cursorPosition
operator|-
name|sn
operator|.
name|pos
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>=
name|t
operator|.
name|size
argument_list|()
condition|)
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|potentialValue
argument_list|(
name|t
operator|.
name|simplified
argument_list|()
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|i
argument_list|,
name|newCurrentValue
argument_list|,
name|pos
argument_list|)
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"invalid because potentialValue("
operator|<<
name|t
operator|.
name|simplified
argument_list|()
operator|<<
name|min
operator|<<
name|max
operator|<<
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
operator|<<
literal|"returned"
operator|<<
name|toMax
operator|<<
name|toMin
operator|<<
name|pos
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|state
operator|=
name|Intermediate
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|context
operator|==
name|FromString
condition|)
block|{
comment|// optimization
name|Q_ASSERT
argument_list|(
name|getMaximum
argument_list|()
operator|.
name|date
argument_list|()
operator|.
name|toJulianDay
argument_list|()
operator|==
literal|4642999
argument_list|)
expr_stmt|;
if|if
condition|(
name|newCurrentValue
operator|.
name|date
argument_list|()
operator|.
name|toJulianDay
argument_list|()
operator|>
literal|4642999
condition|)
name|state
operator|=
name|Invalid
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|newCurrentValue
operator|>
name|getMaximum
argument_list|()
condition|)
name|state
operator|=
name|Invalid
expr_stmt|;
block|}
name|QDTPDEBUG
operator|<<
literal|"not checking intermediate because newCurrentValue is"
operator|<<
name|newCurrentValue
operator|<<
name|getMinimum
argument_list|()
operator|<<
name|getMaximum
argument_list|()
expr_stmt|;
block|}
block|}
name|StateNode
name|node
decl_stmt|;
name|node
operator|.
name|input
operator|=
name|input
expr_stmt|;
name|node
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|node
operator|.
name|conflicts
operator|=
name|conflicts
expr_stmt|;
name|node
operator|.
name|value
operator|=
name|newCurrentValue
operator|.
name|toTimeSpec
argument_list|(
name|spec
argument_list|)
expr_stmt|;
name|text
operator|=
name|input
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_comment
comment|/*!   \internal   finds the first possible monthname that \a str1 can   match. Starting from \a index; str should already by lowered */
end_comment
begin_function
DECL|function|findMonth
name|int
name|QDateTimeParser
operator|::
name|findMonth
parameter_list|(
specifier|const
name|QString
modifier|&
name|str1
parameter_list|,
name|int
name|startMonth
parameter_list|,
name|int
name|sectionIndex
parameter_list|,
name|QString
modifier|*
name|usedMonth
parameter_list|,
name|int
modifier|*
name|used
parameter_list|)
specifier|const
block|{
name|int
name|bestMatch
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bestCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|str1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|!=
name|MonthSection
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::findMonth Internal error"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|QLocale
operator|::
name|FormatType
name|type
init|=
name|sn
operator|.
name|count
operator|==
literal|3
condition|?
name|QLocale
operator|::
name|ShortFormat
else|:
name|QLocale
operator|::
name|LongFormat
decl_stmt|;
name|QLocale
name|l
init|=
name|locale
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|month
init|=
name|startMonth
init|;
name|month
operator|<=
literal|12
condition|;
operator|++
name|month
control|)
block|{
name|QString
name|str2
init|=
name|l
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|type
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|str1
operator|.
name|startsWith
argument_list|(
name|str2
argument_list|)
condition|)
block|{
if|if
condition|(
name|used
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"used is set to"
operator|<<
name|str2
operator|.
name|size
argument_list|()
expr_stmt|;
operator|*
name|used
operator|=
name|str2
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|usedMonth
condition|)
operator|*
name|usedMonth
operator|=
name|l
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|month
return|;
block|}
if|if
condition|(
name|context
operator|==
name|FromString
condition|)
continue|continue;
specifier|const
name|int
name|limit
init|=
name|qMin
argument_list|(
name|str1
operator|.
name|size
argument_list|()
argument_list|,
name|str2
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|QDTPDEBUG
operator|<<
literal|"limit is"
operator|<<
name|limit
operator|<<
name|str1
operator|<<
name|str2
expr_stmt|;
name|bool
name|equal
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|str1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|str2
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|equal
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|bestCount
condition|)
block|{
name|bestCount
operator|=
name|i
expr_stmt|;
name|bestMatch
operator|=
name|month
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|equal
condition|)
block|{
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|usedMonth
condition|)
operator|*
name|usedMonth
operator|=
name|l
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|month
return|;
block|}
block|}
if|if
condition|(
name|usedMonth
operator|&&
name|bestMatch
operator|!=
operator|-
literal|1
condition|)
operator|*
name|usedMonth
operator|=
name|l
operator|.
name|monthName
argument_list|(
name|bestMatch
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|used
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"used is set to"
operator|<<
name|bestCount
expr_stmt|;
operator|*
name|used
operator|=
name|bestCount
expr_stmt|;
block|}
return|return
name|bestMatch
return|;
block|}
end_function
begin_function
DECL|function|findDay
name|int
name|QDateTimeParser
operator|::
name|findDay
parameter_list|(
specifier|const
name|QString
modifier|&
name|str1
parameter_list|,
name|int
name|startDay
parameter_list|,
name|int
name|sectionIndex
parameter_list|,
name|QString
modifier|*
name|usedDay
parameter_list|,
name|int
modifier|*
name|used
parameter_list|)
specifier|const
block|{
name|int
name|bestMatch
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bestCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|str1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sn
operator|.
name|type
operator|&
operator|(
name|DaySection
operator||
name|DayOfWeekSectionShort
operator||
name|DayOfWeekSectionLong
operator|)
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::findDay Internal error"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
specifier|const
name|QLocale
name|l
init|=
name|locale
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|day
init|=
name|startDay
init|;
name|day
operator|<=
literal|7
condition|;
operator|++
name|day
control|)
block|{
specifier|const
name|QString
name|str2
init|=
name|l
operator|.
name|dayName
argument_list|(
name|day
argument_list|,
name|sn
operator|.
name|count
operator|==
literal|4
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|str1
operator|.
name|startsWith
argument_list|(
name|str2
operator|.
name|toLower
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|str2
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|usedDay
condition|)
block|{
operator|*
name|usedDay
operator|=
name|str2
expr_stmt|;
block|}
return|return
name|day
return|;
block|}
if|if
condition|(
name|context
operator|==
name|FromString
condition|)
continue|continue;
specifier|const
name|int
name|limit
init|=
name|qMin
argument_list|(
name|str1
operator|.
name|size
argument_list|()
argument_list|,
name|str2
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|found
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|str1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|str2
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|str1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|bestCount
condition|)
block|{
name|bestCount
operator|=
name|i
expr_stmt|;
name|bestMatch
operator|=
name|day
expr_stmt|;
block|}
name|found
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|usedDay
condition|)
operator|*
name|usedDay
operator|=
name|str2
expr_stmt|;
return|return
name|day
return|;
block|}
block|}
if|if
condition|(
name|usedDay
operator|&&
name|bestMatch
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|usedDay
operator|=
name|l
operator|.
name|dayName
argument_list|(
name|bestMatch
argument_list|,
name|sn
operator|.
name|count
operator|==
literal|4
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|bestCount
expr_stmt|;
return|return
name|bestMatch
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTDATE
end_comment
begin_comment
comment|/*!   \internal    returns   0 if str == QDateTimeEdit::tr("AM")   1 if str == QDateTimeEdit::tr("PM")   2 if str can become QDateTimeEdit::tr("AM")   3 if str can become QDateTimeEdit::tr("PM")   4 if str can become QDateTimeEdit::tr("PM") and can become QDateTimeEdit::tr("AM")   -1 can't become anything sensible  */
end_comment
begin_function
DECL|function|findAmPm
name|int
name|QDateTimeParser
operator|::
name|findAmPm
parameter_list|(
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|index
parameter_list|,
name|int
modifier|*
name|used
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|s
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|type
operator|!=
name|AmPmSection
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::findAmPm Internal error"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|str
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|trimmed
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|PossibleBoth
return|;
block|}
specifier|const
name|QLatin1Char
name|space
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|sectionMaxSize
argument_list|(
name|index
argument_list|)
decl_stmt|;
enum|enum
block|{
name|amindex
init|=
literal|0
block|,
name|pmindex
init|=
literal|1
block|}
enum|;
name|QString
name|ampm
index|[
literal|2
index|]
decl_stmt|;
name|ampm
index|[
name|amindex
index|]
operator|=
name|getAmPmText
argument_list|(
name|AmText
argument_list|,
name|s
operator|.
name|count
operator|==
literal|1
condition|?
name|UpperCase
else|:
name|LowerCase
argument_list|)
expr_stmt|;
name|ampm
index|[
name|pmindex
index|]
operator|=
name|getAmPmText
argument_list|(
name|PmText
argument_list|,
name|s
operator|.
name|count
operator|==
literal|1
condition|?
name|UpperCase
else|:
name|LowerCase
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
name|ampm
index|[
name|i
index|]
operator|.
name|truncate
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"findAmPm"
operator|<<
name|str
operator|<<
name|ampm
index|[
literal|0
index|]
operator|<<
name|ampm
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|indexOf
argument_list|(
name|ampm
index|[
name|amindex
index|]
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
condition|)
block|{
name|str
operator|=
name|ampm
index|[
name|amindex
index|]
expr_stmt|;
return|return
name|AM
return|;
block|}
elseif|else
if|if
condition|(
name|str
operator|.
name|indexOf
argument_list|(
name|ampm
index|[
name|pmindex
index|]
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
condition|)
block|{
name|str
operator|=
name|ampm
index|[
name|pmindex
index|]
expr_stmt|;
return|return
name|PM
return|;
block|}
elseif|else
if|if
condition|(
name|context
operator|==
name|FromString
operator|||
operator|(
name|str
operator|.
name|count
argument_list|(
name|space
argument_list|)
operator|==
literal|0
operator|&&
name|str
operator|.
name|size
argument_list|()
operator|>=
name|size
operator|)
condition|)
block|{
return|return
name|Neither
return|;
block|}
name|size
operator|=
name|qMin
argument_list|(
name|size
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|broken
index|[
literal|2
index|]
init|=
block|{
literal|false
block|,
literal|false
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|space
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
name|broken
index|[
name|j
index|]
condition|)
block|{
name|int
name|index
init|=
name|ampm
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|QDTPDEBUG
operator|<<
literal|"looking for"
operator|<<
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|<<
literal|"in"
operator|<<
name|ampm
index|[
name|j
index|]
operator|<<
literal|"and got"
operator|<<
name|index
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|category
argument_list|()
operator|==
name|QChar
operator|::
name|Letter_Uppercase
condition|)
block|{
name|index
operator|=
name|ampm
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLower
argument_list|()
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"trying with"
operator|<<
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLower
argument_list|()
operator|<<
literal|"in"
operator|<<
name|ampm
index|[
name|j
index|]
operator|<<
literal|"and got"
operator|<<
name|index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|category
argument_list|()
operator|==
name|QChar
operator|::
name|Letter_Lowercase
condition|)
block|{
name|index
operator|=
name|ampm
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toUpper
argument_list|()
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"trying with"
operator|<<
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toUpper
argument_list|()
operator|<<
literal|"in"
operator|<<
name|ampm
index|[
name|j
index|]
operator|<<
literal|"and got"
operator|<<
name|index
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|broken
index|[
name|j
index|]
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|broken
index|[
name|amindex
index|]
operator|&&
name|broken
index|[
name|pmindex
index|]
condition|)
block|{
name|QDTPDEBUG
operator|<<
name|str
operator|<<
literal|"didn't make it"
expr_stmt|;
return|return
name|Neither
return|;
block|}
continue|continue;
block|}
else|else
block|{
name|str
index|[
name|i
index|]
operator|=
name|ampm
index|[
name|j
index|]
operator|.
name|at
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|// fix case
block|}
block|}
name|ampm
index|[
name|j
index|]
operator|.
name|remove
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|broken
index|[
name|pmindex
index|]
operator|&&
operator|!
name|broken
index|[
name|amindex
index|]
condition|)
return|return
name|PossibleBoth
return|;
return|return
operator|(
operator|!
name|broken
index|[
name|amindex
index|]
condition|?
name|PossibleAM
else|:
name|PossiblePM
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Max number of units that can be changed by this section. */
end_comment
begin_function
DECL|function|maxChange
name|int
name|QDateTimeParser
operator|::
name|maxChange
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
comment|// Time. unit is msec
case|case
name|MSecSection
case|:
return|return
literal|999
return|;
case|case
name|SecondSection
case|:
return|return
literal|59
operator|*
literal|1000
return|;
case|case
name|MinuteSection
case|:
return|return
literal|59
operator|*
literal|60
operator|*
literal|1000
return|;
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
return|return
literal|59
operator|*
literal|60
operator|*
literal|60
operator|*
literal|1000
return|;
comment|// Date. unit is day
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
return|return
literal|7
return|;
case|case
name|DaySection
case|:
return|return
literal|30
return|;
case|case
name|MonthSection
case|:
return|return
literal|365
operator|-
literal|31
return|;
case|case
name|YearSection
case|:
return|return
literal|9999
operator|*
literal|365
return|;
case|case
name|YearSection2Digits
case|:
return|return
literal|100
operator|*
literal|365
return|;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::maxChange() Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sectionType
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|fieldInfo
name|QDateTimeParser
operator|::
name|FieldInfo
name|QDateTimeParser
operator|::
name|fieldInfo
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|FieldInfo
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|const
name|Section
name|s
init|=
name|sn
operator|.
name|type
decl_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|MSecSection
case|:
name|ret
operator||=
name|Fraction
expr_stmt|;
comment|// fallthrough
case|case
name|SecondSection
case|:
case|case
name|MinuteSection
case|:
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
case|case
name|YearSection
case|:
case|case
name|YearSection2Digits
case|:
name|ret
operator||=
name|Numeric
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|YearSection
condition|)
block|{
name|ret
operator||=
name|AllowPartial
expr_stmt|;
block|}
if|if
condition|(
name|sn
operator|.
name|count
operator|!=
literal|1
condition|)
block|{
name|ret
operator||=
name|FixedWidth
expr_stmt|;
block|}
break|break;
case|case
name|MonthSection
case|:
case|case
name|DaySection
case|:
switch|switch
condition|(
name|sn
operator|.
name|count
condition|)
block|{
case|case
literal|2
case|:
name|ret
operator||=
name|FixedWidth
expr_stmt|;
comment|// fallthrough
case|case
literal|1
case|:
name|ret
operator||=
operator|(
name|Numeric
operator||
name|AllowPartial
operator|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
if|if
condition|(
name|sn
operator|.
name|count
operator|==
literal|3
condition|)
name|ret
operator||=
name|FixedWidth
expr_stmt|;
break|break;
case|case
name|AmPmSection
case|:
name|ret
operator||=
name|FixedWidth
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::fieldInfo Internal error 2 (%d %s %d)"
argument_list|,
name|index
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|,
name|sn
operator|.
name|count
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Get a number that str can become which is between min   and max or -1 if this is not possible. */
end_comment
begin_function
DECL|function|sectionFormat
name|QString
name|QDateTimeParser
operator|::
name|sectionFormat
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|sectionFormat
argument_list|(
name|sn
operator|.
name|type
argument_list|,
name|sn
operator|.
name|count
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sectionFormat
name|QString
name|QDateTimeParser
operator|::
name|sectionFormat
parameter_list|(
name|Section
name|s
parameter_list|,
name|int
name|count
parameter_list|)
specifier|const
block|{
name|QChar
name|fillChar
decl_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|AmPmSection
case|:
return|return
name|count
operator|==
literal|1
condition|?
name|QLatin1String
argument_list|(
literal|"AP"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"ap"
argument_list|)
return|;
case|case
name|MSecSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'z'
argument_list|)
expr_stmt|;
break|break;
case|case
name|SecondSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
break|break;
case|case
name|MinuteSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'m'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Hour24Section
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'H'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Hour12Section
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'h'
argument_list|)
expr_stmt|;
break|break;
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
case|case
name|DaySection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
break|break;
case|case
name|MonthSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
break|break;
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'y'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionFormat Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
if|if
condition|(
name|fillChar
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionFormat Internal error 2"
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QString
name|str
decl_stmt|;
name|str
operator|.
name|fill
argument_list|(
name|fillChar
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns true if str can be modified to represent a   number that is within min and max. */
end_comment
begin_function
DECL|function|potentialValue
name|bool
name|QDateTimeParser
operator|::
name|potentialValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|currentValue
parameter_list|,
name|int
name|insert
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|const
name|int
name|size
init|=
name|sectionMaxSize
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|val
init|=
operator|(
name|int
operator|)
name|locale
argument_list|()
operator|.
name|toUInt
argument_list|(
name|str
argument_list|)
decl_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|==
name|YearSection2Digits
condition|)
block|{
name|val
operator|+=
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
operator|-
operator|(
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
operator|%
literal|100
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|>=
name|min
operator|&&
name|val
operator|<=
name|max
operator|&&
name|str
operator|.
name|size
argument_list|()
operator|==
name|size
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|val
operator|>
name|max
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|str
operator|.
name|size
argument_list|()
operator|==
name|size
operator|&&
name|val
operator|<
name|min
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|const
name|int
name|len
init|=
name|size
operator|-
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|potentialValue
argument_list|(
name|str
operator|+
name|QLatin1Char
argument_list|(
literal|'0'
operator|+
name|j
argument_list|)
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|index
argument_list|,
name|currentValue
argument_list|,
name|insert
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|insert
operator|>=
literal|0
condition|)
block|{
name|QString
name|tmp
init|=
name|str
decl_stmt|;
name|tmp
operator|.
name|insert
argument_list|(
name|insert
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
operator|+
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|potentialValue
argument_list|(
name|tmp
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|index
argument_list|,
name|currentValue
argument_list|,
name|insert
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|skipToNextSection
name|bool
name|QDateTimeParser
operator|::
name|skipToNextSection
parameter_list|(
name|int
name|index
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|current
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|current
operator|>=
name|getMinimum
argument_list|()
operator|&&
name|current
operator|<=
name|getMaximum
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|SectionNode
modifier|&
name|node
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|text
operator|.
name|size
argument_list|()
operator|<
name|sectionMaxSize
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|QDateTime
name|maximum
init|=
name|getMaximum
argument_list|()
decl_stmt|;
specifier|const
name|QDateTime
name|minimum
init|=
name|getMinimum
argument_list|()
decl_stmt|;
name|QDateTime
name|tmp
init|=
name|current
decl_stmt|;
name|int
name|min
init|=
name|absoluteMin
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|setDigit
argument_list|(
name|tmp
argument_list|,
name|index
argument_list|,
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|minimum
condition|)
block|{
name|min
operator|=
name|getDigit
argument_list|(
name|minimum
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|max
init|=
name|absoluteMax
argument_list|(
name|index
argument_list|,
name|current
argument_list|)
decl_stmt|;
name|setDigit
argument_list|(
name|tmp
argument_list|,
name|index
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|maximum
condition|)
block|{
name|max
operator|=
name|getDigit
argument_list|(
name|maximum
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|pos
init|=
name|cursorPosition
argument_list|()
operator|-
name|node
operator|.
name|pos
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>=
name|text
operator|.
name|size
argument_list|()
condition|)
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
specifier|const
name|bool
name|potential
init|=
name|potentialValue
argument_list|(
name|text
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|index
argument_list|,
name|current
argument_list|,
name|pos
argument_list|)
decl_stmt|;
return|return
operator|!
name|potential
return|;
comment|/* If the value potentially can become another valid entry we      * don't want to skip to the next. E.g. In a M field (month      * without leading 0 if you type 1 we don't want to autoskip but      * if you type 3 we do     */
block|}
end_function
begin_comment
comment|/*!   \internal   For debugging. Returns the name of the section \a s. */
end_comment
begin_function
DECL|function|sectionName
name|QString
name|QDateTimeParser
operator|::
name|sectionName
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|QDateTimeParser
operator|::
name|AmPmSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"AmPmSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|DaySection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"DaySection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|DayOfWeekSectionShort
case|:
return|return
name|QLatin1String
argument_list|(
literal|"DayOfWeekSectionShort"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|DayOfWeekSectionLong
case|:
return|return
name|QLatin1String
argument_list|(
literal|"DayOfWeekSectionLong"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|Hour24Section
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Hour24Section"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|Hour12Section
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Hour12Section"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|MSecSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"MSecSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|MinuteSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"MinuteSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|MonthSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"MonthSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|SecondSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"SecondSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|YearSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"YearSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|YearSection2Digits
case|:
return|return
name|QLatin1String
argument_list|(
literal|"YearSection2Digits"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|NoSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"NoSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|FirstSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"FirstSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|LastSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"LastSection"
argument_list|)
return|;
default|default:
return|return
name|QLatin1String
argument_list|(
literal|"Unknown section "
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   \internal   For debugging. Returns the name of the state \a s. */
end_comment
begin_function
DECL|function|stateName
name|QString
name|QDateTimeParser
operator|::
name|stateName
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|Invalid
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Invalid"
argument_list|)
return|;
case|case
name|Intermediate
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Intermediate"
argument_list|)
return|;
case|case
name|Acceptable
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Acceptable"
argument_list|)
return|;
default|default:
return|return
name|QLatin1String
argument_list|(
literal|"Unknown state "
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function
DECL|function|fromString
name|bool
name|QDateTimeParser
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|,
name|QDate
modifier|*
name|date
parameter_list|,
name|QTime
modifier|*
name|time
parameter_list|)
specifier|const
block|{
name|QDateTime
name|val
argument_list|(
name|QDate
argument_list|(
literal|1900
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|QDATETIMEEDIT_TIME_MIN
argument_list|)
decl_stmt|;
name|QString
name|text
init|=
name|t
decl_stmt|;
name|int
name|copy
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|StateNode
name|tmp
init|=
name|parse
argument_list|(
name|text
argument_list|,
name|copy
argument_list|,
name|val
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|state
operator|!=
name|Acceptable
operator|||
name|tmp
operator|.
name|conflicts
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|time
condition|)
block|{
specifier|const
name|QTime
name|t
init|=
name|tmp
operator|.
name|value
operator|.
name|time
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|time
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|date
condition|)
block|{
specifier|const
name|QDate
name|d
init|=
name|tmp
operator|.
name|value
operator|.
name|date
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|date
operator|=
name|d
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_function
DECL|function|getMinimum
name|QDateTime
name|QDateTimeParser
operator|::
name|getMinimum
parameter_list|()
specifier|const
block|{
return|return
name|QDateTime
argument_list|(
name|QDATETIMEEDIT_DATE_MIN
argument_list|,
name|QDATETIMEEDIT_TIME_MIN
argument_list|,
name|spec
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getMaximum
name|QDateTime
name|QDateTimeParser
operator|::
name|getMaximum
parameter_list|()
specifier|const
block|{
return|return
name|QDateTime
argument_list|(
name|QDATETIMEEDIT_DATE_MAX
argument_list|,
name|QDATETIMEEDIT_TIME_MAX
argument_list|,
name|spec
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getAmPmText
name|QString
name|QDateTimeParser
operator|::
name|getAmPmText
parameter_list|(
name|AmPm
name|ap
parameter_list|,
name|Case
name|cs
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|ap
operator|==
name|AmText
condition|)
block|{
return|return
operator|(
name|cs
operator|==
name|UpperCase
condition|?
name|QLatin1String
argument_list|(
literal|"AM"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"am"
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|cs
operator|==
name|UpperCase
condition|?
name|QLatin1String
argument_list|(
literal|"PM"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"pm"
argument_list|)
operator|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*   \internal    I give arg2 preference because arg1 is always a QDateTime. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QDateTimeParser
operator|::
name|SectionNode
modifier|&
name|s1
parameter_list|,
specifier|const
name|QDateTimeParser
operator|::
name|SectionNode
modifier|&
name|s2
parameter_list|)
block|{
return|return
operator|(
name|s1
operator|.
name|type
operator|==
name|s2
operator|.
name|type
operator|)
operator|&&
operator|(
name|s1
operator|.
name|pos
operator|==
name|s2
operator|.
name|pos
operator|)
operator|&&
operator|(
name|s1
operator|.
name|count
operator|==
name|s2
operator|.
name|count
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BOOTSTRAPPED
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
