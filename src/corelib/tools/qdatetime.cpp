begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"private/qdatetime_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qdatetimeparser_p.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qset.h"
end_include
begin_include
include|#
directive|include
file|"qlocale.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qregexp.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_WIN
end_ifndef
begin_include
include|#
directive|include
file|<locale.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<cmath>
end_include
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_include
include|#
directive|include
file|<qt_windows.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WINCE
end_ifdef
begin_include
include|#
directive|include
file|"qfunctions_wince.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_include
include|#
directive|include
file|<private/qcore_mac_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|enum
type|{
DECL|enumerator|SECS_PER_DAY
name|SECS_PER_DAY
init|=
literal|86400
decl_stmt|,
DECL|enumerator|MSECS_PER_DAY
name|MSECS_PER_DAY
init|=
literal|86400000
decl_stmt|,
DECL|enumerator|SECS_PER_HOUR
name|SECS_PER_HOUR
init|=
literal|3600
decl_stmt|,
DECL|enumerator|MSECS_PER_HOUR
name|MSECS_PER_HOUR
init|=
literal|3600000
decl_stmt|,
DECL|enumerator|SECS_PER_MIN
name|SECS_PER_MIN
init|=
literal|60
decl_stmt|,
DECL|enumerator|MSECS_PER_MIN
name|MSECS_PER_MIN
init|=
literal|60000
decl_stmt|,
DECL|enumerator|TIME_T_MAX
name|TIME_T_MAX
init|=
literal|2145916799
decl_stmt|,
comment|// int maximum 2037-12-31T23:59:59 UTC
DECL|enumerator|JULIAN_DAY_FOR_EPOCH
name|JULIAN_DAY_FOR_EPOCH
init|=
literal|2440588
end_decl_stmt
begin_comment
DECL|enumerator|JULIAN_DAY_FOR_EPOCH
comment|// result of julianDayFromDate(1970, 1, 1)
end_comment
begin_function
DECL|enumerator|JULIAN_DAY_FOR_EPOCH
unit|};
DECL|function|fixedDate
specifier|static
specifier|inline
name|QDate
name|fixedDate
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|QDate
name|result
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|result
operator|.
name|setDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|qMin
argument_list|(
name|d
argument_list|,
name|result
operator|.
name|daysInMonth
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|floordiv
specifier|static
specifier|inline
name|qint64
name|floordiv
parameter_list|(
name|qint64
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|-
operator|(
name|a
operator|<
literal|0
condition|?
name|b
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
operator|/
name|b
return|;
block|}
end_function
begin_function
DECL|function|floordiv
specifier|static
specifier|inline
name|int
name|floordiv
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|-
operator|(
name|a
operator|<
literal|0
condition|?
name|b
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
operator|/
name|b
return|;
block|}
end_function
begin_function
DECL|function|julianDayFromDate
specifier|static
specifier|inline
name|qint64
name|julianDayFromDate
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
comment|// Adjust for no year 0
if|if
condition|(
name|year
operator|<
literal|0
condition|)
operator|++
name|year
expr_stmt|;
comment|/*  * Math from The Calendar FAQ at http://www.tondering.dk/claus/cal/julperiod.php  * This formula is correct for all julian days, when using mathematical integer  * division (round to negative infinity), not c++11 integer division (round to zero)  */
name|int
name|a
init|=
name|floordiv
argument_list|(
literal|14
operator|-
name|month
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|qint64
name|y
init|=
operator|(
name|qint64
operator|)
name|year
operator|+
literal|4800
operator|-
name|a
decl_stmt|;
name|int
name|m
init|=
name|month
operator|+
literal|12
operator|*
name|a
operator|-
literal|3
decl_stmt|;
return|return
name|day
operator|+
name|floordiv
argument_list|(
literal|153
operator|*
name|m
operator|+
literal|2
argument_list|,
literal|5
argument_list|)
operator|+
literal|365
operator|*
name|y
operator|+
name|floordiv
argument_list|(
name|y
argument_list|,
literal|4
argument_list|)
operator|-
name|floordiv
argument_list|(
name|y
argument_list|,
literal|100
argument_list|)
operator|+
name|floordiv
argument_list|(
name|y
argument_list|,
literal|400
argument_list|)
operator|-
literal|32045
return|;
block|}
end_function
begin_function
DECL|function|getDateFromJulianDay
specifier|static
name|void
name|getDateFromJulianDay
parameter_list|(
name|qint64
name|julianDay
parameter_list|,
name|int
modifier|*
name|yearp
parameter_list|,
name|int
modifier|*
name|monthp
parameter_list|,
name|int
modifier|*
name|dayp
parameter_list|)
block|{
comment|/*  * Math from The Calendar FAQ at http://www.tondering.dk/claus/cal/julperiod.php  * This formula is correct for all julian days, when using mathematical integer  * division (round to negative infinity), not c++11 integer division (round to zero)  */
name|qint64
name|a
init|=
name|julianDay
operator|+
literal|32044
decl_stmt|;
name|qint64
name|b
init|=
name|floordiv
argument_list|(
literal|4
operator|*
name|a
operator|+
literal|3
argument_list|,
literal|146097
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|a
operator|-
name|floordiv
argument_list|(
literal|146097
operator|*
name|b
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|int
name|d
init|=
name|floordiv
argument_list|(
literal|4
operator|*
name|c
operator|+
literal|3
argument_list|,
literal|1461
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|c
operator|-
name|floordiv
argument_list|(
literal|1461
operator|*
name|d
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|int
name|m
init|=
name|floordiv
argument_list|(
literal|5
operator|*
name|e
operator|+
literal|2
argument_list|,
literal|153
argument_list|)
decl_stmt|;
name|int
name|day
init|=
name|e
operator|-
name|floordiv
argument_list|(
literal|153
operator|*
name|m
operator|+
literal|2
argument_list|,
literal|5
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|month
init|=
name|m
operator|+
literal|3
operator|-
literal|12
operator|*
name|floordiv
argument_list|(
name|m
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|int
name|year
init|=
literal|100
operator|*
name|b
operator|+
name|d
operator|-
literal|4800
operator|+
name|floordiv
argument_list|(
name|m
argument_list|,
literal|10
argument_list|)
decl_stmt|;
comment|// Adjust for no year 0
if|if
condition|(
name|year
operator|<=
literal|0
condition|)
operator|--
name|year
expr_stmt|;
if|if
condition|(
name|yearp
condition|)
operator|*
name|yearp
operator|=
name|year
expr_stmt|;
if|if
condition|(
name|monthp
condition|)
operator|*
name|monthp
operator|=
name|month
expr_stmt|;
if|if
condition|(
name|dayp
condition|)
operator|*
name|dayp
operator|=
name|day
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|monthDays
specifier|static
specifier|const
name|char
name|monthDays
index|[]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_decl_stmt
DECL|variable|qt_shortMonthNames
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|qt_shortMonthNames
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_monthNumberFromShortName
name|int
name|qt_monthNumberFromShortName
parameter_list|(
specifier|const
name|QString
modifier|&
name|shortName
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|qt_shortMonthNames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|qt_shortMonthNames
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|shortName
operator|==
name|QLatin1String
argument_list|(
name|qt_shortMonthNames
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
operator|+
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function_decl
specifier|static
name|void
name|rfcDateImpl
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|QDate
modifier|*
name|dd
init|=
literal|0
parameter_list|,
name|QTime
modifier|*
name|dt
init|=
literal|0
parameter_list|,
name|int
modifier|*
name|utfcOffset
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Return offset in [+-]HH:MM format
end_comment
begin_comment
comment|// Qt::ISODate puts : between the hours and minutes, but Qt:TextDate does not
end_comment
begin_function
DECL|function|toOffsetString
specifier|static
name|QString
name|toOffsetString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|Qt
operator|::
name|TextDate
condition|)
name|result
operator|=
name|QStringLiteral
argument_list|(
literal|"%1%2%3"
argument_list|)
expr_stmt|;
else|else
comment|// Qt::ISODate
name|result
operator|=
name|QStringLiteral
argument_list|(
literal|"%1%2:%3"
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|arg
argument_list|(
name|offset
operator|>=
literal|0
condition|?
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
else|:
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|qAbs
argument_list|(
name|offset
argument_list|)
operator|/
name|SECS_PER_HOUR
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
operator|(
name|offset
operator|/
literal|60
operator|)
operator|%
literal|60
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// Parse offset in [+-]HH[:]MM format
end_comment
begin_function
DECL|function|fromOffsetString
specifier|static
name|int
name|fromOffsetString
parameter_list|(
specifier|const
name|QString
modifier|&
name|offsetString
parameter_list|,
name|bool
modifier|*
name|valid
parameter_list|)
block|{
operator|*
name|valid
operator|=
literal|false
expr_stmt|;
specifier|const
name|int
name|size
init|=
name|offsetString
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
argument_list|<
literal|2
operator|||
name|size
argument_list|>
literal|6
condition|)
return|return
literal|0
return|;
comment|// First char must be + or -
specifier|const
name|QChar
name|sign
init|=
name|offsetString
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sign
operator|!=
name|QLatin1Char
argument_list|(
literal|'+'
argument_list|)
operator|&&
name|sign
operator|!=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
condition|)
return|return
literal|0
return|;
comment|// Split the hour and minute parts
name|QStringList
name|parts
init|=
name|offsetString
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// [+-]HHMM format
name|parts
operator|.
name|append
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|mid
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|left
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|bool
name|ok
init|=
literal|false
decl_stmt|;
specifier|const
name|int
name|hour
init|=
name|parts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|0
return|;
specifier|const
name|int
name|minute
init|=
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
operator|||
name|minute
argument_list|<
literal|0
operator|||
name|minute
argument_list|>
literal|59
condition|)
return|return
literal|0
return|;
operator|*
name|valid
operator|=
literal|true
expr_stmt|;
return|return
operator|(
operator|(
name|hour
operator|*
literal|60
operator|)
operator|+
name|minute
operator|)
operator|*
literal|60
return|;
block|}
end_function
begin_comment
comment|// Returns the tzname, assume tzset has been called already
end_comment
begin_function
DECL|function|qt_tzname
specifier|static
name|QString
name|qt_tzname
parameter_list|(
name|QDateTimePrivate
operator|::
name|DaylightStatus
name|daylightStatus
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|TIME_ZONE_INFORMATION
name|tzi
decl_stmt|;
name|DWORD
name|res
init|=
name|GetTimeZoneInformation
argument_list|(
operator|&
name|tzi
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|TIME_ZONE_ID_UNKNOWN
condition|)
return|return
name|QString
argument_list|()
return|;
elseif|else
if|if
condition|(
name|daylightStatus
operator|==
name|QDateTimePrivate
operator|::
name|DaylightTime
condition|)
return|return
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|tzi
operator|.
name|DaylightName
argument_list|)
return|;
else|else
return|return
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|tzi
operator|.
name|StandardName
argument_list|)
return|;
else|#
directive|else
name|int
name|isDst
init|=
operator|(
name|daylightStatus
operator|==
name|QDateTimePrivate
operator|::
name|DaylightTime
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
name|size_t
name|s
init|=
literal|0
decl_stmt|;
name|char
name|name
index|[
literal|512
index|]
decl_stmt|;
if|if
condition|(
name|_get_tzname
argument_list|(
operator|&
name|s
argument_list|,
name|name
argument_list|,
literal|512
argument_list|,
name|isDst
argument_list|)
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|name
argument_list|)
return|;
else|#
directive|else
return|return
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|tzname
index|[
name|isDst
index|]
argument_list|)
return|;
endif|#
directive|endif
comment|// Q_OS_WIN
endif|#
directive|endif
comment|// Q_OS_WINCE
block|}
end_function
begin_comment
comment|// Calls the platform variant of mktime for the given date and time,
end_comment
begin_comment
comment|// and updates the date, time, daylightStatus and abbreviation with the returned values
end_comment
begin_comment
comment|// If the date falls outside the 1970 to 2037 range supported by mktime / time_t
end_comment
begin_comment
comment|// then null date/time will be returned, you should adjust the date first if
end_comment
begin_comment
comment|// you need a guaranteed result.
end_comment
begin_function
DECL|function|qt_mktime
specifier|static
name|qint64
name|qt_mktime
parameter_list|(
name|QDate
modifier|*
name|date
parameter_list|,
name|QTime
modifier|*
name|time
parameter_list|,
name|QDateTimePrivate
operator|::
name|DaylightStatus
modifier|*
name|daylightStatus
parameter_list|,
name|QString
modifier|*
name|abbreviation
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
specifier|const
name|qint64
name|msec
init|=
name|time
operator|->
name|msec
argument_list|()
decl_stmt|;
name|int
name|yy
decl_stmt|,
name|mm
decl_stmt|,
name|dd
decl_stmt|;
name|date
operator|->
name|getDate
argument_list|(
operator|&
name|yy
argument_list|,
operator|&
name|mm
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
comment|// WinCE doesn't provide standard C library time functions
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|.
name|wSecond
operator|=
name|time
operator|->
name|second
argument_list|()
expr_stmt|;
name|st
operator|.
name|wMinute
operator|=
name|time
operator|->
name|minute
argument_list|()
expr_stmt|;
name|st
operator|.
name|wHour
operator|=
name|time
operator|->
name|hour
argument_list|()
expr_stmt|;
name|st
operator|.
name|wDay
operator|=
name|dd
expr_stmt|;
name|st
operator|.
name|wMonth
operator|=
name|mm
expr_stmt|;
name|st
operator|.
name|wYear
operator|=
name|yy
expr_stmt|;
name|FILETIME
name|lft
decl_stmt|;
name|bool
name|valid
init|=
name|SystemTimeToFileTime
argument_list|(
operator|&
name|st
argument_list|,
operator|&
name|lft
argument_list|)
decl_stmt|;
name|FILETIME
name|ft
decl_stmt|;
if|if
condition|(
name|valid
condition|)
name|valid
operator|=
name|LocalFileTimeToFileTime
argument_list|(
operator|&
name|lft
argument_list|,
operator|&
name|ft
argument_list|)
expr_stmt|;
specifier|const
name|time_t
name|secsSinceEpoch
init|=
name|ftToTime_t
argument_list|(
name|ft
argument_list|)
decl_stmt|;
specifier|const
name|time_t
name|localSecs
init|=
name|ftToTime_t
argument_list|(
name|lft
argument_list|)
decl_stmt|;
name|TIME_ZONE_INFORMATION
name|tzi
decl_stmt|;
name|GetTimeZoneInformation
argument_list|(
operator|&
name|tzi
argument_list|)
expr_stmt|;
name|bool
name|isDaylight
init|=
literal|false
decl_stmt|;
comment|// Check for overflow
name|qint64
name|localDiff
init|=
name|qAbs
argument_list|(
name|localSecs
operator|-
name|secsSinceEpoch
argument_list|)
decl_stmt|;
name|int
name|daylightOffset
init|=
name|qAbs
argument_list|(
name|tzi
operator|.
name|Bias
operator|+
name|tzi
operator|.
name|DaylightBias
argument_list|)
operator|*
literal|60
decl_stmt|;
if|if
condition|(
name|localDiff
operator|>
name|daylightOffset
condition|)
name|valid
operator|=
literal|false
expr_stmt|;
else|else
name|isDaylight
operator|=
operator|(
name|localDiff
operator|==
name|daylightOffset
operator|)
expr_stmt|;
if|if
condition|(
name|daylightStatus
condition|)
block|{
if|if
condition|(
name|isDaylight
condition|)
operator|*
name|daylightStatus
operator|=
name|QDateTimePrivate
operator|::
name|DaylightTime
expr_stmt|;
else|else
operator|*
name|daylightStatus
operator|=
name|QDateTimePrivate
operator|::
name|StandardTime
expr_stmt|;
block|}
if|if
condition|(
name|abbreviation
condition|)
block|{
if|if
condition|(
name|isDaylight
condition|)
operator|*
name|abbreviation
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|tzi
operator|.
name|DaylightName
argument_list|)
expr_stmt|;
else|else
operator|*
name|abbreviation
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|tzi
operator|.
name|StandardName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
name|valid
expr_stmt|;
else|#
directive|else
comment|// All other platforms provide standard C library time functions
name|tm
name|local
decl_stmt|;
name|local
operator|.
name|tm_sec
operator|=
name|time
operator|->
name|second
argument_list|()
expr_stmt|;
name|local
operator|.
name|tm_min
operator|=
name|time
operator|->
name|minute
argument_list|()
expr_stmt|;
name|local
operator|.
name|tm_hour
operator|=
name|time
operator|->
name|hour
argument_list|()
expr_stmt|;
name|local
operator|.
name|tm_mday
operator|=
name|dd
expr_stmt|;
name|local
operator|.
name|tm_mon
operator|=
name|mm
operator|-
literal|1
expr_stmt|;
name|local
operator|.
name|tm_year
operator|=
name|yy
operator|-
literal|1900
expr_stmt|;
name|local
operator|.
name|tm_wday
operator|=
literal|0
expr_stmt|;
name|local
operator|.
name|tm_yday
operator|=
literal|0
expr_stmt|;
name|local
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|int
name|hh
init|=
name|local
operator|.
name|tm_hour
decl_stmt|;
endif|#
directive|endif
comment|// Q_OS_WIN
name|time_t
name|secsSinceEpoch
init|=
name|mktime
argument_list|(
operator|&
name|local
argument_list|)
decl_stmt|;
if|if
condition|(
name|secsSinceEpoch
operator|!=
name|time_t
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
operator|*
name|date
operator|=
name|QDate
argument_list|(
name|local
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|local
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|local
operator|.
name|tm_mday
argument_list|)
expr_stmt|;
operator|*
name|time
operator|=
name|QTime
argument_list|(
name|local
operator|.
name|tm_hour
argument_list|,
name|local
operator|.
name|tm_min
argument_list|,
name|local
operator|.
name|tm_sec
argument_list|,
name|msec
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
comment|// Windows mktime for the missing hour subtracts 1 hour from the time
comment|// instead of adding 1 hour.  If time differs and is standard time then
comment|// this has happened, so add 2 hours to the time and 1 hour to the msecs
if|if
condition|(
name|local
operator|.
name|tm_isdst
operator|==
literal|0
operator|&&
name|local
operator|.
name|tm_hour
operator|!=
name|hh
condition|)
block|{
if|if
condition|(
name|time
operator|->
name|hour
argument_list|()
operator|>=
literal|22
condition|)
operator|*
name|date
operator|=
name|date
operator|->
name|addDays
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|time
operator|=
name|time
operator|->
name|addSecs
argument_list|(
literal|2
operator|*
name|SECS_PER_HOUR
argument_list|)
expr_stmt|;
name|secsSinceEpoch
operator|+=
name|SECS_PER_HOUR
expr_stmt|;
name|local
operator|.
name|tm_isdst
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Q_OS_WIN
if|if
condition|(
name|local
operator|.
name|tm_isdst
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|daylightStatus
condition|)
operator|*
name|daylightStatus
operator|=
name|QDateTimePrivate
operator|::
name|DaylightTime
expr_stmt|;
if|if
condition|(
name|abbreviation
condition|)
operator|*
name|abbreviation
operator|=
name|qt_tzname
argument_list|(
name|QDateTimePrivate
operator|::
name|DaylightTime
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local
operator|.
name|tm_isdst
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|daylightStatus
condition|)
operator|*
name|daylightStatus
operator|=
name|QDateTimePrivate
operator|::
name|StandardTime
expr_stmt|;
if|if
condition|(
name|abbreviation
condition|)
operator|*
name|abbreviation
operator|=
name|qt_tzname
argument_list|(
name|QDateTimePrivate
operator|::
name|StandardTime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|daylightStatus
condition|)
operator|*
name|daylightStatus
operator|=
name|QDateTimePrivate
operator|::
name|UnknownDaylightTime
expr_stmt|;
if|if
condition|(
name|abbreviation
condition|)
operator|*
name|abbreviation
operator|=
name|qt_tzname
argument_list|(
name|QDateTimePrivate
operator|::
name|StandardTime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
operator|*
name|date
operator|=
name|QDate
argument_list|()
expr_stmt|;
operator|*
name|time
operator|=
name|QTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|daylightStatus
condition|)
operator|*
name|daylightStatus
operator|=
name|QDateTimePrivate
operator|::
name|UnknownDaylightTime
expr_stmt|;
if|if
condition|(
name|abbreviation
condition|)
operator|*
name|abbreviation
operator|=
name|QString
argument_list|()
expr_stmt|;
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Q_OS_WINCE
return|return
operator|(
operator|(
name|qint64
operator|)
name|secsSinceEpoch
operator|*
literal|1000
operator|)
operator|+
name|msec
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QDate member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \since 4.5      \enum QDate::MonthNameType      This enum describes the types of the string representation used     for the month name.      \value DateFormat This type of name can be used for date-to-string formatting.     \value StandaloneFormat This type is used when you need to enumerate months or weekdays.            Usually standalone names are represented in singular forms with            capitalized first letter. */
end_comment
begin_comment
comment|/*!     \class QDate     \inmodule QtCore     \reentrant     \brief The QDate class provides date functions.       A QDate object contains a calendar date, i.e. year, month, and day     numbers, in the Gregorian calendar. It can read the current date     from the system clock. It provides functions for comparing dates,     and for manipulating dates. For example, it is possible to add     and subtract days, months, and years to dates.      A QDate object is typically created by giving the year,     month, and day numbers explicitly. Note that QDate interprets two     digit years as is, i.e., years 0 - 99. A QDate can also be     constructed with the static function currentDate(), which creates     a QDate object containing the system clock's date.  An explicit     date can also be set using setDate(). The fromString() function     returns a QDate given a string and a date format which is used to     interpret the date within the string.      The year(), month(), and day() functions provide access to the     year, month, and day numbers. Also, dayOfWeek() and dayOfYear()     functions are provided. The same information is provided in     textual format by the toString(), shortDayName(), longDayName(),     shortMonthName(), and longMonthName() functions.      QDate provides a full set of operators to compare two QDate     objects where smaller means earlier, and larger means later.      You can increment (or decrement) a date by a given number of days     using addDays(). Similarly you can use addMonths() and addYears().     The daysTo() function returns the number of days between two     dates.      The daysInMonth() and daysInYear() functions return how many days     there are in this date's month and year, respectively. The     isLeapYear() function indicates whether a date is in a leap year.      \section1      \section2 No Year 0      There is no year 0. Dates in that year are considered invalid. The     year -1 is the year "1 before Christ" or "1 before current era."     The day before 1 January 1 CE is 31 December 1 BCE.      \section2 Range of Valid Dates      Dates are stored internally as a Julian Day number, an integer count of     every day in a contiguous range, with 24 November 4714 BCE in the Gregorian     calendar being Julian Day 0 (1 January 4713 BCE in the Julian calendar).     As well as being an efficient and accurate way of storing an absolute date,     it is suitable for converting a Date into other calendar systems such as     Hebrew, Islamic or Chinese. The Julian Day number can be obtained using     QDate::toJulianDay() and can be set using QDate::fromJulianDay().      The range of dates able to be stored by QDate as a Julian Day number is     for technical reasons limited to between -784350574879 and 784354017364,     which means from before 2 billion BCE to after 2 billion CE.      \sa QTime, QDateTime, QDateEdit, QDateTimeEdit, QCalendarWidget */
end_comment
begin_comment
comment|/*!     \fn QDate::QDate()      Constructs a null date. Null dates are invalid.      \sa isNull(), isValid() */
end_comment
begin_comment
comment|/*!     Constructs a date with year \a y, month \a m and day \a d.      If the specified date is invalid, the date is not set and     isValid() returns false.      \warning Years 1 to 99 are interpreted as is. Year 0 is invalid.      \sa isValid() */
end_comment
begin_constructor
DECL|function|QDate
name|QDate
operator|::
name|QDate
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|setDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn bool QDate::isNull() const      Returns true if the date is null; otherwise returns false. A null     date is invalid.      \note The behavior of this function is equivalent to isValid().      \sa isValid() */
end_comment
begin_comment
comment|/*!     \fn bool QDate::isValid() const      Returns true if this date is valid; otherwise returns false.      \sa isNull() */
end_comment
begin_comment
comment|/*!     Returns the year of this date. Negative numbers indicate years     before 1 CE, such that year -44 is 44 BCE.      Returns 0 if the date is invalid.      \sa month(), day() */
end_comment
begin_function
DECL|function|year
name|int
name|QDate
operator|::
name|year
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|y
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number corresponding to the month of this date, using     the following convention:      \list     \li 1 = "January"     \li 2 = "February"     \li 3 = "March"     \li 4 = "April"     \li 5 = "May"     \li 6 = "June"     \li 7 = "July"     \li 8 = "August"     \li 9 = "September"     \li 10 = "October"     \li 11 = "November"     \li 12 = "December"     \endlist      Returns 0 if the date is invalid.      \sa year(), day() */
end_comment
begin_function
DECL|function|month
name|int
name|QDate
operator|::
name|month
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|m
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
literal|0
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the day of the month (1 to 31) of this date.      Returns 0 if the date is invalid.      \sa year(), month(), dayOfWeek() */
end_comment
begin_function
DECL|function|day
name|int
name|QDate
operator|::
name|day
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the weekday (1 = Monday to 7 = Sunday) for this date.      Returns 0 if the date is invalid.      \sa day(), dayOfYear(), Qt::DayOfWeek */
end_comment
begin_function
DECL|function|dayOfWeek
name|int
name|QDate
operator|::
name|dayOfWeek
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|jd
operator|>=
literal|0
condition|)
return|return
operator|(
name|jd
operator|%
literal|7
operator|)
operator|+
literal|1
return|;
else|else
return|return
operator|(
operator|(
name|jd
operator|+
literal|1
operator|)
operator|%
literal|7
operator|)
operator|+
literal|7
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the day of the year (1 to 365 or 366 on leap years) for     this date.      Returns 0 if the date is invalid.      \sa day(), dayOfWeek() */
end_comment
begin_function
DECL|function|dayOfYear
name|int
name|QDate
operator|::
name|dayOfYear
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|jd
operator|-
name|julianDayFromDate
argument_list|(
name|year
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days in the month (28 to 31) for this date.      Returns 0 if the date is invalid.      \sa day(), daysInYear() */
end_comment
begin_function
DECL|function|daysInMonth
name|int
name|QDate
operator|::
name|daysInMonth
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|y
decl_stmt|,
name|m
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|2
operator|&&
name|isLeapYear
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|29
return|;
else|else
return|return
name|monthDays
index|[
name|m
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days in the year (365 or 366) for this date.      Returns 0 if the date is invalid.      \sa day(), daysInMonth() */
end_comment
begin_function
DECL|function|daysInYear
name|int
name|QDate
operator|::
name|daysInYear
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|y
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|isLeapYear
argument_list|(
name|y
argument_list|)
condition|?
literal|366
else|:
literal|365
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the week number (1 to 53), and stores the year in     *\a{yearNumber} unless \a yearNumber is null (the default).      Returns 0 if the date is invalid.      In accordance with ISO 8601, weeks start on Monday and the first     Thursday of a year is always in week 1 of that year. Most years     have 52 weeks, but some have 53.      *\a{yearNumber} is not always the same as year(). For example, 1     January 2000 has week number 52 in the year 1999, and 31 December     2002 has week number 1 in the year 2003.      \legalese     Copyright (c) 1989 The Regents of the University of California.     All rights reserved.      Redistribution and use in source and binary forms are permitted     provided that the above copyright notice and this paragraph are     duplicated in all such forms and that any documentation,     advertising materials, and other materials related to such     distribution and use acknowledge that the software was developed     by the University of California, Berkeley.  The name of the     University may not be used to endorse or promote products derived     from this software without specific prior written permission.     THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR     IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.      \sa isValid() */
end_comment
begin_function
DECL|function|weekNumber
name|int
name|QDate
operator|::
name|weekNumber
parameter_list|(
name|int
modifier|*
name|yearNumber
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
name|int
name|year
init|=
name|QDate
operator|::
name|year
argument_list|()
decl_stmt|;
name|int
name|yday
init|=
name|dayOfYear
argument_list|()
operator|-
literal|1
decl_stmt|;
name|int
name|wday
init|=
name|dayOfWeek
argument_list|()
decl_stmt|;
if|if
condition|(
name|wday
operator|==
literal|7
condition|)
name|wday
operator|=
literal|0
expr_stmt|;
name|int
name|w
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|bot
decl_stmt|;
name|int
name|top
decl_stmt|;
name|len
operator|=
name|isLeapYear
argument_list|(
name|year
argument_list|)
condition|?
literal|366
else|:
literal|365
expr_stmt|;
comment|/*         ** What yday (-3 ... 3) does         ** the ISO year begin on?         */
name|bot
operator|=
operator|(
operator|(
name|yday
operator|+
literal|11
operator|-
name|wday
operator|)
operator|%
literal|7
operator|)
operator|-
literal|3
expr_stmt|;
comment|/*         ** What yday does the NEXT         ** ISO year begin on?         */
name|top
operator|=
name|bot
operator|-
operator|(
name|len
operator|%
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|top
operator|<
operator|-
literal|3
condition|)
name|top
operator|+=
literal|7
expr_stmt|;
name|top
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|yday
operator|>=
name|top
condition|)
block|{
operator|++
name|year
expr_stmt|;
name|w
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|yday
operator|>=
name|bot
condition|)
block|{
name|w
operator|=
literal|1
operator|+
operator|(
operator|(
name|yday
operator|-
name|bot
operator|)
operator|/
literal|7
operator|)
expr_stmt|;
break|break;
block|}
operator|--
name|year
expr_stmt|;
name|yday
operator|+=
name|isLeapYear
argument_list|(
name|year
argument_list|)
condition|?
literal|366
else|:
literal|365
expr_stmt|;
block|}
if|if
condition|(
name|yearNumber
operator|!=
literal|0
condition|)
operator|*
name|yearNumber
operator|=
name|year
expr_stmt|;
return|return
name|w
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_comment
comment|/*!     \since 4.5      Returns the short name of the \a month for the representation specified     by \a type.      The months are enumerated using the following convention:      \list     \li 1 = "Jan"     \li 2 = "Feb"     \li 3 = "Mar"     \li 4 = "Apr"     \li 5 = "May"     \li 6 = "Jun"     \li 7 = "Jul"     \li 8 = "Aug"     \li 9 = "Sep"     \li 10 = "Oct"     \li 11 = "Nov"     \li 12 = "Dec"     \endlist      The month names will be localized according to the system's     locale settings, i.e. using QLocale::system().      Returns an empty string if the date is invalid.      \sa toString(), longMonthName(), shortDayName(), longDayName() */
end_comment
begin_function
DECL|function|shortMonthName
name|QString
name|QDate
operator|::
name|shortMonthName
parameter_list|(
name|int
name|month
parameter_list|,
name|QDate
operator|::
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|month
argument_list|<
literal|1
operator|||
name|month
argument_list|>
literal|12
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneMonthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the long name of the \a month for the representation specified     by \a type.      The months are enumerated using the following convention:      \list     \li 1 = "January"     \li 2 = "February"     \li 3 = "March"     \li 4 = "April"     \li 5 = "May"     \li 6 = "June"     \li 7 = "July"     \li 8 = "August"     \li 9 = "September"     \li 10 = "October"     \li 11 = "November"     \li 12 = "December"     \endlist      The month names will be localized according to the system's     locale settings, i.e. using QLocale::system().      Returns an empty string if the date is invalid.      \sa toString(), shortMonthName(), shortDayName(), longDayName() */
end_comment
begin_function
DECL|function|longMonthName
name|QString
name|QDate
operator|::
name|longMonthName
parameter_list|(
name|int
name|month
parameter_list|,
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|month
argument_list|<
literal|1
operator|||
name|month
argument_list|>
literal|12
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneMonthName
argument_list|(
name|month
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the short name of the \a weekday for the representation specified     by \a type.      The days are enumerated using the following convention:      \list     \li 1 = "Mon"     \li 2 = "Tue"     \li 3 = "Wed"     \li 4 = "Thu"     \li 5 = "Fri"     \li 6 = "Sat"     \li 7 = "Sun"     \endlist      The day names will be localized according to the system's     locale settings, i.e. using QLocale::system().      Returns an empty string if the date is invalid.      \sa toString(), shortMonthName(), longMonthName(), longDayName() */
end_comment
begin_function
DECL|function|shortDayName
name|QString
name|QDate
operator|::
name|shortDayName
parameter_list|(
name|int
name|weekday
parameter_list|,
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|weekday
argument_list|<
literal|1
operator|||
name|weekday
argument_list|>
literal|7
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneDayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the long name of the \a weekday for the representation specified     by \a type.      The days are enumerated using the following convention:      \list     \li 1 = "Monday"     \li 2 = "Tuesday"     \li 3 = "Wednesday"     \li 4 = "Thursday"     \li 5 = "Friday"     \li 6 = "Saturday"     \li 7 = "Sunday"     \endlist      The day names will be localized according to the system's     locale settings, i.e. using QLocale::system().      Returns an empty string if the date is invalid.      \sa toString(), shortDayName(), shortMonthName(), longMonthName() */
end_comment
begin_function
DECL|function|longDayName
name|QString
name|QDate
operator|::
name|longDayName
parameter_list|(
name|int
name|weekday
parameter_list|,
name|MonthNameType
name|type
parameter_list|)
block|{
if|if
condition|(
name|weekday
argument_list|<
literal|1
operator|||
name|weekday
argument_list|>
literal|7
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QDate
operator|::
name|DateFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|QDate
operator|::
name|StandaloneFormat
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|standaloneDayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|dayName
argument_list|(
name|weekday
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_TEXTDATE
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \fn QString QDate::toString(Qt::DateFormat format) const      \overload      Returns the date as a string. The \a format parameter determines     the format of the string.      If the \a format is Qt::TextDate, the string is formatted in     the default way. QDate::shortDayName() and QDate::shortMonthName()     are used to generate the string, so the day and month names will     be localized names using the system locale, i.e. QLocale::system(). An     example of this formatting is "Sat May 20 1995".      If the \a format is Qt::ISODate, the string format corresponds     to the ISO 8601 extended specification for representations of     dates and times, taking the form YYYY-MM-DD, where YYYY is the     year, MM is the month of the year (between 01 and 12), and DD is     the day of the month between 01 and 31.      If the \a format is Qt::SystemLocaleShortDate or     Qt::SystemLocaleLongDate, the string format depends on the locale     settings of the system. Identical to calling     QLocale::system().toString(date, QLocale::ShortFormat) or     QLocale::system().toString(date, QLocale::LongFormat).      If the \a format is Qt::DefaultLocaleShortDate or     Qt::DefaultLocaleLongDate, the string format depends on the     default application locale. This is the locale set with     QLocale::setDefault(), or the system locale if no default locale     has been set. Identical to calling QLocale().toString(date,     QLocale::ShortFormat) or QLocale().toString(date,     QLocale::LongFormat).      If the \a format is Qt::RFC2822Date, the string is formatted in     an \l{RFC 2822} compatible way. An example of this formatting is     "20 May 1995".      If the date is invalid, an empty string will be returned.      \warning The Qt::ISODate format is only valid for years in the     range 0 to 9999. This restriction may apply to locale-aware     formats as well, depending on the locale settings.      \sa shortDayName(), shortMonthName() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDate
operator|::
name|toString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|int
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
return|return
name|toString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"dd MMM yyyy"
argument_list|)
argument_list|)
return|;
default|default:
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
case|case
name|Qt
operator|::
name|TextDate
case|:
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"%1 %2 %3 %4"
argument_list|)
operator|.
name|arg
argument_list|(
name|shortDayName
argument_list|(
name|dayOfWeek
argument_list|()
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|shortMonthName
argument_list|(
name|m
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|d
argument_list|)
operator|.
name|arg
argument_list|(
name|y
argument_list|)
return|;
endif|#
directive|endif
case|case
name|Qt
operator|::
name|ISODate
case|:
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
argument_list|<
literal|0
operator|||
name|y
argument_list|>
literal|9999
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"%1-%2-%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|y
argument_list|,
literal|4
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|m
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|d
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the date as a string. The \a format parameter determines     the format of the result string.      These expressions may be used:      \table     \header \li Expression \li Output     \row \li d \li the day as number without a leading zero (1 to 31)     \row \li dd \li the day as number with a leading zero (01 to 31)     \row \li ddd          \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li dddd          \li the long localized day name (e.g. 'Monday' to 'Sunday').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li M \li the month as number without a leading zero (1 to 12)     \row \li MM \li the month as number with a leading zero (01 to 12)     \row \li MMM          \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li MMMM          \li the long localized month name (e.g. 'January' to 'December').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li yy \li the year as two digit number (00 to 99)     \row \li yyyy \li the year as four digit number. If the year is negative,             a minus sign is prepended in addition.     \endtable      All other input characters will be ignored. Any sequence of characters that     are enclosed in single quotes will be treated as text and not be used as an     expression. Two consecutive single quotes ("''") are replaced by a singlequote     in the output. Formats without separators (e.g. "ddMM") are currently not supported.      Example format strings (assuming that the QDate is the 20 July     1969):      \table     \header \li Format            \li Result     \row    \li dd.MM.yyyy        \li 20.07.1969     \row    \li ddd MMMM d yy     \li Sun July 20 69     \row    \li 'The day is' dddd \li The day is Sunday     \endtable      If the datetime is invalid, an empty string will be returned.      \sa QDateTime::toString(), QTime::toString(), QLocale::toString()  */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDate
operator|::
name|toString
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
block|{
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \fn bool QDate::setYMD(int y, int m, int d)      \deprecated in 5.0, use setDate() instead.      Sets the date's year \a y, month \a m, and day \a d.      If \a y is in the range 0 to 99, it is interpreted as 1900 to     1999.     Returns \c false if the date is invalid.      Use setDate() instead. */
end_comment
begin_comment
comment|/*!     \since 4.2      Sets the date's \a year, \a month, and \a day. Returns true if     the date is valid; otherwise returns false.      If the specified date is invalid, the QDate object is set to be     invalid.      \sa isValid() */
end_comment
begin_function
DECL|function|setDate
name|bool
name|QDate
operator|::
name|setDate
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
condition|)
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
else|else
name|jd
operator|=
name|nullJd
argument_list|()
expr_stmt|;
return|return
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Extracts the date's year, month, and day, and assigns them to     *\a year, *\a month, and *\a day. The pointers may be null.      Returns 0 if the date is invalid.      \sa year(), month(), day(), isValid() */
end_comment
begin_function
DECL|function|getDate
name|void
name|QDate
operator|::
name|getDate
parameter_list|(
name|int
modifier|*
name|year
parameter_list|,
name|int
modifier|*
name|month
parameter_list|,
name|int
modifier|*
name|day
parameter_list|)
block|{
if|if
condition|(
name|isValid
argument_list|()
condition|)
block|{
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|year
condition|)
operator|*
name|year
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|month
condition|)
operator|*
name|month
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|day
condition|)
operator|*
name|day
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns a QDate object containing a date \a ndays later than the     date of this object (or earlier if \a ndays is negative).      Returns a null date if the current date is invalid or the new date is     out of range.      \sa addMonths(), addYears(), daysTo() */
end_comment
begin_function
DECL|function|addDays
name|QDate
name|QDate
operator|::
name|addDays
parameter_list|(
name|qint64
name|ndays
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
comment|// Due to limits on minJd() and maxJd() we know that any overflow
comment|// will be invalid and caught by fromJulianDay().
return|return
name|fromJulianDay
argument_list|(
name|jd
operator|+
name|ndays
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDate object containing a date \a nmonths later than the     date of this object (or earlier if \a nmonths is negative).      \note If the ending day/month combination does not exist in the     resulting month/year, this function will return a date that is the     latest valid date.      \sa addDays(), addYears() */
end_comment
begin_function
DECL|function|addMonths
name|QDate
name|QDate
operator|::
name|addMonths
parameter_list|(
name|int
name|nmonths
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
if|if
condition|(
operator|!
name|nmonths
condition|)
return|return
operator|*
name|this
return|;
name|int
name|old_y
decl_stmt|,
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|old_y
operator|=
name|y
expr_stmt|;
name|bool
name|increasing
init|=
name|nmonths
operator|>
literal|0
decl_stmt|;
while|while
condition|(
name|nmonths
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nmonths
operator|<
literal|0
operator|&&
name|nmonths
operator|+
literal|12
operator|<=
literal|0
condition|)
block|{
name|y
operator|--
expr_stmt|;
name|nmonths
operator|+=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmonths
operator|<
literal|0
condition|)
block|{
name|m
operator|+=
name|nmonths
expr_stmt|;
name|nmonths
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0
condition|)
block|{
operator|--
name|y
expr_stmt|;
name|m
operator|+=
literal|12
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nmonths
operator|-
literal|12
operator|>=
literal|0
condition|)
block|{
name|y
operator|++
expr_stmt|;
name|nmonths
operator|-=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
literal|12
condition|)
block|{
name|y
operator|++
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|m
operator|+=
name|nmonths
expr_stmt|;
name|nmonths
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|12
condition|)
block|{
operator|++
name|y
expr_stmt|;
name|m
operator|-=
literal|12
expr_stmt|;
block|}
block|}
block|}
comment|// was there a sign change?
if|if
condition|(
operator|(
name|old_y
operator|>
literal|0
operator|&&
name|y
operator|<=
literal|0
operator|)
operator|||
operator|(
name|old_y
operator|<
literal|0
operator|&&
name|y
operator|>=
literal|0
operator|)
condition|)
comment|// yes, adjust the date by +1 or -1 years
name|y
operator|+=
name|increasing
condition|?
operator|+
literal|1
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|fixedDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDate object containing a date \a nyears later than the     date of this object (or earlier if \a nyears is negative).      \note If the ending day/month combination does not exist in the     resulting year (i.e., if the date was Feb 29 and the final year is     not a leap year), this function will return a date that is the     latest valid date (that is, Feb 28).      \sa addDays(), addMonths() */
end_comment
begin_function
DECL|function|addYears
name|QDate
name|QDate
operator|::
name|addYears
parameter_list|(
name|int
name|nyears
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
name|int
name|y
decl_stmt|,
name|m
decl_stmt|,
name|d
decl_stmt|;
name|getDateFromJulianDay
argument_list|(
name|jd
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|int
name|old_y
init|=
name|y
decl_stmt|;
name|y
operator|+=
name|nyears
expr_stmt|;
comment|// was there a sign change?
if|if
condition|(
operator|(
name|old_y
operator|>
literal|0
operator|&&
name|y
operator|<=
literal|0
operator|)
operator|||
operator|(
name|old_y
operator|<
literal|0
operator|&&
name|y
operator|>=
literal|0
operator|)
condition|)
comment|// yes, adjust the date by +1 or -1 years
name|y
operator|+=
name|nyears
operator|>
literal|0
condition|?
operator|+
literal|1
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|fixedDate
argument_list|(
name|y
argument_list|,
name|m
argument_list|,
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days from this date to \a d (which is     negative if \a d is earlier than this date).      Returns 0 if either date is invalid.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 0      \sa addDays() */
end_comment
begin_function
DECL|function|daysTo
name|qint64
name|QDate
operator|::
name|daysTo
parameter_list|(
specifier|const
name|QDate
modifier|&
name|d
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
operator|||
name|d
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// Due to limits on minJd() and maxJd() we know this will never overflow
return|return
name|d
operator|.
name|jd
operator|-
name|jd
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDate::operator==(const QDate&d) const      Returns true if this date is equal to \a d; otherwise returns     false.  */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator!=(const QDate&d) const      Returns true if this date is different from \a d; otherwise     returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator<(const QDate&d) const      Returns true if this date is earlier than \a d; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator<=(const QDate&d) const      Returns true if this date is earlier than or equal to \a d;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator>(const QDate&d) const      Returns true if this date is later than \a d; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     \fn bool QDate::operator>=(const QDate&d) const      Returns true if this date is later than or equal to \a d;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QDate::currentDate()     Returns the current date, as reported by the system clock.      \sa QTime::currentTime(), QDateTime::currentDateTime() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \fn QDate QDate::fromString(const QString&string, Qt::DateFormat format)      Returns the QDate represented by the \a string, using the     \a format given, or an invalid date if the string cannot be     parsed.      Note for Qt::TextDate: It is recommended that you use the     English short month names (e.g. "Jan"). Although localized month     names can also be used, they depend on the user's locale settings. */
end_comment
begin_function
DECL|function|fromString
name|QDate
name|QDate
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
block|{
if|if
condition|(
name|string
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QDate
argument_list|()
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toDate
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toDate
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toDate
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toDate
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
block|{
name|QDate
name|date
decl_stmt|;
name|rfcDateImpl
argument_list|(
name|string
argument_list|,
operator|&
name|date
argument_list|)
expr_stmt|;
return|return
name|date
return|;
block|}
default|default:
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
case|case
name|Qt
operator|::
name|TextDate
case|:
block|{
name|QStringList
name|parts
init|=
name|string
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|!=
literal|4
condition|)
return|return
name|QDate
argument_list|()
return|;
name|QString
name|monthName
init|=
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|month
init|=
operator|-
literal|1
decl_stmt|;
comment|// Assume that English monthnames are the default
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QLatin1String
argument_list|(
name|qt_shortMonthNames
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|month
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|// If English names can't be found, search the localized ones
if|if
condition|(
name|month
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QDate
operator|::
name|shortMonthName
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|month
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|month
operator|==
operator|-
literal|1
condition|)
comment|// Month name matches neither English nor other localised name.
return|return
name|QDate
argument_list|()
return|;
block|}
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|int
name|year
init|=
name|parts
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDate
argument_list|()
return|;
return|return
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|// QT_NO_TEXTDATE
case|case
name|Qt
operator|::
name|ISODate
case|:
block|{
specifier|const
name|int
name|year
init|=
name|string
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|year
operator|<=
literal|0
operator|||
name|year
operator|>
literal|9999
condition|)
return|return
name|QDate
argument_list|()
return|;
return|return
name|QDate
argument_list|(
name|year
argument_list|,
name|string
operator|.
name|mid
argument_list|(
literal|5
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|,
name|string
operator|.
name|mid
argument_list|(
literal|8
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
return|;
block|}
block|}
return|return
name|QDate
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDate::fromString(const QString&string, const QString&format)      Returns the QDate represented by the \a string, using the \a     format given, or an invalid date if the string cannot be parsed.      These expressions may be used for the format:      \table     \header \li Expression \li Output     \row \li d \li The day as a number without a leading zero (1 to 31)     \row \li dd \li The day as a number with a leading zero (01 to 31)     \row \li ddd          \li The abbreviated localized day name (e.g. 'Mon' to 'Sun').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li dddd          \li The long localized day name (e.g. 'Monday' to 'Sunday').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li M \li The month as a number without a leading zero (1 to 12)     \row \li MM \li The month as a number with a leading zero (01 to 12)     \row \li MMM          \li The abbreviated localized month name (e.g. 'Jan' to 'Dec').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li MMMM          \li The long localized month name (e.g. 'January' to 'December').              Uses the system locale to localize the name, i.e. QLocale::system().     \row \li yy \li The year as two digit number (00 to 99)     \row \li yyyy \li The year as four digit number. If the year is negative,             a minus sign is prepended in addition.     \endtable      All other input characters will be treated as text. Any sequence     of characters that are enclosed in single quotes will also be     treated as text and will not be used as an expression. For example:      \snippet code/src_corelib_tools_qdatetime.cpp 1      If the format is not satisfied, an invalid QDate is returned. The     expressions that don't expect leading zeroes (d, M) will be     greedy. This means that they will use two digits even if this     will put them outside the accepted range of values and leaves too     few digits for other sections. For example, the following format     string could have meant January 30 but the M will grab two     digits, resulting in an invalid date:      \snippet code/src_corelib_tools_qdatetime.cpp 2      For any field that is not represented in the format the following     defaults are used:      \table     \header \li Field  \li Default value     \row    \li Year   \li 1900     \row    \li Month  \li 1     \row    \li Day    \li 1     \endtable      The following examples demonstrate the default values:      \snippet code/src_corelib_tools_qdatetime.cpp 3      \sa QDateTime::fromString(), QTime::fromString(), QDate::toString(),         QDateTime::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|fromString
name|QDate
name|QDate
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
name|QDate
name|date
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QDateTimeParser
name|dt
argument_list|(
name|QVariant
operator|::
name|Date
argument_list|,
name|QDateTimeParser
operator|::
name|FromString
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|parseFormat
argument_list|(
name|format
argument_list|)
condition|)
name|dt
operator|.
name|fromString
argument_list|(
name|string
argument_list|,
operator|&
name|date
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|date
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \overload      Returns true if the specified date (\a year, \a month, and \a     day) is valid; otherwise returns false.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 4      \sa isNull(), setDate() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QDate
operator|::
name|isValid
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|day
parameter_list|)
block|{
comment|// there is no year 0 in the Gregorian calendar
if|if
condition|(
name|year
operator|==
literal|0
condition|)
return|return
literal|false
return|;
return|return
operator|(
name|day
operator|>
literal|0
operator|&&
name|month
operator|>
literal|0
operator|&&
name|month
operator|<=
literal|12
operator|)
operator|&&
operator|(
name|day
operator|<=
name|monthDays
index|[
name|month
index|]
operator|||
operator|(
name|day
operator|==
literal|29
operator|&&
name|month
operator|==
literal|2
operator|&&
name|isLeapYear
argument_list|(
name|year
argument_list|)
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDate::isLeapYear(int year)      Returns true if the specified \a year is a leap year; otherwise     returns false. */
end_comment
begin_function
DECL|function|isLeapYear
name|bool
name|QDate
operator|::
name|isLeapYear
parameter_list|(
name|int
name|y
parameter_list|)
block|{
comment|// No year 0 in Gregorian calendar, so -1, -5, -9 etc are leap years
if|if
condition|(
name|y
operator|<
literal|1
condition|)
operator|++
name|y
expr_stmt|;
return|return
operator|(
name|y
operator|%
literal|4
operator|==
literal|0
operator|&&
name|y
operator|%
literal|100
operator|!=
literal|0
operator|)
operator|||
name|y
operator|%
literal|400
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \fn static QDate QDate::fromJulianDay(qint64 jd)      Converts the Julian day \a jd to a QDate.      \sa toJulianDay() */
end_comment
begin_comment
comment|/*! \fn int QDate::toJulianDay() const      Converts the date to a Julian day.      \sa fromJulianDay() */
end_comment
begin_comment
comment|/*****************************************************************************   QTime member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QTime     \inmodule QtCore     \reentrant      \brief The QTime class provides clock time functions.       A QTime object contains a clock time, i.e. the number of hours,     minutes, seconds, and milliseconds since midnight. It can read the     current time from the system clock and measure a span of elapsed     time. It provides functions for comparing times and for     manipulating a time by adding a number of milliseconds.      QTime uses the 24-hour clock format; it has no concept of AM/PM.     Unlike QDateTime, QTime knows nothing about time zones or     daylight savings time (DST).      A QTime object is typically created either by giving the number     of hours, minutes, seconds, and milliseconds explicitly, or by     using the static function currentTime(), which creates a QTime     object that contains the system's local time. Note that the     accuracy depends on the accuracy of the underlying operating     system; not all systems provide 1-millisecond accuracy.      The hour(), minute(), second(), and msec() functions provide     access to the number of hours, minutes, seconds, and milliseconds     of the time. The same information is provided in textual format by     the toString() function.      QTime provides a full set of operators to compare two QTime     objects. QTime A is considered smaller than QTime B if A is     earlier than B.      The addSecs() and addMSecs() functions provide the time a given     number of seconds or milliseconds later than a given time.     Correspondingly, the number of seconds or milliseconds     between two times can be found using secsTo() or msecsTo().      QTime can be used to measure a span of elapsed time using the     start(), restart(), and elapsed() functions.      \sa QDate, QDateTime */
end_comment
begin_comment
comment|/*!     \fn QTime::QTime()      Constructs a null time object. A null time can be a QTime(0, 0, 0, 0)     (i.e., midnight) object, except that isNull() returns true and isValid()     returns false.      \sa isNull(), isValid() */
end_comment
begin_comment
comment|/*!     Constructs a time with hour \a h, minute \a m, seconds \a s and     milliseconds \a ms.      \a h must be in the range 0 to 23, \a m and \a s must be in the     range 0 to 59, and \a ms must be in the range 0 to 999.      \sa isValid() */
end_comment
begin_constructor
DECL|function|QTime
name|QTime
operator|::
name|QTime
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
name|setHMS
argument_list|(
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn bool QTime::isNull() const      Returns true if the time is null (i.e., the QTime object was     constructed using the default constructor); otherwise returns     false. A null time is also an invalid time.      \sa isValid() */
end_comment
begin_comment
comment|/*!     Returns true if the time is valid; otherwise returns false. For example,     the time 23:30:55.746 is valid, but 24:12:30 is invalid.      \sa isNull() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QTime
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|mds
operator|>
name|NullTime
operator|&&
name|mds
operator|<
name|MSECS_PER_DAY
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the hour part (0 to 23) of the time.      Returns -1 if the time is invalid.      \sa minute(), second(), msec() */
end_comment
begin_function
DECL|function|hour
name|int
name|QTime
operator|::
name|hour
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ds
argument_list|()
operator|/
name|MSECS_PER_HOUR
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the minute part (0 to 59) of the time.      Returns -1 if the time is invalid.      \sa hour(), second(), msec() */
end_comment
begin_function
DECL|function|minute
name|int
name|QTime
operator|::
name|minute
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|ds
argument_list|()
operator|%
name|MSECS_PER_HOUR
operator|)
operator|/
name|MSECS_PER_MIN
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the second part (0 to 59) of the time.      Returns -1 if the time is invalid.      \sa hour(), minute(), msec() */
end_comment
begin_function
DECL|function|second
name|int
name|QTime
operator|::
name|second
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|ds
argument_list|()
operator|/
literal|1000
operator|)
operator|%
name|SECS_PER_MIN
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the millisecond part (0 to 999) of the time.      Returns -1 if the time is invalid.      \sa hour(), minute(), second() */
end_comment
begin_function
DECL|function|msec
name|int
name|QTime
operator|::
name|msec
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ds
argument_list|()
operator|%
literal|1000
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \overload      Returns the time as a string. The \a format parameter determines     the format of the string.      If \a format is Qt::TextDate, the string format is HH:MM:SS;     e.g. 1 second before midnight would be "23:59:59".      If \a format is Qt::ISODate, the string format corresponds to the     ISO 8601 extended specification for representations of dates,     which is also HH:MM:SS.      If the \a format is Qt::SystemLocaleShortDate or     Qt::SystemLocaleLongDate, the string format depends on the locale     settings of the system. Identical to calling     QLocale::system().toString(time, QLocale::ShortFormat) or     QLocale::system().toString(time, QLocale::LongFormat).      If the \a format is Qt::DefaultLocaleShortDate or     Qt::DefaultLocaleLongDate, the string format depends on the     default application locale. This is the locale set with     QLocale::setDefault(), or the system locale if no default locale     has been set. Identical to calling QLocale().toString(time,     QLocale::ShortFormat) or QLocale().toString(time,     QLocale::LongFormat).      If the \a format is Qt::RFC2822Date, the string is formatted in     an \l{RFC 2822} compatible way. An example of this formatting is     "23:59:20".      If the time is invalid, an empty string will be returned.      \sa QDate::toString(), QDateTime::toString() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QTime
operator|::
name|toString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1:%2:%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|hour
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|minute
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|second
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
case|case
name|Qt
operator|::
name|ISODate
case|:
case|case
name|Qt
operator|::
name|TextDate
case|:
default|default:
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"%1:%2:%3"
argument_list|)
operator|.
name|arg
argument_list|(
name|hour
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|minute
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|second
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the time as a string. The \a format parameter determines     the format of the result string.      These expressions may be used:      \table     \header \li Expression \li Output     \row \li h          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li H          \li the hour without a leading zero (0 to 23, even with AM/PM display)     \row \li HH          \li the hour with a leading zero (00 to 23, even with AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP or A          \li use AM/PM display. \e A/AP will be replaced by either "AM" or "PM".     \row \li ap or a          \li use am/pm display. \e a/ap will be replaced by either "am" or "pm".     \row \li t \li the timezone (for example "CEST")     \endtable      All other input characters will be ignored. Any sequence of characters that     are enclosed in single quotes will be treated as text and not be used as an     expression. Two consecutive single quotes ("''") are replaced by a singlequote     in the output. Formats without separators (e.g. "HHmm") are currently not supported.      Example format strings (assuming that the QTime is 14:13:09.042)      \table     \header \li Format \li Result     \row \li hh:mm:ss.zzz \li 14:13:09.042     \row \li h:m:s ap     \li 2:13:9 pm     \row \li H:m:s a      \li 14:13:9 pm     \endtable      If the time is invalid, an empty string will be returned.     If \a format is empty, the default format "hh:mm:ss" is used.      \sa QDate::toString(), QDateTime::toString(), QLocale::toString() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QTime
operator|::
name|toString
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
block|{
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     Sets the time to hour \a h, minute \a m, seconds \a s and     milliseconds \a ms.      \a h must be in the range 0 to 23, \a m and \a s must be in the     range 0 to 59, and \a ms must be in the range 0 to 999.     Returns true if the set time is valid; otherwise returns false.      \sa isValid() */
end_comment
begin_function
DECL|function|setHMS
name|bool
name|QTime
operator|::
name|setHMS
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|startTick
operator|=
name|NullTime
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|isValid
argument_list|(
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|,
name|ms
argument_list|)
condition|)
block|{
name|mds
operator|=
name|NullTime
expr_stmt|;
comment|// make this invalid
return|return
literal|false
return|;
block|}
name|mds
operator|=
operator|(
name|h
operator|*
name|SECS_PER_HOUR
operator|+
name|m
operator|*
name|SECS_PER_MIN
operator|+
name|s
operator|)
operator|*
literal|1000
operator|+
name|ms
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QTime object containing a time \a s seconds later     than the time of this object (or earlier if \a s is negative).      Note that the time will wrap if it passes midnight.      Returns a null time if this time is invalid.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 5      \sa addMSecs(), secsTo(), QDateTime::addSecs() */
end_comment
begin_function
DECL|function|addSecs
name|QTime
name|QTime
operator|::
name|addSecs
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
return|return
name|addMSecs
argument_list|(
name|s
operator|*
literal|1000
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of seconds from this time to \a t.     If \a t is earlier than this time, the number of seconds returned     is negative.      Because QTime measures time within a day and there are 86400     seconds in a day, the result is always between -86400 and 86400.      secsTo() does not take into account any milliseconds.      Returns 0 if either time is invalid.      \sa addSecs(), QDateTime::secsTo() */
end_comment
begin_function
DECL|function|secsTo
name|int
name|QTime
operator|::
name|secsTo
parameter_list|(
specifier|const
name|QTime
modifier|&
name|t
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|t
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// Truncate milliseconds as we do not want to consider them.
name|int
name|ourSeconds
init|=
name|ds
argument_list|()
operator|/
literal|1000
decl_stmt|;
name|int
name|theirSeconds
init|=
name|t
operator|.
name|ds
argument_list|()
operator|/
literal|1000
decl_stmt|;
return|return
name|theirSeconds
operator|-
name|ourSeconds
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QTime object containing a time \a ms milliseconds later     than the time of this object (or earlier if \a ms is negative).      Note that the time will wrap if it passes midnight. See addSecs()     for an example.      Returns a null time if this time is invalid.      \sa addSecs(), msecsTo(), QDateTime::addMSecs() */
end_comment
begin_function
DECL|function|addMSecs
name|QTime
name|QTime
operator|::
name|addMSecs
parameter_list|(
name|int
name|ms
parameter_list|)
specifier|const
block|{
name|QTime
name|t
decl_stmt|;
if|if
condition|(
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|ms
operator|<
literal|0
condition|)
block|{
comment|// % not well-defined for -ve, but / is.
name|int
name|negdays
init|=
operator|(
name|MSECS_PER_DAY
operator|-
name|ms
operator|)
operator|/
name|MSECS_PER_DAY
decl_stmt|;
name|t
operator|.
name|mds
operator|=
operator|(
name|ds
argument_list|()
operator|+
name|ms
operator|+
name|negdays
operator|*
name|MSECS_PER_DAY
operator|)
operator|%
name|MSECS_PER_DAY
expr_stmt|;
block|}
else|else
block|{
name|t
operator|.
name|mds
operator|=
operator|(
name|ds
argument_list|()
operator|+
name|ms
operator|)
operator|%
name|MSECS_PER_DAY
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
name|startTick
operator|>
name|NullTime
condition|)
name|t
operator|.
name|startTick
operator|=
operator|(
name|startTick
operator|+
name|ms
operator|)
operator|%
name|MSECS_PER_DAY
expr_stmt|;
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of milliseconds from this time to \a t.     If \a t is earlier than this time, the number of milliseconds returned     is negative.      Because QTime measures time within a day and there are 86400     seconds in a day, the result is always between -86400000 and     86400000 ms.      Returns 0 if either time is invalid.      \sa secsTo(), addMSecs(), QDateTime::msecsTo() */
end_comment
begin_function
DECL|function|msecsTo
name|int
name|QTime
operator|::
name|msecsTo
parameter_list|(
specifier|const
name|QTime
modifier|&
name|t
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|t
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
comment|// GetLocalTime() for Windows CE has no milliseconds resolution
if|if
condition|(
name|t
operator|.
name|startTick
operator|>
name|NullTime
operator|&&
name|startTick
operator|>
name|NullTime
condition|)
return|return
name|t
operator|.
name|startTick
operator|-
name|startTick
return|;
else|else
endif|#
directive|endif
return|return
name|t
operator|.
name|ds
argument_list|()
operator|-
name|ds
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QTime::operator==(const QTime&t) const      Returns true if this time is equal to \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator!=(const QTime&t) const      Returns true if this time is different from \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator<(const QTime&t) const      Returns true if this time is earlier than \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator<=(const QTime&t) const      Returns true if this time is earlier than or equal to \a t;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator>(const QTime&t) const      Returns true if this time is later than \a t; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QTime::operator>=(const QTime&t) const      Returns true if this time is later than or equal to \a t;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QTime QTime::fromMSecsSinceStartOfDay(int msecs)      Returns a new QTime instance with the time set to the number of \a msecs     since the start of the day, i.e. since 00:00:00.      If \a msecs falls outside the valid range an invalid QTime will be returned.      \sa msecsSinceStartOfDay() */
end_comment
begin_comment
comment|/*!     \fn int QTime::msecsSinceStartOfDay() const      Returns the number of msecs since the start of the day, i.e. since 00:00:00.      \sa fromMSecsSinceStartOfDay() */
end_comment
begin_comment
comment|/*!     \fn QTime::currentTime()      Returns the current time as reported by the system clock.      Note that the accuracy depends on the accuracy of the underlying     operating system; not all systems provide 1-millisecond accuracy. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function
DECL|function|fromIsoTimeString
specifier|static
name|QTime
name|fromIsoTimeString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|,
name|bool
modifier|*
name|isMidnight24
parameter_list|)
block|{
if|if
condition|(
name|isMidnight24
condition|)
operator|*
name|isMidnight24
operator|=
literal|false
expr_stmt|;
specifier|const
name|int
name|size
init|=
name|string
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|5
condition|)
return|return
name|QTime
argument_list|()
return|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|int
name|hour
init|=
name|string
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
specifier|const
name|int
name|minute
init|=
name|string
operator|.
name|mid
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
name|int
name|second
init|=
literal|0
decl_stmt|;
name|int
name|msec
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|5
condition|)
block|{
comment|// HH:MM format
name|second
operator|=
literal|0
expr_stmt|;
name|msec
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|string
operator|.
name|at
argument_list|(
literal|5
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|||
name|string
operator|.
name|at
argument_list|(
literal|5
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
condition|)
block|{
if|if
condition|(
name|format
operator|==
name|Qt
operator|::
name|TextDate
condition|)
return|return
name|QTime
argument_list|()
return|;
comment|// ISODate HH:MM.SSSSSS format
comment|// We only want 5 digits worth of fraction of minute. This follows the existing
comment|// behavior that determines how milliseconds are read; 4 millisecond digits are
comment|// read and then rounded to 3. If we read at most 5 digits for fraction of minute,
comment|// the maximum amount of millisecond digits it will expand to once converted to
comment|// seconds is 4. E.g. 12:34,99999 will expand to 12:34:59.9994. The milliseconds
comment|// will then be rounded up AND clamped to 999.
specifier|const
name|float
name|minuteFraction
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"0.%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|string
operator|.
name|mid
argument_list|(
literal|6
argument_list|,
literal|5
argument_list|)
argument_list|)
operator|.
name|toFloat
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
specifier|const
name|float
name|secondWithMs
init|=
name|minuteFraction
operator|*
literal|60
decl_stmt|;
specifier|const
name|float
name|secondNoMs
init|=
name|std
operator|::
name|floor
argument_list|(
name|secondWithMs
argument_list|)
decl_stmt|;
specifier|const
name|float
name|secondFraction
init|=
name|secondWithMs
operator|-
name|secondNoMs
decl_stmt|;
name|second
operator|=
name|secondNoMs
expr_stmt|;
name|msec
operator|=
name|qMin
argument_list|(
name|qRound
argument_list|(
name|secondFraction
operator|*
literal|1000.0
argument_list|)
argument_list|,
literal|999
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// HH:MM:SS or HH:MM:SS.sssss
name|second
operator|=
name|string
operator|.
name|mid
argument_list|(
literal|6
argument_list|,
literal|2
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
if|if
condition|(
name|size
operator|>
literal|8
operator|&&
operator|(
name|string
operator|.
name|at
argument_list|(
literal|8
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|||
name|string
operator|.
name|at
argument_list|(
literal|8
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|double
name|secondFraction
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"0.%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|string
operator|.
name|mid
argument_list|(
literal|9
argument_list|,
literal|4
argument_list|)
argument_list|)
operator|.
name|toDouble
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QTime
argument_list|()
return|;
name|msec
operator|=
name|qMin
argument_list|(
name|qRound
argument_list|(
name|secondFraction
operator|*
literal|1000.0
argument_list|)
argument_list|,
literal|999
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|format
operator|==
name|Qt
operator|::
name|ISODate
operator|&&
name|hour
operator|==
literal|24
operator|&&
name|minute
operator|==
literal|0
operator|&&
name|second
operator|==
literal|0
operator|&&
name|msec
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isMidnight24
condition|)
operator|*
name|isMidnight24
operator|=
literal|true
expr_stmt|;
name|hour
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|msec
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTime QTime::fromString(const QString&string, Qt::DateFormat format)      Returns the time represented in the \a string as a QTime using the     \a format given, or an invalid time if this is not possible.      Note that fromString() uses a "C" locale encoded string to convert     milliseconds to a float value. If the default locale is not "C",     this may result in two conversion attempts (if the conversion     fails for the default locale). This should be considered an     implementation detail. */
end_comment
begin_function
DECL|function|fromString
name|QTime
name|QTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
block|{
if|if
condition|(
name|string
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QTime
argument_list|()
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
block|{
name|QTime
name|time
decl_stmt|;
name|rfcDateImpl
argument_list|(
name|string
argument_list|,
literal|0
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
return|return
name|time
return|;
block|}
case|case
name|Qt
operator|::
name|ISODate
case|:
case|case
name|Qt
operator|::
name|TextDate
case|:
default|default:
return|return
name|fromIsoTimeString
argument_list|(
name|string
argument_list|,
name|format
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QTime::fromString(const QString&string, const QString&format)      Returns the QTime represented by the \a string, using the \a     format given, or an invalid time if the string cannot be parsed.      These expressions may be used for the format:      \table     \header \li Expression \li Output     \row \li h          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP          \li interpret as an AM/PM time. \e AP must be either "AM" or "PM".     \row \li ap          \li Interpret as an AM/PM time. \e ap must be either "am" or "pm".     \endtable      All other input characters will be treated as text. Any sequence     of characters that are enclosed in single quotes will also be     treated as text and not be used as an expression.      \snippet code/src_corelib_tools_qdatetime.cpp 6      If the format is not satisfied, an invalid QTime is returned.     Expressions that do not expect leading zeroes to be given (h, m, s     and z) are greedy. This means that they will use two digits even if     this puts them outside the range of accepted values and leaves too     few digits for other sections. For example, the following string     could have meant 00:07:10, but the m will grab two digits, resulting     in an invalid time:      \snippet code/src_corelib_tools_qdatetime.cpp 7      Any field that is not represented in the format will be set to zero.     For example:      \snippet code/src_corelib_tools_qdatetime.cpp 8      \sa QDateTime::fromString(), QDate::fromString(), QDate::toString(),     QDateTime::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|fromString
name|QTime
name|QTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
name|QTime
name|time
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QDateTimeParser
name|dt
argument_list|(
name|QVariant
operator|::
name|Time
argument_list|,
name|QDateTimeParser
operator|::
name|FromString
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|parseFormat
argument_list|(
name|format
argument_list|)
condition|)
name|dt
operator|.
name|fromString
argument_list|(
name|string
argument_list|,
literal|0
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|time
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \overload      Returns true if the specified time is valid; otherwise returns     false.      The time is valid if \a h is in the range 0 to 23, \a m and     \a s are in the range 0 to 59, and \a ms is in the range 0 to 999.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 9 */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QTime
operator|::
name|isValid
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
return|return
operator|(
name|uint
operator|)
name|h
operator|<
literal|24
operator|&&
operator|(
name|uint
operator|)
name|m
operator|<
literal|60
operator|&&
operator|(
name|uint
operator|)
name|s
operator|<
literal|60
operator|&&
operator|(
name|uint
operator|)
name|ms
operator|<
literal|1000
return|;
block|}
end_function
begin_comment
comment|/*!     Sets this time to the current time. This is practical for timing:      \snippet code/src_corelib_tools_qdatetime.cpp 10      \sa restart(), elapsed(), currentTime() */
end_comment
begin_function
DECL|function|start
name|void
name|QTime
operator|::
name|start
parameter_list|()
block|{
operator|*
name|this
operator|=
name|currentTime
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets this time to the current time and returns the number of     milliseconds that have elapsed since the last time start() or     restart() was called.      This function is guaranteed to be atomic and is thus very handy     for repeated measurements. Call start() to start the first     measurement, and restart() for each later measurement.      Note that the counter wraps to zero 24 hours after the last call     to start() or restart().      \warning If the system's clock setting has been changed since the     last time start() or restart() was called, the result is     undefined. This can happen when daylight savings time is turned on     or off.      \sa start(), elapsed(), currentTime() */
end_comment
begin_function
DECL|function|restart
name|int
name|QTime
operator|::
name|restart
parameter_list|()
block|{
name|QTime
name|t
init|=
name|currentTime
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|msecsTo
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|// passed midnight
name|n
operator|+=
literal|86400
operator|*
literal|1000
expr_stmt|;
operator|*
name|this
operator|=
name|t
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of milliseconds that have elapsed since the     last time start() or restart() was called.      Note that the counter wraps to zero 24 hours after the last call     to start() or restart.      Note that the accuracy depends on the accuracy of the underlying     operating system; not all systems provide 1-millisecond accuracy.      \warning If the system's clock setting has been changed since the     last time start() or restart() was called, the result is     undefined. This can happen when daylight savings time is turned on     or off.      \sa start(), restart() */
end_comment
begin_function
DECL|function|elapsed
name|int
name|QTime
operator|::
name|elapsed
parameter_list|()
specifier|const
block|{
name|int
name|n
init|=
name|msecsTo
argument_list|(
name|currentTime
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|// passed midnight
name|n
operator|+=
literal|86400
operator|*
literal|1000
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QDateTimePrivate private helper functions  *****************************************************************************/
end_comment
begin_comment
comment|// Calls the platform variant of tzset
end_comment
begin_function
DECL|function|qt_tzset
specifier|static
name|void
name|qt_tzset
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
comment|// WinCE doesn't use tzset
return|return;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|_tzset
argument_list|()
expr_stmt|;
else|#
directive|else
name|tzset
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Q_OS_WIN
block|}
end_function
begin_comment
comment|// Returns the platform variant of timezone, i.e. the standard time offset
end_comment
begin_comment
comment|// The timezone external variable is documented as always holding the
end_comment
begin_comment
comment|// Standard Time offset as seconds west of Greenwich, i.e. UTC+01:00 is -3600
end_comment
begin_comment
comment|// Note this may not be historicaly accurate.
end_comment
begin_comment
comment|// Relies on tzset, mktime, or localtime having been called to populate timezone
end_comment
begin_function
DECL|function|qt_timezone
specifier|static
name|int
name|qt_timezone
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|TIME_ZONE_INFORMATION
name|tzi
decl_stmt|;
name|GetTimeZoneInformation
argument_list|(
operator|&
name|tzi
argument_list|)
expr_stmt|;
comment|// Expressed in minutes, convert to seconds
return|return
operator|(
name|tzi
operator|.
name|Bias
operator|+
name|tzi
operator|.
name|StandardBias
operator|)
operator|*
literal|60
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
name|long
name|offset
decl_stmt|;
name|_get_timezone
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
else|#
directive|else
return|return
name|timezone
return|;
endif|#
directive|endif
comment|// Q_OS_WIN
block|}
end_function
begin_comment
comment|// Calls the platform variant of localtime for the given msecs, and updates
end_comment
begin_comment
comment|// the date, time, and daylight status with the returned values.
end_comment
begin_function
DECL|function|qt_localtime
specifier|static
name|bool
name|qt_localtime
parameter_list|(
name|qint64
name|msecsSinceEpoch
parameter_list|,
name|QDate
modifier|*
name|localDate
parameter_list|,
name|QTime
modifier|*
name|localTime
parameter_list|,
name|QDateTimePrivate
operator|::
name|DaylightStatus
modifier|*
name|daylightStatus
parameter_list|)
block|{
specifier|const
name|time_t
name|secsSinceEpoch
init|=
name|msecsSinceEpoch
operator|/
literal|1000
decl_stmt|;
specifier|const
name|int
name|msec
init|=
name|msecsSinceEpoch
operator|%
literal|1000
decl_stmt|;
name|tm
name|local
decl_stmt|;
name|bool
name|valid
init|=
literal|false
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|FILETIME
name|utcTime
init|=
name|time_tToFt
argument_list|(
name|secsSinceEpoch
argument_list|)
decl_stmt|;
name|FILETIME
name|resultTime
decl_stmt|;
name|valid
operator|=
name|FileTimeToLocalFileTime
argument_list|(
operator|&
name|utcTime
argument_list|,
operator|&
name|resultTime
argument_list|)
expr_stmt|;
name|SYSTEMTIME
name|sysTime
decl_stmt|;
if|if
condition|(
name|valid
condition|)
name|valid
operator|=
name|FileTimeToSystemTime
argument_list|(
operator|&
name|resultTime
argument_list|,
operator|&
name|sysTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
condition|)
block|{
name|local
operator|.
name|tm_sec
operator|=
name|sysTime
operator|.
name|wSecond
expr_stmt|;
name|local
operator|.
name|tm_min
operator|=
name|sysTime
operator|.
name|wMinute
expr_stmt|;
name|local
operator|.
name|tm_hour
operator|=
name|sysTime
operator|.
name|wHour
expr_stmt|;
name|local
operator|.
name|tm_mday
operator|=
name|sysTime
operator|.
name|wDay
expr_stmt|;
name|local
operator|.
name|tm_mon
operator|=
name|sysTime
operator|.
name|wMonth
operator|-
literal|1
expr_stmt|;
name|local
operator|.
name|tm_year
operator|=
name|sysTime
operator|.
name|wYear
operator|-
literal|1900
expr_stmt|;
block|}
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
comment|// Use the reentrant version of localtime() where available
comment|// as is thread-safe and doesn't use a shared static data area
name|tm
modifier|*
name|res
init|=
literal|0
decl_stmt|;
name|res
operator|=
name|localtime_r
argument_list|(
operator|&
name|secsSinceEpoch
argument_list|,
operator|&
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|valid
operator|=
literal|true
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
if|if
condition|(
operator|!
name|_localtime64_s
argument_list|(
operator|&
name|local
argument_list|,
operator|&
name|secsSinceEpoch
argument_list|)
condition|)
name|valid
operator|=
literal|true
expr_stmt|;
else|#
directive|else
comment|// Returns shared static data which may be overwritten at any time
comment|// So copy the result asap
name|tm
modifier|*
name|res
init|=
literal|0
decl_stmt|;
name|res
operator|=
name|localtime
argument_list|(
operator|&
name|secsSinceEpoch
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|local
operator|=
operator|*
name|res
expr_stmt|;
name|valid
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|valid
condition|)
block|{
operator|*
name|localDate
operator|=
name|QDate
argument_list|(
name|local
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|local
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|local
operator|.
name|tm_mday
argument_list|)
expr_stmt|;
operator|*
name|localTime
operator|=
name|QTime
argument_list|(
name|local
operator|.
name|tm_hour
argument_list|,
name|local
operator|.
name|tm_min
argument_list|,
name|local
operator|.
name|tm_sec
argument_list|,
name|msec
argument_list|)
expr_stmt|;
if|if
condition|(
name|daylightStatus
condition|)
block|{
if|if
condition|(
name|local
operator|.
name|tm_isdst
operator|>
literal|0
condition|)
operator|*
name|daylightStatus
operator|=
name|QDateTimePrivate
operator|::
name|DaylightTime
expr_stmt|;
elseif|else
if|if
condition|(
name|local
operator|.
name|tm_isdst
operator|<
literal|0
condition|)
operator|*
name|daylightStatus
operator|=
name|QDateTimePrivate
operator|::
name|UnknownDaylightTime
expr_stmt|;
else|else
operator|*
name|daylightStatus
operator|=
name|QDateTimePrivate
operator|::
name|StandardTime
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
operator|*
name|localDate
operator|=
name|QDate
argument_list|()
expr_stmt|;
operator|*
name|localTime
operator|=
name|QTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|daylightStatus
condition|)
operator|*
name|daylightStatus
operator|=
name|QDateTimePrivate
operator|::
name|UnknownDaylightTime
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|// Converts an msecs value into a date and time
end_comment
begin_function
DECL|function|msecsToTime
specifier|static
name|void
name|msecsToTime
parameter_list|(
name|qint64
name|msecs
parameter_list|,
name|QDate
modifier|*
name|date
parameter_list|,
name|QTime
modifier|*
name|time
parameter_list|)
block|{
name|qint64
name|jd
init|=
name|JULIAN_DAY_FOR_EPOCH
decl_stmt|;
name|qint64
name|ds
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|msecs
argument_list|)
operator|>=
name|MSECS_PER_DAY
condition|)
block|{
name|jd
operator|+=
operator|(
name|msecs
operator|/
name|MSECS_PER_DAY
operator|)
expr_stmt|;
name|msecs
operator|%=
name|MSECS_PER_DAY
expr_stmt|;
block|}
if|if
condition|(
name|msecs
operator|<
literal|0
condition|)
block|{
name|ds
operator|=
name|MSECS_PER_DAY
operator|-
name|msecs
operator|-
literal|1
expr_stmt|;
name|jd
operator|-=
name|ds
operator|/
name|MSECS_PER_DAY
expr_stmt|;
name|ds
operator|=
name|ds
operator|%
name|MSECS_PER_DAY
expr_stmt|;
name|ds
operator|=
name|MSECS_PER_DAY
operator|-
name|ds
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|=
name|msecs
expr_stmt|;
block|}
if|if
condition|(
name|date
condition|)
operator|*
name|date
operator|=
name|QDate
operator|::
name|fromJulianDay
argument_list|(
name|jd
argument_list|)
expr_stmt|;
if|if
condition|(
name|time
condition|)
operator|*
name|time
operator|=
name|QTime
operator|::
name|fromMSecsSinceStartOfDay
argument_list|(
name|ds
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Converts a date/time value into msecs
end_comment
begin_function
DECL|function|timeToMSecs
specifier|static
name|qint64
name|timeToMSecs
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
return|return
operator|(
operator|(
name|date
operator|.
name|toJulianDay
argument_list|()
operator|-
name|JULIAN_DAY_FOR_EPOCH
operator|)
operator|*
name|MSECS_PER_DAY
operator|)
operator|+
name|time
operator|.
name|msecsSinceStartOfDay
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// Convert an MSecs Since Epoch into Local Time
end_comment
begin_function
DECL|function|epochMSecsToLocalTime
specifier|static
name|bool
name|epochMSecsToLocalTime
parameter_list|(
name|qint64
name|msecs
parameter_list|,
name|QDate
modifier|*
name|localDate
parameter_list|,
name|QTime
modifier|*
name|localTime
parameter_list|,
name|QDateTimePrivate
operator|::
name|DaylightStatus
modifier|*
name|daylightStatus
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
name|msecs
operator|<
literal|0
condition|)
block|{
comment|// Docs state any LocalTime before 1970-01-01 will *not* have any Daylight Time applied
comment|// Instead just use the standard offset from UTC to convert to UTC time
name|qt_tzset
argument_list|()
expr_stmt|;
name|msecsToTime
argument_list|(
name|msecs
operator|-
name|qt_timezone
argument_list|()
operator|*
literal|1000
argument_list|,
name|localDate
argument_list|,
name|localTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|daylightStatus
condition|)
operator|*
name|daylightStatus
operator|=
name|QDateTimePrivate
operator|::
name|StandardTime
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|msecs
operator|>
operator|(
name|qint64
argument_list|(
name|TIME_T_MAX
argument_list|)
operator|*
literal|1000
operator|)
condition|)
block|{
comment|// Docs state any LocalTime after 2037-12-31 *will* have any Daylight Time applied
comment|// but this may fall outside the supported time_t range, so need to fake it.
comment|// Use existing method to fake the conversion, but this is deeply flawed as it may
comment|// apply the conversion from the wrong day number, e.g. if rule is last Sunday of month
comment|// TODO Use QTimeZone when available to apply the future rule correctly
name|QDate
name|utcDate
decl_stmt|;
name|QTime
name|utcTime
decl_stmt|;
name|msecsToTime
argument_list|(
name|msecs
argument_list|,
operator|&
name|utcDate
argument_list|,
operator|&
name|utcTime
argument_list|)
expr_stmt|;
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|;
name|utcDate
operator|.
name|getDate
argument_list|(
operator|&
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|)
expr_stmt|;
comment|// 2037 is not a leap year, so make sure date isn't Feb 29
if|if
condition|(
name|month
operator|==
literal|2
operator|&&
name|day
operator|==
literal|29
condition|)
operator|--
name|day
expr_stmt|;
name|QDate
name|fakeDate
argument_list|(
literal|2037
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
decl_stmt|;
name|qint64
name|fakeMsecs
init|=
name|QDateTime
argument_list|(
name|fakeDate
argument_list|,
name|utcTime
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
operator|.
name|toMSecsSinceEpoch
argument_list|()
decl_stmt|;
name|bool
name|res
init|=
name|qt_localtime
argument_list|(
name|fakeMsecs
argument_list|,
name|localDate
argument_list|,
name|localTime
argument_list|,
name|daylightStatus
argument_list|)
decl_stmt|;
operator|*
name|localDate
operator|=
name|localDate
operator|->
name|addDays
argument_list|(
name|fakeDate
operator|.
name|daysTo
argument_list|(
name|utcDate
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
else|else
block|{
comment|// Falls inside time_t suported range so can use localtime
return|return
name|qt_localtime
argument_list|(
name|msecs
argument_list|,
name|localDate
argument_list|,
name|localTime
argument_list|,
name|daylightStatus
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|// Convert a LocalTime expressed in local msecs encoding into a UTC epoch msecs
end_comment
begin_comment
comment|// Optionally populate the returned values from mktime for the adjusted local
end_comment
begin_comment
comment|// date and time and daylight status
end_comment
begin_function
DECL|function|localMSecsToEpochMSecs
specifier|static
name|qint64
name|localMSecsToEpochMSecs
parameter_list|(
name|qint64
name|localMsecs
parameter_list|,
name|QDate
modifier|*
name|localDate
init|=
literal|0
parameter_list|,
name|QTime
modifier|*
name|localTime
init|=
literal|0
parameter_list|,
name|QDateTimePrivate
operator|::
name|DaylightStatus
modifier|*
name|daylightStatus
init|=
literal|0
parameter_list|,
name|QString
modifier|*
name|abbreviation
init|=
literal|0
parameter_list|,
name|bool
modifier|*
name|ok
init|=
literal|0
parameter_list|)
block|{
name|QDate
name|dt
decl_stmt|;
name|QTime
name|tm
decl_stmt|;
name|msecsToTime
argument_list|(
name|localMsecs
argument_list|,
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|qint64
name|msecsMax
init|=
name|qint64
argument_list|(
name|TIME_T_MAX
argument_list|)
operator|*
literal|1000
decl_stmt|;
if|if
condition|(
name|localMsecs
operator|<=
name|qint64
argument_list|(
name|MSECS_PER_DAY
argument_list|)
condition|)
block|{
comment|// Docs state any LocalTime before 1970-01-01 will *not* have any Daylight Time applied
comment|// First, if localMsecs is within +/- 1 day of minimum time_t try mktime in case it does
comment|// fall after minimum and needs proper daylight conversion
if|if
condition|(
name|localMsecs
operator|>=
operator|-
name|qint64
argument_list|(
name|MSECS_PER_DAY
argument_list|)
condition|)
block|{
name|bool
name|valid
decl_stmt|;
name|qint64
name|utcMsecs
init|=
name|qt_mktime
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|,
name|daylightStatus
argument_list|,
name|abbreviation
argument_list|,
operator|&
name|valid
argument_list|)
decl_stmt|;
if|if
condition|(
name|valid
operator|&&
name|utcMsecs
operator|>=
literal|0
condition|)
block|{
comment|// mktime worked and falls in valid range, so use it
if|if
condition|(
name|localDate
condition|)
operator|*
name|localDate
operator|=
name|dt
expr_stmt|;
if|if
condition|(
name|localTime
condition|)
operator|*
name|localTime
operator|=
name|tm
expr_stmt|;
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|utcMsecs
return|;
block|}
block|}
else|else
block|{
comment|// If we don't call mktime then need to call tzset to get offset
name|qt_tzset
argument_list|()
expr_stmt|;
block|}
comment|// Time is clearly before 1970-01-01 so just use standard offset to convert
name|qint64
name|utcMsecs
init|=
name|localMsecs
operator|+
name|qt_timezone
argument_list|()
operator|*
literal|1000
decl_stmt|;
if|if
condition|(
name|localDate
operator|||
name|localTime
condition|)
name|msecsToTime
argument_list|(
name|localMsecs
argument_list|,
name|localDate
argument_list|,
name|localTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|daylightStatus
condition|)
operator|*
name|daylightStatus
operator|=
name|QDateTimePrivate
operator|::
name|StandardTime
expr_stmt|;
if|if
condition|(
name|abbreviation
condition|)
operator|*
name|abbreviation
operator|=
name|qt_tzname
argument_list|(
name|QDateTimePrivate
operator|::
name|StandardTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|utcMsecs
return|;
block|}
elseif|else
if|if
condition|(
name|localMsecs
operator|>=
name|msecsMax
operator|-
name|MSECS_PER_DAY
condition|)
block|{
comment|// Docs state any LocalTime after 2037-12-31 *will* have any Daylight Time applied
comment|// but this may fall outside the supported time_t range, so need to fake it.
comment|// First, if localMsecs is within +/- 1 day of maximum time_t try mktime in case it does
comment|// fall before maximum and can use proper daylight conversion
if|if
condition|(
name|localMsecs
operator|<=
name|msecsMax
operator|+
name|MSECS_PER_DAY
condition|)
block|{
name|bool
name|valid
decl_stmt|;
name|qint64
name|utcMsecs
init|=
name|qt_mktime
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|,
name|daylightStatus
argument_list|,
name|abbreviation
argument_list|,
operator|&
name|valid
argument_list|)
decl_stmt|;
if|if
condition|(
name|valid
operator|&&
name|utcMsecs
operator|<=
name|msecsMax
condition|)
block|{
comment|// mktime worked and falls in valid range, so use it
if|if
condition|(
name|localDate
condition|)
operator|*
name|localDate
operator|=
name|dt
expr_stmt|;
if|if
condition|(
name|localTime
condition|)
operator|*
name|localTime
operator|=
name|tm
expr_stmt|;
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|utcMsecs
return|;
block|}
block|}
comment|// Use existing method to fake the conversion, but this is deeply flawed as it may
comment|// apply the conversion from the wrong day number, e.g. if rule is last Sunday of month
comment|// TODO Use QTimeZone when available to apply the future rule correctly
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|;
name|dt
operator|.
name|getDate
argument_list|(
operator|&
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|)
expr_stmt|;
comment|// 2037 is not a leap year, so make sure date isn't Feb 29
if|if
condition|(
name|month
operator|==
literal|2
operator|&&
name|day
operator|==
literal|29
condition|)
operator|--
name|day
expr_stmt|;
name|QDate
name|fakeDate
argument_list|(
literal|2037
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
decl_stmt|;
name|qint64
name|fakeDiff
init|=
name|fakeDate
operator|.
name|daysTo
argument_list|(
name|dt
argument_list|)
decl_stmt|;
name|qint64
name|utcMsecs
init|=
name|qt_mktime
argument_list|(
operator|&
name|fakeDate
argument_list|,
operator|&
name|tm
argument_list|,
name|daylightStatus
argument_list|,
name|abbreviation
argument_list|,
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|localDate
condition|)
operator|*
name|localDate
operator|=
name|fakeDate
operator|.
name|addDays
argument_list|(
name|fakeDiff
argument_list|)
expr_stmt|;
if|if
condition|(
name|localTime
condition|)
operator|*
name|localTime
operator|=
name|tm
expr_stmt|;
name|QDate
name|utcDate
decl_stmt|;
name|QTime
name|utcTime
decl_stmt|;
name|msecsToTime
argument_list|(
name|utcMsecs
argument_list|,
operator|&
name|utcDate
argument_list|,
operator|&
name|utcTime
argument_list|)
expr_stmt|;
name|utcDate
operator|=
name|utcDate
operator|.
name|addDays
argument_list|(
name|fakeDiff
argument_list|)
expr_stmt|;
name|utcMsecs
operator|=
name|timeToMSecs
argument_list|(
name|utcDate
argument_list|,
name|utcTime
argument_list|)
expr_stmt|;
return|return
name|utcMsecs
return|;
block|}
else|else
block|{
comment|// Clearly falls inside 1970-2037 suported range so can use mktime
name|qint64
name|utcMsecs
init|=
name|qt_mktime
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|,
name|daylightStatus
argument_list|,
name|abbreviation
argument_list|,
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|localDate
condition|)
operator|*
name|localDate
operator|=
name|dt
expr_stmt|;
if|if
condition|(
name|localTime
condition|)
operator|*
name|localTime
operator|=
name|tm
expr_stmt|;
return|return
name|utcMsecs
return|;
block|}
block|}
end_function
begin_comment
comment|/*****************************************************************************   QDateTimePrivate member functions  *****************************************************************************/
end_comment
begin_function
DECL|function|setTimeSpec
name|void
name|QDateTimePrivate
operator|::
name|setTimeSpec
parameter_list|(
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|,
name|int
name|offsetSeconds
parameter_list|)
block|{
name|clearValidDateTime
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|spec
condition|)
block|{
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
if|if
condition|(
name|offsetSeconds
operator|==
literal|0
condition|)
block|{
name|m_spec
operator|=
name|Qt
operator|::
name|UTC
expr_stmt|;
name|m_offsetFromUtc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|m_spec
operator|=
name|Qt
operator|::
name|OffsetFromUTC
expr_stmt|;
name|m_offsetFromUtc
operator|=
name|offsetSeconds
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|UTC
case|:
case|case
name|Qt
operator|::
name|LocalTime
case|:
name|m_spec
operator|=
name|spec
expr_stmt|;
name|m_offsetFromUtc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|setDateTime
name|void
name|QDateTimePrivate
operator|::
name|setDateTime
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
comment|// If the date is valid and the time is not we set time to 00:00:00
name|QTime
name|useTime
init|=
name|time
decl_stmt|;
if|if
condition|(
operator|!
name|useTime
operator|.
name|isValid
argument_list|()
operator|&&
name|date
operator|.
name|isValid
argument_list|()
condition|)
name|useTime
operator|=
name|QTime
operator|::
name|fromMSecsSinceStartOfDay
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Reset the status
name|m_status
operator|=
literal|0
expr_stmt|;
comment|// Set date value and status
name|qint64
name|days
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|date
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|days
operator|=
name|date
operator|.
name|toJulianDay
argument_list|()
operator|-
name|JULIAN_DAY_FOR_EPOCH
expr_stmt|;
name|m_status
operator|=
name|ValidDate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|date
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|m_status
operator|=
name|NullDate
expr_stmt|;
block|}
comment|// Set time value and status
name|int
name|ds
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|useTime
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|ds
operator|=
name|useTime
operator|.
name|msecsSinceStartOfDay
argument_list|()
expr_stmt|;
name|m_status
operator|=
name|m_status
operator||
name|ValidTime
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|time
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|m_status
operator|=
name|m_status
operator||
name|NullTime
expr_stmt|;
block|}
comment|// Set msecs serial value
name|m_msecs
operator|=
operator|(
name|days
operator|*
name|MSECS_PER_DAY
operator|)
operator|+
name|ds
expr_stmt|;
comment|// Set if date and time are valid
name|checkValidDateTime
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getDateTime
name|void
name|QDateTimePrivate
operator|::
name|getDateTime
parameter_list|(
name|QDate
modifier|*
name|date
parameter_list|,
name|QTime
modifier|*
name|time
parameter_list|)
specifier|const
block|{
name|msecsToTime
argument_list|(
name|m_msecs
argument_list|,
name|date
argument_list|,
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|isNullDate
argument_list|()
condition|)
operator|*
name|date
operator|=
name|QDate
argument_list|()
expr_stmt|;
if|if
condition|(
name|isNullTime
argument_list|()
condition|)
operator|*
name|time
operator|=
name|QTime
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// Check the UTC / offsetFromUTC validity
end_comment
begin_function
DECL|function|checkValidDateTime
name|void
name|QDateTimePrivate
operator|::
name|checkValidDateTime
parameter_list|()
block|{
switch|switch
condition|(
name|m_spec
condition|)
block|{
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
case|case
name|Qt
operator|::
name|UTC
case|:
if|if
condition|(
name|isValidDate
argument_list|()
operator|&&
name|isValidTime
argument_list|()
condition|)
name|setValidDateTime
argument_list|()
expr_stmt|;
else|else
name|clearValidDateTime
argument_list|()
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|LocalTime
case|:
comment|// Defer checking until required as can be expensive
name|clearValidDateTime
argument_list|()
expr_stmt|;
name|m_offsetFromUtc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|// Refresh the LocalTime validity and offset
end_comment
begin_function
DECL|function|refreshDateTime
name|void
name|QDateTimePrivate
operator|::
name|refreshDateTime
parameter_list|()
block|{
comment|// Always set by setDateTime so just return
if|if
condition|(
name|m_spec
operator|==
name|Qt
operator|::
name|UTC
operator|||
name|m_spec
operator|==
name|Qt
operator|::
name|OffsetFromUTC
condition|)
return|return;
comment|// If not valid date and time then is invalid
if|if
condition|(
operator|!
name|isValidDate
argument_list|()
operator|||
operator|!
name|isValidTime
argument_list|()
condition|)
block|{
name|clearValidDateTime
argument_list|()
expr_stmt|;
name|m_offsetFromUtc
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|// We have a valid date and time and a Qt::LocalTime that needs calculating
name|QDate
name|date
decl_stmt|;
name|QTime
name|time
decl_stmt|;
name|getDateTime
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
comment|// LocalTime and TimeZone might fall into "missing" DaylightTime transition hour
comment|// Calling toEpochMSecs will adjust the returned date/time if it does
name|QDate
name|testDate
decl_stmt|;
name|QTime
name|testTime
decl_stmt|;
name|qint64
name|epochMSecs
init|=
name|localMSecsToEpochMSecs
argument_list|(
name|m_msecs
argument_list|,
operator|&
name|testDate
argument_list|,
operator|&
name|testTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|testDate
operator|==
name|date
operator|&&
name|testTime
operator|==
name|time
condition|)
block|{
name|setValidDateTime
argument_list|()
expr_stmt|;
comment|// Cache the offset to use in toMSecsSinceEpoch()
name|m_offsetFromUtc
operator|=
operator|(
name|m_msecs
operator|-
name|epochMSecs
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
else|else
block|{
name|clearValidDateTime
argument_list|()
expr_stmt|;
name|m_offsetFromUtc
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*****************************************************************************   QDateTime member functions  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QDateTime     \inmodule QtCore     \ingroup shared     \reentrant     \brief The QDateTime class provides date and time functions.       A QDateTime object contains a calendar date and a clock time (a     "datetime"). It is a combination of the QDate and QTime classes.     It can read the current datetime from the system clock. It     provides functions for comparing datetimes and for manipulating a     datetime by adding a number of seconds, days, months, or years.      A QDateTime object is typically created either by giving a date     and time explicitly in the constructor, or by using the static     function currentDateTime() that returns a QDateTime object set     to the system clock's time. The date and time can be changed with     setDate() and setTime(). A datetime can also be set using the     setTime_t() function that takes a POSIX-standard "number of     seconds since 00:00:00 on January 1, 1970" value. The fromString()     function returns a QDateTime, given a string and a date format     used to interpret the date within the string.      The date() and time() functions provide access to the date and     time parts of the datetime. The same information is provided in     textual format by the toString() function.      QDateTime provides a full set of operators to compare two     QDateTime objects, where smaller means earlier and larger means     later.      You can increment (or decrement) a datetime by a given number of     milliseconds using addMSecs(), seconds using addSecs(), or days     using addDays(). Similarly, you can use addMonths() and addYears().     The daysTo() function returns the number of days between two datetimes,     secsTo() returns the number of seconds between two datetimes, and     msecsTo() returns the number of milliseconds between two datetimes.      QDateTime can store datetimes as \l{Qt::LocalTime}{local time} or     as \l{Qt::UTC}{UTC}. QDateTime::currentDateTime() returns a     QDateTime expressed as local time; use toUTC() to convert it to     UTC. You can also use timeSpec() to find out if a QDateTime     object stores a UTC time or a local time. Operations such as     addSecs() and secsTo() are aware of daylight saving time (DST).      \note QDateTime does not account for leap seconds.      \section1      \section2 No Year 0      There is no year 0. Dates in that year are considered invalid. The     year -1 is the year "1 before Christ" or "1 before current era."     The day before 1 January 1 CE is 31 December 1 BCE.      \section2 Range of Valid Dates      The range of valid values able to be stored in QDateTime is dependent on     the internal storage implementation. QDateTime is currently stored in a     qint64 as a serial msecs value encoding the date and time.  This restricts     the date range to about +/- 292 million years, compared to the QDate range     of +/- 2 billion years.  Care must be taken when creating a QDateTime with     extreme values that you do not overflow the storage.  The exact range of     supported values varies depending on the Qt::TimeSpec and time zone.      \section2     Use of System Timezone      QDateTime uses the system's time zone information to determine the     offset of local time from UTC. If the system is not configured     correctly or not up-to-date, QDateTime will give wrong results as     well.      \section2 Daylight Savings Time (DST)      QDateTime takes into account the system's time zone information     when dealing with DST. On modern Unix systems, this means it     applies the correct historical DST data whenever possible. On     Windows and Windows CE, where the system doesn't support     historical DST data, historical accuracy is not maintained with     respect to DST.      The range of valid dates taking DST into account is 1970-01-01 to     the present, and rules are in place for handling DST correctly     until 2037-12-31, but these could change. For dates falling     outside that range, QDateTime makes a \e{best guess} using the     rules for year 1970 or 2037, but we can't guarantee accuracy. This     means QDateTime doesn't take into account changes in a locale's     time zone before 1970, even if the system's time zone database     supports that information.      QDateTime takes into consideration the Standard Time to Daylight Time     transition.  For example if the transition is at 2am and the clock goes     forward to 3am, then there is a "missing" hour from 02:00:00 to 02:59:59.999     which QDateTime considers to be invalid.  Any date maths performed     will take this missing hour into account and return a valid result.      \section2 Offset From UTC      A Qt::TimeSpec of Qt::OffsetFromUTC is also supported. This allows you     to define a QDateTime relative to UTC at a fixed offset of a given number     of seconds from UTC.  For example, an offset of +3600 seconds is one hour     ahead of UTC and is usually written in ISO standard notation as     "UTC+01:00".  Daylight Savings Time never applies with this TimeSpec.      There is no explicit size restriction to the offset seconds, but there is     an implicit limit imposed when using the toString() and fromString()     methods which use a format of [+|-]hh:mm, effectively limiting the range     to +/- 99 hours and 59 minutes and whole minutes only.  Note that currently     no time zone lies outside the range of +/- 14 hours.      \sa QDate, QTime, QDateTimeEdit */
end_comment
begin_comment
comment|/*!     Constructs a null datetime (i.e. null date and null time). A null     datetime is invalid, since the date is invalid.      \sa isValid() */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a datetime with the given \a date, a valid     time(00:00:00.000), and sets the timeSpec() to Qt::LocalTime. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|(
name|date
argument_list|,
name|QTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|,
literal|0
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a datetime with the given \a date and \a time, using     the time specification defined by \a spec.      If \a date is valid and \a time is not, the time will be set to midnight.      If \a spec is Qt::OffsetFromUTC then it will be set to Qt::UTC, i.e. an     offset of 0 seconds. To create a Qt::OffsetFromUTC datetime use the     correct constructor. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|spec
argument_list|,
literal|0
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \since 5.2      Constructs a datetime with the given \a date and \a time, using     the time specification defined by \a spec and \a offsetSeconds seconds.      If \a date is valid and \a time is not, the time will be set to midnight.      If the \a spec is not Qt::OffsetFromUTC then \a offsetSeconds will be ignored.      If the \a spec is Qt::OffsetFromUTC and \a offsetSeconds is 0 then the     timeSpec() will be set to Qt::UTC, i.e. an offset of 0 seconds. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|,
name|int
name|offsetSeconds
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QDateTimePrivate
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|spec
argument_list|,
name|offsetSeconds
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     \internal     \since 5.2      Private.      Create a datetime with the given \a date, \a time, \a spec and \a offsetSeconds */
end_comment
begin_constructor
DECL|function|QDateTimePrivate
name|QDateTimePrivate
operator|::
name|QDateTimePrivate
parameter_list|(
specifier|const
name|QDate
modifier|&
name|toDate
parameter_list|,
specifier|const
name|QTime
modifier|&
name|toTime
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|toSpec
parameter_list|,
name|int
name|offsetSeconds
parameter_list|)
member_init_list|:
name|m_msecs
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_spec
argument_list|(
name|Qt
operator|::
name|LocalTime
argument_list|)
member_init_list|,
name|m_offsetFromUtc
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_status
argument_list|(
literal|0
argument_list|)
block|{
name|setTimeSpec
argument_list|(
name|toSpec
argument_list|,
name|offsetSeconds
argument_list|)
expr_stmt|;
name|setDateTime
argument_list|(
name|toDate
argument_list|,
name|toTime
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of the \a other datetime. */
end_comment
begin_constructor
DECL|function|QDateTime
name|QDateTime
operator|::
name|QDateTime
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the datetime. */
end_comment
begin_destructor
DECL|function|~QDateTime
name|QDateTime
operator|::
name|~
name|QDateTime
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Makes a copy of the \a other datetime and returns a reference to the     copy. */
end_comment
begin_function
DECL|function|operator =
name|QDateTime
modifier|&
name|QDateTime
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QDateTime::swap(QDateTime&other)     \since 5.0      Swaps this datetime with \a other. This operation is very fast     and never fails. */
end_comment
begin_comment
comment|/*!     Returns true if both the date and the time are null; otherwise     returns false. A null datetime is invalid.      \sa QDate::isNull(), QTime::isNull(), isValid() */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QDateTime
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|isNullDate
argument_list|()
operator|&&
name|d
operator|->
name|isNullTime
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if both the date and the time are valid and they are valid in     the current Qt::TimeSpec, otherwise returns false.      If the timeSpec() is Qt::LocalTime then the date and time are     checked to see if they fall in the Standard Time to Daylight Time transition     hour, i.e. if the transition is at 2am and the clock goes forward to 3am     then the time from 02:00:00 to 02:59:59.999 is considered to be invalid.      \sa QDate::isValid(), QTime::isValid() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QDateTime
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|d
operator|->
name|refreshDateTime
argument_list|()
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|isValidDateTime
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the date part of the datetime.      \sa setDate(), time(), timeSpec() */
end_comment
begin_function
DECL|function|date
name|QDate
name|QDateTime
operator|::
name|date
parameter_list|()
specifier|const
block|{
name|QDate
name|dt
decl_stmt|;
name|QTime
name|tm
decl_stmt|;
name|d
operator|->
name|getDateTime
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the time part of the datetime.      \sa setTime(), date(), timeSpec() */
end_comment
begin_function
DECL|function|time
name|QTime
name|QDateTime
operator|::
name|time
parameter_list|()
specifier|const
block|{
name|QDate
name|dt
decl_stmt|;
name|QTime
name|tm
decl_stmt|;
name|d
operator|->
name|getDateTime
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
return|return
name|tm
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the time specification of the datetime.      \sa setTimeSpec(), date(), time(), Qt::TimeSpec */
end_comment
begin_function
DECL|function|timeSpec
name|Qt
operator|::
name|TimeSpec
name|QDateTime
operator|::
name|timeSpec
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|m_spec
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Returns the current Offset From UTC in seconds.      If the timeSpec() is Qt::OffsetFromUTC this will be the value originally set.      If the timeSpec() is Qt::LocalTime this will be the difference between the     Local Time and UTC including any Daylight Saving Offset.      If the timeSpec() is Qt::UTC this will be 0.      \sa setOffsetFromUtc() */
end_comment
begin_function
DECL|function|offsetFromUtc
name|int
name|QDateTime
operator|::
name|offsetFromUtc
parameter_list|()
specifier|const
block|{
name|d
operator|->
name|refreshDateTime
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|m_offsetFromUtc
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Returns the Time Zone Abbreviation for the datetime.      If the timeSpec() is Qt::UTC this will be "UTC".      If the timeSpec() is Qt::OffsetFromUTC this will be in the format     "UTC[+-]00:00".      If the timeSpec() is Qt::LocalTime then the host system is queried for the     correct abbreviation.      Note that abbreviations may or may not be localized.      Note too that the abbreviation is not guaranteed to be a unique value,     i.e. different time zones may have the same abbreviation.      \sa timeSpec() */
end_comment
begin_function
DECL|function|timeZoneAbbreviation
name|QString
name|QDateTime
operator|::
name|timeZoneAbbreviation
parameter_list|()
specifier|const
block|{
switch|switch
condition|(
name|d
operator|->
name|m_spec
condition|)
block|{
case|case
name|Qt
operator|::
name|UTC
case|:
return|return
name|QStringLiteral
argument_list|(
literal|"UTC"
argument_list|)
return|;
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
return|return
name|QLatin1String
argument_list|(
literal|"UTC"
argument_list|)
operator|+
name|toOffsetString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|,
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocalTime
case|:
block|{
name|QString
name|abbrev
decl_stmt|;
name|localMSecsToEpochMSecs
argument_list|(
name|d
operator|->
name|m_msecs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|abbrev
argument_list|)
expr_stmt|;
return|return
name|abbrev
return|;
block|}
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the date part of this datetime to \a date.     If no time is set, it is set to midnight.      \sa date(), setTime(), setTimeSpec() */
end_comment
begin_function
DECL|function|setDate
name|void
name|QDateTime
operator|::
name|setDate
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|setDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the time part of this datetime to \a time.      \sa time(), setDate(), setTimeSpec() */
end_comment
begin_function
DECL|function|setTime
name|void
name|QDateTime
operator|::
name|setTime
parameter_list|(
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|setDateTime
argument_list|(
name|date
argument_list|()
argument_list|,
name|time
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the time specification used in this datetime to \a spec.     The datetime will refer to a different point in time.      If \a spec is Qt::OffsetFromUTC then the timeSpec() will be set     to Qt::UTC, i.e. an effective offset of 0.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 19      \sa timeSpec(), setDate(), setTime(), Qt::TimeSpec */
end_comment
begin_function
DECL|function|setTimeSpec
name|void
name|QDateTime
operator|::
name|setTimeSpec
parameter_list|(
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|setTimeSpec
argument_list|(
name|spec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|checkValidDateTime
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Sets the timeSpec() to Qt::OffsetFromUTC and the offset to \a offsetSeconds.     The datetime will refer to a different point in time.      The maximum and minimum offset is 14 positive or negative hours.  If     \a offsetSeconds is larger or smaller than that, then the result is     undefined.      If \a offsetSeconds is 0 then the timeSpec() will be set to Qt::UTC.      \sa isValid(), offsetFromUtc() */
end_comment
begin_function
DECL|function|setOffsetFromUtc
name|void
name|QDateTime
operator|::
name|setOffsetFromUtc
parameter_list|(
name|int
name|offsetSeconds
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|setTimeSpec
argument_list|(
name|Qt
operator|::
name|OffsetFromUTC
argument_list|,
name|offsetSeconds
argument_list|)
expr_stmt|;
name|d
operator|->
name|checkValidDateTime
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the datetime as the number of milliseconds that have passed     since 1970-01-01T00:00:00.000, Coordinated Universal Time (Qt::UTC).      On systems that do not support time zones, this function will     behave as if local time were Qt::UTC.      The behavior for this function is undefined if the datetime stored in     this object is not valid. However, for all valid dates, this function     returns a unique value.      \sa toTime_t(), setMSecsSinceEpoch() */
end_comment
begin_function
DECL|function|toMSecsSinceEpoch
name|qint64
name|QDateTime
operator|::
name|toMSecsSinceEpoch
parameter_list|()
specifier|const
block|{
name|d
operator|->
name|refreshDateTime
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|toMSecsSinceEpoch
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the datetime as the number of seconds that have passed     since 1970-01-01T00:00:00, Coordinated Universal Time (Qt::UTC).      On systems that do not support time zones, this function will     behave as if local time were Qt::UTC.      \note This function returns a 32-bit unsigned integer, so it does not     support dates before 1970, but it does support dates after     2038-01-19T03:14:06, which may not be valid time_t values. Be careful     when passing those time_t values to system functions, which could     interpret them as negative dates.      If the date is outside the range 1970-01-01T00:00:00 to     2106-02-07T06:28:14, this function returns -1 cast to an unsigned integer     (i.e., 0xFFFFFFFF).      To get an extended range, use toMSecsSinceEpoch().      \sa toMSecsSinceEpoch(), setTime_t() */
end_comment
begin_function
DECL|function|toTime_t
name|uint
name|QDateTime
operator|::
name|toTime_t
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|uint
argument_list|(
operator|-
literal|1
argument_list|)
return|;
name|qint64
name|retval
init|=
name|d
operator|->
name|toMSecsSinceEpoch
argument_list|()
operator|/
literal|1000
decl_stmt|;
if|if
condition|(
name|quint64
argument_list|(
name|retval
argument_list|)
operator|>=
name|Q_UINT64_C
argument_list|(
literal|0xFFFFFFFF
argument_list|)
condition|)
return|return
name|uint
argument_list|(
operator|-
literal|1
argument_list|)
return|;
return|return
name|uint
argument_list|(
name|retval
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Sets the date and time given the number of milliseconds \a msecs that have     passed since 1970-01-01T00:00:00.000, Coordinated Universal Time     (Qt::UTC). On systems that do not support time zones this function     will behave as if local time were Qt::UTC.      Note that passing the minimum of \c qint64     (\c{std::numeric_limits<qint64>::min()}) to \a msecs will result in     undefined behavior.      \sa toMSecsSinceEpoch(), setTime_t() */
end_comment
begin_function
DECL|function|setMSecsSinceEpoch
name|void
name|QDateTime
operator|::
name|setMSecsSinceEpoch
parameter_list|(
name|qint64
name|msecs
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|m_status
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|m_spec
condition|)
block|{
case|case
name|Qt
operator|::
name|UTC
case|:
name|d
operator|->
name|m_msecs
operator|=
name|msecs
expr_stmt|;
name|d
operator|->
name|m_status
operator|=
name|d
operator|->
name|m_status
operator||
name|QDateTimePrivate
operator|::
name|ValidDate
operator||
name|QDateTimePrivate
operator|::
name|ValidTime
operator||
name|QDateTimePrivate
operator|::
name|ValidDateTime
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
name|d
operator|->
name|m_msecs
operator|=
name|msecs
operator|+
operator|(
name|d
operator|->
name|m_offsetFromUtc
operator|*
literal|1000
operator|)
expr_stmt|;
name|d
operator|->
name|m_status
operator|=
name|d
operator|->
name|m_status
operator||
name|QDateTimePrivate
operator|::
name|ValidDate
operator||
name|QDateTimePrivate
operator|::
name|ValidTime
operator||
name|QDateTimePrivate
operator|::
name|ValidDateTime
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|LocalTime
case|:
block|{
name|QDate
name|dt
decl_stmt|;
name|QTime
name|tm
decl_stmt|;
name|epochMSecsToLocalTime
argument_list|(
name|msecs
argument_list|,
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|d
operator|->
name|setDateTime
argument_list|(
name|dt
argument_list|,
name|tm
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \fn void QDateTime::setTime_t(uint seconds)      Sets the date and time given the number of \a seconds that have     passed since 1970-01-01T00:00:00, Coordinated Universal Time     (Qt::UTC). On systems that do not support time zones this function     will behave as if local time were Qt::UTC.      \sa toTime_t() */
end_comment
begin_function
DECL|function|setTime_t
name|void
name|QDateTime
operator|::
name|setTime_t
parameter_list|(
name|uint
name|secsSince1Jan1970UTC
parameter_list|)
block|{
name|setMSecsSinceEpoch
argument_list|(
operator|(
name|qint64
operator|)
name|secsSince1Jan1970UTC
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!     \fn QString QDateTime::toString(Qt::DateFormat format) const      \overload      Returns the datetime as a string in the \a format given.      If the \a format is Qt::TextDate, the string is formatted in     the default way. QDate::shortDayName(), QDate::shortMonthName(),     and QTime::toString() are used to generate the string, so the     day and month names will be localized names using the system locale,     i.e. QLocale::system(). An example of this formatting is     "Wed May 20 03:40:13 1998".      If the \a format is Qt::ISODate, the string format corresponds     to the ISO 8601 extended specification for representations of     dates and times, taking the form YYYY-MM-DDTHH:MM:SS[Z|[+|-]HH:MM],     depending on the timeSpec() of the QDateTime. If the timeSpec()     is Qt::UTC, Z will be appended to the string; if the timeSpec() is     Qt::OffsetFromUTC, the offset in hours and minutes from UTC will     be appended to the string.      If the \a format is Qt::SystemLocaleShortDate or     Qt::SystemLocaleLongDate, the string format depends on the locale     settings of the system. Identical to calling     QLocale::system().toString(datetime, QLocale::ShortFormat) or     QLocale::system().toString(datetime, QLocale::LongFormat).      If the \a format is Qt::DefaultLocaleShortDate or     Qt::DefaultLocaleLongDate, the string format depends on the     default application locale. This is the locale set with     QLocale::setDefault(), or the system locale if no default locale     has been set. Identical to calling QLocale().toString(datetime,     QLocale::ShortFormat) or QLocale().toString(datetime,     QLocale::LongFormat).      If the \a format is Qt::RFC2822Date, the string is formatted     following \l{RFC 2822}.      If the datetime is invalid, an empty string will be returned.      \warning The Qt::ISODate format is only valid for years in the     range 0 to 9999. This restriction may apply to locale-aware     formats as well, depending on the locale settings.      \sa QDate::toString(), QTime::toString(), Qt::DateFormat */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDateTime
operator|::
name|toString
parameter_list|(
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
specifier|const
block|{
name|QString
name|buf
decl_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|buf
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
block|{
name|buf
operator|=
name|toString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"dd MMM yyyy hh:mm:ss "
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|utcOffset
init|=
name|d
operator|->
name|m_offsetFromUtc
decl_stmt|;
if|if
condition|(
name|timeSpec
argument_list|()
operator|==
name|Qt
operator|::
name|LocalTime
condition|)
block|{
name|QDateTime
name|utc
init|=
name|toUTC
argument_list|()
decl_stmt|;
name|utc
operator|.
name|setTimeSpec
argument_list|(
name|timeSpec
argument_list|()
argument_list|)
expr_stmt|;
name|utcOffset
operator|=
name|utc
operator|.
name|secsTo
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
specifier|const
name|int
name|offset
init|=
name|qAbs
argument_list|(
name|utcOffset
argument_list|)
decl_stmt|;
name|buf
operator|+=
name|QLatin1Char
argument_list|(
operator|(
name|offset
operator|==
name|utcOffset
operator|)
condition|?
literal|'+'
else|:
literal|'-'
argument_list|)
expr_stmt|;
specifier|const
name|int
name|hour
init|=
name|offset
operator|/
literal|3600
decl_stmt|;
if|if
condition|(
name|hour
operator|<
literal|10
condition|)
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|hour
argument_list|)
expr_stmt|;
specifier|const
name|int
name|min
init|=
operator|(
name|offset
operator|-
operator|(
name|hour
operator|*
literal|3600
operator|)
operator|)
operator|/
literal|60
decl_stmt|;
if|if
condition|(
name|min
operator|<
literal|10
condition|)
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QString
operator|::
name|number
argument_list|(
name|min
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
default|default:
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
case|case
name|Qt
operator|::
name|TextDate
case|:
block|{
name|QDate
name|dt
decl_stmt|;
name|QTime
name|tm
decl_stmt|;
name|d
operator|->
name|getDateTime
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
comment|//We cant use date.toString(Qt::TextDate) as we need to insert the time before the year
name|buf
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|"%1 %2 %3 %4 %5"
argument_list|)
operator|.
name|arg
argument_list|(
name|dt
operator|.
name|shortDayName
argument_list|(
name|dt
operator|.
name|dayOfWeek
argument_list|()
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|dt
operator|.
name|shortMonthName
argument_list|(
name|dt
operator|.
name|month
argument_list|()
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|dt
operator|.
name|day
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|tm
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|TextDate
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|dt
operator|.
name|year
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeSpec
argument_list|()
operator|!=
name|Qt
operator|::
name|LocalTime
condition|)
block|{
name|buf
operator|+=
name|QStringLiteral
argument_list|(
literal|" GMT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|m_spec
operator|==
name|Qt
operator|::
name|OffsetFromUTC
condition|)
name|buf
operator|+=
name|toOffsetString
argument_list|(
name|Qt
operator|::
name|TextDate
argument_list|,
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
endif|#
directive|endif
case|case
name|Qt
operator|::
name|ISODate
case|:
block|{
name|QDate
name|dt
decl_stmt|;
name|QTime
name|tm
decl_stmt|;
name|d
operator|->
name|getDateTime
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|buf
operator|=
name|dt
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// failed to convert
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|tm
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|m_spec
condition|)
block|{
case|case
name|Qt
operator|::
name|UTC
case|:
name|buf
operator|+=
name|QLatin1Char
argument_list|(
literal|'Z'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
name|buf
operator|+=
name|toOffsetString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|,
name|d
operator|->
name|m_offsetFromUtc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|buf
return|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the datetime as a string. The \a format parameter     determines the format of the result string.      These expressions may be used for the date:      \table     \header \li Expression \li Output     \row \li d \li the day as number without a leading zero (1 to 31)     \row \li dd \li the day as number with a leading zero (01 to 31)     \row \li ddd             \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').             Uses the system locale to localize the name, i.e. QLocale::system().     \row \li dddd             \li the long localized day name (e.g. 'Monday' to 'Qt::Sunday').             Uses the system locale to localize the name, i.e. QLocale::system().     \row \li M \li the month as number without a leading zero (1-12)     \row \li MM \li the month as number with a leading zero (01-12)     \row \li MMM             \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').             Uses the system locale to localize the name, i.e. QLocale::system().     \row \li MMMM             \li the long localized month name (e.g. 'January' to 'December').             Uses the system locale to localize the name, i.e. QLocale::system().     \row \li yy \li the year as two digit number (00-99)     \row \li yyyy \li the year as four digit number     \endtable      These expressions may be used for the time:      \table     \header \li Expression \li Output     \row \li h          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li H          \li the hour without a leading zero (0 to 23, even with AM/PM display)     \row \li HH          \li the hour with a leading zero (00 to 23, even with AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP or A          \li use AM/PM display. \e A/AP will be replaced by either "AM" or "PM".     \row \li ap or a          \li use am/pm display. \e a/ap will be replaced by either "am" or "pm".     \row \li t \li the timezone (for example "CEST")     \endtable      All other input characters will be ignored. Any sequence of characters that     are enclosed in single quotes will be treated as text and not be used as an     expression. Two consecutive single quotes ("''") are replaced by a singlequote     in the output. Formats without separators (e.g. "HHmm") are currently not supported.      Example format strings (assumed that the QDateTime is 21 May 2001     14:13:09):      \table     \header \li Format       \li Result     \row \li dd.MM.yyyy      \li 21.05.2001     \row \li ddd MMMM d yy   \li Tue May 21 01     \row \li hh:mm:ss.zzz    \li 14:13:09.042     \row \li h:m:s ap        \li 2:13:9 pm     \endtable      If the datetime is invalid, an empty string will be returned.      \sa QDate::toString(), QTime::toString(), QLocale::toString() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QDateTime
operator|::
name|toString
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
block|{
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toString
argument_list|(
operator|*
name|this
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a ndays days     later than the datetime of this object (or earlier if \a ndays is     negative).      If the timeSpec() is Qt::LocalTime and the resulting     date and time fall in the Standard Time to Daylight Time transition     hour then the result will be adjusted accordingly, i.e. if the transition     is at 2am and the clock goes forward to 3am and the result falls between     2am and 3am then the result will be adjusted to fall after 3am.      \sa daysTo(), addMonths(), addYears(), addSecs() */
end_comment
begin_function
DECL|function|addDays
name|QDateTime
name|QDateTime
operator|::
name|addDays
parameter_list|(
name|qint64
name|ndays
parameter_list|)
specifier|const
block|{
name|QDateTime
name|dt
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|dt
operator|.
name|detach
argument_list|()
expr_stmt|;
name|QDate
name|date
decl_stmt|;
name|QTime
name|time
decl_stmt|;
name|d
operator|->
name|getDateTime
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
name|ndays
argument_list|)
expr_stmt|;
comment|// Result might fall into "missing" DaylightTime transition hour,
comment|// so call conversion and use the adjusted returned time
if|if
condition|(
name|d
operator|->
name|m_spec
operator|==
name|Qt
operator|::
name|LocalTime
condition|)
name|localMSecsToEpochMSecs
argument_list|(
name|timeToMSecs
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|setDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a nmonths months     later than the datetime of this object (or earlier if \a nmonths     is negative).      If the timeSpec() is Qt::LocalTime and the resulting     date and time fall in the Standard Time to Daylight Time transition     hour then the result will be adjusted accordingly, i.e. if the transition     is at 2am and the clock goes forward to 3am and the result falls between     2am and 3am then the result will be adjusted to fall after 3am.      \sa daysTo(), addDays(), addYears(), addSecs() */
end_comment
begin_function
DECL|function|addMonths
name|QDateTime
name|QDateTime
operator|::
name|addMonths
parameter_list|(
name|int
name|nmonths
parameter_list|)
specifier|const
block|{
name|QDateTime
name|dt
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|dt
operator|.
name|detach
argument_list|()
expr_stmt|;
name|QDate
name|date
decl_stmt|;
name|QTime
name|time
decl_stmt|;
name|d
operator|->
name|getDateTime
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|date
operator|=
name|date
operator|.
name|addMonths
argument_list|(
name|nmonths
argument_list|)
expr_stmt|;
comment|// Result might fall into "missing" DaylightTime transition hour,
comment|// so call conversion and use the adjusted returned time
if|if
condition|(
name|d
operator|->
name|m_spec
operator|==
name|Qt
operator|::
name|LocalTime
condition|)
name|localMSecsToEpochMSecs
argument_list|(
name|timeToMSecs
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|setDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a nyears years     later than the datetime of this object (or earlier if \a nyears is     negative).      If the timeSpec() is Qt::LocalTime and the resulting     date and time fall in the Standard Time to Daylight Time transition     hour then the result will be adjusted accordingly, i.e. if the transition     is at 2am and the clock goes forward to 3am and the result falls between     2am and 3am then the result will be adjusted to fall after 3am.      \sa daysTo(), addDays(), addMonths(), addSecs() */
end_comment
begin_function
DECL|function|addYears
name|QDateTime
name|QDateTime
operator|::
name|addYears
parameter_list|(
name|int
name|nyears
parameter_list|)
specifier|const
block|{
name|QDateTime
name|dt
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|dt
operator|.
name|detach
argument_list|()
expr_stmt|;
name|QDate
name|date
decl_stmt|;
name|QTime
name|time
decl_stmt|;
name|d
operator|->
name|getDateTime
argument_list|(
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|date
operator|=
name|date
operator|.
name|addYears
argument_list|(
name|nyears
argument_list|)
expr_stmt|;
comment|// Result might fall into "missing" DaylightTime transition hour,
comment|// so call conversion and use the adjusted returned time
if|if
condition|(
name|d
operator|->
name|m_spec
operator|==
name|Qt
operator|::
name|LocalTime
condition|)
name|localMSecsToEpochMSecs
argument_list|(
name|timeToMSecs
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|setDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a s seconds     later than the datetime of this object (or earlier if \a s is     negative).      If this datetime is invalid, an invalid datetime will be returned.      \sa addMSecs(), secsTo(), addDays(), addMonths(), addYears() */
end_comment
begin_function
DECL|function|addSecs
name|QDateTime
name|QDateTime
operator|::
name|addSecs
parameter_list|(
name|qint64
name|s
parameter_list|)
specifier|const
block|{
return|return
name|addMSecs
argument_list|(
name|s
operator|*
literal|1000
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QDateTime object containing a datetime \a msecs miliseconds     later than the datetime of this object (or earlier if \a msecs is     negative).      If this datetime is invalid, an invalid datetime will be returned.      \sa addSecs(), msecsTo(), addDays(), addMonths(), addYears() */
end_comment
begin_function
DECL|function|addMSecs
name|QDateTime
name|QDateTime
operator|::
name|addMSecs
parameter_list|(
name|qint64
name|msecs
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|QDateTime
name|dt
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|dt
operator|.
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|m_spec
operator|==
name|Qt
operator|::
name|LocalTime
condition|)
comment|// Convert to real UTC first in case crosses daylight transition
name|dt
operator|.
name|setMSecsSinceEpoch
argument_list|(
name|d
operator|->
name|toMSecsSinceEpoch
argument_list|()
operator|+
name|msecs
argument_list|)
expr_stmt|;
else|else
comment|// No need to convert, just add on
name|dt
operator|.
name|d
operator|->
name|m_msecs
operator|=
name|dt
operator|.
name|d
operator|->
name|m_msecs
operator|+
name|msecs
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of days from this datetime to the \a other     datetime. The number of days is counted as the number of times     midnight is reached between this datetime to the \a other     datetime. This means that a 10 minute difference from 23:55 to     0:05 the next day counts as one day.      If the \a other datetime is earlier than this datetime,     the value returned is negative.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 15      \sa addDays(), secsTo(), msecsTo() */
end_comment
begin_function
DECL|function|daysTo
name|qint64
name|QDateTime
operator|::
name|daysTo
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|date
argument_list|()
operator|.
name|daysTo
argument_list|(
name|other
operator|.
name|date
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of seconds from this datetime to the \a other     datetime. If the \a other datetime is earlier than this datetime,     the value returned is negative.      Before performing the comparison, the two datetimes are converted     to Qt::UTC to ensure that the result is correct if one of the two     datetimes has daylight saving time (DST) and the other doesn't.      Returns 0 if either datetime is invalid.      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 11      \sa addSecs(), daysTo(), QTime::secsTo() */
end_comment
begin_function
DECL|function|secsTo
name|qint64
name|QDateTime
operator|::
name|secsTo
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|msecsTo
argument_list|(
name|other
argument_list|)
operator|/
literal|1000
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of milliseconds from this datetime to the \a other     datetime. If the \a other datetime is earlier than this datetime,     the value returned is negative.      Before performing the comparison, the two datetimes are converted     to Qt::UTC to ensure that the result is correct if one of the two     datetimes has daylight saving time (DST) and the other doesn't.      Returns 0 if either datetime is invalid.      \sa addMSecs(), daysTo(), QTime::msecsTo() */
end_comment
begin_function
DECL|function|msecsTo
name|qint64
name|QDateTime
operator|::
name|msecsTo
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
operator|||
operator|!
name|other
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|other
operator|.
name|d
operator|->
name|toMSecsSinceEpoch
argument_list|()
operator|-
name|d
operator|->
name|toMSecsSinceEpoch
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDateTime QDateTime::toTimeSpec(Qt::TimeSpec spec) const      Returns a copy of this datetime converted to the given time     \a spec.      If \a spec is Qt::OffsetFromUTC then it is set to Qt::UTC.  To set to a     spec of Qt::OffsetFromUTC use toOffsetFromUtc().      Example:     \snippet code/src_corelib_tools_qdatetime.cpp 16      \sa timeSpec(), toUTC(), toLocalTime() */
end_comment
begin_function
DECL|function|toTimeSpec
name|QDateTime
name|QDateTime
operator|::
name|toTimeSpec
parameter_list|(
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|)
specifier|const
block|{
return|return
name|fromMSecsSinceEpoch
argument_list|(
name|toMSecsSinceEpoch
argument_list|()
argument_list|,
name|spec
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2      \fn QDateTime QDateTime::toOffsetFromUtc(int offsetSeconds) const      Returns a copy of this datetime converted to a spec of Qt::OffsetFromUTC     with the given \a offsetSeconds.      If the \a offsetSeconds equals 0 then a UTC datetime will be returned      \sa setOffsetFromUtc(), offsetFromUtc(), toTimeSpec() */
end_comment
begin_function
DECL|function|toOffsetFromUtc
name|QDateTime
name|QDateTime
operator|::
name|toOffsetFromUtc
parameter_list|(
name|int
name|offsetSeconds
parameter_list|)
specifier|const
block|{
return|return
name|fromMSecsSinceEpoch
argument_list|(
name|toMSecsSinceEpoch
argument_list|()
argument_list|,
name|Qt
operator|::
name|OffsetFromUTC
argument_list|,
name|offsetSeconds
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this datetime is equal to the \a other datetime;     otherwise returns false.      \sa operator!=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QDateTime
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|m_spec
operator|==
name|Qt
operator|::
name|LocalTime
operator|&&
name|other
operator|.
name|d
operator|->
name|m_spec
operator|==
name|Qt
operator|::
name|LocalTime
operator|&&
name|d
operator|->
name|m_status
operator|==
name|other
operator|.
name|d
operator|->
name|m_status
condition|)
block|{
return|return
operator|(
name|d
operator|->
name|m_msecs
operator|==
name|other
operator|.
name|d
operator|->
name|m_msecs
operator|)
return|;
block|}
comment|// Convert to UTC and compare
return|return
operator|(
name|toMSecsSinceEpoch
argument_list|()
operator|==
name|other
operator|.
name|toMSecsSinceEpoch
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDateTime::operator!=(const QDateTime&other) const      Returns true if this datetime is different from the \a other     datetime; otherwise returns false.      Two datetimes are different if either the date, the time, or the     time zone components are different.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns true if this datetime is earlier than the \a other     datetime; otherwise returns false. */
end_comment
begin_function
DECL|function|operator <
name|bool
name|QDateTime
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|m_spec
operator|==
name|Qt
operator|::
name|LocalTime
operator|&&
name|other
operator|.
name|d
operator|->
name|m_spec
operator|==
name|Qt
operator|::
name|LocalTime
operator|&&
name|d
operator|->
name|m_status
operator|==
name|other
operator|.
name|d
operator|->
name|m_status
condition|)
block|{
return|return
operator|(
name|d
operator|->
name|m_msecs
operator|<
name|other
operator|.
name|d
operator|->
name|m_msecs
operator|)
return|;
block|}
comment|// Convert to UTC and compare
return|return
operator|(
name|toMSecsSinceEpoch
argument_list|()
operator|<
name|other
operator|.
name|toMSecsSinceEpoch
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QDateTime::operator<=(const QDateTime&other) const      Returns true if this datetime is earlier than or equal to the     \a other datetime; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDateTime::operator>(const QDateTime&other) const      Returns true if this datetime is later than the \a other datetime;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QDateTime::operator>=(const QDateTime&other) const      Returns true if this datetime is later than or equal to the     \a other datetime; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::currentDateTime()     Returns the current datetime, as reported by the system clock, in     the local time zone.      \sa currentDateTimeUtc(), QDate::currentDate(), QTime::currentTime(), toTimeSpec() */
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::currentDateTimeUtc()     \since 4.7     Returns the current datetime, as reported by the system clock, in     UTC.      \sa currentDateTime(), QDate::currentDate(), QTime::currentTime(), toTimeSpec() */
end_comment
begin_comment
comment|/*!     \fn qint64 QDateTime::currentMSecsSinceEpoch()     \since 4.7      Returns the number of milliseconds since 1970-01-01T00:00:00 Universal     Coordinated Time. This number is like the POSIX time_t variable, but     expressed in milliseconds instead.      \sa currentDateTime(), currentDateTimeUtc(), toTime_t(), toTimeSpec() */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_function
DECL|function|msecsFromDecomposed
specifier|static
specifier|inline
name|uint
name|msecsFromDecomposed
parameter_list|(
name|int
name|hour
parameter_list|,
name|int
name|minute
parameter_list|,
name|int
name|sec
parameter_list|,
name|int
name|msec
init|=
literal|0
parameter_list|)
block|{
return|return
name|MSECS_PER_HOUR
operator|*
name|hour
operator|+
name|MSECS_PER_MIN
operator|*
name|minute
operator|+
literal|1000
operator|*
name|sec
operator|+
name|msec
return|;
block|}
end_function
begin_function
DECL|function|currentDate
name|QDate
name|QDate
operator|::
name|currentDate
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetLocalTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|currentTime
name|QTime
name|QTime
operator|::
name|currentTime
parameter_list|()
block|{
name|QTime
name|ct
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetLocalTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|ct
operator|.
name|setHMS
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|ct
operator|.
name|startTick
operator|=
name|GetTickCount
argument_list|()
operator|%
name|MSECS_PER_DAY
expr_stmt|;
endif|#
directive|endif
return|return
name|ct
return|;
block|}
end_function
begin_function
DECL|function|currentDateTime
name|QDateTime
name|QDateTime
operator|::
name|currentDateTime
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetLocalTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
expr_stmt|;
name|t
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|d
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|currentDateTimeUtc
name|QDateTime
name|QDateTime
operator|::
name|currentDateTimeUtc
parameter_list|()
block|{
name|QDate
name|d
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetSystemTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|d
operator|.
name|jd
operator|=
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
expr_stmt|;
name|t
operator|.
name|mds
operator|=
name|msecsFromDecomposed
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|d
argument_list|,
name|t
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
return|;
block|}
end_function
begin_function
name|qint64
name|QDateTime
operator|::
name|currentMSecsSinceEpoch
parameter_list|()
name|Q_DECL_NOTHROW
block|{
name|QDate
name|d
decl_stmt|;
name|QTime
name|t
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SYSTEMTIME
argument_list|)
argument_list|)
expr_stmt|;
name|GetSystemTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
return|return
name|msecsFromDecomposed
argument_list|(
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|)
operator|+
name|qint64
argument_list|(
name|julianDayFromDate
argument_list|(
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|)
operator|-
name|julianDayFromDate
argument_list|(
literal|1970
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|Q_INT64_C
argument_list|(
literal|86400000
argument_list|)
return|;
block|}
end_function
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
end_elif
begin_function
DECL|function|currentDate
name|QDate
name|QDate
operator|::
name|currentDate
parameter_list|()
block|{
return|return
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|date
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|currentTime
name|QTime
name|QTime
operator|::
name|currentTime
parameter_list|()
block|{
return|return
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|time
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|currentDateTime
name|QDateTime
name|QDateTime
operator|::
name|currentDateTime
parameter_list|()
block|{
return|return
name|fromMSecsSinceEpoch
argument_list|(
name|currentMSecsSinceEpoch
argument_list|()
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|currentDateTimeUtc
name|QDateTime
name|QDateTime
operator|::
name|currentDateTimeUtc
parameter_list|()
block|{
return|return
name|fromMSecsSinceEpoch
argument_list|(
name|currentMSecsSinceEpoch
argument_list|()
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
return|;
block|}
end_function
begin_function
name|qint64
name|QDateTime
operator|::
name|currentMSecsSinceEpoch
parameter_list|()
name|Q_DECL_NOTHROW
block|{
comment|// posix compliant system
comment|// we have milliseconds
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|qint64
argument_list|(
name|tv
operator|.
name|tv_sec
argument_list|)
operator|*
name|Q_INT64_C
argument_list|(
literal|1000
argument_list|)
operator|+
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
literal|"What system is this?"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \since 4.2    Returns a datetime whose date and time are the number of \a seconds   that have passed since 1970-01-01T00:00:00, Coordinated Universal   Time (Qt::UTC) and converted to Qt::LocalTime.  On systems that do not   support time zones, the time will be set as if local time were Qt::UTC.    \sa toTime_t(), setTime_t() */
end_comment
begin_function
DECL|function|fromTime_t
name|QDateTime
name|QDateTime
operator|::
name|fromTime_t
parameter_list|(
name|uint
name|seconds
parameter_list|)
block|{
return|return
name|fromMSecsSinceEpoch
argument_list|(
operator|(
name|qint64
operator|)
name|seconds
operator|*
literal|1000
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 5.2    Returns a datetime whose date and time are the number of \a seconds   that have passed since 1970-01-01T00:00:00, Coordinated Universal   Time (Qt::UTC) and converted to the given \a spec.    If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.    \sa toTime_t(), setTime_t() */
end_comment
begin_function
DECL|function|fromTime_t
name|QDateTime
name|QDateTime
operator|::
name|fromTime_t
parameter_list|(
name|uint
name|seconds
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|,
name|int
name|offsetSeconds
parameter_list|)
block|{
return|return
name|fromMSecsSinceEpoch
argument_list|(
operator|(
name|qint64
operator|)
name|seconds
operator|*
literal|1000
argument_list|,
name|spec
argument_list|,
name|offsetSeconds
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.7    Returns a datetime whose date and time are the number of milliseconds, \a msecs,   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal   Time (Qt::UTC), and converted to Qt::LocalTime.  On systems that do not   support time zones, the time will be set as if local time were Qt::UTC.    Note that there are possible values for \a msecs that lie outside the valid   range of QDateTime, both negative and positive. The behavior of this   function is undefined for those values.    \sa toTime_t(), setTime_t() */
end_comment
begin_function
DECL|function|fromMSecsSinceEpoch
name|QDateTime
name|QDateTime
operator|::
name|fromMSecsSinceEpoch
parameter_list|(
name|qint64
name|msecs
parameter_list|)
block|{
return|return
name|fromMSecsSinceEpoch
argument_list|(
name|msecs
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 5.2    Returns a datetime whose date and time are the number of milliseconds \a msecs   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal   Time (Qt::UTC) and converted to the given \a spec.    Note that there are possible values for \a msecs that lie outside the valid   range of QDateTime, both negative and positive. The behavior of this   function is undefined for those values.    If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.    \sa fromTime_t() */
end_comment
begin_function
DECL|function|fromMSecsSinceEpoch
name|QDateTime
name|QDateTime
operator|::
name|fromMSecsSinceEpoch
parameter_list|(
name|qint64
name|msecs
parameter_list|,
name|Qt
operator|::
name|TimeSpec
name|spec
parameter_list|,
name|int
name|offsetSeconds
parameter_list|)
block|{
name|QDateTime
name|dt
decl_stmt|;
name|dt
operator|.
name|detach
argument_list|()
expr_stmt|;
name|dt
operator|.
name|d
operator|->
name|setTimeSpec
argument_list|(
name|spec
argument_list|,
name|offsetSeconds
argument_list|)
expr_stmt|;
name|dt
operator|.
name|setMSecsSinceEpoch
argument_list|(
name|msecs
argument_list|)
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_if
if|#
directive|if
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|2
argument_list|)
end_if
begin_comment
comment|/*!     \since 4.4     \internal     \obsolete      This method was added in 4.4 but never documented as public. It was replaced     in 5.2 with public method setOffsetFromUtc() for consistency with QTimeZone.      This method should never be made public.      \sa setOffsetFromUtc()  */
end_comment
begin_function
DECL|function|setUtcOffset
name|void
name|QDateTime
operator|::
name|setUtcOffset
parameter_list|(
name|int
name|seconds
parameter_list|)
block|{
name|setOffsetFromUtc
argument_list|(
name|seconds
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4     \internal     \obsolete      This method was added in 4.4 but never documented as public. It was replaced     in 5.1 with public method offsetFromUTC() for consistency with QTimeZone.      This method should never be made public.      \sa offsetFromUTC() */
end_comment
begin_function
DECL|function|utcOffset
name|int
name|QDateTime
operator|::
name|utcOffset
parameter_list|()
specifier|const
block|{
return|return
name|offsetFromUtc
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_DEPRECATED_SINCE
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function
DECL|function|fromShortMonthName
specifier|static
name|int
name|fromShortMonthName
parameter_list|(
specifier|const
name|QString
modifier|&
name|monthName
parameter_list|)
block|{
comment|// Assume that English monthnames are the default
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QLatin1String
argument_list|(
name|qt_shortMonthNames
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
operator|+
literal|1
return|;
block|}
comment|// If English names can't be found, search the localized ones
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|12
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|monthName
operator|==
name|QDate
operator|::
name|shortMonthName
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDateTime QDateTime::fromString(const QString&string, Qt::DateFormat format)      Returns the QDateTime represented by the \a string, using the     \a format given, or an invalid datetime if this is not possible.      Note for Qt::TextDate: It is recommended that you use the     English short month names (e.g. "Jan"). Although localized month     names can also be used, they depend on the user's locale settings. */
end_comment
begin_function
DECL|function|fromString
name|QDateTime
name|QDateTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
name|Qt
operator|::
name|DateFormat
name|format
parameter_list|)
block|{
if|if
condition|(
name|string
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|Qt
operator|::
name|SystemLocaleDate
case|:
case|case
name|Qt
operator|::
name|SystemLocaleShortDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toDateTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|SystemLocaleLongDate
case|:
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|toDateTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LocaleDate
case|:
case|case
name|Qt
operator|::
name|DefaultLocaleShortDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toDateTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|ShortFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|DefaultLocaleLongDate
case|:
return|return
name|QLocale
argument_list|()
operator|.
name|toDateTime
argument_list|(
name|string
argument_list|,
name|QLocale
operator|::
name|LongFormat
argument_list|)
return|;
case|case
name|Qt
operator|::
name|RFC2822Date
case|:
block|{
name|QDate
name|date
decl_stmt|;
name|QTime
name|time
decl_stmt|;
name|int
name|utcOffset
init|=
literal|0
decl_stmt|;
name|rfcDateImpl
argument_list|(
name|string
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|,
operator|&
name|utcOffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|date
operator|.
name|isValid
argument_list|()
operator|||
operator|!
name|time
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|QDateTime
name|dateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
name|dateTime
operator|.
name|setOffsetFromUtc
argument_list|(
name|utcOffset
argument_list|)
expr_stmt|;
return|return
name|dateTime
return|;
block|}
case|case
name|Qt
operator|::
name|ISODate
case|:
block|{
specifier|const
name|int
name|size
init|=
name|string
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|10
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|QString
name|isoString
init|=
name|string
decl_stmt|;
name|Qt
operator|::
name|TimeSpec
name|spec
init|=
name|Qt
operator|::
name|LocalTime
decl_stmt|;
name|QDate
name|date
init|=
name|QDate
operator|::
name|fromString
argument_list|(
name|isoString
operator|.
name|left
argument_list|(
literal|10
argument_list|)
argument_list|,
name|Qt
operator|::
name|ISODate
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|date
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
if|if
condition|(
name|size
operator|==
literal|10
condition|)
return|return
name|QDateTime
argument_list|(
name|date
argument_list|)
return|;
name|isoString
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|// Check end of string for Time Zone definition, either Z for UTC or [+-]HH:MM for Offset
if|if
condition|(
name|isoString
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'Z'
argument_list|)
argument_list|)
condition|)
block|{
name|spec
operator|=
name|Qt
operator|::
name|UTC
expr_stmt|;
name|isoString
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|signIndex
init|=
name|isoString
operator|.
name|indexOf
argument_list|(
name|QRegExp
argument_list|(
name|QStringLiteral
argument_list|(
literal|"[+-]"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|signIndex
operator|>=
literal|0
condition|)
block|{
name|bool
name|ok
decl_stmt|;
name|offset
operator|=
name|fromOffsetString
argument_list|(
name|isoString
operator|.
name|mid
argument_list|(
name|signIndex
argument_list|)
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|isoString
operator|=
name|isoString
operator|.
name|left
argument_list|(
name|signIndex
argument_list|)
expr_stmt|;
name|spec
operator|=
name|Qt
operator|::
name|OffsetFromUTC
expr_stmt|;
block|}
block|}
comment|// Might be end of day (24:00, including variants), which QTime considers invalid.
comment|// ISO 8601 (section 4.2.3) says that 24:00 is equivalent to 00:00 the next day.
name|bool
name|isMidnight24
init|=
literal|false
decl_stmt|;
name|QTime
name|time
init|=
name|fromIsoTimeString
argument_list|(
name|isoString
argument_list|,
name|Qt
operator|::
name|ISODate
argument_list|,
operator|&
name|isMidnight24
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|time
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
if|if
condition|(
name|isMidnight24
condition|)
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|spec
argument_list|,
name|offset
argument_list|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_TEXTDATE
argument_list|)
case|case
name|Qt
operator|::
name|TextDate
case|:
block|{
name|QStringList
name|parts
init|=
name|string
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|parts
operator|.
name|count
argument_list|()
operator|<
literal|5
operator|)
operator|||
operator|(
name|parts
operator|.
name|count
argument_list|()
operator|>
literal|6
operator|)
condition|)
return|return
name|QDateTime
argument_list|()
return|;
comment|// Accept "Sun Dec 1 13:02:00 1974" and "Sun 1. Dec 13:02:00 1974"
name|int
name|month
init|=
literal|0
decl_stmt|;
name|int
name|day
init|=
literal|0
decl_stmt|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
comment|// First try month then day
name|month
operator|=
name|fromShortMonthName
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|month
condition|)
name|day
operator|=
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
comment|// If failed try day then month
if|if
condition|(
operator|!
name|month
operator|||
operator|!
name|day
condition|)
block|{
name|month
operator|=
name|fromShortMonthName
argument_list|(
name|parts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|month
condition|)
block|{
name|QString
name|dayStr
init|=
name|parts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|dayStr
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
block|{
name|dayStr
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|day
operator|=
name|dayStr
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// If both failed, give up
if|if
condition|(
operator|!
name|month
operator|||
operator|!
name|day
condition|)
return|return
name|QDateTime
argument_list|()
return|;
comment|// Year can be before or after time, "Sun Dec 1 1974 13:02:00" or "Sun Dec 1 13:02:00 1974"
comment|// Guess which by looking for ':' in the time
name|int
name|year
init|=
literal|0
decl_stmt|;
name|int
name|yearPart
init|=
literal|0
decl_stmt|;
name|int
name|timePart
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
block|{
name|yearPart
operator|=
literal|4
expr_stmt|;
name|timePart
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parts
operator|.
name|at
argument_list|(
literal|4
argument_list|)
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
block|{
name|yearPart
operator|=
literal|3
expr_stmt|;
name|timePart
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|year
operator|=
name|parts
operator|.
name|at
argument_list|(
name|yearPart
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|QDate
name|date
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|date
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|QStringList
name|timeParts
init|=
name|parts
operator|.
name|at
argument_list|(
name|timePart
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeParts
operator|.
name|count
argument_list|()
operator|<
literal|2
operator|||
name|timeParts
operator|.
name|count
argument_list|()
operator|>
literal|3
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|int
name|hour
init|=
name|timeParts
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|int
name|minute
init|=
name|timeParts
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|int
name|second
init|=
literal|0
decl_stmt|;
name|int
name|millisecond
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|timeParts
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|QStringList
name|secondParts
init|=
name|timeParts
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|secondParts
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
name|second
operator|=
name|secondParts
operator|.
name|first
argument_list|()
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
if|if
condition|(
name|secondParts
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|millisecond
operator|=
name|secondParts
operator|.
name|last
argument_list|()
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
name|QDateTime
argument_list|()
return|;
block|}
block|}
block|}
name|QTime
name|time
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|millisecond
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|time
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
if|if
condition|(
name|parts
operator|.
name|count
argument_list|()
operator|==
literal|5
condition|)
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|LocalTime
argument_list|)
return|;
name|QString
name|tz
init|=
name|parts
operator|.
name|at
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tz
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"GMT"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
return|return
name|QDateTime
argument_list|()
return|;
name|tz
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tz
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|offset
init|=
name|fromOffsetString
argument_list|(
name|tz
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|QDateTime
argument_list|()
return|;
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|OffsetFromUTC
argument_list|,
name|offset
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
comment|//QT_NO_TEXTDATE
block|}
return|return
name|QDateTime
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDateTime::fromString(const QString&string, const QString&format)      Returns the QDateTime represented by the \a string, using the \a     format given, or an invalid datetime if the string cannot be parsed.      These expressions may be used for the date part of the format string:      \table     \header \li Expression \li Output     \row \li d \li the day as number without a leading zero (1 to 31)     \row \li dd \li the day as number with a leading zero (01 to 31)     \row \li ddd             \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').             Uses QDate::shortDayName().     \row \li dddd             \li the long localized day name (e.g. 'Monday' to 'Sunday').             Uses QDate::longDayName().     \row \li M \li the month as number without a leading zero (1-12)     \row \li MM \li the month as number with a leading zero (01-12)     \row \li MMM             \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').             Uses QDate::shortMonthName().     \row \li MMMM             \li the long localized month name (e.g. 'January' to 'December').             Uses QDate::longMonthName().     \row \li yy \li the year as two digit number (00-99)     \row \li yyyy \li the year as four digit number     \endtable      \note Unlike the other version of this function, day and month names must     be given in the user's local language. It is only possible to use the English     names if the user's language is English.      These expressions may be used for the time part of the format string:      \table     \header \li Expression \li Output     \row \li h             \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)     \row \li hh             \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)     \row \li H             \li the hour without a leading zero (0 to 23, even with AM/PM display)     \row \li HH             \li the hour with a leading zero (00 to 23, even with AM/PM display)     \row \li m \li the minute without a leading zero (0 to 59)     \row \li mm \li the minute with a leading zero (00 to 59)     \row \li s \li the second without a leading zero (0 to 59)     \row \li ss \li the second with a leading zero (00 to 59)     \row \li z \li the milliseconds without leading zeroes (0 to 999)     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)     \row \li AP or A          \li interpret as an AM/PM time. \e AP must be either "AM" or "PM".     \row \li ap or a          \li Interpret as an AM/PM time. \e ap must be either "am" or "pm".     \endtable      All other input characters will be treated as text. Any sequence     of characters that are enclosed in single quotes will also be     treated as text and not be used as an expression.      \snippet code/src_corelib_tools_qdatetime.cpp 12      If the format is not satisfied, an invalid QDateTime is returned.     The expressions that don't have leading zeroes (d, M, h, m, s, z) will be     greedy. This means that they will use two digits even if this will     put them outside the range and/or leave too few digits for other     sections.      \snippet code/src_corelib_tools_qdatetime.cpp 13      This could have meant 1 January 00:30.00 but the M will grab     two digits.      Incorrectly specified fields of the \a string will cause an invalid     QDateTime to be returned. For example, consider the following code,     where the two digit year 12 is read as 1912 (see the table below for all     field defaults); the resulting datetime is invalid because 23 April 1912     was a Tuesday, not a Monday:      \snippet code/src_corelib_tools_qdatetime.cpp 20      The correct code is:      \snippet code/src_corelib_tools_qdatetime.cpp 21      For any field that is not represented in the format, the following     defaults are used:      \table     \header \li Field  \li Default value     \row    \li Year   \li 1900     \row    \li Month  \li 1 (January)     \row    \li Day    \li 1     \row    \li Hour   \li 0     \row    \li Minute \li 0     \row    \li Second \li 0     \endtable      For example:      \snippet code/src_corelib_tools_qdatetime.cpp 14      \sa QDate::fromString(), QTime::fromString(), QDate::toString(),     QDateTime::toString(), QTime::toString() */
end_comment
begin_function
DECL|function|fromString
name|QDateTime
name|QDateTime
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QTime
name|time
decl_stmt|;
name|QDate
name|date
decl_stmt|;
name|QDateTimeParser
name|dt
argument_list|(
name|QVariant
operator|::
name|DateTime
argument_list|,
name|QDateTimeParser
operator|::
name|FromString
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|parseFormat
argument_list|(
name|format
argument_list|)
operator|&&
name|dt
operator|.
name|fromString
argument_list|(
name|string
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|time
argument_list|)
condition|)
return|return
name|QDateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|QDateTime
argument_list|(
name|QDate
argument_list|()
argument_list|,
name|QTime
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::toLocalTime() const      Returns a datetime containing the date and time information in     this datetime, but specified using the Qt::LocalTime definition.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 17      \sa toTimeSpec() */
end_comment
begin_comment
comment|/*!     \fn QDateTime QDateTime::toUTC() const      Returns a datetime containing the date and time information in     this datetime, but specified using the Qt::UTC definition.      Example:      \snippet code/src_corelib_tools_qdatetime.cpp 18      \sa toTimeSpec() */
end_comment
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|detach
name|void
name|QDateTime
operator|::
name|detach
parameter_list|()
block|{
name|d
operator|.
name|detach
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   Date/time stream functions  *****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \relates QDate      Writes the \a date to stream \a out.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
block|{
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_5_0
condition|)
return|return
name|out
operator|<<
name|quint32
argument_list|(
name|date
operator|.
name|jd
argument_list|)
return|;
else|else
return|return
name|out
operator|<<
name|qint64
argument_list|(
name|date
operator|.
name|jd
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QDate      Reads a date from stream \a in into the \a date.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QDate
modifier|&
name|date
parameter_list|)
block|{
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_5_0
condition|)
block|{
name|quint32
name|jd
decl_stmt|;
name|in
operator|>>
name|jd
expr_stmt|;
comment|// Older versions consider 0 an invalid jd.
name|date
operator|.
name|jd
operator|=
operator|(
name|jd
operator|!=
literal|0
condition|?
name|jd
else|:
name|QDate
operator|::
name|nullJd
argument_list|()
operator|)
expr_stmt|;
block|}
else|else
block|{
name|qint64
name|jd
decl_stmt|;
name|in
operator|>>
name|jd
expr_stmt|;
name|date
operator|.
name|jd
operator|=
name|jd
expr_stmt|;
block|}
return|return
name|in
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTime      Writes \a time to stream \a out.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
return|return
name|out
operator|<<
name|quint32
argument_list|(
name|time
operator|.
name|mds
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QTime      Reads a time from stream \a in into the given \a time.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|quint32
name|ds
decl_stmt|;
name|in
operator|>>
name|ds
expr_stmt|;
name|time
operator|.
name|mds
operator|=
name|int
argument_list|(
name|ds
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QDateTime      Writes \a dateTime to the \a out stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|dateTime
parameter_list|)
block|{
name|QDate
name|dt
decl_stmt|;
name|QTime
name|tm
decl_stmt|;
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|==
name|QDataStream
operator|::
name|Qt_5_0
condition|)
block|{
comment|// This approach is wrong and should not be used again; it breaks
comment|// the guarantee that a deserialised local datetime is the same time
comment|// of day, regardless of which timezone it was serialised in.
if|if
condition|(
name|dateTime
operator|.
name|isValid
argument_list|()
condition|)
name|dateTime
operator|.
name|toUTC
argument_list|()
operator|.
name|d
operator|->
name|getDateTime
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
else|else
name|dateTime
operator|.
name|d
operator|->
name|getDateTime
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|out
operator|<<
name|dt
operator|<<
name|tm
operator|<<
operator|(
name|qint8
operator|)
name|dateTime
operator|.
name|timeSpec
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dateTime
operator|.
name|d
operator|->
name|getDateTime
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|out
operator|<<
name|dt
operator|<<
name|tm
expr_stmt|;
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_0
condition|)
block|{
switch|switch
condition|(
name|dateTime
operator|.
name|d
operator|->
name|m_spec
condition|)
block|{
case|case
name|Qt
operator|::
name|UTC
case|:
name|out
operator|<<
operator|(
name|qint8
operator|)
name|QDateTimePrivate
operator|::
name|UTC
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
name|out
operator|<<
operator|(
name|qint8
operator|)
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|LocalTime
case|:
name|out
operator|<<
operator|(
name|qint8
operator|)
name|QDateTimePrivate
operator|::
name|LocalUnknown
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_5_2
operator|&&
name|dateTime
operator|.
name|d
operator|->
name|m_spec
operator|==
name|Qt
operator|::
name|OffsetFromUTC
condition|)
block|{
name|out
operator|<<
name|qint32
argument_list|(
name|dateTime
operator|.
name|offsetFromUtc
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QDateTime      Reads a datetime from the stream \a in into \a dateTime.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QDateTime
modifier|&
name|dateTime
parameter_list|)
block|{
name|dateTime
operator|.
name|detach
argument_list|()
expr_stmt|;
name|QDate
name|dt
decl_stmt|;
name|QTime
name|tm
decl_stmt|;
name|in
operator|>>
name|dt
operator|>>
name|tm
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|==
name|QDataStream
operator|::
name|Qt_5_0
condition|)
block|{
name|qint8
name|ts
init|=
literal|0
decl_stmt|;
name|in
operator|>>
name|ts
expr_stmt|;
comment|// We incorrectly stored the datetime as UTC in Qt_5_0.
name|dateTime
operator|.
name|setTimeSpec
argument_list|(
name|Qt
operator|::
name|UTC
argument_list|)
expr_stmt|;
name|dateTime
operator|.
name|d
operator|->
name|setDateTime
argument_list|(
name|dt
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|dateTime
operator|=
name|dateTime
operator|.
name|toTimeSpec
argument_list|(
cast|static_cast
argument_list|<
name|Qt
operator|::
name|TimeSpec
argument_list|>
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qint8
name|ts
init|=
operator|(
name|qint8
operator|)
name|QDateTimePrivate
operator|::
name|LocalUnknown
decl_stmt|;
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_0
condition|)
name|in
operator|>>
name|ts
expr_stmt|;
name|qint32
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_5_2
operator|&&
name|ts
operator|==
name|qint8
argument_list|(
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
argument_list|)
condition|)
name|in
operator|>>
name|offset
expr_stmt|;
switch|switch
condition|(
operator|(
name|QDateTimePrivate
operator|::
name|Spec
operator|)
name|ts
condition|)
block|{
case|case
name|QDateTimePrivate
operator|::
name|UTC
case|:
name|dateTime
operator|.
name|d
operator|->
name|m_spec
operator|=
name|Qt
operator|::
name|UTC
expr_stmt|;
break|break;
case|case
name|QDateTimePrivate
operator|::
name|OffsetFromUTC
case|:
name|dateTime
operator|.
name|d
operator|->
name|m_spec
operator|=
name|Qt
operator|::
name|OffsetFromUTC
expr_stmt|;
break|break;
case|case
name|QDateTimePrivate
operator|::
name|LocalUnknown
case|:
case|case
name|QDateTimePrivate
operator|::
name|LocalStandard
case|:
case|case
name|QDateTimePrivate
operator|::
name|LocalDST
case|:
name|dateTime
operator|.
name|d
operator|->
name|m_spec
operator|=
name|Qt
operator|::
name|LocalTime
expr_stmt|;
break|break;
block|}
name|dateTime
operator|.
name|d
operator|->
name|m_offsetFromUtc
operator|=
name|offset
expr_stmt|;
name|dateTime
operator|.
name|d
operator|->
name|setDateTime
argument_list|(
name|dt
argument_list|,
name|tm
argument_list|)
expr_stmt|;
block|}
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*****************************************************************************   Some static function used by QDate, QTime and QDateTime *****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function
DECL|function|rfcDateImpl
specifier|static
name|void
name|rfcDateImpl
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|QDate
modifier|*
name|dd
parameter_list|,
name|QTime
modifier|*
name|dt
parameter_list|,
name|int
modifier|*
name|utcOffset
parameter_list|)
block|{
name|int
name|day
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|month
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|year
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hour
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|min
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|sec
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hourOffset
init|=
literal|0
decl_stmt|;
name|int
name|minOffset
init|=
literal|0
decl_stmt|;
name|bool
name|positiveOffset
init|=
literal|false
decl_stmt|;
comment|// Matches "Wdy, DD Mon YYYY HH:MM:SS Â±hhmm" (Wdy, being optional)
name|QRegExp
name|rex
argument_list|(
name|QStringLiteral
argument_list|(
literal|"^(?:[A-Z][a-z]+,)?[ \\t]*(\\d{1,2})[ \\t]+([A-Z][a-z]+)[ \\t]+(\\d\\d\\d\\d)(?:[ \\t]+(\\d\\d):(\\d\\d)(?::(\\d\\d))?)?[ \\t]*(?:([+-])(\\d\\d)(\\d\\d))?"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|indexOf
argument_list|(
name|rex
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dd
condition|)
block|{
name|day
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|month
operator|=
name|qt_monthNumberFromShortName
argument_list|(
name|rex
operator|.
name|cap
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|year
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|3
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
operator|!
name|rex
operator|.
name|cap
argument_list|(
literal|4
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|hour
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|4
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|min
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|5
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|sec
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|6
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
name|positiveOffset
operator|=
operator|(
name|rex
operator|.
name|cap
argument_list|(
literal|7
argument_list|)
operator|==
name|QStringLiteral
argument_list|(
literal|"+"
argument_list|)
operator|)
expr_stmt|;
name|hourOffset
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|8
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|minOffset
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|9
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|utcOffset
condition|)
operator|*
name|utcOffset
operator|=
operator|(
operator|(
name|hourOffset
operator|*
literal|60
operator|+
name|minOffset
operator|)
operator|*
operator|(
name|positiveOffset
condition|?
literal|60
else|:
operator|-
literal|60
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// Matches "Wdy Mon DD HH:MM:SS YYYY"
name|QRegExp
name|rex
argument_list|(
name|QStringLiteral
argument_list|(
literal|"^[A-Z][a-z]+[ \\t]+([A-Z][a-z]+)[ \\t]+(\\d\\d)(?:[ \\t]+(\\d\\d):(\\d\\d):(\\d\\d))?[ \\t]+(\\d\\d\\d\\d)[ \\t]*(?:([+-])(\\d\\d)(\\d\\d))?"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|indexOf
argument_list|(
name|rex
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dd
condition|)
block|{
name|month
operator|=
name|qt_monthNumberFromShortName
argument_list|(
name|rex
operator|.
name|cap
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|day
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|2
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|year
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|6
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
operator|!
name|rex
operator|.
name|cap
argument_list|(
literal|3
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|hour
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|3
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|min
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|4
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|sec
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|5
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
name|positiveOffset
operator|=
operator|(
name|rex
operator|.
name|cap
argument_list|(
literal|7
argument_list|)
operator|==
name|QStringLiteral
argument_list|(
literal|"+"
argument_list|)
operator|)
expr_stmt|;
name|hourOffset
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|8
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|minOffset
operator|=
name|rex
operator|.
name|cap
argument_list|(
literal|9
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|utcOffset
condition|)
operator|*
name|utcOffset
operator|=
operator|(
operator|(
name|hourOffset
operator|*
literal|60
operator|+
name|minOffset
operator|)
operator|*
operator|(
name|positiveOffset
condition|?
literal|60
else|:
operator|-
literal|60
operator|)
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dd
condition|)
operator|*
name|dd
operator|=
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt
condition|)
operator|*
name|dt
operator|=
name|QTime
argument_list|(
name|hour
argument_list|,
name|min
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_DATESTRING
argument_list|)
end_if
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QDate
modifier|&
name|date
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QDate("
operator|<<
name|date
operator|.
name|toString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"yyyy-MM-dd"
argument_list|)
argument_list|)
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QTime("
operator|<<
name|time
operator|.
name|toString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"HH:mm:ss.zzz"
argument_list|)
argument_list|)
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|date
parameter_list|)
block|{
name|QString
name|spec
decl_stmt|;
switch|switch
condition|(
name|date
operator|.
name|d
operator|->
name|m_spec
condition|)
block|{
case|case
name|Qt
operator|::
name|UTC
case|:
name|spec
operator|=
name|QStringLiteral
argument_list|(
literal|" Qt::UTC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|OffsetFromUTC
case|:
name|spec
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
literal|" Qt::OffsetFromUTC %1s"
argument_list|)
operator|.
name|arg
argument_list|(
name|date
operator|.
name|offsetFromUtc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|LocalTime
case|:
name|spec
operator|=
name|QStringLiteral
argument_list|(
literal|" Qt::LocalTime"
argument_list|)
expr_stmt|;
break|break;
block|}
name|QString
name|output
init|=
name|date
operator|.
name|toString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"yyyy-MM-dd HH:mm:ss.zzz t"
argument_list|)
argument_list|)
operator|+
name|spec
decl_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QDateTime("
operator|<<
name|output
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \fn uint qHash(const QDateTime&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_function
DECL|function|qHash
name|uint
name|qHash
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
block|{
comment|// Use to toMSecsSinceEpoch instead of individual qHash functions for
comment|// QDate/QTime/spec/offset because QDateTime::operator== converts both arguments
comment|// to the same timezone. If we don't, qHash would return different hashes for
comment|// two QDateTimes that are equivalent once converted to the same timezone.
return|return
name|qHash
argument_list|(
name|key
operator|.
name|toMSecsSinceEpoch
argument_list|()
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn uint qHash(const QDate&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_function
name|uint
name|qHash
parameter_list|(
specifier|const
name|QDate
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|qHash
argument_list|(
name|key
operator|.
name|toJulianDay
argument_list|()
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn uint qHash(const QTime&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_function
name|uint
name|qHash
parameter_list|(
specifier|const
name|QTime
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|qHash
argument_list|(
name|key
operator|.
name|msecsSinceStartOfDay
argument_list|()
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
