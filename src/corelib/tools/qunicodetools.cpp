begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qunicodetools_p.h"
end_include
begin_include
include|#
directive|include
file|"qunicodetables_p.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|qt_initcharattributes_default_algorithm_only
name|Q_AUTOTEST_EXPORT
name|int
name|qt_initcharattributes_default_algorithm_only
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_namespace
DECL|namespace|QUnicodeTools
namespace|namespace
name|QUnicodeTools
block|{
comment|// -----------------------------------------------------------------------------------------------------
comment|//
comment|// The line breaking algorithm. See http://www.unicode.org/reports/tr14/tr14-19.html
comment|//
comment|// -----------------------------------------------------------------------------------------------------
comment|//
comment|// The text boundaries determination algorithm. See http://www.unicode.org/reports/tr29/tr29-11.html
comment|//
comment|// -----------------------------------------------------------------------------------------------------
comment|/* The Unicode algorithm does in our opinion allow line breaks at some    places they shouldn't be allowed. The following changes were thus    made in comparison to the Unicode reference:     EX->AL from DB to IB    SY->AL from DB to IB    SY->PO from DB to IB    SY->PR from DB to IB    SY->OP from DB to IB    AL->PR from DB to IB    AL->PO from DB to IB    PR->PR from DB to IB    PO->PO from DB to IB    PR->PO from DB to IB    PO->PR from DB to IB    HY->PO from DB to IB    HY->PR from DB to IB    HY->OP from DB to IB    NU->EX from PB to IB    EX->PO from DB to IB */
comment|// The following line break classes are not treated by the table:
comment|//  AI, BK, CB, CR, LF, NL, SA, SG, SP, XX
DECL|enum|LineBreakRule
enum|enum
name|LineBreakRule
block|{
DECL|enumerator|ProhibitedBreak
name|ProhibitedBreak
block|,
comment|// PB in table
DECL|enumerator|DirectBreak
name|DirectBreak
block|,
comment|// DB in table
DECL|enumerator|IndirectBreak
name|IndirectBreak
block|,
comment|// IB in table
DECL|enumerator|CombiningIndirectBreak
name|CombiningIndirectBreak
block|,
comment|// CI in table
DECL|enumerator|CombiningProhibitedBreak
name|CombiningProhibitedBreak
comment|// CP in table
block|}
enum|;
DECL|macro|DB
define|#
directive|define
name|DB
value|DirectBreak
DECL|macro|IB
define|#
directive|define
name|IB
value|IndirectBreak
DECL|macro|CI
define|#
directive|define
name|CI
value|CombiningIndirectBreak
DECL|macro|CP
define|#
directive|define
name|CP
value|CombiningProhibitedBreak
DECL|macro|PB
define|#
directive|define
name|PB
value|ProhibitedBreak
DECL|member|lineBreakTable
specifier|static
specifier|const
name|uchar
name|lineBreakTable
index|[
name|QUnicodeTables
operator|::
name|LineBreak_JT
operator|+
literal|1
index|]
index|[
name|QUnicodeTables
operator|::
name|LineBreak_JT
operator|+
literal|1
index|]
init|=
block|{
comment|/*         OP  CL  QU  GL  NS  EX  SY  IS  PR  PO  NU  AL  ID  IN  HY  BA  BB  B2  ZW  CM  WJ  H2  H3  JL  JV  JT */
comment|/* OP */
block|{
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|CP
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|}
block|,
comment|/* CL */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* QU */
block|{
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|}
block|,
comment|/* GL */
block|{
name|IB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|}
block|,
comment|/* NS */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* EX */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* SY */
block|{
name|IB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* IS */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* PR */
block|{
name|IB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|}
block|,
comment|/* PO */
block|{
name|IB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* NU */
block|{
name|IB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* AL */
block|{
name|IB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* ID */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* IN */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* HY */
block|{
name|IB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* BA */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* BB */
block|{
name|IB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|}
block|,
comment|/* B2 */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* ZW */
block|{
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* CM */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* WJ */
block|{
name|IB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|}
block|,
comment|/* H2 */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|}
block|,
comment|/* H3 */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|}
block|,
comment|/* JL */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|}
block|,
comment|/* JV */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|}
block|,
comment|/* JT */
block|{
name|DB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|}
block|}
decl_stmt|;
DECL|macro|DB
undef|#
directive|undef
name|DB
DECL|macro|IB
undef|#
directive|undef
name|IB
DECL|macro|CI
undef|#
directive|undef
name|CI
DECL|macro|CP
undef|#
directive|undef
name|CP
DECL|macro|PB
undef|#
directive|undef
name|PB
DECL|member|graphemeBreakTable
specifier|static
specifier|const
name|uchar
name|graphemeBreakTable
index|[
name|QUnicodeTables
operator|::
name|GraphemeBreakLVT
operator|+
literal|1
index|]
index|[
name|QUnicodeTables
operator|::
name|GraphemeBreakLVT
operator|+
literal|1
index|]
init|=
block|{
comment|//    Other, CR,    LF,  Control, Extend, L,     V,     T,     LV,    LVT
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// Other,
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// CR,
block|{
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// LF,
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// Control,
block|{
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|}
block|,
comment|// Extend,
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// L,
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|false
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|}
block|,
comment|// V,
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|}
block|,
comment|// T,
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// LV,
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// LVT
block|}
decl_stmt|;
DECL|function|calcGraphemeAndLineBreaks
specifier|static
name|void
name|calcGraphemeAndLineBreaks
parameter_list|(
specifier|const
name|ushort
modifier|*
name|string
parameter_list|,
name|quint32
name|len
parameter_list|,
name|HB_CharAttributes
modifier|*
name|attributes
parameter_list|)
block|{
comment|// ##### can this fail if the first char is a surrogate?
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|prop
init|=
name|QUnicodeTables
operator|::
name|properties
argument_list|(
name|string
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|QUnicodeTables
operator|::
name|GraphemeBreak
name|grapheme
init|=
operator|(
name|QUnicodeTables
operator|::
name|GraphemeBreak
operator|)
name|prop
operator|->
name|graphemeBreak
decl_stmt|;
name|QUnicodeTables
operator|::
name|LineBreakClass
name|cls
init|=
operator|(
name|QUnicodeTables
operator|::
name|LineBreakClass
operator|)
name|prop
operator|->
name|line_break_class
decl_stmt|;
comment|// handle case where input starts with an LF
if|if
condition|(
name|cls
operator|==
name|QUnicodeTables
operator|::
name|LineBreak_LF
condition|)
name|cls
operator|=
name|QUnicodeTables
operator|::
name|LineBreak_BK
expr_stmt|;
name|attributes
index|[
literal|0
index|]
operator|.
name|whiteSpace
operator|=
operator|(
name|cls
operator|==
name|QUnicodeTables
operator|::
name|LineBreak_SP
operator|||
name|cls
operator|==
name|QUnicodeTables
operator|::
name|LineBreak_BK
operator|)
expr_stmt|;
name|attributes
index|[
literal|0
index|]
operator|.
name|charStop
operator|=
literal|true
expr_stmt|;
name|int
name|lcls
init|=
name|cls
decl_stmt|;
for|for
control|(
name|quint32
name|i
init|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|attributes
index|[
name|i
index|]
operator|.
name|whiteSpace
operator|=
literal|false
expr_stmt|;
name|attributes
index|[
name|i
index|]
operator|.
name|charStop
operator|=
literal|true
expr_stmt|;
name|uint
name|ucs4
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
name|prop
operator|=
name|QUnicodeTables
operator|::
name|properties
argument_list|(
name|ucs4
argument_list|)
expr_stmt|;
name|QUnicodeTables
operator|::
name|GraphemeBreak
name|ngrapheme
init|=
operator|(
name|QUnicodeTables
operator|::
name|GraphemeBreak
operator|)
name|prop
operator|->
name|graphemeBreak
decl_stmt|;
name|QUnicodeTables
operator|::
name|LineBreakClass
name|ncls
init|=
operator|(
name|QUnicodeTables
operator|::
name|LineBreakClass
operator|)
name|prop
operator|->
name|line_break_class
decl_stmt|;
name|attributes
index|[
name|i
index|]
operator|.
name|charStop
operator|=
name|graphemeBreakTable
index|[
name|ngrapheme
index|]
index|[
name|grapheme
index|]
expr_stmt|;
comment|// handle surrogates
if|if
condition|(
name|ncls
operator|==
name|QUnicodeTables
operator|::
name|LineBreak_SG
condition|)
block|{
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
operator|&&
name|i
operator|<
name|len
operator|-
literal|1
operator|&&
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|string
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
operator|&&
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|string
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|ucs4
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|string
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|prop
operator|=
name|QUnicodeTables
operator|::
name|properties
argument_list|(
name|ucs4
argument_list|)
expr_stmt|;
name|ngrapheme
operator|=
operator|(
name|QUnicodeTables
operator|::
name|GraphemeBreak
operator|)
name|prop
operator|->
name|graphemeBreak
expr_stmt|;
name|ncls
operator|=
operator|(
name|QUnicodeTables
operator|::
name|LineBreakClass
operator|)
name|prop
operator|->
name|line_break_class
expr_stmt|;
name|attributes
index|[
name|i
index|]
operator|.
name|charStop
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|ncls
operator|=
name|QUnicodeTables
operator|::
name|LineBreak_AL
expr_stmt|;
block|}
block|}
comment|// set white space and char stop flag
if|if
condition|(
name|ncls
operator|>=
name|QUnicodeTables
operator|::
name|LineBreak_SP
condition|)
name|attributes
index|[
name|i
index|]
operator|.
name|whiteSpace
operator|=
literal|true
expr_stmt|;
name|HB_LineBreakType
name|lineBreakType
init|=
name|HB_NoBreak
decl_stmt|;
if|if
condition|(
name|cls
operator|>=
name|QUnicodeTables
operator|::
name|LineBreak_LF
condition|)
block|{
name|lineBreakType
operator|=
name|HB_ForcedBreak
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cls
operator|==
name|QUnicodeTables
operator|::
name|LineBreak_CR
condition|)
block|{
name|lineBreakType
operator|=
operator|(
name|ncls
operator|==
name|QUnicodeTables
operator|::
name|LineBreak_LF
operator|)
condition|?
name|HB_NoBreak
else|:
name|HB_ForcedBreak
expr_stmt|;
block|}
if|if
condition|(
name|ncls
operator|==
name|QUnicodeTables
operator|::
name|LineBreak_SP
condition|)
goto|goto
name|next_no_cls_update
goto|;
if|if
condition|(
name|ncls
operator|>=
name|QUnicodeTables
operator|::
name|LineBreak_CR
condition|)
goto|goto
name|next
goto|;
block|{
name|int
name|tcls
init|=
name|ncls
decl_stmt|;
comment|// for south east asian chars that require a complex (dictionary analysis), the unicode
comment|// standard recommends to treat them as AL. thai_attributes and other attribute methods that
comment|// do dictionary analysis can override
if|if
condition|(
name|tcls
operator|>=
name|QUnicodeTables
operator|::
name|LineBreak_SA
condition|)
name|tcls
operator|=
name|QUnicodeTables
operator|::
name|LineBreak_AL
expr_stmt|;
if|if
condition|(
name|cls
operator|>=
name|QUnicodeTables
operator|::
name|LineBreak_SA
condition|)
name|cls
operator|=
name|QUnicodeTables
operator|::
name|LineBreak_AL
expr_stmt|;
name|int
name|brk
init|=
name|lineBreakTable
index|[
name|cls
index|]
index|[
name|tcls
index|]
decl_stmt|;
switch|switch
condition|(
name|brk
condition|)
block|{
case|case
name|DirectBreak
case|:
name|lineBreakType
operator|=
name|HB_Break
expr_stmt|;
if|if
condition|(
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|0xad
condition|)
comment|// soft hyphen
name|lineBreakType
operator|=
name|HB_SoftHyphen
expr_stmt|;
break|break;
case|case
name|IndirectBreak
case|:
name|lineBreakType
operator|=
operator|(
name|lcls
operator|==
name|QUnicodeTables
operator|::
name|LineBreak_SP
operator|)
condition|?
name|HB_Break
else|:
name|HB_NoBreak
expr_stmt|;
break|break;
case|case
name|CombiningIndirectBreak
case|:
name|lineBreakType
operator|=
name|HB_NoBreak
expr_stmt|;
if|if
condition|(
name|lcls
operator|==
name|QUnicodeTables
operator|::
name|LineBreak_SP
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|attributes
index|[
name|i
operator|-
literal|2
index|]
operator|.
name|lineBreakType
operator|=
name|HB_Break
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|next_no_cls_update
goto|;
block|}
break|break;
case|case
name|CombiningProhibitedBreak
case|:
name|lineBreakType
operator|=
name|HB_NoBreak
expr_stmt|;
if|if
condition|(
name|lcls
operator|!=
name|QUnicodeTables
operator|::
name|LineBreak_SP
condition|)
goto|goto
name|next_no_cls_update
goto|;
case|case
name|ProhibitedBreak
case|:
default|default:
break|break;
block|}
block|}
name|next
label|:
name|cls
operator|=
name|ncls
expr_stmt|;
name|next_no_cls_update
label|:
name|lcls
operator|=
name|ncls
expr_stmt|;
name|grapheme
operator|=
name|ngrapheme
expr_stmt|;
name|attributes
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|lineBreakType
operator|=
name|lineBreakType
expr_stmt|;
block|}
name|attributes
index|[
name|len
operator|-
literal|1
index|]
operator|.
name|lineBreakType
operator|=
name|HB_ForcedBreak
expr_stmt|;
block|}
DECL|enum|WordBreakRule
DECL|enumerator|NoBreak
DECL|enumerator|Break
DECL|enumerator|Middle
enum|enum
name|WordBreakRule
block|{
name|NoBreak
init|=
literal|0
block|,
name|Break
init|=
literal|1
block|,
name|Middle
init|=
literal|2
block|}
enum|;
DECL|member|wordBreakTable
specifier|static
specifier|const
name|uchar
name|wordBreakTable
index|[
name|QUnicodeTables
operator|::
name|WordBreakExtendNumLet
operator|+
literal|1
index|]
index|[
name|QUnicodeTables
operator|::
name|WordBreakExtendNumLet
operator|+
literal|1
index|]
init|=
block|{
comment|//    Other    Format   Katakana ALetter  MidLetter MidNum  Numeric  ExtendNumLet
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// Other
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// Format
block|{
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|}
block|,
comment|// Katakana
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Middle
block|,
name|Break
block|,
name|NoBreak
block|,
name|NoBreak
block|}
block|,
comment|// ALetter
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// MidLetter
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// MidNum
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Break
block|,
name|Middle
block|,
name|NoBreak
block|,
name|NoBreak
block|}
block|,
comment|// Numeric
block|{
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|NoBreak
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|NoBreak
block|}
block|,
comment|// ExtendNumLet
block|}
decl_stmt|;
DECL|function|calcWordBreaks
specifier|static
name|void
name|calcWordBreaks
parameter_list|(
specifier|const
name|ushort
modifier|*
name|string
parameter_list|,
name|quint32
name|len
parameter_list|,
name|HB_CharAttributes
modifier|*
name|attributes
parameter_list|)
block|{
name|quint32
name|brk
init|=
name|QUnicodeTables
operator|::
name|wordBreakClass
argument_list|(
name|string
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|attributes
index|[
literal|0
index|]
operator|.
name|wordBoundary
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|quint32
name|i
init|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|attributes
index|[
name|i
index|]
operator|.
name|charStop
condition|)
block|{
name|attributes
index|[
name|i
index|]
operator|.
name|wordBoundary
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
name|quint32
name|nbrk
init|=
name|QUnicodeTables
operator|::
name|wordBreakClass
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbrk
operator|==
name|QUnicodeTables
operator|::
name|WordBreakFormat
condition|)
block|{
name|attributes
index|[
name|i
index|]
operator|.
name|wordBoundary
operator|=
operator|(
name|QUnicodeTables
operator|::
name|sentenceBreakClass
argument_list|(
name|string
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|==
name|QUnicodeTables
operator|::
name|SentenceBreakSep
operator|)
expr_stmt|;
continue|continue;
block|}
name|WordBreakRule
name|rule
init|=
operator|(
name|WordBreakRule
operator|)
name|wordBreakTable
index|[
name|brk
index|]
index|[
name|nbrk
index|]
decl_stmt|;
if|if
condition|(
name|rule
operator|==
name|Middle
condition|)
block|{
name|rule
operator|=
name|Break
expr_stmt|;
name|quint32
name|lookahead
init|=
name|i
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|lookahead
operator|<
name|len
condition|)
block|{
name|quint32
name|testbrk
init|=
name|QUnicodeTables
operator|::
name|wordBreakClass
argument_list|(
name|string
index|[
name|lookahead
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|testbrk
operator|==
name|QUnicodeTables
operator|::
name|WordBreakFormat
operator|&&
name|QUnicodeTables
operator|::
name|sentenceBreakClass
argument_list|(
name|string
index|[
name|lookahead
index|]
argument_list|)
operator|!=
name|QUnicodeTables
operator|::
name|SentenceBreakSep
condition|)
block|{
operator|++
name|lookahead
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|testbrk
operator|==
name|brk
condition|)
block|{
name|rule
operator|=
name|NoBreak
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|lookahead
condition|)
name|attributes
index|[
name|i
operator|++
index|]
operator|.
name|wordBoundary
operator|=
literal|false
expr_stmt|;
name|nbrk
operator|=
name|testbrk
expr_stmt|;
block|}
break|break;
block|}
block|}
name|attributes
index|[
name|i
index|]
operator|.
name|wordBoundary
operator|=
operator|(
name|rule
operator|==
name|Break
operator|)
expr_stmt|;
name|brk
operator|=
name|nbrk
expr_stmt|;
block|}
block|}
DECL|enum|SentenceBreakState
enum|enum
name|SentenceBreakState
block|{
DECL|enumerator|SB_Initial
name|SB_Initial
block|,
DECL|enumerator|SB_Upper
name|SB_Upper
block|,
DECL|enumerator|SB_UpATerm
name|SB_UpATerm
block|,
DECL|enumerator|SB_ATerm
name|SB_ATerm
block|,
DECL|enumerator|SB_ATermC
name|SB_ATermC
block|,
DECL|enumerator|SB_ACS
name|SB_ACS
block|,
DECL|enumerator|SB_STerm
name|SB_STerm
block|,
DECL|enumerator|SB_STermC
name|SB_STermC
block|,
DECL|enumerator|SB_SCS
name|SB_SCS
block|,
DECL|enumerator|SB_BAfter
name|SB_BAfter
block|,
DECL|enumerator|SB_Break
name|SB_Break
block|,
DECL|enumerator|SB_Lookup
name|SB_Lookup
block|}
enum|;
DECL|member|sentenceBreakTable
specifier|static
specifier|const
name|uchar
name|sentenceBreakTable
index|[
name|SB_Lookup
operator|+
literal|1
index|]
index|[
name|QUnicodeTables
operator|::
name|SentenceBreakClose
operator|+
literal|1
index|]
init|=
block|{
comment|//      Other       Sep         Format      Sp          Lower       Upper       OLetter     Numeric     ATerm       STerm       Close
block|{
name|SB_Initial
block|,
name|SB_BAfter
block|,
name|SB_Initial
block|,
name|SB_Initial
block|,
name|SB_Initial
block|,
name|SB_Upper
block|,
name|SB_Initial
block|,
name|SB_Initial
block|,
name|SB_ATerm
block|,
name|SB_STerm
block|,
name|SB_Initial
block|}
block|,
comment|// SB_Initial,
block|{
name|SB_Initial
block|,
name|SB_BAfter
block|,
name|SB_Upper
block|,
name|SB_Initial
block|,
name|SB_Initial
block|,
name|SB_Upper
block|,
name|SB_Initial
block|,
name|SB_Initial
block|,
name|SB_UpATerm
block|,
name|SB_STerm
block|,
name|SB_Initial
block|}
block|,
comment|// SB_Upper
block|{
name|SB_Lookup
block|,
name|SB_BAfter
block|,
name|SB_UpATerm
block|,
name|SB_ACS
block|,
name|SB_Initial
block|,
name|SB_Upper
block|,
name|SB_Break
block|,
name|SB_Initial
block|,
name|SB_ATerm
block|,
name|SB_STerm
block|,
name|SB_ATermC
block|}
block|,
comment|// SB_UpATerm
block|{
name|SB_Lookup
block|,
name|SB_BAfter
block|,
name|SB_ATerm
block|,
name|SB_ACS
block|,
name|SB_Initial
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Initial
block|,
name|SB_ATerm
block|,
name|SB_STerm
block|,
name|SB_ATermC
block|}
block|,
comment|// SB_ATerm
block|{
name|SB_Lookup
block|,
name|SB_BAfter
block|,
name|SB_ATermC
block|,
name|SB_ACS
block|,
name|SB_Initial
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Lookup
block|,
name|SB_ATerm
block|,
name|SB_STerm
block|,
name|SB_ATermC
block|}
block|,
comment|// SB_ATermC,
block|{
name|SB_Lookup
block|,
name|SB_BAfter
block|,
name|SB_ACS
block|,
name|SB_ACS
block|,
name|SB_Initial
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Lookup
block|,
name|SB_ATerm
block|,
name|SB_STerm
block|,
name|SB_Lookup
block|}
block|,
comment|// SB_ACS,
block|{
name|SB_Break
block|,
name|SB_BAfter
block|,
name|SB_STerm
block|,
name|SB_SCS
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_ATerm
block|,
name|SB_STerm
block|,
name|SB_STermC
block|}
block|,
comment|// SB_STerm,
block|{
name|SB_Break
block|,
name|SB_BAfter
block|,
name|SB_STermC
block|,
name|SB_SCS
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_ATerm
block|,
name|SB_STerm
block|,
name|SB_STermC
block|}
block|,
comment|// SB_STermC,
block|{
name|SB_Break
block|,
name|SB_BAfter
block|,
name|SB_SCS
block|,
name|SB_SCS
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_ATerm
block|,
name|SB_STerm
block|,
name|SB_Break
block|}
block|,
comment|// SB_SCS,
block|{
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|,
name|SB_Break
block|}
block|,
comment|// SB_BAfter,
block|}
decl_stmt|;
DECL|function|calcSentenceBreaks
specifier|static
name|void
name|calcSentenceBreaks
parameter_list|(
specifier|const
name|ushort
modifier|*
name|string
parameter_list|,
name|quint32
name|len
parameter_list|,
name|HB_CharAttributes
modifier|*
name|attributes
parameter_list|)
block|{
name|quint32
name|brk
init|=
name|sentenceBreakTable
index|[
name|SB_Initial
index|]
index|[
name|QUnicodeTables
operator|::
name|sentenceBreakClass
argument_list|(
name|string
index|[
literal|0
index|]
argument_list|)
index|]
decl_stmt|;
name|attributes
index|[
literal|0
index|]
operator|.
name|sentenceBoundary
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|quint32
name|i
init|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|attributes
index|[
name|i
index|]
operator|.
name|charStop
condition|)
block|{
name|attributes
index|[
name|i
index|]
operator|.
name|sentenceBoundary
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
name|brk
operator|=
name|sentenceBreakTable
index|[
name|brk
index|]
index|[
name|QUnicodeTables
operator|::
name|sentenceBreakClass
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|brk
operator|==
name|SB_Lookup
condition|)
block|{
name|brk
operator|=
name|SB_Break
expr_stmt|;
name|quint32
name|lookahead
init|=
name|i
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|lookahead
operator|<
name|len
condition|)
block|{
name|quint32
name|sbrk
init|=
name|QUnicodeTables
operator|::
name|sentenceBreakClass
argument_list|(
name|string
index|[
name|lookahead
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|sbrk
operator|!=
name|QUnicodeTables
operator|::
name|SentenceBreakOther
operator|&&
name|sbrk
operator|!=
name|QUnicodeTables
operator|::
name|SentenceBreakNumeric
operator|&&
name|sbrk
operator|!=
name|QUnicodeTables
operator|::
name|SentenceBreakClose
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|sbrk
operator|==
name|QUnicodeTables
operator|::
name|SentenceBreakLower
condition|)
block|{
name|brk
operator|=
name|SB_Initial
expr_stmt|;
break|break;
block|}
operator|++
name|lookahead
expr_stmt|;
block|}
if|if
condition|(
name|brk
operator|==
name|SB_Initial
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|lookahead
condition|)
name|attributes
index|[
name|i
operator|++
index|]
operator|.
name|sentenceBoundary
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|brk
operator|==
name|SB_Break
condition|)
block|{
name|attributes
index|[
name|i
index|]
operator|.
name|sentenceBoundary
operator|=
literal|true
expr_stmt|;
name|brk
operator|=
name|sentenceBreakTable
index|[
name|SB_Initial
index|]
index|[
name|QUnicodeTables
operator|::
name|sentenceBreakClass
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|attributes
index|[
name|i
index|]
operator|.
name|sentenceBoundary
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
DECL|function|initCharAttributes
name|Q_CORE_EXPORT
name|void
name|initCharAttributes
parameter_list|(
specifier|const
name|ushort
modifier|*
name|string
parameter_list|,
name|int
name|length
parameter_list|,
specifier|const
name|HB_ScriptItem
modifier|*
name|items
parameter_list|,
name|int
name|numItems
parameter_list|,
name|HB_CharAttributes
modifier|*
name|attributes
parameter_list|,
name|CharAttributeOptions
name|options
parameter_list|)
block|{
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|DontClearAttributes
operator|)
condition|)
block|{
operator|::
name|memset
argument_list|(
name|attributes
argument_list|,
literal|0
argument_list|,
name|length
operator|*
sizeof|sizeof
argument_list|(
name|HB_CharAttributes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
operator|(
name|WordBreaks
operator||
name|SentenceBreaks
operator|)
condition|)
name|options
operator||=
name|GraphemeBreaks
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
operator|(
name|GraphemeBreaks
operator||
name|LineBreaks
operator||
name|WhiteSpaces
operator|)
condition|)
name|calcGraphemeAndLineBreaks
argument_list|(
name|string
argument_list|,
name|length
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|WordBreaks
condition|)
name|calcWordBreaks
argument_list|(
name|string
argument_list|,
name|length
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|SentenceBreaks
condition|)
name|calcSentenceBreaks
argument_list|(
name|string
argument_list|,
name|length
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|items
operator|||
name|numItems
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|qt_initcharattributes_default_algorithm_only
condition|)
name|HB_GetTailoredCharAttributes
argument_list|(
name|string
argument_list|,
name|length
argument_list|,
name|items
argument_list|,
name|numItems
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace QUnicodeTools
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
