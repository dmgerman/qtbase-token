begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qunicodetools_p.h"
end_include
begin_include
include|#
directive|include
file|"qunicodetables_p.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qharfbuzz_p.h"
end_include
begin_define
DECL|macro|FLAG
define|#
directive|define
name|FLAG
parameter_list|(
name|x
parameter_list|)
value|(1<< (x))
end_define
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|qt_initcharattributes_default_algorithm_only
name|Q_AUTOTEST_EXPORT
name|int
name|qt_initcharattributes_default_algorithm_only
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_namespace
DECL|namespace|QUnicodeTools
namespace|namespace
name|QUnicodeTools
block|{
comment|// -----------------------------------------------------------------------------------------------------
comment|//
comment|// The text boundaries determination algorithm.
comment|// See http://www.unicode.org/reports/tr29/tr29-21.html
comment|//
comment|// -----------------------------------------------------------------------------------------------------
DECL|namespace|GB
namespace|namespace
name|GB
block|{
DECL|member|breakTable
specifier|static
specifier|const
name|uchar
name|breakTable
index|[
name|QUnicodeTables
operator|::
name|GraphemeBreak_LVT
operator|+
literal|1
index|]
index|[
name|QUnicodeTables
operator|::
name|GraphemeBreak_LVT
operator|+
literal|1
index|]
init|=
block|{
comment|//    Other   CR     LF  Control Extend   RI  Prepend S-Mark   L      V      T      LV    LVT
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// Other
block|{
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// CR
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// LF
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// Control
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// Extend
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|false
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// RegionalIndicator
block|{
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|}
block|,
comment|// Prepend
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// SpacingMark
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|false
block|,
literal|false
block|,
literal|true
block|,
literal|false
block|,
literal|false
block|}
block|,
comment|// L
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|false
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// V
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// T
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|false
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// LV
block|{
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|,
literal|false
block|,
literal|true
block|,
literal|true
block|}
block|,
comment|// LVT
block|}
decl_stmt|;
block|}
comment|// namespace GB
DECL|function|getGraphemeBreaks
specifier|static
name|void
name|getGraphemeBreaks
parameter_list|(
specifier|const
name|ushort
modifier|*
name|string
parameter_list|,
name|quint32
name|len
parameter_list|,
name|QCharAttributes
modifier|*
name|attributes
parameter_list|)
block|{
name|QUnicodeTables
operator|::
name|GraphemeBreakClass
name|lcls
init|=
name|QUnicodeTables
operator|::
name|GraphemeBreak_LF
decl_stmt|;
comment|// to meet GB1
for|for
control|(
name|quint32
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|len
condition|;
operator|++
name|i
control|)
block|{
name|quint32
name|pos
init|=
name|i
decl_stmt|;
name|uint
name|ucs4
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|ucs4
argument_list|)
operator|&&
name|i
operator|+
literal|1
operator|!=
name|len
condition|)
block|{
name|ushort
name|low
init|=
name|string
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|ucs4
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|ucs4
argument_list|,
name|low
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|prop
init|=
name|QUnicodeTables
operator|::
name|properties
argument_list|(
name|ucs4
argument_list|)
decl_stmt|;
name|QUnicodeTables
operator|::
name|GraphemeBreakClass
name|cls
init|=
operator|(
name|QUnicodeTables
operator|::
name|GraphemeBreakClass
operator|)
name|prop
operator|->
name|graphemeBreakClass
decl_stmt|;
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|GB
operator|::
name|breakTable
index|[
name|lcls
index|]
index|[
name|cls
index|]
argument_list|)
condition|)
name|attributes
index|[
name|pos
index|]
operator|.
name|graphemeBoundary
operator|=
literal|true
expr_stmt|;
name|lcls
operator|=
name|cls
expr_stmt|;
block|}
name|attributes
index|[
name|len
index|]
operator|.
name|graphemeBoundary
operator|=
literal|true
expr_stmt|;
comment|// GB2
block|}
DECL|namespace|WB
namespace|namespace
name|WB
block|{
DECL|enum|Action
enum|enum
name|Action
block|{
DECL|enumerator|NoBreak
name|NoBreak
init|=
literal|0
block|,
DECL|enumerator|Break
name|Break
init|=
literal|1
block|,
DECL|enumerator|Lookup
name|Lookup
init|=
literal|2
block|}
enum|;
DECL|member|breakTable
specifier|static
specifier|const
name|uchar
name|breakTable
index|[
name|QUnicodeTables
operator|::
name|WordBreak_ExtendNumLet
operator|+
literal|1
index|]
index|[
name|QUnicodeTables
operator|::
name|WordBreak_ExtendNumLet
operator|+
literal|1
index|]
init|=
block|{
comment|//    Other      CR       LF    Newline   Extend    RI    Katakana ALetter MidNumLet MidLetter MidNum  Numeric  ExtendNumLet
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// Other
block|{
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// CR
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// LF
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// Newline
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// Extend
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|NoBreak
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// RegionalIndicator
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Break
block|,
name|NoBreak
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|}
block|,
comment|// Katakana
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Lookup
block|,
name|Lookup
block|,
name|Break
block|,
name|NoBreak
block|,
name|NoBreak
block|}
block|,
comment|// ALetter
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// MidNumLet
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// MidLetter
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// MidNum
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Lookup
block|,
name|Break
block|,
name|Lookup
block|,
name|NoBreak
block|,
name|NoBreak
block|}
block|,
comment|// Numeric
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|Break
block|,
name|NoBreak
block|,
name|NoBreak
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|NoBreak
block|,
name|NoBreak
block|}
block|,
comment|// ExtendNumLet
block|}
decl_stmt|;
block|}
comment|// namespace WB
DECL|function|getWordBreaks
specifier|static
name|void
name|getWordBreaks
parameter_list|(
specifier|const
name|ushort
modifier|*
name|string
parameter_list|,
name|quint32
name|len
parameter_list|,
name|QCharAttributes
modifier|*
name|attributes
parameter_list|)
block|{
enum|enum
name|WordType
block|{
name|WordTypeNone
block|,
name|WordTypeAlphaNumeric
block|,
name|WordTypeHiraganaKatakana
block|}
name|currentWordType
init|=
name|WordTypeNone
enum|;
name|QUnicodeTables
operator|::
name|WordBreakClass
name|cls
init|=
name|QUnicodeTables
operator|::
name|WordBreak_LF
decl_stmt|;
comment|// to meet WB1
for|for
control|(
name|quint32
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|len
condition|;
operator|++
name|i
control|)
block|{
name|quint32
name|pos
init|=
name|i
decl_stmt|;
name|uint
name|ucs4
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|ucs4
argument_list|)
operator|&&
name|i
operator|+
literal|1
operator|!=
name|len
condition|)
block|{
name|ushort
name|low
init|=
name|string
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|ucs4
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|ucs4
argument_list|,
name|low
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|prop
init|=
name|QUnicodeTables
operator|::
name|properties
argument_list|(
name|ucs4
argument_list|)
decl_stmt|;
name|QUnicodeTables
operator|::
name|WordBreakClass
name|ncls
init|=
operator|(
name|QUnicodeTables
operator|::
name|WordBreakClass
operator|)
name|prop
operator|->
name|wordBreakClass
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_BUILD_INTERNAL
if|if
condition|(
name|qt_initcharattributes_default_algorithm_only
condition|)
block|{
comment|// as of Unicode 5.1, some punctuation marks were mapped to MidLetter and MidNumLet
comment|// which caused "hi.there" to be treated like if it were just a single word;
comment|// by remapping those characters in the Unicode tables generator.
comment|// this code is needed to pass the coverage tests; remove once the issue is fixed.
if|if
condition|(
name|ucs4
operator|==
literal|0x002E
condition|)
comment|// FULL STOP
name|ncls
operator|=
name|QUnicodeTables
operator|::
name|WordBreak_MidNumLet
expr_stmt|;
elseif|else
if|if
condition|(
name|ucs4
operator|==
literal|0x003A
condition|)
comment|// COLON
name|ncls
operator|=
name|QUnicodeTables
operator|::
name|WordBreak_MidLetter
expr_stmt|;
block|}
endif|#
directive|endif
name|uchar
name|action
init|=
name|WB
operator|::
name|breakTable
index|[
name|cls
index|]
index|[
name|ncls
index|]
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|action
operator|==
name|WB
operator|::
name|Lookup
argument_list|)
condition|)
block|{
name|action
operator|=
name|WB
operator|::
name|Break
expr_stmt|;
for|for
control|(
name|quint32
name|lookahead
init|=
name|i
operator|+
literal|1
init|;
name|lookahead
operator|<
name|len
condition|;
operator|++
name|lookahead
control|)
block|{
name|ucs4
operator|=
name|string
index|[
name|lookahead
index|]
expr_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|ucs4
argument_list|)
operator|&&
name|lookahead
operator|+
literal|1
operator|!=
name|len
condition|)
block|{
name|ushort
name|low
init|=
name|string
index|[
name|lookahead
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|ucs4
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|ucs4
argument_list|,
name|low
argument_list|)
expr_stmt|;
operator|++
name|lookahead
expr_stmt|;
block|}
block|}
name|prop
operator|=
name|QUnicodeTables
operator|::
name|properties
argument_list|(
name|ucs4
argument_list|)
expr_stmt|;
name|QUnicodeTables
operator|::
name|WordBreakClass
name|tcls
init|=
operator|(
name|QUnicodeTables
operator|::
name|WordBreakClass
operator|)
name|prop
operator|->
name|wordBreakClass
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|tcls
operator|==
name|QUnicodeTables
operator|::
name|WordBreak_Extend
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|tcls
operator|==
name|cls
argument_list|)
condition|)
block|{
name|i
operator|=
name|lookahead
expr_stmt|;
name|ncls
operator|=
name|tcls
expr_stmt|;
name|action
operator|=
name|WB
operator|::
name|NoBreak
expr_stmt|;
block|}
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|ncls
operator|==
name|QUnicodeTables
operator|::
name|WordBreak_Extend
argument_list|)
condition|)
block|{
comment|// WB4: X(Extend|Format)* -> X
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|action
operator|!=
name|WB
operator|::
name|Break
argument_list|)
condition|)
continue|continue;
block|}
name|cls
operator|=
name|ncls
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|WB
operator|::
name|Break
condition|)
block|{
name|attributes
index|[
name|pos
index|]
operator|.
name|wordBreak
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|currentWordType
operator|!=
name|WordTypeNone
condition|)
name|attributes
index|[
name|pos
index|]
operator|.
name|wordEnd
operator|=
literal|true
expr_stmt|;
switch|switch
condition|(
name|cls
condition|)
block|{
case|case
name|QUnicodeTables
operator|::
name|WordBreak_Katakana
case|:
name|currentWordType
operator|=
name|WordTypeHiraganaKatakana
expr_stmt|;
name|attributes
index|[
name|pos
index|]
operator|.
name|wordStart
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|QUnicodeTables
operator|::
name|WordBreak_ALetter
case|:
case|case
name|QUnicodeTables
operator|::
name|WordBreak_Numeric
case|:
name|currentWordType
operator|=
name|WordTypeAlphaNumeric
expr_stmt|;
name|attributes
index|[
name|pos
index|]
operator|.
name|wordStart
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|currentWordType
operator|=
name|WordTypeNone
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|currentWordType
operator|!=
name|WordTypeNone
condition|)
name|attributes
index|[
name|len
index|]
operator|.
name|wordEnd
operator|=
literal|true
expr_stmt|;
name|attributes
index|[
name|len
index|]
operator|.
name|wordBreak
operator|=
literal|true
expr_stmt|;
comment|// WB2
block|}
DECL|namespace|SB
namespace|namespace
name|SB
block|{
DECL|enum|State
enum|enum
name|State
block|{
DECL|enumerator|Initial
name|Initial
block|,
DECL|enumerator|Upper
name|Upper
block|,
DECL|enumerator|UpATerm
name|UpATerm
block|,
DECL|enumerator|ATerm
name|ATerm
block|,
DECL|enumerator|ATermC
name|ATermC
block|,
DECL|enumerator|ACS
name|ACS
block|,
DECL|enumerator|STerm
name|STerm
block|,
DECL|enumerator|STermC
name|STermC
block|,
DECL|enumerator|SCS
name|SCS
block|,
DECL|enumerator|BAfterC
name|BAfterC
block|,
DECL|enumerator|BAfter
name|BAfter
block|,
DECL|enumerator|Break
name|Break
block|,
DECL|enumerator|Lookup
name|Lookup
block|}
enum|;
DECL|member|breakTable
specifier|static
specifier|const
name|uchar
name|breakTable
index|[
name|BAfter
operator|+
literal|1
index|]
index|[
name|QUnicodeTables
operator|::
name|SentenceBreak_Close
operator|+
literal|1
index|]
init|=
block|{
comment|//     Other     CR       LF      Sep     Extend     Sp      Lower   Upper    OLetter  Numeric  ATerm   SContinue STerm     Close
block|{
name|Initial
block|,
name|BAfterC
block|,
name|BAfter
block|,
name|BAfter
block|,
name|Initial
block|,
name|Initial
block|,
name|Initial
block|,
name|Upper
block|,
name|Initial
block|,
name|Initial
block|,
name|ATerm
block|,
name|Initial
block|,
name|STerm
block|,
name|Initial
block|}
block|,
comment|// Initial
block|{
name|Initial
block|,
name|BAfterC
block|,
name|BAfter
block|,
name|BAfter
block|,
name|Upper
block|,
name|Initial
block|,
name|Initial
block|,
name|Upper
block|,
name|Initial
block|,
name|Initial
block|,
name|UpATerm
block|,
name|STerm
block|,
name|STerm
block|,
name|Initial
block|}
block|,
comment|// Upper
block|{
name|Lookup
block|,
name|BAfterC
block|,
name|BAfter
block|,
name|BAfter
block|,
name|UpATerm
block|,
name|ACS
block|,
name|Initial
block|,
name|Upper
block|,
name|Break
block|,
name|Initial
block|,
name|ATerm
block|,
name|STerm
block|,
name|STerm
block|,
name|ATermC
block|}
block|,
comment|// UpATerm
block|{
name|Lookup
block|,
name|BAfterC
block|,
name|BAfter
block|,
name|BAfter
block|,
name|ATerm
block|,
name|ACS
block|,
name|Initial
block|,
name|Break
block|,
name|Break
block|,
name|Initial
block|,
name|ATerm
block|,
name|STerm
block|,
name|STerm
block|,
name|ATermC
block|}
block|,
comment|// ATerm
block|{
name|Lookup
block|,
name|BAfterC
block|,
name|BAfter
block|,
name|BAfter
block|,
name|ATermC
block|,
name|ACS
block|,
name|Initial
block|,
name|Break
block|,
name|Break
block|,
name|Lookup
block|,
name|ATerm
block|,
name|STerm
block|,
name|STerm
block|,
name|ATermC
block|}
block|,
comment|// ATermC
block|{
name|Lookup
block|,
name|BAfterC
block|,
name|BAfter
block|,
name|BAfter
block|,
name|ACS
block|,
name|ACS
block|,
name|Initial
block|,
name|Break
block|,
name|Break
block|,
name|Lookup
block|,
name|ATerm
block|,
name|STerm
block|,
name|STerm
block|,
name|Lookup
block|}
block|,
comment|// ACS
block|{
name|Break
block|,
name|BAfterC
block|,
name|BAfter
block|,
name|BAfter
block|,
name|STerm
block|,
name|SCS
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|ATerm
block|,
name|STerm
block|,
name|STerm
block|,
name|STermC
block|}
block|,
comment|// STerm,
block|{
name|Break
block|,
name|BAfterC
block|,
name|BAfter
block|,
name|BAfter
block|,
name|STermC
block|,
name|SCS
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|ATerm
block|,
name|STerm
block|,
name|STerm
block|,
name|STermC
block|}
block|,
comment|// STermC
block|{
name|Break
block|,
name|BAfterC
block|,
name|BAfter
block|,
name|BAfter
block|,
name|SCS
block|,
name|SCS
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|ATerm
block|,
name|STerm
block|,
name|STerm
block|,
name|Break
block|}
block|,
comment|// SCS
block|{
name|Break
block|,
name|Break
block|,
name|BAfter
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// BAfterC
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// BAfter
block|}
decl_stmt|;
block|}
comment|// namespace SB
DECL|function|getSentenceBreaks
specifier|static
name|void
name|getSentenceBreaks
parameter_list|(
specifier|const
name|ushort
modifier|*
name|string
parameter_list|,
name|quint32
name|len
parameter_list|,
name|QCharAttributes
modifier|*
name|attributes
parameter_list|)
block|{
name|uchar
name|state
init|=
name|SB
operator|::
name|BAfter
decl_stmt|;
comment|// to meet SB1
for|for
control|(
name|quint32
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|len
condition|;
operator|++
name|i
control|)
block|{
name|quint32
name|pos
init|=
name|i
decl_stmt|;
name|uint
name|ucs4
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|ucs4
argument_list|)
operator|&&
name|i
operator|+
literal|1
operator|!=
name|len
condition|)
block|{
name|ushort
name|low
init|=
name|string
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|ucs4
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|ucs4
argument_list|,
name|low
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|prop
init|=
name|QUnicodeTables
operator|::
name|properties
argument_list|(
name|ucs4
argument_list|)
decl_stmt|;
name|QUnicodeTables
operator|::
name|SentenceBreakClass
name|ncls
init|=
operator|(
name|QUnicodeTables
operator|::
name|SentenceBreakClass
operator|)
name|prop
operator|->
name|sentenceBreakClass
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|state
operator|<=
name|SB
operator|::
name|BAfter
argument_list|)
expr_stmt|;
name|state
operator|=
name|SB
operator|::
name|breakTable
index|[
name|state
index|]
index|[
name|ncls
index|]
expr_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|state
operator|==
name|SB
operator|::
name|Lookup
argument_list|)
condition|)
block|{
comment|// SB8
name|state
operator|=
name|SB
operator|::
name|Break
expr_stmt|;
for|for
control|(
name|quint32
name|lookahead
init|=
name|i
operator|+
literal|1
init|;
name|lookahead
operator|<
name|len
condition|;
operator|++
name|lookahead
control|)
block|{
name|ucs4
operator|=
name|string
index|[
name|lookahead
index|]
expr_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|ucs4
argument_list|)
operator|&&
name|lookahead
operator|+
literal|1
operator|!=
name|len
condition|)
block|{
name|ushort
name|low
init|=
name|string
index|[
name|lookahead
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|ucs4
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|ucs4
argument_list|,
name|low
argument_list|)
expr_stmt|;
operator|++
name|lookahead
expr_stmt|;
block|}
block|}
name|prop
operator|=
name|QUnicodeTables
operator|::
name|properties
argument_list|(
name|ucs4
argument_list|)
expr_stmt|;
name|QUnicodeTables
operator|::
name|SentenceBreakClass
name|tcls
init|=
operator|(
name|QUnicodeTables
operator|::
name|SentenceBreakClass
operator|)
name|prop
operator|->
name|sentenceBreakClass
decl_stmt|;
switch|switch
condition|(
name|tcls
condition|)
block|{
case|case
name|QUnicodeTables
operator|::
name|SentenceBreak_Other
case|:
case|case
name|QUnicodeTables
operator|::
name|SentenceBreak_Extend
case|:
case|case
name|QUnicodeTables
operator|::
name|SentenceBreak_Sp
case|:
case|case
name|QUnicodeTables
operator|::
name|SentenceBreak_Numeric
case|:
case|case
name|QUnicodeTables
operator|::
name|SentenceBreak_SContinue
case|:
case|case
name|QUnicodeTables
operator|::
name|SentenceBreak_Close
case|:
continue|continue;
case|case
name|QUnicodeTables
operator|::
name|SentenceBreak_Lower
case|:
name|i
operator|=
name|lookahead
expr_stmt|;
name|state
operator|=
name|SB
operator|::
name|Initial
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|state
operator|==
name|SB
operator|::
name|Break
argument_list|)
condition|)
block|{
name|attributes
index|[
name|pos
index|]
operator|.
name|sentenceBoundary
operator|=
literal|true
expr_stmt|;
name|state
operator|=
name|SB
operator|::
name|breakTable
index|[
name|SB
operator|::
name|Initial
index|]
index|[
name|ncls
index|]
expr_stmt|;
block|}
block|}
name|attributes
index|[
name|len
index|]
operator|.
name|sentenceBoundary
operator|=
literal|true
expr_stmt|;
comment|// SB2
block|}
comment|// -----------------------------------------------------------------------------------------------------
comment|//
comment|// The line breaking algorithm.
comment|// See http://www.unicode.org/reports/tr14/tr14-30.html
comment|//
comment|// -----------------------------------------------------------------------------------------------------
DECL|namespace|LB
namespace|namespace
name|LB
block|{
DECL|namespace|NS
namespace|namespace
name|NS
block|{
comment|// Number Sequence
comment|// LB25 recommends to not break lines inside numbers of the form
comment|// described by the following regular expression:
comment|//  (PR|PO)?(OP|HY)?NU(NU|SY|IS)*(CL|CP)?(PR|PO)?
DECL|enum|Action
enum|enum
name|Action
block|{
DECL|enumerator|None
name|None
block|,
DECL|enumerator|Start
name|Start
block|,
DECL|enumerator|Continue
name|Continue
block|,
DECL|enumerator|Break
name|Break
block|}
enum|;
DECL|enum|Class
enum|enum
name|Class
block|{
DECL|enumerator|XX
name|XX
block|,
DECL|enumerator|PRPO
name|PRPO
block|,
DECL|enumerator|OPHY
name|OPHY
block|,
DECL|enumerator|NU
name|NU
block|,
DECL|enumerator|SYIS
name|SYIS
block|,
DECL|enumerator|CLCP
name|CLCP
block|}
enum|;
DECL|member|actionTable
specifier|static
specifier|const
name|uchar
name|actionTable
index|[
name|CLCP
operator|+
literal|1
index|]
index|[
name|CLCP
operator|+
literal|1
index|]
init|=
block|{
comment|//     XX       PRPO      OPHY       NU       SYIS      CLCP
block|{
name|None
block|,
name|Start
block|,
name|Start
block|,
name|Start
block|,
name|None
block|,
name|None
block|}
block|,
comment|// XX
block|{
name|None
block|,
name|Start
block|,
name|Continue
block|,
name|Continue
block|,
name|None
block|,
name|None
block|}
block|,
comment|// PRPO
block|{
name|None
block|,
name|Start
block|,
name|Start
block|,
name|Continue
block|,
name|None
block|,
name|None
block|}
block|,
comment|// OPHY
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Continue
block|,
name|Continue
block|,
name|Continue
block|}
block|,
comment|// NU
block|{
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Continue
block|,
name|Continue
block|,
name|Continue
block|}
block|,
comment|// SYIS
block|{
name|Break
block|,
name|Continue
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|,
name|Break
block|}
block|,
comment|// CLCP
block|}
decl_stmt|;
DECL|function|toClass
specifier|inline
name|Class
name|toClass
parameter_list|(
name|QUnicodeTables
operator|::
name|LineBreakClass
name|lbc
parameter_list|,
name|QChar
operator|::
name|Category
name|category
parameter_list|)
block|{
switch|switch
condition|(
name|lbc
condition|)
block|{
case|case
name|QUnicodeTables
operator|::
name|LineBreak_AL
case|:
comment|// case QUnicodeTables::LineBreak_AI:
comment|// resolve AI math symbols in numerical context to IS
if|if
condition|(
name|category
operator|==
name|QChar
operator|::
name|Symbol_Math
condition|)
return|return
name|SYIS
return|;
break|break;
case|case
name|QUnicodeTables
operator|::
name|LineBreak_PR
case|:
case|case
name|QUnicodeTables
operator|::
name|LineBreak_PO
case|:
return|return
name|PRPO
return|;
case|case
name|QUnicodeTables
operator|::
name|LineBreak_OP
case|:
case|case
name|QUnicodeTables
operator|::
name|LineBreak_HY
case|:
return|return
name|OPHY
return|;
case|case
name|QUnicodeTables
operator|::
name|LineBreak_NU
case|:
return|return
name|NU
return|;
case|case
name|QUnicodeTables
operator|::
name|LineBreak_SY
case|:
case|case
name|QUnicodeTables
operator|::
name|LineBreak_IS
case|:
return|return
name|SYIS
return|;
case|case
name|QUnicodeTables
operator|::
name|LineBreak_CL
case|:
case|case
name|QUnicodeTables
operator|::
name|LineBreak_CP
case|:
return|return
name|CLCP
return|;
default|default:
break|break;
block|}
return|return
name|XX
return|;
block|}
block|}
comment|// namespace NS
comment|/* In order to support the tailored implementation of LB25 properly    the following changes were made in the pair table to allow breaks    where the numeric expression doesn't match the template (i.e. [^NU](IS|SY)NU):    CL->PO from IB to DB    CP->PO from IB to DB    CL->PR from IB to DB    CP->PR from IB to DB    PO->OP from IB to DB    PR->OP from IB to DB    IS->NU from IB to DB    SY->NU from IB to DB */
comment|// The following line break classes are not treated by the pair table
comment|// and must be resolved outside:
comment|//  AI, BK, CB, CJ, CR, LF, NL, SA, SG, SP, XX
DECL|enum|Action
enum|enum
name|Action
block|{
DECL|enumerator|ProhibitedBreak
DECL|enumerator|PB
name|ProhibitedBreak
block|,
name|PB
init|=
name|ProhibitedBreak
block|,
DECL|enumerator|DirectBreak
DECL|enumerator|DB
name|DirectBreak
block|,
name|DB
init|=
name|DirectBreak
block|,
DECL|enumerator|IndirectBreak
DECL|enumerator|IB
name|IndirectBreak
block|,
name|IB
init|=
name|IndirectBreak
block|,
DECL|enumerator|CombiningIndirectBreak
DECL|enumerator|CI
name|CombiningIndirectBreak
block|,
name|CI
init|=
name|CombiningIndirectBreak
block|,
DECL|enumerator|CombiningProhibitedBreak
DECL|enumerator|CP
name|CombiningProhibitedBreak
block|,
name|CP
init|=
name|CombiningProhibitedBreak
block|}
enum|;
DECL|member|breakTable
specifier|static
specifier|const
name|uchar
name|breakTable
index|[
name|QUnicodeTables
operator|::
name|LineBreak_CB
operator|+
literal|1
index|]
index|[
name|QUnicodeTables
operator|::
name|LineBreak_CB
operator|+
literal|1
index|]
init|=
block|{
comment|/*         OP  CL  CP  QU  GL  NS  EX  SY  IS  PR  PO  NU  AL  HL  ID  IN  HY  BA  BB  B2  ZW  CM  WJ  H2  H3  JL  JV  JT  RI  CB */
comment|/* OP */
block|{
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|CP
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|}
block|,
comment|/* CL */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* CP */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* QU */
block|{
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|}
block|,
comment|/* GL */
block|{
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|}
block|,
comment|/* NS */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* EX */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* SY */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* IS */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* PR */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* PO */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* NU */
block|{
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* AL */
block|{
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* HL */
block|{
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* ID */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* IN */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* HY */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|DB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* BA */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|DB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* BB */
block|{
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|}
block|,
comment|/* B2 */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* ZW */
block|{
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* CM */
block|{
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* WJ */
block|{
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|}
block|,
comment|/* H2 */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* H3 */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* JL */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* JV */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* JT */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|}
block|,
comment|/* RI */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|IB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|IB
block|,
name|DB
block|}
block|,
comment|/* CB */
block|{
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|IB
block|,
name|IB
block|,
name|DB
block|,
name|PB
block|,
name|PB
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|PB
block|,
name|CI
block|,
name|PB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|,
name|DB
block|}
block|}
decl_stmt|;
block|}
comment|// namespace LB
DECL|function|getLineBreaks
specifier|static
name|void
name|getLineBreaks
parameter_list|(
specifier|const
name|ushort
modifier|*
name|string
parameter_list|,
name|quint32
name|len
parameter_list|,
name|QCharAttributes
modifier|*
name|attributes
parameter_list|)
block|{
name|quint32
name|nestart
init|=
literal|0
decl_stmt|;
name|LB
operator|::
name|NS
operator|::
name|Class
name|nelast
init|=
name|LB
operator|::
name|NS
operator|::
name|XX
decl_stmt|;
name|QUnicodeTables
operator|::
name|LineBreakClass
name|lcls
init|=
name|QUnicodeTables
operator|::
name|LineBreak_LF
decl_stmt|;
comment|// to meet LB10
name|QUnicodeTables
operator|::
name|LineBreakClass
name|cls
init|=
name|lcls
decl_stmt|;
for|for
control|(
name|quint32
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|len
condition|;
operator|++
name|i
control|)
block|{
name|quint32
name|pos
init|=
name|i
decl_stmt|;
name|uint
name|ucs4
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|ucs4
argument_list|)
operator|&&
name|i
operator|+
literal|1
operator|!=
name|len
condition|)
block|{
name|ushort
name|low
init|=
name|string
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|ucs4
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|ucs4
argument_list|,
name|low
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|prop
init|=
name|QUnicodeTables
operator|::
name|properties
argument_list|(
name|ucs4
argument_list|)
decl_stmt|;
name|QUnicodeTables
operator|::
name|LineBreakClass
name|ncls
init|=
operator|(
name|QUnicodeTables
operator|::
name|LineBreakClass
operator|)
name|prop
operator|->
name|lineBreakClass
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|ncls
operator|==
name|QUnicodeTables
operator|::
name|LineBreak_SA
argument_list|)
condition|)
block|{
comment|// LB1: resolve SA to AL, except of those that have Category Mn or Mc be resolved to CM
specifier|static
specifier|const
name|int
name|test
init|=
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_NonSpacing
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_SpacingCombining
argument_list|)
decl_stmt|;
if|if
condition|(
name|FLAG
argument_list|(
name|prop
operator|->
name|category
argument_list|)
operator|&
name|test
condition|)
name|ncls
operator|=
name|QUnicodeTables
operator|::
name|LineBreak_CM
expr_stmt|;
block|}
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|ncls
operator|==
name|QUnicodeTables
operator|::
name|LineBreak_CM
argument_list|)
condition|)
block|{
comment|// LB10: treat CM that follows SP, BK, CR, LF, NL, or ZW as AL
if|if
condition|(
name|lcls
operator|==
name|QUnicodeTables
operator|::
name|LineBreak_ZW
operator|||
name|lcls
operator|>=
name|QUnicodeTables
operator|::
name|LineBreak_SP
condition|)
name|ncls
operator|=
name|QUnicodeTables
operator|::
name|LineBreak_AL
expr_stmt|;
block|}
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|ncls
operator|!=
name|QUnicodeTables
operator|::
name|LineBreak_CM
argument_list|)
condition|)
block|{
comment|// LB25: do not break lines inside numbers
name|LB
operator|::
name|NS
operator|::
name|Class
name|necur
init|=
name|LB
operator|::
name|NS
operator|::
name|toClass
argument_list|(
name|ncls
argument_list|,
operator|(
name|QChar
operator|::
name|Category
operator|)
name|prop
operator|->
name|category
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|LB
operator|::
name|NS
operator|::
name|actionTable
index|[
name|nelast
index|]
index|[
name|necur
index|]
condition|)
block|{
case|case
name|LB
operator|::
name|NS
operator|::
name|Break
case|:
comment|// do not change breaks before and after the expression
for|for
control|(
name|quint32
name|j
init|=
name|nestart
operator|+
literal|1
init|;
name|j
operator|<
name|pos
condition|;
operator|++
name|j
control|)
name|attributes
index|[
name|j
index|]
operator|.
name|lineBreak
operator|=
literal|false
expr_stmt|;
comment|// fall through
case|case
name|LB
operator|::
name|NS
operator|::
name|None
case|:
name|nelast
operator|=
name|LB
operator|::
name|NS
operator|::
name|XX
expr_stmt|;
comment|// reset state
break|break;
case|case
name|LB
operator|::
name|NS
operator|::
name|Start
case|:
name|nestart
operator|=
name|i
expr_stmt|;
comment|// fall through
default|default:
name|nelast
operator|=
name|necur
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|lcls
operator|>=
name|QUnicodeTables
operator|::
name|LineBreak_CR
argument_list|)
condition|)
block|{
comment|// LB4: BK!, LB5: (CRxLF|CR|LF|NL)!
if|if
condition|(
name|lcls
operator|>
name|QUnicodeTables
operator|::
name|LineBreak_CR
operator|||
name|ncls
operator|!=
name|QUnicodeTables
operator|::
name|LineBreak_LF
condition|)
name|attributes
index|[
name|pos
index|]
operator|.
name|lineBreak
operator|=
name|attributes
index|[
name|pos
index|]
operator|.
name|mandatoryBreak
operator|=
literal|true
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|ncls
operator|>=
name|QUnicodeTables
operator|::
name|LineBreak_SP
argument_list|)
condition|)
block|{
if|if
condition|(
name|ncls
operator|>
name|QUnicodeTables
operator|::
name|LineBreak_SP
condition|)
goto|goto
name|next
goto|;
comment|// LB6: x(BK|CR|LF|NL)
goto|goto
name|next_no_cls_update
goto|;
comment|// LB7: xSP
block|}
comment|// for South East Asian chars that require a complex analysis, the Unicode
comment|// standard recommends to treat them as AL. tailoring that do dictionary analysis can override
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|cls
operator|>=
name|QUnicodeTables
operator|::
name|LineBreak_SA
argument_list|)
condition|)
name|cls
operator|=
name|QUnicodeTables
operator|::
name|LineBreak_AL
expr_stmt|;
switch|switch
condition|(
name|LB
operator|::
name|breakTable
index|[
name|cls
index|]
index|[
name|ncls
operator|<
name|QUnicodeTables
operator|::
name|LineBreak_SA
condition|?
name|ncls
else|:
name|QUnicodeTables
operator|::
name|LineBreak_AL
index|]
condition|)
block|{
case|case
name|LB
operator|::
name|DirectBreak
case|:
name|attributes
index|[
name|pos
index|]
operator|.
name|lineBreak
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|LB
operator|::
name|IndirectBreak
case|:
if|if
condition|(
name|lcls
operator|==
name|QUnicodeTables
operator|::
name|LineBreak_SP
condition|)
name|attributes
index|[
name|pos
index|]
operator|.
name|lineBreak
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|LB
operator|::
name|CombiningIndirectBreak
case|:
if|if
condition|(
name|lcls
operator|!=
name|QUnicodeTables
operator|::
name|LineBreak_SP
condition|)
goto|goto
name|next_no_cls_update
goto|;
name|attributes
index|[
name|pos
index|]
operator|.
name|lineBreak
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|LB
operator|::
name|CombiningProhibitedBreak
case|:
if|if
condition|(
name|lcls
operator|!=
name|QUnicodeTables
operator|::
name|LineBreak_SP
condition|)
goto|goto
name|next_no_cls_update
goto|;
break|break;
case|case
name|LB
operator|::
name|ProhibitedBreak
case|:
comment|// nothing to do
default|default:
break|break;
block|}
name|next
label|:
name|cls
operator|=
name|ncls
expr_stmt|;
name|next_no_cls_update
label|:
name|lcls
operator|=
name|ncls
expr_stmt|;
block|}
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|LB
operator|::
name|NS
operator|::
name|actionTable
index|[
name|nelast
index|]
index|[
name|LB
operator|::
name|NS
operator|::
name|XX
index|]
operator|==
name|LB
operator|::
name|NS
operator|::
name|Break
argument_list|)
condition|)
block|{
comment|// LB25: do not break lines inside numbers
for|for
control|(
name|quint32
name|j
init|=
name|nestart
operator|+
literal|1
init|;
name|j
operator|<
name|len
condition|;
operator|++
name|j
control|)
name|attributes
index|[
name|j
index|]
operator|.
name|lineBreak
operator|=
literal|false
expr_stmt|;
block|}
name|attributes
index|[
literal|0
index|]
operator|.
name|lineBreak
operator|=
name|attributes
index|[
literal|0
index|]
operator|.
name|mandatoryBreak
operator|=
literal|false
expr_stmt|;
comment|// LB2
name|attributes
index|[
name|len
index|]
operator|.
name|lineBreak
operator|=
name|attributes
index|[
name|len
index|]
operator|.
name|mandatoryBreak
operator|=
literal|true
expr_stmt|;
comment|// LB3
block|}
DECL|function|getWhiteSpaces
specifier|static
name|void
name|getWhiteSpaces
parameter_list|(
specifier|const
name|ushort
modifier|*
name|string
parameter_list|,
name|quint32
name|len
parameter_list|,
name|QCharAttributes
modifier|*
name|attributes
parameter_list|)
block|{
for|for
control|(
name|quint32
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|len
condition|;
operator|++
name|i
control|)
block|{
name|uint
name|ucs4
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|ucs4
argument_list|)
operator|&&
name|i
operator|+
literal|1
operator|!=
name|len
condition|)
block|{
name|ushort
name|low
init|=
name|string
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|ucs4
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|ucs4
argument_list|,
name|low
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|QChar
operator|::
name|isSpace
argument_list|(
name|ucs4
argument_list|)
argument_list|)
condition|)
name|attributes
index|[
name|i
index|]
operator|.
name|whiteSpace
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|function|initCharAttributes
name|Q_CORE_EXPORT
name|void
name|initCharAttributes
parameter_list|(
specifier|const
name|ushort
modifier|*
name|string
parameter_list|,
name|int
name|length
parameter_list|,
specifier|const
name|ScriptItem
modifier|*
name|items
parameter_list|,
name|int
name|numItems
parameter_list|,
name|QCharAttributes
modifier|*
name|attributes
parameter_list|,
name|CharAttributeOptions
name|options
parameter_list|)
block|{
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|DontClearAttributes
operator|)
condition|)
operator|::
name|memset
argument_list|(
name|attributes
argument_list|,
literal|0
argument_list|,
operator|(
name|length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QCharAttributes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|GraphemeBreaks
condition|)
name|getGraphemeBreaks
argument_list|(
name|string
argument_list|,
name|length
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|WordBreaks
condition|)
name|getWordBreaks
argument_list|(
name|string
argument_list|,
name|length
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|SentenceBreaks
condition|)
name|getSentenceBreaks
argument_list|(
name|string
argument_list|,
name|length
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|LineBreaks
condition|)
name|getLineBreaks
argument_list|(
name|string
argument_list|,
name|length
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|WhiteSpaces
condition|)
name|getWhiteSpaces
argument_list|(
name|string
argument_list|,
name|length
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qt_initcharattributes_default_algorithm_only
condition|)
block|{
if|if
condition|(
operator|!
name|items
operator|||
name|numItems
operator|<=
literal|0
condition|)
return|return;
name|QVarLengthArray
argument_list|<
name|HB_ScriptItem
argument_list|,
literal|64
argument_list|>
name|scriptItems
decl_stmt|;
name|scriptItems
operator|.
name|reserve
argument_list|(
name|numItems
argument_list|)
expr_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
name|HB_Script
name|startScript
init|=
name|script_to_hbscript
argument_list|(
name|items
index|[
name|start
index|]
operator|.
name|script
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|startScript
operator|==
name|HB_Script_Inherited
argument_list|)
condition|)
name|startScript
operator|=
name|HB_Script_Common
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
operator|+
literal|1
init|;
name|i
operator|<
name|numItems
condition|;
operator|++
name|i
control|)
block|{
name|HB_Script
name|script
init|=
name|script_to_hbscript
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|script
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|script
operator|==
name|startScript
operator|||
name|script
operator|==
name|HB_Script_Inherited
argument_list|)
condition|)
continue|continue;
name|Q_ASSERT
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|position
operator|>
name|items
index|[
name|start
index|]
operator|.
name|position
argument_list|)
expr_stmt|;
name|HB_ScriptItem
name|item
decl_stmt|;
name|item
operator|.
name|pos
operator|=
name|items
index|[
name|start
index|]
operator|.
name|position
expr_stmt|;
name|item
operator|.
name|length
operator|=
name|items
index|[
name|i
index|]
operator|.
name|position
operator|-
name|items
index|[
name|start
index|]
operator|.
name|position
expr_stmt|;
name|item
operator|.
name|script
operator|=
name|startScript
expr_stmt|;
name|item
operator|.
name|bidiLevel
operator|=
literal|0
expr_stmt|;
comment|// unused
name|scriptItems
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
name|startScript
operator|=
name|script
expr_stmt|;
block|}
if|if
condition|(
name|items
index|[
name|start
index|]
operator|.
name|position
operator|+
literal|1
operator|<
name|length
condition|)
block|{
name|HB_ScriptItem
name|item
decl_stmt|;
name|item
operator|.
name|pos
operator|=
name|items
index|[
name|start
index|]
operator|.
name|position
expr_stmt|;
name|item
operator|.
name|length
operator|=
name|length
operator|-
name|items
index|[
name|start
index|]
operator|.
name|position
expr_stmt|;
name|item
operator|.
name|script
operator|=
name|startScript
expr_stmt|;
name|item
operator|.
name|bidiLevel
operator|=
literal|0
expr_stmt|;
comment|// unused
name|scriptItems
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
name|Q_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|QCharAttributes
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|HB_CharAttributes
argument_list|)
argument_list|)
expr_stmt|;
name|HB_GetTailoredCharAttributes
argument_list|(
name|string
argument_list|,
name|length
argument_list|,
name|scriptItems
operator|.
name|constData
argument_list|()
argument_list|,
name|scriptItems
operator|.
name|size
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
name|HB_CharAttributes
operator|*
argument_list|>
argument_list|(
name|attributes
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ----------------------------------------------------------------------------
comment|//
comment|// The Unicode script property. See http://www.unicode.org/reports/tr24/ (some very old version)
comment|//
comment|// ----------------------------------------------------------------------------
DECL|function|initScripts
name|Q_CORE_EXPORT
name|void
name|initScripts
parameter_list|(
specifier|const
name|ushort
modifier|*
name|string
parameter_list|,
name|int
name|length
parameter_list|,
name|uchar
modifier|*
name|scripts
parameter_list|)
block|{
name|int
name|sor
init|=
literal|0
decl_stmt|;
name|int
name|eor
init|=
operator|-
literal|1
decl_stmt|;
name|uchar
name|script
init|=
name|QChar
operator|::
name|Script_Common
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
name|eor
operator|=
name|i
expr_stmt|;
name|uint
name|ucs4
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|ucs4
argument_list|)
operator|&&
name|i
operator|+
literal|1
operator|<
name|length
condition|)
block|{
name|ushort
name|low
init|=
name|string
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|ucs4
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|ucs4
argument_list|,
name|low
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|prop
init|=
name|QUnicodeTables
operator|::
name|properties
argument_list|(
name|ucs4
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|prop
operator|->
name|script
operator|==
name|script
operator|||
name|prop
operator|->
name|script
operator|==
name|QChar
operator|::
name|Script_Inherited
argument_list|)
condition|)
continue|continue;
comment|// Never break between a combining mark (gc= Mc, Mn or Me) and its base character.
comment|// Thus, a combining mark  whatever its script property value is  should inherit
comment|// the script property value of its base character.
specifier|static
specifier|const
name|int
name|test
init|=
operator|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_NonSpacing
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_SpacingCombining
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_Enclosing
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|FLAG
argument_list|(
name|prop
operator|->
name|category
argument_list|)
operator|&
name|test
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|sor
operator|<
name|eor
condition|)
name|scripts
index|[
name|sor
operator|++
index|]
operator|=
name|script
expr_stmt|;
name|script
operator|=
name|prop
operator|->
name|script
expr_stmt|;
block|}
name|eor
operator|=
name|length
expr_stmt|;
while|while
condition|(
name|sor
operator|<
name|eor
condition|)
name|scripts
index|[
name|sor
operator|++
index|]
operator|=
name|script
expr_stmt|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace QUnicodeTools
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
