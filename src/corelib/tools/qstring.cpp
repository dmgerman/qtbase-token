begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Copyright (C) 2015 Intel Corporation ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qregexp.h"
end_include
begin_include
include|#
directive|include
file|"qregularexpression.h"
end_include
begin_include
include|#
directive|include
file|"qunicodetables_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
end_ifndef
begin_include
include|#
directive|include
file|<qtextcodec.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<private/qutfcodec_p.h>
end_include
begin_include
include|#
directive|include
file|"qsimd_p.h"
end_include
begin_include
include|#
directive|include
file|<qnumeric.h>
end_include
begin_include
include|#
directive|include
file|<qdatastream.h>
end_include
begin_include
include|#
directive|include
file|<qlist.h>
end_include
begin_include
include|#
directive|include
file|"qlocale.h"
end_include
begin_include
include|#
directive|include
file|"qlocale_p.h"
end_include
begin_include
include|#
directive|include
file|"qstringbuilder.h"
end_include
begin_include
include|#
directive|include
file|"qstringmatcher.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qtools_p.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qendian.h"
end_include
begin_include
include|#
directive|include
file|"qcollator.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_MAC
end_ifdef
begin_include
include|#
directive|include
file|<private/qcore_mac_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<private/qfunctions_p.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_include
include|#
directive|include
file|"qchar.cpp"
end_include
begin_include
include|#
directive|include
file|"qstringmatcher.cpp"
end_include
begin_include
include|#
directive|include
file|"qstringiterator_p.h"
end_include
begin_include
include|#
directive|include
file|"qstringalgorithms_p.h"
end_include
begin_include
include|#
directive|include
file|"qthreadstorage.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_include
include|#
directive|include
file|<qt_windows.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WINCE
end_ifdef
begin_include
include|#
directive|include
file|<winnls.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|truncate
end_ifdef
begin_undef
DECL|macro|truncate
undef|#
directive|undef
name|truncate
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|LLONG_MAX
end_ifndef
begin_define
DECL|macro|LLONG_MAX
define|#
directive|define
name|LLONG_MAX
value|qint64_C(9223372036854775807)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|LLONG_MIN
end_ifndef
begin_define
DECL|macro|LLONG_MIN
define|#
directive|define
name|LLONG_MIN
value|(-LLONG_MAX - qint64_C(1))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|ULLONG_MAX
end_ifndef
begin_define
DECL|macro|ULLONG_MAX
define|#
directive|define
name|ULLONG_MAX
value|quint64_C(18446744073709551615)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|IS_RAW_DATA
define|#
directive|define
name|IS_RAW_DATA
parameter_list|(
name|d
parameter_list|)
value|((d)->offset != sizeof(QStringData))
end_define
begin_expr_stmt
name|QT_BEGIN_NAMESPACE
comment|/*  * Note on the use of SIMD in qstring.cpp:  *  * Several operations with strings are improved with the use of SIMD code,  * since they are repetitive. For MIPS, we have hand-written assembly code  * outside of qstring.cpp targeting MIPS DSP and MIPS DSPr2. For ARM and for  * x86, we can only use intrinsics and therefore everything is contained in  * qstring.cpp. We need to use intrinsics only for those platforms due to the  * different compilers and toolchains used, which have different syntax for  * assembly sources.  *  * ** SSE notes: **  *  * Whenever multiple alternatives are equivalent or near so, we prefer the one  * using instructions from SSE2, since SSE2 is guaranteed to be enabled for all  * 64-bit builds and we enable it for 32-bit builds by default. Use of higher  * SSE versions should be done when there's a clear performance benefit and  * requires fallback code to SSE2, if it exists.  *  * Performance measurement in the past shows that most strings are short in  * size and, therefore, do not benefit from alignment prologues. That is,  * trying to find a 16-byte-aligned boundary to operate on is often more  * expensive than executing the unaligned operation directly. In addition, note  * that the QString private data is designed so that the data is stored on  * 16-byte boundaries if the system malloc() returns 16-byte aligned pointers  * on its own (64-bit glibc on Linux does; 32-bit glibc on Linux returns them  * 50% of the time), so skipping the alignment prologue is actually optimizing  * for the common case.  */
if|#
directive|if
name|defined
argument_list|(
name|__mips_dsp
argument_list|)
comment|// From qstring_mips_dsp_asm.S
specifier|extern
literal|"C"
name|void
name|qt_fromlatin1_mips_asm_unroll4
argument_list|(
name|ushort
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|uint
argument_list|)
expr_stmt|;
end_expr_stmt
begin_extern
extern|extern
literal|"C"
name|void
name|qt_fromlatin1_mips_asm_unroll8
parameter_list|(
name|ushort
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|uint
parameter_list|)
function_decl|;
end_extern
begin_extern
extern|extern
literal|"C"
name|void
name|qt_toLatin1_mips_dsp_asm
parameter_list|(
name|uchar
modifier|*
name|dst
parameter_list|,
specifier|const
name|ushort
modifier|*
name|src
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// internal
end_comment
begin_function_decl
name|int
name|qFindString
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
name|int
name|from
parameter_list|,
specifier|const
name|QChar
modifier|*
name|needle
parameter_list|,
name|int
name|needleLen
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|qFindStringBoyerMoore
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
name|int
name|from
parameter_list|,
specifier|const
name|QChar
modifier|*
name|needle
parameter_list|,
name|int
name|needleLen
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|int
name|qt_last_index_of
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
name|QChar
name|needle
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|int
name|qt_string_count
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
specifier|const
name|QChar
modifier|*
name|needle
parameter_list|,
name|int
name|needleLen
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|int
name|qt_string_count
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
name|QChar
name|needle
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|int
name|qt_find_latin1_string
parameter_list|(
specifier|const
name|QChar
modifier|*
name|hay
parameter_list|,
name|int
name|size
parameter_list|,
name|QLatin1String
name|needle
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|bool
name|qt_starts_with
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
specifier|const
name|QChar
modifier|*
name|needle
parameter_list|,
name|int
name|needleLen
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|bool
name|qt_starts_with
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
name|QLatin1String
name|needle
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|bool
name|qt_ends_with
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
specifier|const
name|QChar
modifier|*
name|needle
parameter_list|,
name|int
name|needleLen
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|bool
name|qt_ends_with
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
name|QLatin1String
name|needle
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_COMPILER_LAMBDA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OPTIMIZE_SIZE__
argument_list|)
end_if
begin_namespace
namespace|namespace
block|{
DECL|struct|UnrollTailLoop
template|template
parameter_list|<
name|uint
name|MaxCount
parameter_list|>
struct|struct
name|UnrollTailLoop
block|{
template|template
parameter_list|<
name|typename
name|RetType
parameter_list|,
name|typename
name|Functor1
parameter_list|,
name|typename
name|Functor2
parameter_list|>
DECL|function|exec
specifier|static
specifier|inline
name|RetType
name|exec
parameter_list|(
name|int
name|count
parameter_list|,
name|RetType
name|returnIfExited
parameter_list|,
name|Functor1
name|loopCheck
parameter_list|,
name|Functor2
name|returnIfFailed
parameter_list|,
name|int
name|i
init|=
literal|0
parameter_list|)
block|{
comment|/* equivalent to:          *   while (count--) {          *       if (loopCheck(i))          *           return returnIfFailed(i);          *   }          *   return returnIfExited;          */
if|if
condition|(
operator|!
name|count
condition|)
return|return
name|returnIfExited
return|;
name|bool
name|check
init|=
name|loopCheck
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|check
condition|)
block|{
specifier|const
name|RetType
modifier|&
name|retval
init|=
name|returnIfFailed
argument_list|(
name|i
argument_list|)
decl_stmt|;
return|return
name|retval
return|;
block|}
return|return
name|UnrollTailLoop
argument_list|<
name|MaxCount
operator|-
literal|1
argument_list|>
operator|::
name|exec
argument_list|(
name|count
operator|-
literal|1
argument_list|,
name|returnIfExited
argument_list|,
name|loopCheck
argument_list|,
name|returnIfFailed
argument_list|,
name|i
operator|+
literal|1
argument_list|)
return|;
block|}
template|template
parameter_list|<
name|typename
name|Functor
parameter_list|>
DECL|function|exec
specifier|static
specifier|inline
name|void
name|exec
parameter_list|(
name|int
name|count
parameter_list|,
name|Functor
name|code
parameter_list|)
block|{
comment|/* equivalent to:          *   for (int i = 0; i< count; ++i)          *       code(i);          */
name|exec
argument_list|(
name|count
argument_list|,
literal|0
argument_list|,
capture|[
modifier|=
capture|]
parameter_list|(
name|int
name|i
parameter_list|)
lambda|->
name|bool
block|{
name|code
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
argument_list|,
capture|[]
parameter_list|(
name|int
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
argument_list|)
expr_stmt|;
block|}
block|}
struct|;
template|template
parameter_list|<>
template|template
parameter_list|<
name|typename
name|RetType
parameter_list|,
name|typename
name|Functor1
parameter_list|,
name|typename
name|Functor2
parameter_list|>
DECL|function|exec
specifier|inline
name|RetType
name|UnrollTailLoop
argument_list|<
literal|0
argument_list|>
operator|::
name|exec
parameter_list|(
name|int
parameter_list|,
name|RetType
name|returnIfExited
parameter_list|,
name|Functor1
parameter_list|,
name|Functor2
parameter_list|,
name|int
parameter_list|)
block|{
return|return
name|returnIfExited
return|;
block|}
block|}
end_namespace
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// conversion between Latin 1 and UTF-16
end_comment
begin_function
DECL|function|qt_from_latin1
name|void
name|qt_from_latin1
parameter_list|(
name|ushort
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
comment|/* SIMD:      * Unpacking with SSE has been shown to improve performance on recent CPUs      * The same method gives no improvement with NEON.      */
if|#
directive|if
name|defined
argument_list|(
name|__SSE2__
argument_list|)
specifier|const
name|char
modifier|*
name|e
init|=
name|str
operator|+
name|size
decl_stmt|;
name|qptrdiff
name|offset
init|=
literal|0
decl_stmt|;
comment|// we're going to read str[offset..offset+15] (16 bytes)
for|for
control|(
init|;
name|str
operator|+
name|offset
operator|+
literal|15
operator|<
name|e
condition|;
name|offset
operator|+=
literal|16
control|)
block|{
specifier|const
name|__m128i
name|chunk
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|str
operator|+
name|offset
operator|)
argument_list|)
decl_stmt|;
comment|// load
ifdef|#
directive|ifdef
name|__AVX2__
comment|// zero extend to an YMM register
specifier|const
name|__m256i
name|extended
init|=
name|_mm256_cvtepu8_epi16
argument_list|(
name|chunk
argument_list|)
decl_stmt|;
comment|// store
name|_mm256_storeu_si256
argument_list|(
operator|(
name|__m256i
operator|*
operator|)
operator|(
name|dst
operator|+
name|offset
operator|)
argument_list|,
name|extended
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|const
name|__m128i
name|nullMask
init|=
name|_mm_set1_epi32
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// unpack the first 8 bytes, padding with zeros
specifier|const
name|__m128i
name|firstHalf
init|=
name|_mm_unpacklo_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|offset
operator|)
argument_list|,
name|firstHalf
argument_list|)
expr_stmt|;
comment|// store
comment|// unpack the last 8 bytes, padding with zeros
specifier|const
name|__m128i
name|secondHalf
init|=
name|_mm_unpackhi_epi8
argument_list|(
name|chunk
argument_list|,
name|nullMask
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|offset
operator|+
literal|8
operator|)
argument_list|,
name|secondHalf
argument_list|)
expr_stmt|;
comment|// store
endif|#
directive|endif
block|}
name|size
operator|=
name|size
operator|%
literal|16
expr_stmt|;
name|dst
operator|+=
name|offset
expr_stmt|;
name|str
operator|+=
name|offset
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_COMPILER_LAMBDA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OPTIMIZE_SIZE__
argument_list|)
return|return
name|UnrollTailLoop
argument_list|<
literal|15
argument_list|>
operator|::
name|exec
argument_list|(
name|int
argument_list|(
name|size
argument_list|)
argument_list|,
capture|[
modifier|=
capture|]
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|dst
index|[
name|i
index|]
operator|=
operator|(
name|uchar
operator|)
name|str
index|[
name|i
index|]
expr_stmt|;
block|}
argument_list|)
return|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__mips_dsp
argument_list|)
if|if
condition|(
name|size
operator|>
literal|20
condition|)
name|qt_fromlatin1_mips_asm_unroll8
argument_list|(
name|dst
argument_list|,
name|str
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|qt_fromlatin1_mips_asm_unroll4
argument_list|(
name|dst
argument_list|,
name|str
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|size
operator|--
condition|)
operator|*
name|dst
operator|++
operator|=
operator|(
name|uchar
operator|)
operator|*
name|str
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SSE2__
argument_list|)
end_if
begin_function
DECL|function|mergeQuestionMarks
specifier|static
specifier|inline
name|__m128i
name|mergeQuestionMarks
parameter_list|(
name|__m128i
name|chunk
parameter_list|)
block|{
specifier|const
name|__m128i
name|questionMark
init|=
name|_mm_set1_epi16
argument_list|(
literal|'?'
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|__SSE4_2__
comment|// compare the unsigned shorts for the range 0x0100-0xFFFF
comment|// note on the use of _mm_cmpestrm:
comment|//  The MSDN documentation online (http://technet.microsoft.com/en-us/library/bb514080.aspx)
comment|//  says for range search the following:
comment|//    For each character c in a, determine whether b0<= c<= b1 or b2<= c<= b3
comment|//
comment|//  However, all examples on the Internet, including from Intel
comment|//  (see http://software.intel.com/en-us/articles/xml-parsing-accelerator-with-intel-streaming-simd-extensions-4-intel-sse4/)
comment|//  put the range to be searched first
comment|//
comment|//  Disassembly and instruction-level debugging with GCC and ICC show
comment|//  that they are doing the right thing. Inverting the arguments in the
comment|//  instruction does cause a bunch of test failures.
specifier|const
name|__m128i
name|rangeMatch
init|=
name|_mm_cvtsi32_si128
argument_list|(
literal|0xffff0100
argument_list|)
decl_stmt|;
specifier|const
name|__m128i
name|offLimitMask
init|=
name|_mm_cmpestrm
argument_list|(
name|rangeMatch
argument_list|,
literal|2
argument_list|,
name|chunk
argument_list|,
literal|8
argument_list|,
name|_SIDD_UWORD_OPS
operator||
name|_SIDD_CMP_RANGES
operator||
name|_SIDD_UNIT_MASK
argument_list|)
decl_stmt|;
comment|// replace the non-Latin 1 characters in the chunk with question marks
name|chunk
operator|=
name|_mm_blendv_epi8
argument_list|(
name|chunk
argument_list|,
name|questionMark
argument_list|,
name|offLimitMask
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// SSE has no compare instruction for unsigned comparison.
comment|// The variables must be shiffted + 0x8000 to be compared
specifier|const
name|__m128i
name|signedBitOffset
init|=
name|_mm_set1_epi16
argument_list|(
name|short
argument_list|(
literal|0x8000
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|__m128i
name|thresholdMask
init|=
name|_mm_set1_epi16
argument_list|(
name|short
argument_list|(
literal|0xff
operator|+
literal|0x8000
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|__m128i
name|signedChunk
init|=
name|_mm_add_epi16
argument_list|(
name|chunk
argument_list|,
name|signedBitOffset
argument_list|)
decl_stmt|;
specifier|const
name|__m128i
name|offLimitMask
init|=
name|_mm_cmpgt_epi16
argument_list|(
name|signedChunk
argument_list|,
name|thresholdMask
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|__SSE4_1__
comment|// replace the non-Latin 1 characters in the chunk with question marks
name|chunk
operator|=
name|_mm_blendv_epi8
argument_list|(
name|chunk
argument_list|,
name|questionMark
argument_list|,
name|offLimitMask
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// offLimitQuestionMark contains '?' for each 16 bits that was off-limit
comment|// the 16 bits that were correct contains zeros
specifier|const
name|__m128i
name|offLimitQuestionMark
init|=
name|_mm_and_si128
argument_list|(
name|offLimitMask
argument_list|,
name|questionMark
argument_list|)
decl_stmt|;
comment|// correctBytes contains the bytes that were in limit
comment|// the 16 bits that were off limits contains zeros
specifier|const
name|__m128i
name|correctBytes
init|=
name|_mm_andnot_si128
argument_list|(
name|offLimitMask
argument_list|,
name|chunk
argument_list|)
decl_stmt|;
comment|// merge offLimitQuestionMark and correctBytes to have the result
name|chunk
operator|=
name|_mm_or_si128
argument_list|(
name|correctBytes
argument_list|,
name|offLimitQuestionMark
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|chunk
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qt_to_latin1
specifier|static
name|void
name|qt_to_latin1
parameter_list|(
name|uchar
modifier|*
name|dst
parameter_list|,
specifier|const
name|ushort
modifier|*
name|src
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__SSE2__
argument_list|)
name|uchar
modifier|*
name|e
init|=
name|dst
operator|+
name|length
decl_stmt|;
name|qptrdiff
name|offset
init|=
literal|0
decl_stmt|;
comment|// we're going to write to dst[offset..offset+15] (16 bytes)
for|for
control|(
init|;
name|dst
operator|+
name|offset
operator|+
literal|15
operator|<
name|e
condition|;
name|offset
operator|+=
literal|16
control|)
block|{
name|__m128i
name|chunk1
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|src
operator|+
name|offset
operator|)
argument_list|)
decl_stmt|;
comment|// load
name|chunk1
operator|=
name|mergeQuestionMarks
argument_list|(
name|chunk1
argument_list|)
expr_stmt|;
name|__m128i
name|chunk2
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|src
operator|+
name|offset
operator|+
literal|8
operator|)
argument_list|)
decl_stmt|;
comment|// load
name|chunk2
operator|=
name|mergeQuestionMarks
argument_list|(
name|chunk2
argument_list|)
expr_stmt|;
comment|// pack the two vector to 16 x 8bits elements
specifier|const
name|__m128i
name|result
init|=
name|_mm_packus_epi16
argument_list|(
name|chunk1
argument_list|,
name|chunk2
argument_list|)
decl_stmt|;
name|_mm_storeu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|dst
operator|+
name|offset
operator|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|// store
block|}
name|length
operator|=
name|length
operator|%
literal|16
expr_stmt|;
name|dst
operator|+=
name|offset
expr_stmt|;
name|src
operator|+=
name|offset
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_COMPILER_LAMBDA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OPTIMIZE_SIZE__
argument_list|)
return|return
name|UnrollTailLoop
argument_list|<
literal|15
argument_list|>
operator|::
name|exec
argument_list|(
name|length
argument_list|,
capture|[
modifier|=
capture|]
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|dst
index|[
name|i
index|]
operator|=
operator|(
name|src
index|[
name|i
index|]
operator|>
literal|0xff
operator|)
condition|?
literal|'?'
else|:
operator|(
name|uchar
operator|)
name|src
index|[
name|i
index|]
expr_stmt|;
block|}
argument_list|)
return|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|__ARM_NEON__
argument_list|)
comment|// Refer to the documentation of the SSE2 implementation
comment|// this use eactly the same method as for SSE except:
comment|// 1) neon has unsigned comparison
comment|// 2) packing is done to 64 bits (8 x 8bits component).
if|if
condition|(
name|length
operator|>=
literal|16
condition|)
block|{
specifier|const
name|int
name|chunkCount
init|=
name|length
operator|>>
literal|3
decl_stmt|;
comment|// divided by 8
specifier|const
name|uint16x8_t
name|questionMark
init|=
name|vdupq_n_u16
argument_list|(
literal|'?'
argument_list|)
decl_stmt|;
comment|// set
specifier|const
name|uint16x8_t
name|thresholdMask
init|=
name|vdupq_n_u16
argument_list|(
literal|0xff
argument_list|)
decl_stmt|;
comment|// set
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|chunkCount
condition|;
operator|++
name|i
control|)
block|{
name|uint16x8_t
name|chunk
init|=
name|vld1q_u16
argument_list|(
operator|(
name|uint16_t
operator|*
operator|)
name|src
argument_list|)
decl_stmt|;
comment|// load
name|src
operator|+=
literal|8
expr_stmt|;
specifier|const
name|uint16x8_t
name|offLimitMask
init|=
name|vcgtq_u16
argument_list|(
name|chunk
argument_list|,
name|thresholdMask
argument_list|)
decl_stmt|;
comment|// chunk> thresholdMask
specifier|const
name|uint16x8_t
name|offLimitQuestionMark
init|=
name|vandq_u16
argument_list|(
name|offLimitMask
argument_list|,
name|questionMark
argument_list|)
decl_stmt|;
comment|// offLimitMask& questionMark
specifier|const
name|uint16x8_t
name|correctBytes
init|=
name|vbicq_u16
argument_list|(
name|chunk
argument_list|,
name|offLimitMask
argument_list|)
decl_stmt|;
comment|// !offLimitMask& chunk
name|chunk
operator|=
name|vorrq_u16
argument_list|(
name|correctBytes
argument_list|,
name|offLimitQuestionMark
argument_list|)
expr_stmt|;
comment|// correctBytes | offLimitQuestionMark
specifier|const
name|uint8x8_t
name|result
init|=
name|vmovn_u16
argument_list|(
name|chunk
argument_list|)
decl_stmt|;
comment|// narrowing move->packing
name|vst1_u8
argument_list|(
name|dst
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|// store
name|dst
operator|+=
literal|8
expr_stmt|;
block|}
name|length
operator|=
name|length
operator|%
literal|8
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__mips_dsp
argument_list|)
name|qt_toLatin1_mips_dsp_asm
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|length
operator|--
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src
operator|>
literal|0xff
operator|)
condition|?
literal|'?'
else|:
operator|(
name|uchar
operator|)
operator|*
name|src
expr_stmt|;
operator|++
name|src
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|// Unicode case-insensitive comparison
end_comment
begin_function
DECL|function|ucstricmp
specifier|static
name|int
name|ucstricmp
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|ae
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
specifier|const
name|ushort
modifier|*
name|be
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
name|b
condition|)
return|return
operator|(
name|ae
operator|-
name|be
operator|)
return|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
specifier|const
name|ushort
modifier|*
name|e
init|=
name|ae
decl_stmt|;
if|if
condition|(
name|be
operator|-
name|b
operator|<
name|ae
operator|-
name|a
condition|)
name|e
operator|=
name|a
operator|+
operator|(
name|be
operator|-
name|b
operator|)
expr_stmt|;
name|uint
name|alast
init|=
literal|0
decl_stmt|;
name|uint
name|blast
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|a
operator|<
name|e
condition|)
block|{
comment|//         qDebug()<< hex<< alast<< blast;
comment|//         qDebug()<< hex<< "*a="<< *a<< "alast="<< alast<< "folded="<< foldCase (*a, alast);
comment|//         qDebug()<< hex<< "*b="<< *b<< "blast="<< blast<< "folded="<< foldCase (*b, blast);
name|int
name|diff
init|=
name|foldCase
argument_list|(
operator|*
name|a
argument_list|,
name|alast
argument_list|)
operator|-
name|foldCase
argument_list|(
operator|*
name|b
argument_list|,
name|blast
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|diff
operator|)
condition|)
return|return
name|diff
return|;
operator|++
name|a
expr_stmt|;
operator|++
name|b
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|==
name|ae
condition|)
block|{
if|if
condition|(
name|b
operator|==
name|be
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|// Case-insensitive comparison between a Unicode string and a QLatin1String
end_comment
begin_function
DECL|function|ucstricmp
specifier|static
name|int
name|ucstricmp
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|ae
parameter_list|,
specifier|const
name|uchar
modifier|*
name|b
parameter_list|,
specifier|const
name|uchar
modifier|*
name|be
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
specifier|const
name|ushort
modifier|*
name|e
init|=
name|ae
decl_stmt|;
if|if
condition|(
name|be
operator|-
name|b
operator|<
name|ae
operator|-
name|a
condition|)
name|e
operator|=
name|a
operator|+
operator|(
name|be
operator|-
name|b
operator|)
expr_stmt|;
while|while
condition|(
name|a
operator|<
name|e
condition|)
block|{
name|int
name|diff
init|=
name|foldCase
argument_list|(
operator|*
name|a
argument_list|)
operator|-
name|foldCase
argument_list|(
operator|*
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|diff
operator|)
condition|)
return|return
name|diff
return|;
operator|++
name|a
expr_stmt|;
operator|++
name|b
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|==
name|ae
condition|)
block|{
if|if
condition|(
name|b
operator|==
name|be
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__mips_dsp
argument_list|)
end_if
begin_comment
comment|// From qstring_mips_dsp_asm.S
end_comment
begin_extern
extern|extern
literal|"C"
name|int
name|qt_ucstrncmp_mips_dsp_asm
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
name|unsigned
name|len
parameter_list|)
function_decl|;
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Unicode case-sensitive compare two same-sized strings
end_comment
begin_function
DECL|function|ucstrncmp
specifier|static
name|int
name|ucstrncmp
parameter_list|(
specifier|const
name|QChar
modifier|*
name|a
parameter_list|,
specifier|const
name|QChar
modifier|*
name|b
parameter_list|,
name|int
name|l
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__mips_dsp
argument_list|)
if|if
condition|(
name|l
operator|>=
literal|8
condition|)
block|{
return|return
name|qt_ucstrncmp_mips_dsp_asm
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|a
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|b
argument_list|)
argument_list|,
name|l
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|// __mips_dsp
ifdef|#
directive|ifdef
name|__SSE2__
specifier|const
name|char
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|qptrdiff
name|distance
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|b
argument_list|)
operator|-
name|ptr
decl_stmt|;
name|a
operator|+=
name|l
operator|&
operator|~
literal|7
expr_stmt|;
name|b
operator|+=
name|l
operator|&
operator|~
literal|7
expr_stmt|;
name|l
operator|&=
literal|7
expr_stmt|;
comment|// we're going to read ptr[0..15] (16 bytes)
for|for
control|(
init|;
name|ptr
operator|+
literal|15
operator|<
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|a
argument_list|)
condition|;
name|ptr
operator|+=
literal|16
control|)
block|{
name|__m128i
name|a_data
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|ptr
argument_list|)
decl_stmt|;
name|__m128i
name|b_data
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|ptr
operator|+
name|distance
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|result
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|a_data
argument_list|,
name|b_data
argument_list|)
decl_stmt|;
name|uint
name|mask
init|=
name|~
name|_mm_movemask_epi8
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|ushort
argument_list|(
name|mask
argument_list|)
condition|)
block|{
comment|// found a different byte
name|uint
name|idx
init|=
name|uint
argument_list|(
name|_bit_scan_forward
argument_list|(
name|mask
argument_list|)
argument_list|)
decl_stmt|;
return|return
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|ptr
operator|+
name|idx
argument_list|)
operator|->
name|unicode
argument_list|()
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|ptr
operator|+
name|distance
operator|+
name|idx
argument_list|)
operator|->
name|unicode
argument_list|()
return|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_COMPILER_LAMBDA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OPTIMIZE_SIZE__
argument_list|)
specifier|const
specifier|auto
modifier|&
name|lambda
init|=
capture|[
modifier|=
capture|]
parameter_list|(
name|int
name|i
parameter_list|)
lambda|->
name|int
block|{
return|return
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|ptr
argument_list|)
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|ptr
operator|+
name|distance
argument_list|)
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
return|;
block|}
decl_stmt|;
return|return
name|UnrollTailLoop
argument_list|<
literal|7
argument_list|>
operator|::
name|exec
argument_list|(
name|l
argument_list|,
literal|0
argument_list|,
name|lambda
argument_list|,
name|lambda
argument_list|)
return|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|l
condition|)
return|return
literal|0
return|;
union|union
block|{
specifier|const
name|QChar
modifier|*
name|w
decl_stmt|;
specifier|const
name|quint32
modifier|*
name|d
decl_stmt|;
name|quintptr
name|value
decl_stmt|;
block|}
name|sa
union|,
name|sb
union|;
name|sa
operator|.
name|w
operator|=
name|a
expr_stmt|;
name|sb
operator|.
name|w
operator|=
name|b
expr_stmt|;
comment|// check alignment
if|if
condition|(
operator|(
name|sa
operator|.
name|value
operator|&
literal|2
operator|)
operator|==
operator|(
name|sb
operator|.
name|value
operator|&
literal|2
operator|)
condition|)
block|{
comment|// both addresses have the same alignment
if|if
condition|(
name|sa
operator|.
name|value
operator|&
literal|2
condition|)
block|{
comment|// both addresses are not aligned to 4-bytes boundaries
comment|// compare the first character
if|if
condition|(
operator|*
name|sa
operator|.
name|w
operator|!=
operator|*
name|sb
operator|.
name|w
condition|)
return|return
name|sa
operator|.
name|w
operator|->
name|unicode
argument_list|()
operator|-
name|sb
operator|.
name|w
operator|->
name|unicode
argument_list|()
return|;
operator|--
name|l
expr_stmt|;
operator|++
name|sa
operator|.
name|w
expr_stmt|;
operator|++
name|sb
operator|.
name|w
expr_stmt|;
comment|// now both addresses are 4-bytes aligned
block|}
comment|// both addresses are 4-bytes aligned
comment|// do a fast 32-bit comparison
specifier|const
name|quint32
modifier|*
name|e
init|=
name|sa
operator|.
name|d
operator|+
operator|(
name|l
operator|>>
literal|1
operator|)
decl_stmt|;
for|for
control|(
init|;
name|sa
operator|.
name|d
operator|!=
name|e
condition|;
operator|++
name|sa
operator|.
name|d
operator|,
operator|++
name|sb
operator|.
name|d
control|)
block|{
if|if
condition|(
operator|*
name|sa
operator|.
name|d
operator|!=
operator|*
name|sb
operator|.
name|d
condition|)
block|{
if|if
condition|(
operator|*
name|sa
operator|.
name|w
operator|!=
operator|*
name|sb
operator|.
name|w
condition|)
return|return
name|sa
operator|.
name|w
operator|->
name|unicode
argument_list|()
operator|-
name|sb
operator|.
name|w
operator|->
name|unicode
argument_list|()
return|;
return|return
name|sa
operator|.
name|w
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
operator|-
name|sb
operator|.
name|w
index|[
literal|1
index|]
operator|.
name|unicode
argument_list|()
return|;
block|}
block|}
comment|// do we have a tail?
return|return
operator|(
name|l
operator|&
literal|1
operator|)
condition|?
name|sa
operator|.
name|w
operator|->
name|unicode
argument_list|()
operator|-
name|sb
operator|.
name|w
operator|->
name|unicode
argument_list|()
else|:
literal|0
return|;
block|}
else|else
block|{
comment|// one of the addresses isn't 4-byte aligned but the other is
specifier|const
name|QChar
modifier|*
name|e
init|=
name|sa
operator|.
name|w
operator|+
name|l
decl_stmt|;
for|for
control|(
init|;
name|sa
operator|.
name|w
operator|!=
name|e
condition|;
operator|++
name|sa
operator|.
name|w
operator|,
operator|++
name|sb
operator|.
name|w
control|)
block|{
if|if
condition|(
operator|*
name|sa
operator|.
name|w
operator|!=
operator|*
name|sb
operator|.
name|w
condition|)
return|return
name|sa
operator|.
name|w
operator|->
name|unicode
argument_list|()
operator|-
name|sb
operator|.
name|w
operator|->
name|unicode
argument_list|()
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|ucstrncmp
specifier|static
name|int
name|ucstrncmp
parameter_list|(
specifier|const
name|QChar
modifier|*
name|a
parameter_list|,
specifier|const
name|uchar
modifier|*
name|c
parameter_list|,
name|int
name|l
parameter_list|)
block|{
specifier|const
name|ushort
modifier|*
name|uc
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|a
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|e
init|=
name|uc
operator|+
name|l
decl_stmt|;
ifdef|#
directive|ifdef
name|__SSE2__
name|__m128i
name|nullmask
init|=
name|_mm_setzero_si128
argument_list|()
decl_stmt|;
name|qptrdiff
name|offset
init|=
literal|0
decl_stmt|;
comment|// we're going to read uc[offset..offset+15] (32 bytes)
comment|// and c[offset..offset+15] (16 bytes)
for|for
control|(
init|;
name|uc
operator|+
name|offset
operator|+
literal|15
operator|<
name|e
condition|;
name|offset
operator|+=
literal|16
control|)
block|{
comment|// similar to fromLatin1_helper:
comment|// load 16 bytes of Latin 1 data
name|__m128i
name|chunk
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|c
operator|+
name|offset
operator|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|__AVX2__
comment|// expand Latin 1 data via zero extension
name|__m256i
name|ldata
init|=
name|_mm256_cvtepu8_epi16
argument_list|(
name|chunk
argument_list|)
decl_stmt|;
comment|// load UTF-16 data and compare
name|__m256i
name|ucdata
init|=
name|_mm256_loadu_si256
argument_list|(
operator|(
name|__m256i
operator|*
operator|)
operator|(
name|uc
operator|+
name|offset
operator|)
argument_list|)
decl_stmt|;
name|__m256i
name|result
init|=
name|_mm256_cmpeq_epi16
argument_list|(
name|ldata
argument_list|,
name|ucdata
argument_list|)
decl_stmt|;
name|uint
name|mask
init|=
name|~
name|_mm256_movemask_epi8
argument_list|(
name|result
argument_list|)
decl_stmt|;
else|#
directive|else
comment|// expand via unpacking
name|__m128i
name|firstHalf
init|=
name|_mm_unpacklo_epi8
argument_list|(
name|chunk
argument_list|,
name|nullmask
argument_list|)
decl_stmt|;
name|__m128i
name|secondHalf
init|=
name|_mm_unpackhi_epi8
argument_list|(
name|chunk
argument_list|,
name|nullmask
argument_list|)
decl_stmt|;
comment|// load UTF-16 data and compare
name|__m128i
name|ucdata1
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|uc
operator|+
name|offset
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|ucdata2
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|uc
operator|+
name|offset
operator|+
literal|8
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|result1
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|firstHalf
argument_list|,
name|ucdata1
argument_list|)
decl_stmt|;
name|__m128i
name|result2
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|secondHalf
argument_list|,
name|ucdata2
argument_list|)
decl_stmt|;
name|uint
name|mask
init|=
operator|~
operator|(
name|_mm_movemask_epi8
argument_list|(
name|result1
argument_list|)
operator||
name|_mm_movemask_epi8
argument_list|(
name|result2
argument_list|)
operator|<<
literal|16
operator|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mask
condition|)
block|{
comment|// found a different character
name|uint
name|idx
init|=
name|uint
argument_list|(
name|_bit_scan_forward
argument_list|(
name|mask
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|uc
index|[
name|offset
operator|+
name|idx
operator|/
literal|2
index|]
operator|-
name|c
index|[
name|offset
operator|+
name|idx
operator|/
literal|2
index|]
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|Q_PROCESSOR_X86_64
enum|enum
block|{
name|MaxTailLength
init|=
literal|7
block|}
enum|;
comment|// we'll read uc[offset..offset+7] (16 bytes) and c[offset..offset+7] (8 bytes)
if|if
condition|(
name|uc
operator|+
name|offset
operator|+
literal|7
operator|<
name|e
condition|)
block|{
comment|// same, but we're using an 8-byte load
name|__m128i
name|chunk
init|=
name|_mm_cvtsi64_si128
argument_list|(
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|(
name|c
operator|+
name|offset
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|secondHalf
init|=
name|_mm_unpacklo_epi8
argument_list|(
name|chunk
argument_list|,
name|nullmask
argument_list|)
decl_stmt|;
name|__m128i
name|ucdata
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
operator|(
name|uc
operator|+
name|offset
operator|)
argument_list|)
decl_stmt|;
name|__m128i
name|result
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|secondHalf
argument_list|,
name|ucdata
argument_list|)
decl_stmt|;
name|uint
name|mask
init|=
name|~
name|_mm_movemask_epi8
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|ushort
argument_list|(
name|mask
argument_list|)
condition|)
block|{
comment|// found a different character
name|uint
name|idx
init|=
name|uint
argument_list|(
name|_bit_scan_forward
argument_list|(
name|mask
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|uc
index|[
name|offset
operator|+
name|idx
operator|/
literal|2
index|]
operator|-
name|c
index|[
name|offset
operator|+
name|idx
operator|/
literal|2
index|]
return|;
block|}
comment|// still matched
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
else|#
directive|else
comment|// 32-bit, we can't do MOVQ to load 8 bytes
enum|enum
block|{
name|MaxTailLength
init|=
literal|15
block|}
enum|;
endif|#
directive|endif
comment|// reset uc and c
name|uc
operator|+=
name|offset
expr_stmt|;
name|c
operator|+=
name|offset
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_COMPILER_LAMBDA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OPTIMIZE_SIZE__
argument_list|)
specifier|const
specifier|auto
modifier|&
name|lambda
init|=
capture|[
modifier|=
capture|]
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|uc
index|[
name|i
index|]
operator|-
name|ushort
argument_list|(
name|c
index|[
name|i
index|]
argument_list|)
return|;
block|}
decl_stmt|;
return|return
name|UnrollTailLoop
argument_list|<
name|MaxTailLength
argument_list|>
operator|::
name|exec
argument_list|(
name|e
operator|-
name|uc
argument_list|,
literal|0
argument_list|,
name|lambda
argument_list|,
name|lambda
argument_list|)
return|;
endif|#
directive|endif
endif|#
directive|endif
while|while
condition|(
name|uc
operator|<
name|e
condition|)
block|{
name|int
name|diff
init|=
operator|*
name|uc
operator|-
operator|*
name|c
decl_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|diff
return|;
name|uc
operator|++
operator|,
name|c
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|// Unicode case-sensitive comparison
end_comment
begin_function
DECL|function|ucstrcmp
specifier|static
name|int
name|ucstrcmp
parameter_list|(
specifier|const
name|QChar
modifier|*
name|a
parameter_list|,
name|int
name|alen
parameter_list|,
specifier|const
name|QChar
modifier|*
name|b
parameter_list|,
name|int
name|blen
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
name|b
operator|&&
name|alen
operator|==
name|blen
condition|)
return|return
literal|0
return|;
name|int
name|l
init|=
name|qMin
argument_list|(
name|alen
argument_list|,
name|blen
argument_list|)
decl_stmt|;
name|int
name|cmp
init|=
name|ucstrncmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|l
argument_list|)
decl_stmt|;
return|return
name|cmp
condition|?
name|cmp
else|:
operator|(
name|alen
operator|-
name|blen
operator|)
return|;
block|}
end_function
begin_comment
comment|// Unicode case-insensitive compare two same-sized strings
end_comment
begin_function
DECL|function|ucstrnicmp
specifier|static
name|int
name|ucstrnicmp
parameter_list|(
specifier|const
name|ushort
modifier|*
name|a
parameter_list|,
specifier|const
name|ushort
modifier|*
name|b
parameter_list|,
name|int
name|l
parameter_list|)
block|{
return|return
name|ucstricmp
argument_list|(
name|a
argument_list|,
name|a
operator|+
name|l
argument_list|,
name|b
argument_list|,
name|b
operator|+
name|l
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qMemEquals
specifier|static
name|bool
name|qMemEquals
parameter_list|(
specifier|const
name|quint16
modifier|*
name|a
parameter_list|,
specifier|const
name|quint16
modifier|*
name|b
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
name|b
operator|||
operator|!
name|length
condition|)
return|return
literal|true
return|;
return|return
name|ucstrncmp
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|a
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|b
argument_list|)
argument_list|,
name|length
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|ucstrcmp
specifier|static
name|int
name|ucstrcmp
parameter_list|(
specifier|const
name|QChar
modifier|*
name|a
parameter_list|,
name|int
name|alen
parameter_list|,
specifier|const
name|uchar
modifier|*
name|b
parameter_list|,
name|int
name|blen
parameter_list|)
block|{
name|int
name|l
init|=
name|qMin
argument_list|(
name|alen
argument_list|,
name|blen
argument_list|)
decl_stmt|;
name|int
name|cmp
init|=
name|ucstrncmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|l
argument_list|)
decl_stmt|;
return|return
name|cmp
condition|?
name|cmp
else|:
operator|(
name|alen
operator|-
name|blen
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the index position of the first occurrence of the     character \a ch in the string given by \a str and \a len,     searching forward from index     position \a from. Returns -1 if \a ch could not be found. */
end_comment
begin_function
DECL|function|findChar
specifier|static
name|int
name|findChar
parameter_list|(
specifier|const
name|QChar
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
name|QChar
name|ch
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
specifier|const
name|ushort
modifier|*
name|s
init|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|str
decl_stmt|;
name|ushort
name|c
init|=
name|ch
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|=
name|qMax
argument_list|(
name|from
operator|+
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|<
name|len
condition|)
block|{
specifier|const
name|ushort
modifier|*
name|n
init|=
name|s
operator|+
name|from
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|e
init|=
name|s
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
ifdef|#
directive|ifdef
name|__SSE2__
name|__m128i
name|mch
init|=
name|_mm_set1_epi32
argument_list|(
name|c
operator||
operator|(
name|c
operator|<<
literal|16
operator|)
argument_list|)
decl_stmt|;
comment|// we're going to read n[0..7] (16 bytes)
for|for
control|(
specifier|const
name|ushort
modifier|*
name|next
init|=
name|n
operator|+
literal|8
init|;
name|next
operator|<=
name|e
condition|;
name|n
operator|=
name|next
operator|,
name|next
operator|+=
literal|8
control|)
block|{
name|__m128i
name|data
init|=
name|_mm_loadu_si128
argument_list|(
operator|(
name|__m128i
operator|*
operator|)
name|n
argument_list|)
decl_stmt|;
name|__m128i
name|result
init|=
name|_mm_cmpeq_epi16
argument_list|(
name|data
argument_list|,
name|mch
argument_list|)
decl_stmt|;
name|uint
name|mask
init|=
name|_mm_movemask_epi8
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|ushort
argument_list|(
name|mask
argument_list|)
condition|)
block|{
comment|// found a match
comment|// same as: return n - s + _bit_scan_forward(mask) / 2
return|return
operator|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|n
argument_list|)
operator|-
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
operator|+
name|_bit_scan_forward
argument_list|(
name|mask
argument_list|)
operator|)
operator|>>
literal|1
return|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_COMPILER_LAMBDA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OPTIMIZE_SIZE__
argument_list|)
return|return
name|UnrollTailLoop
argument_list|<
literal|7
argument_list|>
operator|::
name|exec
argument_list|(
name|e
operator|-
name|n
argument_list|,
operator|-
literal|1
argument_list|,
capture|[
modifier|=
capture|]
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|n
index|[
name|i
index|]
operator|==
name|c
return|;
block|}
argument_list|,
capture|[
modifier|=
capture|]
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|n
operator|-
name|s
operator|+
name|i
return|;
block|}
argument_list|)
return|;
endif|#
directive|endif
endif|#
directive|endif
operator|--
name|n
expr_stmt|;
while|while
condition|(
operator|++
name|n
operator|!=
name|e
condition|)
if|if
condition|(
operator|*
name|n
operator|==
name|c
condition|)
return|return
name|n
operator|-
name|s
return|;
block|}
else|else
block|{
name|c
operator|=
name|foldCase
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|--
name|n
expr_stmt|;
while|while
condition|(
operator|++
name|n
operator|!=
name|e
condition|)
if|if
condition|(
name|foldCase
argument_list|(
operator|*
name|n
argument_list|)
operator|==
name|c
condition|)
return|return
name|n
operator|-
name|s
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_define
DECL|macro|REHASH
define|#
directive|define
name|REHASH
parameter_list|(
name|a
parameter_list|)
define|\
value|if (sl_minus_1< (int)sizeof(int) * CHAR_BIT)       \         hashHaystack -= (a)<< sl_minus_1; \     hashHaystack<<= 1
end_define
begin_function
DECL|function|qIsUpper
specifier|inline
name|bool
name|qIsUpper
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
return|;
block|}
end_function
begin_function
DECL|function|qIsDigit
specifier|inline
name|bool
name|qIsDigit
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
return|;
block|}
end_function
begin_function
DECL|function|qToLower
specifier|inline
name|char
name|qToLower
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|'a'
return|;
else|else
return|return
name|ch
return|;
block|}
end_function
begin_decl_stmt
DECL|member|null
specifier|const
name|QString
operator|::
name|Null
name|QString
operator|::
name|null
init|=
block|{ }
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!   \macro QT_RESTRICTED_CAST_FROM_ASCII   \relates QString    Defining this macro disables most automatic conversions from source   literals and 8-bit data to unicode QStrings, but allows the use of   the \c{QChar(char)} and \c{QString(const char (&ch)[N]} constructors,   and the \c{QString::operator=(const char (&ch)[N])} assignment operator   giving most of the type-safety benefits of QT_NO_CAST_FROM_ASCII   but does not require user code to wrap character and string literals   with QLatin1Char, QLatin1String or similar.    Using this macro together with source strings outside the 7-bit range,   non-literals, or literals with embedded NUL characters is undefined.    \sa QT_NO_CAST_FROM_ASCII, QT_NO_CAST_TO_ASCII */
end_comment
begin_comment
comment|/*!   \macro QT_NO_CAST_FROM_ASCII   \relates QString    Disables automatic conversions from 8-bit strings (char *) to unicode QStrings    \sa QT_NO_CAST_TO_ASCII, QT_RESTRICTED_CAST_FROM_ASCII, QT_NO_CAST_FROM_BYTEARRAY */
end_comment
begin_comment
comment|/*!   \macro QT_NO_CAST_TO_ASCII   \relates QString    disables automatic conversion from QString to 8-bit strings (char *)    \sa QT_NO_CAST_FROM_ASCII, QT_RESTRICTED_CAST_FROM_ASCII, QT_NO_CAST_FROM_BYTEARRAY */
end_comment
begin_comment
comment|/*!   \macro QT_ASCII_CAST_WARNINGS   \internal   \relates QString    This macro can be defined to force a warning whenever a function is   called that automatically converts between unicode and 8-bit encodings.    Note: This only works for compilers that support warnings for   deprecated API.    \sa QT_NO_CAST_TO_ASCII, QT_NO_CAST_FROM_ASCII, QT_RESTRICTED_CAST_FROM_ASCII */
end_comment
begin_comment
comment|/*!     \class QCharRef     \inmodule QtCore     \reentrant     \brief The QCharRef class is a helper class for QString.      \internal      \ingroup string-processing      When you get an object of type QCharRef, if you can assign to it,     the assignment will apply to the character in the string from     which you got the reference. That is its whole purpose in life.     The QCharRef becomes invalid once modifications are made to the     string: if you want to keep the character, copy it into a QChar.      Most of the QChar member functions also exist in QCharRef.     However, they are not explicitly documented here.      \sa QString::operator[](), QString::at(), QChar */
end_comment
begin_comment
comment|/*!     \class QString     \inmodule QtCore     \reentrant      \brief The QString class provides a Unicode character string.      \ingroup tools     \ingroup shared     \ingroup string-processing      QString stores a string of 16-bit \l{QChar}s, where each QChar     corresponds one Unicode 4.0 character. (Unicode characters     with code values above 65535 are stored using surrogate pairs,     i.e., two consecutive \l{QChar}s.)      \l{Unicode} is an international standard that supports most of the     writing systems in use today. It is a superset of US-ASCII (ANSI     X3.4-1986) and Latin-1 (ISO 8859-1), and all the US-ASCII/Latin-1     characters are available at the same code positions.      Behind the scenes, QString uses \l{implicit sharing}     (copy-on-write) to reduce memory usage and to avoid the needless     copying of data. This also helps reduce the inherent overhead of     storing 16-bit characters instead of 8-bit characters.      In addition to QString, Qt also provides the QByteArray class to     store raw bytes and traditional 8-bit '\\0'-terminated strings.     For most purposes, QString is the class you want to use. It is     used throughout the Qt API, and the Unicode support ensures that     your applications will be easy to translate if you want to expand     your application's market at some point. The two main cases where     QByteArray is appropriate are when you need to store raw binary     data, and when memory conservation is critical (like in embedded     systems).      \tableofcontents      \section1 Initializing a String      One way to initialize a QString is simply to pass a \c{const char     *} to its constructor. For example, the following code creates a     QString of size 5 containing the data "Hello":      \snippet qstring/main.cpp 0      QString converts the \c{const char *} data into Unicode using the     fromUtf8() function.      In all of the QString functions that take \c{const char *}     parameters, the \c{const char *} is interpreted as a classic     C-style '\\0'-terminated string encoded in UTF-8. It is legal for     the \c{const char *} parameter to be 0.      You can also provide string data as an array of \l{QChar}s:      \snippet qstring/main.cpp 1      QString makes a deep copy of the QChar data, so you can modify it     later without experiencing side effects. (If for performance     reasons you don't want to take a deep copy of the character data,     use QString::fromRawData() instead.)      Another approach is to set the size of the string using resize()     and to initialize the data character per character. QString uses     0-based indexes, just like C++ arrays. To access the character at     a particular index position, you can use \l operator[](). On     non-const strings, \l operator[]() returns a reference to a     character that can be used on the left side of an assignment. For     example:      \snippet qstring/main.cpp 2      For read-only access, an alternative syntax is to use the at()     function:      \snippet qstring/main.cpp 3      The at() function can be faster than \l operator[](), because it     never causes a \l{deep copy} to occur. Alternatively, use the     left(), right(), or mid() functions to extract several characters     at a time.      A QString can embed '\\0' characters (QChar::Null). The size()     function always returns the size of the whole string, including     embedded '\\0' characters.      After a call to the resize() function, newly allocated characters     have undefined values. To set all the characters in the string to     a particular value, use the fill() function.      QString provides dozens of overloads designed to simplify string     usage. For example, if you want to compare a QString with a string     literal, you can write code like this and it will work as expected:      \snippet qstring/main.cpp 4      You can also pass string literals to functions that take QStrings     as arguments, invoking the QString(const char *)     constructor. Similarly, you can pass a QString to a function that     takes a \c{const char *} argument using the \l qPrintable() macro     which returns the given QString as a \c{const char *}. This is     equivalent to calling<QString>.toLocal8Bit().constData().      \section1 Manipulating String Data      QString provides the following basic functions for modifying the     character data: append(), prepend(), insert(), replace(), and     remove(). For example:      \snippet qstring/main.cpp 5      If you are building a QString gradually and know in advance     approximately how many characters the QString will contain, you     can call reserve(), asking QString to preallocate a certain amount     of memory. You can also call capacity() to find out how much     memory QString actually allocated.      The replace() and remove() functions' first two arguments are the     position from which to start erasing and the number of characters     that should be erased.  If you want to replace all occurrences of     a particular substring with another, use one of the two-parameter     replace() overloads.      A frequent requirement is to remove whitespace characters from a     string ('\\n', '\\t', ' ', etc.). If you want to remove whitespace     from both ends of a QString, use the trimmed() function. If you     want to remove whitespace from both ends and replace multiple     consecutive whitespaces with a single space character within the     string, use simplified().      If you want to find all occurrences of a particular character or     substring in a QString, use the indexOf() or lastIndexOf()     functions. The former searches forward starting from a given index     position, the latter searches backward. Both return the index     position of the character or substring if they find it; otherwise,     they return -1.  For example, here's a typical loop that finds all     occurrences of a particular substring:      \snippet qstring/main.cpp 6      QString provides many functions for converting numbers into     strings and strings into numbers. See the arg() functions, the     setNum() functions, the number() static functions, and the     toInt(), toDouble(), and similar functions.      To get an upper- or lowercase version of a string use toUpper() or     toLower().      Lists of strings are handled by the QStringList class. You can     split a string into a list of strings using the split() function,     and join a list of strings into a single string with an optional     separator using QStringList::join(). You can obtain a list of     strings from a string list that contain a particular substring or     that match a particular QRegExp using the QStringList::filter()     function.      \section1 Querying String Data      If you want to see if a QString starts or ends with a particular     substring use startsWith() or endsWith(). If you simply want to     check whether a QString contains a particular character or     substring, use the contains() function. If you want to find out     how many times a particular character or substring occurs in the     string, use count().      QStrings can be compared using overloaded operators such as \l     operator<(), \l operator<=(), \l operator==(), \l operator>=(),     and so on.  Note that the comparison is based exclusively on the     numeric Unicode values of the characters. It is very fast, but is     not what a human would expect; the QString::localeAwareCompare()     function is a better choice for sorting user-interface strings.      To obtain a pointer to the actual character data, call data() or     constData(). These functions return a pointer to the beginning of     the QChar data. The pointer is guaranteed to remain valid until a     non-const function is called on the QString.      \section1 Converting Between 8-Bit Strings and Unicode Strings      QString provides the following three functions that return a     \c{const char *} version of the string as QByteArray: toUtf8(),     toLatin1(), and toLocal8Bit().      \list     \li toLatin1() returns a Latin-1 (ISO 8859-1) encoded 8-bit string.     \li toUtf8() returns a UTF-8 encoded 8-bit string. UTF-8 is a        superset of US-ASCII (ANSI X3.4-1986) that supports the entire        Unicode character set through multibyte sequences.     \li toLocal8Bit() returns an 8-bit string using the system's local        encoding.     \endlist      To convert from one of these encodings, QString provides     fromLatin1(), fromUtf8(), and fromLocal8Bit(). Other     encodings are supported through the QTextCodec class.      As mentioned above, QString provides a lot of functions and     operators that make it easy to interoperate with \c{const char *}     strings. But this functionality is a double-edged sword: It makes     QString more convenient to use if all strings are US-ASCII or     Latin-1, but there is always the risk that an implicit conversion     from or to \c{const char *} is done using the wrong 8-bit     encoding. To minimize these risks, you can turn off these implicit     conversions by defining the following two preprocessor symbols:      \list     \li \c QT_NO_CAST_FROM_ASCII disables automatic conversions from        C string literals and pointers to Unicode.     \li \c QT_RESTRICTED_CAST_FROM_ASCII allows automatic conversions        from C characters and character arrays, but disables automatic        conversions from character pointers to Unicode.     \li \c QT_NO_CAST_TO_ASCII disables automatic conversion from QString        to C strings.     \endlist      One way to define these preprocessor symbols globally for your     application is to add the following entry to your \l {Creating Project Files}{qmake project file}:      \snippet code/src_corelib_tools_qstring.cpp 0      You then need to explicitly call fromUtf8(), fromLatin1(),     or fromLocal8Bit() to construct a QString from an     8-bit string, or use the lightweight QLatin1String class, for     example:      \snippet code/src_corelib_tools_qstring.cpp 1      Similarly, you must call toLatin1(), toUtf8(), or     toLocal8Bit() explicitly to convert the QString to an 8-bit     string.  (Other encodings are supported through the QTextCodec     class.)      \table 100 %     \header     \li Note for C Programmers      \row     \li     Due to C++'s type system and the fact that QString is     \l{implicitly shared}, QStrings may be treated like \c{int}s or     other basic types. For example:      \snippet qstring/main.cpp 7      The \c result variable, is a normal variable allocated on the     stack. When \c return is called, and because we're returning by     value, the copy constructor is called and a copy of the string is     returned. No actual copying takes place thanks to the implicit     sharing.      \endtable      \section1 Distinction Between Null and Empty Strings      For historical reasons, QString distinguishes between a null     string and an empty string. A \e null string is a string that is     initialized using QString's default constructor or by passing     (const char *)0 to the constructor. An \e empty string is any     string with size 0. A null string is always empty, but an empty     string isn't necessarily null:      \snippet qstring/main.cpp 8      All functions except isNull() treat null strings the same as empty     strings. For example, toUtf8().constData() returns a pointer to a     '\\0' character for a null string (\e not a null pointer), and     QString() compares equal to QString(""). We recommend that you     always use the isEmpty() function and avoid isNull().      \section1 Argument Formats      In member functions where an argument \e format can be specified     (e.g., arg(), number()), the argument \e format can be one of the     following:      \table     \header \li Format \li Meaning     \row \li \c e \li format as [-]9.9e[+|-]999     \row \li \c E \li format as [-]9.9E[+|-]999     \row \li \c f \li format as [-]9.9     \row \li \c g \li use \c e or \c f format, whichever is the most concise     \row \li \c G \li use \c E or \c f format, whichever is the most concise     \endtable      A \e precision is also specified with the argument \e format. For     the 'e', 'E', and 'f' formats, the \e precision represents the     number of digits \e after the decimal point. For the 'g' and 'G'     formats, the \e precision represents the maximum number of     significant digits (trailing zeroes are omitted).      \section1 More Efficient String Construction      Many strings are known at compile time. But the trivial     constructor QString("Hello"), will copy the contents of the string,     treating the contents as Latin-1. To avoid this one can use the     QStringLiteral macro to directly create the required data at compile     time. Constructing a QString out of the literal does then not cause     any overhead at runtime.      A slightly less efficient way is to use QLatin1String. This class wraps     a C string literal, precalculates it length at compile time and can     then be used for faster comparison with QStrings and conversion to     QStrings than a regular C string literal.      Using the QString \c{'+'} operator, it is easy to construct a     complex string from multiple substrings. You will often write code     like this:      \snippet qstring/stringbuilder.cpp 0      There is nothing wrong with either of these string constructions,     but there are a few hidden inefficiencies. Beginning with Qt 4.6,     you can eliminate them.      First, multiple uses of the \c{'+'} operator usually means     multiple memory allocations. When concatenating \e{n} substrings,     where \e{n> 2}, there can be as many as \e{n - 1} calls to the     memory allocator.      In 4.6, an internal template class \c{QStringBuilder} has been     added along with a few helper functions. This class is marked     internal and does not appear in the documentation, because you     aren't meant to instantiate it in your code. Its use will be     automatic, as described below. The class is found in     \c {src/corelib/tools/qstringbuilder.cpp} if you want to have a     look at it.      \c{QStringBuilder} uses expression templates and reimplements the     \c{'%'} operator so that when you use \c{'%'} for string     concatenation instead of \c{'+'}, multiple substring     concatenations will be postponed until the final result is about     to be assigned to a QString. At this point, the amount of memory     required for the final result is known. The memory allocator is     then called \e{once} to get the required space, and the substrings     are copied into it one by one.      Additional efficiency is gained by inlining and reduced reference     counting (the QString created from a \c{QStringBuilder} typically     has a ref count of 1, whereas QString::append() needs an extra     test).      There are three ways you can access this improved method of string     construction. The straightforward way is to include     \c{QStringBuilder} wherever you want to use it, and use the     \c{'%'} operator instead of \c{'+'} when concatenating strings:      \snippet qstring/stringbuilder.cpp 5      A more global approach which is the most convenient but     not entirely source compatible, is to this define in your     .pro file:      \snippet qstring/stringbuilder.cpp 3      and the \c{'+'} will automatically be performed as the     \c{QStringBuilder} \c{'%'} everywhere.      \sa fromRawData(), QChar, QLatin1String, QByteArray, QStringRef */
end_comment
begin_comment
comment|/*!     \enum QString::SplitBehavior      This enum specifies how the split() function should behave with     respect to empty strings.      \value KeepEmptyParts  If a field is empty, keep it in the result.     \value SkipEmptyParts  If a field is empty, don't include it in the result.      \sa split() */
end_comment
begin_comment
comment|/*! \typedef QString::ConstIterator      Qt-style synonym for QString::const_iterator. */
end_comment
begin_comment
comment|/*! \typedef QString::Iterator      Qt-style synonym for QString::iterator. */
end_comment
begin_comment
comment|/*! \typedef QString::const_iterator      This typedef provides an STL-style const iterator for QString.      \sa QString::iterator */
end_comment
begin_comment
comment|/*! \typedef QString::iterator      The QString::iterator typedef provides an STL-style non-const     iterator for QString.      \sa QString::const_iterator */
end_comment
begin_comment
comment|/*! \typedef QString::const_reverse_iterator     \since 5.6      This typedef provides an STL-style const reverse iterator for QString.      \sa QString::reverse_iterator, QString::const_iterator */
end_comment
begin_comment
comment|/*! \typedef QString::reverse_iterator     \since 5.6      This typedef provides an STL-style non-const reverse iterator for QString.      \sa QString::const_reverse_iterator, QString::iterator */
end_comment
begin_comment
comment|/*!     \typedef QString::size_type      The QString::size_type typedef provides an STL-style type for sizes (int). */
end_comment
begin_comment
comment|/*!     \typedef QString::difference_type      The QString::size_type typedef provides an STL-style type for difference between pointers. */
end_comment
begin_comment
comment|/*!     \typedef QString::const_reference      This typedef provides an STL-style const reference for a QString element (QChar). */
end_comment
begin_comment
comment|/*!     \typedef QString::reference      This typedef provides an STL-style     reference for a QString element (QChar). */
end_comment
begin_comment
comment|/*!     \typedef QString::const_pointer      The QString::const_pointer typedef provides an STL-style     const pointer to a QString element (QChar). */
end_comment
begin_comment
comment|/*!     \typedef QString::pointer      The QString::const_pointer typedef provides an STL-style     pointer to a QString element (QChar). */
end_comment
begin_comment
comment|/*!     \typedef QString::value_type      This typedef provides an STL-style value type for QString. */
end_comment
begin_comment
comment|/*! \fn QString::iterator QString::begin()      Returns an \l{STL-style iterators}{STL-style iterator} pointing to the first character in     the string.      \sa constBegin(), end() */
end_comment
begin_comment
comment|/*! \fn QString::const_iterator QString::begin() const      \overload begin() */
end_comment
begin_comment
comment|/*! \fn QString::const_iterator QString::cbegin() const     \since 5.0      Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first character     in the string.      \sa begin(), cend() */
end_comment
begin_comment
comment|/*! \fn QString::const_iterator QString::constBegin() const      Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first character     in the string.      \sa begin(), constEnd() */
end_comment
begin_comment
comment|/*! \fn QString::iterator QString::end()      Returns an \l{STL-style iterators}{STL-style iterator} pointing to the imaginary character     after the last character in the string.      \sa begin(), constEnd() */
end_comment
begin_comment
comment|/*! \fn QString::const_iterator QString::end() const      \overload end() */
end_comment
begin_comment
comment|/*! \fn QString::const_iterator QString::cend() const     \since 5.0      Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary     character after the last character in the list.      \sa cbegin(), end() */
end_comment
begin_comment
comment|/*! \fn QString::const_iterator QString::constEnd() const      Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary     character after the last character in the list.      \sa constBegin(), end() */
end_comment
begin_comment
comment|/*! \fn QString::reverse_iterator QString::rbegin()     \since 5.6      Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing to the first     character in the string, in reverse order.      \sa begin(), crbegin(), rend() */
end_comment
begin_comment
comment|/*! \fn QString::const_reverse_iterator QString::rbegin() const     \since 5.6     \overload */
end_comment
begin_comment
comment|/*! \fn QString::const_reverse_iterator QString::crbegin() const     \since 5.6      Returns a const \l{STL-style iterators}{STL-style} reverse iterator pointing to the first     character in the string, in reverse order.      \sa begin(), rbegin(), rend() */
end_comment
begin_comment
comment|/*! \fn QString::reverse_iterator QString::rend()     \since 5.6      Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing to one past     the last character in the string, in reverse order.      \sa end(), crend(), rbegin() */
end_comment
begin_comment
comment|/*! \fn QString::const_reverse_iterator QString::rend() const     \since 5.6     \overload */
end_comment
begin_comment
comment|/*! \fn QString::const_reverse_iterator QString::crend() const     \since 5.6      Returns a const \l{STL-style iterators}{STL-style} reverse iterator pointing to one     past the last character in the string, in reverse order.      \sa end(), rend(), rbegin() */
end_comment
begin_comment
comment|/*!     \fn QString::QString()      Constructs a null string. Null strings are also empty.      \sa isEmpty() */
end_comment
begin_comment
comment|/*!     \fn QString::QString(QString&&other)      Move-constructs a QString instance, making it point at the same     object that \a other was pointing to.      \since 5.2 */
end_comment
begin_comment
comment|/*! \fn QString::QString(const char *str)      Constructs a string initialized with the 8-bit string \a str. The     given const char pointer is converted to Unicode using the     fromUtf8() function.      You can disable this constructor by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example.      \note Defining QT_RESTRICTED_CAST_FROM_ASCII also disables     this constructor, but enables a \c{QString(const char (&ch)[N])}     constructor instead. Using non-literal input, or input with     embedded NUL characters, or non-7-bit characters is undefined     in this case.      \sa fromLatin1(), fromLocal8Bit(), fromUtf8() */
end_comment
begin_comment
comment|/*! \fn QString QString::fromStdString(const std::string&str)      Returns a copy of the \a str string. The given string is converted     to Unicode using the fromUtf8() function.      \sa fromLatin1(), fromLocal8Bit(), fromUtf8(), QByteArray::fromStdString() */
end_comment
begin_comment
comment|/*! \fn QString QString::fromStdWString(const std::wstring&str)      Returns a copy of the \a str string. The given string is assumed     to be encoded in utf16 if the size of wchar_t is 2 bytes (e.g. on     windows) and ucs4 if the size of wchar_t is 4 bytes (most Unix     systems).      \sa fromUtf16(), fromLatin1(), fromLocal8Bit(), fromUtf8(), fromUcs4(), fromStdU16String(), fromStdU32String() */
end_comment
begin_comment
comment|/*! \fn QString QString::fromWCharArray(const wchar_t *string, int size)     \since 4.2      Returns a copy of the \a string, where the encoding of \a string depends on     the size of wchar. If wchar is 4 bytes, the \a string is interpreted as UCS-4,     if wchar is 2 bytes it is interpreted as UTF-16.      If \a size is -1 (default), the \a string has to be 0 terminated.      \sa fromUtf16(), fromLatin1(), fromLocal8Bit(), fromUtf8(), fromUcs4(), fromStdWString() */
end_comment
begin_comment
comment|/*! \fn std::wstring QString::toStdWString() const      Returns a std::wstring object with the data contained in this     QString. The std::wstring is encoded in utf16 on platforms where     wchar_t is 2 bytes wide (e.g. windows) and in ucs4 on platforms     where wchar_t is 4 bytes wide (most Unix systems).      This method is mostly useful to pass a QString to a function     that accepts a std::wstring object.      \sa utf16(), toLatin1(), toUtf8(), toLocal8Bit(), toStdU16String(), toStdU32String() */
end_comment
begin_function
DECL|function|toUcs4_helper
name|int
name|QString
operator|::
name|toUcs4_helper
parameter_list|(
specifier|const
name|ushort
modifier|*
name|uc
parameter_list|,
name|int
name|length
parameter_list|,
name|uint
modifier|*
name|out
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|QStringIterator
name|i
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|uc
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|uc
operator|+
name|length
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
name|out
index|[
name|count
operator|++
index|]
operator|=
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
name|count
return|;
block|}
end_function
begin_comment
comment|/*! \fn int QString::toWCharArray(wchar_t *array) const   \since 4.2    Fills the \a array with the data contained in this QString object.   The array is encoded in UTF-16 on platforms where   wchar_t is 2 bytes wide (e.g. windows) and in UCS-4 on platforms   where wchar_t is 4 bytes wide (most Unix systems).    \a array has to be allocated by the caller and contain enough space to   hold the complete string (allocating the array with the same length as the   string is always sufficient).    This function returns the actual length of the string in \a array.    \note This function does not append a null character to the array.    \sa utf16(), toUcs4(), toLatin1(), toUtf8(), toLocal8Bit(), toStdWString() */
end_comment
begin_comment
comment|/*! \fn QString::QString(const QString&other)      Constructs a copy of \a other.      This operation takes \l{constant time}, because QString is     \l{implicitly shared}. This makes returning a QString from a     function very fast. If a shared instance is modified, it will be     copied (copy-on-write), and that takes \l{linear time}.      \sa operator=() */
end_comment
begin_comment
comment|/*!     Constructs a string initialized with the first \a size characters     of the QChar array \a unicode.      If \a unicode is 0, a null string is constructed.      If \a size is negative, \a unicode is assumed to point to a nul-terminated     array and its length is determined dynamically. The terminating     nul-character is not considered part of the string.      QString makes a deep copy of the string data. The unicode data is copied as     is and the Byte Order Mark is preserved if present.      \sa fromRawData() */
end_comment
begin_constructor
DECL|function|QString
name|QString
operator|::
name|QString
parameter_list|(
specifier|const
name|QChar
modifier|*
name|unicode
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
operator|!
name|unicode
condition|)
block|{
name|d
operator|=
name|Data
operator|::
name|sharedNull
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|unicode
index|[
name|size
index|]
operator|!=
literal|0
condition|)
operator|++
name|size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|d
operator|=
name|Data
operator|::
name|allocate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|Data
operator|::
name|allocate
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|unicode
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
end_constructor
begin_comment
comment|/*!     Constructs a string of the given \a size with every character set     to \a ch.      \sa fill() */
end_comment
begin_constructor
DECL|function|QString
name|QString
operator|::
name|QString
parameter_list|(
name|int
name|size
parameter_list|,
name|QChar
name|ch
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
name|d
operator|=
name|Data
operator|::
name|allocate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|Data
operator|::
name|allocate
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ushort
modifier|*
name|i
init|=
name|d
operator|->
name|data
argument_list|()
operator|+
name|size
decl_stmt|;
name|ushort
modifier|*
name|b
init|=
name|d
operator|->
name|data
argument_list|()
decl_stmt|;
specifier|const
name|ushort
name|value
init|=
name|ch
operator|.
name|unicode
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|b
condition|)
operator|*
operator|--
name|i
operator|=
name|value
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*! \fn QString::QString(int size, Qt::Initialization)   \internal    Constructs a string of the given \a size without initializing the   characters. This is only used in \c QStringBuilder::toString(). */
end_comment
begin_constructor
DECL|function|QString
name|QString
operator|::
name|QString
parameter_list|(
name|int
name|size
parameter_list|,
name|Qt
operator|::
name|Initialization
parameter_list|)
block|{
name|d
operator|=
name|Data
operator|::
name|allocate
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \fn QString::QString(QLatin1String str)      Constructs a copy of the Latin-1 string \a str.      \sa fromLatin1() */
end_comment
begin_comment
comment|/*!     Constructs a string of size 1 containing the character \a ch. */
end_comment
begin_constructor
DECL|function|QString
name|QString
operator|::
name|QString
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
name|d
operator|=
name|Data
operator|::
name|allocate
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
literal|0
index|]
operator|=
name|ch
operator|.
name|unicode
argument_list|()
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \fn QString::QString(const QByteArray&ba)      Constructs a string initialized with the byte array \a ba. The     given byte array is converted to Unicode using fromUtf8(). Stops     copying at the first 0 character, otherwise copies the entire byte     array.      You can disable this constructor by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example.      \sa fromLatin1(), fromLocal8Bit(), fromUtf8() */
end_comment
begin_comment
comment|/*! \fn QString::QString(const Null&)     \internal */
end_comment
begin_comment
comment|/*! \fn QString::QString(QStringDataPtr)     \internal */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator=(const Null&)     \internal */
end_comment
begin_comment
comment|/*!   \fn QString::~QString()      Destroys the string. */
end_comment
begin_comment
comment|/*! \fn void QString::swap(QString&other)     \since 4.8      Swaps string \a other with this string. This operation is very fast and     never fails. */
end_comment
begin_comment
comment|/*! \fn void QString::detach()      \internal */
end_comment
begin_comment
comment|/*! \fn bool QString::isDetached() const      \internal */
end_comment
begin_comment
comment|/*! \fn bool QString::isSharedWith(const QString&other) const      \internal */
end_comment
begin_comment
comment|/*!     Sets the size of the string to \a size characters.      If \a size is greater than the current size, the string is     extended to make it \a size characters long with the extra     characters added to the end. The new characters are uninitialized.      If \a size is less than the current size, characters are removed     from the end.      Example:      \snippet qstring/main.cpp 45      If you want to append a certain number of identical characters to     the string, use \l operator+=() as follows rather than resize():      \snippet qstring/main.cpp 46      If you want to expand the string so that it reaches a certain     width and fill the new positions with a particular character, use     the leftJustified() function:      If \a size is negative, it is equivalent to passing zero.      \snippet qstring/main.cpp 47      \sa truncate(), reserve() */
end_comment
begin_function
DECL|function|resize
name|void
name|QString
operator|::
name|resize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_RAW_DATA
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|&&
name|size
operator|<
name|d
operator|->
name|size
condition|)
block|{
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|==
literal|0
operator|&&
operator|!
name|d
operator|->
name|capacityReserved
condition|)
block|{
name|Data
modifier|*
name|x
init|=
name|Data
operator|::
name|allocate
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|Data
operator|::
name|deallocate
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|uint
argument_list|(
name|size
argument_list|)
operator|+
literal|1u
operator|>
name|d
operator|->
name|alloc
operator|||
operator|(
operator|!
name|d
operator|->
name|capacityReserved
operator|&&
name|size
operator|<
name|d
operator|->
name|size
operator|&&
name|uint
argument_list|(
name|size
argument_list|)
operator|+
literal|1u
operator|<
name|uint
argument_list|(
name|d
operator|->
name|alloc
operator|>>
literal|1
argument_list|)
operator|)
condition|)
name|reallocData
argument_list|(
name|uint
argument_list|(
name|size
argument_list|)
operator|+
literal|1u
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|alloc
condition|)
block|{
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*! \fn int QString::capacity() const      Returns the maximum number of characters that can be stored in     the string without forcing a reallocation.      The sole purpose of this function is to provide a means of fine     tuning QString's memory usage. In general, you will rarely ever     need to call this function. If you want to know how many     characters are in the string, call size().      \sa reserve(), squeeze() */
end_comment
begin_comment
comment|/*!     \fn void QString::reserve(int size)      Attempts to allocate memory for at least \a size characters. If     you know in advance how large the string will be, you can call     this function, and if you resize the string often you are likely     to get better performance. If \a size is an underestimate, the     worst that will happen is that the QString will be a bit slower.      The sole purpose of this function is to provide a means of fine     tuning QString's memory usage. In general, you will rarely ever     need to call this function. If you want to change the size of the     string, call resize().      This function is useful for code that needs to build up a long     string and wants to avoid repeated reallocation. In this example,     we want to add to the string until some condition is \c true, and     we're fairly sure that size is large enough to make a call to     reserve() worthwhile:      \snippet qstring/main.cpp 44      \sa squeeze(), capacity() */
end_comment
begin_comment
comment|/*!     \fn void QString::squeeze()      Releases any memory not required to store the character data.      The sole purpose of this function is to provide a means of fine     tuning QString's memory usage. In general, you will rarely ever     need to call this function.      \sa reserve(), capacity() */
end_comment
begin_function
DECL|function|reallocData
name|void
name|QString
operator|::
name|reallocData
parameter_list|(
name|uint
name|alloc
parameter_list|,
name|bool
name|grow
parameter_list|)
block|{
if|if
condition|(
name|grow
condition|)
block|{
if|if
condition|(
name|alloc
operator|>
operator|(
name|uint
argument_list|(
name|MaxAllocSize
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|Data
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
condition|)
name|qBadAlloc
argument_list|()
expr_stmt|;
name|alloc
operator|=
name|qAllocMore
argument_list|(
name|alloc
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Data
argument_list|)
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|IS_RAW_DATA
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|Data
operator|::
name|AllocationOptions
name|allocOptions
argument_list|(
name|d
operator|->
name|capacityReserved
condition|?
name|Data
operator|::
name|CapacityReserved
else|:
literal|0
argument_list|)
decl_stmt|;
name|Data
modifier|*
name|x
init|=
name|Data
operator|::
name|allocate
argument_list|(
name|alloc
argument_list|,
name|allocOptions
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|->
name|size
operator|=
name|qMin
argument_list|(
name|int
argument_list|(
name|alloc
argument_list|)
operator|-
literal|1
argument_list|,
name|d
operator|->
name|size
argument_list|)
expr_stmt|;
operator|::
name|memcpy
argument_list|(
name|x
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|x
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|data
argument_list|()
index|[
name|x
operator|->
name|size
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|Data
operator|::
name|deallocate
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
name|Data
modifier|*
name|p
init|=
cast|static_cast
argument_list|<
name|Data
operator|*
argument_list|>
argument_list|(
operator|::
name|realloc
argument_list|(
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|Data
argument_list|)
operator|+
name|alloc
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|d
operator|=
name|p
expr_stmt|;
name|d
operator|->
name|alloc
operator|=
name|alloc
expr_stmt|;
name|d
operator|->
name|offset
operator|=
sizeof|sizeof
argument_list|(
name|QStringData
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|expand
name|void
name|QString
operator|::
name|expand
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|int
name|sz
init|=
name|d
operator|->
name|size
decl_stmt|;
name|resize
argument_list|(
name|qMax
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|sz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|size
operator|-
literal|1
operator|>
name|sz
condition|)
block|{
name|ushort
modifier|*
name|n
init|=
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
operator|-
literal|1
decl_stmt|;
name|ushort
modifier|*
name|e
init|=
name|d
operator|->
name|data
argument_list|()
operator|+
name|sz
decl_stmt|;
while|while
condition|(
name|n
operator|!=
name|e
condition|)
operator|*
operator|--
name|n
operator|=
literal|' '
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \fn void QString::clear()      Clears the contents of the string and makes it null.      \sa resize(), isNull() */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator=(const QString&other)      Assigns \a other to this string and returns a reference to this     string. */
end_comment
begin_function
name|QString
modifier|&
name|QString
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QString
modifier|&
name|other
parameter_list|)
name|Q_DECL_NOTHROW
block|{
name|other
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|Data
operator|::
name|deallocate
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString&QString::operator=(QString&&other)      Move-assigns \a other to this QString instance.      \since 5.2 */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator=(QLatin1String str)      \overload operator=()      Assigns the Latin-1 string \a str to this string. */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator=(const QByteArray&ba)      \overload operator=()      Assigns \a ba to this string. The byte array is converted to Unicode     using the fromUtf8() function. This function stops conversion at the     first NUL character found, or the end of the \a ba byte array.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator=(const char *str)      \overload operator=()      Assigns \a str to this string. The const char pointer is converted     to Unicode using the fromUtf8() function.      You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII     or \c QT_RESTRICTED_CAST_FROM_ASCII when you compile your applications.     This can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example.  */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator=(char ch)      \overload operator=()      Assigns character \a ch to this string. Note that the character is     converted to Unicode using the fromLatin1() function, unlike other 8-bit     functions that operate on UTF-8 data.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*!     \overload operator=()      Sets the string to contain the single character \a ch. */
end_comment
begin_function
DECL|function|operator =
name|QString
modifier|&
name|QString
operator|::
name|operator
name|=
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
return|return
name|operator
name|=
argument_list|(
name|QString
argument_list|(
name|ch
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!      \fn QString& QString::insert(int position, const QString&str)      Inserts the string \a str at the given index \a position and     returns a reference to this string.      Example:      \snippet qstring/main.cpp 26      If the given \a position is greater than size(), the array is     first extended using resize().      \sa append(), prepend(), replace(), remove() */
end_comment
begin_comment
comment|/*!     \fn QString& QString::insert(int position, const QStringRef&str)     \since 5.5     \overload insert()      Inserts the string reference \a str at the given index \a position and     returns a reference to this string.      If the given \a position is greater than size(), the array is     first extended using resize(). */
end_comment
begin_comment
comment|/*!     \fn QString& QString::insert(int position, const char *str)     \since 5.5     \overload insert()      Inserts the C string \a str at the given index \a position and     returns a reference to this string.      If the given \a position is greater than size(), the array is     first extended using resize().      This function is not available when QT_NO_CAST_FROM_ASCII is     defined. */
end_comment
begin_comment
comment|/*!     \fn QString& QString::insert(int position, const QByteArray&str)     \since 5.5     \overload insert()      Inserts the byte array \a str at the given index \a position and     returns a reference to this string.      If the given \a position is greater than size(), the array is     first extended using resize().      This function is not available when QT_NO_CAST_FROM_ASCII is     defined. */
end_comment
begin_comment
comment|/*!     \fn QString&QString::insert(int position, QLatin1String str)     \overload insert()      Inserts the Latin-1 string \a str at the given index \a position. */
end_comment
begin_function
DECL|function|insert
name|QString
modifier|&
name|QString
operator|::
name|insert
parameter_list|(
name|int
name|i
parameter_list|,
name|QLatin1String
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|str
operator|.
name|latin1
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
operator|!
name|s
operator|||
operator|!
operator|(
operator|*
name|s
operator|)
condition|)
return|return
operator|*
name|this
return|;
name|int
name|len
init|=
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
name|expand
argument_list|(
name|qMax
argument_list|(
name|d
operator|->
name|size
argument_list|,
name|i
argument_list|)
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|::
name|memmove
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|i
operator|+
name|len
argument_list|,
name|d
operator|->
name|data
argument_list|()
operator|+
name|i
argument_list|,
operator|(
name|d
operator|->
name|size
operator|-
name|i
operator|-
name|len
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|qt_from_latin1
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|i
argument_list|,
name|s
argument_list|,
name|uint
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString& QString::insert(int position, const QChar *unicode, int size)     \overload insert()      Inserts the first \a size characters of the QChar array \a unicode     at the given index \a position in the string. */
end_comment
begin_function
DECL|function|insert
name|QString
modifier|&
name|QString
operator|::
name|insert
parameter_list|(
name|int
name|i
parameter_list|,
specifier|const
name|QChar
modifier|*
name|unicode
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|size
operator|<=
literal|0
condition|)
return|return
operator|*
name|this
return|;
specifier|const
name|ushort
modifier|*
name|s
init|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|unicode
decl_stmt|;
if|if
condition|(
name|s
operator|>=
name|d
operator|->
name|data
argument_list|()
operator|&&
name|s
operator|<
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|alloc
condition|)
block|{
comment|// Part of me - take a copy
name|ushort
modifier|*
name|tmp
init|=
cast|static_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
operator|::
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|s
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|i
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|::
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|expand
argument_list|(
name|qMax
argument_list|(
name|d
operator|->
name|size
argument_list|,
name|i
argument_list|)
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|::
name|memmove
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|i
operator|+
name|size
argument_list|,
name|d
operator|->
name|data
argument_list|()
operator|+
name|i
argument_list|,
operator|(
name|d
operator|->
name|size
operator|-
name|i
operator|-
name|size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|i
argument_list|,
name|s
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString& QString::insert(int position, QChar ch)     \overload insert()      Inserts \a ch at the given index \a position in the string. */
end_comment
begin_function
DECL|function|insert
name|QString
modifier|&
name|QString
operator|::
name|insert
parameter_list|(
name|int
name|i
parameter_list|,
name|QChar
name|ch
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|+=
name|d
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|*
name|this
return|;
name|expand
argument_list|(
name|qMax
argument_list|(
name|i
argument_list|,
name|d
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
operator|::
name|memmove
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|i
operator|+
literal|1
argument_list|,
name|d
operator|->
name|data
argument_list|()
operator|+
name|i
argument_list|,
operator|(
name|d
operator|->
name|size
operator|-
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|i
index|]
operator|=
name|ch
operator|.
name|unicode
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Appends the string \a str onto the end of this string.      Example:      \snippet qstring/main.cpp 9      This is the same as using the insert() function:      \snippet qstring/main.cpp 10      The append() function is typically very fast (\l{constant time}),     because QString preallocates extra space at the end of the string     data so it can grow without reallocating the entire string each     time.      \sa operator+=(), prepend(), insert() */
end_comment
begin_function
DECL|function|append
name|QString
modifier|&
name|QString
operator|::
name|append
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|.
name|d
operator|!=
name|Data
operator|::
name|sharedNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|==
name|Data
operator|::
name|sharedNull
argument_list|()
condition|)
block|{
name|operator
name|=
parameter_list|(
name|str
parameter_list|)
function_decl|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|str
operator|.
name|d
operator|->
name|size
argument_list|)
operator|+
literal|1u
operator|>
name|d
operator|->
name|alloc
condition|)
name|reallocData
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|str
operator|.
name|d
operator|->
name|size
argument_list|)
operator|+
literal|1u
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
argument_list|,
name|str
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|str
operator|.
name|d
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|+=
name|str
operator|.
name|d
operator|->
name|size
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|d
operator|->
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   \overload append()   \since 5.0    Appends \a len characters from the QChar array \a str to this string. */
end_comment
begin_function
DECL|function|append
name|QString
modifier|&
name|QString
operator|::
name|append
parameter_list|(
specifier|const
name|QChar
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|str
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|len
argument_list|)
operator|+
literal|1u
operator|>
name|d
operator|->
name|alloc
condition|)
name|reallocData
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|len
argument_list|)
operator|+
literal|1u
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
argument_list|,
name|str
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|+=
name|len
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|d
operator|->
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   \overload append()    Appends the Latin-1 string \a str to this string. */
end_comment
begin_function
DECL|function|append
name|QString
modifier|&
name|QString
operator|::
name|append
parameter_list|(
name|QLatin1String
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|str
operator|.
name|latin1
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|int
name|len
init|=
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|len
argument_list|)
operator|+
literal|1u
operator|>
name|d
operator|->
name|alloc
condition|)
name|reallocData
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|size
operator|+
name|len
argument_list|)
operator|+
literal|1u
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|ushort
modifier|*
name|i
init|=
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
decl_stmt|;
name|qt_from_latin1
argument_list|(
name|i
argument_list|,
name|s
argument_list|,
name|uint
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|i
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|->
name|size
operator|+=
name|len
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*! \fn QString&QString::append(const QByteArray&ba)      \overload append()      Appends the byte array \a ba to this string. The given byte array     is converted to Unicode using the fromUtf8() function.      You can disable this function by defining \c QT_NO_CAST_FROM_ASCII     when you compile your applications. This can be useful if you want     to ensure that all user-visible strings go through QObject::tr(),     for example. */
end_comment
begin_comment
comment|/*! \fn QString&QString::append(const char *str)      \overload append()      Appends the string \a str to this string. The given const char     pointer is converted to Unicode using the fromUtf8() function.      You can disable this function by defining \c QT_NO_CAST_FROM_ASCII     when you compile your applications. This can be useful if you want     to ensure that all user-visible strings go through QObject::tr(),     for example. */
end_comment
begin_comment
comment|/*!     \overload append()      Appends the character \a ch to this string. */
end_comment
begin_function
DECL|function|append
name|QString
modifier|&
name|QString
operator|::
name|append
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
operator|+
literal|2u
operator|>
name|d
operator|->
name|alloc
condition|)
name|reallocData
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
operator|+
literal|2u
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|d
operator|->
name|size
operator|++
index|]
operator|=
name|ch
operator|.
name|unicode
argument_list|()
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|d
operator|->
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*! \fn QString&QString::prepend(const QString&str)      Prepends the string \a str to the beginning of this string and     returns a reference to this string.      Example:      \snippet qstring/main.cpp 36      \sa append(), insert() */
end_comment
begin_comment
comment|/*! \fn QString&QString::prepend(QLatin1String str)      \overload prepend()      Prepends the Latin-1 string \a str to this string. */
end_comment
begin_comment
comment|/*! \fn QString&QString::prepend(const QChar *str, int len)     \since 5.5     \overload prepend()      Prepends \a len characters from the QChar array \a str to this string and     returns a reference to this string. */
end_comment
begin_comment
comment|/*! \fn QString&QString::prepend(const QStringRef&str)     \since 5.5     \overload prepend()      Prepends the string reference \a str to the beginning of this string and     returns a reference to this string. */
end_comment
begin_comment
comment|/*! \fn QString&QString::prepend(const QByteArray&ba)      \overload prepend()      Prepends the byte array \a ba to this string. The byte array is     converted to Unicode using the fromUtf8() function.      You can disable this function by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*! \fn QString&QString::prepend(const char *str)      \overload prepend()      Prepends the string \a str to this string. The const char pointer     is converted to Unicode using the fromUtf8() function.      You can disable this function by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*! \fn QString&QString::prepend(QChar ch)      \overload prepend()      Prepends the character \a ch to this string. */
end_comment
begin_comment
comment|/*!   \fn QString&QString::remove(int position, int n)    Removes \a n characters from the string, starting at the given \a   position index, and returns a reference to the string.    If the specified \a position index is within the string, but \a   position + \a n is beyond the end of the string, the string is   truncated at the specified \a position.    \snippet qstring/main.cpp 37    \sa insert(), replace() */
end_comment
begin_function
DECL|function|remove
name|QString
modifier|&
name|QString
operator|::
name|remove
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
comment|// count from end of string
name|pos
operator|+=
name|d
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|pos
argument_list|)
operator|>=
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
condition|)
block|{
comment|// range problems
block|}
elseif|else
if|if
condition|(
name|len
operator|>=
name|d
operator|->
name|size
operator|-
name|pos
condition|)
block|{
name|resize
argument_list|(
name|pos
argument_list|)
expr_stmt|;
comment|// truncate
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|memmove
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|pos
argument_list|,
name|d
operator|->
name|data
argument_list|()
operator|+
name|pos
operator|+
name|len
argument_list|,
operator|(
name|d
operator|->
name|size
operator|-
name|pos
operator|-
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|-=
name|len
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   Removes every occurrence of the given \a str string in this   string, and returns a reference to this string.    If \a cs is Qt::CaseSensitive (default), the search is   case sensitive; otherwise the search is case insensitive.    This is the same as \c replace(str, "", cs).    \sa replace() */
end_comment
begin_function
DECL|function|remove
name|QString
modifier|&
name|QString
operator|::
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
if|if
condition|(
name|str
operator|.
name|d
operator|->
name|size
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|indexOf
argument_list|(
name|str
argument_list|,
name|i
argument_list|,
name|cs
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
name|remove
argument_list|(
name|i
argument_list|,
name|str
operator|.
name|d
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   Removes every occurrence of the character \a ch in this string, and   returns a reference to this string.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    Example:    \snippet qstring/main.cpp 38    This is the same as \c replace(ch, "", cs).    \sa replace() */
end_comment
begin_function
DECL|function|remove
name|QString
modifier|&
name|QString
operator|::
name|remove
parameter_list|(
name|QChar
name|ch
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|ushort
name|c
init|=
name|ch
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|d
operator|->
name|size
condition|)
if|if
condition|(
name|d
operator|->
name|data
argument_list|()
index|[
name|i
index|]
operator|==
name|ch
condition|)
name|remove
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|foldCase
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|d
operator|->
name|size
condition|)
if|if
condition|(
name|foldCase
argument_list|(
name|d
operator|->
name|data
argument_list|()
index|[
name|i
index|]
argument_list|)
operator|==
name|c
condition|)
name|remove
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   \fn QString&QString::remove(const QRegExp&rx)    Removes every occurrence of the regular expression \a rx in the   string, and returns a reference to the string. For example:    \snippet qstring/main.cpp 39    \sa indexOf(), lastIndexOf(), replace() */
end_comment
begin_comment
comment|/*!   \fn QString&QString::remove(const QRegularExpression&re)   \since 5.0    Removes every occurrence of the regular expression \a re in the   string, and returns a reference to the string. For example:    \snippet qstring/main.cpp 96    \sa indexOf(), lastIndexOf(), replace() */
end_comment
begin_comment
comment|/*!   \fn QString&QString::replace(int position, int n, const QString&after)    Replaces \a n characters beginning at index \a position with   the string \a after and returns a reference to this string.    \note If the specified \a position index is within the string,   but \a position + \a n goes outside the strings range,   then \a n will be adjusted to stop at the end of the string.    Example:    \snippet qstring/main.cpp 40    \sa insert(), remove() */
end_comment
begin_function
DECL|function|replace
name|QString
modifier|&
name|QString
operator|::
name|replace
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|QString
modifier|&
name|after
parameter_list|)
block|{
name|QString
name|copy
init|=
name|after
decl_stmt|;
return|return
name|replace
argument_list|(
name|pos
argument_list|,
name|len
argument_list|,
name|copy
operator|.
name|constData
argument_list|()
argument_list|,
name|copy
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \fn QString&QString::replace(int position, int n, const QChar *unicode, int size)   \overload replace()   Replaces \a n characters beginning at index \a position with the   first \a size characters of the QChar array \a unicode and returns a   reference to this string. */
end_comment
begin_function
DECL|function|replace
name|QString
modifier|&
name|QString
operator|::
name|replace
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|QChar
modifier|*
name|unicode
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|uint
argument_list|(
name|pos
argument_list|)
operator|>
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|len
operator|>
name|d
operator|->
name|size
operator|-
name|pos
condition|)
name|len
operator|=
name|d
operator|->
name|size
operator|-
name|pos
expr_stmt|;
name|uint
name|index
init|=
name|pos
decl_stmt|;
name|replace_helper
argument_list|(
operator|&
name|index
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|unicode
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   \fn QString&QString::replace(int position, int n, QChar after)   \overload replace()    Replaces \a n characters beginning at index \a position with the   character \a after and returns a reference to this string. */
end_comment
begin_function
DECL|function|replace
name|QString
modifier|&
name|QString
operator|::
name|replace
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|len
parameter_list|,
name|QChar
name|after
parameter_list|)
block|{
return|return
name|replace
argument_list|(
name|pos
argument_list|,
name|len
argument_list|,
operator|&
name|after
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload replace()   Replaces every occurrence of the string \a before with the string \a   after and returns a reference to this string.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    Example:    \snippet qstring/main.cpp 41    \note The replacement text is not rescanned after it is inserted.    Example:    \snippet qstring/main.cpp 86 */
end_comment
begin_function
DECL|function|replace
name|QString
modifier|&
name|QString
operator|::
name|replace
parameter_list|(
specifier|const
name|QString
modifier|&
name|before
parameter_list|,
specifier|const
name|QString
modifier|&
name|after
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
return|return
name|replace
argument_list|(
name|before
operator|.
name|constData
argument_list|()
argument_list|,
name|before
operator|.
name|size
argument_list|()
argument_list|,
name|after
operator|.
name|constData
argument_list|()
argument_list|,
name|after
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal  */
end_comment
begin_function
DECL|function|replace_helper
name|void
name|QString
operator|::
name|replace_helper
parameter_list|(
name|uint
modifier|*
name|indices
parameter_list|,
name|int
name|nIndices
parameter_list|,
name|int
name|blen
parameter_list|,
specifier|const
name|QChar
modifier|*
name|after
parameter_list|,
name|int
name|alen
parameter_list|)
block|{
comment|// copy *after in case it lies inside our own d->data() area
comment|// (which we could possibly invalidate via a realloc or corrupt via memcpy operations.)
name|QChar
modifier|*
name|afterBuffer
init|=
cast|const_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
name|after
argument_list|)
decl_stmt|;
if|if
condition|(
name|after
operator|>=
cast|reinterpret_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|)
operator|&&
name|after
operator|<
cast|reinterpret_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|)
operator|+
name|d
operator|->
name|size
condition|)
block|{
name|afterBuffer
operator|=
cast|static_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
operator|::
name|malloc
argument_list|(
name|alen
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|afterBuffer
argument_list|)
expr_stmt|;
operator|::
name|memcpy
argument_list|(
name|afterBuffer
argument_list|,
name|after
argument_list|,
name|alen
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QT_TRY
block|{
if|if
condition|(
name|blen
operator|==
name|alen
condition|)
block|{
comment|// replace in place
name|detach
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nIndices
condition|;
operator|++
name|i
control|)
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|indices
index|[
name|i
index|]
argument_list|,
name|afterBuffer
argument_list|,
name|alen
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alen
operator|<
name|blen
condition|)
block|{
comment|// replace from front
name|detach
argument_list|()
expr_stmt|;
name|uint
name|to
init|=
name|indices
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|alen
condition|)
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|to
argument_list|,
name|after
argument_list|,
name|alen
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|+=
name|alen
expr_stmt|;
name|uint
name|movestart
init|=
name|indices
index|[
literal|0
index|]
operator|+
name|blen
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|nIndices
condition|;
operator|++
name|i
control|)
block|{
name|int
name|msize
init|=
name|indices
index|[
name|i
index|]
operator|-
name|movestart
decl_stmt|;
if|if
condition|(
name|msize
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|to
argument_list|,
name|d
operator|->
name|data
argument_list|()
operator|+
name|movestart
argument_list|,
name|msize
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|+=
name|msize
expr_stmt|;
block|}
if|if
condition|(
name|alen
condition|)
block|{
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|to
argument_list|,
name|afterBuffer
argument_list|,
name|alen
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|+=
name|alen
expr_stmt|;
block|}
name|movestart
operator|=
name|indices
index|[
name|i
index|]
operator|+
name|blen
expr_stmt|;
block|}
name|int
name|msize
init|=
name|d
operator|->
name|size
operator|-
name|movestart
decl_stmt|;
if|if
condition|(
name|msize
operator|>
literal|0
condition|)
name|memmove
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|to
argument_list|,
name|d
operator|->
name|data
argument_list|()
operator|+
name|movestart
argument_list|,
name|msize
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|resize
argument_list|(
name|d
operator|->
name|size
operator|-
name|nIndices
operator|*
operator|(
name|blen
operator|-
name|alen
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// replace from back
name|int
name|adjust
init|=
name|nIndices
operator|*
operator|(
name|alen
operator|-
name|blen
operator|)
decl_stmt|;
name|int
name|newLen
init|=
name|d
operator|->
name|size
operator|+
name|adjust
decl_stmt|;
name|int
name|moveend
init|=
name|d
operator|->
name|size
decl_stmt|;
name|resize
argument_list|(
name|newLen
argument_list|)
expr_stmt|;
while|while
condition|(
name|nIndices
condition|)
block|{
operator|--
name|nIndices
expr_stmt|;
name|int
name|movestart
init|=
name|indices
index|[
name|nIndices
index|]
operator|+
name|blen
decl_stmt|;
name|int
name|insertstart
init|=
name|indices
index|[
name|nIndices
index|]
operator|+
name|nIndices
operator|*
operator|(
name|alen
operator|-
name|blen
operator|)
decl_stmt|;
name|int
name|moveto
init|=
name|insertstart
operator|+
name|alen
decl_stmt|;
name|memmove
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|moveto
argument_list|,
name|d
operator|->
name|data
argument_list|()
operator|+
name|movestart
argument_list|,
operator|(
name|moveend
operator|-
name|movestart
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
operator|+
name|insertstart
argument_list|,
name|afterBuffer
argument_list|,
name|alen
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|moveend
operator|=
name|movestart
operator|-
name|blen
expr_stmt|;
block|}
block|}
block|}
name|QT_CATCH
argument_list|(
argument|const std::bad_alloc&
argument_list|)
block|{
if|if
condition|(
name|afterBuffer
operator|!=
name|after
condition|)
operator|::
name|free
argument_list|(
name|afterBuffer
argument_list|)
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
if|if
condition|(
name|afterBuffer
operator|!=
name|after
condition|)
operator|::
name|free
argument_list|(
name|afterBuffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \since 4.5   \overload replace()    Replaces each occurrence in this string of the first \a blen   characters of \a before with the first \a alen characters of \a   after and returns a reference to this string.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive. */
end_comment
begin_function
DECL|function|replace
name|QString
modifier|&
name|QString
operator|::
name|replace
parameter_list|(
specifier|const
name|QChar
modifier|*
name|before
parameter_list|,
name|int
name|blen
parameter_list|,
specifier|const
name|QChar
modifier|*
name|after
parameter_list|,
name|int
name|alen
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|blen
condition|)
return|return
operator|*
name|this
return|;
block|}
else|else
block|{
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
operator|&&
name|before
operator|==
name|after
operator|&&
name|blen
operator|==
name|alen
condition|)
return|return
operator|*
name|this
return|;
block|}
if|if
condition|(
name|alen
operator|==
literal|0
operator|&&
name|blen
operator|==
literal|0
condition|)
return|return
operator|*
name|this
return|;
name|QStringMatcher
name|matcher
argument_list|(
name|before
argument_list|,
name|blen
argument_list|,
name|cs
argument_list|)
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|uint
name|indices
index|[
literal|1024
index|]
decl_stmt|;
name|uint
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|<
literal|1023
condition|)
block|{
name|index
operator|=
name|matcher
operator|.
name|indexIn
argument_list|(
operator|*
name|this
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
break|break;
name|indices
index|[
name|pos
operator|++
index|]
operator|=
name|index
expr_stmt|;
name|index
operator|+=
name|blen
expr_stmt|;
comment|// avoid infinite loop
if|if
condition|(
operator|!
name|blen
condition|)
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pos
condition|)
break|break;
name|replace_helper
argument_list|(
name|indices
argument_list|,
name|pos
argument_list|,
name|blen
argument_list|,
name|after
argument_list|,
name|alen
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
break|break;
comment|// index has to be adjusted in case we get back into the loop above.
name|index
operator|+=
name|pos
operator|*
operator|(
name|alen
operator|-
name|blen
operator|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   \overload replace()   Replaces every occurrence of the character \a ch in the string with   \a after and returns a reference to this string.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive. */
end_comment
begin_function
DECL|function|replace
name|QString
modifier|&
name|QString
operator|::
name|replace
parameter_list|(
name|QChar
name|ch
parameter_list|,
specifier|const
name|QString
modifier|&
name|after
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
if|if
condition|(
name|after
operator|.
name|d
operator|->
name|size
operator|==
literal|0
condition|)
return|return
name|remove
argument_list|(
name|ch
argument_list|,
name|cs
argument_list|)
return|;
if|if
condition|(
name|after
operator|.
name|d
operator|->
name|size
operator|==
literal|1
condition|)
return|return
name|replace
argument_list|(
name|ch
argument_list|,
name|after
operator|.
name|d
operator|->
name|data
argument_list|()
index|[
literal|0
index|]
argument_list|,
name|cs
argument_list|)
return|;
if|if
condition|(
name|d
operator|->
name|size
operator|==
literal|0
condition|)
return|return
operator|*
name|this
return|;
name|ushort
name|cc
init|=
operator|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|?
name|ch
operator|.
name|unicode
argument_list|()
else|:
name|ch
operator|.
name|toCaseFolded
argument_list|()
operator|.
name|unicode
argument_list|()
operator|)
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|uint
name|indices
index|[
literal|1024
index|]
decl_stmt|;
name|uint
name|pos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
while|while
condition|(
name|pos
operator|<
literal|1023
operator|&&
name|index
operator|<
name|d
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|data
argument_list|()
index|[
name|index
index|]
operator|==
name|cc
condition|)
name|indices
index|[
name|pos
operator|++
index|]
operator|=
name|index
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|pos
operator|<
literal|1023
operator|&&
name|index
operator|<
name|d
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|QChar
operator|::
name|toCaseFolded
argument_list|(
name|d
operator|->
name|data
argument_list|()
index|[
name|index
index|]
argument_list|)
operator|==
name|cc
condition|)
name|indices
index|[
name|pos
operator|++
index|]
operator|=
name|index
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|pos
condition|)
break|break;
name|replace_helper
argument_list|(
name|indices
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|,
name|after
operator|.
name|constData
argument_list|()
argument_list|,
name|after
operator|.
name|d
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
break|break;
comment|// index has to be adjusted in case we get back into the loop above.
name|index
operator|+=
name|pos
operator|*
operator|(
name|after
operator|.
name|d
operator|->
name|size
operator|-
literal|1
operator|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   \overload replace()   Replaces every occurrence of the character \a before with the   character \a after and returns a reference to this string.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive. */
end_comment
begin_function
DECL|function|replace
name|QString
modifier|&
name|QString
operator|::
name|replace
parameter_list|(
name|QChar
name|before
parameter_list|,
name|QChar
name|after
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
name|ushort
name|a
init|=
name|after
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|ushort
name|b
init|=
name|before
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|size
condition|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|ushort
modifier|*
name|i
init|=
name|d
operator|->
name|data
argument_list|()
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|e
init|=
name|i
operator|+
name|d
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
for|for
control|(
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|i
operator|==
name|b
condition|)
operator|*
name|i
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|foldCase
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|foldCase
argument_list|(
operator|*
name|i
argument_list|)
operator|==
name|b
condition|)
operator|*
name|i
operator|=
name|a
expr_stmt|;
block|}
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.5   \overload replace()    Replaces every occurrence of the string \a before with the string \a   after and returns a reference to this string.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    \note The text is not rescanned after a replacement. */
end_comment
begin_function
DECL|function|replace
name|QString
modifier|&
name|QString
operator|::
name|replace
parameter_list|(
name|QLatin1String
name|before
parameter_list|,
name|QLatin1String
name|after
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
name|int
name|alen
init|=
name|after
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|blen
init|=
name|before
operator|.
name|size
argument_list|()
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|ushort
argument_list|>
name|a
argument_list|(
name|alen
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|ushort
argument_list|>
name|b
argument_list|(
name|blen
argument_list|)
decl_stmt|;
name|qt_from_latin1
argument_list|(
name|a
operator|.
name|data
argument_list|()
argument_list|,
name|after
operator|.
name|latin1
argument_list|()
argument_list|,
name|alen
argument_list|)
expr_stmt|;
name|qt_from_latin1
argument_list|(
name|b
operator|.
name|data
argument_list|()
argument_list|,
name|before
operator|.
name|latin1
argument_list|()
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
name|replace
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|b
operator|.
name|data
argument_list|()
argument_list|,
name|blen
argument_list|,
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|a
operator|.
name|data
argument_list|()
argument_list|,
name|alen
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.5   \overload replace()    Replaces every occurrence of the string \a before with the string \a   after and returns a reference to this string.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    \note The text is not rescanned after a replacement. */
end_comment
begin_function
DECL|function|replace
name|QString
modifier|&
name|QString
operator|::
name|replace
parameter_list|(
name|QLatin1String
name|before
parameter_list|,
specifier|const
name|QString
modifier|&
name|after
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
name|int
name|blen
init|=
name|before
operator|.
name|size
argument_list|()
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|ushort
argument_list|>
name|b
argument_list|(
name|blen
argument_list|)
decl_stmt|;
name|qt_from_latin1
argument_list|(
name|b
operator|.
name|data
argument_list|()
argument_list|,
name|before
operator|.
name|latin1
argument_list|()
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
name|replace
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|b
operator|.
name|data
argument_list|()
argument_list|,
name|blen
argument_list|,
name|after
operator|.
name|constData
argument_list|()
argument_list|,
name|after
operator|.
name|d
operator|->
name|size
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.5   \overload replace()    Replaces every occurrence of the string \a before with the string \a   after and returns a reference to this string.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    \note The text is not rescanned after a replacement. */
end_comment
begin_function
DECL|function|replace
name|QString
modifier|&
name|QString
operator|::
name|replace
parameter_list|(
specifier|const
name|QString
modifier|&
name|before
parameter_list|,
name|QLatin1String
name|after
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
name|int
name|alen
init|=
name|after
operator|.
name|size
argument_list|()
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|ushort
argument_list|>
name|a
argument_list|(
name|alen
argument_list|)
decl_stmt|;
name|qt_from_latin1
argument_list|(
name|a
operator|.
name|data
argument_list|()
argument_list|,
name|after
operator|.
name|latin1
argument_list|()
argument_list|,
name|alen
argument_list|)
expr_stmt|;
return|return
name|replace
argument_list|(
name|before
operator|.
name|constData
argument_list|()
argument_list|,
name|before
operator|.
name|d
operator|->
name|size
argument_list|,
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|a
operator|.
name|data
argument_list|()
argument_list|,
name|alen
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.5   \overload replace()    Replaces every occurrence of the character \a c with the string \a   after and returns a reference to this string.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    \note The text is not rescanned after a replacement. */
end_comment
begin_function
DECL|function|replace
name|QString
modifier|&
name|QString
operator|::
name|replace
parameter_list|(
name|QChar
name|c
parameter_list|,
name|QLatin1String
name|after
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
name|int
name|alen
init|=
name|after
operator|.
name|size
argument_list|()
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|ushort
argument_list|>
name|a
argument_list|(
name|alen
argument_list|)
decl_stmt|;
name|qt_from_latin1
argument_list|(
name|a
operator|.
name|data
argument_list|()
argument_list|,
name|after
operator|.
name|latin1
argument_list|()
argument_list|,
name|alen
argument_list|)
expr_stmt|;
return|return
name|replace
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|,
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|a
operator|.
name|data
argument_list|()
argument_list|,
name|alen
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \relates QString   Returns \c true if string \a s1 is equal to string \a s2; otherwise   returns \c false.    The comparison is based exclusively on the numeric Unicode values of   the characters and is very fast, but is not what a human would   expect. Consider sorting user-interface strings with   localeAwareCompare(). */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QString
modifier|&
name|s1
parameter_list|,
specifier|const
name|QString
modifier|&
name|s2
parameter_list|)
block|{
if|if
condition|(
name|s1
operator|.
name|d
operator|->
name|size
operator|!=
name|s2
operator|.
name|d
operator|->
name|size
condition|)
return|return
literal|false
return|;
return|return
name|qMemEquals
argument_list|(
name|s1
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|s2
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|s1
operator|.
name|d
operator|->
name|size
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload operator==() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QString
operator|::
name|operator
name|==
parameter_list|(
name|QLatin1String
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|size
operator|!=
name|other
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|other
operator|.
name|size
argument_list|()
condition|)
return|return
name|isEmpty
argument_list|()
return|;
return|return
name|compare_helper
argument_list|(
name|data
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|other
argument_list|,
name|Qt
operator|::
name|CaseSensitive
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QString::operator==(const QByteArray&other) const      \overload operator==()      The \a other byte array is converted to a QString using the     fromUtf8() function. This function stops conversion at the     first NUL character found, or the end of the byte array.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example.      Returns \c true if this string is lexically equal to the parameter     string \a other. Otherwise returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool QString::operator==(const char *other) const      \overload operator==()      The \a other const char pointer is converted to a QString using     the fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*!    \relates QString     Returns \c true if string \a s1 is lexically less than string     \a s2; otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings using the     QString::localeAwareCompare() function. */
end_comment
begin_function
DECL|function|operator <
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|QString
modifier|&
name|s1
parameter_list|,
specifier|const
name|QString
modifier|&
name|s2
parameter_list|)
block|{
return|return
name|ucstrcmp
argument_list|(
name|s1
operator|.
name|constData
argument_list|()
argument_list|,
name|s1
operator|.
name|length
argument_list|()
argument_list|,
name|s2
operator|.
name|constData
argument_list|()
argument_list|,
name|s2
operator|.
name|length
argument_list|()
argument_list|)
operator|<
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!    \overload operator<()    \relates QString     Returns \c true if this string is lexically less than the parameter     string called \a other; otherwise returns \c false. */
end_comment
begin_function
DECL|function|operator <
name|bool
name|QString
operator|::
name|operator
name|<
parameter_list|(
name|QLatin1String
name|other
parameter_list|)
specifier|const
block|{
specifier|const
name|uchar
modifier|*
name|c
init|=
operator|(
name|uchar
operator|*
operator|)
name|other
operator|.
name|latin1
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
operator|*
name|c
operator|==
literal|0
condition|)
return|return
literal|false
return|;
return|return
name|compare_helper
argument_list|(
name|data
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|other
argument_list|,
name|Qt
operator|::
name|CaseSensitive
argument_list|)
operator|<
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QString::operator<(const QByteArray&other) const      \overload operator<()      The \a other byte array is converted to a QString using the     fromUtf8() function. If any NUL characters ('\\0') are embedded     in the byte array, they will be included in the transformation.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*! \fn bool QString::operator<(const char *other) const      Returns \c true if this string is lexically less than string \a other.     Otherwise returns \c false.      \overload operator<()      The \a other const char pointer is converted to a QString using     the fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*! \fn bool operator<=(const QString&s1, const QString&s2)      \relates QString      Returns \c true if string \a s1 is lexically less than or equal to     string \a s2; otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings with     localeAwareCompare(). */
end_comment
begin_comment
comment|/*! \fn bool QString::operator<=(QLatin1String other) const      Returns \c true if this string is lexically less than or equal to     parameter string \a other. Otherwise returns \c false.      \overload operator<=() */
end_comment
begin_comment
comment|/*! \fn bool QString::operator<=(const QByteArray&other) const      \overload operator<=()      The \a other byte array is converted to a QString using the     fromUtf8() function. If any NUL characters ('\\0') are embedded     in the byte array, they will be included in the transformation.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*! \fn bool QString::operator<=(const char *other) const      \overload operator<=()      The \a other const char pointer is converted to a QString using     the fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*! \fn bool operator>(const QString&s1, const QString&s2)     \relates QString      Returns \c true if string \a s1 is lexically greater than string \a s2;     otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings with     localeAwareCompare(). */
end_comment
begin_comment
comment|/*!    \overload operator>()    \relates QString     Returns \c true if this string is lexically greater than the parameter     string \a other; otherwise returns \c false. */
end_comment
begin_function
DECL|function|operator >
name|bool
name|QString
operator|::
name|operator
name|>
parameter_list|(
name|QLatin1String
name|other
parameter_list|)
specifier|const
block|{
specifier|const
name|uchar
modifier|*
name|c
init|=
operator|(
name|uchar
operator|*
operator|)
name|other
operator|.
name|latin1
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
operator|*
name|c
operator|==
literal|'\0'
condition|)
return|return
operator|!
name|isEmpty
argument_list|()
return|;
return|return
name|compare_helper
argument_list|(
name|data
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|other
argument_list|,
name|Qt
operator|::
name|CaseSensitive
argument_list|)
operator|>
literal|0
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QString::operator>(const QByteArray&other) const      \overload operator>()      The \a other byte array is converted to a QString using the     fromUtf8() function. If any NUL characters ('\\0') are embedded     in the byte array, they will be included in the transformation.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*! \fn bool QString::operator>(const char *other) const      \overload operator>()      The \a other const char pointer is converted to a QString using     the fromUtf8() function.      You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII     when you compile your applications. This can be useful if you want     to ensure that all user-visible strings go through QObject::tr(),     for example. */
end_comment
begin_comment
comment|/*! \fn bool operator>=(const QString&s1, const QString&s2)     \relates QString      Returns \c true if string \a s1 is lexically greater than or equal to     string \a s2; otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings with     localeAwareCompare(). */
end_comment
begin_comment
comment|/*! \fn bool QString::operator>=(QLatin1String other) const      Returns \c true if this string is lexically greater than or equal to parameter     string \a other. Otherwise returns \c false.      \overload operator>=() */
end_comment
begin_comment
comment|/*! \fn bool QString::operator>=(const QByteArray&other) const      \overload operator>=()      The \a other byte array is converted to a QString using the     fromUtf8() function. If any NUL characters ('\\0') are embedded in     the byte array, they will be included in the transformation.      You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII     when you compile your applications. This can be useful if you want     to ensure that all user-visible strings go through QObject::tr(),     for example. */
end_comment
begin_comment
comment|/*! \fn bool QString::operator>=(const char *other) const      \overload operator>=()      The \a other const char pointer is converted to a QString using     the fromUtf8() function.      You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII     when you compile your applications. This can be useful if you want     to ensure that all user-visible strings go through QObject::tr(),     for example. */
end_comment
begin_comment
comment|/*! \fn bool operator!=(const QString&s1, const QString&s2)     \relates QString      Returns \c true if string \a s1 is not equal to string \a s2;     otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings with     localeAwareCompare(). */
end_comment
begin_comment
comment|/*! \fn bool QString::operator!=(QLatin1String other) const      Returns \c true if this string is not equal to parameter string \a other.     Otherwise returns \c false.      \overload operator!=() */
end_comment
begin_comment
comment|/*! \fn bool QString::operator!=(const QByteArray&other) const      \overload operator!=()      The \a other byte array is converted to a QString using the     fromUtf8() function. If any NUL characters ('\\0') are embedded     in the byte array, they will be included in the transformation.      You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII     when you compile your applications. This can be useful if you want     to ensure that all user-visible strings go through QObject::tr(),     for example. */
end_comment
begin_comment
comment|/*! \fn bool QString::operator!=(const char *other) const      \overload operator!=()      The \a other const char pointer is converted to a QString using     the fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*!   Returns the index position of the first occurrence of the string \a   str in this string, searching forward from index position \a   from. Returns -1 if \a str is not found.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    Example:    \snippet qstring/main.cpp 24    If \a from is -1, the search starts at the last character; if it is   -2, at the next to last character and so on.    \sa lastIndexOf(), contains(), count() */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QString
operator|::
name|indexOf
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qFindString
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|length
argument_list|()
argument_list|,
name|from
argument_list|,
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.5   Returns the index position of the first occurrence of the string \a   str in this string, searching forward from index position \a   from. Returns -1 if \a str is not found.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    Example:    \snippet qstring/main.cpp 24    If \a from is -1, the search starts at the last character; if it is   -2, at the next to last character and so on.    \sa lastIndexOf(), contains(), count() */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QString
operator|::
name|indexOf
parameter_list|(
name|QLatin1String
name|str
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_find_latin1_string
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|str
argument_list|,
name|from
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qFindString
name|int
name|qFindString
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack0
parameter_list|,
name|int
name|haystackLen
parameter_list|,
name|int
name|from
parameter_list|,
specifier|const
name|QChar
modifier|*
name|needle0
parameter_list|,
name|int
name|needleLen
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
specifier|const
name|int
name|l
init|=
name|haystackLen
decl_stmt|;
specifier|const
name|int
name|sl
init|=
name|needleLen
decl_stmt|;
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|sl
operator|+
name|from
argument_list|)
operator|>
operator|(
name|uint
operator|)
name|l
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|sl
condition|)
return|return
name|from
return|;
if|if
condition|(
operator|!
name|l
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|sl
operator|==
literal|1
condition|)
return|return
name|findChar
argument_list|(
name|haystack0
argument_list|,
name|haystackLen
argument_list|,
name|needle0
index|[
literal|0
index|]
argument_list|,
name|from
argument_list|,
name|cs
argument_list|)
return|;
comment|/*         We use the Boyer-Moore algorithm in cases where the overhead         for the skip table should pay off, otherwise we use a simple         hash function.     */
if|if
condition|(
name|l
operator|>
literal|500
operator|&&
name|sl
operator|>
literal|5
condition|)
return|return
name|qFindStringBoyerMoore
argument_list|(
name|haystack0
argument_list|,
name|haystackLen
argument_list|,
name|from
argument_list|,
name|needle0
argument_list|,
name|needleLen
argument_list|,
name|cs
argument_list|)
return|;
comment|/*         We use some hashing for efficiency's sake. Instead of         comparing strings, we compare the hash value of str with that         of a part of this QString. Only if that matches, we call         ucstrncmp() or ucstrnicmp().     */
specifier|const
name|ushort
modifier|*
name|needle
init|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|needle0
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|haystack
init|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|haystack0
operator|+
name|from
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|end
init|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|haystack0
operator|+
operator|(
name|l
operator|-
name|sl
operator|)
decl_stmt|;
specifier|const
name|int
name|sl_minus_1
init|=
name|sl
operator|-
literal|1
decl_stmt|;
name|int
name|hashNeedle
init|=
literal|0
decl_stmt|,
name|hashHaystack
init|=
literal|0
decl_stmt|,
name|idx
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sl
condition|;
operator|++
name|idx
control|)
block|{
name|hashNeedle
operator|=
operator|(
operator|(
name|hashNeedle
operator|<<
literal|1
operator|)
operator|+
name|needle
index|[
name|idx
index|]
operator|)
expr_stmt|;
name|hashHaystack
operator|=
operator|(
operator|(
name|hashHaystack
operator|<<
literal|1
operator|)
operator|+
name|haystack
index|[
name|idx
index|]
operator|)
expr_stmt|;
block|}
name|hashHaystack
operator|-=
name|haystack
index|[
name|sl_minus_1
index|]
expr_stmt|;
while|while
condition|(
name|haystack
operator|<=
name|end
condition|)
block|{
name|hashHaystack
operator|+=
name|haystack
index|[
name|sl_minus_1
index|]
expr_stmt|;
if|if
condition|(
name|hashHaystack
operator|==
name|hashNeedle
operator|&&
name|ucstrncmp
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|needle
argument_list|,
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|haystack
argument_list|,
name|sl
argument_list|)
operator|==
literal|0
condition|)
return|return
name|haystack
operator|-
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|haystack0
return|;
name|REHASH
argument_list|(
operator|*
name|haystack
argument_list|)
expr_stmt|;
operator|++
name|haystack
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|ushort
modifier|*
name|haystack_start
init|=
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|haystack0
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sl
condition|;
operator|++
name|idx
control|)
block|{
name|hashNeedle
operator|=
operator|(
name|hashNeedle
operator|<<
literal|1
operator|)
operator|+
name|foldCase
argument_list|(
name|needle
operator|+
name|idx
argument_list|,
name|needle
argument_list|)
expr_stmt|;
name|hashHaystack
operator|=
operator|(
name|hashHaystack
operator|<<
literal|1
operator|)
operator|+
name|foldCase
argument_list|(
name|haystack
operator|+
name|idx
argument_list|,
name|haystack_start
argument_list|)
expr_stmt|;
block|}
name|hashHaystack
operator|-=
name|foldCase
argument_list|(
name|haystack
operator|+
name|sl_minus_1
argument_list|,
name|haystack_start
argument_list|)
expr_stmt|;
while|while
condition|(
name|haystack
operator|<=
name|end
condition|)
block|{
name|hashHaystack
operator|+=
name|foldCase
argument_list|(
name|haystack
operator|+
name|sl_minus_1
argument_list|,
name|haystack_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashHaystack
operator|==
name|hashNeedle
operator|&&
name|ucstrnicmp
argument_list|(
name|needle
argument_list|,
name|haystack
argument_list|,
name|sl
argument_list|)
operator|==
literal|0
condition|)
return|return
name|haystack
operator|-
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|haystack0
return|;
name|REHASH
argument_list|(
name|foldCase
argument_list|(
name|haystack
argument_list|,
name|haystack_start
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|haystack
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \overload indexOf()      Returns the index position of the first occurrence of the     character \a ch in the string, searching forward from index     position \a from. Returns -1 if \a ch could not be found. */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QString
operator|::
name|indexOf
parameter_list|(
name|QChar
name|ch
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|findChar
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|length
argument_list|()
argument_list|,
name|ch
argument_list|,
name|from
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      \overload indexOf()      Returns the index position of the first occurrence of the string     reference \a str in this string, searching forward from index     position \a from. Returns -1 if \a str is not found.      If \a cs is Qt::CaseSensitive (default), the search is case     sensitive; otherwise the search is case insensitive. */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QString
operator|::
name|indexOf
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|str
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qFindString
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|length
argument_list|()
argument_list|,
name|from
argument_list|,
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|lastIndexOfHelper
specifier|static
name|int
name|lastIndexOfHelper
parameter_list|(
specifier|const
name|ushort
modifier|*
name|haystack
parameter_list|,
name|int
name|from
parameter_list|,
specifier|const
name|ushort
modifier|*
name|needle
parameter_list|,
name|int
name|sl
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
comment|/*         See indexOf() for explanations.     */
specifier|const
name|ushort
modifier|*
name|end
init|=
name|haystack
decl_stmt|;
name|haystack
operator|+=
name|from
expr_stmt|;
specifier|const
name|int
name|sl_minus_1
init|=
name|sl
operator|-
literal|1
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|n
init|=
name|needle
operator|+
name|sl_minus_1
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|h
init|=
name|haystack
operator|+
name|sl_minus_1
decl_stmt|;
name|int
name|hashNeedle
init|=
literal|0
decl_stmt|,
name|hashHaystack
init|=
literal|0
decl_stmt|,
name|idx
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sl
condition|;
operator|++
name|idx
control|)
block|{
name|hashNeedle
operator|=
operator|(
operator|(
name|hashNeedle
operator|<<
literal|1
operator|)
operator|+
operator|*
operator|(
name|n
operator|-
name|idx
operator|)
operator|)
expr_stmt|;
name|hashHaystack
operator|=
operator|(
operator|(
name|hashHaystack
operator|<<
literal|1
operator|)
operator|+
operator|*
operator|(
name|h
operator|-
name|idx
operator|)
operator|)
expr_stmt|;
block|}
name|hashHaystack
operator|-=
operator|*
name|haystack
expr_stmt|;
while|while
condition|(
name|haystack
operator|>=
name|end
condition|)
block|{
name|hashHaystack
operator|+=
operator|*
name|haystack
expr_stmt|;
if|if
condition|(
name|hashHaystack
operator|==
name|hashNeedle
operator|&&
name|ucstrncmp
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|needle
argument_list|,
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|haystack
argument_list|,
name|sl
argument_list|)
operator|==
literal|0
condition|)
return|return
name|haystack
operator|-
name|end
return|;
operator|--
name|haystack
expr_stmt|;
name|REHASH
argument_list|(
name|haystack
index|[
name|sl
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sl
condition|;
operator|++
name|idx
control|)
block|{
name|hashNeedle
operator|=
operator|(
operator|(
name|hashNeedle
operator|<<
literal|1
operator|)
operator|+
name|foldCase
argument_list|(
name|n
operator|-
name|idx
argument_list|,
name|needle
argument_list|)
operator|)
expr_stmt|;
name|hashHaystack
operator|=
operator|(
operator|(
name|hashHaystack
operator|<<
literal|1
operator|)
operator|+
name|foldCase
argument_list|(
name|h
operator|-
name|idx
argument_list|,
name|end
argument_list|)
operator|)
expr_stmt|;
block|}
name|hashHaystack
operator|-=
name|foldCase
argument_list|(
name|haystack
argument_list|,
name|end
argument_list|)
expr_stmt|;
while|while
condition|(
name|haystack
operator|>=
name|end
condition|)
block|{
name|hashHaystack
operator|+=
name|foldCase
argument_list|(
name|haystack
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashHaystack
operator|==
name|hashNeedle
operator|&&
name|ucstrnicmp
argument_list|(
name|needle
argument_list|,
name|haystack
argument_list|,
name|sl
argument_list|)
operator|==
literal|0
condition|)
return|return
name|haystack
operator|-
name|end
return|;
operator|--
name|haystack
expr_stmt|;
name|REHASH
argument_list|(
name|foldCase
argument_list|(
name|haystack
operator|+
name|sl
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the index position of the last occurrence of the string \a   str in this string, searching backward from index position \a   from. If \a from is -1 (default), the search starts at the last   character; if \a from is -2, at the next to last character and so   on. Returns -1 if \a str is not found.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    Example:    \snippet qstring/main.cpp 29    \sa indexOf(), contains(), count() */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QString
operator|::
name|lastIndexOf
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|sl
init|=
name|str
operator|.
name|d
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|sl
operator|==
literal|1
condition|)
return|return
name|lastIndexOf
argument_list|(
name|QChar
argument_list|(
name|str
operator|.
name|d
operator|->
name|data
argument_list|()
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|from
argument_list|,
name|cs
argument_list|)
return|;
specifier|const
name|int
name|l
init|=
name|d
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|+=
name|l
expr_stmt|;
name|int
name|delta
init|=
name|l
operator|-
name|sl
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|l
operator|&&
name|sl
operator|==
literal|0
condition|)
return|return
name|from
return|;
if|if
condition|(
name|uint
argument_list|(
name|from
argument_list|)
operator|>=
name|uint
argument_list|(
name|l
argument_list|)
operator|||
name|delta
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|from
operator|>
name|delta
condition|)
name|from
operator|=
name|delta
expr_stmt|;
return|return
name|lastIndexOfHelper
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|from
argument_list|,
name|str
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|str
operator|.
name|d
operator|->
name|size
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.5   \overload lastIndexOf()    Returns the index position of the last occurrence of the string \a   str in this string, searching backward from index position \a   from. If \a from is -1 (default), the search starts at the last   character; if \a from is -2, at the next to last character and so   on. Returns -1 if \a str is not found.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    Example:    \snippet qstring/main.cpp 29    \sa indexOf(), contains(), count() */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QString
operator|::
name|lastIndexOf
parameter_list|(
name|QLatin1String
name|str
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|sl
init|=
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|sl
operator|==
literal|1
condition|)
return|return
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
name|str
operator|.
name|latin1
argument_list|()
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|from
argument_list|,
name|cs
argument_list|)
return|;
specifier|const
name|int
name|l
init|=
name|d
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|+=
name|l
expr_stmt|;
name|int
name|delta
init|=
name|l
operator|-
name|sl
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|l
operator|&&
name|sl
operator|==
literal|0
condition|)
return|return
name|from
return|;
if|if
condition|(
name|uint
argument_list|(
name|from
argument_list|)
operator|>=
name|uint
argument_list|(
name|l
argument_list|)
operator|||
name|delta
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|from
operator|>
name|delta
condition|)
name|from
operator|=
name|delta
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|ushort
argument_list|>
name|s
argument_list|(
name|sl
argument_list|)
decl_stmt|;
name|qt_from_latin1
argument_list|(
name|s
operator|.
name|data
argument_list|()
argument_list|,
name|str
operator|.
name|latin1
argument_list|()
argument_list|,
name|sl
argument_list|)
expr_stmt|;
return|return
name|lastIndexOfHelper
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|from
argument_list|,
name|s
operator|.
name|data
argument_list|()
argument_list|,
name|sl
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload lastIndexOf()    Returns the index position of the last occurrence of the character   \a ch, searching backward from position \a from. */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QString
operator|::
name|lastIndexOf
parameter_list|(
name|QChar
name|ch
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_last_index_of
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ch
argument_list|,
name|from
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.8   \overload lastIndexOf()    Returns the index position of the last occurrence of the string   reference \a str in this string, searching backward from index   position \a from. If \a from is -1 (default), the search starts at   the last character; if \a from is -2, at the next to last character   and so on. Returns -1 if \a str is not found.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    \sa indexOf(), contains(), count() */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QString
operator|::
name|lastIndexOf
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|str
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|sl
init|=
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|sl
operator|==
literal|1
condition|)
return|return
name|lastIndexOf
argument_list|(
name|str
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|,
name|from
argument_list|,
name|cs
argument_list|)
return|;
specifier|const
name|int
name|l
init|=
name|d
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|+=
name|l
expr_stmt|;
name|int
name|delta
init|=
name|l
operator|-
name|sl
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|l
operator|&&
name|sl
operator|==
literal|0
condition|)
return|return
name|from
return|;
if|if
condition|(
name|uint
argument_list|(
name|from
argument_list|)
operator|>=
name|uint
argument_list|(
name|l
argument_list|)
operator|||
name|delta
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|from
operator|>
name|delta
condition|)
name|from
operator|=
name|delta
expr_stmt|;
return|return
name|lastIndexOfHelper
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|from
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|str
operator|.
name|unicode
argument_list|()
argument_list|)
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|QT_NO_REGEXP
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_NO_REGULAREXPRESSION
argument_list|)
operator|)
end_if
begin_struct
DECL|struct|QStringCapture
struct|struct
name|QStringCapture
block|{
DECL|member|pos
name|int
name|pos
decl_stmt|;
DECL|member|len
name|int
name|len
decl_stmt|;
DECL|member|no
name|int
name|no
decl_stmt|;
block|}
struct|;
end_struct
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|QStringCapture
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_comment
comment|/*!   \overload replace()    Replaces every occurrence of the regular expression \a rx in the   string with \a after. Returns a reference to the string. For   example:    \snippet qstring/main.cpp 42    For regular expressions containing \l{capturing parentheses},   occurrences of \b{\\1}, \b{\\2}, ..., in \a after are replaced   with \a{rx}.cap(1), cap(2), ...    \snippet qstring/main.cpp 43    \sa indexOf(), lastIndexOf(), remove(), QRegExp::cap() */
end_comment
begin_function
DECL|function|replace
name|QString
modifier|&
name|QString
operator|::
name|replace
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|,
specifier|const
name|QString
modifier|&
name|after
parameter_list|)
block|{
name|QRegExp
name|rx2
argument_list|(
name|rx
argument_list|)
decl_stmt|;
if|if
condition|(
name|isEmpty
argument_list|()
operator|&&
name|rx2
operator|.
name|indexIn
argument_list|(
operator|*
name|this
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|*
name|this
return|;
name|reallocData
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
operator|+
literal|1u
argument_list|)
expr_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|numCaptures
init|=
name|rx2
operator|.
name|captureCount
argument_list|()
decl_stmt|;
name|int
name|al
init|=
name|after
operator|.
name|length
argument_list|()
decl_stmt|;
name|QRegExp
operator|::
name|CaretMode
name|caretMode
init|=
name|QRegExp
operator|::
name|CaretAtZero
decl_stmt|;
if|if
condition|(
name|numCaptures
operator|>
literal|0
condition|)
block|{
specifier|const
name|QChar
modifier|*
name|uc
init|=
name|after
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|int
name|numBackRefs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|al
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
condition|)
block|{
name|int
name|no
init|=
name|uc
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|digitValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|no
operator|>
literal|0
operator|&&
name|no
operator|<=
name|numCaptures
condition|)
name|numBackRefs
operator|++
expr_stmt|;
block|}
block|}
comment|/*             This is the harder case where we have back-references.         */
if|if
condition|(
name|numBackRefs
operator|>
literal|0
condition|)
block|{
name|QVarLengthArray
argument_list|<
name|QStringCapture
argument_list|,
literal|16
argument_list|>
name|captures
argument_list|(
name|numBackRefs
argument_list|)
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|al
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
condition|)
block|{
name|int
name|no
init|=
name|uc
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|digitValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|no
operator|>
literal|0
operator|&&
name|no
operator|<=
name|numCaptures
condition|)
block|{
name|QStringCapture
name|capture
decl_stmt|;
name|capture
operator|.
name|pos
operator|=
name|i
expr_stmt|;
name|capture
operator|.
name|len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|al
operator|-
literal|2
condition|)
block|{
name|int
name|secondDigit
init|=
name|uc
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|digitValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|secondDigit
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|(
name|no
operator|*
literal|10
operator|)
operator|+
name|secondDigit
operator|)
operator|<=
name|numCaptures
condition|)
block|{
name|no
operator|=
operator|(
name|no
operator|*
literal|10
operator|)
operator|+
name|secondDigit
expr_stmt|;
operator|++
name|capture
operator|.
name|len
expr_stmt|;
block|}
block|}
name|capture
operator|.
name|no
operator|=
name|no
expr_stmt|;
name|captures
index|[
name|j
operator|++
index|]
operator|=
name|capture
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|index
operator|<=
name|length
argument_list|()
condition|)
block|{
name|index
operator|=
name|rx2
operator|.
name|indexIn
argument_list|(
operator|*
name|this
argument_list|,
name|index
argument_list|,
name|caretMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
break|break;
name|QString
name|after2
argument_list|(
name|after
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
name|numBackRefs
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
specifier|const
name|QStringCapture
modifier|&
name|capture
init|=
name|captures
index|[
name|j
index|]
decl_stmt|;
name|after2
operator|.
name|replace
argument_list|(
name|capture
operator|.
name|pos
argument_list|,
name|capture
operator|.
name|len
argument_list|,
name|rx2
operator|.
name|cap
argument_list|(
name|capture
operator|.
name|no
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|replace
argument_list|(
name|index
argument_list|,
name|rx2
operator|.
name|matchedLength
argument_list|()
argument_list|,
name|after2
argument_list|)
expr_stmt|;
name|index
operator|+=
name|after2
operator|.
name|length
argument_list|()
expr_stmt|;
comment|// avoid infinite loop on 0-length matches (e.g., QRegExp("[a-z]*"))
if|if
condition|(
name|rx2
operator|.
name|matchedLength
argument_list|()
operator|==
literal|0
condition|)
operator|++
name|index
expr_stmt|;
name|caretMode
operator|=
name|QRegExp
operator|::
name|CaretWontMatch
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
block|}
comment|/*         This is the simple and optimized case where we don't have         back-references.     */
while|while
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
struct|struct
block|{
name|int
name|pos
decl_stmt|;
name|int
name|length
decl_stmt|;
block|}
name|replacements
index|[
literal|2048
index|]
struct|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|adjust
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|<
literal|2047
condition|)
block|{
name|index
operator|=
name|rx2
operator|.
name|indexIn
argument_list|(
operator|*
name|this
argument_list|,
name|index
argument_list|,
name|caretMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
break|break;
name|int
name|ml
init|=
name|rx2
operator|.
name|matchedLength
argument_list|()
decl_stmt|;
name|replacements
index|[
name|pos
index|]
operator|.
name|pos
operator|=
name|index
expr_stmt|;
name|replacements
index|[
name|pos
operator|++
index|]
operator|.
name|length
operator|=
name|ml
expr_stmt|;
name|index
operator|+=
name|ml
expr_stmt|;
name|adjust
operator|+=
name|al
operator|-
name|ml
expr_stmt|;
comment|// avoid infinite loop
if|if
condition|(
operator|!
name|ml
condition|)
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pos
condition|)
break|break;
name|replacements
index|[
name|pos
index|]
operator|.
name|pos
operator|=
name|d
operator|->
name|size
expr_stmt|;
name|int
name|newlen
init|=
name|d
operator|->
name|size
operator|+
name|adjust
decl_stmt|;
comment|// to continue searching at the right position after we did
comment|// the first round of replacements
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
name|index
operator|+=
name|adjust
expr_stmt|;
name|QString
name|newstring
decl_stmt|;
name|newstring
operator|.
name|reserve
argument_list|(
name|newlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|QChar
modifier|*
name|newuc
init|=
name|newstring
operator|.
name|data
argument_list|()
decl_stmt|;
name|QChar
modifier|*
name|uc
init|=
name|newuc
decl_stmt|;
name|int
name|copystart
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|pos
condition|)
block|{
name|int
name|copyend
init|=
name|replacements
index|[
name|i
index|]
operator|.
name|pos
decl_stmt|;
name|int
name|size
init|=
name|copyend
operator|-
name|copystart
decl_stmt|;
name|memcpy
argument_list|(
name|uc
argument_list|,
name|d
operator|->
name|data
argument_list|()
operator|+
name|copystart
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|uc
operator|+=
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|uc
argument_list|,
name|after
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|al
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|uc
operator|+=
name|al
expr_stmt|;
name|copystart
operator|=
name|copyend
operator|+
name|replacements
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|uc
argument_list|,
name|d
operator|->
name|data
argument_list|()
operator|+
name|copystart
argument_list|,
operator|(
name|d
operator|->
name|size
operator|-
name|copystart
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|newstring
operator|.
name|resize
argument_list|(
name|newlen
argument_list|)
expr_stmt|;
operator|*
name|this
operator|=
name|newstring
expr_stmt|;
name|caretMode
operator|=
name|QRegExp
operator|::
name|CaretWontMatch
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGULAREXPRESSION
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_comment
comment|/*!   \overload replace()   \since 5.0    Replaces every occurrence of the regular expression \a re in the   string with \a after. Returns a reference to the string. For   example:    \snippet qstring/main.cpp 87    For regular expressions containing capturing groups,   occurrences of \b{\\1}, \b{\\2}, ..., in \a after are replaced   with the string captured by the corresponding capturing group.    \snippet qstring/main.cpp 88    \sa indexOf(), lastIndexOf(), remove(), QRegularExpression, QRegularExpressionMatch */
end_comment
begin_function
DECL|function|replace
name|QString
modifier|&
name|QString
operator|::
name|replace
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
specifier|const
name|QString
modifier|&
name|after
parameter_list|)
block|{
if|if
condition|(
operator|!
name|re
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QString::replace: invalid QRegularExpression object"
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
specifier|const
name|QString
name|copy
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|QRegularExpressionMatchIterator
name|iterator
init|=
name|re
operator|.
name|globalMatch
argument_list|(
name|copy
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
comment|// no matches at all
return|return
operator|*
name|this
return|;
name|reallocData
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
operator|+
literal|1u
argument_list|)
expr_stmt|;
name|int
name|numCaptures
init|=
name|re
operator|.
name|captureCount
argument_list|()
decl_stmt|;
comment|// 1. build the backreferences vector, holding where the backreferences
comment|// are in the replacement string
name|QVector
argument_list|<
name|QStringCapture
argument_list|>
name|backReferences
decl_stmt|;
specifier|const
name|int
name|al
init|=
name|after
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|ac
init|=
name|after
operator|.
name|unicode
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|al
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ac
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
condition|)
block|{
name|int
name|no
init|=
name|ac
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|digitValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|no
operator|>
literal|0
operator|&&
name|no
operator|<=
name|numCaptures
condition|)
block|{
name|QStringCapture
name|backReference
decl_stmt|;
name|backReference
operator|.
name|pos
operator|=
name|i
expr_stmt|;
name|backReference
operator|.
name|len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|al
operator|-
literal|2
condition|)
block|{
name|int
name|secondDigit
init|=
name|ac
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|digitValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|secondDigit
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|(
name|no
operator|*
literal|10
operator|)
operator|+
name|secondDigit
operator|)
operator|<=
name|numCaptures
condition|)
block|{
name|no
operator|=
operator|(
name|no
operator|*
literal|10
operator|)
operator|+
name|secondDigit
expr_stmt|;
operator|++
name|backReference
operator|.
name|len
expr_stmt|;
block|}
block|}
name|backReference
operator|.
name|no
operator|=
name|no
expr_stmt|;
name|backReferences
operator|.
name|append
argument_list|(
name|backReference
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// 2. iterate on the matches. For every match, copy in chunks
comment|// - the part before the match
comment|// - the after string, with the proper replacements for the backreferences
name|int
name|newLength
init|=
literal|0
decl_stmt|;
comment|// length of the new string, with all the replacements
name|int
name|lastEnd
init|=
literal|0
decl_stmt|;
name|QVector
argument_list|<
name|QStringRef
argument_list|>
name|chunks
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|QRegularExpressionMatch
name|match
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|// add the part before the match
name|len
operator|=
name|match
operator|.
name|capturedStart
argument_list|()
operator|-
name|lastEnd
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|chunks
operator|<<
name|copy
operator|.
name|midRef
argument_list|(
name|lastEnd
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newLength
operator|+=
name|len
expr_stmt|;
block|}
name|lastEnd
operator|=
literal|0
expr_stmt|;
comment|// add the after string, with replacements for the backreferences
foreach|foreach
control|(
specifier|const
name|QStringCapture
modifier|&
name|backReference
decl|,
name|backReferences
control|)
block|{
comment|// part of "after" before the backreference
name|len
operator|=
name|backReference
operator|.
name|pos
operator|-
name|lastEnd
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|chunks
operator|<<
name|after
operator|.
name|midRef
argument_list|(
name|lastEnd
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newLength
operator|+=
name|len
expr_stmt|;
block|}
comment|// backreference itself
name|len
operator|=
name|match
operator|.
name|capturedLength
argument_list|(
name|backReference
operator|.
name|no
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|chunks
operator|<<
name|copy
operator|.
name|midRef
argument_list|(
name|match
operator|.
name|capturedStart
argument_list|(
name|backReference
operator|.
name|no
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newLength
operator|+=
name|len
expr_stmt|;
block|}
name|lastEnd
operator|=
name|backReference
operator|.
name|pos
operator|+
name|backReference
operator|.
name|len
expr_stmt|;
block|}
comment|// add the last part of the after string
name|len
operator|=
name|after
operator|.
name|length
argument_list|()
operator|-
name|lastEnd
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|chunks
operator|<<
name|after
operator|.
name|midRef
argument_list|(
name|lastEnd
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newLength
operator|+=
name|len
expr_stmt|;
block|}
name|lastEnd
operator|=
name|match
operator|.
name|capturedEnd
argument_list|()
expr_stmt|;
block|}
comment|// 3. trailing string after the last match
if|if
condition|(
name|copy
operator|.
name|length
argument_list|()
operator|>
name|lastEnd
condition|)
block|{
name|chunks
operator|<<
name|copy
operator|.
name|midRef
argument_list|(
name|lastEnd
argument_list|)
expr_stmt|;
name|newLength
operator|+=
name|copy
operator|.
name|length
argument_list|()
operator|-
name|lastEnd
expr_stmt|;
block|}
comment|// 4. assemble the chunks together
name|resize
argument_list|(
name|newLength
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QChar
modifier|*
name|uc
init|=
name|data
argument_list|()
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QStringRef
modifier|&
name|chunk
decl|,
name|chunks
control|)
block|{
name|int
name|len
init|=
name|chunk
operator|.
name|length
argument_list|()
decl_stmt|;
name|memcpy
argument_list|(
name|uc
operator|+
name|i
argument_list|,
name|chunk
operator|.
name|unicode
argument_list|()
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
name|len
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BOOTSTRAPPED
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGULAREXPRESSION
end_comment
begin_comment
comment|/*!     Returns the number of (potentially overlapping) occurrences of     the string \a str in this string.      If \a cs is Qt::CaseSensitive (default), the search is     case sensitive; otherwise the search is case insensitive.      \sa contains(), indexOf() */
end_comment
begin_function
DECL|function|count
name|int
name|QString
operator|::
name|count
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_string_count
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload count()    Returns the number of occurrences of character \a ch in the string. */
end_comment
begin_function
DECL|function|count
name|int
name|QString
operator|::
name|count
parameter_list|(
name|QChar
name|ch
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_string_count
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ch
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     \overload count()     Returns the number of (potentially overlapping) occurrences of the     string reference \a str in this string.      If \a cs is Qt::CaseSensitive (default), the search is     case sensitive; otherwise the search is case insensitive.      \sa contains(), indexOf() */
end_comment
begin_function
DECL|function|count
name|int
name|QString
operator|::
name|count
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|str
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_string_count
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QString::contains(const QString&str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const      Returns \c true if this string contains an occurrence of the string     \a str; otherwise returns \c false.      If \a cs is Qt::CaseSensitive (default), the search is     case sensitive; otherwise the search is case insensitive.      Example:     \snippet qstring/main.cpp 17      \sa indexOf(), count() */
end_comment
begin_comment
comment|/*! \fn bool QString::contains(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const     \since 5.3      \overload contains()      Returns \c true if this string contains an occurrence of the latin-1 string     \a str; otherwise returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool QString::contains(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const      \overload contains()      Returns \c true if this string contains an occurrence of the     character \a ch; otherwise returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool QString::contains(const QStringRef&str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const     \since 4.8      Returns \c true if this string contains an occurrence of the string     reference \a str; otherwise returns \c false.      If \a cs is Qt::CaseSensitive (default), the search is     case sensitive; otherwise the search is case insensitive.      \sa indexOf(), count() */
end_comment
begin_comment
comment|/*! \fn bool QString::contains(const QRegExp&rx) const      \overload contains()      Returns \c true if the regular expression \a rx matches somewhere in     this string; otherwise returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool QString::contains(QRegExp&rx) const     \overload contains()     \since 4.5      Returns \c true if the regular expression \a rx matches somewhere in     this string; otherwise returns \c false.      If there is a match, the \a rx regular expression will contain the     matched captures (see QRegExp::matchedLength, QRegExp::cap). */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_comment
comment|/*!     \overload indexOf()      Returns the index position of the first match of the regular     expression \a rx in the string, searching forward from index     position \a from. Returns -1 if \a rx didn't match anywhere.      Example:      \snippet qstring/main.cpp 25 */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QString
operator|::
name|indexOf
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
name|QRegExp
name|rx2
argument_list|(
name|rx
argument_list|)
decl_stmt|;
return|return
name|rx2
operator|.
name|indexIn
argument_list|(
operator|*
name|this
argument_list|,
name|from
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload indexOf()     \since 4.5      Returns the index position of the first match of the regular     expression \a rx in the string, searching forward from index     position \a from. Returns -1 if \a rx didn't match anywhere.      If there is a match, the \a rx regular expression will contain the     matched captures (see QRegExp::matchedLength, QRegExp::cap).      Example:      \snippet qstring/main.cpp 25 */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QString
operator|::
name|indexOf
parameter_list|(
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
return|return
name|rx
operator|.
name|indexIn
argument_list|(
operator|*
name|this
argument_list|,
name|from
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload lastIndexOf()      Returns the index position of the last match of the regular     expression \a rx in the string, searching backward from index     position \a from. Returns -1 if \a rx didn't match anywhere.      Example:      \snippet qstring/main.cpp 30 */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QString
operator|::
name|lastIndexOf
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
name|QRegExp
name|rx2
argument_list|(
name|rx
argument_list|)
decl_stmt|;
return|return
name|rx2
operator|.
name|lastIndexIn
argument_list|(
operator|*
name|this
argument_list|,
name|from
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload lastIndexOf()     \since 4.5      Returns the index position of the last match of the regular     expression \a rx in the string, searching backward from index     position \a from. Returns -1 if \a rx didn't match anywhere.      If there is a match, the \a rx regular expression will contain the     matched captures (see QRegExp::matchedLength, QRegExp::cap).      Example:      \snippet qstring/main.cpp 30 */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QString
operator|::
name|lastIndexOf
parameter_list|(
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
return|return
name|rx
operator|.
name|lastIndexIn
argument_list|(
operator|*
name|this
argument_list|,
name|from
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload count()      Returns the number of times the regular expression \a rx matches     in the string.      This function counts overlapping matches, so in the example     below, there are four instances of "ana" or "ama":      \snippet qstring/main.cpp 18  */
end_comment
begin_function
DECL|function|count
name|int
name|QString
operator|::
name|count
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|)
specifier|const
block|{
name|QRegExp
name|rx2
argument_list|(
name|rx
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|len
init|=
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|index
operator|<
name|len
operator|-
literal|1
condition|)
block|{
comment|// count overlapping matches
name|index
operator|=
name|rx2
operator|.
name|indexIn
argument_list|(
operator|*
name|this
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
break|break;
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGEXP
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGULAREXPRESSION
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_comment
comment|/*!     \overload indexOf()     \since 5.0      Returns the index position of the first match of the regular     expression \a re in the string, searching forward from index     position \a from. Returns -1 if \a re didn't match anywhere.      Example:      \snippet qstring/main.cpp 93 */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QString
operator|::
name|indexOf
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
return|return
name|indexOf
argument_list|(
name|re
argument_list|,
name|from
argument_list|,
name|Q_NULLPTR
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 5.5      Returns the index position of the first match of the regular     expression \a re in the string, searching forward from index     position \a from. Returns -1 if \a re didn't match anywhere.      If the match is successful and \a rmatch is not a null pointer, it also     writes the results of the match into the QRegularExpressionMatch object     pointed to by \a rmatch.      Example:      \snippet qstring/main.cpp 97 */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QString
operator|::
name|indexOf
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
name|int
name|from
parameter_list|,
name|QRegularExpressionMatch
modifier|*
name|rmatch
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|re
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QString::indexOf: invalid QRegularExpression object"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|QRegularExpressionMatch
name|match
init|=
name|re
operator|.
name|match
argument_list|(
operator|*
name|this
argument_list|,
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|.
name|hasMatch
argument_list|()
condition|)
block|{
specifier|const
name|int
name|ret
init|=
name|match
operator|.
name|capturedStart
argument_list|()
decl_stmt|;
if|if
condition|(
name|rmatch
condition|)
operator|*
name|rmatch
operator|=
name|qMove
argument_list|(
name|match
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \overload lastIndexOf()     \since 5.0      Returns the index position of the last match of the regular     expression \a re in the string, which starts before the index     position \a from. Returns -1 if \a re didn't match anywhere.      Example:      \snippet qstring/main.cpp 94 */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QString
operator|::
name|lastIndexOf
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
return|return
name|lastIndexOf
argument_list|(
name|re
argument_list|,
name|from
argument_list|,
name|Q_NULLPTR
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 5.5      Returns the index position of the last match of the regular     expression \a re in the string, which starts before the index     position \a from. Returns -1 if \a re didn't match anywhere.      If the match is successful and \a rmatch is not a null pointer, it also     writes the results of the match into the QRegularExpressionMatch object     pointed to by \a rmatch.      Example:      \snippet qstring/main.cpp 98 */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QString
operator|::
name|lastIndexOf
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
name|int
name|from
parameter_list|,
name|QRegularExpressionMatch
modifier|*
name|rmatch
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|re
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QString::lastIndexOf: invalid QRegularExpression object"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|int
name|endpos
init|=
operator|(
name|from
operator|<
literal|0
operator|)
condition|?
operator|(
name|size
argument_list|()
operator|+
name|from
operator|+
literal|1
operator|)
else|:
operator|(
name|from
operator|+
literal|1
operator|)
decl_stmt|;
name|QRegularExpressionMatchIterator
name|iterator
init|=
name|re
operator|.
name|globalMatch
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|int
name|lastIndex
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|QRegularExpressionMatch
name|match
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|start
init|=
name|match
operator|.
name|capturedStart
argument_list|()
decl_stmt|;
if|if
condition|(
name|start
operator|<
name|endpos
condition|)
block|{
name|lastIndex
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|rmatch
condition|)
operator|*
name|rmatch
operator|=
name|qMove
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|lastIndex
return|;
block|}
end_function
begin_comment
comment|/*! \overload contains()     \since 5.0      Returns \c true if the regular expression \a re matches somewhere in     this string; otherwise returns \c false. */
end_comment
begin_function
DECL|function|contains
name|bool
name|QString
operator|::
name|contains
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|)
specifier|const
block|{
return|return
name|contains
argument_list|(
name|re
argument_list|,
name|Q_NULLPTR
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload contains()     \since 5.1      Returns \c true if the regular expression \a re matches somewhere in this     string; otherwise returns \c false.      If the match is successful and \a match is not a null pointer, it also     writes the results of the match into the QRegularExpressionMatch object     pointed to by \a match.      \sa QRegularExpression::match() */
end_comment
begin_function
DECL|function|contains
name|bool
name|QString
operator|::
name|contains
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
name|QRegularExpressionMatch
modifier|*
name|match
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|re
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QString::contains: invalid QRegularExpression object"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QRegularExpressionMatch
name|m
init|=
name|re
operator|.
name|match
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
name|bool
name|hasMatch
init|=
name|m
operator|.
name|hasMatch
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasMatch
operator|&&
name|match
condition|)
operator|*
name|match
operator|=
name|qMove
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|hasMatch
return|;
block|}
end_function
begin_comment
comment|/*!     \overload count()     \since 5.0      Returns the number of times the regular expression \a re matches     in the string.      This function counts overlapping matches, so in the example     below, there are four instances of "ana" or "ama":      \snippet qstring/main.cpp 95 */
end_comment
begin_function
DECL|function|count
name|int
name|QString
operator|::
name|count
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|re
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QString::count: invalid QRegularExpression object"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|len
init|=
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|index
operator|<
name|len
operator|-
literal|1
condition|)
block|{
name|QRegularExpressionMatch
name|match
init|=
name|re
operator|.
name|match
argument_list|(
operator|*
name|this
argument_list|,
name|index
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|match
operator|.
name|hasMatch
argument_list|()
condition|)
break|break;
name|index
operator|=
name|match
operator|.
name|capturedStart
argument_list|()
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BOOTSTRAPPED
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGULAREXPRESSION
end_comment
begin_comment
comment|/*! \fn int QString::count() const      \overload count()      Same as size(). */
end_comment
begin_comment
comment|/*!     \enum QString::SectionFlag      This enum specifies flags that can be used to affect various     aspects of the section() function's behavior with respect to     separators and empty fields.      \value SectionDefault Empty fields are counted, leading and     trailing separators are not included, and the separator is     compared case sensitively.      \value SectionSkipEmpty Treat empty fields as if they don't exist,     i.e. they are not considered as far as \e start and \e end are     concerned.      \value SectionIncludeLeadingSep Include the leading separator (if     any) in the result string.      \value SectionIncludeTrailingSep Include the trailing separator     (if any) in the result string.      \value SectionCaseInsensitiveSeps Compare the separator     case-insensitively.      \sa section() */
end_comment
begin_comment
comment|/*!     \fn QString QString::section(QChar sep, int start, int end = -1, SectionFlags flags) const      This function returns a section of the string.      This string is treated as a sequence of fields separated by the     character, \a sep. The returned string consists of the fields from     position \a start to position \a end inclusive. If \a end is not     specified, all fields from position \a start to the end of the     string are included. Fields are numbered 0, 1, 2, etc., counting     from the left, and -1, -2, etc., counting from right to left.      The \a flags argument can be used to affect some aspects of the     function's behavior, e.g. whether to be case sensitive, whether     to skip empty fields and how to deal with leading and trailing     separators; see \l{SectionFlags}.      \snippet qstring/main.cpp 52      If \a start or \a end is negative, we count fields from the right     of the string, the right-most field being -1, the one from     right-most field being -2, and so on.      \snippet qstring/main.cpp 53      \sa split() */
end_comment
begin_comment
comment|/*!     \overload section()      \snippet qstring/main.cpp 51     \snippet qstring/main.cpp 54      \sa split() */
end_comment
begin_function
DECL|function|section
name|QString
name|QString
operator|::
name|section
parameter_list|(
specifier|const
name|QString
modifier|&
name|sep
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|SectionFlags
name|flags
parameter_list|)
specifier|const
block|{
specifier|const
name|QVector
argument_list|<
name|QStringRef
argument_list|>
name|sections
init|=
name|splitRef
argument_list|(
name|sep
argument_list|,
name|KeepEmptyParts
argument_list|,
operator|(
name|flags
operator|&
name|SectionCaseInsensitiveSeps
operator|)
condition|?
name|Qt
operator|::
name|CaseInsensitive
else|:
name|Qt
operator|::
name|CaseSensitive
argument_list|)
decl_stmt|;
specifier|const
name|int
name|sectionsSize
init|=
name|sections
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SectionSkipEmpty
operator|)
condition|)
block|{
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|+=
name|sectionsSize
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|+=
name|sectionsSize
expr_stmt|;
block|}
else|else
block|{
name|int
name|skip
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|sectionsSize
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
name|sections
operator|.
name|at
argument_list|(
name|k
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|skip
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|+=
name|sectionsSize
operator|-
name|skip
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|+=
name|sectionsSize
operator|-
name|skip
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|>=
name|sectionsSize
operator|||
name|end
argument_list|<
literal|0
operator|||
name|start
argument_list|>
name|end
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|ret
decl_stmt|;
name|int
name|first_i
init|=
name|start
decl_stmt|,
name|last_i
init|=
name|end
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|,
name|i
init|=
literal|0
init|;
name|x
operator|<=
name|end
operator|&&
name|i
operator|<
name|sectionsSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QStringRef
modifier|&
name|section
init|=
name|sections
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|empty
init|=
name|section
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|>=
name|start
condition|)
block|{
if|if
condition|(
name|x
operator|==
name|start
condition|)
name|first_i
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|end
condition|)
name|last_i
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|start
operator|&&
name|i
operator|>
literal|0
condition|)
name|ret
operator|+=
name|sep
expr_stmt|;
name|ret
operator|+=
name|section
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|empty
operator|||
operator|!
operator|(
name|flags
operator|&
name|SectionSkipEmpty
operator|)
condition|)
name|x
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|SectionIncludeLeadingSep
operator|)
operator|&&
name|first_i
operator|>
literal|0
condition|)
name|ret
operator|.
name|prepend
argument_list|(
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SectionIncludeTrailingSep
operator|)
operator|&&
name|last_i
operator|<
name|sectionsSize
operator|-
literal|1
condition|)
name|ret
operator|+=
name|sep
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|QT_NO_REGEXP
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_NO_REGULAREXPRESSION
argument_list|)
operator|)
end_if
begin_class
DECL|class|qt_section_chunk
class|class
name|qt_section_chunk
block|{
public|public:
DECL|function|qt_section_chunk
name|qt_section_chunk
parameter_list|()
block|{}
DECL|function|qt_section_chunk
name|qt_section_chunk
parameter_list|(
name|int
name|l
parameter_list|,
name|QStringRef
name|s
parameter_list|)
member_init_list|:
name|length
argument_list|(
name|l
argument_list|)
member_init_list|,
name|string
argument_list|(
name|qMove
argument_list|(
name|s
argument_list|)
argument_list|)
block|{}
DECL|member|length
name|int
name|length
decl_stmt|;
DECL|member|string
name|QStringRef
name|string
decl_stmt|;
block|}
class|;
end_class
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|qt_section_chunk
argument_list|,
name|Q_MOVABLE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_function
DECL|function|extractSections
specifier|static
name|QString
name|extractSections
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|qt_section_chunk
argument_list|>
modifier|&
name|sections
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|QString
operator|::
name|SectionFlags
name|flags
parameter_list|)
block|{
specifier|const
name|int
name|sectionsSize
init|=
name|sections
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|QString
operator|::
name|SectionSkipEmpty
operator|)
condition|)
block|{
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|+=
name|sectionsSize
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|+=
name|sectionsSize
expr_stmt|;
block|}
else|else
block|{
name|int
name|skip
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|sectionsSize
condition|;
operator|++
name|k
control|)
block|{
specifier|const
name|qt_section_chunk
modifier|&
name|section
init|=
name|sections
operator|.
name|at
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|section
operator|.
name|length
operator|==
name|section
operator|.
name|string
operator|.
name|length
argument_list|()
condition|)
name|skip
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|+=
name|sectionsSize
operator|-
name|skip
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|+=
name|sectionsSize
operator|-
name|skip
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|>=
name|sectionsSize
operator|||
name|end
argument_list|<
literal|0
operator|||
name|start
argument_list|>
name|end
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|ret
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
name|int
name|first_i
init|=
name|start
decl_stmt|,
name|last_i
init|=
name|end
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|x
operator|<=
name|end
operator|&&
name|i
operator|<
name|sectionsSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|qt_section_chunk
modifier|&
name|section
init|=
name|sections
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|empty
init|=
operator|(
name|section
operator|.
name|length
operator|==
name|section
operator|.
name|string
operator|.
name|length
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|x
operator|>=
name|start
condition|)
block|{
if|if
condition|(
name|x
operator|==
name|start
condition|)
name|first_i
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|end
condition|)
name|last_i
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|start
condition|)
name|ret
operator|+=
name|section
operator|.
name|string
expr_stmt|;
else|else
name|ret
operator|+=
name|section
operator|.
name|string
operator|.
name|mid
argument_list|(
name|section
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|empty
operator|||
operator|!
operator|(
name|flags
operator|&
name|QString
operator|::
name|SectionSkipEmpty
operator|)
condition|)
name|x
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|QString
operator|::
name|SectionIncludeLeadingSep
operator|)
operator|&&
name|first_i
operator|>=
literal|0
condition|)
block|{
specifier|const
name|qt_section_chunk
modifier|&
name|section
init|=
name|sections
operator|.
name|at
argument_list|(
name|first_i
argument_list|)
decl_stmt|;
name|ret
operator|.
name|prepend
argument_list|(
name|section
operator|.
name|string
operator|.
name|left
argument_list|(
name|section
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|QString
operator|::
name|SectionIncludeTrailingSep
operator|)
operator|&&
name|last_i
operator|<
name|sectionsSize
operator|-
literal|1
condition|)
block|{
specifier|const
name|qt_section_chunk
modifier|&
name|section
init|=
name|sections
operator|.
name|at
argument_list|(
name|last_i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|ret
operator|+=
name|section
operator|.
name|string
operator|.
name|left
argument_list|(
name|section
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_comment
comment|/*!     \overload section()      This string is treated as a sequence of fields separated by the     regular expression, \a reg.      \snippet qstring/main.cpp 55      \warning Using this QRegExp version is much more expensive than     the overloaded string and character versions.      \sa split(), simplified() */
end_comment
begin_function
DECL|function|section
name|QString
name|QString
operator|::
name|section
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|reg
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|SectionFlags
name|flags
parameter_list|)
specifier|const
block|{
specifier|const
name|QChar
modifier|*
name|uc
init|=
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|uc
condition|)
return|return
name|QString
argument_list|()
return|;
name|QRegExp
name|sep
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|sep
operator|.
name|setCaseSensitivity
argument_list|(
operator|(
name|flags
operator|&
name|SectionCaseInsensitiveSeps
operator|)
condition|?
name|Qt
operator|::
name|CaseInsensitive
else|:
name|Qt
operator|::
name|CaseSensitive
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|qt_section_chunk
argument_list|>
name|sections
decl_stmt|;
name|int
name|n
init|=
name|length
argument_list|()
decl_stmt|,
name|m
init|=
literal|0
decl_stmt|,
name|last_m
init|=
literal|0
decl_stmt|,
name|last_len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|sep
operator|.
name|indexIn
argument_list|(
operator|*
name|this
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|sections
operator|.
name|append
argument_list|(
name|qt_section_chunk
argument_list|(
name|last_len
argument_list|,
name|QStringRef
argument_list|(
name|this
argument_list|,
name|last_m
argument_list|,
name|m
operator|-
name|last_m
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last_m
operator|=
name|m
expr_stmt|;
name|last_len
operator|=
name|sep
operator|.
name|matchedLength
argument_list|()
expr_stmt|;
name|m
operator|+=
name|qMax
argument_list|(
name|sep
operator|.
name|matchedLength
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sections
operator|.
name|append
argument_list|(
name|qt_section_chunk
argument_list|(
name|last_len
argument_list|,
name|QStringRef
argument_list|(
name|this
argument_list|,
name|last_m
argument_list|,
name|n
operator|-
name|last_m
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|extractSections
argument_list|(
name|sections
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGULAREXPRESSION
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_comment
comment|/*!     \overload section()     \since 5.0      This string is treated as a sequence of fields separated by the     regular expression, \a re.      \snippet qstring/main.cpp 89      \warning Using this QRegularExpression version is much more expensive than     the overloaded string and character versions.      \sa split(), simplified() */
end_comment
begin_function
DECL|function|section
name|QString
name|QString
operator|::
name|section
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|SectionFlags
name|flags
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|re
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QString::section: invalid QRegularExpression object"
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
specifier|const
name|QChar
modifier|*
name|uc
init|=
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|uc
condition|)
return|return
name|QString
argument_list|()
return|;
name|QRegularExpression
name|sep
argument_list|(
name|re
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SectionCaseInsensitiveSeps
condition|)
name|sep
operator|.
name|setPatternOptions
argument_list|(
name|sep
operator|.
name|patternOptions
argument_list|()
operator||
name|QRegularExpression
operator|::
name|CaseInsensitiveOption
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|qt_section_chunk
argument_list|>
name|sections
decl_stmt|;
name|int
name|n
init|=
name|length
argument_list|()
decl_stmt|,
name|m
init|=
literal|0
decl_stmt|,
name|last_m
init|=
literal|0
decl_stmt|,
name|last_len
init|=
literal|0
decl_stmt|;
name|QRegularExpressionMatchIterator
name|iterator
init|=
name|sep
operator|.
name|globalMatch
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|QRegularExpressionMatch
name|match
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|m
operator|=
name|match
operator|.
name|capturedStart
argument_list|()
expr_stmt|;
name|sections
operator|.
name|append
argument_list|(
name|qt_section_chunk
argument_list|(
name|last_len
argument_list|,
name|QStringRef
argument_list|(
name|this
argument_list|,
name|last_m
argument_list|,
name|m
operator|-
name|last_m
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|last_m
operator|=
name|m
expr_stmt|;
name|last_len
operator|=
name|match
operator|.
name|capturedLength
argument_list|()
expr_stmt|;
block|}
name|sections
operator|.
name|append
argument_list|(
name|qt_section_chunk
argument_list|(
name|last_len
argument_list|,
name|QStringRef
argument_list|(
name|this
argument_list|,
name|last_m
argument_list|,
name|n
operator|-
name|last_m
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|extractSections
argument_list|(
name|sections
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BOOTSTRAPPED
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGULAREXPRESSION
end_comment
begin_comment
comment|/*!     Returns a substring that contains the \a n leftmost characters     of the string.      The entire string is returned if \a n is greater than or equal     to size(), or less than zero.      \snippet qstring/main.cpp 31      \sa right(), mid(), startsWith() */
end_comment
begin_function
DECL|function|left
name|QString
name|QString
operator|::
name|left
parameter_list|(
name|int
name|n
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|uint
argument_list|(
name|n
argument_list|)
operator|>=
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
return|return
name|QString
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a substring that contains the \a n rightmost characters     of the string.      The entire string is returned if \a n is greater than or equal     to size(), or less than zero.      \snippet qstring/main.cpp 48      \sa left(), mid(), endsWith() */
end_comment
begin_function
DECL|function|right
name|QString
name|QString
operator|::
name|right
parameter_list|(
name|int
name|n
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|uint
argument_list|(
name|n
argument_list|)
operator|>=
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
return|return
name|QString
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
operator|-
name|n
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a string that contains \a n characters of this string,     starting at the specified \a position index.      Returns a null string if the \a position index exceeds the     length of the string. If there are less than \a n characters     available in the string starting at the given \a position, or if     \a n is -1 (default), the function returns all characters that     are available from the specified \a position.      Example:      \snippet qstring/main.cpp 34      \sa left(), right() */
end_comment
begin_function
DECL|function|mid
name|QString
name|QString
operator|::
name|mid
parameter_list|(
name|int
name|position
parameter_list|,
name|int
name|n
parameter_list|)
specifier|const
block|{
using|using
namespace|namespace
name|QtPrivate
namespace|;
switch|switch
condition|(
name|QContainerImplHelper
operator|::
name|mid
argument_list|(
name|d
operator|->
name|size
argument_list|,
operator|&
name|position
argument_list|,
operator|&
name|n
argument_list|)
condition|)
block|{
case|case
name|QContainerImplHelper
operator|::
name|Null
case|:
return|return
name|QString
argument_list|()
return|;
case|case
name|QContainerImplHelper
operator|::
name|Empty
case|:
block|{
name|QStringDataPtr
name|empty
init|=
block|{
name|Data
operator|::
name|allocate
operator|(
literal|0
operator|)
block|}
decl_stmt|;
return|return
name|QString
argument_list|(
name|empty
argument_list|)
return|;
block|}
case|case
name|QContainerImplHelper
operator|::
name|Full
case|:
return|return
operator|*
name|this
return|;
case|case
name|QContainerImplHelper
operator|::
name|Subset
case|:
return|return
name|QString
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|d
operator|->
name|data
argument_list|()
operator|+
name|position
argument_list|,
name|n
argument_list|)
return|;
block|}
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the string starts with \a s; otherwise returns     \c false.      If \a cs is Qt::CaseSensitive (default), the search is     case sensitive; otherwise the search is case insensitive.      \snippet qstring/main.cpp 65      \sa endsWith() */
end_comment
begin_function
DECL|function|startsWith
name|bool
name|QString
operator|::
name|startsWith
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_starts_with
argument_list|(
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|s
operator|.
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|s
operator|.
name|unicode
argument_list|()
argument_list|,
name|s
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload startsWith()  */
end_comment
begin_function
DECL|function|startsWith
name|bool
name|QString
operator|::
name|startsWith
parameter_list|(
name|QLatin1String
name|s
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_starts_with
argument_list|(
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|s
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload startsWith()    Returns \c true if the string starts with \a c; otherwise returns   \c false. */
end_comment
begin_function
DECL|function|startsWith
name|bool
name|QString
operator|::
name|startsWith
parameter_list|(
name|QChar
name|c
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|size
operator|&&
operator|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|?
name|d
operator|->
name|data
argument_list|()
index|[
literal|0
index|]
operator|==
name|c
else|:
name|foldCase
argument_list|(
name|d
operator|->
name|data
argument_list|()
index|[
literal|0
index|]
argument_list|)
operator|==
name|foldCase
argument_list|(
name|c
operator|.
name|unicode
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     \overload     Returns \c true if the string starts with the string reference \a s;     otherwise returns \c false.      If \a cs is Qt::CaseSensitive (default), the search is case     sensitive; otherwise the search is case insensitive.      \sa endsWith() */
end_comment
begin_function
DECL|function|startsWith
name|bool
name|QString
operator|::
name|startsWith
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_starts_with
argument_list|(
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|s
operator|.
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|s
operator|.
name|unicode
argument_list|()
argument_list|,
name|s
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the string ends with \a s; otherwise returns     \c false.      If \a cs is Qt::CaseSensitive (default), the search is case     sensitive; otherwise the search is case insensitive.      \snippet qstring/main.cpp 20      \sa startsWith() */
end_comment
begin_function
DECL|function|endsWith
name|bool
name|QString
operator|::
name|endsWith
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_ends_with
argument_list|(
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|s
operator|.
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|s
operator|.
name|unicode
argument_list|()
argument_list|,
name|s
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     \overload endsWith()     Returns \c true if the string ends with the string reference \a s;     otherwise returns \c false.      If \a cs is Qt::CaseSensitive (default), the search is case     sensitive; otherwise the search is case insensitive.      \sa startsWith() */
end_comment
begin_function
DECL|function|endsWith
name|bool
name|QString
operator|::
name|endsWith
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|s
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_ends_with
argument_list|(
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|s
operator|.
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|s
operator|.
name|unicode
argument_list|()
argument_list|,
name|s
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload endsWith() */
end_comment
begin_function
DECL|function|endsWith
name|bool
name|QString
operator|::
name|endsWith
parameter_list|(
name|QLatin1String
name|s
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_ends_with
argument_list|(
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|s
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns \c true if the string ends with \a c; otherwise returns   \c false.    \overload endsWith()  */
end_comment
begin_function
DECL|function|endsWith
name|bool
name|QString
operator|::
name|endsWith
parameter_list|(
name|QChar
name|c
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|size
operator|&&
operator|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|?
name|d
operator|->
name|data
argument_list|()
index|[
name|d
operator|->
name|size
operator|-
literal|1
index|]
operator|==
name|c
else|:
name|foldCase
argument_list|(
name|d
operator|->
name|data
argument_list|()
index|[
name|d
operator|->
name|size
operator|-
literal|1
index|]
argument_list|)
operator|==
name|foldCase
argument_list|(
name|c
operator|.
name|unicode
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|toLatin1_helper
name|QByteArray
name|QString
operator|::
name|toLatin1_helper
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
block|{
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|string
operator|.
name|isNull
argument_list|()
argument_list|)
condition|)
return|return
name|QByteArray
argument_list|()
return|;
return|return
name|toLatin1_helper
argument_list|(
name|string
operator|.
name|constData
argument_list|()
argument_list|,
name|string
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|toLatin1_helper
name|QByteArray
name|QString
operator|::
name|toLatin1_helper
parameter_list|(
specifier|const
name|QChar
modifier|*
name|data
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|QByteArray
name|ba
argument_list|(
name|length
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
comment|// since we own the only copy, we're going to const_cast the constData;
comment|// that avoids an unnecessary call to detach() and expansion code that will never get used
name|qt_to_latin1
argument_list|(
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|ba
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|ba
return|;
block|}
end_function
begin_function
DECL|function|toLatin1_helper_inplace
name|QByteArray
name|QString
operator|::
name|toLatin1_helper_inplace
parameter_list|(
name|QString
modifier|&
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|s
operator|.
name|isDetached
argument_list|()
condition|)
return|return
name|s
operator|.
name|toLatin1
argument_list|()
return|;
comment|// We can return our own buffer to the caller.
comment|// Conversion to Latin-1 always shrinks the buffer by half.
specifier|const
name|ushort
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|s
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|uint
name|length
init|=
name|s
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Swap the d pointers.
comment|// Kids, avert your eyes. Don't try this at home.
name|QArrayData
modifier|*
name|ba_d
init|=
name|s
operator|.
name|d
decl_stmt|;
comment|// multiply the allocated capacity by sizeof(ushort)
name|ba_d
operator|->
name|alloc
operator|*=
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
expr_stmt|;
comment|// reset ourselves to QString()
name|s
operator|.
name|d
operator|=
name|QString
argument_list|()
operator|.
name|d
expr_stmt|;
comment|// do the in-place conversion
name|uchar
modifier|*
name|dst
init|=
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|ba_d
operator|->
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|qt_to_latin1
argument_list|(
name|dst
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|dst
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|QByteArrayDataPtr
name|badptr
init|=
block|{
name|ba_d
block|}
decl_stmt|;
return|return
name|QByteArray
argument_list|(
name|badptr
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray QString::toLatin1() const      Returns a Latin-1 representation of the string as a QByteArray.      The returned byte array is undefined if the string contains non-Latin1     characters. Those characters may be suppressed or replaced with a     question mark.      \sa fromLatin1(), toUtf8(), toLocal8Bit(), QTextCodec */
end_comment
begin_comment
comment|/*!     \fn QByteArray QString::toAscii() const     \deprecated     Returns an 8-bit representation of the string as a QByteArray.      This function does the same as toLatin1().      Note that, despite the name, this function does not necessarily return an US-ASCII     (ANSI X3.4-1986) string and its result may not be US-ASCII compatible.      \sa fromAscii(), toLatin1(), toUtf8(), toLocal8Bit(), QTextCodec */
end_comment
begin_comment
comment|/*!     \fn QByteArray QString::toLocal8Bit() const      Returns the local 8-bit representation of the string as a     QByteArray. The returned byte array is undefined if the string     contains characters not supported by the local 8-bit encoding.      QTextCodec::codecForLocale() is used to perform the conversion from     Unicode. If the locale encoding could not be determined, this function     does the same as toLatin1().      If this string contains any characters that cannot be encoded in the     locale, the returned byte array is undefined. Those characters may be     suppressed or replaced by another.      \sa fromLocal8Bit(), toLatin1(), toUtf8(), QTextCodec */
end_comment
begin_function
DECL|function|toLocal8Bit_helper
name|QByteArray
name|QString
operator|::
name|toLocal8Bit_helper
parameter_list|(
specifier|const
name|QChar
modifier|*
name|data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|QTextCodec
modifier|*
name|localeCodec
init|=
name|QTextCodec
operator|::
name|codecForLocale
argument_list|()
decl_stmt|;
if|if
condition|(
name|localeCodec
condition|)
return|return
name|localeCodec
operator|->
name|fromUnicode
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
return|;
endif|#
directive|endif
comment|// QT_NO_TEXTCODEC
return|return
name|toLatin1_helper
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray QString::toUtf8() const      Returns a UTF-8 representation of the string as a QByteArray.      UTF-8 is a Unicode codec and can represent all characters in a Unicode     string like QString.      \sa fromUtf8(), toLatin1(), toLocal8Bit(), QTextCodec */
end_comment
begin_function
DECL|function|toUtf8_helper
name|QByteArray
name|QString
operator|::
name|toUtf8_helper
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QByteArray
argument_list|()
return|;
return|return
name|QUtf8
operator|::
name|convertFromUnicode
argument_list|(
name|str
operator|.
name|constData
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns a UCS-4/UTF-32 representation of the string as a QVector<uint>.      UCS-4 is a Unicode codec and therefore it is lossless. All characters from     this string will be encoded in UCS-4. Any invalid sequence of code units in     this string is replaced by the Unicode's replacement character     (QChar::ReplacementCharacter, which corresponds to \c{U+FFFD}).      The returned vector is not NUL terminated.      \sa fromUtf8(), toUtf8(), toLatin1(), toLocal8Bit(), QTextCodec, fromUcs4(), toWCharArray() */
end_comment
begin_function
DECL|function|toUcs4
name|QVector
argument_list|<
name|uint
argument_list|>
name|QString
operator|::
name|toUcs4
parameter_list|()
specifier|const
block|{
name|QVector
argument_list|<
name|uint
argument_list|>
name|v
argument_list|(
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|uint
modifier|*
name|a
init|=
name|v
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|toUcs4_helper
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|length
argument_list|()
argument_list|,
name|a
argument_list|)
decl_stmt|;
name|v
operator|.
name|resize
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function
begin_function
DECL|function|fromLatin1_helper
name|QString
operator|::
name|Data
modifier|*
name|QString
operator|::
name|fromLatin1_helper
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|Data
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
block|{
name|d
operator|=
name|Data
operator|::
name|sharedNull
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|0
operator|||
operator|(
operator|!
operator|*
name|str
operator|&&
name|size
operator|<
literal|0
operator|)
condition|)
block|{
name|d
operator|=
name|Data
operator|::
name|allocate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|size
operator|=
name|qstrlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|d
operator|=
name|Data
operator|::
name|allocate
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|d
operator|->
name|data
argument_list|()
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ushort
modifier|*
name|dst
init|=
name|d
operator|->
name|data
argument_list|()
decl_stmt|;
name|qt_from_latin1
argument_list|(
name|dst
argument_list|,
name|str
argument_list|,
name|uint
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|fromAscii_helper
name|QString
operator|::
name|Data
modifier|*
name|QString
operator|::
name|fromAscii_helper
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|QString
name|s
init|=
name|fromUtf8
argument_list|(
name|str
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|s
operator|.
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
return|return
name|s
operator|.
name|d
return|;
block|}
end_function
begin_comment
comment|/*! \fn QString QString::fromLatin1(const char *str, int size)     Returns a QString initialized with the first \a size characters     of the Latin-1 string \a str.      If \a size is -1 (default), it is taken to be strlen(\a     str).      \sa toLatin1(), fromUtf8(), fromLocal8Bit() */
end_comment
begin_comment
comment|/*!     \fn QString QString::fromLatin1(const QByteArray&str)     \overload     \since 5.0      Returns a QString initialized with the Latin-1 string \a str. */
end_comment
begin_comment
comment|/*! \fn QString QString::fromLocal8Bit(const char *str, int size)     Returns a QString initialized with the first \a size characters     of the 8-bit string \a str.      If \a size is -1 (default), it is taken to be strlen(\a     str).      QTextCodec::codecForLocale() is used to perform the conversion.      \sa toLocal8Bit(), fromLatin1(), fromUtf8() */
end_comment
begin_comment
comment|/*!     \fn QString QString::fromLocal8Bit(const QByteArray&str)     \overload     \since 5.0      Returns a QString initialized with the 8-bit string \a str. */
end_comment
begin_function
DECL|function|fromLocal8Bit_helper
name|QString
name|QString
operator|::
name|fromLocal8Bit_helper
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
operator|(
operator|!
operator|*
name|str
operator|&&
name|size
operator|<
literal|0
operator|)
condition|)
block|{
name|QStringDataPtr
name|empty
init|=
block|{
name|Data
operator|::
name|allocate
operator|(
literal|0
operator|)
block|}
decl_stmt|;
return|return
name|QString
argument_list|(
name|empty
argument_list|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_TEXTCODEC
argument_list|)
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|size
operator|=
name|qstrlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|QTextCodec
modifier|*
name|codec
init|=
name|QTextCodec
operator|::
name|codecForLocale
argument_list|()
decl_stmt|;
if|if
condition|(
name|codec
condition|)
return|return
name|codec
operator|->
name|toUnicode
argument_list|(
name|str
argument_list|,
name|size
argument_list|)
return|;
endif|#
directive|endif
comment|// !QT_NO_TEXTCODEC
return|return
name|fromLatin1
argument_list|(
name|str
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn QString QString::fromAscii(const char *, int size);     \deprecated      Returns a QString initialized with the first \a size characters     from the string \a str.      If \a size is -1 (default), it is taken to be strlen(\a     str).      This function does the same as fromLatin1().      \sa toAscii(), fromLatin1(), fromUtf8(), fromLocal8Bit() */
end_comment
begin_comment
comment|/*!     \fn QString QString::fromAscii(const QByteArray&str)     \deprecated     \overload     \since 5.0      Returns a QString initialized with the string \a str. */
end_comment
begin_comment
comment|/*! \fn QString QString::fromUtf8(const char *str, int size)     Returns a QString initialized with the first \a size bytes     of the UTF-8 string \a str.      If \a size is -1 (default), it is taken to be strlen(\a     str).      UTF-8 is a Unicode codec and can represent all characters in a Unicode     string like QString. However, invalid sequences are possible with UTF-8     and, if any such are found, they will be replaced with one or more     "replacement characters", or suppressed. These include non-Unicode     sequences, non-characters, overlong sequences or surrogate codepoints     encoded into UTF-8.      This function can be used to process incoming data incrementally as long as     all UTF-8 characters are terminated within the incoming data. Any     unterminated characters at the end of the string will be replaced or     suppressed. In order to do stateful decoding, please use \l QTextDecoder.      \sa toUtf8(), fromLatin1(), fromLocal8Bit() */
end_comment
begin_comment
comment|/*!     \fn QString QString::fromUtf8(const QByteArray&str)     \overload     \since 5.0      Returns a QString initialized with the UTF-8 string \a str. */
end_comment
begin_function
DECL|function|fromUtf8_helper
name|QString
name|QString
operator|::
name|fromUtf8_helper
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|QString
argument_list|()
return|;
name|Q_ASSERT
argument_list|(
name|size
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|QUtf8
operator|::
name|convertToUnicode
argument_list|(
name|str
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QString initialized with the first \a size characters     of the Unicode string \a unicode (ISO-10646-UTF-16 encoded).      If \a size is -1 (default), \a unicode must be terminated     with a 0.      This function checks for a Byte Order Mark (BOM). If it is missing,     host byte order is assumed.      This function is slow compared to the other Unicode conversions.     Use QString(const QChar *, int) or QString(const QChar *) if possible.      QString makes a deep copy of the Unicode data.      \sa utf16(), setUtf16(), fromStdU16String() */
end_comment
begin_function
DECL|function|fromUtf16
name|QString
name|QString
operator|::
name|fromUtf16
parameter_list|(
specifier|const
name|ushort
modifier|*
name|unicode
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
operator|!
name|unicode
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|unicode
index|[
name|size
index|]
operator|!=
literal|0
condition|)
operator|++
name|size
expr_stmt|;
block|}
return|return
name|QUtf16
operator|::
name|convertToUnicode
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|unicode
argument_list|,
name|size
operator|*
literal|2
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns a QString initialized with the first \a size characters     of the Unicode string \a unicode (ISO-10646-UCS-4 encoded).      If \a size is -1 (default), \a unicode must be terminated     with a 0.      \sa toUcs4(), fromUtf16(), utf16(), setUtf16(), fromWCharArray(), fromStdU32String() */
end_comment
begin_function
DECL|function|fromUcs4
name|QString
name|QString
operator|::
name|fromUcs4
parameter_list|(
specifier|const
name|uint
modifier|*
name|unicode
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
operator|!
name|unicode
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|unicode
index|[
name|size
index|]
operator|!=
literal|0
condition|)
operator|++
name|size
expr_stmt|;
block|}
return|return
name|QUtf32
operator|::
name|convertToUnicode
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|unicode
argument_list|,
name|size
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Resizes the string to \a size characters and copies \a unicode     into the string.      If \a unicode is 0, nothing is copied, but the string is still     resized to \a size.      \sa unicode(), setUtf16() */
end_comment
begin_function
DECL|function|setUnicode
name|QString
modifier|&
name|QString
operator|::
name|setUnicode
parameter_list|(
specifier|const
name|QChar
modifier|*
name|unicode
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|resize
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unicode
operator|&&
name|size
condition|)
name|memcpy
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|unicode
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString&QString::setUtf16(const ushort *unicode, int size)      Resizes the string to \a size characters and copies \a unicode     into the string.      If \a unicode is 0, nothing is copied, but the string is still     resized to \a size.      Note that unlike fromUtf16(), this function does not consider BOMs and     possibly differing byte ordering.      \sa utf16(), setUnicode() */
end_comment
begin_comment
comment|/*!     \fn QString QString::simplified() const      Returns a string that has whitespace removed from the start     and the end, and that has each sequence of internal whitespace     replaced with a single space.      Whitespace means any character for which QChar::isSpace() returns     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',     '\\f', '\\r', and ' '.      Example:      \snippet qstring/main.cpp 57      \sa trimmed() */
end_comment
begin_function
DECL|function|simplified_helper
name|QString
name|QString
operator|::
name|simplified_helper
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
return|return
name|QStringAlgorithms
argument_list|<
specifier|const
name|QString
argument_list|>
operator|::
name|simplified_helper
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|simplified_helper
name|QString
name|QString
operator|::
name|simplified_helper
parameter_list|(
name|QString
modifier|&
name|str
parameter_list|)
block|{
return|return
name|QStringAlgorithms
argument_list|<
name|QString
argument_list|>
operator|::
name|simplified_helper
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QString::trimmed() const      Returns a string that has whitespace removed from the start and     the end.      Whitespace means any character for which QChar::isSpace() returns     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',     '\\f', '\\r', and ' '.      Example:      \snippet qstring/main.cpp 82      Unlike simplified(), trimmed() leaves internal whitespace alone.      \sa simplified() */
end_comment
begin_function
DECL|function|trimmed_helper
name|QString
name|QString
operator|::
name|trimmed_helper
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
return|return
name|QStringAlgorithms
argument_list|<
specifier|const
name|QString
argument_list|>
operator|::
name|trimmed_helper
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|trimmed_helper
name|QString
name|QString
operator|::
name|trimmed_helper
parameter_list|(
name|QString
modifier|&
name|str
parameter_list|)
block|{
return|return
name|QStringAlgorithms
argument_list|<
name|QString
argument_list|>
operator|::
name|trimmed_helper
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn const QChar QString::at(int position) const      Returns the character at the given index \a position in the     string.      The \a position must be a valid index position in the string     (i.e., 0<= \a position< size()).      \sa operator[]() */
end_comment
begin_comment
comment|/*!     \fn QCharRef QString::operator[](int position)      Returns the character at the specified \a position in the string as a     modifiable reference.      Example:      \snippet qstring/main.cpp 85      The return value is of type QCharRef, a helper class for QString.     When you get an object of type QCharRef, you can use it as if it     were a QChar&. If you assign to it, the assignment will apply to     the character in the QString from which you got the reference.      \sa at() */
end_comment
begin_comment
comment|/*!     \fn const QChar QString::operator[](int position) const      \overload operator[]() */
end_comment
begin_comment
comment|/*! \fn QCharRef QString::operator[](uint position)  \overload operator[]()  Returns the character at the specified \a position in the string as a modifiable reference. */
end_comment
begin_comment
comment|/*! \fn const QChar QString::operator[](uint position) const     Equivalent to \c at(position). \overload operator[]() */
end_comment
begin_comment
comment|/*!     \fn void QString::truncate(int position)      Truncates the string at the given \a position index.      If the specified \a position index is beyond the end of the     string, nothing happens.      Example:      \snippet qstring/main.cpp 83      If \a position is negative, it is equivalent to passing zero.      \sa chop(), resize(), left(), QStringRef::truncate() */
end_comment
begin_function
DECL|function|truncate
name|void
name|QString
operator|::
name|truncate
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|<
name|d
operator|->
name|size
condition|)
name|resize
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes \a n characters from the end of the string.      If \a n is greater than or equal to size(), the result is an     empty string.      Example:     \snippet qstring/main.cpp 15      If you want to remove characters from the \e beginning of the     string, use remove() instead.      \sa truncate(), resize(), remove() */
end_comment
begin_function
DECL|function|chop
name|void
name|QString
operator|::
name|chop
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|resize
argument_list|(
name|d
operator|->
name|size
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets every character in the string to character \a ch. If \a size     is different from -1 (default), the string is resized to \a     size beforehand.      Example:      \snippet qstring/main.cpp 21      \sa resize() */
end_comment
begin_function
DECL|function|fill
name|QString
modifier|&
name|QString
operator|::
name|fill
parameter_list|(
name|QChar
name|ch
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|resize
argument_list|(
name|size
operator|<
literal|0
condition|?
name|d
operator|->
name|size
else|:
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|size
condition|)
block|{
name|QChar
modifier|*
name|i
init|=
operator|(
name|QChar
operator|*
operator|)
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
decl_stmt|;
name|QChar
modifier|*
name|b
init|=
operator|(
name|QChar
operator|*
operator|)
name|d
operator|->
name|data
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|!=
name|b
condition|)
operator|*
operator|--
name|i
operator|=
name|ch
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QString::length() const      Returns the number of characters in this string.  Equivalent to     size().      \sa resize() */
end_comment
begin_comment
comment|/*!     \fn int QString::size() const      Returns the number of characters in this string.      The last character in the string is at position size() - 1. In     addition, QString ensures that the character at position size()     is always '\\0', so that you can use the return value of data()     and constData() as arguments to functions that expect     '\\0'-terminated strings.      Example:      \snippet qstring/main.cpp 58      \sa isEmpty(), resize() */
end_comment
begin_comment
comment|/*! \fn bool QString::isNull() const      Returns \c true if this string is null; otherwise returns \c false.      Example:      \snippet qstring/main.cpp 28      Qt makes a distinction between null strings and empty strings for     historical reasons. For most applications, what matters is     whether or not a string contains any data, and this can be     determined using the isEmpty() function.      \sa isEmpty() */
end_comment
begin_comment
comment|/*! \fn bool QString::isEmpty() const      Returns \c true if the string has no characters; otherwise returns     \c false.      Example:      \snippet qstring/main.cpp 27      \sa size() */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator+=(const QString&other)      Appends the string \a other onto the end of this string and     returns a reference to this string.      Example:      \snippet qstring/main.cpp 84      This operation is typically very fast (\l{constant time}),     because QString preallocates extra space at the end of the string     data so it can grow without reallocating the entire string each     time.      \sa append(), prepend() */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator+=(QLatin1String str)      \overload operator+=()      Appends the Latin-1 string \a str to this string. */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator+=(const QByteArray&ba)      \overload operator+=()      Appends the byte array \a ba to this string. The byte array is converted     to Unicode using the fromUtf8() function. If any NUL characters ('\\0')     are embedded in the \a ba byte array, they will be included in the     transformation.      You can disable this function by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator+=(const char *str)      \overload operator+=()      Appends the string \a str to this string. The const char pointer     is converted to Unicode using the fromUtf8() function.      You can disable this function by defining \c QT_NO_CAST_FROM_ASCII     when you compile your applications. This can be useful if you want     to ensure that all user-visible strings go through QObject::tr(),     for example. */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator+=(const QStringRef&str)      \overload operator+=()      Appends the string section referenced by \a str to this string. */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator+=(char ch)      \overload operator+=()      Appends the character \a ch to this string. Note that the character is     converted to Unicode using the fromLatin1() function, unlike other 8-bit     functions that operate on UTF-8 data.      You can disable this function by defining \c QT_NO_CAST_FROM_ASCII     when you compile your applications. This can be useful if you want     to ensure that all user-visible strings go through QObject::tr(),     for example. */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator+=(QChar ch)      \overload operator+=()      Appends the character \a ch to the string. */
end_comment
begin_comment
comment|/*! \fn QString&QString::operator+=(QChar::SpecialCharacter c)      \overload operator+=()      \internal */
end_comment
begin_comment
comment|/*!     \fn bool operator==(const char *s1, const QString&s2)      \overload  operator==()     \relates QString      Returns \c true if \a s1 is equal to \a s2; otherwise returns \c false.     Note that no string is equal to \a s1 being 0.      Equivalent to \c {s1 != 0&& compare(s1, s2) == 0}.      \sa QString::compare() */
end_comment
begin_comment
comment|/*!     \fn bool operator!=(const char *s1, const QString&s2)     \relates QString      Returns \c true if \a s1 is not equal to \a s2; otherwise returns     \c false.      For \a s1 != 0, this is equivalent to \c {compare(} \a s1, \a s2     \c {) != 0}. Note that no string is equal to \a s1 being 0.      \sa QString::compare() */
end_comment
begin_comment
comment|/*!     \fn bool operator<(const char *s1, const QString&s2)     \relates QString      Returns \c true if \a s1 is lexically less than \a s2; otherwise     returns \c false.  For \a s1 != 0, this is equivalent to \c     {compare(s1, s2)< 0}.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings using the     QString::localeAwareCompare() function.      \sa QString::compare() */
end_comment
begin_comment
comment|/*!     \fn bool operator<=(const char *s1, const QString&s2)     \relates QString      Returns \c true if \a s1 is lexically less than or equal to \a s2;     otherwise returns \c false.  For \a s1 != 0, this is equivalent to \c     {compare(s1, s2)<= 0}.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings with     QString::localeAwareCompare().      \sa QString::compare() */
end_comment
begin_comment
comment|/*!     \fn bool operator>(const char *s1, const QString&s2)     \relates QString      Returns \c true if \a s1 is lexically greater than \a s2; otherwise     returns \c false.  Equivalent to \c {compare(s1, s2)> 0}.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings using the     QString::localeAwareCompare() function.      \sa QString::compare() */
end_comment
begin_comment
comment|/*!     \fn bool operator>=(const char *s1, const QString&s2)     \relates QString      Returns \c true if \a s1 is lexically greater than or equal to \a s2;     otherwise returns \c false.  For \a s1 != 0, this is equivalent to \c     {compare(s1, s2)>= 0}.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings using the     QString::localeAwareCompare() function. */
end_comment
begin_comment
comment|/*!     \fn const QString operator+(const QString&s1, const QString&s2)     \relates QString      Returns a string which is the result of concatenating \a s1 and \a     s2. */
end_comment
begin_comment
comment|/*!     \fn const QString operator+(const QString&s1, const char *s2)     \relates QString      Returns a string which is the result of concatenating \a s1 and \a     s2 (\a s2 is converted to Unicode using the QString::fromUtf8()     function).      \sa QString::fromUtf8() */
end_comment
begin_comment
comment|/*!     \fn const QString operator+(const char *s1, const QString&s2)     \relates QString      Returns a string which is the result of concatenating \a s1 and \a     s2 (\a s1 is converted to Unicode using the QString::fromUtf8()     function).      \sa QString::fromUtf8() */
end_comment
begin_comment
comment|/*!     \fn const QString operator+(const QString&s, char ch)     \relates QString      Returns a string which is the result of concatenating the string     \a s and the character \a ch. */
end_comment
begin_comment
comment|/*!     \fn const QString operator+(char ch, const QString&s)     \relates QString      Returns a string which is the result of concatenating the     character \a ch and the string \a s. */
end_comment
begin_comment
comment|/*!     \fn int QString::compare(const QString&s1, const QString&s2, Qt::CaseSensitivity cs)     \since 4.2      Compares \a s1 with \a s2 and returns an integer less than, equal     to, or greater than zero if \a s1 is less than, equal to, or     greater than \a s2.      If \a cs is Qt::CaseSensitive, the comparison is case sensitive;     otherwise the comparison is case insensitive.      Case sensitive comparison is based exclusively on the numeric     Unicode values of the characters and is very fast, but is not what     a human would expect.  Consider sorting user-visible strings with     localeAwareCompare().      \snippet qstring/main.cpp 16      \sa operator==(), operator<(), operator>() */
end_comment
begin_comment
comment|/*!     \fn int QString::compare(const QString&s1, QLatin1String s2, Qt::CaseSensitivity cs)     \since 4.2     \overload compare()      Performs a comparison of \a s1 and \a s2, using the case     sensitivity setting \a cs. */
end_comment
begin_comment
comment|/*!     \fn int QString::compare(QLatin1String s1, const QString&s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)      \since 4.2     \overload compare()      Performs a comparison of \a s1 and \a s2, using the case     sensitivity setting \a cs. */
end_comment
begin_comment
comment|/*!     \overload compare()     \since 4.2      Lexically compares this string with the \a other string and     returns an integer less than, equal to, or greater than zero if     this string is less than, equal to, or greater than the other     string.      Same as compare(*this, \a other, \a cs). */
end_comment
begin_function
DECL|function|compare
name|int
name|QString
operator|::
name|compare
parameter_list|(
specifier|const
name|QString
modifier|&
name|other
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
return|return
name|ucstrcmp
argument_list|(
name|constData
argument_list|()
argument_list|,
name|length
argument_list|()
argument_list|,
name|other
operator|.
name|constData
argument_list|()
argument_list|,
name|other
operator|.
name|length
argument_list|()
argument_list|)
return|;
return|return
name|ucstricmp
argument_list|(
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|data
argument_list|()
operator|+
name|d
operator|->
name|size
argument_list|,
name|other
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|other
operator|.
name|d
operator|->
name|data
argument_list|()
operator|+
name|other
operator|.
name|d
operator|->
name|size
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 4.5 */
end_comment
begin_function
DECL|function|compare_helper
name|int
name|QString
operator|::
name|compare_helper
parameter_list|(
specifier|const
name|QChar
modifier|*
name|data1
parameter_list|,
name|int
name|length1
parameter_list|,
specifier|const
name|QChar
modifier|*
name|data2
parameter_list|,
name|int
name|length2
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
return|return
name|ucstrcmp
argument_list|(
name|data1
argument_list|,
name|length1
argument_list|,
name|data2
argument_list|,
name|length2
argument_list|)
return|;
specifier|const
name|ushort
modifier|*
name|s1
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|data1
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|s2
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|data2
argument_list|)
decl_stmt|;
return|return
name|ucstricmp
argument_list|(
name|s1
argument_list|,
name|s1
operator|+
name|length1
argument_list|,
name|s2
argument_list|,
name|s2
operator|+
name|length2
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload compare()     \since 4.2      Same as compare(*this, \a other, \a cs). */
end_comment
begin_function
DECL|function|compare
name|int
name|QString
operator|::
name|compare
parameter_list|(
name|QLatin1String
name|other
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|compare_helper
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|length
argument_list|()
argument_list|,
name|other
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \fn int QString::compare(const QStringRef&ref, Qt::CaseSensitivity cs = Qt::CaseSensitive) const   \overload compare()    Compares the string reference, \a ref, with the string and returns   an integer less than, equal to, or greater than zero if the string   is less than, equal to, or greater than \a ref. */
end_comment
begin_comment
comment|/*!     \internal     \since 5.0 */
end_comment
begin_function
DECL|function|compare_helper
name|int
name|QString
operator|::
name|compare_helper
parameter_list|(
specifier|const
name|QChar
modifier|*
name|data1
parameter_list|,
name|int
name|length1
parameter_list|,
specifier|const
name|char
modifier|*
name|data2
parameter_list|,
name|int
name|length2
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
comment|// ### optimize me
specifier|const
name|QString
name|s2
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|data2
argument_list|,
name|length2
operator|==
operator|-
literal|1
condition|?
operator|(
name|data2
condition|?
name|int
argument_list|(
name|strlen
argument_list|(
name|data2
argument_list|)
argument_list|)
else|:
operator|-
literal|1
operator|)
else|:
name|length2
argument_list|)
decl_stmt|;
return|return
name|compare_helper
argument_list|(
name|data1
argument_list|,
name|length1
argument_list|,
name|s2
operator|.
name|constData
argument_list|()
argument_list|,
name|s2
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \fn int QString::compare(const QString&s1, const QStringRef&s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)   \overload compare() */
end_comment
begin_comment
comment|/*!     \internal     \since 4.5 */
end_comment
begin_function
DECL|function|compare_helper
name|int
name|QString
operator|::
name|compare_helper
parameter_list|(
specifier|const
name|QChar
modifier|*
name|data1
parameter_list|,
name|int
name|length1
parameter_list|,
name|QLatin1String
name|s2
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
specifier|const
name|ushort
modifier|*
name|uc
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|data1
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|uce
init|=
name|uc
operator|+
name|length1
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|c
init|=
operator|(
name|uchar
operator|*
operator|)
name|s2
operator|.
name|latin1
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|length1
return|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
return|return
name|ucstrcmp
argument_list|(
name|data1
argument_list|,
name|length1
argument_list|,
name|c
argument_list|,
name|s2
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|ucstricmp
argument_list|(
name|uc
argument_list|,
name|uce
argument_list|,
name|c
argument_list|,
name|c
operator|+
name|s2
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn int QString::localeAwareCompare(const QString& s1, const QString& s2)      Compares \a s1 with \a s2 and returns an integer less than, equal     to, or greater than zero if \a s1 is less than, equal to, or     greater than \a s2.      The comparison is performed in a locale- and also     platform-dependent manner. Use this function to present sorted     lists of strings to the user.      On OS X and iOS this function compares according the     "Order for sorted lists" setting in the International preferences panel.      \sa compare(), QLocale */
end_comment
begin_comment
comment|/*!     \fn int QString::localeAwareCompare(const QStringRef&other) const     \since 4.5     \overload localeAwareCompare()      Compares this string with the \a other string and returns an     integer less than, equal to, or greater than zero if this string     is less than, equal to, or greater than the \a other string.      The comparison is performed in a locale- and also     platform-dependent manner. Use this function to present sorted     lists of strings to the user.      Same as \c {localeAwareCompare(*this, other)}. */
end_comment
begin_comment
comment|/*!     \fn int QString::localeAwareCompare(const QString&s1, const QStringRef&s2)     \since 4.5     \overload localeAwareCompare()      Compares \a s1 with \a s2 and returns an integer less than, equal     to, or greater than zero if \a s1 is less than, equal to, or     greater than \a s2.      The comparison is performed in a locale- and also     platform-dependent manner. Use this function to present sorted     lists of strings to the user. */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CSTR_LESS_THAN
argument_list|)
end_if
begin_define
DECL|macro|CSTR_LESS_THAN
define|#
directive|define
name|CSTR_LESS_THAN
value|1
end_define
begin_define
DECL|macro|CSTR_EQUAL
define|#
directive|define
name|CSTR_EQUAL
value|2
end_define
begin_define
DECL|macro|CSTR_GREATER_THAN
define|#
directive|define
name|CSTR_GREATER_THAN
value|3
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \overload localeAwareCompare()      Compares this string with the \a other string and returns an     integer less than, equal to, or greater than zero if this string     is less than, equal to, or greater than the \a other string.      The comparison is performed in a locale- and also     platform-dependent manner. Use this function to present sorted     lists of strings to the user.      Same as \c {localeAwareCompare(*this, other)}. */
end_comment
begin_function
DECL|function|localeAwareCompare
name|int
name|QString
operator|::
name|localeAwareCompare
parameter_list|(
specifier|const
name|QString
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|localeAwareCompare_helper
argument_list|(
name|constData
argument_list|()
argument_list|,
name|length
argument_list|()
argument_list|,
name|other
operator|.
name|constData
argument_list|()
argument_list|,
name|other
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_ICU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QThreadStorage<QCollator>
argument_list|,
argument|defaultCollator
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal     \since 4.5 */
end_comment
begin_function
DECL|function|localeAwareCompare_helper
name|int
name|QString
operator|::
name|localeAwareCompare_helper
parameter_list|(
specifier|const
name|QChar
modifier|*
name|data1
parameter_list|,
name|int
name|length1
parameter_list|,
specifier|const
name|QChar
modifier|*
name|data2
parameter_list|,
name|int
name|length2
parameter_list|)
block|{
comment|// do the right thing for null and empty
if|if
condition|(
name|length1
operator|==
literal|0
operator|||
name|length2
operator|==
literal|0
condition|)
return|return
name|ucstrcmp
argument_list|(
name|data1
argument_list|,
name|length1
argument_list|,
name|data2
argument_list|,
name|length2
argument_list|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
ifndef|#
directive|ifndef
name|Q_OS_WINRT
name|int
name|res
init|=
name|CompareString
argument_list|(
name|GetUserDefaultLCID
argument_list|()
argument_list|,
literal|0
argument_list|,
operator|(
name|wchar_t
operator|*
operator|)
name|data1
argument_list|,
name|length1
argument_list|,
operator|(
name|wchar_t
operator|*
operator|)
name|data2
argument_list|,
name|length2
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|res
init|=
name|CompareStringEx
argument_list|(
name|LOCALE_NAME_USER_DEFAULT
argument_list|,
literal|0
argument_list|,
operator|(
name|LPCWSTR
operator|)
name|data1
argument_list|,
name|length1
argument_list|,
operator|(
name|LPCWSTR
operator|)
name|data2
argument_list|,
name|length2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|CSTR_LESS_THAN
case|:
return|return
operator|-
literal|1
return|;
case|case
name|CSTR_GREATER_THAN
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
comment|// Use CFStringCompare for comparing strings on Mac. This makes Qt order
comment|// strings the same way as native applications do, and also respects
comment|// the "Order for sorted lists" setting in the International preferences
comment|// panel.
specifier|const
name|CFStringRef
name|thisString
init|=
name|CFStringCreateWithCharactersNoCopy
argument_list|(
name|kCFAllocatorDefault
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|UniChar
operator|*
argument_list|>
argument_list|(
name|data1
argument_list|)
argument_list|,
name|length1
argument_list|,
name|kCFAllocatorNull
argument_list|)
decl_stmt|;
specifier|const
name|CFStringRef
name|otherString
init|=
name|CFStringCreateWithCharactersNoCopy
argument_list|(
name|kCFAllocatorDefault
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|UniChar
operator|*
argument_list|>
argument_list|(
name|data2
argument_list|)
argument_list|,
name|length2
argument_list|,
name|kCFAllocatorNull
argument_list|)
decl_stmt|;
specifier|const
name|int
name|result
init|=
name|CFStringCompare
argument_list|(
name|thisString
argument_list|,
name|otherString
argument_list|,
name|kCFCompareLocalized
argument_list|)
decl_stmt|;
name|CFRelease
argument_list|(
name|thisString
argument_list|)
expr_stmt|;
name|CFRelease
argument_list|(
name|otherString
argument_list|)
expr_stmt|;
return|return
name|result
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|QT_USE_ICU
argument_list|)
if|if
condition|(
operator|!
name|defaultCollator
argument_list|()
operator|->
name|hasLocalData
argument_list|()
condition|)
name|defaultCollator
argument_list|()
operator|->
name|setLocalData
argument_list|(
name|QCollator
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|defaultCollator
argument_list|()
operator|->
name|localData
argument_list|()
operator|.
name|compare
argument_list|(
name|data1
argument_list|,
name|length1
argument_list|,
name|data2
argument_list|,
name|length2
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
comment|// declared in<string.h>
name|int
name|delta
init|=
name|strcoll
argument_list|(
name|toLocal8Bit_helper
argument_list|(
name|data1
argument_list|,
name|length1
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|toLocal8Bit_helper
argument_list|(
name|data2
argument_list|,
name|length2
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|delta
operator|=
name|ucstrcmp
argument_list|(
name|data1
argument_list|,
name|length1
argument_list|,
name|data2
argument_list|,
name|length2
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
else|#
directive|else
return|return
name|ucstrcmp
argument_list|(
name|data1
argument_list|,
name|length1
argument_list|,
name|data2
argument_list|,
name|length2
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \fn const QChar *QString::unicode() const      Returns a '\\0'-terminated Unicode representation of the string.     The result remains valid until the string is modified.      \sa utf16() */
end_comment
begin_comment
comment|/*!     \fn const ushort *QString::utf16() const      Returns the QString as a '\\0\'-terminated array of unsigned     shorts. The result remains valid until the string is modified.      The returned string is in host byte order.      \sa unicode() */
end_comment
begin_function
DECL|function|utf16
specifier|const
name|ushort
modifier|*
name|QString
operator|::
name|utf16
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|IS_RAW_DATA
argument_list|(
name|d
argument_list|)
condition|)
block|{
comment|// ensure '\0'-termination for ::fromRawData strings
cast|const_cast
argument_list|<
name|QString
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|reallocData
argument_list|(
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
operator|+
literal|1u
argument_list|)
expr_stmt|;
block|}
return|return
name|d
operator|->
name|data
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a string of size \a width that contains this string     padded by the \a fill character.      If \a truncate is \c false and the size() of the string is more than     \a width, then the returned string is a copy of the string.      \snippet qstring/main.cpp 32      If \a truncate is \c true and the size() of the string is more than     \a width, then any characters in a copy of the string after     position \a width are removed, and the copy is returned.      \snippet qstring/main.cpp 33      \sa rightJustified() */
end_comment
begin_function
DECL|function|leftJustified
name|QString
name|QString
operator|::
name|leftJustified
parameter_list|(
name|int
name|width
parameter_list|,
name|QChar
name|fill
parameter_list|,
name|bool
name|truncate
parameter_list|)
specifier|const
block|{
name|QString
name|result
decl_stmt|;
name|int
name|len
init|=
name|length
argument_list|()
decl_stmt|;
name|int
name|padlen
init|=
name|width
operator|-
name|len
decl_stmt|;
if|if
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|resize
argument_list|(
name|len
operator|+
name|padlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|memcpy
argument_list|(
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|data
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
operator|*
name|len
argument_list|)
expr_stmt|;
name|QChar
modifier|*
name|uc
init|=
operator|(
name|QChar
operator|*
operator|)
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
operator|+
name|len
decl_stmt|;
while|while
condition|(
name|padlen
operator|--
condition|)
operator|*
name|uc
operator|++
operator|=
name|fill
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|truncate
condition|)
name|result
operator|=
name|left
argument_list|(
name|width
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|*
name|this
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a string of size() \a width that contains the \a fill     character followed by the string. For example:      \snippet qstring/main.cpp 49      If \a truncate is \c false and the size() of the string is more than     \a width, then the returned string is a copy of the string.      If \a truncate is true and the size() of the string is more than     \a width, then the resulting string is truncated at position \a     width.      \snippet qstring/main.cpp 50      \sa leftJustified() */
end_comment
begin_function
DECL|function|rightJustified
name|QString
name|QString
operator|::
name|rightJustified
parameter_list|(
name|int
name|width
parameter_list|,
name|QChar
name|fill
parameter_list|,
name|bool
name|truncate
parameter_list|)
specifier|const
block|{
name|QString
name|result
decl_stmt|;
name|int
name|len
init|=
name|length
argument_list|()
decl_stmt|;
name|int
name|padlen
init|=
name|width
operator|-
name|len
decl_stmt|;
if|if
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|resize
argument_list|(
name|len
operator|+
name|padlen
argument_list|)
expr_stmt|;
name|QChar
modifier|*
name|uc
init|=
operator|(
name|QChar
operator|*
operator|)
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
decl_stmt|;
while|while
condition|(
name|padlen
operator|--
condition|)
operator|*
name|uc
operator|++
operator|=
name|fill
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|memcpy
argument_list|(
name|uc
argument_list|,
name|d
operator|->
name|data
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
operator|*
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|truncate
condition|)
name|result
operator|=
name|left
argument_list|(
name|width
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|*
name|this
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QString::toLower() const      Returns a lowercase copy of the string.      \snippet qstring/main.cpp 75      The case conversion will always happen in the 'C' locale. For locale dependent     case folding use QLocale::toLower()      \sa toUpper(), QLocale::toLower() */
end_comment
begin_namespace
DECL|namespace|QUnicodeTables
namespace|namespace
name|QUnicodeTables
block|{
DECL|struct|LowercaseTraits
struct|struct
name|LowercaseTraits
block|{
DECL|function|caseDiff
specifier|static
name|signed
name|short
name|caseDiff
parameter_list|(
specifier|const
name|Properties
modifier|*
name|prop
parameter_list|)
block|{
return|return
name|prop
operator|->
name|lowerCaseDiff
return|;
block|}
DECL|function|caseSpecial
specifier|static
name|bool
name|caseSpecial
parameter_list|(
specifier|const
name|Properties
modifier|*
name|prop
parameter_list|)
block|{
return|return
name|prop
operator|->
name|lowerCaseSpecial
return|;
block|}
block|}
struct|;
DECL|struct|UppercaseTraits
struct|struct
name|UppercaseTraits
block|{
DECL|function|caseDiff
specifier|static
name|signed
name|short
name|caseDiff
parameter_list|(
specifier|const
name|Properties
modifier|*
name|prop
parameter_list|)
block|{
return|return
name|prop
operator|->
name|upperCaseDiff
return|;
block|}
DECL|function|caseSpecial
specifier|static
name|bool
name|caseSpecial
parameter_list|(
specifier|const
name|Properties
modifier|*
name|prop
parameter_list|)
block|{
return|return
name|prop
operator|->
name|upperCaseSpecial
return|;
block|}
block|}
struct|;
DECL|struct|CasefoldTraits
struct|struct
name|CasefoldTraits
block|{
DECL|function|caseDiff
specifier|static
name|signed
name|short
name|caseDiff
parameter_list|(
specifier|const
name|Properties
modifier|*
name|prop
parameter_list|)
block|{
return|return
name|prop
operator|->
name|caseFoldDiff
return|;
block|}
DECL|function|caseSpecial
specifier|static
name|bool
name|caseSpecial
parameter_list|(
specifier|const
name|Properties
modifier|*
name|prop
parameter_list|)
block|{
return|return
name|prop
operator|->
name|caseFoldSpecial
return|;
block|}
block|}
struct|;
template|template
parameter_list|<
name|typename
name|Traits
parameter_list|,
name|typename
name|T
parameter_list|>
name|Q_NEVER_INLINE
DECL|function|detachAndConvertCase
specifier|static
name|QString
name|detachAndConvertCase
parameter_list|(
name|T
modifier|&
name|str
parameter_list|,
name|QStringIterator
name|it
parameter_list|)
block|{
name|QString
name|s
init|=
name|qMove
argument_list|(
name|str
argument_list|)
decl_stmt|;
comment|// will copy if T is const QString
name|QChar
modifier|*
name|pp
init|=
name|s
operator|.
name|begin
argument_list|()
operator|+
name|it
operator|.
name|index
argument_list|()
decl_stmt|;
comment|// will detach if necessary
name|uint
name|uc
init|=
name|it
operator|.
name|nextUnchecked
argument_list|()
decl_stmt|;
forever|forever
block|{
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|prop
init|=
name|qGetProp
argument_list|(
name|uc
argument_list|)
decl_stmt|;
name|signed
name|short
name|caseDiff
init|=
name|Traits
operator|::
name|caseDiff
argument_list|(
name|prop
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|Traits
operator|::
name|caseSpecial
argument_list|(
name|prop
argument_list|)
argument_list|)
condition|)
block|{
comment|// slow path
specifier|const
name|ushort
modifier|*
name|specialCase
init|=
name|specialCaseMap
operator|+
name|caseDiff
decl_stmt|;
name|ushort
name|length
init|=
operator|*
name|specialCase
operator|++
decl_stmt|;
name|int
name|pos
init|=
name|pp
operator|-
name|s
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|s
operator|.
name|replace
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|specialCase
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|pp
operator|=
cast|const_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
name|s
operator|.
name|constBegin
argument_list|()
argument_list|)
operator|+
name|pos
operator|+
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|uc
argument_list|)
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|uc
operator|+
name|caseDiff
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|uc
operator|+
name|caseDiff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pp
operator|++
operator|=
name|QChar
argument_list|(
name|uc
operator|+
name|caseDiff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|it
operator|.
name|hasNext
argument_list|()
condition|)
return|return
name|s
return|;
name|uc
operator|=
name|it
operator|.
name|nextUnchecked
argument_list|()
expr_stmt|;
block|}
block|}
template|template
parameter_list|<
name|typename
name|Traits
parameter_list|,
name|typename
name|T
parameter_list|>
DECL|function|convertCase
specifier|static
name|QString
name|convertCase
parameter_list|(
name|T
modifier|&
name|str
parameter_list|)
block|{
specifier|const
name|QChar
modifier|*
name|p
init|=
name|str
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|e
init|=
name|p
operator|+
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// this avoids out of bounds check in the loop
while|while
condition|(
name|e
operator|!=
name|p
operator|&&
name|e
index|[
operator|-
literal|1
index|]
operator|.
name|isHighSurrogate
argument_list|()
condition|)
operator|--
name|e
expr_stmt|;
specifier|const
name|QUnicodeTables
operator|::
name|Properties
modifier|*
name|prop
decl_stmt|;
name|QStringIterator
name|it
argument_list|(
name|p
argument_list|,
name|e
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
name|it
operator|.
name|advanceUnchecked
argument_list|()
control|)
block|{
name|prop
operator|=
name|qGetProp
argument_list|(
name|it
operator|.
name|peekNextUnchecked
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Traits
operator|::
name|caseDiff
argument_list|(
name|prop
argument_list|)
condition|)
return|return
name|detachAndConvertCase
argument_list|<
name|Traits
argument_list|>
argument_list|(
name|str
argument_list|,
name|it
argument_list|)
return|;
block|}
return|return
name|qMove
argument_list|(
name|str
argument_list|)
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace QUnicodeTables
end_comment
begin_function
DECL|function|toLower_helper
name|QString
name|QString
operator|::
name|toLower_helper
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
return|return
name|QUnicodeTables
operator|::
name|convertCase
argument_list|<
name|QUnicodeTables
operator|::
name|LowercaseTraits
argument_list|>
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|toLower_helper
name|QString
name|QString
operator|::
name|toLower_helper
parameter_list|(
name|QString
modifier|&
name|str
parameter_list|)
block|{
return|return
name|QUnicodeTables
operator|::
name|convertCase
argument_list|<
name|QUnicodeTables
operator|::
name|LowercaseTraits
argument_list|>
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QString::toCaseFolded() const      Returns the case folded equivalent of the string. For most Unicode     characters this is the same as toLower(). */
end_comment
begin_function
DECL|function|toCaseFolded_helper
name|QString
name|QString
operator|::
name|toCaseFolded_helper
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
return|return
name|QUnicodeTables
operator|::
name|convertCase
argument_list|<
name|QUnicodeTables
operator|::
name|CasefoldTraits
argument_list|>
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|toCaseFolded_helper
name|QString
name|QString
operator|::
name|toCaseFolded_helper
parameter_list|(
name|QString
modifier|&
name|str
parameter_list|)
block|{
return|return
name|QUnicodeTables
operator|::
name|convertCase
argument_list|<
name|QUnicodeTables
operator|::
name|CasefoldTraits
argument_list|>
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QString::toUpper() const      Returns an uppercase copy of the string.      \snippet qstring/main.cpp 81      The case conversion will always happen in the 'C' locale. For locale dependent     case folding use QLocale::toUpper()      \sa toLower(), QLocale::toLower() */
end_comment
begin_function
DECL|function|toUpper_helper
name|QString
name|QString
operator|::
name|toUpper_helper
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
return|return
name|QUnicodeTables
operator|::
name|convertCase
argument_list|<
name|QUnicodeTables
operator|::
name|UppercaseTraits
argument_list|>
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|toUpper_helper
name|QString
name|QString
operator|::
name|toUpper_helper
parameter_list|(
name|QString
modifier|&
name|str
parameter_list|)
block|{
return|return
name|QUnicodeTables
operator|::
name|convertCase
argument_list|<
name|QUnicodeTables
operator|::
name|UppercaseTraits
argument_list|>
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete Use asprintf(), arg() or QTextStream instead. */
end_comment
begin_function
DECL|function|sprintf
name|QString
modifier|&
name|QString
operator|::
name|sprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|cformat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cformat
argument_list|)
expr_stmt|;
operator|*
name|this
operator|=
name|vasprintf
argument_list|(
name|cformat
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|// ### Qt 6: Consider whether this function shouldn't be removed See task 202871.
end_comment
begin_comment
comment|/*!     \since 5.5      Safely builds a formatted string from the format string \a cformat     and an arbitrary list of arguments.      The format string supports the conversion specifiers, length modifiers,     and flags provided by printf() in the standard C++ library. The \a cformat     string and \c{%s} arguments must be UTF-8 encoded.      \note The \c{%lc} escape sequence expects a unicode character of type     \c char16_t, or \c ushort (as returned by QChar::unicode()).     The \c{%ls} escape sequence expects a pointer to a zero-terminated array     of unicode characters of type \c char16_t, or ushort (as returned by     QString::utf16()). This is at odds with the printf() in the standard C++     library, which defines \c {%lc} to print a wchar_t and \c{%ls} to print     a \c{wchar_t*}, and might also produce compiler warnings on platforms     where the size of \c {wchar_t} is not 16 bits.      \warning We do not recommend using QString::asprintf() in new Qt     code. Instead, consider using QTextStream or arg(), both of     which support Unicode strings seamlessly and are type-safe.     Here's an example that uses QTextStream:      \snippet qstring/main.cpp 64      For \l {QObject::tr()}{translations}, especially if the strings     contains more than one escape sequence, you should consider using     the arg() function instead. This allows the order of the     replacements to be controlled by the translator.      \sa arg() */
end_comment
begin_function
DECL|function|asprintf
name|QString
name|QString
operator|::
name|asprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|cformat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cformat
argument_list|)
expr_stmt|;
specifier|const
name|QString
name|s
init|=
name|vasprintf
argument_list|(
name|cformat
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete Use vasprintf(), arg() or QTextStream instead. */
end_comment
begin_function
DECL|function|vsprintf
name|QString
modifier|&
name|QString
operator|::
name|vsprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|cformat
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
return|return
operator|*
name|this
operator|=
name|vasprintf
argument_list|(
name|cformat
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString::vasprintf(const char *cformat, va_list ap)     \since 5.5      Equivalent method to asprintf(), but takes a va_list \a ap     instead a list of variable arguments. See the asprintf()     documentation for an explanation of \a cformat.      This method does not call the va_end macro, the caller     is responsible to call va_end on \a ap.      \sa asprintf() */
end_comment
begin_function
DECL|function|vasprintf
name|QString
name|QString
operator|::
name|vasprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|cformat
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cformat
operator|||
operator|!
operator|*
name|cformat
condition|)
block|{
comment|// Qt 1.x compat
return|return
name|fromLatin1
argument_list|(
literal|""
argument_list|)
return|;
block|}
comment|// Parse cformat
name|QString
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
init|=
name|cformat
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// Copy non-escape chars to result
specifier|const
name|char
modifier|*
name|cb
init|=
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|c
operator|!=
literal|'\0'
operator|&&
operator|*
name|c
operator|!=
literal|'%'
condition|)
name|c
operator|++
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
name|cb
argument_list|,
call|(
name|int
call|)
argument_list|(
name|c
operator|-
name|cb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|==
literal|'\0'
condition|)
break|break;
comment|// Found '%'
specifier|const
name|char
modifier|*
name|escape_start
init|=
name|c
decl_stmt|;
operator|++
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|==
literal|'\0'
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
argument_list|)
expr_stmt|;
comment|// a % at the end of the string - treat as non-escape text
break|break;
block|}
if|if
condition|(
operator|*
name|c
operator|==
literal|'%'
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
argument_list|)
expr_stmt|;
comment|// %%
operator|++
name|c
expr_stmt|;
continue|continue;
block|}
comment|// Parse flag characters
name|uint
name|flags
init|=
literal|0
decl_stmt|;
name|bool
name|no_more_flags
init|=
literal|false
decl_stmt|;
do|do
block|{
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'#'
case|:
name|flags
operator||=
name|QLocaleData
operator|::
name|Alternate
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
name|flags
operator||=
name|QLocaleData
operator|::
name|ZeroPadded
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|flags
operator||=
name|QLocaleData
operator|::
name|LeftAdjusted
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|flags
operator||=
name|QLocaleData
operator|::
name|BlankBeforePositive
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|flags
operator||=
name|QLocaleData
operator|::
name|AlwaysShowSign
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|flags
operator||=
name|QLocaleData
operator|::
name|ThousandsGroup
expr_stmt|;
break|break;
default|default:
name|no_more_flags
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|no_more_flags
condition|)
operator|++
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|no_more_flags
condition|)
do|;
if|if
condition|(
operator|*
name|c
operator|==
literal|'\0'
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
name|escape_start
argument_list|)
argument_list|)
expr_stmt|;
comment|// incomplete escape, treat as non-escape text
break|break;
block|}
comment|// Parse field width
name|int
name|width
init|=
operator|-
literal|1
decl_stmt|;
comment|// -1 means unspecified
if|if
condition|(
name|qIsDigit
argument_list|(
operator|*
name|c
argument_list|)
condition|)
block|{
name|QString
name|width_str
decl_stmt|;
while|while
condition|(
operator|*
name|c
operator|!=
literal|'\0'
operator|&&
name|qIsDigit
argument_list|(
operator|*
name|c
argument_list|)
condition|)
name|width_str
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
operator|*
name|c
operator|++
argument_list|)
argument_list|)
expr_stmt|;
comment|// can't be negative - started with a digit
comment|// contains at least one digit
name|width
operator|=
name|width_str
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|c
operator|==
literal|'*'
condition|)
block|{
name|width
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
name|width
operator|=
operator|-
literal|1
expr_stmt|;
comment|// treat all negative numbers as unspecified
operator|++
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|c
operator|==
literal|'\0'
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
name|escape_start
argument_list|)
argument_list|)
expr_stmt|;
comment|// incomplete escape, treat as non-escape text
break|break;
block|}
comment|// Parse precision
name|int
name|precision
init|=
operator|-
literal|1
decl_stmt|;
comment|// -1 means unspecified
if|if
condition|(
operator|*
name|c
operator|==
literal|'.'
condition|)
block|{
operator|++
name|c
expr_stmt|;
if|if
condition|(
name|qIsDigit
argument_list|(
operator|*
name|c
argument_list|)
condition|)
block|{
name|QString
name|precision_str
decl_stmt|;
while|while
condition|(
operator|*
name|c
operator|!=
literal|'\0'
operator|&&
name|qIsDigit
argument_list|(
operator|*
name|c
argument_list|)
condition|)
name|precision_str
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
operator|*
name|c
operator|++
argument_list|)
argument_list|)
expr_stmt|;
comment|// can't be negative - started with a digit
comment|// contains at least one digit
name|precision
operator|=
name|precision_str
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|c
operator|==
literal|'*'
condition|)
block|{
name|precision
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|precision
operator|<
literal|0
condition|)
name|precision
operator|=
operator|-
literal|1
expr_stmt|;
comment|// treat all negative numbers as unspecified
operator|++
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|c
operator|==
literal|'\0'
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
name|escape_start
argument_list|)
argument_list|)
expr_stmt|;
comment|// incomplete escape, treat as non-escape text
break|break;
block|}
comment|// Parse the length modifier
enum|enum
name|LengthMod
block|{
name|lm_none
block|,
name|lm_hh
block|,
name|lm_h
block|,
name|lm_l
block|,
name|lm_ll
block|,
name|lm_L
block|,
name|lm_j
block|,
name|lm_z
block|,
name|lm_t
block|}
enum|;
name|LengthMod
name|length_mod
init|=
name|lm_none
decl_stmt|;
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'h'
case|:
operator|++
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|==
literal|'h'
condition|)
block|{
name|length_mod
operator|=
name|lm_hh
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
else|else
name|length_mod
operator|=
name|lm_h
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|++
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|==
literal|'l'
condition|)
block|{
name|length_mod
operator|=
name|lm_ll
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
else|else
name|length_mod
operator|=
name|lm_l
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
operator|++
name|c
expr_stmt|;
name|length_mod
operator|=
name|lm_L
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
operator|++
name|c
expr_stmt|;
name|length_mod
operator|=
name|lm_j
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
case|case
literal|'Z'
case|:
operator|++
name|c
expr_stmt|;
name|length_mod
operator|=
name|lm_z
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|++
name|c
expr_stmt|;
name|length_mod
operator|=
name|lm_t
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|*
name|c
operator|==
literal|'\0'
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
name|escape_start
argument_list|)
argument_list|)
expr_stmt|;
comment|// incomplete escape, treat as non-escape text
break|break;
block|}
comment|// Parse the conversion specifier and do the conversion
name|QString
name|subst
decl_stmt|;
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
block|{
name|qint64
name|i
decl_stmt|;
switch|switch
condition|(
name|length_mod
condition|)
block|{
case|case
name|lm_none
case|:
name|i
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|lm_hh
case|:
name|i
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|lm_h
case|:
name|i
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|lm_l
case|:
name|i
operator|=
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|long int
argument_list|)
expr_stmt|;
break|break;
case|case
name|lm_ll
case|:
name|i
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|qint64
argument_list|)
expr_stmt|;
break|break;
case|case
name|lm_j
case|:
name|i
operator|=
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|long int
argument_list|)
expr_stmt|;
break|break;
case|case
name|lm_z
case|:
name|i
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|lm_t
case|:
name|i
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
default|default:
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|subst
operator|=
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|longLongToString
argument_list|(
name|i
argument_list|,
name|precision
argument_list|,
literal|10
argument_list|,
name|width
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
block|}
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
block|{
name|quint64
name|u
decl_stmt|;
switch|switch
condition|(
name|length_mod
condition|)
block|{
case|case
name|lm_none
case|:
name|u
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint
argument_list|)
expr_stmt|;
break|break;
case|case
name|lm_hh
case|:
name|u
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint
argument_list|)
expr_stmt|;
break|break;
case|case
name|lm_h
case|:
name|u
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint
argument_list|)
expr_stmt|;
break|break;
case|case
name|lm_l
case|:
name|u
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|ulong
argument_list|)
expr_stmt|;
break|break;
case|case
name|lm_ll
case|:
name|u
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|quint64
argument_list|)
expr_stmt|;
break|break;
case|case
name|lm_z
case|:
name|u
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|u
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|qIsUpper
argument_list|(
operator|*
name|c
argument_list|)
condition|)
name|flags
operator||=
name|QLocaleData
operator|::
name|CapitalEorX
expr_stmt|;
name|int
name|base
init|=
literal|10
decl_stmt|;
switch|switch
condition|(
name|qToLower
argument_list|(
operator|*
name|c
argument_list|)
condition|)
block|{
case|case
literal|'o'
case|:
name|base
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|base
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|base
operator|=
literal|16
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|subst
operator|=
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|unsLongLongToString
argument_list|(
name|u
argument_list|,
name|precision
argument_list|,
name|base
argument_list|,
name|width
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
block|}
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
case|case
literal|'G'
case|:
case|case
literal|'g'
case|:
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
block|{
name|double
name|d
decl_stmt|;
if|if
condition|(
name|length_mod
operator|==
name|lm_L
condition|)
name|d
operator|=
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|long double
argument_list|)
expr_stmt|;
comment|// not supported - converted to a double
else|else
name|d
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
expr_stmt|;
if|if
condition|(
name|qIsUpper
argument_list|(
operator|*
name|c
argument_list|)
condition|)
name|flags
operator||=
name|QLocaleData
operator|::
name|CapitalEorX
expr_stmt|;
name|QLocaleData
operator|::
name|DoubleForm
name|form
init|=
name|QLocaleData
operator|::
name|DFDecimal
decl_stmt|;
switch|switch
condition|(
name|qToLower
argument_list|(
operator|*
name|c
argument_list|)
condition|)
block|{
case|case
literal|'e'
case|:
name|form
operator|=
name|QLocaleData
operator|::
name|DFExponent
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|// not supported - decimal form used instead
case|case
literal|'f'
case|:
name|form
operator|=
name|QLocaleData
operator|::
name|DFDecimal
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|form
operator|=
name|QLocaleData
operator|::
name|DFSignificantDigits
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|subst
operator|=
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|doubleToString
argument_list|(
name|d
argument_list|,
name|precision
argument_list|,
name|form
argument_list|,
name|width
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
block|}
case|case
literal|'c'
case|:
block|{
if|if
condition|(
name|length_mod
operator|==
name|lm_l
condition|)
name|subst
operator|=
name|QChar
argument_list|(
operator|(
name|ushort
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|subst
operator|=
name|QLatin1Char
argument_list|(
operator|(
name|uchar
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
block|}
case|case
literal|'s'
case|:
block|{
if|if
condition|(
name|length_mod
operator|==
name|lm_l
condition|)
block|{
specifier|const
name|ushort
modifier|*
name|buff
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|ushort
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|ch
init|=
name|buff
decl_stmt|;
while|while
condition|(
operator|*
name|ch
operator|!=
literal|0
condition|)
operator|++
name|ch
expr_stmt|;
name|subst
operator|.
name|setUtf16
argument_list|(
name|buff
argument_list|,
name|ch
operator|-
name|buff
argument_list|)
expr_stmt|;
block|}
else|else
name|subst
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|precision
operator|!=
operator|-
literal|1
condition|)
name|subst
operator|.
name|truncate
argument_list|(
name|precision
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
block|}
case|case
literal|'p'
case|:
block|{
name|void
modifier|*
name|arg
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN64
name|quint64
name|i
init|=
cast|reinterpret_cast
argument_list|<
name|quint64
argument_list|>
argument_list|(
name|arg
argument_list|)
decl_stmt|;
else|#
directive|else
name|quint64
name|i
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|long
argument_list|>
argument_list|(
name|arg
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|flags
operator||=
name|QLocaleData
operator|::
name|Alternate
expr_stmt|;
name|subst
operator|=
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|unsLongLongToString
argument_list|(
name|i
argument_list|,
name|precision
argument_list|,
literal|16
argument_list|,
name|width
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
break|break;
block|}
case|case
literal|'n'
case|:
switch|switch
condition|(
name|length_mod
condition|)
block|{
case|case
name|lm_hh
case|:
block|{
name|signed
name|char
modifier|*
name|n
init|=
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|signed char*
argument_list|)
decl_stmt|;
operator|*
name|n
operator|=
name|result
operator|.
name|length
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|lm_h
case|:
block|{
name|short
name|int
modifier|*
name|n
init|=
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|short int*
argument_list|)
decl_stmt|;
operator|*
name|n
operator|=
name|result
operator|.
name|length
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|lm_l
case|:
block|{
name|long
name|int
modifier|*
name|n
init|=
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|long int*
argument_list|)
decl_stmt|;
operator|*
name|n
operator|=
name|result
operator|.
name|length
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|lm_ll
case|:
block|{
name|qint64
modifier|*
name|n
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|qint64
operator|*
argument_list|)
decl_stmt|;
specifier|volatile
name|uint
name|tmp
init|=
name|result
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// egcs-2.91.66 gets internal
operator|*
name|n
operator|=
name|tmp
expr_stmt|;
comment|// compiler error without volatile
break|break;
block|}
default|default:
block|{
name|int
modifier|*
name|n
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
decl_stmt|;
operator|*
name|n
operator|=
name|result
operator|.
name|length
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
operator|++
name|c
expr_stmt|;
break|break;
default|default:
comment|// bad escape, treat as non-escape text
for|for
control|(
specifier|const
name|char
modifier|*
name|cc
init|=
name|escape_start
init|;
name|cc
operator|!=
name|c
condition|;
operator|++
name|cc
control|)
name|result
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
operator|*
name|cc
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|flags
operator|&
name|QLocaleData
operator|::
name|LeftAdjusted
condition|)
name|result
operator|.
name|append
argument_list|(
name|subst
operator|.
name|leftJustified
argument_list|(
name|width
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|result
operator|.
name|append
argument_list|(
name|subst
operator|.
name|rightJustified
argument_list|(
name|width
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to a \c{long long} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toLongLong()      Example:      \snippet qstring/main.cpp 74      \sa number(), toULongLong(), toInt(), QLocale::toLongLong() */
end_comment
begin_function
DECL|function|toLongLong
name|qint64
name|QString
operator|::
name|toLongLong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|toIntegral_helper
argument_list|<
name|qlonglong
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|toIntegral_helper
name|qlonglong
name|QString
operator|::
name|toIntegral_helper
parameter_list|(
specifier|const
name|QChar
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_CHECK_RANGE
argument_list|)
if|if
condition|(
name|base
operator|!=
literal|0
operator|&&
operator|(
name|base
argument_list|<
literal|2
operator|||
name|base
argument_list|>
literal|36
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QString::toULongLong: Invalid base (%d)"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|stringToLongLong
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|base
argument_list|,
name|ok
argument_list|,
name|QLocaleData
operator|::
name|FailOnGroupSeparators
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to an \c{unsigned long long} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toULongLong()      Example:      \snippet qstring/main.cpp 79      \sa number(), toLongLong(), QLocale::toULongLong() */
end_comment
begin_function
DECL|function|toULongLong
name|quint64
name|QString
operator|::
name|toULongLong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|toIntegral_helper
argument_list|<
name|qulonglong
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|toIntegral_helper
name|qulonglong
name|QString
operator|::
name|toIntegral_helper
parameter_list|(
specifier|const
name|QChar
modifier|*
name|data
parameter_list|,
name|uint
name|len
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_CHECK_RANGE
argument_list|)
if|if
condition|(
name|base
operator|!=
literal|0
operator|&&
operator|(
name|base
argument_list|<
literal|2
operator|||
name|base
argument_list|>
literal|36
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QString::toULongLong: Invalid base (%d)"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|stringToUnsLongLong
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|base
argument_list|,
name|ok
argument_list|,
name|QLocaleData
operator|::
name|FailOnGroupSeparators
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn long QString::toLong(bool *ok, int base) const      Returns the string converted to a \c long using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toLongLong()      Example:      \snippet qstring/main.cpp 73      \sa number(), toULong(), toInt(), QLocale::toInt() */
end_comment
begin_function
DECL|function|toLong
name|long
name|QString
operator|::
name|toLong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|toIntegral_helper
argument_list|<
name|long
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn ulong QString::toULong(bool *ok, int base) const      Returns the string converted to an \c{unsigned long} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toULongLong()      Example:      \snippet qstring/main.cpp 78      \sa number(), QLocale::toUInt() */
end_comment
begin_function
DECL|function|toULong
name|ulong
name|QString
operator|::
name|toULong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|toIntegral_helper
argument_list|<
name|ulong
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to an \c int using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toInt()      Example:      \snippet qstring/main.cpp 72      \sa number(), toUInt(), toDouble(), QLocale::toInt() */
end_comment
begin_function
DECL|function|toInt
name|int
name|QString
operator|::
name|toInt
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|toIntegral_helper
argument_list|<
name|int
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to an \c{unsigned int} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toUInt()      Example:      \snippet qstring/main.cpp 77      \sa number(), toInt(), QLocale::toUInt() */
end_comment
begin_function
DECL|function|toUInt
name|uint
name|QString
operator|::
name|toUInt
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|toIntegral_helper
argument_list|<
name|uint
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to a \c short using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toShort()      Example:      \snippet qstring/main.cpp 76      \sa number(), toUShort(), toInt(), QLocale::toShort() */
end_comment
begin_function
DECL|function|toShort
name|short
name|QString
operator|::
name|toShort
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|toIntegral_helper
argument_list|<
name|short
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to an \c{unsigned short} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toUShort()      Example:      \snippet qstring/main.cpp 80      \sa number(), toShort(), QLocale::toUShort() */
end_comment
begin_function
DECL|function|toUShort
name|ushort
name|QString
operator|::
name|toUShort
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|toIntegral_helper
argument_list|<
name|ushort
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to a \c double value.      Returns 0.0 if the conversion fails.      If a conversion error occurs, \c{*}\a{ok} is set to \c false;     otherwise \c{*}\a{ok} is set to \c true.      \snippet qstring/main.cpp 66      \warning The QString content may only contain valid numerical characters which includes the plus/minus sign, the characters g and e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.      \snippet qstring/main.cpp 67      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toDouble()      \snippet qstring/main.cpp 68      For historical reasons, this function does not handle     thousands group separators. If you need to convert such numbers,     use QLocale::toDouble().      \snippet qstring/main.cpp 69      \sa number(), QLocale::setDefault(), QLocale::toDouble(), trimmed() */
end_comment
begin_function
DECL|function|toDouble
name|double
name|QString
operator|::
name|toDouble
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
return|return
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|stringToDouble
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|QLocaleData
operator|::
name|FailOnGroupSeparators
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to a \c float value.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true. Returns 0.0 if the conversion fails.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toFloat()      Example:      \snippet qstring/main.cpp 71      \sa number(), toDouble(), toInt(), QLocale::toFloat() */
end_comment
begin_function
DECL|function|toFloat
name|float
name|QString
operator|::
name|toFloat
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
return|return
name|QLocaleData
operator|::
name|convertDoubleToFloat
argument_list|(
name|toDouble
argument_list|(
name|ok
argument_list|)
argument_list|,
name|ok
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn QString&QString::setNum(int n, int base)      Sets the string to the printed value of \a n in the specified \a     base, and returns a reference to the string.      The base is 10 by default and must be between 2 and 36. For bases     other than 10, \a n is treated as an unsigned integer.      \snippet qstring/main.cpp 56     The formatting always uses QLocale::C, i.e., English/UnitedStates.    To get a localized string representation of a number, use    QLocale::toString() with the appropriate locale. */
end_comment
begin_comment
comment|/*! \fn QString&QString::setNum(uint n, int base)      \overload */
end_comment
begin_comment
comment|/*! \fn QString&QString::setNum(long n, int base)      \overload */
end_comment
begin_comment
comment|/*! \fn QString&QString::setNum(ulong n, int base)      \overload */
end_comment
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|setNum
name|QString
modifier|&
name|QString
operator|::
name|setNum
parameter_list|(
name|qlonglong
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
return|return
operator|*
name|this
operator|=
name|number
argument_list|(
name|n
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|setNum
name|QString
modifier|&
name|QString
operator|::
name|setNum
parameter_list|(
name|qulonglong
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
return|return
operator|*
name|this
operator|=
name|number
argument_list|(
name|n
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn QString&QString::setNum(short n, int base)      \overload */
end_comment
begin_comment
comment|/*! \fn QString&QString::setNum(ushort n, int base)      \overload */
end_comment
begin_comment
comment|/*!     \fn QString&QString::setNum(double n, char format, int precision)     \overload      Sets the string to the printed value of \a n, formatted according     to the given \a format and \a precision, and returns a reference     to the string.      The \a format can be 'e', 'E', 'f', 'g' or 'G' (see     \l{Argument Formats} for an explanation of the formats).      The formatting always uses QLocale::C, i.e., English/UnitedStates.     To get a localized string representation of a number, use     QLocale::toString() with the appropriate locale. */
end_comment
begin_function
DECL|function|setNum
name|QString
modifier|&
name|QString
operator|::
name|setNum
parameter_list|(
name|double
name|n
parameter_list|,
name|char
name|f
parameter_list|,
name|int
name|prec
parameter_list|)
block|{
return|return
operator|*
name|this
operator|=
name|number
argument_list|(
name|n
argument_list|,
name|f
argument_list|,
name|prec
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString&QString::setNum(float n, char format, int precision)     \overload      Sets the string to the printed value of \a n, formatted according     to the given \a format and \a precision, and returns a reference     to the string.      The formatting always uses QLocale::C, i.e., English/UnitedStates.     To get a localized string representation of a number, use     QLocale::toString() with the appropriate locale. */
end_comment
begin_comment
comment|/*!     \fn QString QString::number(long n, int base)      Returns a string equivalent of the number \a n according to the     specified \a base.      The base is 10 by default and must be between 2     and 36. For bases other than 10, \a n is treated as an     unsigned integer.      The formatting always uses QLocale::C, i.e., English/UnitedStates.     To get a localized string representation of a number, use     QLocale::toString() with the appropriate locale.      \snippet qstring/main.cpp 35      \sa setNum() */
end_comment
begin_function
DECL|function|number
name|QString
name|QString
operator|::
name|number
parameter_list|(
name|long
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
return|return
name|number
argument_list|(
name|qlonglong
argument_list|(
name|n
argument_list|)
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \fn QString QString::number(ulong n, int base)      \overload */
end_comment
begin_function
DECL|function|number
name|QString
name|QString
operator|::
name|number
parameter_list|(
name|ulong
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
return|return
name|number
argument_list|(
name|qulonglong
argument_list|(
name|n
argument_list|)
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|number
name|QString
name|QString
operator|::
name|number
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
return|return
name|number
argument_list|(
name|qlonglong
argument_list|(
name|n
argument_list|)
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|number
name|QString
name|QString
operator|::
name|number
parameter_list|(
name|uint
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
return|return
name|number
argument_list|(
name|qulonglong
argument_list|(
name|n
argument_list|)
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|number
name|QString
name|QString
operator|::
name|number
parameter_list|(
name|qlonglong
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_CHECK_RANGE
argument_list|)
if|if
condition|(
name|base
argument_list|<
literal|2
operator|||
name|base
argument_list|>
literal|36
condition|)
block|{
name|qWarning
argument_list|(
literal|"QString::setNum: Invalid base (%d)"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|longLongToString
argument_list|(
name|n
argument_list|,
operator|-
literal|1
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|number
name|QString
name|QString
operator|::
name|number
parameter_list|(
name|qulonglong
name|n
parameter_list|,
name|int
name|base
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_CHECK_RANGE
argument_list|)
if|if
condition|(
name|base
argument_list|<
literal|2
operator|||
name|base
argument_list|>
literal|36
condition|)
block|{
name|qWarning
argument_list|(
literal|"QString::setNum: Invalid base (%d)"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|unsLongLongToString
argument_list|(
name|n
argument_list|,
operator|-
literal|1
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QString::number(double n, char format, int precision)      Returns a string equivalent of the number \a n, formatted     according to the specified \a format and \a precision. See     \l{Argument Formats} for details.      Unlike QLocale::toString(), this function does not honor the     user's locale settings.      \sa setNum(), QLocale::toString() */
end_comment
begin_function
DECL|function|number
name|QString
name|QString
operator|::
name|number
parameter_list|(
name|double
name|n
parameter_list|,
name|char
name|f
parameter_list|,
name|int
name|prec
parameter_list|)
block|{
name|QLocaleData
operator|::
name|DoubleForm
name|form
init|=
name|QLocaleData
operator|::
name|DFDecimal
decl_stmt|;
name|uint
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|qIsUpper
argument_list|(
name|f
argument_list|)
condition|)
name|flags
operator|=
name|QLocaleData
operator|::
name|CapitalEorX
expr_stmt|;
name|f
operator|=
name|qToLower
argument_list|(
name|f
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|f
condition|)
block|{
case|case
literal|'f'
case|:
name|form
operator|=
name|QLocaleData
operator|::
name|DFDecimal
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|form
operator|=
name|QLocaleData
operator|::
name|DFExponent
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|form
operator|=
name|QLocaleData
operator|::
name|DFSignificantDigits
expr_stmt|;
break|break;
default|default:
if|#
directive|if
name|defined
argument_list|(
name|QT_CHECK_RANGE
argument_list|)
name|qWarning
argument_list|(
literal|"QString::setNum: Invalid format char '%c'"
argument_list|,
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
return|return
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|doubleToString
argument_list|(
name|n
argument_list|,
name|prec
argument_list|,
name|form
argument_list|,
operator|-
literal|1
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
template|template
parameter_list|<
name|class
name|ResultList
parameter_list|,
name|class
name|StringSource
parameter_list|>
DECL|function|splitString
specifier|static
name|ResultList
name|splitString
parameter_list|(
specifier|const
name|StringSource
modifier|&
name|source
parameter_list|,
specifier|const
name|QChar
modifier|*
name|sep
parameter_list|,
name|QString
operator|::
name|SplitBehavior
name|behavior
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|,
specifier|const
name|int
name|separatorSize
parameter_list|)
block|{
name|ResultList
name|list
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|extra
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|end
operator|=
name|qFindString
argument_list|(
name|source
operator|.
name|constData
argument_list|()
argument_list|,
name|source
operator|.
name|size
argument_list|()
argument_list|,
name|start
operator|+
name|extra
argument_list|,
name|sep
argument_list|,
name|separatorSize
argument_list|,
name|cs
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|start
operator|!=
name|end
operator|||
name|behavior
operator|==
name|QString
operator|::
name|KeepEmptyParts
condition|)
name|list
operator|.
name|append
argument_list|(
name|source
operator|.
name|mid
argument_list|(
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|end
operator|+
name|separatorSize
expr_stmt|;
name|extra
operator|=
operator|(
name|separatorSize
operator|==
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|source
operator|.
name|size
argument_list|()
operator|||
name|behavior
operator|==
name|QString
operator|::
name|KeepEmptyParts
condition|)
name|list
operator|.
name|append
argument_list|(
name|source
operator|.
name|mid
argument_list|(
name|start
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_comment
comment|/*!     Splits the string into substrings wherever \a sep occurs, and     returns the list of those strings. If \a sep does not match     anywhere in the string, split() returns a single-element list     containing this string.      \a cs specifies whether \a sep should be matched case     sensitively or case insensitively.      If \a behavior is QString::SkipEmptyParts, empty entries don't     appear in the result. By default, empty entries are kept.      Example:      \snippet qstring/main.cpp 62      \sa QStringList::join(), section() */
end_comment
begin_function
DECL|function|split
name|QStringList
name|QString
operator|::
name|split
parameter_list|(
specifier|const
name|QString
modifier|&
name|sep
parameter_list|,
name|SplitBehavior
name|behavior
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|splitString
argument_list|<
name|QStringList
argument_list|>
argument_list|(
operator|*
name|this
argument_list|,
name|sep
operator|.
name|constData
argument_list|()
argument_list|,
name|behavior
argument_list|,
name|cs
argument_list|,
name|sep
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Splits the string into substring references wherever \a sep occurs, and     returns the list of those strings. If \a sep does not match     anywhere in the string, splitRef() returns a single-element vector     containing this string reference.      \a cs specifies whether \a sep should be matched case     sensitively or case insensitively.      If \a behavior is QString::SkipEmptyParts, empty entries don't     appear in the result. By default, empty entries are kept.      \note All references are valid as long this string is alive. Destroying this     string will cause all references be dangling pointers.      \since 5.4     \sa QStringRef split() */
end_comment
begin_function
DECL|function|splitRef
name|QVector
argument_list|<
name|QStringRef
argument_list|>
name|QString
operator|::
name|splitRef
parameter_list|(
specifier|const
name|QString
modifier|&
name|sep
parameter_list|,
name|SplitBehavior
name|behavior
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|splitString
argument_list|<
name|QVector
argument_list|<
name|QStringRef
argument_list|>
argument_list|>
argument_list|(
name|QStringRef
argument_list|(
name|this
argument_list|)
argument_list|,
name|sep
operator|.
name|constData
argument_list|()
argument_list|,
name|behavior
argument_list|,
name|cs
argument_list|,
name|sep
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload */
end_comment
begin_function
DECL|function|split
name|QStringList
name|QString
operator|::
name|split
parameter_list|(
name|QChar
name|sep
parameter_list|,
name|SplitBehavior
name|behavior
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|splitString
argument_list|<
name|QStringList
argument_list|>
argument_list|(
operator|*
name|this
argument_list|,
operator|&
name|sep
argument_list|,
name|behavior
argument_list|,
name|cs
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 5.4 */
end_comment
begin_function
DECL|function|splitRef
name|QVector
argument_list|<
name|QStringRef
argument_list|>
name|QString
operator|::
name|splitRef
parameter_list|(
name|QChar
name|sep
parameter_list|,
name|SplitBehavior
name|behavior
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|splitString
argument_list|<
name|QVector
argument_list|<
name|QStringRef
argument_list|>
argument_list|>
argument_list|(
name|QStringRef
argument_list|(
name|this
argument_list|)
argument_list|,
operator|&
name|sep
argument_list|,
name|behavior
argument_list|,
name|cs
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Splits the string into substrings references wherever \a sep occurs, and     returns the list of those strings. If \a sep does not match     anywhere in the string, split() returns a single-element vector     containing this string reference.      \a cs specifies whether \a sep should be matched case     sensitively or case insensitively.      If \a behavior is QString::SkipEmptyParts, empty entries don't     appear in the result. By default, empty entries are kept.      \note All references are valid as long this string is alive. Destroying this     string will cause all references be dangling pointers.      \since 5.4 */
end_comment
begin_function
DECL|function|split
name|QVector
argument_list|<
name|QStringRef
argument_list|>
name|QStringRef
operator|::
name|split
parameter_list|(
specifier|const
name|QString
modifier|&
name|sep
parameter_list|,
name|QString
operator|::
name|SplitBehavior
name|behavior
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|splitString
argument_list|<
name|QVector
argument_list|<
name|QStringRef
argument_list|>
argument_list|>
argument_list|(
operator|*
name|this
argument_list|,
name|sep
operator|.
name|constData
argument_list|()
argument_list|,
name|behavior
argument_list|,
name|cs
argument_list|,
name|sep
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 5.4 */
end_comment
begin_function
DECL|function|split
name|QVector
argument_list|<
name|QStringRef
argument_list|>
name|QStringRef
operator|::
name|split
parameter_list|(
name|QChar
name|sep
parameter_list|,
name|QString
operator|::
name|SplitBehavior
name|behavior
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|splitString
argument_list|<
name|QVector
argument_list|<
name|QStringRef
argument_list|>
argument_list|>
argument_list|(
operator|*
name|this
argument_list|,
operator|&
name|sep
argument_list|,
name|behavior
argument_list|,
name|cs
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_namespace
namespace|namespace
block|{
template|template
parameter_list|<
name|class
name|ResultList
parameter_list|,
name|typename
name|MidMethod
parameter_list|>
DECL|function|splitString
specifier|static
name|ResultList
name|splitString
parameter_list|(
specifier|const
name|QString
modifier|&
name|source
parameter_list|,
name|MidMethod
name|mid
parameter_list|,
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|QString
operator|::
name|SplitBehavior
name|behavior
parameter_list|)
block|{
name|QRegExp
name|rx2
argument_list|(
name|rx
argument_list|)
decl_stmt|;
name|ResultList
name|list
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|int
name|end
decl_stmt|;
while|while
condition|(
operator|(
name|end
operator|=
name|rx2
operator|.
name|indexIn
argument_list|(
name|source
argument_list|,
name|start
operator|+
name|extra
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|matchedLen
init|=
name|rx2
operator|.
name|matchedLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|start
operator|!=
name|end
operator|||
name|behavior
operator|==
name|QString
operator|::
name|KeepEmptyParts
condition|)
name|list
operator|.
name|append
argument_list|(
call|(
name|source
operator|.*
name|mid
call|)
argument_list|(
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|end
operator|+
name|matchedLen
expr_stmt|;
name|extra
operator|=
operator|(
name|matchedLen
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|source
operator|.
name|size
argument_list|()
operator|||
name|behavior
operator|==
name|QString
operator|::
name|KeepEmptyParts
condition|)
name|list
operator|.
name|append
argument_list|(
call|(
name|source
operator|.*
name|mid
call|)
argument_list|(
name|start
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_comment
comment|/*!     \overload      Splits the string into substrings wherever the regular expression     \a rx matches, and returns the list of those strings. If \a rx     does not match anywhere in the string, split() returns a     single-element list containing this string.      Here's an example where we extract the words in a sentence     using one or more whitespace characters as the separator:      \snippet qstring/main.cpp 59      Here's a similar example, but this time we use any sequence of     non-word characters as the separator:      \snippet qstring/main.cpp 60      Here's a third example where we use a zero-length assertion,     \b{\\b} (word boundary), to split the string into an     alternating sequence of non-word and word tokens:      \snippet qstring/main.cpp 61      \sa QStringList::join(), section() */
end_comment
begin_function
DECL|function|split
name|QStringList
name|QString
operator|::
name|split
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|SplitBehavior
name|behavior
parameter_list|)
specifier|const
block|{
return|return
name|splitString
argument_list|<
name|QStringList
argument_list|>
argument_list|(
operator|*
name|this
argument_list|,
operator|&
name|QString
operator|::
name|mid
argument_list|,
name|rx
argument_list|,
name|behavior
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 5.4      Splits the string into substring references wherever the regular expression     \a rx matches, and returns the list of those strings. If \a rx     does not match anywhere in the string, splitRef() returns a     single-element vector containing this string reference.      \note All references are valid as long this string is alive. Destroying this     string will cause all references be dangling pointers.      \sa QStringRef split() */
end_comment
begin_function
DECL|function|splitRef
name|QVector
argument_list|<
name|QStringRef
argument_list|>
name|QString
operator|::
name|splitRef
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|,
name|SplitBehavior
name|behavior
parameter_list|)
specifier|const
block|{
return|return
name|splitString
argument_list|<
name|QVector
argument_list|<
name|QStringRef
argument_list|>
argument_list|>
argument_list|(
operator|*
name|this
argument_list|,
operator|&
name|QString
operator|::
name|midRef
argument_list|,
name|rx
argument_list|,
name|behavior
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGULAREXPRESSION
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_namespace
namespace|namespace
block|{
template|template
parameter_list|<
name|class
name|ResultList
parameter_list|,
name|typename
name|MidMethod
parameter_list|>
DECL|function|splitString
specifier|static
name|ResultList
name|splitString
parameter_list|(
specifier|const
name|QString
modifier|&
name|source
parameter_list|,
name|MidMethod
name|mid
parameter_list|,
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
name|QString
operator|::
name|SplitBehavior
name|behavior
parameter_list|)
block|{
name|ResultList
name|list
decl_stmt|;
if|if
condition|(
operator|!
name|re
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QString::split: invalid QRegularExpression object"
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
name|int
name|start
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
literal|0
decl_stmt|;
name|QRegularExpressionMatchIterator
name|iterator
init|=
name|re
operator|.
name|globalMatch
argument_list|(
name|source
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|QRegularExpressionMatch
name|match
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|end
operator|=
name|match
operator|.
name|capturedStart
argument_list|()
expr_stmt|;
if|if
condition|(
name|start
operator|!=
name|end
operator|||
name|behavior
operator|==
name|QString
operator|::
name|KeepEmptyParts
condition|)
name|list
operator|.
name|append
argument_list|(
call|(
name|source
operator|.*
name|mid
call|)
argument_list|(
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|match
operator|.
name|capturedEnd
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|source
operator|.
name|size
argument_list|()
operator|||
name|behavior
operator|==
name|QString
operator|::
name|KeepEmptyParts
condition|)
name|list
operator|.
name|append
argument_list|(
call|(
name|source
operator|.*
name|mid
call|)
argument_list|(
name|start
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_comment
comment|/*!     \overload     \since 5.0      Splits the string into substrings wherever the regular expression     \a re matches, and returns the list of those strings. If \a re     does not match anywhere in the string, split() returns a     single-element list containing this string.      Here's an example where we extract the words in a sentence     using one or more whitespace characters as the separator:      \snippet qstring/main.cpp 90      Here's a similar example, but this time we use any sequence of     non-word characters as the separator:      \snippet qstring/main.cpp 91      Here's a third example where we use a zero-length assertion,     \b{\\b} (word boundary), to split the string into an     alternating sequence of non-word and word tokens:      \snippet qstring/main.cpp 92      \sa QStringList::join(), section() */
end_comment
begin_function
DECL|function|split
name|QStringList
name|QString
operator|::
name|split
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
name|SplitBehavior
name|behavior
parameter_list|)
specifier|const
block|{
return|return
name|splitString
argument_list|<
name|QStringList
argument_list|>
argument_list|(
operator|*
name|this
argument_list|,
operator|&
name|QString
operator|::
name|mid
argument_list|,
name|re
argument_list|,
name|behavior
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 5.4      Splits the string into substring references wherever the regular expression     \a re matches, and returns the list of those strings. If \a re     does not match anywhere in the string, splitRef() returns a     single-element vector containing this string reference.      \note All references are valid as long this string is alive. Destroying this     string will cause all references be dangling pointers.      \sa split() QStringRef */
end_comment
begin_function
DECL|function|splitRef
name|QVector
argument_list|<
name|QStringRef
argument_list|>
name|QString
operator|::
name|splitRef
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
name|SplitBehavior
name|behavior
parameter_list|)
specifier|const
block|{
return|return
name|splitString
argument_list|<
name|QVector
argument_list|<
name|QStringRef
argument_list|>
argument_list|>
argument_list|(
operator|*
name|this
argument_list|,
operator|&
name|QString
operator|::
name|midRef
argument_list|,
name|re
argument_list|,
name|behavior
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BOOTSTRAPPED
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGULAREXPRESSION
end_comment
begin_comment
comment|/*!     \enum QString::NormalizationForm      This enum describes the various normalized forms of Unicode text.      \value NormalizationForm_D  Canonical Decomposition     \value NormalizationForm_C  Canonical Decomposition followed by Canonical Composition     \value NormalizationForm_KD  Compatibility Decomposition     \value NormalizationForm_KC  Compatibility Decomposition followed by Canonical Composition      \sa normalized(),         {http://www.unicode.org/reports/tr15/}{Unicode Standard Annex #15} */
end_comment
begin_comment
comment|/*!     \since 4.5      Returns a copy of this string repeated the specified number of \a times.      If \a times is less than 1, an empty string is returned.      Example:      \code         QString str("ab");         str.repeated(4);            // returns "abababab"     \endcode */
end_comment
begin_function
DECL|function|repeated
name|QString
name|QString
operator|::
name|repeated
parameter_list|(
name|int
name|times
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|size
operator|==
literal|0
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|times
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|times
operator|==
literal|1
condition|)
return|return
operator|*
name|this
return|;
return|return
name|QString
argument_list|()
return|;
block|}
specifier|const
name|int
name|resultSize
init|=
name|times
operator|*
name|d
operator|->
name|size
decl_stmt|;
name|QString
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|resultSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|d
operator|->
name|alloc
operator|!=
name|uint
argument_list|(
name|resultSize
argument_list|)
operator|+
literal|1u
condition|)
return|return
name|QString
argument_list|()
return|;
comment|// not enough memory
name|memcpy
argument_list|(
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|d
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|sizeSoFar
init|=
name|d
operator|->
name|size
decl_stmt|;
name|ushort
modifier|*
name|end
init|=
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
operator|+
name|sizeSoFar
decl_stmt|;
specifier|const
name|int
name|halfResultSize
init|=
name|resultSize
operator|>>
literal|1
decl_stmt|;
while|while
condition|(
name|sizeSoFar
operator|<=
name|halfResultSize
condition|)
block|{
name|memcpy
argument_list|(
name|end
argument_list|,
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
name|sizeSoFar
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|+=
name|sizeSoFar
expr_stmt|;
name|sizeSoFar
operator|<<=
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|end
argument_list|,
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
argument_list|,
operator|(
name|resultSize
operator|-
name|sizeSoFar
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|data
argument_list|()
index|[
name|resultSize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|size
operator|=
name|resultSize
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|qt_string_normalize
name|void
name|qt_string_normalize
parameter_list|(
name|QString
modifier|*
name|data
parameter_list|,
name|QString
operator|::
name|NormalizationForm
name|mode
parameter_list|,
name|QChar
operator|::
name|UnicodeVersion
name|version
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|bool
name|simple
init|=
literal|true
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|p
init|=
name|data
operator|->
name|constData
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|data
operator|->
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
operator|>=
literal|0x80
condition|)
block|{
name|simple
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|from
condition|)
name|from
operator|=
name|i
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|simple
condition|)
return|return;
if|if
condition|(
name|version
operator|==
name|QChar
operator|::
name|Unicode_Unassigned
condition|)
block|{
name|version
operator|=
name|QChar
operator|::
name|currentUnicodeVersion
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|int
argument_list|(
name|version
argument_list|)
operator|<=
name|NormalizationCorrectionsVersionMax
condition|)
block|{
specifier|const
name|QString
modifier|&
name|s
init|=
operator|*
name|data
decl_stmt|;
name|QChar
modifier|*
name|d
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumNormalizationCorrections
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|NormalizationCorrection
modifier|&
name|n
init|=
name|uc_normalization_corrections
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|.
name|version
operator|>
name|version
condition|)
block|{
name|int
name|pos
init|=
name|from
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|requiresSurrogates
argument_list|(
name|n
operator|.
name|ucs4
argument_list|)
condition|)
block|{
name|ushort
name|ucs4High
init|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|n
operator|.
name|ucs4
argument_list|)
decl_stmt|;
name|ushort
name|ucs4Low
init|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|n
operator|.
name|ucs4
argument_list|)
decl_stmt|;
name|ushort
name|oldHigh
init|=
name|QChar
operator|::
name|highSurrogate
argument_list|(
name|n
operator|.
name|old_mapping
argument_list|)
decl_stmt|;
name|ushort
name|oldLow
init|=
name|QChar
operator|::
name|lowSurrogate
argument_list|(
name|n
operator|.
name|old_mapping
argument_list|)
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|.
name|unicode
argument_list|()
operator|==
name|ucs4High
operator|&&
name|s
operator|.
name|at
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|.
name|unicode
argument_list|()
operator|==
name|ucs4Low
condition|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
name|data
operator|->
name|data
argument_list|()
expr_stmt|;
name|d
index|[
name|pos
index|]
operator|=
name|QChar
argument_list|(
name|oldHigh
argument_list|)
expr_stmt|;
name|d
index|[
operator|++
name|pos
index|]
operator|=
name|QChar
argument_list|(
name|oldLow
argument_list|)
expr_stmt|;
block|}
operator|++
name|pos
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|pos
operator|<
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|.
name|unicode
argument_list|()
operator|==
name|n
operator|.
name|ucs4
condition|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
name|data
operator|->
name|data
argument_list|()
expr_stmt|;
name|d
index|[
name|pos
index|]
operator|=
name|QChar
argument_list|(
name|n
operator|.
name|old_mapping
argument_list|)
expr_stmt|;
block|}
operator|++
name|pos
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|normalizationQuickCheckHelper
argument_list|(
name|data
argument_list|,
name|mode
argument_list|,
name|from
argument_list|,
operator|&
name|from
argument_list|)
condition|)
return|return;
name|decomposeHelper
argument_list|(
name|data
argument_list|,
name|mode
operator|<
name|QString
operator|::
name|NormalizationForm_KD
argument_list|,
name|version
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|canonicalOrderHelper
argument_list|(
name|data
argument_list|,
name|version
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|QString
operator|::
name|NormalizationForm_D
operator|||
name|mode
operator|==
name|QString
operator|::
name|NormalizationForm_KD
condition|)
return|return;
name|composeHelper
argument_list|(
name|data
argument_list|,
name|version
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the string in the given Unicode normalization \a mode,     according to the given \a version of the Unicode standard. */
end_comment
begin_function
DECL|function|normalized
name|QString
name|QString
operator|::
name|normalized
parameter_list|(
name|QString
operator|::
name|NormalizationForm
name|mode
parameter_list|,
name|QChar
operator|::
name|UnicodeVersion
name|version
parameter_list|)
specifier|const
block|{
name|QString
name|copy
init|=
operator|*
name|this
decl_stmt|;
name|qt_string_normalize
argument_list|(
operator|&
name|copy
argument_list|,
name|mode
argument_list|,
name|version
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function
begin_struct
DECL|struct|ArgEscapeData
struct|struct
name|ArgEscapeData
block|{
DECL|member|min_escape
name|int
name|min_escape
decl_stmt|;
comment|// lowest escape sequence number
DECL|member|occurrences
name|int
name|occurrences
decl_stmt|;
comment|// number of occurrences of the lowest escape sequence number
DECL|member|locale_occurrences
name|int
name|locale_occurrences
decl_stmt|;
comment|// number of occurrences of the lowest escape sequence number that
comment|// contain 'L'
DECL|member|escape_len
name|int
name|escape_len
decl_stmt|;
comment|// total length of escape sequences which will be replaced
block|}
struct|;
end_struct
begin_function
DECL|function|findArgEscapes
specifier|static
name|ArgEscapeData
name|findArgEscapes
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
specifier|const
name|QChar
modifier|*
name|uc_begin
init|=
name|s
operator|.
name|unicode
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|uc_end
init|=
name|uc_begin
operator|+
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
name|ArgEscapeData
name|d
decl_stmt|;
name|d
operator|.
name|min_escape
operator|=
name|INT_MAX
expr_stmt|;
name|d
operator|.
name|occurrences
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|escape_len
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|locale_occurrences
operator|=
literal|0
expr_stmt|;
specifier|const
name|QChar
modifier|*
name|c
init|=
name|uc_begin
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|uc_end
condition|)
block|{
while|while
condition|(
name|c
operator|!=
name|uc_end
operator|&&
name|c
operator|->
name|unicode
argument_list|()
operator|!=
literal|'%'
condition|)
operator|++
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|uc_end
condition|)
break|break;
specifier|const
name|QChar
modifier|*
name|escape_start
init|=
name|c
decl_stmt|;
if|if
condition|(
operator|++
name|c
operator|==
name|uc_end
condition|)
break|break;
name|bool
name|locale_arg
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|unicode
argument_list|()
operator|==
literal|'L'
condition|)
block|{
name|locale_arg
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|++
name|c
operator|==
name|uc_end
condition|)
break|break;
block|}
name|int
name|escape
init|=
name|c
operator|->
name|digitValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|escape
operator|==
operator|-
literal|1
condition|)
continue|continue;
operator|++
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|uc_end
condition|)
block|{
name|int
name|next_escape
init|=
name|c
operator|->
name|digitValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|next_escape
operator|!=
operator|-
literal|1
condition|)
block|{
name|escape
operator|=
operator|(
literal|10
operator|*
name|escape
operator|)
operator|+
name|next_escape
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|escape
operator|>
name|d
operator|.
name|min_escape
condition|)
continue|continue;
if|if
condition|(
name|escape
operator|<
name|d
operator|.
name|min_escape
condition|)
block|{
name|d
operator|.
name|min_escape
operator|=
name|escape
expr_stmt|;
name|d
operator|.
name|occurrences
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|escape_len
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|locale_occurrences
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|d
operator|.
name|occurrences
expr_stmt|;
if|if
condition|(
name|locale_arg
condition|)
operator|++
name|d
operator|.
name|locale_occurrences
expr_stmt|;
name|d
operator|.
name|escape_len
operator|+=
name|c
operator|-
name|escape_start
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|replaceArgEscapes
specifier|static
name|QString
name|replaceArgEscapes
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
specifier|const
name|ArgEscapeData
modifier|&
name|d
parameter_list|,
name|int
name|field_width
parameter_list|,
specifier|const
name|QString
modifier|&
name|arg
parameter_list|,
specifier|const
name|QString
modifier|&
name|larg
parameter_list|,
name|QChar
name|fillChar
init|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
parameter_list|)
block|{
specifier|const
name|QChar
modifier|*
name|uc_begin
init|=
name|s
operator|.
name|unicode
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|uc_end
init|=
name|uc_begin
operator|+
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|abs_field_width
init|=
name|qAbs
argument_list|(
name|field_width
argument_list|)
decl_stmt|;
name|int
name|result_len
init|=
name|s
operator|.
name|length
argument_list|()
operator|-
name|d
operator|.
name|escape_len
operator|+
operator|(
name|d
operator|.
name|occurrences
operator|-
name|d
operator|.
name|locale_occurrences
operator|)
operator|*
name|qMax
argument_list|(
name|abs_field_width
argument_list|,
name|arg
operator|.
name|length
argument_list|()
argument_list|)
operator|+
name|d
operator|.
name|locale_occurrences
operator|*
name|qMax
argument_list|(
name|abs_field_width
argument_list|,
name|larg
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|result
argument_list|(
name|result_len
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|QChar
modifier|*
name|result_buff
init|=
operator|(
name|QChar
operator|*
operator|)
name|result
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|QChar
modifier|*
name|rc
init|=
name|result_buff
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|c
init|=
name|uc_begin
decl_stmt|;
name|int
name|repl_cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|c
operator|!=
name|uc_end
condition|)
block|{
comment|/* We don't have to check if we run off the end of the string with c,            because as long as d.occurrences> 0 we KNOW there are valid escape            sequences. */
specifier|const
name|QChar
modifier|*
name|text_start
init|=
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|->
name|unicode
argument_list|()
operator|!=
literal|'%'
condition|)
operator|++
name|c
expr_stmt|;
specifier|const
name|QChar
modifier|*
name|escape_start
init|=
name|c
operator|++
decl_stmt|;
name|bool
name|locale_arg
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|unicode
argument_list|()
operator|==
literal|'L'
condition|)
block|{
name|locale_arg
operator|=
literal|true
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|int
name|escape
init|=
name|c
operator|->
name|digitValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|escape
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|+
literal|1
operator|!=
name|uc_end
operator|&&
operator|(
name|c
operator|+
literal|1
operator|)
operator|->
name|digitValue
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|escape
operator|=
operator|(
literal|10
operator|*
name|escape
operator|)
operator|+
operator|(
name|c
operator|+
literal|1
operator|)
operator|->
name|digitValue
argument_list|()
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|escape
operator|!=
name|d
operator|.
name|min_escape
condition|)
block|{
name|memcpy
argument_list|(
name|rc
argument_list|,
name|text_start
argument_list|,
operator|(
name|c
operator|-
name|text_start
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|+=
name|c
operator|-
name|text_start
expr_stmt|;
block|}
else|else
block|{
operator|++
name|c
expr_stmt|;
name|memcpy
argument_list|(
name|rc
argument_list|,
name|text_start
argument_list|,
operator|(
name|escape_start
operator|-
name|text_start
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|+=
name|escape_start
operator|-
name|text_start
expr_stmt|;
name|uint
name|pad_chars
decl_stmt|;
if|if
condition|(
name|locale_arg
condition|)
name|pad_chars
operator|=
name|qMax
argument_list|(
name|abs_field_width
argument_list|,
name|larg
operator|.
name|length
argument_list|()
argument_list|)
operator|-
name|larg
operator|.
name|length
argument_list|()
expr_stmt|;
else|else
name|pad_chars
operator|=
name|qMax
argument_list|(
name|abs_field_width
argument_list|,
name|arg
operator|.
name|length
argument_list|()
argument_list|)
operator|-
name|arg
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|field_width
operator|>
literal|0
condition|)
block|{
comment|// left padded
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pad_chars
condition|;
operator|++
name|i
control|)
operator|(
name|rc
operator|++
operator|)
operator|->
name|unicode
argument_list|()
operator|=
name|fillChar
operator|.
name|unicode
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|locale_arg
condition|)
block|{
name|memcpy
argument_list|(
name|rc
argument_list|,
name|larg
operator|.
name|unicode
argument_list|()
argument_list|,
name|larg
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|+=
name|larg
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|rc
argument_list|,
name|arg
operator|.
name|unicode
argument_list|()
argument_list|,
name|arg
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|+=
name|arg
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|field_width
operator|<
literal|0
condition|)
block|{
comment|// right padded
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pad_chars
condition|;
operator|++
name|i
control|)
operator|(
name|rc
operator|++
operator|)
operator|->
name|unicode
argument_list|()
operator|=
name|fillChar
operator|.
name|unicode
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|repl_cnt
operator|==
name|d
operator|.
name|occurrences
condition|)
block|{
name|memcpy
argument_list|(
name|rc
argument_list|,
name|c
argument_list|,
operator|(
name|uc_end
operator|-
name|c
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|+=
name|uc_end
operator|-
name|c
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|rc
operator|-
name|result_buff
operator|==
name|result_len
argument_list|)
expr_stmt|;
name|c
operator|=
name|uc_end
expr_stmt|;
block|}
block|}
block|}
name|Q_ASSERT
argument_list|(
name|rc
operator|==
name|result_buff
operator|+
name|result_len
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a copy of this string with the lowest numbered place marker   replaced by string \a a, i.e., \c %1, \c %2, ..., \c %99.    \a fieldWidth specifies the minimum amount of space that argument \a   a shall occupy. If \a a requires less space than \a fieldWidth, it   is padded to \a fieldWidth with character \a fillChar.  A positive   \a fieldWidth produces right-aligned text. A negative \a fieldWidth   produces left-aligned text.    This example shows how we might create a \c status string for   reporting progress while processing a list of files:    \snippet qstring/main.cpp 11    First, \c arg(i) replaces \c %1. Then \c arg(total) replaces \c   %2. Finally, \c arg(fileName) replaces \c %3.    One advantage of using arg() over asprintf() is that the order of the   numbered place markers can change, if the application's strings are   translated into other languages, but each arg() will still replace   the lowest numbered unreplaced place marker, no matter where it   appears. Also, if place marker \c %i appears more than once in the   string, the arg() replaces all of them.    If there is no unreplaced place marker remaining, a warning message   is output and the result is undefined. Place marker numbers must be   in the range 1 to 99. */
end_comment
begin_function
DECL|function|arg
name|QString
name|QString
operator|::
name|arg
parameter_list|(
specifier|const
name|QString
modifier|&
name|a
parameter_list|,
name|int
name|fieldWidth
parameter_list|,
name|QChar
name|fillChar
parameter_list|)
specifier|const
block|{
name|ArgEscapeData
name|d
init|=
name|findArgEscapes
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|occurrences
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QString::arg: Argument missing: %s, %s"
argument_list|,
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|a
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
return|return
name|replaceArgEscapes
argument_list|(
operator|*
name|this
argument_list|,
name|d
argument_list|,
name|fieldWidth
argument_list|,
name|a
argument_list|,
name|a
argument_list|,
name|fillChar
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \fn QString QString::arg(const QString& a1, const QString& a2) const   \overload arg()    This is the same as \c {str.arg(a1).arg(a2)}, except that the   strings \a a1 and \a a2 are replaced in one pass. This can make a   difference if \a a1 contains e.g. \c{%1}:    \snippet qstring/main.cpp 13    A similar problem occurs when the numbered place markers are not   white space separated:    \snippet qstring/main.cpp 12   \snippet qstring/main.cpp 97    Let's look at the substitutions:   \list   \li First, \c Hello replaces \c {%1} so the string becomes \c {"Hello%3%2"}.   \li Then, \c 20 replaces \c {%2} so the string becomes \c {"Hello%320"}.   \li Since the maximum numbered place marker value is 99, \c 50 replaces \c {%32}.   \endlist   Thus the string finally becomes \c {"Hello500"}.    In such cases, the following yields the expected results:    \snippet qstring/main.cpp 12   \snippet qstring/main.cpp 98 */
end_comment
begin_comment
comment|/*!   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3) const   \overload arg()    This is the same as calling \c str.arg(a1).arg(a2).arg(a3), except   that the strings \a a1, \a a2 and \a a3 are replaced in one pass. */
end_comment
begin_comment
comment|/*!   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4) const   \overload arg()    This is the same as calling \c   {str.arg(a1).arg(a2).arg(a3).arg(a4)}, except that the strings \a   a1, \a a2, \a a3 and \a a4 are replaced in one pass. */
end_comment
begin_comment
comment|/*!   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5) const   \overload arg()    This is the same as calling \c   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)}, except that the strings   \a a1, \a a2, \a a3, \a a4, and \a a5 are replaced in one pass. */
end_comment
begin_comment
comment|/*!   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5, const QString& a6) const   \overload arg()    This is the same as calling \c   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))}, except that   the strings \a a1, \a a2, \a a3, \a a4, \a a5, and \a a6 are   replaced in one pass. */
end_comment
begin_comment
comment|/*!   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5, const QString& a6, const QString& a7) const   \overload arg()    This is the same as calling \c   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)},   except that the strings \a a1, \a a2, \a a3, \a a4, \a a5, \a a6,   and \a a7 are replaced in one pass. */
end_comment
begin_comment
comment|/*!   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5, const QString& a6, const QString& a7, const QString& a8) const   \overload arg()    This is the same as calling \c   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)},   except that the strings \a a1, \a a2, \a a3, \a a4, \a a5, \a a6, \a   a7, and \a a8 are replaced in one pass. */
end_comment
begin_comment
comment|/*!   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5, const QString& a6, const QString& a7, const QString& a8, const QString& a9) const   \overload arg()    This is the same as calling \c   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)},   except that the strings \a a1, \a a2, \a a3, \a a4, \a a5, \a a6, \a   a7, \a a8, and \a a9 are replaced in one pass. */
end_comment
begin_comment
comment|/*! \fn QString QString::arg(int a, int fieldWidth, int base, QChar fillChar) const   \overload arg()    The \a a argument is expressed in base \a base, which is 10 by   default and must be between 2 and 36. For bases other than 10, \a a   is treated as an unsigned integer.    \a fieldWidth specifies the minimum amount of space that \a a is   padded to and filled with the character \a fillChar. A positive   value produces right-aligned text; a negative value produces   left-aligned text.    The '%' can be followed by an 'L', in which case the sequence is   replaced with a localized representation of \a a. The conversion   uses the default locale, set by QLocale::setDefault(). If no default   locale was specified, the "C" locale is used. The 'L' flag is   ignored if \a base is not 10.    \snippet qstring/main.cpp 12   \snippet qstring/main.cpp 14    If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is   used. For negative numbers, zero padding might appear before the   minus sign. */
end_comment
begin_comment
comment|/*! \fn QString QString::arg(uint a, int fieldWidth, int base, QChar fillChar) const   \overload arg()    The \a base argument specifies the base to use when converting the   integer \a a into a string. The base must be between 2 and 36.    If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is   used. For negative numbers, zero padding might appear before the   minus sign. */
end_comment
begin_comment
comment|/*! \fn QString QString::arg(long a, int fieldWidth, int base, QChar fillChar) const   \overload arg()    \a fieldWidth specifies the minimum amount of space that \a a is   padded to and filled with the character \a fillChar. A positive   value produces right-aligned text; a negative value produces   left-aligned text.    The \a a argument is expressed in the given \a base, which is 10 by   default and must be between 2 and 36.    The '%' can be followed by an 'L', in which case the sequence is   replaced with a localized representation of \a a. The conversion   uses the default locale. The default locale is determined from the   system's locale settings at application startup. It can be changed   using QLocale::setDefault(). The 'L' flag is ignored if \a base is   not 10.    \snippet qstring/main.cpp 12   \snippet qstring/main.cpp 14    If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is   used. For negative numbers, zero padding might appear before the   minus sign. */
end_comment
begin_comment
comment|/*! \fn QString QString::arg(ulong a, int fieldWidth, int base, QChar fillChar) const   \overload arg()    \a fieldWidth specifies the minimum amount of space that \a a is   padded to and filled with the character \a fillChar. A positive   value produces right-aligned text; a negative value produces   left-aligned text.    The \a base argument specifies the base to use when converting the   integer \a a to a string. The base must be between 2 and 36, with 8   giving octal, 10 decimal, and 16 hexadecimal numbers.    If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is   used. For negative numbers, zero padding might appear before the   minus sign. */
end_comment
begin_comment
comment|/*!   \overload arg()    \a fieldWidth specifies the minimum amount of space that \a a is   padded to and filled with the character \a fillChar. A positive   value produces right-aligned text; a negative value produces   left-aligned text.    The \a base argument specifies the base to use when converting the   integer \a a into a string. The base must be between 2 and 36, with   8 giving octal, 10 decimal, and 16 hexadecimal numbers.    If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is   used. For negative numbers, zero padding might appear before the   minus sign. */
end_comment
begin_function
DECL|function|arg
name|QString
name|QString
operator|::
name|arg
parameter_list|(
name|qlonglong
name|a
parameter_list|,
name|int
name|fieldWidth
parameter_list|,
name|int
name|base
parameter_list|,
name|QChar
name|fillChar
parameter_list|)
specifier|const
block|{
name|ArgEscapeData
name|d
init|=
name|findArgEscapes
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|occurrences
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QString::arg: Argument missing:"
operator|<<
operator|*
name|this
operator|<<
literal|','
operator|<<
name|a
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|unsigned
name|flags
init|=
name|QLocaleData
operator|::
name|NoFlags
decl_stmt|;
if|if
condition|(
name|fillChar
operator|==
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
condition|)
name|flags
operator|=
name|QLocaleData
operator|::
name|ZeroPadded
expr_stmt|;
name|QString
name|arg
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|occurrences
operator|>
name|d
operator|.
name|locale_occurrences
condition|)
name|arg
operator|=
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|longLongToString
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|,
name|base
argument_list|,
name|fieldWidth
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|QString
name|locale_arg
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|locale_occurrences
operator|>
literal|0
condition|)
block|{
name|QLocale
name|locale
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|locale
operator|.
name|numberOptions
argument_list|()
operator|&
name|QLocale
operator|::
name|OmitGroupSeparator
operator|)
condition|)
name|flags
operator||=
name|QLocaleData
operator|::
name|ThousandsGroup
expr_stmt|;
name|locale_arg
operator|=
name|locale
operator|.
name|d
operator|->
name|m_data
operator|->
name|longLongToString
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|,
name|base
argument_list|,
name|fieldWidth
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
name|replaceArgEscapes
argument_list|(
operator|*
name|this
argument_list|,
name|d
argument_list|,
name|fieldWidth
argument_list|,
name|arg
argument_list|,
name|locale_arg
argument_list|,
name|fillChar
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload arg()    \a fieldWidth specifies the minimum amount of space that \a a is   padded to and filled with the character \a fillChar. A positive   value produces right-aligned text; a negative value produces   left-aligned text.    The \a base argument specifies the base to use when converting the   integer \a a into a string. \a base must be between 2 and 36, with 8   giving octal, 10 decimal, and 16 hexadecimal numbers.    If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is   used. For negative numbers, zero padding might appear before the   minus sign. */
end_comment
begin_function
DECL|function|arg
name|QString
name|QString
operator|::
name|arg
parameter_list|(
name|qulonglong
name|a
parameter_list|,
name|int
name|fieldWidth
parameter_list|,
name|int
name|base
parameter_list|,
name|QChar
name|fillChar
parameter_list|)
specifier|const
block|{
name|ArgEscapeData
name|d
init|=
name|findArgEscapes
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|occurrences
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QString::arg: Argument missing:"
operator|<<
operator|*
name|this
operator|<<
literal|','
operator|<<
name|a
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|unsigned
name|flags
init|=
name|QLocaleData
operator|::
name|NoFlags
decl_stmt|;
if|if
condition|(
name|fillChar
operator|==
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
condition|)
name|flags
operator|=
name|QLocaleData
operator|::
name|ZeroPadded
expr_stmt|;
name|QString
name|arg
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|occurrences
operator|>
name|d
operator|.
name|locale_occurrences
condition|)
name|arg
operator|=
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|unsLongLongToString
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|,
name|base
argument_list|,
name|fieldWidth
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|QString
name|locale_arg
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|locale_occurrences
operator|>
literal|0
condition|)
block|{
name|QLocale
name|locale
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|locale
operator|.
name|numberOptions
argument_list|()
operator|&
name|QLocale
operator|::
name|OmitGroupSeparator
operator|)
condition|)
name|flags
operator||=
name|QLocaleData
operator|::
name|ThousandsGroup
expr_stmt|;
name|locale_arg
operator|=
name|locale
operator|.
name|d
operator|->
name|m_data
operator|->
name|unsLongLongToString
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|,
name|base
argument_list|,
name|fieldWidth
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
name|replaceArgEscapes
argument_list|(
operator|*
name|this
argument_list|,
name|d
argument_list|,
name|fieldWidth
argument_list|,
name|arg
argument_list|,
name|locale_arg
argument_list|,
name|fillChar
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload arg()    \fn QString QString::arg(short a, int fieldWidth, int base, QChar fillChar) const    \a fieldWidth specifies the minimum amount of space that \a a is   padded to and filled with the character \a fillChar. A positive   value produces right-aligned text; a negative value produces   left-aligned text.    The \a base argument specifies the base to use when converting the   integer \a a into a string. The base must be between 2 and 36, with   8 giving octal, 10 decimal, and 16 hexadecimal numbers.    If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is   used. For negative numbers, zero padding might appear before the   minus sign. */
end_comment
begin_comment
comment|/*!   \fn QString QString::arg(ushort a, int fieldWidth, int base, QChar fillChar) const   \overload arg()    \a fieldWidth specifies the minimum amount of space that \a a is   padded to and filled with the character \a fillChar. A positive   value produces right-aligned text; a negative value produces   left-aligned text.    The \a base argument specifies the base to use when converting the   integer \a a into a string. The base must be between 2 and 36, with   8 giving octal, 10 decimal, and 16 hexadecimal numbers.    If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is   used. For negative numbers, zero padding might appear before the   minus sign. */
end_comment
begin_comment
comment|/*!     \overload arg() */
end_comment
begin_function
DECL|function|arg
name|QString
name|QString
operator|::
name|arg
parameter_list|(
name|QChar
name|a
parameter_list|,
name|int
name|fieldWidth
parameter_list|,
name|QChar
name|fillChar
parameter_list|)
specifier|const
block|{
name|QString
name|c
decl_stmt|;
name|c
operator|+=
name|a
expr_stmt|;
return|return
name|arg
argument_list|(
name|c
argument_list|,
name|fieldWidth
argument_list|,
name|fillChar
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload arg()    The \a a argument is interpreted as a Latin-1 character. */
end_comment
begin_function
DECL|function|arg
name|QString
name|QString
operator|::
name|arg
parameter_list|(
name|char
name|a
parameter_list|,
name|int
name|fieldWidth
parameter_list|,
name|QChar
name|fillChar
parameter_list|)
specifier|const
block|{
name|QString
name|c
decl_stmt|;
name|c
operator|+=
name|QLatin1Char
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
name|arg
argument_list|(
name|c
argument_list|,
name|fieldWidth
argument_list|,
name|fillChar
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \fn QString QString::arg(double a, int fieldWidth, char format, int precision, QChar fillChar) const   \overload arg()    Argument \a a is formatted according to the specified \a format and   \a precision. See \l{Argument Formats} for details.    \a fieldWidth specifies the minimum amount of space that \a a is   padded to and filled with the character \a fillChar.  A positive   value produces right-aligned text; a negative value produces   left-aligned text.    \snippet code/src_corelib_tools_qstring.cpp 2    The '%' can be followed by an 'L', in which case the sequence is   replaced with a localized representation of \a a. The conversion   uses the default locale, set by QLocale::setDefault(). If no   default locale was specified, the "C" locale is used.    If \a fillChar is '0' (the number 0, ASCII 48), this function will   use the locale's zero to pad. For negative numbers, the zero padding   will probably appear before the minus sign.    \sa QLocale::toString() */
end_comment
begin_function
DECL|function|arg
name|QString
name|QString
operator|::
name|arg
parameter_list|(
name|double
name|a
parameter_list|,
name|int
name|fieldWidth
parameter_list|,
name|char
name|fmt
parameter_list|,
name|int
name|prec
parameter_list|,
name|QChar
name|fillChar
parameter_list|)
specifier|const
block|{
name|ArgEscapeData
name|d
init|=
name|findArgEscapes
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|occurrences
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QString::arg: Argument missing: %s, %g"
argument_list|,
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
name|unsigned
name|flags
init|=
name|QLocaleData
operator|::
name|NoFlags
decl_stmt|;
if|if
condition|(
name|fillChar
operator|==
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
condition|)
name|flags
operator|=
name|QLocaleData
operator|::
name|ZeroPadded
expr_stmt|;
if|if
condition|(
name|qIsUpper
argument_list|(
name|fmt
argument_list|)
condition|)
name|flags
operator||=
name|QLocaleData
operator|::
name|CapitalEorX
expr_stmt|;
name|fmt
operator|=
name|qToLower
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
name|QLocaleData
operator|::
name|DoubleForm
name|form
init|=
name|QLocaleData
operator|::
name|DFDecimal
decl_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
literal|'f'
case|:
name|form
operator|=
name|QLocaleData
operator|::
name|DFDecimal
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|form
operator|=
name|QLocaleData
operator|::
name|DFExponent
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|form
operator|=
name|QLocaleData
operator|::
name|DFSignificantDigits
expr_stmt|;
break|break;
default|default:
if|#
directive|if
name|defined
argument_list|(
name|QT_CHECK_RANGE
argument_list|)
name|qWarning
argument_list|(
literal|"QString::arg: Invalid format char '%c'"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|QString
name|arg
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|occurrences
operator|>
name|d
operator|.
name|locale_occurrences
condition|)
name|arg
operator|=
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|doubleToString
argument_list|(
name|a
argument_list|,
name|prec
argument_list|,
name|form
argument_list|,
name|fieldWidth
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|QString
name|locale_arg
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|locale_occurrences
operator|>
literal|0
condition|)
block|{
name|QLocale
name|locale
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|locale
operator|.
name|numberOptions
argument_list|()
operator|&
name|QLocale
operator|::
name|OmitGroupSeparator
operator|)
condition|)
name|flags
operator||=
name|QLocaleData
operator|::
name|ThousandsGroup
expr_stmt|;
name|locale_arg
operator|=
name|locale
operator|.
name|d
operator|->
name|m_data
operator|->
name|doubleToString
argument_list|(
name|a
argument_list|,
name|prec
argument_list|,
name|form
argument_list|,
name|fieldWidth
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
name|replaceArgEscapes
argument_list|(
operator|*
name|this
argument_list|,
name|d
argument_list|,
name|fieldWidth
argument_list|,
name|arg
argument_list|,
name|locale_arg
argument_list|,
name|fillChar
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getEscape
specifier|static
name|int
name|getEscape
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|maxNumber
init|=
literal|999
parameter_list|)
block|{
name|int
name|i
init|=
operator|*
name|pos
decl_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
operator|&&
name|uc
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'L'
argument_list|)
condition|)
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|int
name|escape
init|=
name|uc
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|escape
argument_list|)
operator|>=
literal|10U
condition|)
return|return
operator|-
literal|1
return|;
operator|++
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|int
name|digit
init|=
name|uc
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|digit
argument_list|)
operator|>=
literal|10U
condition|)
break|break;
name|escape
operator|=
operator|(
name|escape
operator|*
literal|10
operator|)
operator|+
name|digit
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|escape
operator|<=
name|maxNumber
condition|)
block|{
operator|*
name|pos
operator|=
name|i
expr_stmt|;
return|return
name|escape
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*     Algorithm for multiArg:      1. Parse the string as a sequence of verbatim text and placeholders (%L?\d{,3}).        The L is parsed and accepted for compatibility with non-multi-arg, but since        multiArg only accepts strings as replacements, the localization request can        be safely ignored.     2. The result of step (1) is a list of (string-ref,int)-tuples. The string-ref        either points at text to be copied verbatim (in which case the int is -1),        or, initially, at the textual representation of the placeholder. In that case,        the int contains the numerical number as parsed from the placeholder.     3. Next, collect all the non-negative ints found, sort them in ascending order and        remove duplicates.        3a. If the result has more entires than multiArg() was given replacement strings,            we have found placeholders we can't satisfy with replacement strings. That is            fine (there could be another .arg() call coming after this one), so just            truncate the result to the number of actual multiArg() replacement strings.        3b. If the result has less entries than multiArg() was given replacement strings,            the string is missing placeholders. This is an error that the user should be            warned about.     4. The result of step (3) is a mapping from the index of any replacement string to        placeholder number. This is the wrong way around, but since placeholder        numbers could get as large as 999, while we typically don't have more than 9        replacement strings, we trade 4K of sparsely-used memory for doing a reverse lookup        each time we need to map a placeholder number to a replacement string index        (that's a linear search; but still *much* faster than using an associative container).     5. Next, for each of the tuples found in step (1), do the following:        5a. If the int is negative, do nothing.        5b. Otherwise, if the int is found in the result of step (3) at index I, replace            the string-ref with a string-ref for the (complete) I'th replacement string.        5c. Otherwise, do nothing.     6. Concatenate all string refs into a single result string. */
end_comment
begin_namespace
namespace|namespace
block|{
DECL|struct|Part
struct|struct
name|Part
block|{
DECL|function|Part
name|Part
parameter_list|()
member_init_list|:
name|stringRef
argument_list|()
member_init_list|,
name|number
argument_list|(
literal|0
argument_list|)
block|{}
DECL|member|Q_DECL_NOTHROW
name|Part
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|num
init|=
operator|-
literal|1
parameter_list|)
name|Q_DECL_NOTHROW
public|:
DECL|member|pos
DECL|member|len
DECL|function|number
name|stringRef
argument_list|(
argument|&s
argument_list|,
argument|pos
argument_list|,
argument|len
argument_list|)
operator|,
name|number
parameter_list|(
name|num
parameter_list|)
block|{}
DECL|member|stringRef
name|QStringRef
name|stringRef
decl_stmt|;
DECL|member|number
name|int
name|number
decl_stmt|;
block|}
struct|;
block|}
end_namespace
begin_comment
comment|// unnamed namespace
end_comment
begin_class
template|template
parameter_list|<>
class|class
DECL|class|QTypeInfo
name|QTypeInfo
argument_list|<
name|Part
argument_list|>
super|:
specifier|public
name|QTypeInfoMerger
argument_list|<
name|Part
argument_list|,
name|QStringRef
argument_list|,
name|int
argument_list|>
block|{
block|}
class|;
end_class
begin_comment
DECL|class|QTypeInfo
comment|// Q_DECLARE_METATYPE
end_comment
begin_namespace
namespace|namespace
block|{
DECL|enumerator|ExpectedParts
enum|enum
block|{
name|ExpectedParts
init|=
literal|32
block|}
enum|;
DECL|typedef|ParseResult
typedef|typedef
name|QVarLengthArray
argument_list|<
name|Part
argument_list|,
name|ExpectedParts
argument_list|>
name|ParseResult
typedef|;
DECL|typedef|ArgIndexToPlaceholderMap
typedef|typedef
name|QVarLengthArray
argument_list|<
name|int
argument_list|,
name|ExpectedParts
operator|/
literal|2
argument_list|>
name|ArgIndexToPlaceholderMap
typedef|;
DECL|function|parseMultiArgFormatString
specifier|static
name|ParseResult
name|parseMultiArgFormatString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
name|ParseResult
name|result
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|uc
init|=
name|s
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|int
name|len
init|=
name|s
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|int
name|end
init|=
name|len
operator|-
literal|1
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|last
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
condition|)
block|{
name|int
name|percent
init|=
name|i
decl_stmt|;
name|int
name|number
init|=
name|getEscape
argument_list|(
name|uc
argument_list|,
operator|&
name|i
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|number
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|last
operator|!=
name|percent
condition|)
name|result
operator|.
name|push_back
argument_list|(
name|Part
argument_list|(
name|s
argument_list|,
name|last
argument_list|,
name|percent
operator|-
name|last
argument_list|)
argument_list|)
expr_stmt|;
comment|// literal text (incl. failed placeholders)
name|result
operator|.
name|push_back
argument_list|(
name|Part
argument_list|(
name|s
argument_list|,
name|percent
argument_list|,
name|i
operator|-
name|percent
argument_list|,
name|number
argument_list|)
argument_list|)
expr_stmt|;
comment|// parsed placeholder
name|last
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
block|}
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|<
name|len
condition|)
name|result
operator|.
name|push_back
argument_list|(
name|Part
argument_list|(
name|s
argument_list|,
name|last
argument_list|,
name|len
operator|-
name|last
argument_list|)
argument_list|)
expr_stmt|;
comment|// trailing literal text
return|return
name|result
return|;
block|}
DECL|function|makeArgIndexToPlaceholderMap
specifier|static
name|ArgIndexToPlaceholderMap
name|makeArgIndexToPlaceholderMap
parameter_list|(
specifier|const
name|ParseResult
modifier|&
name|parts
parameter_list|)
block|{
name|ArgIndexToPlaceholderMap
name|result
decl_stmt|;
for|for
control|(
name|ParseResult
operator|::
name|const_iterator
name|it
init|=
name|parts
operator|.
name|begin
argument_list|()
init|,
name|end
init|=
name|parts
operator|.
name|end
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|it
operator|->
name|number
operator|>=
literal|0
condition|)
name|result
operator|.
name|push_back
argument_list|(
name|it
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
name|std
operator|::
name|sort
argument_list|(
name|result
operator|.
name|begin
argument_list|()
argument_list|,
name|result
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|erase
argument_list|(
name|std
operator|::
name|unique
argument_list|(
name|result
operator|.
name|begin
argument_list|()
argument_list|,
name|result
operator|.
name|end
argument_list|()
argument_list|)
argument_list|,
name|result
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|function|resolveStringRefsAndReturnTotalSize
specifier|static
name|int
name|resolveStringRefsAndReturnTotalSize
parameter_list|(
name|ParseResult
modifier|&
name|parts
parameter_list|,
specifier|const
name|ArgIndexToPlaceholderMap
modifier|&
name|argIndexToPlaceholderMap
parameter_list|,
specifier|const
name|QString
modifier|*
name|args
index|[]
parameter_list|)
block|{
name|int
name|totalSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ParseResult
operator|::
name|iterator
name|pit
init|=
name|parts
operator|.
name|begin
argument_list|()
init|,
name|end
init|=
name|parts
operator|.
name|end
argument_list|()
init|;
name|pit
operator|!=
name|end
condition|;
operator|++
name|pit
control|)
block|{
if|if
condition|(
name|pit
operator|->
name|number
operator|!=
operator|-
literal|1
condition|)
block|{
specifier|const
name|ArgIndexToPlaceholderMap
operator|::
name|const_iterator
name|ait
init|=
name|std
operator|::
name|find
argument_list|(
name|argIndexToPlaceholderMap
operator|.
name|begin
argument_list|()
argument_list|,
name|argIndexToPlaceholderMap
operator|.
name|end
argument_list|()
argument_list|,
name|pit
operator|->
name|number
argument_list|)
decl_stmt|;
if|if
condition|(
name|ait
operator|!=
name|argIndexToPlaceholderMap
operator|.
name|end
argument_list|()
condition|)
name|pit
operator|->
name|stringRef
operator|=
name|QStringRef
argument_list|(
name|args
index|[
name|ait
operator|-
name|argIndexToPlaceholderMap
operator|.
name|begin
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
name|totalSize
operator|+=
name|pit
operator|->
name|stringRef
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|totalSize
return|;
block|}
block|}
end_namespace
begin_comment
comment|// unnamed namespace
end_comment
begin_function
DECL|function|multiArg
name|QString
name|QString
operator|::
name|multiArg
parameter_list|(
name|int
name|numArgs
parameter_list|,
specifier|const
name|QString
modifier|*
modifier|*
name|args
parameter_list|)
specifier|const
block|{
comment|// Step 1-2 above
name|ParseResult
name|parts
init|=
name|parseMultiArgFormatString
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
comment|// 3-4
name|ArgIndexToPlaceholderMap
name|argIndexToPlaceholderMap
init|=
name|makeArgIndexToPlaceholderMap
argument_list|(
name|parts
argument_list|)
decl_stmt|;
if|if
condition|(
name|argIndexToPlaceholderMap
operator|.
name|size
argument_list|()
operator|>
name|numArgs
condition|)
comment|// 3a
name|argIndexToPlaceholderMap
operator|.
name|resize
argument_list|(
name|numArgs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argIndexToPlaceholderMap
operator|.
name|size
argument_list|()
operator|<
name|numArgs
condition|)
comment|// 3b
name|qWarning
argument_list|(
literal|"QString::arg: %d argument(s) missing in %s"
argument_list|,
name|numArgs
operator|-
name|argIndexToPlaceholderMap
operator|.
name|size
argument_list|()
argument_list|,
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
comment|// 5
specifier|const
name|int
name|totalSize
init|=
name|resolveStringRefsAndReturnTotalSize
argument_list|(
name|parts
argument_list|,
name|argIndexToPlaceholderMap
argument_list|,
name|args
argument_list|)
decl_stmt|;
comment|// 6:
name|QString
name|result
argument_list|(
name|totalSize
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|QChar
modifier|*
name|out
init|=
name|result
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|ParseResult
operator|::
name|const_iterator
name|it
init|=
name|parts
operator|.
name|begin
argument_list|()
init|,
name|end
init|=
name|parts
operator|.
name|end
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
specifier|const
name|int
name|sz
init|=
name|it
operator|->
name|stringRef
operator|.
name|size
argument_list|()
condition|)
block|{
name|memcpy
argument_list|(
name|out
argument_list|,
name|it
operator|->
name|stringRef
operator|.
name|constData
argument_list|()
argument_list|,
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|+=
name|sz
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*! \fn QString QString::fromCFString(CFStringRef string)     \since 5.2      Constructs a new QString containing a copy of the \a string CFString.      \note this function is only available on OS X and iOS. */
end_comment
begin_comment
comment|/*! \fn CFStringRef QString::toCFString() const     \since 5.2      Creates a CFString from a QString. The caller owns the CFString and is     responsible for releasing it.      \note this function is only available on OS X and iOS. */
end_comment
begin_comment
comment|/*! \fn QString QString::fromNSString(const NSString *string)     \since 5.2      Constructs a new QString containing a copy of the \a string NSString.      \note this function is only available on OS X and iOS. */
end_comment
begin_comment
comment|/*! \fn NSString QString::toNSString() const     \since 5.2      Creates a NSString from a QString. The NSString is autoreleased.      \note this function is only available on OS X and iOS. */
end_comment
begin_comment
comment|/*! \fn bool QString::isSimpleText() const      \internal */
end_comment
begin_function
DECL|function|isSimpleText
name|bool
name|QString
operator|::
name|isSimpleText
parameter_list|()
specifier|const
block|{
specifier|const
name|ushort
modifier|*
name|p
init|=
name|d
operator|->
name|data
argument_list|()
decl_stmt|;
specifier|const
name|ushort
modifier|*
specifier|const
name|end
init|=
name|p
operator|+
name|d
operator|->
name|size
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|ushort
name|uc
init|=
operator|*
name|p
decl_stmt|;
comment|// sort out regions of complex text formatting
if|if
condition|(
name|uc
operator|>
literal|0x058f
operator|&&
operator|(
name|uc
argument_list|<
literal|0x1100
operator|||
name|uc
argument_list|>
literal|0xfb0f
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QString::isRightToLeft() const      Returns \c true if the string is read right to left. */
end_comment
begin_function
DECL|function|isRightToLeft
name|bool
name|QString
operator|::
name|isRightToLeft
parameter_list|()
specifier|const
block|{
specifier|const
name|ushort
modifier|*
name|p
init|=
name|d
operator|->
name|data
argument_list|()
decl_stmt|;
specifier|const
name|ushort
modifier|*
specifier|const
name|end
init|=
name|p
operator|+
name|d
operator|->
name|size
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|uint
name|ucs4
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isHighSurrogate
argument_list|(
name|ucs4
argument_list|)
operator|&&
name|p
operator|<
name|end
operator|-
literal|1
condition|)
block|{
name|ushort
name|low
init|=
name|p
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|QChar
operator|::
name|isLowSurrogate
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|ucs4
operator|=
name|QChar
operator|::
name|surrogateToUcs4
argument_list|(
name|ucs4
argument_list|,
name|low
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|QChar
operator|::
name|direction
argument_list|(
name|ucs4
argument_list|)
condition|)
block|{
case|case
name|QChar
operator|::
name|DirL
case|:
return|return
literal|false
return|;
case|case
name|QChar
operator|::
name|DirR
case|:
case|case
name|QChar
operator|::
name|DirAL
case|:
return|return
literal|true
return|;
default|default:
break|break;
block|}
operator|++
name|p
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*! \fn QChar *QString::data()      Returns a pointer to the data stored in the QString. The pointer     can be used to access and modify the characters that compose the     string. For convenience, the data is '\\0'-terminated.      Example:      \snippet qstring/main.cpp 19      Note that the pointer remains valid only as long as the string is     not modified by other means. For read-only access, constData() is     faster because it never causes a \l{deep copy} to occur.      \sa constData(), operator[]() */
end_comment
begin_comment
comment|/*! \fn const QChar *QString::data() const      \overload */
end_comment
begin_comment
comment|/*! \fn const QChar *QString::constData() const      Returns a pointer to the data stored in the QString. The pointer     can be used to access the characters that compose the string. For     convenience, the data is '\\0'-terminated.      Note that the pointer remains valid only as long as the string is     not modified.      \sa data(), operator[]() */
end_comment
begin_comment
comment|/*! \fn void QString::push_front(const QString&other)      This function is provided for STL compatibility, prepending the     given \a other string to the beginning of this string. It is     equivalent to \c prepend(other).      \sa prepend() */
end_comment
begin_comment
comment|/*! \fn void QString::push_front(QChar ch)      \overload      Prepends the given \a ch character to the beginning of this string. */
end_comment
begin_comment
comment|/*! \fn void QString::push_back(const QString&other)      This function is provided for STL compatibility, appending the     given \a other string onto the end of this string. It is     equivalent to \c append(other).      \sa append() */
end_comment
begin_comment
comment|/*! \fn void QString::push_back(QChar ch)      \overload      Appends the given \a ch character onto the end of this string. */
end_comment
begin_comment
comment|/*!     \fn std::string QString::toStdString() const      Returns a std::string object with the data contained in this     QString. The Unicode data is converted into 8-bit characters using     the toUtf8() function.      This method is mostly useful to pass a QString to a function     that accepts a std::string object.      \sa toLatin1(), toUtf8(), toLocal8Bit(), QByteArray::toStdString() */
end_comment
begin_comment
comment|/*!     Constructs a QString that uses the first \a size Unicode characters     in the array \a unicode. The data in \a unicode is \e not     copied. The caller must be able to guarantee that \a unicode will     not be deleted or modified as long as the QString (or an     unmodified copy of it) exists.      Any attempts to modify the QString or copies of it will cause it     to create a deep copy of the data, ensuring that the raw data     isn't modified.      Here's an example of how we can use a QRegExp on raw data in     memory without requiring to copy the data into a QString:      \snippet qstring/main.cpp 22     \snippet qstring/main.cpp 23      \warning A string created with fromRawData() is \e not     '\\0'-terminated, unless the raw data contains a '\\0' character     at position \a size. This means unicode() will \e not return a     '\\0'-terminated string (although utf16() does, at the cost of     copying the raw data).      \sa fromUtf16(), setRawData() */
end_comment
begin_function
DECL|function|fromRawData
name|QString
name|QString
operator|::
name|fromRawData
parameter_list|(
specifier|const
name|QChar
modifier|*
name|unicode
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|Data
modifier|*
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|unicode
condition|)
block|{
name|x
operator|=
name|Data
operator|::
name|sharedNull
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|x
operator|=
name|Data
operator|::
name|allocate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|Data
operator|::
name|fromRawData
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|unicode
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|QStringDataPtr
name|dataPtr
init|=
block|{
name|x
block|}
decl_stmt|;
return|return
name|QString
argument_list|(
name|dataPtr
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Resets the QString to use the first \a size Unicode characters     in the array \a unicode. The data in \a unicode is \e not     copied. The caller must be able to guarantee that \a unicode will     not be deleted or modified as long as the QString (or an     unmodified copy of it) exists.      This function can be used instead of fromRawData() to re-use     existings QString objects to save memory re-allocations.      \sa fromRawData() */
end_comment
begin_function
DECL|function|setRawData
name|QString
modifier|&
name|QString
operator|::
name|setRawData
parameter_list|(
specifier|const
name|QChar
modifier|*
name|unicode
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|isShared
argument_list|()
operator|||
name|d
operator|->
name|alloc
condition|)
block|{
operator|*
name|this
operator|=
name|fromRawData
argument_list|(
name|unicode
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|unicode
condition|)
block|{
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|d
operator|->
name|offset
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|unicode
argument_list|)
operator|-
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|offset
operator|=
sizeof|sizeof
argument_list|(
name|QStringData
argument_list|)
expr_stmt|;
name|d
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*! \fn QString QString::fromStdU16String(const std::u16string&str)     \since 5.5      Returns a copy of the \a str string. The given string is assumed     to be encoded in UTF-16.      \sa fromUtf16(), fromStdWString(), fromStdU32String() */
end_comment
begin_comment
comment|/*!     \fn std::u16string QString::toStdU16String() const     \since 5.5      Returns a std::u16string object with the data contained in this     QString. The Unicode data is the same as returned by the utf16()     method.      \sa utf16(), toStdWString(), toStdU32String() */
end_comment
begin_comment
comment|/*! \fn QString QString::fromStdU32String(const std::u32string&str)     \since 5.5      Returns a copy of the \a str string. The given string is assumed     to be encoded in UCS-4.      \sa fromUcs4(), fromStdWString(), fromStdU16String() */
end_comment
begin_comment
comment|/*!     \fn std::u32string QString::toStdU32String() const     \since 5.5      Returns a std::u32string object with the data contained in this     QString. The Unicode data is the same as returned by the toUcs4()     method.      \sa toUcs4(), toStdWString(), toStdU16String() */
end_comment
begin_comment
comment|/*! \class QLatin1String     \inmodule QtCore     \brief The QLatin1String class provides a thin wrapper around an US-ASCII/Latin-1 encoded string literal.      \ingroup string-processing     \reentrant      Many of QString's member functions are overloaded to accept     \c{const char *} instead of QString. This includes the copy     constructor, the assignment operator, the comparison operators,     and various other functions such as \l{QString::insert()}{insert()}, \l{QString::replace()}{replace()},     and \l{QString::indexOf()}{indexOf()}. These functions     are usually optimized to avoid constructing a QString object for     the \c{const char *} data. For example, assuming \c str is a     QString,      \snippet code/src_corelib_tools_qstring.cpp 3      is much faster than      \snippet code/src_corelib_tools_qstring.cpp 4      because it doesn't construct four temporary QString objects and     make a deep copy of the character data.      Applications that define \c QT_NO_CAST_FROM_ASCII (as explained     in the QString documentation) don't have access to QString's     \c{const char *} API. To provide an efficient way of specifying     constant Latin-1 strings, Qt provides the QLatin1String, which is     just a very thin wrapper around a \c{const char *}. Using     QLatin1String, the example code above becomes      \snippet code/src_corelib_tools_qstring.cpp 5      This is a bit longer to type, but it provides exactly the same     benefits as the first version of the code, and is faster than     converting the Latin-1 strings using QString::fromLatin1().      Thanks to the QString(QLatin1String) constructor,     QLatin1String can be used everywhere a QString is expected. For     example:      \snippet code/src_corelib_tools_qstring.cpp 6      \sa QString, QLatin1Char, {QStringLiteral()}{QStringLiteral} */
end_comment
begin_comment
comment|/*! \fn QLatin1String::QLatin1String(const char *str)      Constructs a QLatin1String object that stores \a str. Note that if     \a str is 0, an empty string is created; this case is handled by     QString.      The string data is \e not copied. The caller must be able to     guarantee that \a str will not be deleted or modified as long as     the QLatin1String object exists.      \sa latin1() */
end_comment
begin_comment
comment|/*! \fn QLatin1String::QLatin1String(const char *str, int size)      Constructs a QLatin1String object that stores \a str with \a size.     Note that if \a str is 0, an empty string is created; this case     is handled by QString.      The string data is \e not copied. The caller must be able to     guarantee that \a str will not be deleted or modified as long as     the QLatin1String object exists.      \sa latin1() */
end_comment
begin_comment
comment|/*! \fn QLatin1String::QLatin1String(const QByteArray&str)      Constructs a QLatin1String object that stores \a str.      The string data is \e not copied. The caller must be able to     guarantee that \a str will not be deleted or modified as long as     the QLatin1String object exists.      \sa latin1() */
end_comment
begin_comment
comment|/*! \fn const char *QLatin1String::latin1() const      Returns the Latin-1 string stored in this object. */
end_comment
begin_comment
comment|/*! \fn const char *QLatin1String::data() const      Returns the Latin-1 string stored in this object. */
end_comment
begin_comment
comment|/*! \fn int QLatin1String::size() const      Returns the size of the Latin-1 string stored in this object. */
end_comment
begin_comment
comment|/*! \fn bool QLatin1String::operator==(const QString&other) const      Returns \c true if this string is equal to string \a other;     otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings with     QString::localeAwareCompare(). */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator==(const char *other) const     \since 4.3     \overload      The \a other const char pointer is converted to a QString using     the QString::fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator==(const QByteArray&other) const     \since 5.0     \overload      The \a other byte array is converted to a QString using     the QString::fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*! \fn bool QLatin1String::operator!=(const QString&other) const      Returns \c true if this string is not equal to string \a other;     otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings with     QString::localeAwareCompare(). */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator!=(const char *other) const     \since 4.3     \overload operator!=()      The \a other const char pointer is converted to a QString using     the QString::fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator!=(const QByteArray&other) const     \since 5.0     \overload operator!=()      The \a other byte array is converted to a QString using     the QString::fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator>(const QString&other) const      Returns \c true if this string is lexically greater than string \a     other; otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings with     QString::localeAwareCompare(). */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator>(const char *other) const     \since 4.3     \overload      The \a other const char pointer is converted to a QString using     the QString::fromUtf8() function.      You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII     when you compile your applications. This can be useful if you want     to ensure that all user-visible strings go through QObject::tr(),     for example. */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator>(const QByteArray&other) const     \since 5.0     \overload      The \a other const char pointer is converted to a QString using     the QString::fromUtf8() function.      You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII     when you compile your applications. This can be useful if you want     to ensure that all user-visible strings go through QObject::tr(),     for example. */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator<(const QString&other) const      Returns \c true if this string is lexically less than the \a other     string; otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings using the     QString::localeAwareCompare() function. */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator<(const char *other) const     \since 4.3     \overload      The \a other const char pointer is converted to a QString using     the QString::fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator<(const QByteArray&other) const     \since 5.0     \overload      The \a other const char pointer is converted to a QString using     the QString::fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator>=(const QString&other) const      Returns \c true if this string is lexically greater than or equal     to string \a other; otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings with     QString::localeAwareCompare(). */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator>=(const char *other) const     \since 4.3     \overload      The \a other const char pointer is converted to a QString using     the QString::fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator>=(const QByteArray&other) const     \since 5.0     \overload      The \a other array is converted to a QString using     the QString::fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*! \fn bool QLatin1String::operator<=(const QString&other) const      Returns \c true if this string is lexically less than or equal     to string \a other; otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings with     QString::localeAwareCompare(). */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator<=(const char *other) const     \since 4.3     \overload      The \a other const char pointer is converted to a QString using     the QString::fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*!     \fn bool QLatin1String::operator<=(const QByteArray&other) const     \since 5.0     \overload      The \a other array is converted to a QString using     the QString::fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example. */
end_comment
begin_comment
comment|/*! \fn bool operator==(QLatin1String s1, QLatin1String s2)    \relates QLatin1String     Returns \c true if string \a s1 is lexically equal to string \a s2; otherwise    returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool operator!=(QLatin1String s1, QLatin1String s2)    \relates QLatin1String     Returns \c true if string \a s1 is lexically unequal to string \a s2; otherwise    returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool operator<(QLatin1String s1, QLatin1String s2)    \relates QLatin1String     Returns \c true if string \a s1 is lexically smaller than string \a s2; otherwise    returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool operator<=(QLatin1String s1, QLatin1String s2)    \relates QLatin1String     Returns \c true if string \a s1 is lexically smaller than or equal to string \a s2; otherwise    returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool operator>(QLatin1String s1, QLatin1String s2)    \relates QLatin1String     Returns \c true if string \a s1 is lexically greater than string \a s2; otherwise    returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool operator>=(QLatin1String s1, QLatin1String s2)    \relates QLatin1String     Returns \c true if string \a s1 is lexically greater than or equal to    string \a s2; otherwise returns \c false. */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DATASTREAM
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BUILD_QMAKE
argument_list|)
operator|)
end_if
begin_comment
comment|/*!     \fn QDataStream&operator<<(QDataStream&stream, const QString&string)     \relates QString      Writes the given \a string to the specified \a stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
if|if
condition|(
name|out
operator|.
name|version
argument_list|()
operator|==
literal|1
condition|)
block|{
name|out
operator|<<
name|str
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|str
operator|.
name|isNull
argument_list|()
operator|||
name|out
operator|.
name|version
argument_list|()
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|out
operator|.
name|byteOrder
argument_list|()
operator|==
name|QDataStream
operator|::
name|BigEndian
operator|)
operator|==
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|)
condition|)
block|{
name|out
operator|.
name|writeBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|str
operator|.
name|unicode
argument_list|()
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
operator|*
name|str
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QVarLengthArray
argument_list|<
name|ushort
argument_list|>
name|buffer
argument_list|(
name|str
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|str
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|qbswap
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
operator|++
name|data
expr_stmt|;
block|}
name|out
operator|.
name|writeBytes
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|buffer
operator|.
name|data
argument_list|()
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
operator|*
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// write null marker
name|out
operator|<<
operator|(
name|quint32
operator|)
literal|0xffffffff
expr_stmt|;
block|}
block|}
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&operator>>(QDataStream&stream, QString&string)     \relates QString      Reads a string from the specified \a stream into the given \a string.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QString
modifier|&
name|str
parameter_list|)
block|{
if|if
condition|(
name|in
operator|.
name|version
argument_list|()
operator|==
literal|1
condition|)
block|{
name|QByteArray
name|l
decl_stmt|;
name|in
operator|>>
name|l
expr_stmt|;
name|str
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|quint32
name|bytes
init|=
literal|0
decl_stmt|;
name|in
operator|>>
name|bytes
expr_stmt|;
comment|// read size of string
if|if
condition|(
name|bytes
operator|==
literal|0xffffffff
condition|)
block|{
comment|// null string
name|str
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
comment|// not empty
if|if
condition|(
name|bytes
operator|&
literal|0x1
condition|)
block|{
name|str
operator|.
name|clear
argument_list|()
expr_stmt|;
name|in
operator|.
name|setStatus
argument_list|(
name|QDataStream
operator|::
name|ReadCorruptData
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
specifier|const
name|quint32
name|Step
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
name|quint32
name|len
init|=
name|bytes
operator|/
literal|2
decl_stmt|;
name|quint32
name|allocated
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|allocated
operator|<
name|len
condition|)
block|{
name|int
name|blockSize
init|=
name|qMin
argument_list|(
name|Step
argument_list|,
name|len
operator|-
name|allocated
argument_list|)
decl_stmt|;
name|str
operator|.
name|resize
argument_list|(
name|allocated
operator|+
name|blockSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|readRawData
argument_list|(
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|str
operator|.
name|data
argument_list|()
argument_list|)
operator|+
name|allocated
operator|*
literal|2
argument_list|,
name|blockSize
operator|*
literal|2
argument_list|)
operator|!=
name|blockSize
operator|*
literal|2
condition|)
block|{
name|str
operator|.
name|clear
argument_list|()
expr_stmt|;
name|in
operator|.
name|setStatus
argument_list|(
name|QDataStream
operator|::
name|ReadPastEnd
argument_list|)
expr_stmt|;
return|return
name|in
return|;
block|}
name|allocated
operator|+=
name|blockSize
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in
operator|.
name|byteOrder
argument_list|()
operator|==
name|QDataStream
operator|::
name|BigEndian
operator|)
operator|!=
operator|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
operator|)
condition|)
block|{
name|ushort
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|str
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
operator|*
name|data
operator|=
name|qbswap
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
operator|++
name|data
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|str
operator|=
name|QString
argument_list|(
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*!     \class QStringRef     \inmodule QtCore     \since 4.3     \brief The QStringRef class provides a thin wrapper around QString substrings.     \reentrant     \ingroup tools     \ingroup string-processing      QStringRef provides a read-only subset of the QString API.      A string reference explicitly references a portion of a string()     with a given size(), starting at a specific position(). Calling     toString() returns a copy of the data as a real QString instance.      This class is designed to improve the performance of substring     handling when manipulating substrings obtained from existing QString     instances. QStringRef avoids the memory allocation and reference     counting overhead of a standard QString by simply referencing a     part of the original string. This can prove to be advantageous in     low level code, such as that used in a parser, at the expense of     potentially more complex code.      For most users, there are no semantic benefits to using QStringRef     instead of QString since QStringRef requires attention to be paid     to memory management issues, potentially making code more complex     to write and maintain.      \warning A QStringRef is only valid as long as the referenced     string exists. If the original string is deleted, the string     reference points to an invalid memory location.      We suggest that you only use this class in stable code where profiling     has clearly identified that performance improvements can be made by     replacing standard string operations with the optimized substring     handling provided by this class.      \sa {Implicitly Shared Classes} */
end_comment
begin_comment
comment|/*!     \typedef QStringRef::size_type     \internal */
end_comment
begin_comment
comment|/*!     \typedef QStringRef::value_type     \internal */
end_comment
begin_comment
comment|/*!     \typedef QStringRef::const_pointer     \internal */
end_comment
begin_comment
comment|/*!     \typedef QStringRef::const_reference     \internal */
end_comment
begin_comment
comment|/*!     \typedef QStringRef::const_iterator     \internal */
end_comment
begin_comment
comment|/*!  \fn QStringRef::QStringRef()   Constructs an empty string reference. */
end_comment
begin_comment
comment|/*! \fn QStringRef::QStringRef(const QString *string, int position, int length)  Constructs a string reference to the range of characters in the given \a string specified by the starting \a position and \a length in characters.  \warning This function exists to improve performance as much as possible, and performs no bounds checking. For program correctness, \a position and \a length must describe a valid substring of \a string.  This means that the starting \a position must be positive or 0 and smaller than \a string's length, and \a length must be positive or 0 but smaller than the string's length minus the starting \a position; i.e, 0<= position< string->length() and 0<= length<= string->length() - position must both be satisfied. */
end_comment
begin_comment
comment|/*! \fn QStringRef::QStringRef(const QString *string)  Constructs a string reference to the given \a string. */
end_comment
begin_comment
comment|/*! \fn QStringRef::QStringRef(const QStringRef&other)  Constructs a copy of the \a other string reference.  */
end_comment
begin_comment
comment|/*! \fn QStringRef::~QStringRef()  Destroys the string reference.  Since this class is only used to refer to string data, and does not take ownership of it, no memory is freed when instances are destroyed. */
end_comment
begin_comment
comment|/*!     \fn int QStringRef::position() const      Returns the starting position in the referenced string that is referred to     by the string reference.      \sa size(), string() */
end_comment
begin_comment
comment|/*!     \fn int QStringRef::size() const      Returns the number of characters referred to by the string reference.     Equivalent to length() and count().      \sa position(), string() */
end_comment
begin_comment
comment|/*!     \fn int QStringRef::count() const     Returns the number of characters referred to by the string reference.     Equivalent to size() and length().      \sa position(), string() */
end_comment
begin_comment
comment|/*!     \fn int QStringRef::length() const     Returns the number of characters referred to by the string reference.     Equivalent to size() and count().      \sa position(), string() */
end_comment
begin_comment
comment|/*!     \fn bool QStringRef::isEmpty() const      Returns \c true if the string reference has no characters; otherwise returns     \c false.      A string reference is empty if its size is zero.      \sa size() */
end_comment
begin_comment
comment|/*!     \fn bool QStringRef::isNull() const      Returns \c true if string() returns a null pointer or a pointer to a     null string; otherwise returns \c true.      \sa size() */
end_comment
begin_comment
comment|/*!     \fn const QString *QStringRef::string() const      Returns a pointer to the string referred to by the string reference, or     0 if it does not reference a string.      \sa unicode() */
end_comment
begin_comment
comment|/*!     \fn const QChar *QStringRef::unicode() const      Returns a Unicode representation of the string reference. Since     the data stems directly from the referenced string, it is not     null-terminated unless the string reference includes the string's     null terminator.      \sa string() */
end_comment
begin_comment
comment|/*!     \fn const QChar *QStringRef::data() const      Same as unicode(). */
end_comment
begin_comment
comment|/*!     \fn const QChar *QStringRef::begin() const     \since 5.4      Same as unicode(). */
end_comment
begin_comment
comment|/*!     \fn const QChar *QStringRef::cbegin() const     \since 5.4      Same as unicode(). */
end_comment
begin_comment
comment|/*!     \fn const QChar *QStringRef::end() const     \since 5.4      Returns a pointer to one character past the last one in this string.     (It is the same as \c {unicode() + size()}.) */
end_comment
begin_comment
comment|/*!     \fn const QChar *QStringRef::cend() const     \since 5.4      Returns a pointer to one character past the last one in this string.     (It is the same as \c {unicode() + size()}.) */
end_comment
begin_comment
comment|/*!     \fn const QChar *QStringRef::constData() const      Same as unicode(). */
end_comment
begin_comment
comment|/*!     Returns a copy of the string reference as a QString object.      If the string reference is not a complete reference of the string     (meaning that position() is 0 and size() equals string()->size()),     this function will allocate a new string to return.      \sa string() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QStringRef
operator|::
name|toString
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|m_string
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|m_size
operator|&&
name|m_position
operator|==
literal|0
operator|&&
name|m_size
operator|==
name|m_string
operator|->
name|size
argument_list|()
condition|)
return|return
operator|*
name|m_string
return|;
return|return
name|QString
argument_list|(
name|m_string
operator|->
name|unicode
argument_list|()
operator|+
name|m_position
argument_list|,
name|m_size
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \relates QStringRef     Returns \c true if string reference \a s1 is lexically equal to string reference \a s2; otherwise    returns \c false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|s1
parameter_list|,
specifier|const
name|QStringRef
modifier|&
name|s2
parameter_list|)
block|{
return|return
operator|(
name|s1
operator|.
name|size
argument_list|()
operator|==
name|s2
operator|.
name|size
argument_list|()
operator|&&
name|qMemEquals
argument_list|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|s1
operator|.
name|unicode
argument_list|()
argument_list|,
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|s2
operator|.
name|unicode
argument_list|()
argument_list|,
name|s1
operator|.
name|size
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*! \relates QStringRef     Returns \c true if string \a s1 is lexically equal to string reference \a s2; otherwise    returns \c false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QString
modifier|&
name|s1
parameter_list|,
specifier|const
name|QStringRef
modifier|&
name|s2
parameter_list|)
block|{
return|return
operator|(
name|s1
operator|.
name|size
argument_list|()
operator|==
name|s2
operator|.
name|size
argument_list|()
operator|&&
name|qMemEquals
argument_list|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|s1
operator|.
name|unicode
argument_list|()
argument_list|,
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|s2
operator|.
name|unicode
argument_list|()
argument_list|,
name|s1
operator|.
name|size
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*! \relates QStringRef     Returns \c true if string  \a s1 is lexically equal to string reference \a s2; otherwise    returns \c false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
name|QLatin1String
name|s1
parameter_list|,
specifier|const
name|QStringRef
modifier|&
name|s2
parameter_list|)
block|{
if|if
condition|(
name|s1
operator|.
name|size
argument_list|()
operator|!=
name|s2
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
specifier|const
name|uchar
modifier|*
name|c
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|s1
operator|.
name|latin1
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|s2
operator|.
name|isEmpty
argument_list|()
return|;
return|return
name|ucstrncmp
argument_list|(
name|s2
operator|.
name|unicode
argument_list|()
argument_list|,
name|c
argument_list|,
name|s2
operator|.
name|size
argument_list|()
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!    \relates QStringRef      Returns \c true if string reference \a s1 is lexically less than     string reference \a s2; otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings using the     QString::localeAwareCompare() function. */
end_comment
begin_function
DECL|function|operator <
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|s1
parameter_list|,
specifier|const
name|QStringRef
modifier|&
name|s2
parameter_list|)
block|{
return|return
name|ucstrcmp
argument_list|(
name|s1
operator|.
name|constData
argument_list|()
argument_list|,
name|s1
operator|.
name|length
argument_list|()
argument_list|,
name|s2
operator|.
name|constData
argument_list|()
argument_list|,
name|s2
operator|.
name|length
argument_list|()
argument_list|)
operator|<
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!\fn bool operator<=(const QStringRef&s1,const QStringRef&s2)     \relates QStringRef      Returns \c true if string reference \a s1 is lexically less than     or equal to string reference \a s2; otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings using the     QString::localeAwareCompare() function. */
end_comment
begin_comment
comment|/*!\fn bool operator>=(const QStringRef&s1,const QStringRef&s2)     \relates QStringRef      Returns \c true if string reference \a s1 is lexically greater than     or equal to string reference \a s2; otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings using the     QString::localeAwareCompare() function. */
end_comment
begin_comment
comment|/*!\fn bool operator>(const QStringRef&s1,const QStringRef&s2)     \relates QStringRef      Returns \c true if string reference \a s1 is lexically greater than     string reference \a s2; otherwise returns \c false.      The comparison is based exclusively on the numeric Unicode values     of the characters and is very fast, but is not what a human would     expect. Consider sorting user-interface strings using the     QString::localeAwareCompare() function. */
end_comment
begin_comment
comment|/*!     \fn const QChar QStringRef::at(int position) const      Returns the character at the given index \a position in the     string reference.      The \a position must be a valid index position in the string     (i.e., 0<= \a position< size()). */
end_comment
begin_comment
comment|/*!     \fn void QStringRef::clear()      Clears the contents of the string reference by making it null and empty.      \sa isEmpty(), isNull() */
end_comment
begin_comment
comment|/*!     \fn QStringRef&QStringRef::operator=(const QStringRef&other)      Assigns the \a other string reference to this string reference, and     returns the result. */
end_comment
begin_comment
comment|/*!     \fn QStringRef&QStringRef::operator=(const QString *string)      Constructs a string reference to the given \a string and assigns it to     this string reference, returning the result. */
end_comment
begin_comment
comment|/*!     \fn bool QStringRef::operator==(const char * s) const      \overload operator==()      The \a s byte array is converted to a QStringRef using the     fromUtf8() function. This function stops conversion at the     first NUL character found, or the end of the byte array.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example.      Returns \c true if this string is lexically equal to the parameter     string \a s. Otherwise returns \c false.  */
end_comment
begin_comment
comment|/*!     \fn bool QStringRef::operator!=(const char * s) const      \overload operator!=()      The \a s const char pointer is converted to a QStringRef using     the fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example.      Returns \c true if this string is not lexically equal to the parameter     string \a s. Otherwise returns \c false. */
end_comment
begin_comment
comment|/*!     \fn bool QStringRef::operator<(const char * s) const      \overload operator<()      The \a s const char pointer is converted to a QStringRef using     the fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example.      Returns \c true if this string is lexically smaller than the parameter     string \a s. Otherwise returns \c false. */
end_comment
begin_comment
comment|/*!     \fn bool QStringRef::operator<=(const char * s) const      \overload operator<=()      The \a s const char pointer is converted to a QStringRef using     the fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example.      Returns \c true if this string is lexically smaller than or equal to the parameter     string \a s. Otherwise returns \c false. */
end_comment
begin_comment
comment|/*!     \fn bool QStringRef::operator>(const char * s) const       \overload operator>()      The \a s const char pointer is converted to a QStringRef using     the fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example.      Returns \c true if this string is lexically greater than the parameter     string \a s. Otherwise returns \c false. */
end_comment
begin_comment
comment|/*!     \fn bool QStringRef::operator>= (const char * s) const      \overload operator>=()      The \a s const char pointer is converted to a QStringRef using     the fromUtf8() function.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. This     can be useful if you want to ensure that all user-visible strings     go through QObject::tr(), for example.      Returns \c true if this string is lexically greater than or equal to the     parameter string \a s. Otherwise returns \c false. */
end_comment
begin_comment
comment|/*!     \typedef QString::Data     \internal */
end_comment
begin_comment
comment|/*!     \typedef QString::DataPtr     \internal */
end_comment
begin_comment
comment|/*!     \fn DataPtr& QString::data_ptr()     \internal */
end_comment
begin_comment
comment|/*!  Appends the string reference to \a string, and returns a new reference to the combined string data.  */
end_comment
begin_function
DECL|function|appendTo
name|QStringRef
name|QStringRef
operator|::
name|appendTo
parameter_list|(
name|QString
modifier|*
name|string
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|string
condition|)
return|return
name|QStringRef
argument_list|()
return|;
name|int
name|pos
init|=
name|string
operator|->
name|size
argument_list|()
decl_stmt|;
name|string
operator|->
name|insert
argument_list|(
name|pos
argument_list|,
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|QStringRef
argument_list|(
name|string
argument_list|,
name|pos
argument_list|,
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QStringRef::compare(const QStringRef&s1, const QString&s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)     \since 4.5      Compares the string \a s1 with the string \a s2 and returns an     integer less than, equal to, or greater than zero if \a s1     is less than, equal to, or greater than \a s2.      If \a cs is Qt::CaseSensitive, the comparison is case sensitive;     otherwise the comparison is case insensitive. */
end_comment
begin_comment
comment|/*!     \fn int QStringRef::compare(const QStringRef&s1, const QStringRef&s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)     \since 4.5     \overload      Compares the string \a s1 with the string \a s2 and returns an     integer less than, equal to, or greater than zero if \a s1     is less than, equal to, or greater than \a s2.      If \a cs is Qt::CaseSensitive, the comparison is case sensitive;     otherwise the comparison is case insensitive. */
end_comment
begin_comment
comment|/*!     \fn int QStringRef::compare(const QStringRef&s1, QLatin1String s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)     \since 4.5     \overload      Compares the string \a s1 with the string \a s2 and returns an     integer less than, equal to, or greater than zero if \a s1     is less than, equal to, or greater than \a s2.      If \a cs is Qt::CaseSensitive, the comparison is case sensitive;     otherwise the comparison is case insensitive. */
end_comment
begin_comment
comment|/*!     \overload     \fn int QStringRef::compare(const QString&other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const     \since 4.5      Compares this string with the \a other string and returns an     integer less than, equal to, or greater than zero if this string     is less than, equal to, or greater than the \a other string.      If \a cs is Qt::CaseSensitive, the comparison is case sensitive;     otherwise the comparison is case insensitive.      Equivalent to \c {compare(*this, other, cs)}.      \sa QString::compare() */
end_comment
begin_comment
comment|/*!     \overload     \fn int QStringRef::compare(const QStringRef&other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const     \since 4.5      Compares this string with the \a other string and returns an     integer less than, equal to, or greater than zero if this string     is less than, equal to, or greater than the \a other string.      If \a cs is Qt::CaseSensitive, the comparison is case sensitive;     otherwise the comparison is case insensitive.      Equivalent to \c {compare(*this, other, cs)}.      \sa QString::compare() */
end_comment
begin_comment
comment|/*!     \overload     \fn int QStringRef::compare(QLatin1String other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const     \since 4.5      Compares this string with the \a other string and returns an     integer less than, equal to, or greater than zero if this string     is less than, equal to, or greater than the \a other string.      If \a cs is Qt::CaseSensitive, the comparison is case sensitive;     otherwise the comparison is case insensitive.      Equivalent to \c {compare(*this, other, cs)}.      \sa QString::compare() */
end_comment
begin_comment
comment|/*!     \fn int QStringRef::localeAwareCompare(const QStringRef&s1, const QString& s2)     \since 4.5      Compares \a s1 with \a s2 and returns an integer less than, equal     to, or greater than zero if \a s1 is less than, equal to, or     greater than \a s2.      The comparison is performed in a locale- and also     platform-dependent manner. Use this function to present sorted     lists of strings to the user.      On OS X and iOS, this function compares according the     "Order for sorted lists" setting in the International prefereces panel.      \sa compare(), QLocale */
end_comment
begin_comment
comment|/*!     \fn int QStringRef::localeAwareCompare(const QStringRef&s1, const QStringRef& s2)     \since 4.5     \overload      Compares \a s1 with \a s2 and returns an integer less than, equal     to, or greater than zero if \a s1 is less than, equal to, or     greater than \a s2.      The comparison is performed in a locale- and also     platform-dependent manner. Use this function to present sorted     lists of strings to the user.  */
end_comment
begin_comment
comment|/*!     \fn int QStringRef::localeAwareCompare(const QString&other) const     \since 4.5     \overload      Compares this string with the \a other string and returns an     integer less than, equal to, or greater than zero if this string     is less than, equal to, or greater than the \a other string.      The comparison is performed in a locale- and also     platform-dependent manner. Use this function to present sorted     lists of strings to the user. */
end_comment
begin_comment
comment|/*!     \fn int QStringRef::localeAwareCompare(const QStringRef&other) const     \since 4.5     \overload      Compares this string with the \a other string and returns an     integer less than, equal to, or greater than zero if this string     is less than, equal to, or greater than the \a other string.      The comparison is performed in a locale- and also     platform-dependent manner. Use this function to present sorted     lists of strings to the user. */
end_comment
begin_comment
comment|/*!     \fn QString&QString::append(const QStringRef&reference)     \since 4.4      Appends the given string \a reference to this string and returns the result.  */
end_comment
begin_function
DECL|function|append
name|QString
modifier|&
name|QString
operator|::
name|append
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|.
name|string
argument_list|()
operator|==
name|this
condition|)
block|{
name|str
operator|.
name|appendTo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
operator|.
name|string
argument_list|()
condition|)
block|{
name|int
name|oldSize
init|=
name|size
argument_list|()
decl_stmt|;
name|resize
argument_list|(
name|oldSize
operator|+
name|str
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|()
operator|+
name|oldSize
argument_list|,
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QChar
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QStringRef::left(int n) const     \since 5.2      Returns a substring reference to the \a n leftmost characters     of the string.      If \a n is greater than or equal to size(), or less than zero,     a reference to the entire string is returned.      \sa right(), mid(), startsWith() */
end_comment
begin_function
DECL|function|left
name|QStringRef
name|QStringRef
operator|::
name|left
parameter_list|(
name|int
name|n
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|uint
argument_list|(
name|n
argument_list|)
operator|>=
name|uint
argument_list|(
name|m_size
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
return|return
name|QStringRef
argument_list|(
name|m_string
argument_list|,
name|m_position
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns a substring reference to the \a n leftmost characters     of the string.      If \a n is greater than or equal to size(), or less than zero,     a reference to the entire string is returned.      \snippet qstring/main.cpp leftRef      \sa left(), rightRef(), midRef(), startsWith() */
end_comment
begin_function
DECL|function|leftRef
name|QStringRef
name|QString
operator|::
name|leftRef
parameter_list|(
name|int
name|n
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|uint
argument_list|(
name|n
argument_list|)
operator|>=
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
condition|)
name|n
operator|=
name|d
operator|->
name|size
expr_stmt|;
return|return
name|QStringRef
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QStringRef::right(int n) const     \since 5.2      Returns a substring reference to the \a n rightmost characters     of the string.      If \a n is greater than or equal to size(), or less than zero,     a reference to the entire string is returned.      \sa left(), mid(), endsWith() */
end_comment
begin_function
DECL|function|right
name|QStringRef
name|QStringRef
operator|::
name|right
parameter_list|(
name|int
name|n
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|uint
argument_list|(
name|n
argument_list|)
operator|>=
name|uint
argument_list|(
name|m_size
argument_list|)
condition|)
return|return
operator|*
name|this
return|;
return|return
name|QStringRef
argument_list|(
name|m_string
argument_list|,
name|m_size
operator|-
name|n
operator|+
name|m_position
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns a substring reference to the \a n rightmost characters     of the string.      If \a n is greater than or equal to size(), or less than zero,     a reference to the entire string is returned.      \snippet qstring/main.cpp rightRef      \sa right(), leftRef(), midRef(), endsWith() */
end_comment
begin_function
DECL|function|rightRef
name|QStringRef
name|QString
operator|::
name|rightRef
parameter_list|(
name|int
name|n
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|uint
argument_list|(
name|n
argument_list|)
operator|>=
name|uint
argument_list|(
name|d
operator|->
name|size
argument_list|)
condition|)
name|n
operator|=
name|d
operator|->
name|size
expr_stmt|;
return|return
name|QStringRef
argument_list|(
name|this
argument_list|,
name|d
operator|->
name|size
operator|-
name|n
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QStringRef::mid(int position, int n = -1) const     \since 5.2      Returns a substring reference to \a n characters of this string,     starting at the specified \a position.      If the \a position exceeds the length of the string, a null     reference is returned.      If there are less than \a n characters available in the string,     starting at the given \a position, or if \a n is -1 (default), the     function returns all characters from the specified \a position     onwards.      \sa left(), right() */
end_comment
begin_function
DECL|function|mid
name|QStringRef
name|QStringRef
operator|::
name|mid
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|n
parameter_list|)
specifier|const
block|{
using|using
namespace|namespace
name|QtPrivate
namespace|;
switch|switch
condition|(
name|QContainerImplHelper
operator|::
name|mid
argument_list|(
name|m_size
argument_list|,
operator|&
name|pos
argument_list|,
operator|&
name|n
argument_list|)
condition|)
block|{
case|case
name|QContainerImplHelper
operator|::
name|Null
case|:
return|return
name|QStringRef
argument_list|()
return|;
case|case
name|QContainerImplHelper
operator|::
name|Empty
case|:
return|return
name|QStringRef
argument_list|(
name|m_string
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|QContainerImplHelper
operator|::
name|Full
case|:
return|return
operator|*
name|this
return|;
case|case
name|QContainerImplHelper
operator|::
name|Subset
case|:
return|return
name|QStringRef
argument_list|(
name|m_string
argument_list|,
name|pos
operator|+
name|m_position
argument_list|,
name|n
argument_list|)
return|;
block|}
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|QStringRef
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns a substring reference to \a n characters of this string,     starting at the specified \a position.      If the \a position exceeds the length of the string, a null     reference is returned.      If there are less than \a n characters available in the string,     starting at the given \a position, or if \a n is -1 (default), the     function returns all characters from the specified \a position     onwards.      Example:      \snippet qstring/main.cpp midRef      \sa mid(), leftRef(), rightRef() */
end_comment
begin_function
DECL|function|midRef
name|QStringRef
name|QString
operator|::
name|midRef
parameter_list|(
name|int
name|position
parameter_list|,
name|int
name|n
parameter_list|)
specifier|const
block|{
using|using
namespace|namespace
name|QtPrivate
namespace|;
switch|switch
condition|(
name|QContainerImplHelper
operator|::
name|mid
argument_list|(
name|d
operator|->
name|size
argument_list|,
operator|&
name|position
argument_list|,
operator|&
name|n
argument_list|)
condition|)
block|{
case|case
name|QContainerImplHelper
operator|::
name|Null
case|:
return|return
name|QStringRef
argument_list|()
return|;
case|case
name|QContainerImplHelper
operator|::
name|Empty
case|:
return|return
name|QStringRef
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|QContainerImplHelper
operator|::
name|Full
case|:
return|return
name|QStringRef
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|size
argument_list|)
return|;
case|case
name|QContainerImplHelper
operator|::
name|Subset
case|:
return|return
name|QStringRef
argument_list|(
name|this
argument_list|,
name|position
argument_list|,
name|n
argument_list|)
return|;
block|}
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
return|return
name|QStringRef
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QStringRef::truncate(int position)     \since 5.6      Truncates the string at the given \a position index.      If the specified \a position index is beyond the end of the     string, nothing happens.      If \a position is negative, it is equivalent to passing zero.      \sa QString::truncate() */
end_comment
begin_comment
comment|/*!   \since 4.8    Returns the index position of the first occurrence of the string \a   str in this string reference, searching forward from index position   \a from. Returns -1 if \a str is not found.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    If \a from is -1, the search starts at the last character; if it is   -2, at the next to last character and so on.    \sa QString::indexOf(), lastIndexOf(), contains(), count() */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QStringRef
operator|::
name|indexOf
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qFindString
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|length
argument_list|()
argument_list|,
name|from
argument_list|,
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     \overload indexOf()      Returns the index position of the first occurrence of the     character \a ch in the string reference, searching forward from     index position \a from. Returns -1 if \a ch could not be found.      \sa QString::indexOf(), lastIndexOf(), contains(), count() */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QStringRef
operator|::
name|indexOf
parameter_list|(
name|QChar
name|ch
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|findChar
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|length
argument_list|()
argument_list|,
name|ch
argument_list|,
name|from
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.8    Returns the index position of the first occurrence of the string \a   str in this string reference, searching forward from index position   \a from. Returns -1 if \a str is not found.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    If \a from is -1, the search starts at the last character; if it is   -2, at the next to last character and so on.    \sa QString::indexOf(), lastIndexOf(), contains(), count() */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QStringRef
operator|::
name|indexOf
parameter_list|(
name|QLatin1String
name|str
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_find_latin1_string
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|str
argument_list|,
name|from
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      \overload indexOf()      Returns the index position of the first occurrence of the string     reference \a str in this string reference, searching forward from     index position \a from. Returns -1 if \a str is not found.      If \a cs is Qt::CaseSensitive (default), the search is case     sensitive; otherwise the search is case insensitive.      \sa QString::indexOf(), lastIndexOf(), contains(), count() */
end_comment
begin_function
DECL|function|indexOf
name|int
name|QStringRef
operator|::
name|indexOf
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|str
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qFindString
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|from
argument_list|,
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.8    Returns the index position of the last occurrence of the string \a   str in this string reference, searching backward from index position   \a from. If \a from is -1 (default), the search starts at the last   character; if \a from is -2, at the next to last character and so   on. Returns -1 if \a str is not found.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    \sa QString::lastIndexOf(), indexOf(), contains(), count() */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QStringRef
operator|::
name|lastIndexOf
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|sl
init|=
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|sl
operator|==
literal|1
condition|)
return|return
name|lastIndexOf
argument_list|(
name|str
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|,
name|from
argument_list|,
name|cs
argument_list|)
return|;
specifier|const
name|int
name|l
init|=
name|size
argument_list|()
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|+=
name|l
expr_stmt|;
name|int
name|delta
init|=
name|l
operator|-
name|sl
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|l
operator|&&
name|sl
operator|==
literal|0
condition|)
return|return
name|from
return|;
if|if
condition|(
name|uint
argument_list|(
name|from
argument_list|)
operator|>=
name|uint
argument_list|(
name|l
argument_list|)
operator|||
name|delta
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|from
operator|>
name|delta
condition|)
name|from
operator|=
name|delta
expr_stmt|;
return|return
name|lastIndexOfHelper
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|unicode
argument_list|()
argument_list|)
argument_list|,
name|from
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|str
operator|.
name|unicode
argument_list|()
argument_list|)
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.8   \overload lastIndexOf()    Returns the index position of the last occurrence of the character   \a ch, searching backward from position \a from.    \sa QString::lastIndexOf(), indexOf(), contains(), count() */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QStringRef
operator|::
name|lastIndexOf
parameter_list|(
name|QChar
name|ch
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_last_index_of
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ch
argument_list|,
name|from
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.8   \overload lastIndexOf()    Returns the index position of the last occurrence of the string \a   str in this string reference, searching backward from index position   \a from. If \a from is -1 (default), the search starts at the last   character; if \a from is -2, at the next to last character and so   on. Returns -1 if \a str is not found.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    \sa QString::lastIndexOf(), indexOf(), contains(), count() */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QStringRef
operator|::
name|lastIndexOf
parameter_list|(
name|QLatin1String
name|str
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|sl
init|=
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|sl
operator|==
literal|1
condition|)
return|return
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
name|str
operator|.
name|latin1
argument_list|()
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|from
argument_list|,
name|cs
argument_list|)
return|;
specifier|const
name|int
name|l
init|=
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|+=
name|l
expr_stmt|;
name|int
name|delta
init|=
name|l
operator|-
name|sl
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|l
operator|&&
name|sl
operator|==
literal|0
condition|)
return|return
name|from
return|;
if|if
condition|(
name|uint
argument_list|(
name|from
argument_list|)
operator|>=
name|uint
argument_list|(
name|l
argument_list|)
operator|||
name|delta
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|from
operator|>
name|delta
condition|)
name|from
operator|=
name|delta
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|ushort
argument_list|>
name|s
argument_list|(
name|sl
argument_list|)
decl_stmt|;
name|qt_from_latin1
argument_list|(
name|s
operator|.
name|data
argument_list|()
argument_list|,
name|str
operator|.
name|latin1
argument_list|()
argument_list|,
name|sl
argument_list|)
expr_stmt|;
return|return
name|lastIndexOfHelper
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|unicode
argument_list|()
argument_list|)
argument_list|,
name|from
argument_list|,
name|s
operator|.
name|data
argument_list|()
argument_list|,
name|sl
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.8   \overload lastIndexOf()    Returns the index position of the last occurrence of the string   reference \a str in this string reference, searching backward from   index position \a from. If \a from is -1 (default), the search   starts at the last character; if \a from is -2, at the next to last   character and so on. Returns -1 if \a str is not found.    If \a cs is Qt::CaseSensitive (default), the search is case   sensitive; otherwise the search is case insensitive.    \sa QString::lastIndexOf(), indexOf(), contains(), count() */
end_comment
begin_function
DECL|function|lastIndexOf
name|int
name|QStringRef
operator|::
name|lastIndexOf
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|str
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
specifier|const
name|int
name|sl
init|=
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|sl
operator|==
literal|1
condition|)
return|return
name|lastIndexOf
argument_list|(
name|str
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|,
name|from
argument_list|,
name|cs
argument_list|)
return|;
specifier|const
name|int
name|l
init|=
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|+=
name|l
expr_stmt|;
name|int
name|delta
init|=
name|l
operator|-
name|sl
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|l
operator|&&
name|sl
operator|==
literal|0
condition|)
return|return
name|from
return|;
if|if
condition|(
name|uint
argument_list|(
name|from
argument_list|)
operator|>=
name|uint
argument_list|(
name|l
argument_list|)
operator|||
name|delta
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|from
operator|>
name|delta
condition|)
name|from
operator|=
name|delta
expr_stmt|;
return|return
name|lastIndexOfHelper
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|unicode
argument_list|()
argument_list|)
argument_list|,
name|from
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|str
operator|.
name|unicode
argument_list|()
argument_list|)
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     Returns the number of (potentially overlapping) occurrences of     the string \a str in this string reference.      If \a cs is Qt::CaseSensitive (default), the search is     case sensitive; otherwise the search is case insensitive.      \sa QString::count(), contains(), indexOf() */
end_comment
begin_function
DECL|function|count
name|int
name|QStringRef
operator|::
name|count
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_string_count
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     \overload count()      Returns the number of occurrences of the character \a ch in the     string reference.      If \a cs is Qt::CaseSensitive (default), the search is     case sensitive; otherwise the search is case insensitive.      \sa QString::count(), contains(), indexOf() */
end_comment
begin_function
DECL|function|count
name|int
name|QStringRef
operator|::
name|count
parameter_list|(
name|QChar
name|ch
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_string_count
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ch
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     \overload count()      Returns the number of (potentially overlapping) occurrences of the     string reference \a str in this string reference.      If \a cs is Qt::CaseSensitive (default), the search is     case sensitive; otherwise the search is case insensitive.      \sa QString::count(), contains(), indexOf() */
end_comment
begin_function
DECL|function|count
name|int
name|QStringRef
operator|::
name|count
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|str
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_string_count
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns \c true if the string reference starts with \a str; otherwise     returns \c false.      If \a cs is Qt::CaseSensitive (default), the search is     case sensitive; otherwise the search is case insensitive.      \sa QString::startsWith(), endsWith() */
end_comment
begin_function
DECL|function|startsWith
name|bool
name|QStringRef
operator|::
name|startsWith
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_starts_with
argument_list|(
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|str
operator|.
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     \overload startsWith()     \sa QString::startsWith(), endsWith() */
end_comment
begin_function
DECL|function|startsWith
name|bool
name|QStringRef
operator|::
name|startsWith
parameter_list|(
name|QLatin1String
name|str
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_starts_with
argument_list|(
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|str
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     \overload startsWith()     \sa QString::startsWith(), endsWith() */
end_comment
begin_function
DECL|function|startsWith
name|bool
name|QStringRef
operator|::
name|startsWith
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|str
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_starts_with
argument_list|(
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|str
operator|.
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     \overload startsWith()      Returns \c true if the string reference starts with \a ch; otherwise     returns \c false.      If \a cs is Qt::CaseSensitive (default), the search is case     sensitive; otherwise the search is case insensitive.      \sa QString::startsWith(), endsWith() */
end_comment
begin_function
DECL|function|startsWith
name|bool
name|QStringRef
operator|::
name|startsWith
parameter_list|(
name|QChar
name|ch
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|ushort
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|unicode
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|?
name|data
index|[
literal|0
index|]
operator|==
name|ch
else|:
name|foldCase
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
operator|==
name|foldCase
argument_list|(
name|ch
operator|.
name|unicode
argument_list|()
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.8     Returns \c true if the string reference ends with \a str; otherwise     returns \c false.      If \a cs is Qt::CaseSensitive (default), the search is case     sensitive; otherwise the search is case insensitive.      \sa QString::endsWith(), startsWith() */
end_comment
begin_function
DECL|function|endsWith
name|bool
name|QStringRef
operator|::
name|endsWith
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_ends_with
argument_list|(
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|str
operator|.
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     \overload endsWith()      Returns \c true if the string reference ends with \a ch; otherwise     returns \c false.      If \a cs is Qt::CaseSensitive (default), the search is case     sensitive; otherwise the search is case insensitive.      \sa QString::endsWith(), endsWith() */
end_comment
begin_function
DECL|function|endsWith
name|bool
name|QStringRef
operator|::
name|endsWith
parameter_list|(
name|QChar
name|ch
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|ushort
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|unicode
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|size
init|=
name|length
argument_list|()
decl_stmt|;
return|return
operator|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|?
name|data
index|[
name|size
operator|-
literal|1
index|]
operator|==
name|ch
else|:
name|foldCase
argument_list|(
name|data
index|[
name|size
operator|-
literal|1
index|]
argument_list|)
operator|==
name|foldCase
argument_list|(
name|ch
operator|.
name|unicode
argument_list|()
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.8     \overload endsWith()     \sa QString::endsWith(), endsWith() */
end_comment
begin_function
DECL|function|endsWith
name|bool
name|QStringRef
operator|::
name|endsWith
parameter_list|(
name|QLatin1String
name|str
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_ends_with
argument_list|(
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|str
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8     \overload endsWith()     \sa QString::endsWith(), endsWith() */
end_comment
begin_function
DECL|function|endsWith
name|bool
name|QStringRef
operator|::
name|endsWith
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|str
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
specifier|const
block|{
return|return
name|qt_ends_with
argument_list|(
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|unicode
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|str
operator|.
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QStringRef::contains(const QString&str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const      \since 4.8     Returns \c true if this string reference contains an occurrence of     the string \a str; otherwise returns \c false.      If \a cs is Qt::CaseSensitive (default), the search is     case sensitive; otherwise the search is case insensitive.      \sa indexOf(), count() */
end_comment
begin_comment
comment|/*! \fn bool QStringRef::contains(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const      \overload contains()     \since 4.8      Returns \c true if this string contains an occurrence of the     character \a ch; otherwise returns \c false.      If \a cs is Qt::CaseSensitive (default), the search is     case sensitive; otherwise the search is case insensitive.  */
end_comment
begin_comment
comment|/*! \fn bool QStringRef::contains(const QStringRef&str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const     \overload contains()     \since 4.8      Returns \c true if this string reference contains an occurrence of     the string reference \a str; otherwise returns \c false.      If \a cs is Qt::CaseSensitive (default), the search is     case sensitive; otherwise the search is case insensitive.      \sa indexOf(), count() */
end_comment
begin_comment
comment|/*! \fn bool QStringRef::contains(QLatin1String str, Qt::CaseSensitivity cs) const     \since 4,8     \overload contains()      Returns \c true if this string reference contains an occurrence of     the string \a str; otherwise returns \c false.      If \a cs is Qt::CaseSensitive (default), the search is     case sensitive; otherwise the search is case insensitive.      \sa indexOf(), count() */
end_comment
begin_function
DECL|function|qt_last_index_of
specifier|static
specifier|inline
name|int
name|qt_last_index_of
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
name|QChar
name|needle
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
name|ushort
name|c
init|=
name|needle
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|+=
name|haystackLen
expr_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|from
argument_list|)
operator|>=
name|uint
argument_list|(
name|haystackLen
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|from
operator|>=
literal|0
condition|)
block|{
specifier|const
name|ushort
modifier|*
name|b
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|haystack
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|n
init|=
name|b
operator|+
name|from
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
for|for
control|(
init|;
name|n
operator|>=
name|b
condition|;
operator|--
name|n
control|)
if|if
condition|(
operator|*
name|n
operator|==
name|c
condition|)
return|return
name|n
operator|-
name|b
return|;
block|}
else|else
block|{
name|c
operator|=
name|foldCase
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>=
name|b
condition|;
operator|--
name|n
control|)
if|if
condition|(
name|foldCase
argument_list|(
operator|*
name|n
argument_list|)
operator|==
name|c
condition|)
return|return
name|n
operator|-
name|b
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|qt_string_count
specifier|static
specifier|inline
name|int
name|qt_string_count
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
specifier|const
name|QChar
modifier|*
name|needle
parameter_list|,
name|int
name|needleLen
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
name|int
name|num
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|haystackLen
operator|>
literal|500
operator|&&
name|needleLen
operator|>
literal|5
condition|)
block|{
name|QStringMatcher
name|matcher
argument_list|(
name|needle
argument_list|,
name|needleLen
argument_list|,
name|cs
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|matcher
operator|.
name|indexIn
argument_list|(
name|haystack
argument_list|,
name|haystackLen
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
operator|++
name|num
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|i
operator|=
name|qFindString
argument_list|(
name|haystack
argument_list|,
name|haystackLen
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|needle
argument_list|,
name|needleLen
argument_list|,
name|cs
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
operator|++
name|num
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_function
begin_function
DECL|function|qt_string_count
specifier|static
specifier|inline
name|int
name|qt_string_count
parameter_list|(
specifier|const
name|QChar
modifier|*
name|unicode
parameter_list|,
name|int
name|size
parameter_list|,
name|QChar
name|ch
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
name|ushort
name|c
init|=
name|ch
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|b
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|unicode
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|i
init|=
name|b
operator|+
name|size
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
while|while
condition|(
name|i
operator|!=
name|b
condition|)
if|if
condition|(
operator|*
operator|--
name|i
operator|==
name|c
condition|)
operator|++
name|num
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|foldCase
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|!=
name|b
condition|)
if|if
condition|(
name|foldCase
argument_list|(
operator|*
operator|(
operator|--
name|i
operator|)
argument_list|)
operator|==
name|c
condition|)
operator|++
name|num
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_function
begin_function
DECL|function|qt_find_latin1_string
specifier|static
specifier|inline
name|int
name|qt_find_latin1_string
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|size
parameter_list|,
name|QLatin1String
name|needle
parameter_list|,
name|int
name|from
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|latin1
init|=
name|needle
operator|.
name|latin1
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|needle
operator|.
name|size
argument_list|()
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|ushort
argument_list|>
name|s
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|qt_from_latin1
argument_list|(
name|s
operator|.
name|data
argument_list|()
argument_list|,
name|latin1
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|qFindString
argument_list|(
name|haystack
argument_list|,
name|size
argument_list|,
name|from
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|s
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|,
name|len
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qt_starts_with
specifier|static
specifier|inline
name|bool
name|qt_starts_with
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
specifier|const
name|QChar
modifier|*
name|needle
parameter_list|,
name|int
name|needleLen
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|haystack
condition|)
return|return
operator|!
name|needle
return|;
if|if
condition|(
name|haystackLen
operator|==
literal|0
condition|)
return|return
name|needleLen
operator|==
literal|0
return|;
if|if
condition|(
name|needleLen
operator|>
name|haystackLen
condition|)
return|return
literal|false
return|;
specifier|const
name|ushort
modifier|*
name|h
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|haystack
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|n
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|needle
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
return|return
name|qMemEquals
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
name|needleLen
argument_list|)
return|;
block|}
else|else
block|{
name|uint
name|last
init|=
literal|0
decl_stmt|;
name|uint
name|olast
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|needleLen
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|foldCase
argument_list|(
name|h
index|[
name|i
index|]
argument_list|,
name|last
argument_list|)
operator|!=
name|foldCase
argument_list|(
name|n
index|[
name|i
index|]
argument_list|,
name|olast
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|qt_starts_with
specifier|static
specifier|inline
name|bool
name|qt_starts_with
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
name|QLatin1String
name|needle
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|haystack
condition|)
return|return
operator|!
name|needle
operator|.
name|latin1
argument_list|()
return|;
if|if
condition|(
name|haystackLen
operator|==
literal|0
condition|)
return|return
operator|!
name|needle
operator|.
name|latin1
argument_list|()
operator|||
operator|*
name|needle
operator|.
name|latin1
argument_list|()
operator|==
literal|0
return|;
specifier|const
name|int
name|slen
init|=
name|needle
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|slen
operator|>
name|haystackLen
condition|)
return|return
literal|false
return|;
specifier|const
name|ushort
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|haystack
argument_list|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|latin
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|needle
operator|.
name|latin1
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
return|return
name|ucstrncmp
argument_list|(
name|haystack
argument_list|,
name|latin
argument_list|,
name|slen
argument_list|)
operator|==
literal|0
return|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|slen
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|foldCase
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
operator|!=
name|foldCase
argument_list|(
operator|(
name|ushort
operator|)
name|latin
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|qt_ends_with
specifier|static
specifier|inline
name|bool
name|qt_ends_with
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
specifier|const
name|QChar
modifier|*
name|needle
parameter_list|,
name|int
name|needleLen
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|haystack
condition|)
return|return
operator|!
name|needle
return|;
if|if
condition|(
name|haystackLen
operator|==
literal|0
condition|)
return|return
name|needleLen
operator|==
literal|0
return|;
specifier|const
name|int
name|pos
init|=
name|haystackLen
operator|-
name|needleLen
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
literal|false
return|;
specifier|const
name|ushort
modifier|*
name|h
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|haystack
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|n
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|needle
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
return|return
name|qMemEquals
argument_list|(
name|h
operator|+
name|pos
argument_list|,
name|n
argument_list|,
name|needleLen
argument_list|)
return|;
block|}
else|else
block|{
name|uint
name|last
init|=
literal|0
decl_stmt|;
name|uint
name|olast
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|needleLen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|foldCase
argument_list|(
name|h
index|[
name|pos
operator|+
name|i
index|]
argument_list|,
name|last
argument_list|)
operator|!=
name|foldCase
argument_list|(
name|n
index|[
name|i
index|]
argument_list|,
name|olast
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|qt_ends_with
specifier|static
specifier|inline
name|bool
name|qt_ends_with
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
name|QLatin1String
name|needle
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|haystack
condition|)
return|return
operator|!
name|needle
operator|.
name|latin1
argument_list|()
return|;
if|if
condition|(
name|haystackLen
operator|==
literal|0
condition|)
return|return
operator|!
name|needle
operator|.
name|latin1
argument_list|()
operator|||
operator|*
name|needle
operator|.
name|latin1
argument_list|()
operator|==
literal|0
return|;
specifier|const
name|int
name|slen
init|=
name|needle
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|haystackLen
operator|-
name|slen
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
literal|false
return|;
specifier|const
name|uchar
modifier|*
name|latin
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|needle
operator|.
name|latin1
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|haystack
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
return|return
name|ucstrncmp
argument_list|(
name|haystack
operator|+
name|pos
argument_list|,
name|latin
argument_list|,
name|slen
argument_list|)
operator|==
literal|0
return|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|slen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|foldCase
argument_list|(
name|data
index|[
name|pos
operator|+
name|i
index|]
argument_list|)
operator|!=
name|foldCase
argument_list|(
operator|(
name|ushort
operator|)
name|latin
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns a Latin-1 representation of the string as a QByteArray.      The returned byte array is undefined if the string contains non-Latin1     characters. Those characters may be suppressed or replaced with a     question mark.      \sa toUtf8(), toLocal8Bit(), QTextCodec */
end_comment
begin_function
DECL|function|toLatin1
name|QByteArray
name|QStringRef
operator|::
name|toLatin1
parameter_list|()
specifier|const
block|{
return|return
name|QString
operator|::
name|toLatin1_helper
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|length
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray QStringRef::toAscii() const     \since 4.8     \deprecated      Returns an 8-bit representation of the string as a QByteArray.      This function does the same as toLatin1().      Note that, despite the name, this function does not necessarily return an US-ASCII     (ANSI X3.4-1986) string and its result may not be US-ASCII compatible.      \sa toLatin1(), toUtf8(), toLocal8Bit(), QTextCodec */
end_comment
begin_comment
comment|/*!     \since 4.8      Returns the local 8-bit representation of the string as a     QByteArray. The returned byte array is undefined if the string     contains characters not supported by the local 8-bit encoding.      QTextCodec::codecForLocale() is used to perform the conversion from     Unicode. If the locale encoding could not be determined, this function     does the same as toLatin1().      If this string contains any characters that cannot be encoded in the     locale, the returned byte array is undefined. Those characters may be     suppressed or replaced by another.      \sa toLatin1(), toUtf8(), QTextCodec */
end_comment
begin_function
DECL|function|toLocal8Bit
name|QByteArray
name|QStringRef
operator|::
name|toLocal8Bit
parameter_list|()
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|QTextCodec
modifier|*
name|localeCodec
init|=
name|QTextCodec
operator|::
name|codecForLocale
argument_list|()
decl_stmt|;
if|if
condition|(
name|localeCodec
condition|)
return|return
name|localeCodec
operator|->
name|fromUnicode
argument_list|(
name|unicode
argument_list|()
argument_list|,
name|length
argument_list|()
argument_list|)
return|;
endif|#
directive|endif
comment|// QT_NO_TEXTCODEC
return|return
name|toLatin1
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns a UTF-8 representation of the string as a QByteArray.      UTF-8 is a Unicode codec and can represent all characters in a Unicode     string like QString.      \sa toLatin1(), toLocal8Bit(), QTextCodec */
end_comment
begin_function
DECL|function|toUtf8
name|QByteArray
name|QStringRef
operator|::
name|toUtf8
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|QByteArray
argument_list|()
return|;
return|return
name|QUtf8
operator|::
name|convertFromUnicode
argument_list|(
name|constData
argument_list|()
argument_list|,
name|length
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns a UCS-4/UTF-32 representation of the string as a QVector<uint>.      UCS-4 is a Unicode codec and therefore it is lossless. All characters from     this string will be encoded in UCS-4. Any invalid sequence of code units in     this string is replaced by the Unicode's replacement character     (QChar::ReplacementCharacter, which corresponds to \c{U+FFFD}).      The returned vector is not NUL terminated.      \sa toUtf8(), toLatin1(), toLocal8Bit(), QTextCodec */
end_comment
begin_function
DECL|function|toUcs4
name|QVector
argument_list|<
name|uint
argument_list|>
name|QStringRef
operator|::
name|toUcs4
parameter_list|()
specifier|const
block|{
name|QVector
argument_list|<
name|uint
argument_list|>
name|v
argument_list|(
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|uint
modifier|*
name|a
init|=
name|v
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|QString
operator|::
name|toUcs4_helper
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|unicode
argument_list|()
argument_list|)
argument_list|,
name|length
argument_list|()
argument_list|,
name|a
argument_list|)
decl_stmt|;
name|v
operator|.
name|resize
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a string that has whitespace removed from the start and     the end.      Whitespace means any character for which QChar::isSpace() returns     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',     '\\f', '\\r', and ' '.      Unlike QString::simplified(), trimmed() leaves internal whitespace alone.      \since 5.1      \sa QString::trimmed() */
end_comment
begin_function
DECL|function|trimmed
name|QStringRef
name|QStringRef
operator|::
name|trimmed
parameter_list|()
specifier|const
block|{
specifier|const
name|QChar
modifier|*
name|begin
init|=
name|cbegin
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|end
init|=
name|cend
argument_list|()
decl_stmt|;
name|QStringAlgorithms
argument_list|<
specifier|const
name|QStringRef
argument_list|>
operator|::
name|trimmed_helper_positions
argument_list|(
name|begin
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin
operator|==
name|cbegin
argument_list|()
operator|&&
name|end
operator|==
name|cend
argument_list|()
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|begin
operator|==
name|end
condition|)
return|return
name|QStringRef
argument_list|()
return|;
name|int
name|position
init|=
name|m_position
operator|+
operator|(
name|begin
operator|-
name|cbegin
argument_list|()
operator|)
decl_stmt|;
return|return
name|QStringRef
argument_list|(
name|m_string
argument_list|,
name|position
argument_list|,
name|end
operator|-
name|begin
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to a \c{long long} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toLongLong()      \sa QString::toLongLong()      \since 5.1 */
end_comment
begin_function
DECL|function|toLongLong
name|qint64
name|QStringRef
operator|::
name|toLongLong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|QString
operator|::
name|toIntegral_helper
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to an \c{unsigned long long} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toULongLong()      \sa QString::toULongLong()      \since 5.1 */
end_comment
begin_function
DECL|function|toULongLong
name|quint64
name|QStringRef
operator|::
name|toULongLong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|QString
operator|::
name|toIntegral_helper
argument_list|<
name|quint64
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn long QStringRef::toLong(bool *ok, int base) const      Returns the string converted to a \c long using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toLong()      \sa QString::toLong()      \since 5.1 */
end_comment
begin_function
DECL|function|toLong
name|long
name|QStringRef
operator|::
name|toLong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|QString
operator|::
name|toIntegral_helper
argument_list|<
name|long
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn ulong QStringRef::toULong(bool *ok, int base) const      Returns the string converted to an \c{unsigned long} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toULongLong()      \sa QString::toULong()      \since 5.1 */
end_comment
begin_function
DECL|function|toULong
name|ulong
name|QStringRef
operator|::
name|toULong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|QString
operator|::
name|toIntegral_helper
argument_list|<
name|ulong
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to an \c int using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toInt()      \sa QString::toInt()      \since 5.1 */
end_comment
begin_function
DECL|function|toInt
name|int
name|QStringRef
operator|::
name|toInt
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|QString
operator|::
name|toIntegral_helper
argument_list|<
name|int
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to an \c{unsigned int} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toUInt()      \sa QString::toUInt()      \since 5.1 */
end_comment
begin_function
DECL|function|toUInt
name|uint
name|QStringRef
operator|::
name|toUInt
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|QString
operator|::
name|toIntegral_helper
argument_list|<
name|uint
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to a \c short using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toShort()      \sa QString::toShort()      \since 5.1 */
end_comment
begin_function
DECL|function|toShort
name|short
name|QStringRef
operator|::
name|toShort
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|QString
operator|::
name|toIntegral_helper
argument_list|<
name|short
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to an \c{unsigned short} using base \a     base, which is 10 by default and must be between 2 and 36, or 0.     Returns 0 if the conversion fails.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true.      If \a base is 0, the C language convention is used: If the string     begins with "0x", base 16 is used; if the string begins with "0",     base 8 is used; otherwise, base 10 is used.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toUShort()      \sa QString::toUShort()      \since 5.1 */
end_comment
begin_function
DECL|function|toUShort
name|ushort
name|QStringRef
operator|::
name|toUShort
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|,
name|int
name|base
parameter_list|)
specifier|const
block|{
return|return
name|QString
operator|::
name|toIntegral_helper
argument_list|<
name|ushort
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to a \c double value.      Returns 0.0 if the conversion fails.      If a conversion error occurs, \c{*}\a{ok} is set to \c false;     otherwise \c{*}\a{ok} is set to \c true.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toDouble()      For historic reasons, this function does not handle     thousands group separators. If you need to convert such numbers,     use QLocale::toDouble().      \sa QString::toDouble()      \since 5.1 */
end_comment
begin_function
DECL|function|toDouble
name|double
name|QStringRef
operator|::
name|toDouble
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
return|return
name|QLocaleData
operator|::
name|c
argument_list|()
operator|->
name|stringToDouble
argument_list|(
name|constData
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|ok
argument_list|,
name|QLocaleData
operator|::
name|FailOnGroupSeparators
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string converted to a \c float value.      If a conversion error occurs, *\a{ok} is set to \c false; otherwise     *\a{ok} is set to \c true. Returns 0.0 if the conversion fails.      The string conversion will always happen in the 'C' locale. For locale     dependent conversion use QLocale::toFloat()      \sa QString::toFloat()      \since 5.1 */
end_comment
begin_function
DECL|function|toFloat
name|float
name|QStringRef
operator|::
name|toFloat
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
return|return
name|QLocaleData
operator|::
name|convertDoubleToFloat
argument_list|(
name|toDouble
argument_list|(
name|ok
argument_list|)
argument_list|,
name|ok
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete     \fn QString Qt::escape(const QString&plain)      \sa QString::toHtmlEscaped() */
end_comment
begin_comment
comment|/*!     \since 5.0      Converts a plain text string to an HTML string with     HTML metacharacters \c{<}, \c{>}, \c{&}, and \c{"} replaced by HTML     entities.      Example:      \snippet code/src_corelib_tools_qstring.cpp 7 */
end_comment
begin_function
DECL|function|toHtmlEscaped
name|QString
name|QString
operator|::
name|toHtmlEscaped
parameter_list|()
specifier|const
block|{
name|QString
name|rich
decl_stmt|;
specifier|const
name|int
name|len
init|=
name|length
argument_list|()
decl_stmt|;
name|rich
operator|.
name|reserve
argument_list|(
name|int
argument_list|(
name|len
operator|*
literal|1.1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'<'
argument_list|)
condition|)
name|rich
operator|+=
name|QLatin1String
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
condition|)
name|rich
operator|+=
name|QLatin1String
argument_list|(
literal|"&gt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'&'
argument_list|)
condition|)
name|rich
operator|+=
name|QLatin1String
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'"'
argument_list|)
condition|)
name|rich
operator|+=
name|QLatin1String
argument_list|(
literal|"&quot;"
argument_list|)
expr_stmt|;
else|else
name|rich
operator|+=
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|rich
operator|.
name|squeeze
argument_list|()
expr_stmt|;
return|return
name|rich
return|;
block|}
end_function
begin_comment
comment|/*!   \macro QStringLiteral(str)   \relates QString    The macro generates the data for a QString out of \a str at compile time if the compiler supports it.   Creating a QString from it is free in this case, and the generated string data is stored in   the read-only segment of the compiled object file.    For compilers not supporting the creation of compile time strings, QStringLiteral will fall back to   QString::fromUtf8().    If you have code looking like:   \code   if (node.hasAttribute("http-contents-length")) //...   \endcode   One temporary QString will be created to be passed as the hasAttribute function parameter.   This can be quite expensive, as it involves a memory allocation and the copy and the conversion   of the data into QString's internal encoding.    This can be avoided by doing   \code   if (node.hasAttribute(QStringLiteral("http-contents-length"))) //...   \endcode   Then the QString's internal data will be generated at compile time and no conversion or allocation   will occur at runtime    Using QStringLiteral instead of a double quoted ascii literal can significantly speed up creation   of QString's from data known at compile time.    If the compiler is C++11 enabled the string \a str can actually contain unicode data.    \note There are still a few cases in which QLatin1String is more efficient than QStringLiteral:   If it is passed to a function that has an overload that takes the QLatin1String directly, without   conversion to QString. For instance, this is the case of QString::operator==   \code   if (attribute.name() == QLatin1String("http-contents-length")) //...   \endcode    \note There are some restrictions when using the MSVC 2010 or 2012 compilers. The example snippets   provided here fail to compile with them.   \list   \li Concatenated string literals cannot be used with QStringLiteral.   \code   QString s = QStringLiteral("a" "b");   \endcode   \li QStringLiteral cannot be used to initialize lists or arrays of QString.   \code   QString a[] = { QStringLiteral("a"), QStringLiteral("b") };   \endcode   \endlist */
end_comment
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|appendLatin1To
name|void
name|QAbstractConcatenable
operator|::
name|appendLatin1To
parameter_list|(
specifier|const
name|char
modifier|*
name|a
parameter_list|,
name|int
name|len
parameter_list|,
name|QChar
modifier|*
name|out
parameter_list|)
block|{
name|qt_from_latin1
argument_list|(
cast|reinterpret_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|out
argument_list|)
argument_list|,
name|a
argument_list|,
name|uint
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
