begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 John Layt<jlayt@kde.org> ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtimezone.h"
end_include
begin_include
include|#
directive|include
file|"qtimezoneprivate_p.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/*     Private      Windows system implementation */
DECL|macro|MAX_KEY_LENGTH
define|#
directive|define
name|MAX_KEY_LENGTH
value|255
DECL|macro|FILETIME_UNIX_EPOCH
define|#
directive|define
name|FILETIME_UNIX_EPOCH
value|Q_UINT64_C(116444736000000000)
comment|// MSDN home page for Time support
comment|// http://msdn.microsoft.com/en-us/library/windows/desktop/ms724962%28v=vs.85%29.aspx
comment|// For Windows XP and later refer to MSDN docs on TIME_ZONE_INFORMATION structure
comment|// http://msdn.microsoft.com/en-gb/library/windows/desktop/ms725481%28v=vs.85%29.aspx
comment|// Vista introduced support for historic data, see MSDN docs on DYNAMIC_TIME_ZONE_INFORMATION
comment|// http://msdn.microsoft.com/en-gb/library/windows/desktop/ms724253%28v=vs.85%29.aspx
DECL|variable|tzRegPath
specifier|static
specifier|const
name|char
name|tzRegPath
index|[]
init|=
literal|"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|currTzRegPath
specifier|static
specifier|const
name|char
name|currTzRegPath
index|[]
init|=
literal|"SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation"
decl_stmt|;
end_decl_stmt
begin_enum
enum|enum
block|{
DECL|enumerator|MIN_YEAR
name|MIN_YEAR
init|=
operator|-
literal|292275056
block|,
DECL|enumerator|MAX_YEAR
name|MAX_YEAR
init|=
literal|292278994
block|,
DECL|enumerator|MSECS_PER_DAY
name|MSECS_PER_DAY
init|=
literal|86400000
block|,
DECL|enumerator|TIME_T_MAX
name|TIME_T_MAX
init|=
literal|2145916799
block|,
comment|// int maximum 2037-12-31T23:59:59 UTC
DECL|enumerator|JULIAN_DAY_FOR_EPOCH
name|JULIAN_DAY_FOR_EPOCH
init|=
literal|2440588
comment|// result of julianDayFromDate(1970, 1, 1)
block|}
enum|;
end_enum
begin_comment
comment|// Copied from MSDN, see above for link
end_comment
begin_typedef
DECL|struct|_REG_TZI_FORMAT
typedef|typedef
struct|struct
name|_REG_TZI_FORMAT
block|{
DECL|member|Bias
name|LONG
name|Bias
decl_stmt|;
DECL|member|StandardBias
name|LONG
name|StandardBias
decl_stmt|;
DECL|member|DaylightBias
name|LONG
name|DaylightBias
decl_stmt|;
DECL|member|StandardDate
name|SYSTEMTIME
name|StandardDate
decl_stmt|;
DECL|member|DaylightDate
name|SYSTEMTIME
name|DaylightDate
decl_stmt|;
block|}
DECL|typedef|REG_TZI_FORMAT
name|REG_TZI_FORMAT
typedef|;
end_typedef
begin_comment
comment|// Fast and reliable conversion from msecs to date for all values
end_comment
begin_comment
comment|// Adapted from QDateTime msecsToDate
end_comment
begin_function
DECL|function|msecsToDate
specifier|static
name|QDate
name|msecsToDate
parameter_list|(
name|qint64
name|msecs
parameter_list|)
block|{
name|qint64
name|jd
init|=
name|JULIAN_DAY_FOR_EPOCH
decl_stmt|;
if|if
condition|(
name|qAbs
argument_list|(
name|msecs
argument_list|)
operator|>=
name|MSECS_PER_DAY
condition|)
block|{
name|jd
operator|+=
operator|(
name|msecs
operator|/
name|MSECS_PER_DAY
operator|)
expr_stmt|;
name|msecs
operator|%=
name|MSECS_PER_DAY
expr_stmt|;
block|}
if|if
condition|(
name|msecs
operator|<
literal|0
condition|)
block|{
name|qint64
name|ds
init|=
name|MSECS_PER_DAY
operator|-
name|msecs
operator|-
literal|1
decl_stmt|;
name|jd
operator|-=
name|ds
operator|/
name|MSECS_PER_DAY
expr_stmt|;
block|}
return|return
name|QDate
operator|::
name|fromJulianDay
argument_list|(
name|jd
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|equalSystemtime
specifier|static
name|bool
name|equalSystemtime
parameter_list|(
specifier|const
name|SYSTEMTIME
modifier|&
name|t1
parameter_list|,
specifier|const
name|SYSTEMTIME
modifier|&
name|t2
parameter_list|)
block|{
return|return
operator|(
name|t1
operator|.
name|wYear
operator|==
name|t2
operator|.
name|wYear
operator|&&
name|t1
operator|.
name|wMonth
operator|==
name|t2
operator|.
name|wMonth
operator|&&
name|t1
operator|.
name|wDay
operator|==
name|t2
operator|.
name|wDay
operator|&&
name|t1
operator|.
name|wDayOfWeek
operator|==
name|t2
operator|.
name|wDayOfWeek
operator|&&
name|t1
operator|.
name|wHour
operator|==
name|t2
operator|.
name|wHour
operator|&&
name|t1
operator|.
name|wMinute
operator|==
name|t2
operator|.
name|wMinute
operator|&&
name|t1
operator|.
name|wSecond
operator|==
name|t2
operator|.
name|wSecond
operator|&&
name|t1
operator|.
name|wMilliseconds
operator|==
name|t2
operator|.
name|wMilliseconds
operator|)
return|;
block|}
end_function
begin_function
DECL|function|equalTzi
specifier|static
name|bool
name|equalTzi
parameter_list|(
specifier|const
name|TIME_ZONE_INFORMATION
modifier|&
name|tzi1
parameter_list|,
specifier|const
name|TIME_ZONE_INFORMATION
modifier|&
name|tzi2
parameter_list|)
block|{
return|return
operator|(
name|tzi1
operator|.
name|Bias
operator|==
name|tzi2
operator|.
name|Bias
operator|&&
name|tzi1
operator|.
name|StandardBias
operator|==
name|tzi2
operator|.
name|StandardBias
operator|&&
name|equalSystemtime
argument_list|(
name|tzi1
operator|.
name|StandardDate
argument_list|,
name|tzi2
operator|.
name|StandardDate
argument_list|)
operator|&&
name|wcscmp
argument_list|(
name|tzi1
operator|.
name|StandardName
argument_list|,
name|tzi2
operator|.
name|StandardName
argument_list|)
operator|==
literal|0
operator|&&
name|tzi1
operator|.
name|DaylightBias
operator|==
name|tzi2
operator|.
name|DaylightBias
operator|&&
name|equalSystemtime
argument_list|(
name|tzi1
operator|.
name|DaylightDate
argument_list|,
name|tzi2
operator|.
name|DaylightDate
argument_list|)
operator|&&
name|wcscmp
argument_list|(
name|tzi1
operator|.
name|DaylightName
argument_list|,
name|tzi2
operator|.
name|DaylightName
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|openRegistryKey
specifier|static
name|bool
name|openRegistryKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|keyPath
parameter_list|,
name|HKEY
modifier|*
name|key
parameter_list|)
block|{
return|return
operator|(
name|RegOpenKeyEx
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|keyPath
operator|.
name|utf16
argument_list|()
argument_list|,
literal|0
argument_list|,
name|KEY_READ
argument_list|,
name|key
argument_list|)
operator|==
name|ERROR_SUCCESS
operator|)
return|;
block|}
end_function
begin_function
DECL|function|readRegistryString
specifier|static
name|QString
name|readRegistryString
parameter_list|(
specifier|const
name|HKEY
modifier|&
name|key
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|value
parameter_list|)
block|{
name|wchar_t
name|buffer
index|[
name|MAX_PATH
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|DWORD
name|size
init|=
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
operator|*
name|MAX_PATH
decl_stmt|;
name|RegQueryValueEx
argument_list|(
name|key
argument_list|,
operator|(
name|LPCWSTR
operator|)
name|value
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|LPBYTE
operator|)
name|buffer
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
return|return
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|readRegistryValue
specifier|static
name|int
name|readRegistryValue
parameter_list|(
specifier|const
name|HKEY
modifier|&
name|key
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|value
parameter_list|)
block|{
name|DWORD
name|buffer
decl_stmt|;
name|DWORD
name|size
init|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|RegQueryValueEx
argument_list|(
name|key
argument_list|,
operator|(
name|LPCWSTR
operator|)
name|value
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|LPBYTE
operator|)
operator|&
name|buffer
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function
begin_function
DECL|function|readRegistryRule
specifier|static
name|QWinTimeZonePrivate
operator|::
name|QWinTransitionRule
name|readRegistryRule
parameter_list|(
specifier|const
name|HKEY
modifier|&
name|key
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|value
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
name|QWinTimeZonePrivate
operator|::
name|QWinTransitionRule
name|rule
decl_stmt|;
name|REG_TZI_FORMAT
name|tzi
decl_stmt|;
name|DWORD
name|tziSize
init|=
sizeof|sizeof
argument_list|(
name|tzi
argument_list|)
decl_stmt|;
if|if
condition|(
name|RegQueryValueEx
argument_list|(
name|key
argument_list|,
operator|(
name|LPCWSTR
operator|)
name|value
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
operator|&
name|tzi
argument_list|,
operator|&
name|tziSize
argument_list|)
operator|==
name|ERROR_SUCCESS
condition|)
block|{
name|rule
operator|.
name|startYear
operator|=
literal|0
expr_stmt|;
name|rule
operator|.
name|standardTimeBias
operator|=
name|tzi
operator|.
name|Bias
operator|+
name|tzi
operator|.
name|StandardBias
expr_stmt|;
name|rule
operator|.
name|daylightTimeBias
operator|=
name|tzi
operator|.
name|Bias
operator|+
name|tzi
operator|.
name|DaylightBias
operator|-
name|rule
operator|.
name|standardTimeBias
expr_stmt|;
name|rule
operator|.
name|standardTimeRule
operator|=
name|tzi
operator|.
name|StandardDate
expr_stmt|;
name|rule
operator|.
name|daylightTimeRule
operator|=
name|tzi
operator|.
name|DaylightDate
expr_stmt|;
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|rule
return|;
block|}
end_function
begin_function
DECL|function|getRegistryTzi
specifier|static
name|TIME_ZONE_INFORMATION
name|getRegistryTzi
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|windowsId
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
name|TIME_ZONE_INFORMATION
name|tzi
decl_stmt|;
name|REG_TZI_FORMAT
name|regTzi
decl_stmt|;
name|DWORD
name|regTziSize
init|=
sizeof|sizeof
argument_list|(
name|regTzi
argument_list|)
decl_stmt|;
name|HKEY
name|key
init|=
name|NULL
decl_stmt|;
specifier|const
name|QString
name|tziKeyPath
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|tzRegPath
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
operator|+
name|QString
operator|::
name|fromUtf8
argument_list|(
name|windowsId
argument_list|)
decl_stmt|;
if|if
condition|(
name|openRegistryKey
argument_list|(
name|tziKeyPath
argument_list|,
operator|&
name|key
argument_list|)
condition|)
block|{
name|DWORD
name|size
init|=
sizeof|sizeof
argument_list|(
name|tzi
operator|.
name|DaylightName
argument_list|)
decl_stmt|;
name|RegQueryValueEx
argument_list|(
name|key
argument_list|,
literal|L"Dlt"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|LPBYTE
operator|)
name|tzi
operator|.
name|DaylightName
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tzi
operator|.
name|StandardName
argument_list|)
expr_stmt|;
name|RegQueryValueEx
argument_list|(
name|key
argument_list|,
literal|L"Std"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|LPBYTE
operator|)
name|tzi
operator|.
name|StandardName
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|RegQueryValueEx
argument_list|(
name|key
argument_list|,
literal|L"TZI"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
operator|&
name|regTzi
argument_list|,
operator|&
name|regTziSize
argument_list|)
operator|==
name|ERROR_SUCCESS
condition|)
block|{
name|tzi
operator|.
name|Bias
operator|=
name|regTzi
operator|.
name|Bias
expr_stmt|;
name|tzi
operator|.
name|StandardBias
operator|=
name|regTzi
operator|.
name|StandardBias
expr_stmt|;
name|tzi
operator|.
name|DaylightBias
operator|=
name|regTzi
operator|.
name|DaylightBias
expr_stmt|;
name|tzi
operator|.
name|StandardDate
operator|=
name|regTzi
operator|.
name|StandardDate
expr_stmt|;
name|tzi
operator|.
name|DaylightDate
operator|=
name|regTzi
operator|.
name|DaylightDate
expr_stmt|;
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
block|}
name|RegCloseKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|tzi
return|;
block|}
end_function
begin_function
DECL|function|availableWindowsIds
specifier|static
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|availableWindowsIds
parameter_list|()
block|{
comment|// TODO Consider caching results in a global static, very unlikely to change.
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
name|HKEY
name|key
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|openRegistryKey
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
name|tzRegPath
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
condition|)
block|{
name|DWORD
name|idCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|RegQueryInfoKey
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|idCount
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|ERROR_SUCCESS
operator|&&
name|idCount
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|DWORD
name|i
init|=
literal|0
init|;
name|i
operator|<
name|idCount
condition|;
operator|++
name|i
control|)
block|{
name|DWORD
name|maxLen
init|=
name|MAX_KEY_LENGTH
decl_stmt|;
name|TCHAR
name|buffer
index|[
name|MAX_KEY_LENGTH
index|]
decl_stmt|;
if|if
condition|(
name|RegEnumKeyEx
argument_list|(
name|key
argument_list|,
name|i
argument_list|,
name|buffer
argument_list|,
operator|&
name|maxLen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|ERROR_SUCCESS
condition|)
name|list
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|buffer
argument_list|)
operator|.
name|toUtf8
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|RegCloseKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|windowsSystemZoneId
specifier|static
name|QByteArray
name|windowsSystemZoneId
parameter_list|()
block|{
comment|// On Vista and later is held in the value TimeZoneKeyName in key currTzRegPath
name|QString
name|id
decl_stmt|;
name|HKEY
name|key
init|=
name|NULL
decl_stmt|;
name|QString
name|tziKeyPath
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|currTzRegPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|openRegistryKey
argument_list|(
name|tziKeyPath
argument_list|,
operator|&
name|key
argument_list|)
condition|)
block|{
name|id
operator|=
name|readRegistryString
argument_list|(
name|key
argument_list|,
literal|L"TimeZoneKeyName"
argument_list|)
expr_stmt|;
name|RegCloseKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|id
operator|.
name|toUtf8
argument_list|()
return|;
block|}
comment|// On XP we have to iterate over the zones until we find a match on
comment|// names/offsets with the current data
name|TIME_ZONE_INFORMATION
name|sysTzi
decl_stmt|;
name|GetTimeZoneInformation
argument_list|(
operator|&
name|sysTzi
argument_list|)
expr_stmt|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|winId
decl|,
name|availableWindowsIds
argument_list|()
control|)
block|{
if|if
condition|(
name|equalTzi
argument_list|(
name|getRegistryTzi
argument_list|(
name|winId
argument_list|,
operator|&
name|ok
argument_list|)
argument_list|,
name|sysTzi
argument_list|)
condition|)
return|return
name|winId
return|;
block|}
comment|// If we can't determine the current ID use UTC
return|return
name|QByteArrayLiteral
argument_list|(
literal|"UTC"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|calculateTransitionLocalDate
specifier|static
name|QDate
name|calculateTransitionLocalDate
parameter_list|(
specifier|const
name|SYSTEMTIME
modifier|&
name|rule
parameter_list|,
name|int
name|year
parameter_list|)
block|{
name|SYSTEMTIME
name|time
init|=
name|rule
decl_stmt|;
comment|// If the year isn't set, then the rule date is relative
if|if
condition|(
name|time
operator|.
name|wYear
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|time
operator|.
name|wDayOfWeek
operator|==
literal|0
condition|)
name|time
operator|.
name|wDayOfWeek
operator|=
literal|7
expr_stmt|;
name|QDate
name|date
argument_list|(
name|year
argument_list|,
name|time
operator|.
name|wMonth
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|startDow
init|=
name|date
operator|.
name|dayOfWeek
argument_list|()
decl_stmt|;
if|if
condition|(
name|startDow
operator|<=
name|time
operator|.
name|wDayOfWeek
condition|)
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
name|time
operator|.
name|wDayOfWeek
operator|-
name|startDow
operator|-
literal|7
argument_list|)
expr_stmt|;
else|else
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
name|time
operator|.
name|wDayOfWeek
operator|-
name|startDow
argument_list|)
expr_stmt|;
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
name|time
operator|.
name|wDay
operator|*
literal|7
argument_list|)
expr_stmt|;
while|while
condition|(
name|date
operator|.
name|month
argument_list|()
operator|!=
name|time
operator|.
name|wMonth
condition|)
name|date
operator|=
name|date
operator|.
name|addDays
argument_list|(
operator|-
literal|7
argument_list|)
expr_stmt|;
return|return
name|date
return|;
block|}
else|else
block|{
return|return
name|QDate
argument_list|(
name|time
operator|.
name|wYear
argument_list|,
name|time
operator|.
name|wMonth
argument_list|,
name|time
operator|.
name|wDay
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|// Converts a date/time value into msecs
end_comment
begin_function
DECL|function|timeToMSecs
specifier|static
specifier|inline
name|qint64
name|timeToMSecs
parameter_list|(
specifier|const
name|QDate
modifier|&
name|date
parameter_list|,
specifier|const
name|QTime
modifier|&
name|time
parameter_list|)
block|{
return|return
operator|(
operator|(
name|date
operator|.
name|toJulianDay
argument_list|()
operator|-
name|JULIAN_DAY_FOR_EPOCH
operator|)
operator|*
name|MSECS_PER_DAY
operator|)
operator|+
name|time
operator|.
name|msecsSinceStartOfDay
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|calculateTransitionsForYear
specifier|static
name|void
name|calculateTransitionsForYear
parameter_list|(
specifier|const
name|QWinTimeZonePrivate
operator|::
name|QWinTransitionRule
modifier|&
name|rule
parameter_list|,
name|int
name|year
parameter_list|,
name|qint64
modifier|*
name|stdMSecs
parameter_list|,
name|qint64
modifier|*
name|dstMSecs
parameter_list|)
block|{
comment|// TODO Consider caching the calculated values
comment|// The local time in Daylight Time when switches to Standard TIme
name|QDate
name|standardDate
init|=
name|calculateTransitionLocalDate
argument_list|(
name|rule
operator|.
name|standardTimeRule
argument_list|,
name|year
argument_list|)
decl_stmt|;
name|QTime
name|standardTime
init|=
name|QTime
argument_list|(
name|rule
operator|.
name|standardTimeRule
operator|.
name|wHour
argument_list|,
name|rule
operator|.
name|standardTimeRule
operator|.
name|wMinute
argument_list|,
name|rule
operator|.
name|standardTimeRule
operator|.
name|wSecond
argument_list|)
decl_stmt|;
comment|// The local time in Standard Time when switches to Daylight TIme
name|QDate
name|daylightDate
init|=
name|calculateTransitionLocalDate
argument_list|(
name|rule
operator|.
name|daylightTimeRule
argument_list|,
name|year
argument_list|)
decl_stmt|;
name|QTime
name|daylightTime
init|=
name|QTime
argument_list|(
name|rule
operator|.
name|daylightTimeRule
operator|.
name|wHour
argument_list|,
name|rule
operator|.
name|daylightTimeRule
operator|.
name|wMinute
argument_list|,
name|rule
operator|.
name|daylightTimeRule
operator|.
name|wSecond
argument_list|)
decl_stmt|;
operator|*
name|stdMSecs
operator|=
name|timeToMSecs
argument_list|(
name|standardDate
argument_list|,
name|standardTime
argument_list|)
operator|+
operator|(
operator|(
name|rule
operator|.
name|standardTimeBias
operator|+
name|rule
operator|.
name|daylightTimeBias
operator|)
operator|*
literal|60000
operator|)
expr_stmt|;
operator|*
name|dstMSecs
operator|=
name|timeToMSecs
argument_list|(
name|daylightDate
argument_list|,
name|daylightTime
argument_list|)
operator|+
operator|(
name|rule
operator|.
name|standardTimeBias
operator|*
literal|60000
operator|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|userCountry
specifier|static
name|QLocale
operator|::
name|Country
name|userCountry
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
comment|// Guess that the syslem locale country is the right one to use
comment|// TODO Find if WinCE has equivalent api
return|return
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|country
argument_list|()
return|;
else|#
directive|else
specifier|const
name|GEOID
name|id
init|=
name|GetUserGeoID
argument_list|(
name|GEOCLASS_NATION
argument_list|)
decl_stmt|;
name|wchar_t
name|code
index|[
literal|3
index|]
decl_stmt|;
specifier|const
name|int
name|size
init|=
name|GetGeoInfo
argument_list|(
name|id
argument_list|,
name|GEO_ISO2
argument_list|,
name|code
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
operator|(
name|size
operator|==
literal|3
operator|)
condition|?
name|QLocalePrivate
operator|::
name|codeToCountry
argument_list|(
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|code
argument_list|)
argument_list|)
else|:
name|QLocale
operator|::
name|AnyCountry
return|;
endif|#
directive|endif
comment|// Q_OS_WINCE
block|}
end_function
begin_comment
comment|// Create the system default time zone
end_comment
begin_constructor
DECL|function|QWinTimeZonePrivate
name|QWinTimeZonePrivate
operator|::
name|QWinTimeZonePrivate
parameter_list|()
member_init_list|:
name|QTimeZonePrivate
argument_list|()
block|{
name|init
argument_list|(
name|QByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|// Create a named time zone
end_comment
begin_constructor
DECL|function|QWinTimeZonePrivate
name|QWinTimeZonePrivate
operator|::
name|QWinTimeZonePrivate
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|olsenId
parameter_list|)
member_init_list|:
name|QTimeZonePrivate
argument_list|()
block|{
name|init
argument_list|(
name|olsenId
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QWinTimeZonePrivate
name|QWinTimeZonePrivate
operator|::
name|QWinTimeZonePrivate
parameter_list|(
specifier|const
name|QWinTimeZonePrivate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|QTimeZonePrivate
argument_list|(
name|other
argument_list|)
member_init_list|,
name|m_windowsId
argument_list|(
name|other
operator|.
name|m_windowsId
argument_list|)
member_init_list|,
name|m_displayName
argument_list|(
name|other
operator|.
name|m_displayName
argument_list|)
member_init_list|,
name|m_standardName
argument_list|(
name|other
operator|.
name|m_standardName
argument_list|)
member_init_list|,
name|m_daylightName
argument_list|(
name|other
operator|.
name|m_daylightName
argument_list|)
member_init_list|,
name|m_tranRules
argument_list|(
name|other
operator|.
name|m_tranRules
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QWinTimeZonePrivate
name|QWinTimeZonePrivate
operator|::
name|~
name|QWinTimeZonePrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|clone
name|QTimeZonePrivate
modifier|*
name|QWinTimeZonePrivate
operator|::
name|clone
parameter_list|()
block|{
return|return
operator|new
name|QWinTimeZonePrivate
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QWinTimeZonePrivate
operator|::
name|init
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|olsenId
parameter_list|)
block|{
if|if
condition|(
name|olsenId
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|m_windowsId
operator|=
name|windowsSystemZoneId
argument_list|()
expr_stmt|;
name|m_id
operator|=
name|systemTimeZoneId
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|m_windowsId
operator|=
name|olsenIdToWindowsId
argument_list|(
name|olsenId
argument_list|)
expr_stmt|;
name|m_id
operator|=
name|olsenId
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|m_windowsId
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Open the base TZI for the time zone
name|HKEY
name|baseKey
init|=
name|NULL
decl_stmt|;
specifier|const
name|QString
name|baseKeyPath
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|tzRegPath
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
operator|+
name|QString
operator|::
name|fromUtf8
argument_list|(
name|m_windowsId
argument_list|)
decl_stmt|;
if|if
condition|(
name|openRegistryKey
argument_list|(
name|baseKeyPath
argument_list|,
operator|&
name|baseKey
argument_list|)
condition|)
block|{
comment|//  Load the localized names
name|m_displayName
operator|=
name|readRegistryString
argument_list|(
name|baseKey
argument_list|,
literal|L"Display"
argument_list|)
expr_stmt|;
name|m_standardName
operator|=
name|readRegistryString
argument_list|(
name|baseKey
argument_list|,
literal|L"Std"
argument_list|)
expr_stmt|;
name|m_daylightName
operator|=
name|readRegistryString
argument_list|(
name|baseKey
argument_list|,
literal|L"Dlt"
argument_list|)
expr_stmt|;
comment|// On Vista and later the optional dynamic key holds historic data
specifier|const
name|QString
name|dynamicKeyPath
init|=
name|baseKeyPath
operator|+
name|QStringLiteral
argument_list|(
literal|"\\Dynamic DST"
argument_list|)
decl_stmt|;
name|HKEY
name|dynamicKey
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|openRegistryKey
argument_list|(
name|dynamicKeyPath
argument_list|,
operator|&
name|dynamicKey
argument_list|)
condition|)
block|{
comment|// Find out the start and end years stored, then iterate over them
name|int
name|startYear
init|=
name|readRegistryValue
argument_list|(
name|dynamicKey
argument_list|,
literal|L"FirstEntry"
argument_list|)
decl_stmt|;
name|int
name|endYear
init|=
name|readRegistryValue
argument_list|(
name|dynamicKey
argument_list|,
literal|L"LastEntry"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|year
init|=
name|startYear
init|;
name|year
operator|<=
name|endYear
condition|;
operator|++
name|year
control|)
block|{
name|bool
name|ruleOk
decl_stmt|;
name|QWinTransitionRule
name|rule
init|=
name|readRegistryRule
argument_list|(
name|dynamicKey
argument_list|,
operator|(
name|LPCWSTR
operator|)
name|QString
operator|::
name|number
argument_list|(
name|year
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|,
operator|&
name|ruleOk
argument_list|)
decl_stmt|;
name|rule
operator|.
name|startYear
operator|=
name|year
expr_stmt|;
if|if
condition|(
name|ruleOk
condition|)
name|m_tranRules
operator|.
name|append
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
name|RegCloseKey
argument_list|(
name|dynamicKey
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No dynamic data so use the base data
name|bool
name|ruleOk
decl_stmt|;
name|QWinTransitionRule
name|rule
init|=
name|readRegistryRule
argument_list|(
name|baseKey
argument_list|,
literal|L"TZI"
argument_list|,
operator|&
name|ruleOk
argument_list|)
decl_stmt|;
name|rule
operator|.
name|startYear
operator|=
literal|1970
expr_stmt|;
if|if
condition|(
name|ruleOk
condition|)
name|m_tranRules
operator|.
name|append
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
name|RegCloseKey
argument_list|(
name|baseKey
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If there are no rules then we failed to find a windowsId or any tzi info
if|if
condition|(
name|m_tranRules
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|m_id
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_windowsId
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_displayName
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|comment
name|QString
name|QWinTimeZonePrivate
operator|::
name|comment
parameter_list|()
specifier|const
block|{
return|return
name|m_displayName
return|;
block|}
end_function
begin_function
DECL|function|displayName
name|QString
name|QWinTimeZonePrivate
operator|::
name|displayName
parameter_list|(
name|QTimeZone
operator|::
name|TimeType
name|timeType
parameter_list|,
name|QTimeZone
operator|::
name|NameType
name|nameType
parameter_list|,
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
specifier|const
block|{
comment|// TODO Registry holds MUI keys, should be able to look up translations?
name|Q_UNUSED
argument_list|(
name|locale
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameType
operator|==
name|QTimeZone
operator|::
name|OffsetName
condition|)
block|{
name|QWinTransitionRule
name|rule
init|=
name|ruleForYear
argument_list|(
name|QDate
operator|::
name|currentDate
argument_list|()
operator|.
name|year
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeType
operator|==
name|QTimeZone
operator|::
name|DaylightTime
condition|)
return|return
name|isoOffsetFormat
argument_list|(
operator|(
name|rule
operator|.
name|standardTimeBias
operator|+
name|rule
operator|.
name|daylightTimeBias
operator|)
operator|*
operator|-
literal|60
argument_list|)
return|;
else|else
return|return
name|isoOffsetFormat
argument_list|(
operator|(
name|rule
operator|.
name|standardTimeBias
operator|)
operator|*
operator|-
literal|60
argument_list|)
return|;
block|}
switch|switch
condition|(
name|timeType
condition|)
block|{
case|case
name|QTimeZone
operator|::
name|DaylightTime
case|:
return|return
name|m_daylightName
return|;
case|case
name|QTimeZone
operator|::
name|GenericTime
case|:
return|return
name|m_displayName
return|;
case|case
name|QTimeZone
operator|::
name|StandardTime
case|:
return|return
name|m_standardName
return|;
block|}
return|return
name|m_standardName
return|;
block|}
end_function
begin_function
DECL|function|abbreviation
name|QString
name|QWinTimeZonePrivate
operator|::
name|abbreviation
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
return|return
name|data
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
operator|.
name|abbreviation
return|;
block|}
end_function
begin_function
DECL|function|offsetFromUtc
name|int
name|QWinTimeZonePrivate
operator|::
name|offsetFromUtc
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
return|return
name|data
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
operator|.
name|offsetFromUtc
return|;
block|}
end_function
begin_function
DECL|function|standardTimeOffset
name|int
name|QWinTimeZonePrivate
operator|::
name|standardTimeOffset
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
return|return
name|data
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
operator|.
name|standardTimeOffset
return|;
block|}
end_function
begin_function
DECL|function|daylightTimeOffset
name|int
name|QWinTimeZonePrivate
operator|::
name|daylightTimeOffset
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
return|return
name|data
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
operator|.
name|daylightTimeOffset
return|;
block|}
end_function
begin_function
DECL|function|hasDaylightTime
name|bool
name|QWinTimeZonePrivate
operator|::
name|hasDaylightTime
parameter_list|()
specifier|const
block|{
return|return
name|hasTransitions
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|isDaylightTime
name|bool
name|QWinTimeZonePrivate
operator|::
name|isDaylightTime
parameter_list|(
name|qint64
name|atMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|data
argument_list|(
name|atMSecsSinceEpoch
argument_list|)
operator|.
name|daylightTimeOffset
operator|!=
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|data
name|QTimeZonePrivate
operator|::
name|Data
name|QWinTimeZonePrivate
operator|::
name|data
parameter_list|(
name|qint64
name|forMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
comment|// Convert MSecs to year to get transitions for, but around 31 Dec/1 Jan may not be right year
comment|// So get the year after we think we want transitions for, to be safe
name|QDate
name|date
init|=
name|msecsToDate
argument_list|(
name|forMSecsSinceEpoch
argument_list|)
decl_stmt|;
name|int
name|year
decl_stmt|;
name|int
name|month
decl_stmt|;
name|int
name|day
decl_stmt|;
name|date
operator|.
name|getDate
argument_list|(
operator|&
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|month
operator|==
literal|12
operator|&&
name|day
operator|==
literal|31
operator|)
operator|||
operator|(
name|month
operator|==
literal|1
operator|&&
name|day
operator|==
literal|1
operator|)
condition|)
operator|++
name|year
expr_stmt|;
name|qint64
name|first
decl_stmt|;
name|qint64
name|second
decl_stmt|;
name|qint64
name|next
init|=
name|maxMSecs
argument_list|()
decl_stmt|;
name|qint64
name|stdMSecs
decl_stmt|;
name|qint64
name|dstMSecs
decl_stmt|;
name|QWinTransitionRule
name|rule
decl_stmt|;
do|do
block|{
comment|// Convert the transition rules into msecs for the year we want to try
name|rule
operator|=
name|ruleForYear
argument_list|(
name|year
argument_list|)
expr_stmt|;
name|calculateTransitionsForYear
argument_list|(
name|rule
argument_list|,
name|year
argument_list|,
operator|&
name|stdMSecs
argument_list|,
operator|&
name|dstMSecs
argument_list|)
expr_stmt|;
name|first
operator|=
name|qMin
argument_list|(
name|stdMSecs
argument_list|,
name|dstMSecs
argument_list|)
expr_stmt|;
name|second
operator|=
name|qMax
argument_list|(
name|stdMSecs
argument_list|,
name|dstMSecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|forMSecsSinceEpoch
operator|>=
name|second
condition|)
name|next
operator|=
name|second
expr_stmt|;
elseif|else
if|if
condition|(
name|forMSecsSinceEpoch
operator|>=
name|first
condition|)
name|next
operator|=
name|first
expr_stmt|;
comment|// If didn't fall in this year, try the previous
operator|--
name|year
expr_stmt|;
block|}
do|while
condition|(
name|forMSecsSinceEpoch
operator|<
name|first
operator|&&
name|year
operator|>=
name|MIN_YEAR
condition|)
do|;
if|if
condition|(
name|next
operator|==
name|dstMSecs
condition|)
return|return
name|ruleToData
argument_list|(
name|rule
argument_list|,
name|forMSecsSinceEpoch
argument_list|,
name|QTimeZone
operator|::
name|DaylightTime
argument_list|)
return|;
else|else
return|return
name|ruleToData
argument_list|(
name|rule
argument_list|,
name|forMSecsSinceEpoch
argument_list|,
name|QTimeZone
operator|::
name|StandardTime
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|hasTransitions
name|bool
name|QWinTimeZonePrivate
operator|::
name|hasTransitions
parameter_list|()
specifier|const
block|{
foreach|foreach
control|(
specifier|const
name|QWinTransitionRule
modifier|&
name|rule
decl|,
name|m_tranRules
control|)
block|{
if|if
condition|(
name|rule
operator|.
name|standardTimeRule
operator|.
name|wMonth
operator|>
literal|0
operator|&&
name|rule
operator|.
name|daylightTimeRule
operator|.
name|wMonth
operator|>
literal|0
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|nextTransition
name|QTimeZonePrivate
operator|::
name|Data
name|QWinTimeZonePrivate
operator|::
name|nextTransition
parameter_list|(
name|qint64
name|afterMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
comment|// Convert MSecs to year to get transitions for, but around 31 Dec/1 Jan may not be right year
comment|// Get the year before we think we want transitions for, to be safe
name|QDate
name|date
init|=
name|msecsToDate
argument_list|(
name|afterMSecsSinceEpoch
argument_list|)
decl_stmt|;
name|int
name|year
decl_stmt|;
name|int
name|month
decl_stmt|;
name|int
name|day
decl_stmt|;
name|date
operator|.
name|getDate
argument_list|(
operator|&
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|month
operator|==
literal|12
operator|&&
name|day
operator|==
literal|31
operator|)
operator|||
operator|(
name|month
operator|==
literal|1
operator|&&
name|day
operator|==
literal|1
operator|)
condition|)
operator|--
name|year
expr_stmt|;
name|qint64
name|first
decl_stmt|;
name|qint64
name|second
decl_stmt|;
name|qint64
name|next
init|=
name|minMSecs
argument_list|()
decl_stmt|;
name|qint64
name|stdMSecs
decl_stmt|;
name|qint64
name|dstMSecs
decl_stmt|;
name|QWinTransitionRule
name|rule
decl_stmt|;
do|do
block|{
comment|// Convert the transition rules into msecs for the year we want to try
name|rule
operator|=
name|ruleForYear
argument_list|(
name|year
argument_list|)
expr_stmt|;
name|calculateTransitionsForYear
argument_list|(
name|rule
argument_list|,
name|year
argument_list|,
operator|&
name|stdMSecs
argument_list|,
operator|&
name|dstMSecs
argument_list|)
expr_stmt|;
comment|// Find the first and second transition for the year
name|first
operator|=
name|qMin
argument_list|(
name|stdMSecs
argument_list|,
name|dstMSecs
argument_list|)
expr_stmt|;
name|second
operator|=
name|qMax
argument_list|(
name|stdMSecs
argument_list|,
name|dstMSecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|afterMSecsSinceEpoch
operator|<
name|first
condition|)
name|next
operator|=
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|afterMSecsSinceEpoch
operator|<
name|second
condition|)
name|next
operator|=
name|second
expr_stmt|;
comment|// If didn't fall in this year, try the next
operator|++
name|year
expr_stmt|;
block|}
do|while
condition|(
name|afterMSecsSinceEpoch
operator|>=
name|second
operator|&&
name|year
operator|<=
name|MAX_YEAR
condition|)
do|;
if|if
condition|(
name|next
operator|==
name|dstMSecs
condition|)
return|return
name|ruleToData
argument_list|(
name|rule
argument_list|,
name|next
argument_list|,
name|QTimeZone
operator|::
name|DaylightTime
argument_list|)
return|;
else|else
return|return
name|ruleToData
argument_list|(
name|rule
argument_list|,
name|next
argument_list|,
name|QTimeZone
operator|::
name|StandardTime
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|previousTransition
name|QTimeZonePrivate
operator|::
name|Data
name|QWinTimeZonePrivate
operator|::
name|previousTransition
parameter_list|(
name|qint64
name|beforeMSecsSinceEpoch
parameter_list|)
specifier|const
block|{
comment|// Convert MSecs to year to get transitions for, but around 31 Dec/1 Jan may not be right year
comment|// So get the year after we think we want transitions for, to be safe
name|QDate
name|date
init|=
name|msecsToDate
argument_list|(
name|beforeMSecsSinceEpoch
argument_list|)
decl_stmt|;
name|int
name|year
decl_stmt|;
name|int
name|month
decl_stmt|;
name|int
name|day
decl_stmt|;
name|date
operator|.
name|getDate
argument_list|(
operator|&
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|month
operator|==
literal|12
operator|&&
name|day
operator|==
literal|31
operator|)
operator|||
operator|(
name|month
operator|==
literal|1
operator|&&
name|day
operator|==
literal|1
operator|)
condition|)
operator|++
name|year
expr_stmt|;
name|qint64
name|first
decl_stmt|;
name|qint64
name|second
decl_stmt|;
name|qint64
name|next
init|=
name|maxMSecs
argument_list|()
decl_stmt|;
name|qint64
name|stdMSecs
decl_stmt|;
name|qint64
name|dstMSecs
decl_stmt|;
name|QWinTransitionRule
name|rule
decl_stmt|;
do|do
block|{
comment|// Convert the transition rules into msecs for the year we want to try
name|rule
operator|=
name|ruleForYear
argument_list|(
name|year
argument_list|)
expr_stmt|;
name|calculateTransitionsForYear
argument_list|(
name|rule
argument_list|,
name|year
argument_list|,
operator|&
name|stdMSecs
argument_list|,
operator|&
name|dstMSecs
argument_list|)
expr_stmt|;
name|first
operator|=
name|qMin
argument_list|(
name|stdMSecs
argument_list|,
name|dstMSecs
argument_list|)
expr_stmt|;
name|second
operator|=
name|qMax
argument_list|(
name|stdMSecs
argument_list|,
name|dstMSecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|beforeMSecsSinceEpoch
operator|>
name|second
condition|)
name|next
operator|=
name|second
expr_stmt|;
elseif|else
if|if
condition|(
name|beforeMSecsSinceEpoch
operator|>
name|first
condition|)
name|next
operator|=
name|first
expr_stmt|;
comment|// If didn't fall in this year, try the previous
operator|--
name|year
expr_stmt|;
block|}
do|while
condition|(
name|beforeMSecsSinceEpoch
operator|<
name|first
operator|&&
name|year
operator|>=
name|MIN_YEAR
condition|)
do|;
if|if
condition|(
name|next
operator|==
name|dstMSecs
condition|)
return|return
name|ruleToData
argument_list|(
name|rule
argument_list|,
name|next
argument_list|,
name|QTimeZone
operator|::
name|DaylightTime
argument_list|)
return|;
else|else
return|return
name|ruleToData
argument_list|(
name|rule
argument_list|,
name|next
argument_list|,
name|QTimeZone
operator|::
name|StandardTime
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|systemTimeZoneId
name|QByteArray
name|QWinTimeZonePrivate
operator|::
name|systemTimeZoneId
parameter_list|()
specifier|const
block|{
specifier|const
name|QLocale
operator|::
name|Country
name|country
init|=
name|userCountry
argument_list|()
decl_stmt|;
specifier|const
name|QByteArray
name|windowsId
init|=
name|windowsSystemZoneId
argument_list|()
decl_stmt|;
name|QByteArray
name|olsenId
decl_stmt|;
comment|// If we have a real country, then try get a specific match for that country
if|if
condition|(
name|country
operator|!=
name|QLocale
operator|::
name|AnyCountry
condition|)
name|olsenId
operator|=
name|windowsIdToDefaultOlsenId
argument_list|(
name|windowsId
argument_list|,
name|country
argument_list|)
expr_stmt|;
comment|// If we don't have a real country, or there wasn't a specific match, try the global default
if|if
condition|(
name|olsenId
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|olsenId
operator|=
name|windowsIdToDefaultOlsenId
argument_list|(
name|windowsId
argument_list|)
expr_stmt|;
comment|// If no global default then probably an unknown Windows ID so return UTC
if|if
condition|(
name|olsenId
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QByteArrayLiteral
argument_list|(
literal|"UTC"
argument_list|)
return|;
block|}
return|return
name|olsenId
return|;
block|}
end_function
begin_function
DECL|function|availableTimeZoneIds
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|QWinTimeZonePrivate
operator|::
name|availableTimeZoneIds
parameter_list|()
specifier|const
block|{
name|QSet
argument_list|<
name|QByteArray
argument_list|>
name|set
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|winId
decl|,
name|availableWindowsIds
argument_list|()
control|)
block|{
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|olsenId
decl|,
name|windowsIdToOlsenIds
argument_list|(
name|winId
argument_list|)
control|)
name|set
operator|<<
name|olsenId
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
end_function
begin_function
DECL|function|ruleForYear
name|QWinTimeZonePrivate
operator|::
name|QWinTransitionRule
name|QWinTimeZonePrivate
operator|::
name|ruleForYear
parameter_list|(
name|int
name|year
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
name|m_tranRules
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|m_tranRules
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|startYear
operator|<=
name|year
condition|)
return|return
name|m_tranRules
operator|.
name|at
argument_list|(
name|i
argument_list|)
return|;
block|}
return|return
name|m_tranRules
operator|.
name|at
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ruleToData
name|QTimeZonePrivate
operator|::
name|Data
name|QWinTimeZonePrivate
operator|::
name|ruleToData
parameter_list|(
specifier|const
name|QWinTransitionRule
modifier|&
name|rule
parameter_list|,
name|qint64
name|atMSecsSinceEpoch
parameter_list|,
name|QTimeZone
operator|::
name|TimeType
name|type
parameter_list|)
specifier|const
block|{
name|QTimeZonePrivate
operator|::
name|Data
name|tran
init|=
name|QTimeZonePrivate
operator|::
name|invalidData
argument_list|()
decl_stmt|;
name|tran
operator|.
name|atMSecsSinceEpoch
operator|=
name|atMSecsSinceEpoch
expr_stmt|;
name|tran
operator|.
name|standardTimeOffset
operator|=
name|rule
operator|.
name|standardTimeBias
operator|*
operator|-
literal|60
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|QTimeZone
operator|::
name|DaylightTime
condition|)
block|{
name|tran
operator|.
name|daylightTimeOffset
operator|=
name|rule
operator|.
name|daylightTimeBias
operator|*
operator|-
literal|60
expr_stmt|;
name|tran
operator|.
name|abbreviation
operator|=
name|m_daylightName
expr_stmt|;
block|}
else|else
block|{
name|tran
operator|.
name|daylightTimeOffset
operator|=
literal|0
expr_stmt|;
name|tran
operator|.
name|abbreviation
operator|=
name|m_standardName
expr_stmt|;
block|}
name|tran
operator|.
name|offsetFromUtc
operator|=
name|tran
operator|.
name|standardTimeOffset
operator|+
name|tran
operator|.
name|daylightTimeOffset
expr_stmt|;
return|return
name|tran
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
