begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Laszlo Papp<lpapp@kde.org> ** Copyright (C) 2013 David Faure<faure@kde.org> ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qcommandlineparser.h"
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<qvector.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_typedef
DECL|typedef|NameHash_t
typedef|typedef
name|QHash
argument_list|<
name|QString
argument_list|,
name|int
argument_list|>
name|NameHash_t
typedef|;
end_typedef
begin_comment
comment|// Special value for "not found" when doing hash lookups.
end_comment
begin_decl_stmt
DECL|variable|optionNotFound
specifier|static
specifier|const
name|NameHash_t
operator|::
name|mapped_type
name|optionNotFound
init|=
operator|~
literal|0
decl_stmt|;
end_decl_stmt
begin_class
DECL|class|QCommandLineParserPrivate
class|class
name|QCommandLineParserPrivate
block|{
public|public:
DECL|function|QCommandLineParserPrivate
specifier|inline
name|QCommandLineParserPrivate
parameter_list|()
member_init_list|:
name|singleDashWordOptionMode
argument_list|(
name|QCommandLineParser
operator|::
name|ParseAsCompactedShortOptions
argument_list|)
member_init_list|,
name|builtinVersionOption
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|builtinHelpOption
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|needsParsing
argument_list|(
literal|true
argument_list|)
block|{ }
name|bool
name|parse
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|args
parameter_list|)
function_decl|;
name|void
name|checkParsed
parameter_list|(
specifier|const
name|char
modifier|*
name|method
parameter_list|)
function_decl|;
name|QStringList
name|aliases
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
function_decl|;
name|QString
name|helpText
parameter_list|()
specifier|const
function_decl|;
name|bool
name|registerFoundOption
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|)
function_decl|;
name|bool
name|parseOptionValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|,
specifier|const
name|QString
modifier|&
name|argument
parameter_list|,
name|QStringList
operator|::
name|const_iterator
modifier|*
name|argumentIterator
parameter_list|,
name|QStringList
operator|::
name|const_iterator
name|argsEnd
parameter_list|)
function_decl|;
comment|//! Error text set when parse() returns false
DECL|member|errorText
name|QString
name|errorText
decl_stmt|;
comment|//! The command line options used for parsing
DECL|member|commandLineOptionList
name|QList
argument_list|<
name|QCommandLineOption
argument_list|>
name|commandLineOptionList
decl_stmt|;
comment|//! Hash mapping option names to their offsets in commandLineOptionList and optionArgumentList.
DECL|member|nameHash
name|NameHash_t
name|nameHash
decl_stmt|;
comment|//! Option values found (only for options with a value)
DECL|member|optionValuesHash
name|QHash
argument_list|<
name|int
argument_list|,
name|QStringList
argument_list|>
name|optionValuesHash
decl_stmt|;
comment|//! Names of options found on the command line.
DECL|member|optionNames
name|QStringList
name|optionNames
decl_stmt|;
comment|//! Arguments which did not belong to any option.
DECL|member|positionalArgumentList
name|QStringList
name|positionalArgumentList
decl_stmt|;
comment|//! Names of options which were unknown.
DECL|member|unknownOptionNames
name|QStringList
name|unknownOptionNames
decl_stmt|;
comment|//! Application description
DECL|member|description
name|QString
name|description
decl_stmt|;
comment|//! Documentation for positional arguments
DECL|struct|PositionalArgumentDefinition
struct|struct
name|PositionalArgumentDefinition
block|{
DECL|member|name
name|QString
name|name
decl_stmt|;
DECL|member|description
name|QString
name|description
decl_stmt|;
DECL|member|syntax
name|QString
name|syntax
decl_stmt|;
block|}
struct|;
DECL|member|positionalArgumentDefinitions
name|QVector
argument_list|<
name|PositionalArgumentDefinition
argument_list|>
name|positionalArgumentDefinitions
decl_stmt|;
comment|//! The parsing mode for "-abc"
DECL|member|singleDashWordOptionMode
name|QCommandLineParser
operator|::
name|SingleDashWordOptionMode
name|singleDashWordOptionMode
decl_stmt|;
comment|//! Whether addVersionOption was called
DECL|member|builtinVersionOption
name|bool
name|builtinVersionOption
decl_stmt|;
comment|//! Whether addHelpOption was called
DECL|member|builtinHelpOption
name|bool
name|builtinHelpOption
decl_stmt|;
comment|//! True if parse() needs to be called
DECL|member|needsParsing
name|bool
name|needsParsing
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|aliases
name|QStringList
name|QCommandLineParserPrivate
operator|::
name|aliases
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|)
specifier|const
block|{
specifier|const
name|NameHash_t
operator|::
name|mapped_type
name|optionOffset
init|=
name|nameHash
operator|.
name|value
argument_list|(
name|optionName
argument_list|,
name|optionNotFound
argument_list|)
decl_stmt|;
if|if
condition|(
name|optionOffset
operator|==
name|optionNotFound
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCommandLineParser: option not defined: \"%s\""
argument_list|,
name|qPrintable
argument_list|(
name|optionName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QStringList
argument_list|()
return|;
block|}
return|return
name|commandLineOptionList
operator|.
name|at
argument_list|(
name|optionOffset
argument_list|)
operator|.
name|names
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2     \class QCommandLineParser     \inmodule QtCore     \ingroup tools      \brief The QCommandLineParser class provides a means for handling the     command line options.      QCoreApplication provides the command-line arguments as a simple list of strings.     QCommandLineParser provides the ability to define a set of options, parse the     command-line arguments, and store which options have actually been used, as     well as option values.      Any argument that isn't an option (i.e. doesn't start with a \c{-}) is stored     as a "positional argument".      The parser handles short names, long names, more than one name for the same     option, and option values.      Options on the command line are recognized as starting with a single or     double \c{-} character(s).     The option \c{-} (single dash alone) is a special case, often meaning standard     input, and not treated as an option. The parser will treat everything after the     option \c{--} (double dash) as positional arguments.      Short options are single letters. The option \c{v} would be specified by     passing \c{-v} on the command line. In the default parsing mode, short options     can be written in a compact form, for instance \c{-abc} is equivalent to \c{-a -b -c}.     The parsing mode for can be set to ParseAsLongOptions, in which case \c{-abc}     will be parsed as the long option \a{abc}.      Long options are more than one letter long and cannot be compacted together.     The long option \c{verbose} would be passed as \c{--verbose} or \c{-verbose}.      Passing values to options can be done using the assignment operator: \c{-v=value}     \c{--verbose=value}, or a space: \c{-v value} \c{--verbose value}, i.e. the next     argument is used as value (even if it starts with a \c{-}).      The parser does not support optional values - if an option is set to     require a value, one must be present. If such an option is placed last     and has no value, the option will be treated as if it had not been     specified.      The parser does not automatically support negating or disabling long options     by using the format \c{--disable-option} or \c{--no-option}. However, it is     possible to handle this case explicitly by making an option with \c{no-option}     as one of its names, and handling the option explicitly.      Example:     \snippet code/src_corelib_tools_qcommandlineparser.cpp 3      Known limitation: the parsing of Qt options inside QCoreApplication and subclasses     happens before QCommandLineParser exists, so it can't take it into account. This     means any option value that looks like a builtin Qt option, will be treated by     QCoreApplication as a builtin Qt option. Example: \c{--profile -reverse} will     lead to QGuiApplication seeing the -reverse option set, and removing it from     QCoreApplication::arguments() before QCommandLineParser defines the \c{profile}     option and parses the command line.      \sa QCommandLineOption, QCoreApplication */
end_comment
begin_comment
comment|/*!     Constructs a command line parser object. */
end_comment
begin_constructor
DECL|function|QCommandLineParser
name|QCommandLineParser
operator|::
name|QCommandLineParser
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QCommandLineParserPrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the command line parser object. */
end_comment
begin_destructor
DECL|function|~QCommandLineParser
name|QCommandLineParser
operator|::
name|~
name|QCommandLineParser
parameter_list|()
block|{
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \enum QCommandLineParser::SingleDashWordOptionMode      This enum describes the way the parser interprets command-line     options that use a single dash followed by multiple letters, as as \c{-abc}.      \value ParseAsCompactedShortOptions \c{-abc} is interpreted as \c{-a -b -c},     i.e. as three short options that have been compacted on the command-line,     if none of the options take a value. If \c{a} takes a value, then it     is interpreted as \c{-a bc}, i.e. the short option \c{a} followed by the value \c{bc}.     This is typically used in tools that behave like compilers, in order     to handle options such as \c{-DDEFINE=VALUE} or \c{-I/include/path}.     This is the default parsing mode. New applications are recommended to     use this mode.      \value ParseAsLongOptions \c{-abc} is interpreted as \c{--abc},     i.e. as the long option named \c{abc}. This is how Qt's own tools     (uic, rcc...) have always been parsing arguments. This mode should be     used for preserving compatibility in applications that were parsing     arguments in such a way.      \sa setSingleDashWordOptionMode() */
end_comment
begin_comment
comment|/*!     Sets the parsing mode to \a singleDashWordOptionMode.     This must be called before process() or parse(). */
end_comment
begin_function
DECL|function|setSingleDashWordOptionMode
name|void
name|QCommandLineParser
operator|::
name|setSingleDashWordOptionMode
parameter_list|(
name|QCommandLineParser
operator|::
name|SingleDashWordOptionMode
name|singleDashWordOptionMode
parameter_list|)
block|{
name|d
operator|->
name|singleDashWordOptionMode
operator|=
name|singleDashWordOptionMode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds the option \a option to look for while parsing.      Returns true if adding the option was successful; otherwise returns false.      Adding the option fails if there is no name attached to the option, or     the option has a name that clashes with an option name added before.  */
end_comment
begin_function
DECL|function|addOption
name|bool
name|QCommandLineParser
operator|::
name|addOption
parameter_list|(
specifier|const
name|QCommandLineOption
modifier|&
name|option
parameter_list|)
block|{
name|QStringList
name|optionNames
init|=
name|option
operator|.
name|names
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|optionNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|name
decl|,
name|optionNames
control|)
block|{
if|if
condition|(
name|d
operator|->
name|nameHash
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
name|d
operator|->
name|commandLineOptionList
operator|.
name|append
argument_list|(
name|option
argument_list|)
expr_stmt|;
specifier|const
name|int
name|offset
init|=
name|d
operator|->
name|commandLineOptionList
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|name
decl|,
name|optionNames
control|)
name|d
operator|->
name|nameHash
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Adds the \c{-v} / \c{--version} option, which displays the version string of the application.      This option is handled automatically by QCommandLineParser.      You can set the actual version string by using QCoreApplication::setApplicationVersion().      Returns the option instance, which can be used to call isSet(). */
end_comment
begin_function
DECL|function|addVersionOption
name|QCommandLineOption
name|QCommandLineParser
operator|::
name|addVersionOption
parameter_list|()
block|{
name|d
operator|->
name|builtinVersionOption
operator|=
literal|true
expr_stmt|;
name|QCommandLineOption
name|opt
argument_list|(
name|QStringList
argument_list|()
operator|<<
name|QStringLiteral
argument_list|(
literal|"v"
argument_list|)
operator|<<
name|QStringLiteral
argument_list|(
literal|"version"
argument_list|)
argument_list|,
name|tr
argument_list|(
literal|"Displays version information."
argument_list|)
argument_list|)
decl_stmt|;
name|addOption
argument_list|(
name|opt
argument_list|)
expr_stmt|;
return|return
name|opt
return|;
block|}
end_function
begin_comment
comment|/*!     Adds the help option (\c{-h}, \c{--help} and \c{-?} on Windows)     This option is handled automatically by QCommandLineParser.      Remember to use setApplicationDescription to set the application description,     which will be displayed when this option is used.      Example:     \code         setApplicationDescription(QCoreApplication::translate("main", "The best application in the world"));         addHelpOption();     \endcode      Returns the option instance, which can be used to call isSet(). */
end_comment
begin_function
DECL|function|addHelpOption
name|QCommandLineOption
name|QCommandLineParser
operator|::
name|addHelpOption
parameter_list|()
block|{
name|d
operator|->
name|builtinHelpOption
operator|=
literal|true
expr_stmt|;
name|QCommandLineOption
name|opt
argument_list|(
name|QStringList
argument_list|()
ifdef|#
directive|ifdef
name|Q_OS_WIN
operator|<<
name|QStringLiteral
argument_list|(
literal|"?"
argument_list|)
endif|#
directive|endif
operator|<<
name|QStringLiteral
argument_list|(
literal|"h"
argument_list|)
operator|<<
name|QStringLiteral
argument_list|(
literal|"help"
argument_list|)
argument_list|,
name|tr
argument_list|(
literal|"Displays this help."
argument_list|)
argument_list|)
decl_stmt|;
name|addOption
argument_list|(
name|opt
argument_list|)
expr_stmt|;
return|return
name|opt
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the application \a description shown by helpText().     Most applications don't need to call this directly, addHelpOption()     also sets the application description. */
end_comment
begin_function
DECL|function|setApplicationDescription
name|void
name|QCommandLineParser
operator|::
name|setApplicationDescription
parameter_list|(
specifier|const
name|QString
modifier|&
name|description
parameter_list|)
block|{
name|d
operator|->
name|description
operator|=
name|description
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the application description set in setApplicationDescription()     or addHelpOption(). */
end_comment
begin_function
DECL|function|applicationDescription
name|QString
name|QCommandLineParser
operator|::
name|applicationDescription
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|description
return|;
block|}
end_function
begin_comment
comment|/*!     Defines an additional argument to the application, for the benefit of the help text.      The argument \a name and \a description will appear under the \c{Arguments:} section     of the help. If \a syntax is specified, it will be appended to the Usage line, otherwise     the \a name will be appended.      Example:     \snippet code/src_corelib_tools_qcommandlineparser.cpp 1      \sa addHelpOption(), helpText() */
end_comment
begin_function
DECL|function|addPositionalArgument
name|void
name|QCommandLineParser
operator|::
name|addPositionalArgument
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|description
parameter_list|,
specifier|const
name|QString
modifier|&
name|syntax
parameter_list|)
block|{
name|QCommandLineParserPrivate
operator|::
name|PositionalArgumentDefinition
name|arg
decl_stmt|;
name|arg
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|arg
operator|.
name|description
operator|=
name|description
expr_stmt|;
name|arg
operator|.
name|syntax
operator|=
name|syntax
operator|.
name|isEmpty
argument_list|()
condition|?
name|name
else|:
name|syntax
expr_stmt|;
name|d
operator|->
name|positionalArgumentDefinitions
operator|.
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Clears the definitions of additional arguments from the help text.      This is only needed for the special case of tools which support multiple commands     with different options. Once the actual command has been identified, the options     for this command can be defined, and the help text for the command can be adjusted     accordingly.      Example:     \snippet code/src_corelib_tools_qcommandlineparser.cpp 2 */
end_comment
begin_function
DECL|function|clearPositionalArguments
name|void
name|QCommandLineParser
operator|::
name|clearPositionalArguments
parameter_list|()
block|{
name|d
operator|->
name|positionalArgumentDefinitions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Parses the command line \a arguments.      Most programs don't need to call this, a simple call to process(app) is enough.      parse() is more low-level, and only does the parsing. The application will have to     take care of the error handling, using errorText() if parse() returns false.     This can be useful for instance to show a graphical error message in graphical programs.      Calling parse() instead of process() can also be useful in order to ignore unknown     options temporarily, because more option definitions will be provided later on     (depending on one of the arguments), before calling process().      Don't forget that \a arguments must start with the name of the executable (ignored, though).      Return false in case of a parse error (unknown option or missing value); returns true otherwise.      \sa process() */
end_comment
begin_function
DECL|function|parse
name|bool
name|QCommandLineParser
operator|::
name|parse
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|)
block|{
return|return
name|d
operator|->
name|parse
argument_list|(
name|arguments
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a translated error text for the user.     This should only be called when parse() returns false. */
end_comment
begin_function
DECL|function|errorText
name|QString
name|QCommandLineParser
operator|::
name|errorText
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|errorText
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|d
operator|->
name|errorText
return|;
if|if
condition|(
name|d
operator|->
name|unknownOptionNames
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
return|return
name|tr
argument_list|(
literal|"Unknown option '%1'."
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|unknownOptionNames
operator|.
name|first
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|d
operator|->
name|unknownOptionNames
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
return|return
name|tr
argument_list|(
literal|"Unknown options: %1."
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|unknownOptionNames
operator|.
name|join
argument_list|(
name|QStringLiteral
argument_list|(
literal|", "
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Processes the command line \a arguments.      This means both parsing them, and handling the builtin options,     \c{--version} if addVersionOption was called, \c{--help} if addHelpOption was called,     as well as giving an error on unknown option names.     In each of these three cases, the current process will then stop, using the exit() function.      \sa QCoreApplication::arguments(), parse()  */
end_comment
begin_function
DECL|function|process
name|void
name|QCommandLineParser
operator|::
name|process
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|parse
argument_list|(
name|arguments
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|qPrintable
argument_list|(
name|errorText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|::
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|builtinVersionOption
operator|&&
name|isSet
argument_list|(
name|QStringLiteral
argument_list|(
literal|"version"
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|qPrintable
argument_list|(
name|QCoreApplication
operator|::
name|applicationName
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|QCoreApplication
operator|::
name|applicationVersion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|::
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|builtinHelpOption
operator|&&
name|isSet
argument_list|(
name|QStringLiteral
argument_list|(
literal|"help"
argument_list|)
argument_list|)
condition|)
name|showHelp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      The command line is obtained from the QCoreApplication instance \a app.  */
end_comment
begin_function
DECL|function|process
name|void
name|QCommandLineParser
operator|::
name|process
parameter_list|(
specifier|const
name|QCoreApplication
modifier|&
name|app
parameter_list|)
block|{
comment|// QCoreApplication::arguments() is static, but the app instance must exist so we require it as parameter
name|Q_UNUSED
argument_list|(
name|app
argument_list|)
expr_stmt|;
name|process
argument_list|(
name|QCoreApplication
operator|::
name|arguments
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|checkParsed
name|void
name|QCommandLineParserPrivate
operator|::
name|checkParsed
parameter_list|(
specifier|const
name|char
modifier|*
name|method
parameter_list|)
block|{
if|if
condition|(
name|needsParsing
condition|)
name|qWarning
argument_list|(
literal|"QCommandLineParser: call process() or parse() before %s"
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Looks up the option \a optionName (found on the command line) and register it as found.     Returns true on success.  */
end_comment
begin_function
DECL|function|registerFoundOption
name|bool
name|QCommandLineParserPrivate
operator|::
name|registerFoundOption
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|)
block|{
if|if
condition|(
name|nameHash
operator|.
name|contains
argument_list|(
name|optionName
argument_list|)
condition|)
block|{
name|optionNames
operator|.
name|append
argument_list|(
name|optionName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|unknownOptionNames
operator|.
name|append
argument_list|(
name|optionName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     \brief Parse the value for a given option, if it was defined to expect one.      The value is taken from the next argument, or after the equal sign in \a argument.      \param optionName the short option name     \param argument the argument from the command line currently parsed. Only used for -k=value parsing.     \param argumentIterator iterator to the currently parsed argument. Incremented if the next argument contains the value.     \param argsEnd args.end(), to check if ++argumentIterator goes out of bounds     Returns true on success.  */
end_comment
begin_function
DECL|function|parseOptionValue
name|bool
name|QCommandLineParserPrivate
operator|::
name|parseOptionValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|,
specifier|const
name|QString
modifier|&
name|argument
parameter_list|,
name|QStringList
operator|::
name|const_iterator
modifier|*
name|argumentIterator
parameter_list|,
name|QStringList
operator|::
name|const_iterator
name|argsEnd
parameter_list|)
block|{
specifier|const
name|QLatin1Char
name|assignChar
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
specifier|const
name|NameHash_t
operator|::
name|const_iterator
name|nameHashIt
init|=
name|nameHash
operator|.
name|constFind
argument_list|(
name|optionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nameHashIt
operator|!=
name|nameHash
operator|.
name|constEnd
argument_list|()
condition|)
block|{
specifier|const
name|int
name|assignPos
init|=
name|argument
operator|.
name|indexOf
argument_list|(
name|assignChar
argument_list|)
decl_stmt|;
specifier|const
name|NameHash_t
operator|::
name|mapped_type
name|optionOffset
init|=
operator|*
name|nameHashIt
decl_stmt|;
specifier|const
name|bool
name|withValue
init|=
operator|!
name|commandLineOptionList
operator|.
name|at
argument_list|(
name|optionOffset
argument_list|)
operator|.
name|valueName
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|withValue
condition|)
block|{
if|if
condition|(
name|assignPos
operator|==
operator|-
literal|1
condition|)
block|{
operator|++
operator|(
operator|*
name|argumentIterator
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|argumentIterator
operator|==
name|argsEnd
condition|)
block|{
name|errorText
operator|=
name|QCommandLineParser
operator|::
name|tr
argument_list|(
literal|"Missing value after '%1'."
argument_list|)
operator|.
name|arg
argument_list|(
name|argument
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|optionValuesHash
index|[
name|optionOffset
index|]
operator|.
name|append
argument_list|(
operator|*
operator|(
operator|*
name|argumentIterator
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|optionValuesHash
index|[
name|optionOffset
index|]
operator|.
name|append
argument_list|(
name|argument
operator|.
name|mid
argument_list|(
name|assignPos
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|assignPos
operator|!=
operator|-
literal|1
condition|)
block|{
name|errorText
operator|=
name|QCommandLineParser
operator|::
name|tr
argument_list|(
literal|"Unexpected value after '%1'."
argument_list|)
operator|.
name|arg
argument_list|(
name|argument
operator|.
name|left
argument_list|(
name|assignPos
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Parse the list of arguments \a arguments.      Any results from a previous parse operation are removed.     The parser will not look for further options once it encounters the option     \c{--}; this does not include when \c{--} follows an option that requires a value.      Options that were successfully recognized, and their values, are     removed from the input list. If \c m_bRemoveUnknownLongNames is     \c true, unrecognized options are removed and placed into a list of     unknown option names. Anything left over is placed into a list of     leftover arguments.  */
end_comment
begin_function
DECL|function|parse
name|bool
name|QCommandLineParserPrivate
operator|::
name|parse
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|args
parameter_list|)
block|{
name|needsParsing
operator|=
literal|false
expr_stmt|;
name|bool
name|error
init|=
literal|false
decl_stmt|;
specifier|const
name|QString
name|doubleDashString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"--"
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QLatin1Char
name|dashChar
argument_list|(
literal|'-'
argument_list|)
decl_stmt|;
specifier|const
name|QLatin1Char
name|assignChar
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
name|bool
name|doubleDashFound
init|=
literal|false
decl_stmt|;
name|errorText
operator|.
name|clear
argument_list|()
expr_stmt|;
name|positionalArgumentList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|optionNames
operator|.
name|clear
argument_list|()
expr_stmt|;
name|unknownOptionNames
operator|.
name|clear
argument_list|()
expr_stmt|;
name|optionValuesHash
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCommandLineParser: argument list cannot be empty, it should contain at least the executable name"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QStringList
operator|::
name|const_iterator
name|argumentIterator
init|=
name|args
operator|.
name|begin
argument_list|()
decl_stmt|;
operator|++
name|argumentIterator
expr_stmt|;
comment|// skip executable name
for|for
control|(
init|;
name|argumentIterator
operator|!=
name|args
operator|.
name|end
argument_list|()
condition|;
operator|++
name|argumentIterator
control|)
block|{
name|QString
name|argument
init|=
operator|*
name|argumentIterator
decl_stmt|;
if|if
condition|(
name|doubleDashFound
condition|)
block|{
name|positionalArgumentList
operator|.
name|append
argument_list|(
name|argument
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argument
operator|.
name|startsWith
argument_list|(
name|doubleDashString
argument_list|)
condition|)
block|{
if|if
condition|(
name|argument
operator|.
name|length
argument_list|()
operator|>
literal|2
condition|)
block|{
name|QString
name|optionName
init|=
name|argument
operator|.
name|mid
argument_list|(
literal|2
argument_list|)
operator|.
name|section
argument_list|(
name|assignChar
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|registerFoundOption
argument_list|(
name|optionName
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|parseOptionValue
argument_list|(
name|optionName
argument_list|,
name|argument
argument_list|,
operator|&
name|argumentIterator
argument_list|,
name|args
operator|.
name|end
argument_list|()
argument_list|)
condition|)
name|error
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|doubleDashFound
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argument
operator|.
name|startsWith
argument_list|(
name|dashChar
argument_list|)
condition|)
block|{
if|if
condition|(
name|argument
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// single dash ("stdin")
name|positionalArgumentList
operator|.
name|append
argument_list|(
name|argument
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|singleDashWordOptionMode
condition|)
block|{
case|case
name|QCommandLineParser
operator|::
name|ParseAsCompactedShortOptions
case|:
block|{
name|QString
name|optionName
decl_stmt|;
name|bool
name|valueFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|1
init|;
name|pos
operator|<
name|argument
operator|.
name|size
argument_list|()
condition|;
operator|++
name|pos
control|)
block|{
name|optionName
operator|=
name|argument
operator|.
name|mid
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|registerFoundOption
argument_list|(
name|optionName
argument_list|)
condition|)
block|{
name|error
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|NameHash_t
operator|::
name|const_iterator
name|nameHashIt
init|=
name|nameHash
operator|.
name|constFind
argument_list|(
name|optionName
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|nameHashIt
operator|!=
name|nameHash
operator|.
name|constEnd
argument_list|()
argument_list|)
expr_stmt|;
comment|// checked by registerFoundOption
specifier|const
name|NameHash_t
operator|::
name|mapped_type
name|optionOffset
init|=
operator|*
name|nameHashIt
decl_stmt|;
specifier|const
name|bool
name|withValue
init|=
operator|!
name|commandLineOptionList
operator|.
name|at
argument_list|(
name|optionOffset
argument_list|)
operator|.
name|valueName
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|withValue
condition|)
block|{
if|if
condition|(
name|pos
operator|+
literal|1
operator|<
name|argument
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|argument
operator|.
name|at
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|==
name|assignChar
condition|)
operator|++
name|pos
expr_stmt|;
name|optionValuesHash
index|[
name|optionOffset
index|]
operator|.
name|append
argument_list|(
name|argument
operator|.
name|mid
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|valueFound
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|pos
operator|+
literal|1
operator|<
name|argument
operator|.
name|size
argument_list|()
operator|&&
name|argument
operator|.
name|at
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|==
name|assignChar
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|valueFound
operator|&&
operator|!
name|parseOptionValue
argument_list|(
name|optionName
argument_list|,
name|argument
argument_list|,
operator|&
name|argumentIterator
argument_list|,
name|args
operator|.
name|end
argument_list|()
argument_list|)
condition|)
name|error
operator|=
literal|true
expr_stmt|;
break|break;
block|}
case|case
name|QCommandLineParser
operator|::
name|ParseAsLongOptions
case|:
block|{
specifier|const
name|QString
name|optionName
init|=
name|argument
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
operator|.
name|section
argument_list|(
name|assignChar
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|registerFoundOption
argument_list|(
name|optionName
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|parseOptionValue
argument_list|(
name|optionName
argument_list|,
name|argument
argument_list|,
operator|&
name|argumentIterator
argument_list|,
name|args
operator|.
name|end
argument_list|()
argument_list|)
condition|)
name|error
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
else|else
block|{
name|positionalArgumentList
operator|.
name|append
argument_list|(
name|argument
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argumentIterator
operator|==
name|args
operator|.
name|end
argument_list|()
condition|)
break|break;
block|}
return|return
operator|!
name|error
return|;
block|}
end_function
begin_comment
comment|/*!     Checks whether the option \a name was passed to the application.      Returns true if the option \a name was set, false otherwise.      This is the recommended way to check for options with no values.      The name provided can be any long or short name of any option that was     added with \c addOption(). All the options names are treated as being     equivalent. If the name is not recognized or that option was not present,     false is returned.      Example:     \snippet code/src_corelib_tools_qcommandlineparser.cpp 0  */
end_comment
begin_function
DECL|function|isSet
name|bool
name|QCommandLineParser
operator|::
name|isSet
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|d
operator|->
name|checkParsed
argument_list|(
literal|"isSet"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|optionNames
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|true
return|;
specifier|const
name|QStringList
name|aliases
init|=
name|d
operator|->
name|aliases
argument_list|(
name|name
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|optionName
decl|,
name|d
operator|->
name|optionNames
control|)
block|{
if|if
condition|(
name|aliases
operator|.
name|contains
argument_list|(
name|optionName
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the option value found for the given option name \a optionName, or     an empty string if not found.      The name provided can be any long or short name of any option that was     added with \c addOption(). All the option names are treated as being     equivalent. If the name is not recognized or that option was not present, an     empty string is returned.      For options found by the parser, the last value found for     that option is returned. If the option wasn't specified on the command line,     the default value is returned.      An empty string is returned if the option does not take a value.      \sa values()  */
end_comment
begin_function
DECL|function|value
name|QString
name|QCommandLineParser
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|)
specifier|const
block|{
name|d
operator|->
name|checkParsed
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
specifier|const
name|QStringList
name|valueList
init|=
name|values
argument_list|(
name|optionName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|valueList
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|valueList
operator|.
name|last
argument_list|()
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of option values found for the given option name \a     optionName, or an empty list if not found.      The name provided can be any long or short name of any option that was     added with \c addOption(). All the options names are treated as being     equivalent. If the name is not recognized or that option was not present, an     empty list is returned.      For options found by the parser, the list will contain an entry for     each time the option was encountered by the parser. If the option wasn't     specified on the command line, the default values are returned.      An empty list is returned if the option does not take a value.      \sa value()  */
end_comment
begin_function
DECL|function|values
name|QStringList
name|QCommandLineParser
operator|::
name|values
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|)
specifier|const
block|{
name|d
operator|->
name|checkParsed
argument_list|(
literal|"values"
argument_list|)
expr_stmt|;
specifier|const
name|NameHash_t
operator|::
name|mapped_type
name|optionOffset
init|=
name|d
operator|->
name|nameHash
operator|.
name|value
argument_list|(
name|optionName
argument_list|,
name|optionNotFound
argument_list|)
decl_stmt|;
if|if
condition|(
name|optionOffset
operator|!=
name|optionNotFound
condition|)
block|{
name|QStringList
name|values
init|=
name|d
operator|->
name|optionValuesHash
operator|.
name|value
argument_list|(
name|optionOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
name|values
operator|=
name|d
operator|->
name|commandLineOptionList
operator|.
name|at
argument_list|(
name|optionOffset
argument_list|)
operator|.
name|defaultValues
argument_list|()
expr_stmt|;
return|return
name|values
return|;
block|}
name|qWarning
argument_list|(
literal|"QCommandLineParser: option not defined: \"%s\""
argument_list|,
name|qPrintable
argument_list|(
name|optionName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QStringList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Returns true if the \a option was set, false otherwise. */
end_comment
begin_function
DECL|function|isSet
name|bool
name|QCommandLineParser
operator|::
name|isSet
parameter_list|(
specifier|const
name|QCommandLineOption
modifier|&
name|option
parameter_list|)
specifier|const
block|{
return|return
name|isSet
argument_list|(
name|option
operator|.
name|names
argument_list|()
operator|.
name|first
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Returns the option value found for the given \a option, or     an empty string if not found. */
end_comment
begin_function
DECL|function|value
name|QString
name|QCommandLineParser
operator|::
name|value
parameter_list|(
specifier|const
name|QCommandLineOption
modifier|&
name|option
parameter_list|)
specifier|const
block|{
return|return
name|value
argument_list|(
name|option
operator|.
name|names
argument_list|()
operator|.
name|first
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Returns a list of option values found for the given \a option,     or an empty list if not found. */
end_comment
begin_function
DECL|function|values
name|QStringList
name|QCommandLineParser
operator|::
name|values
parameter_list|(
specifier|const
name|QCommandLineOption
modifier|&
name|option
parameter_list|)
specifier|const
block|{
return|return
name|values
argument_list|(
name|option
operator|.
name|names
argument_list|()
operator|.
name|first
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of positional arguments.      These are all of the arguments that were not recognized as part of an     option.  */
end_comment
begin_function
DECL|function|positionalArguments
name|QStringList
name|QCommandLineParser
operator|::
name|positionalArguments
parameter_list|()
specifier|const
block|{
name|d
operator|->
name|checkParsed
argument_list|(
literal|"positionalArguments"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|positionalArgumentList
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of option names that were found.      This returns a list of all the recognized option names found by the     parser, in the order in which they were found. For any long options     that were in the form {--option=value}, the value part will have been     dropped.      The names in this list do not include the preceding dash characters.     Names may appear more than once in this list if they were encountered     more than once by the parser.      Any entry in the list can be used with \c value() or with     \c values() to get any relevant option values.  */
end_comment
begin_function
DECL|function|optionNames
name|QStringList
name|QCommandLineParser
operator|::
name|optionNames
parameter_list|()
specifier|const
block|{
name|d
operator|->
name|checkParsed
argument_list|(
literal|"optionNames"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|optionNames
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of unknown option names.      This list will include both long an short name options that were not     recognized. For any long options that were in the form {--option=value},     the value part will have been dropped and only the long name is added.      The names in this list do not include the preceding dash characters.     Names may appear more than once in this list if they were encountered     more than once by the parser.      \sa optionNames()  */
end_comment
begin_function
DECL|function|unknownOptionNames
name|QStringList
name|QCommandLineParser
operator|::
name|unknownOptionNames
parameter_list|()
specifier|const
block|{
name|d
operator|->
name|checkParsed
argument_list|(
literal|"unknownOptionNames"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|unknownOptionNames
return|;
block|}
end_function
begin_comment
comment|/*!     Displays the help information, and exits the application.     This is automatically triggered by the --help option, but can also     be used to display the help when the user is not invoking the     application correctly.     The exit code is set to \a exitCode. It should be set to 0 if the     user requested to see the help, and to any other value in case of     an error.      \sa helpText() */
end_comment
begin_function
DECL|function|showHelp
name|Q_NORETURN
name|void
name|QCommandLineParser
operator|::
name|showHelp
parameter_list|(
name|int
name|exitCode
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|qPrintable
argument_list|(
name|d
operator|->
name|helpText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|::
name|exit
argument_list|(
name|exitCode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a string containing the complete help information.      \sa showHelp() */
end_comment
begin_function
DECL|function|helpText
name|QString
name|QCommandLineParser
operator|::
name|helpText
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|helpText
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|wrapText
specifier|static
name|QString
name|wrapText
parameter_list|(
specifier|const
name|QString
modifier|&
name|names
parameter_list|,
name|int
name|longestOptionNameString
parameter_list|,
specifier|const
name|QString
modifier|&
name|description
parameter_list|)
block|{
specifier|const
name|QLatin1Char
name|nl
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
name|QString
name|text
init|=
name|QStringLiteral
argument_list|(
literal|"  "
argument_list|)
operator|+
name|names
operator|.
name|leftJustified
argument_list|(
name|longestOptionNameString
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
specifier|const
name|int
name|leftColumnWidth
init|=
name|text
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|const
name|int
name|rightColumnWidth
init|=
literal|79
operator|-
name|leftColumnWidth
decl_stmt|;
name|text
operator|+=
name|description
operator|.
name|left
argument_list|(
name|rightColumnWidth
argument_list|)
operator|+
name|nl
expr_stmt|;
for|for
control|(
name|int
name|n
init|=
name|rightColumnWidth
init|;
name|n
operator|<
name|description
operator|.
name|length
argument_list|()
condition|;
name|n
operator|+=
name|rightColumnWidth
control|)
name|text
operator|+=
name|QStringLiteral
argument_list|(
literal|" "
argument_list|)
operator|.
name|repeated
argument_list|(
name|leftColumnWidth
argument_list|)
operator|+
name|description
operator|.
name|mid
argument_list|(
name|n
argument_list|,
name|rightColumnWidth
argument_list|)
operator|+
name|nl
expr_stmt|;
return|return
name|text
return|;
block|}
end_function
begin_function
DECL|function|helpText
name|QString
name|QCommandLineParserPrivate
operator|::
name|helpText
parameter_list|()
specifier|const
block|{
specifier|const
name|QLatin1Char
name|nl
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
name|QString
name|text
decl_stmt|;
specifier|const
name|QString
name|exeName
init|=
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|->
name|arguments
argument_list|()
operator|.
name|first
argument_list|()
decl_stmt|;
name|QString
name|usage
init|=
name|exeName
decl_stmt|;
if|if
condition|(
operator|!
name|commandLineOptionList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|usage
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|usage
operator|+=
name|QCommandLineParser
operator|::
name|tr
argument_list|(
literal|"[options]"
argument_list|)
expr_stmt|;
block|}
foreach|foreach
control|(
specifier|const
name|PositionalArgumentDefinition
modifier|&
name|arg
decl|,
name|positionalArgumentDefinitions
control|)
block|{
name|usage
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|usage
operator|+=
name|arg
operator|.
name|syntax
expr_stmt|;
block|}
name|text
operator|+=
name|QCommandLineParser
operator|::
name|tr
argument_list|(
literal|"Usage: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|usage
argument_list|)
operator|+
name|nl
expr_stmt|;
if|if
condition|(
operator|!
name|description
operator|.
name|isEmpty
argument_list|()
condition|)
name|text
operator|+=
name|description
operator|+
name|nl
expr_stmt|;
name|text
operator|+=
name|nl
expr_stmt|;
if|if
condition|(
operator|!
name|commandLineOptionList
operator|.
name|isEmpty
argument_list|()
condition|)
name|text
operator|+=
name|QCommandLineParser
operator|::
name|tr
argument_list|(
literal|"Options:"
argument_list|)
operator|+
name|nl
expr_stmt|;
name|QStringList
name|optionNameList
decl_stmt|;
name|int
name|longestOptionNameString
init|=
literal|0
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QCommandLineOption
modifier|&
name|option
decl|,
name|commandLineOptionList
control|)
block|{
name|QStringList
name|optionNames
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|optionName
decl|,
name|option
operator|.
name|names
argument_list|()
control|)
block|{
if|if
condition|(
name|optionName
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|)
name|optionNames
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
operator|+
name|optionName
argument_list|)
expr_stmt|;
else|else
name|optionNames
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"--"
argument_list|)
operator|+
name|optionName
argument_list|)
expr_stmt|;
block|}
name|QString
name|optionNamesString
init|=
name|optionNames
operator|.
name|join
argument_list|(
name|QStringLiteral
argument_list|(
literal|", "
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|option
operator|.
name|valueName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|optionNamesString
operator|+=
name|QStringLiteral
argument_list|(
literal|"<"
argument_list|)
operator|+
name|option
operator|.
name|valueName
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|optionNameList
operator|.
name|append
argument_list|(
name|optionNamesString
argument_list|)
expr_stmt|;
name|longestOptionNameString
operator|=
name|qMax
argument_list|(
name|longestOptionNameString
argument_list|,
name|optionNamesString
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|++
name|longestOptionNameString
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|commandLineOptionList
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QCommandLineOption
modifier|&
name|option
init|=
name|commandLineOptionList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|text
operator|+=
name|wrapText
argument_list|(
name|optionNameList
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|longestOptionNameString
argument_list|,
name|option
operator|.
name|description
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|positionalArgumentDefinitions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|commandLineOptionList
operator|.
name|isEmpty
argument_list|()
condition|)
name|text
operator|+=
name|nl
expr_stmt|;
name|text
operator|+=
name|QCommandLineParser
operator|::
name|tr
argument_list|(
literal|"Arguments:"
argument_list|)
operator|+
name|nl
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|PositionalArgumentDefinition
modifier|&
name|arg
decl|,
name|positionalArgumentDefinitions
control|)
block|{
name|text
operator|+=
name|wrapText
argument_list|(
name|arg
operator|.
name|name
argument_list|,
name|longestOptionNameString
argument_list|,
name|arg
operator|.
name|description
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|text
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
