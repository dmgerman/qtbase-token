begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Laszlo Papp<lpapp@kde.org> ** Copyright (C) 2013 David Faure<faure@kde.org> ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qcommandlineparser.h"
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<qvector.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
end_if
begin_include
include|#
directive|include
file|<qt_windows.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_typedef
DECL|typedef|NameHash_t
typedef|typedef
name|QHash
argument_list|<
name|QString
argument_list|,
name|int
argument_list|>
name|NameHash_t
typedef|;
end_typedef
begin_class
DECL|class|QCommandLineParserPrivate
class|class
name|QCommandLineParserPrivate
block|{
public|public:
DECL|function|QCommandLineParserPrivate
specifier|inline
name|QCommandLineParserPrivate
parameter_list|()
member_init_list|:
name|singleDashWordOptionMode
argument_list|(
name|QCommandLineParser
operator|::
name|ParseAsCompactedShortOptions
argument_list|)
member_init_list|,
name|optionsAfterPositionalArgumentsMode
argument_list|(
name|QCommandLineParser
operator|::
name|ParseAsOptions
argument_list|)
member_init_list|,
name|builtinVersionOption
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|builtinHelpOption
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|needsParsing
argument_list|(
literal|true
argument_list|)
block|{ }
name|bool
name|parse
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|args
parameter_list|)
function_decl|;
name|void
name|checkParsed
parameter_list|(
specifier|const
name|char
modifier|*
name|method
parameter_list|)
function_decl|;
name|QStringList
name|aliases
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
function_decl|;
name|QString
name|helpText
parameter_list|()
specifier|const
function_decl|;
name|bool
name|registerFoundOption
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|)
function_decl|;
name|bool
name|parseOptionValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|,
specifier|const
name|QString
modifier|&
name|argument
parameter_list|,
name|QStringList
operator|::
name|const_iterator
modifier|*
name|argumentIterator
parameter_list|,
name|QStringList
operator|::
name|const_iterator
name|argsEnd
parameter_list|)
function_decl|;
comment|//! Error text set when parse() returns false
DECL|member|errorText
name|QString
name|errorText
decl_stmt|;
comment|//! The command line options used for parsing
DECL|member|commandLineOptionList
name|QList
argument_list|<
name|QCommandLineOption
argument_list|>
name|commandLineOptionList
decl_stmt|;
comment|//! Hash mapping option names to their offsets in commandLineOptionList and optionArgumentList.
DECL|member|nameHash
name|NameHash_t
name|nameHash
decl_stmt|;
comment|//! Option values found (only for options with a value)
DECL|member|optionValuesHash
name|QHash
argument_list|<
name|int
argument_list|,
name|QStringList
argument_list|>
name|optionValuesHash
decl_stmt|;
comment|//! Names of options found on the command line.
DECL|member|optionNames
name|QStringList
name|optionNames
decl_stmt|;
comment|//! Arguments which did not belong to any option.
DECL|member|positionalArgumentList
name|QStringList
name|positionalArgumentList
decl_stmt|;
comment|//! Names of options which were unknown.
DECL|member|unknownOptionNames
name|QStringList
name|unknownOptionNames
decl_stmt|;
comment|//! Application description
DECL|member|description
name|QString
name|description
decl_stmt|;
comment|//! Documentation for positional arguments
DECL|struct|PositionalArgumentDefinition
struct|struct
name|PositionalArgumentDefinition
block|{
DECL|member|name
name|QString
name|name
decl_stmt|;
DECL|member|description
name|QString
name|description
decl_stmt|;
DECL|member|syntax
name|QString
name|syntax
decl_stmt|;
block|}
struct|;
DECL|member|positionalArgumentDefinitions
name|QVector
argument_list|<
name|PositionalArgumentDefinition
argument_list|>
name|positionalArgumentDefinitions
decl_stmt|;
comment|//! The parsing mode for "-abc"
DECL|member|singleDashWordOptionMode
name|QCommandLineParser
operator|::
name|SingleDashWordOptionMode
name|singleDashWordOptionMode
decl_stmt|;
comment|//! How to parse "arg -option"
DECL|member|optionsAfterPositionalArgumentsMode
name|QCommandLineParser
operator|::
name|OptionsAfterPositionalArgumentsMode
name|optionsAfterPositionalArgumentsMode
decl_stmt|;
comment|//! Whether addVersionOption was called
DECL|member|builtinVersionOption
name|bool
name|builtinVersionOption
decl_stmt|;
comment|//! Whether addHelpOption was called
DECL|member|builtinHelpOption
name|bool
name|builtinHelpOption
decl_stmt|;
comment|//! True if parse() needs to be called
DECL|member|needsParsing
name|bool
name|needsParsing
decl_stmt|;
block|}
class|;
end_class
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|QCommandLineParserPrivate
operator|::
name|PositionalArgumentDefinition
argument_list|,
name|Q_MOVABLE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_function
DECL|function|aliases
name|QStringList
name|QCommandLineParserPrivate
operator|::
name|aliases
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|)
specifier|const
block|{
specifier|const
name|NameHash_t
operator|::
name|const_iterator
name|it
init|=
name|nameHash
operator|.
name|constFind
argument_list|(
name|optionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|nameHash
operator|.
name|cend
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCommandLineParser: option not defined: \"%s\""
argument_list|,
name|qPrintable
argument_list|(
name|optionName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QStringList
argument_list|()
return|;
block|}
return|return
name|commandLineOptionList
operator|.
name|at
argument_list|(
operator|*
name|it
argument_list|)
operator|.
name|names
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2     \class QCommandLineParser     \inmodule QtCore     \ingroup tools      \brief The QCommandLineParser class provides a means for handling the     command line options.      QCoreApplication provides the command-line arguments as a simple list of strings.     QCommandLineParser provides the ability to define a set of options, parse the     command-line arguments, and store which options have actually been used, as     well as option values.      Any argument that isn't an option (i.e. doesn't start with a \c{-}) is stored     as a "positional argument".      The parser handles short names, long names, more than one name for the same     option, and option values.      Options on the command line are recognized as starting with a single or     double \c{-} character(s).     The option \c{-} (single dash alone) is a special case, often meaning standard     input, and not treated as an option. The parser will treat everything after the     option \c{--} (double dash) as positional arguments.      Short options are single letters. The option \c{v} would be specified by     passing \c{-v} on the command line. In the default parsing mode, short options     can be written in a compact form, for instance \c{-abc} is equivalent to \c{-a -b -c}.     The parsing mode for can be set to ParseAsLongOptions, in which case \c{-abc}     will be parsed as the long option \c{abc}.      Long options are more than one letter long and cannot be compacted together.     The long option \c{verbose} would be passed as \c{--verbose} or \c{-verbose}.      Passing values to options can be done using the assignment operator: \c{-v=value}     \c{--verbose=value}, or a space: \c{-v value} \c{--verbose value}, i.e. the next     argument is used as value (even if it starts with a \c{-}).      The parser does not support optional values - if an option is set to     require a value, one must be present. If such an option is placed last     and has no value, the option will be treated as if it had not been     specified.      The parser does not automatically support negating or disabling long options     by using the format \c{--disable-option} or \c{--no-option}. However, it is     possible to handle this case explicitly by making an option with \c{no-option}     as one of its names, and handling the option explicitly.      Example:     \snippet code/src_corelib_tools_qcommandlineparser_main.cpp 0      If your compiler supports the C++11 standard, the three addOption() calls in     the above example can be simplified:     \snippet code/src_corelib_tools_qcommandlineparser_main.cpp cxx11      Known limitation: the parsing of Qt options inside QCoreApplication and subclasses     happens before QCommandLineParser exists, so it can't take it into account. This     means any option value that looks like a builtin Qt option, will be treated by     QCoreApplication as a builtin Qt option. Example: \c{--profile -reverse} will     lead to QGuiApplication seeing the -reverse option set, and removing it from     QCoreApplication::arguments() before QCommandLineParser defines the \c{profile}     option and parses the command line.      \section2 How to Use QCommandLineParser in Complex Applications      In practice, additional error checking needs to be performed on the positional     arguments and option values. For example, ranges of numbers should be checked.      It is then advisable to introduce a function to do the command line parsing     which takes a struct or class receiving the option values returning an     enumeration representing the result. The dnslookup example of the QtNetwork     module illustrates this:      \snippet dnslookup.h 0      \snippet dnslookup.cpp 0      In the main function, help should be printed to the standard output if the help option     was passed and the application should return the exit code 0.      If an error was detected, the error message should be printed to the standard     error output and the application should return an exit code other than 0.      \snippet dnslookup.cpp 1      A special case to consider here are GUI applications on Windows and mobile     platforms. These applications may not use the standard output or error channels     since the output is either discarded or not accessible.      On Windows, QCommandLineParser uses message boxes to display usage information     and errors if no console window can be obtained.      For other platforms, it is recommended to display help texts and error messages     using a QMessageBox. To preserve the formatting of the help text, rich text     with \c<pre> elements should be used:      \code      switch (parseCommandLine(parser,&query,&errorMessage)) {     case CommandLineOk:         break;     case CommandLineError:         QMessageBox::warning(0, QGuiApplication::applicationDisplayName(),                              "<html><head/><body><h2>" + errorMessage + "</h2><pre>"                              + parser.helpText() + "</pre></body></html>");         return 1;     case CommandLineVersionRequested:         QMessageBox::information(0, QGuiApplication::applicationDisplayName(),                                  QGuiApplication::applicationDisplayName() + ' '                                  + QCoreApplication::applicationVersion());         return 0;     case CommandLineHelpRequested:         QMessageBox::warning(0, QGuiApplication::applicationDisplayName(),                              "<html><head/><body><pre>"                              + parser.helpText() + "</pre></body></html>");         return 0;     }     \endcode      However, this does not apply to the dnslookup example, because it is a     console application.      \sa QCommandLineOption, QCoreApplication */
end_comment
begin_comment
comment|/*!     Constructs a command line parser object. */
end_comment
begin_constructor
DECL|function|QCommandLineParser
name|QCommandLineParser
operator|::
name|QCommandLineParser
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QCommandLineParserPrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the command line parser object. */
end_comment
begin_destructor
DECL|function|~QCommandLineParser
name|QCommandLineParser
operator|::
name|~
name|QCommandLineParser
parameter_list|()
block|{
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \enum QCommandLineParser::SingleDashWordOptionMode      This enum describes the way the parser interprets command-line     options that use a single dash followed by multiple letters, as as \c{-abc}.      \value ParseAsCompactedShortOptions \c{-abc} is interpreted as \c{-a -b -c},     i.e. as three short options that have been compacted on the command-line,     if none of the options take a value. If \c{a} takes a value, then it     is interpreted as \c{-a bc}, i.e. the short option \c{a} followed by the value \c{bc}.     This is typically used in tools that behave like compilers, in order     to handle options such as \c{-DDEFINE=VALUE} or \c{-I/include/path}.     This is the default parsing mode. New applications are recommended to     use this mode.      \value ParseAsLongOptions \c{-abc} is interpreted as \c{--abc},     i.e. as the long option named \c{abc}. This is how Qt's own tools     (uic, rcc...) have always been parsing arguments. This mode should be     used for preserving compatibility in applications that were parsing     arguments in such a way.      \sa setSingleDashWordOptionMode() */
end_comment
begin_comment
comment|/*!     Sets the parsing mode to \a singleDashWordOptionMode.     This must be called before process() or parse(). */
end_comment
begin_function
DECL|function|setSingleDashWordOptionMode
name|void
name|QCommandLineParser
operator|::
name|setSingleDashWordOptionMode
parameter_list|(
name|QCommandLineParser
operator|::
name|SingleDashWordOptionMode
name|singleDashWordOptionMode
parameter_list|)
block|{
name|d
operator|->
name|singleDashWordOptionMode
operator|=
name|singleDashWordOptionMode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \enum QCommandLineParser::OptionsAfterPositionalArgumentsMode      This enum describes the way the parser interprets options that     occur after positional arguments.      \value ParseAsOptions \c{application argument --opt -t} is interpreted as setting     the options \c{opt} and \c{t}, just like \c{application --opt -t argument} would do.     This is the default parsing mode. In order to specify that \c{--opt} and \c{-t}     are positional arguments instead, the user can use \c{--}, as in     \c{application argument -- --opt -t}.      \value ParseAsPositionalArguments \c{application argument --opt} is interpreted as     having two positional arguments, \c{argument} and \c{--opt}.     This mode is useful for executables that aim to launch other executables     (e.g. wrappers, debugging tools, etc.) or that support internal commands     followed by options for the command. \c{argument} is the name of the command,     and all options occurring after it can be collected and parsed by another     command line parser, possibly in another executable.      \sa setOptionsAfterPositionalArgumentsMode()      \since 5.6 */
end_comment
begin_comment
comment|/*!     Sets the parsing mode to \a parsingMode.     This must be called before process() or parse().     \since 5.6 */
end_comment
begin_function
DECL|function|setOptionsAfterPositionalArgumentsMode
name|void
name|QCommandLineParser
operator|::
name|setOptionsAfterPositionalArgumentsMode
parameter_list|(
name|QCommandLineParser
operator|::
name|OptionsAfterPositionalArgumentsMode
name|parsingMode
parameter_list|)
block|{
name|d
operator|->
name|optionsAfterPositionalArgumentsMode
operator|=
name|parsingMode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds the option \a option to look for while parsing.      Returns \c true if adding the option was successful; otherwise returns \c false.      Adding the option fails if there is no name attached to the option, or     the option has a name that clashes with an option name added before.  */
end_comment
begin_function
DECL|function|addOption
name|bool
name|QCommandLineParser
operator|::
name|addOption
parameter_list|(
specifier|const
name|QCommandLineOption
modifier|&
name|option
parameter_list|)
block|{
specifier|const
name|QStringList
name|optionNames
init|=
name|option
operator|.
name|names
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|optionNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
specifier|const
name|QString
modifier|&
name|name
range|:
name|optionNames
control|)
block|{
if|if
condition|(
name|d
operator|->
name|nameHash
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
name|d
operator|->
name|commandLineOptionList
operator|.
name|append
argument_list|(
name|option
argument_list|)
expr_stmt|;
specifier|const
name|int
name|offset
init|=
name|d
operator|->
name|commandLineOptionList
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
specifier|const
name|QString
modifier|&
name|name
range|:
name|optionNames
control|)
name|d
operator|->
name|nameHash
operator|.
name|insert
argument_list|(
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.4      Adds the options to look for while parsing. The options are specified by     the parameter \a options.      Returns \c true if adding all of the options was successful; otherwise     returns \c false.      See the documentation for addOption() for when this function may fail. */
end_comment
begin_function
DECL|function|addOptions
name|bool
name|QCommandLineParser
operator|::
name|addOptions
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QCommandLineOption
argument_list|>
modifier|&
name|options
parameter_list|)
block|{
comment|// should be optimized (but it's no worse than what was possible before)
name|bool
name|result
init|=
literal|true
decl_stmt|;
for|for
control|(
name|QList
argument_list|<
name|QCommandLineOption
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|options
operator|.
name|begin
argument_list|()
init|,
name|end
init|=
name|options
operator|.
name|end
argument_list|()
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|result
operator|&=
name|addOption
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Adds the \c{-v} / \c{--version} option, which displays the version string of the application.      This option is handled automatically by QCommandLineParser.      You can set the actual version string by using QCoreApplication::setApplicationVersion().      Returns the option instance, which can be used to call isSet(). */
end_comment
begin_function
DECL|function|addVersionOption
name|QCommandLineOption
name|QCommandLineParser
operator|::
name|addVersionOption
parameter_list|()
block|{
name|QCommandLineOption
name|opt
argument_list|(
name|QStringList
argument_list|()
operator|<<
name|QStringLiteral
argument_list|(
literal|"v"
argument_list|)
operator|<<
name|QStringLiteral
argument_list|(
literal|"version"
argument_list|)
argument_list|,
name|tr
argument_list|(
literal|"Displays version information."
argument_list|)
argument_list|)
decl_stmt|;
name|addOption
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|d
operator|->
name|builtinVersionOption
operator|=
literal|true
expr_stmt|;
return|return
name|opt
return|;
block|}
end_function
begin_comment
comment|/*!     Adds the help option (\c{-h}, \c{--help} and \c{-?} on Windows)     This option is handled automatically by QCommandLineParser.      Remember to use setApplicationDescription to set the application description,     which will be displayed when this option is used.      Example:     \snippet code/src_corelib_tools_qcommandlineparser_main.cpp 0      Returns the option instance, which can be used to call isSet(). */
end_comment
begin_function
DECL|function|addHelpOption
name|QCommandLineOption
name|QCommandLineParser
operator|::
name|addHelpOption
parameter_list|()
block|{
name|QCommandLineOption
name|opt
argument_list|(
name|QStringList
argument_list|()
ifdef|#
directive|ifdef
name|Q_OS_WIN
operator|<<
name|QStringLiteral
argument_list|(
literal|"?"
argument_list|)
endif|#
directive|endif
operator|<<
name|QStringLiteral
argument_list|(
literal|"h"
argument_list|)
operator|<<
name|QStringLiteral
argument_list|(
literal|"help"
argument_list|)
argument_list|,
name|tr
argument_list|(
literal|"Displays this help."
argument_list|)
argument_list|)
decl_stmt|;
name|addOption
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|d
operator|->
name|builtinHelpOption
operator|=
literal|true
expr_stmt|;
return|return
name|opt
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the application \a description shown by helpText(). */
end_comment
begin_function
DECL|function|setApplicationDescription
name|void
name|QCommandLineParser
operator|::
name|setApplicationDescription
parameter_list|(
specifier|const
name|QString
modifier|&
name|description
parameter_list|)
block|{
name|d
operator|->
name|description
operator|=
name|description
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the application description set in setApplicationDescription(). */
end_comment
begin_function
DECL|function|applicationDescription
name|QString
name|QCommandLineParser
operator|::
name|applicationDescription
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|description
return|;
block|}
end_function
begin_comment
comment|/*!     Defines an additional argument to the application, for the benefit of the help text.      The argument \a name and \a description will appear under the \c{Arguments:} section     of the help. If \a syntax is specified, it will be appended to the Usage line, otherwise     the \a name will be appended.      Example:     \snippet code/src_corelib_tools_qcommandlineparser.cpp 2      \sa addHelpOption(), helpText() */
end_comment
begin_function
DECL|function|addPositionalArgument
name|void
name|QCommandLineParser
operator|::
name|addPositionalArgument
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|description
parameter_list|,
specifier|const
name|QString
modifier|&
name|syntax
parameter_list|)
block|{
name|QCommandLineParserPrivate
operator|::
name|PositionalArgumentDefinition
name|arg
decl_stmt|;
name|arg
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|arg
operator|.
name|description
operator|=
name|description
expr_stmt|;
name|arg
operator|.
name|syntax
operator|=
name|syntax
operator|.
name|isEmpty
argument_list|()
condition|?
name|name
else|:
name|syntax
expr_stmt|;
name|d
operator|->
name|positionalArgumentDefinitions
operator|.
name|append
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Clears the definitions of additional arguments from the help text.      This is only needed for the special case of tools which support multiple commands     with different options. Once the actual command has been identified, the options     for this command can be defined, and the help text for the command can be adjusted     accordingly.      Example:     \snippet code/src_corelib_tools_qcommandlineparser.cpp 3 */
end_comment
begin_function
DECL|function|clearPositionalArguments
name|void
name|QCommandLineParser
operator|::
name|clearPositionalArguments
parameter_list|()
block|{
name|d
operator|->
name|positionalArgumentDefinitions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Parses the command line \a arguments.      Most programs don't need to call this, a simple call to process() is enough.      parse() is more low-level, and only does the parsing. The application will have to     take care of the error handling, using errorText() if parse() returns \c false.     This can be useful for instance to show a graphical error message in graphical programs.      Calling parse() instead of process() can also be useful in order to ignore unknown     options temporarily, because more option definitions will be provided later on     (depending on one of the arguments), before calling process().      Don't forget that \a arguments must start with the name of the executable (ignored, though).      Returns \c false in case of a parse error (unknown option or missing value); returns \c true otherwise.      \sa process() */
end_comment
begin_function
DECL|function|parse
name|bool
name|QCommandLineParser
operator|::
name|parse
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|)
block|{
return|return
name|d
operator|->
name|parse
argument_list|(
name|arguments
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a translated error text for the user.     This should only be called when parse() returns \c false. */
end_comment
begin_function
DECL|function|errorText
name|QString
name|QCommandLineParser
operator|::
name|errorText
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|errorText
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|d
operator|->
name|errorText
return|;
if|if
condition|(
name|d
operator|->
name|unknownOptionNames
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
return|return
name|tr
argument_list|(
literal|"Unknown option '%1'."
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|unknownOptionNames
operator|.
name|first
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|d
operator|->
name|unknownOptionNames
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
return|return
name|tr
argument_list|(
literal|"Unknown options: %1."
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|unknownOptionNames
operator|.
name|join
argument_list|(
name|QStringLiteral
argument_list|(
literal|", "
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_enum
DECL|enum|MessageType
DECL|enumerator|UsageMessage
DECL|enumerator|ErrorMessage
enum|enum
name|MessageType
block|{
name|UsageMessage
block|,
name|ErrorMessage
block|}
enum|;
end_enum
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
end_if
begin_comment
comment|// Return whether to use a message box. Use handles if a console can be obtained
end_comment
begin_comment
comment|// or we are run with redirected handles (for example, by QProcess).
end_comment
begin_function
DECL|function|displayMessageBox
specifier|static
specifier|inline
name|bool
name|displayMessageBox
parameter_list|()
block|{
if|if
condition|(
name|GetConsoleWindow
argument_list|()
condition|)
return|return
literal|false
return|;
name|STARTUPINFO
name|startupInfo
decl_stmt|;
name|startupInfo
operator|.
name|cb
operator|=
sizeof|sizeof
argument_list|(
name|STARTUPINFO
argument_list|)
expr_stmt|;
name|GetStartupInfo
argument_list|(
operator|&
name|startupInfo
argument_list|)
expr_stmt|;
return|return
operator|!
operator|(
name|startupInfo
operator|.
name|dwFlags
operator|&
name|STARTF_USESTDHANDLES
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_OS_WIN&& !QT_BOOTSTRAPPED&& !Q_OS_WIN&& !Q_OS_WINRT
end_comment
begin_function
DECL|function|showParserMessage
specifier|static
name|void
name|showParserMessage
parameter_list|(
specifier|const
name|QString
modifier|&
name|message
parameter_list|,
name|MessageType
name|type
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
if|if
condition|(
name|displayMessageBox
argument_list|()
condition|)
block|{
specifier|const
name|UINT
name|flags
init|=
name|MB_OK
operator||
name|MB_TOPMOST
operator||
name|MB_SETFOREGROUND
operator||
operator|(
name|type
operator|==
name|UsageMessage
condition|?
name|MB_ICONINFORMATION
else|:
name|MB_ICONERROR
operator|)
decl_stmt|;
name|QString
name|title
decl_stmt|;
if|if
condition|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
condition|)
name|title
operator|=
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|->
name|property
argument_list|(
literal|"applicationDisplayName"
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|title
operator|.
name|isEmpty
argument_list|()
condition|)
name|title
operator|=
name|QCoreApplication
operator|::
name|applicationName
argument_list|()
expr_stmt|;
name|MessageBoxW
argument_list|(
literal|0
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|message
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|title
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|// Q_OS_WIN&& !QT_BOOTSTRAPPED&& !Q_OS_WIN&& !Q_OS_WINRT
name|fputs
argument_list|(
name|qPrintable
argument_list|(
name|message
argument_list|)
argument_list|,
name|type
operator|==
name|UsageMessage
condition|?
name|stdout
else|:
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Processes the command line \a arguments.      In addition to parsing the options (like parse()), this function also handles the builtin     options and handles errors.      The builtin options are \c{--version} if addVersionOption was called and \c{--help} if addHelpOption was called.      When invoking one of these options, or when an error happens (for instance an unknown option was     passed), the current process will then stop, using the exit() function.      \sa QCoreApplication::arguments(), parse()  */
end_comment
begin_function
DECL|function|process
name|void
name|QCommandLineParser
operator|::
name|process
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|arguments
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|parse
argument_list|(
name|arguments
argument_list|)
condition|)
block|{
name|showParserMessage
argument_list|(
name|errorText
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|,
name|ErrorMessage
argument_list|)
expr_stmt|;
operator|::
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|builtinVersionOption
operator|&&
name|isSet
argument_list|(
name|QStringLiteral
argument_list|(
literal|"version"
argument_list|)
argument_list|)
condition|)
name|showVersion
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|builtinHelpOption
operator|&&
name|isSet
argument_list|(
name|QStringLiteral
argument_list|(
literal|"help"
argument_list|)
argument_list|)
condition|)
name|showHelp
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      The command line is obtained from the QCoreApplication instance \a app.  */
end_comment
begin_function
DECL|function|process
name|void
name|QCommandLineParser
operator|::
name|process
parameter_list|(
specifier|const
name|QCoreApplication
modifier|&
name|app
parameter_list|)
block|{
comment|// QCoreApplication::arguments() is static, but the app instance must exist so we require it as parameter
name|Q_UNUSED
argument_list|(
name|app
argument_list|)
expr_stmt|;
name|process
argument_list|(
name|QCoreApplication
operator|::
name|arguments
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|checkParsed
name|void
name|QCommandLineParserPrivate
operator|::
name|checkParsed
parameter_list|(
specifier|const
name|char
modifier|*
name|method
parameter_list|)
block|{
if|if
condition|(
name|needsParsing
condition|)
name|qWarning
argument_list|(
literal|"QCommandLineParser: call process() or parse() before %s"
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Looks up the option \a optionName (found on the command line) and register it as found.     Returns \c true on success.  */
end_comment
begin_function
DECL|function|registerFoundOption
name|bool
name|QCommandLineParserPrivate
operator|::
name|registerFoundOption
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|)
block|{
if|if
condition|(
name|nameHash
operator|.
name|contains
argument_list|(
name|optionName
argument_list|)
condition|)
block|{
name|optionNames
operator|.
name|append
argument_list|(
name|optionName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|unknownOptionNames
operator|.
name|append
argument_list|(
name|optionName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     \brief Parse the value for a given option, if it was defined to expect one.      The value is taken from the next argument, or after the equal sign in \a argument.      \param optionName the short option name     \param argument the argument from the command line currently parsed. Only used for -k=value parsing.     \param argumentIterator iterator to the currently parsed argument. Incremented if the next argument contains the value.     \param argsEnd args.end(), to check if ++argumentIterator goes out of bounds     Returns \c true on success.  */
end_comment
begin_function
DECL|function|parseOptionValue
name|bool
name|QCommandLineParserPrivate
operator|::
name|parseOptionValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|,
specifier|const
name|QString
modifier|&
name|argument
parameter_list|,
name|QStringList
operator|::
name|const_iterator
modifier|*
name|argumentIterator
parameter_list|,
name|QStringList
operator|::
name|const_iterator
name|argsEnd
parameter_list|)
block|{
specifier|const
name|QLatin1Char
name|assignChar
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
specifier|const
name|NameHash_t
operator|::
name|const_iterator
name|nameHashIt
init|=
name|nameHash
operator|.
name|constFind
argument_list|(
name|optionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nameHashIt
operator|!=
name|nameHash
operator|.
name|constEnd
argument_list|()
condition|)
block|{
specifier|const
name|int
name|assignPos
init|=
name|argument
operator|.
name|indexOf
argument_list|(
name|assignChar
argument_list|)
decl_stmt|;
specifier|const
name|NameHash_t
operator|::
name|mapped_type
name|optionOffset
init|=
operator|*
name|nameHashIt
decl_stmt|;
specifier|const
name|bool
name|withValue
init|=
operator|!
name|commandLineOptionList
operator|.
name|at
argument_list|(
name|optionOffset
argument_list|)
operator|.
name|valueName
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|withValue
condition|)
block|{
if|if
condition|(
name|assignPos
operator|==
operator|-
literal|1
condition|)
block|{
operator|++
operator|(
operator|*
name|argumentIterator
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|argumentIterator
operator|==
name|argsEnd
condition|)
block|{
name|errorText
operator|=
name|QCommandLineParser
operator|::
name|tr
argument_list|(
literal|"Missing value after '%1'."
argument_list|)
operator|.
name|arg
argument_list|(
name|argument
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|optionValuesHash
index|[
name|optionOffset
index|]
operator|.
name|append
argument_list|(
operator|*
operator|(
operator|*
name|argumentIterator
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|optionValuesHash
index|[
name|optionOffset
index|]
operator|.
name|append
argument_list|(
name|argument
operator|.
name|mid
argument_list|(
name|assignPos
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|assignPos
operator|!=
operator|-
literal|1
condition|)
block|{
name|errorText
operator|=
name|QCommandLineParser
operator|::
name|tr
argument_list|(
literal|"Unexpected value after '%1'."
argument_list|)
operator|.
name|arg
argument_list|(
name|argument
operator|.
name|left
argument_list|(
name|assignPos
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Parse the list of arguments \a args, and fills in     optionNames, optionValuesHash, unknownOptionNames, positionalArguments, and errorText.      Any results from a previous parse operation are removed.      The parser will not look for further options once it encounters the option     \c{--}; this does not include when \c{--} follows an option that requires a value.  */
end_comment
begin_function
DECL|function|parse
name|bool
name|QCommandLineParserPrivate
operator|::
name|parse
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|args
parameter_list|)
block|{
name|needsParsing
operator|=
literal|false
expr_stmt|;
name|bool
name|error
init|=
literal|false
decl_stmt|;
specifier|const
name|QString
name|doubleDashString
argument_list|(
name|QStringLiteral
argument_list|(
literal|"--"
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QLatin1Char
name|dashChar
argument_list|(
literal|'-'
argument_list|)
decl_stmt|;
specifier|const
name|QLatin1Char
name|assignChar
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
name|bool
name|forcePositional
init|=
literal|false
decl_stmt|;
name|errorText
operator|.
name|clear
argument_list|()
expr_stmt|;
name|positionalArgumentList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|optionNames
operator|.
name|clear
argument_list|()
expr_stmt|;
name|unknownOptionNames
operator|.
name|clear
argument_list|()
expr_stmt|;
name|optionValuesHash
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCommandLineParser: argument list cannot be empty, it should contain at least the executable name"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QStringList
operator|::
name|const_iterator
name|argumentIterator
init|=
name|args
operator|.
name|begin
argument_list|()
decl_stmt|;
operator|++
name|argumentIterator
expr_stmt|;
comment|// skip executable name
for|for
control|(
init|;
name|argumentIterator
operator|!=
name|args
operator|.
name|end
argument_list|()
condition|;
operator|++
name|argumentIterator
control|)
block|{
name|QString
name|argument
init|=
operator|*
name|argumentIterator
decl_stmt|;
if|if
condition|(
name|forcePositional
condition|)
block|{
name|positionalArgumentList
operator|.
name|append
argument_list|(
name|argument
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argument
operator|.
name|startsWith
argument_list|(
name|doubleDashString
argument_list|)
condition|)
block|{
if|if
condition|(
name|argument
operator|.
name|length
argument_list|()
operator|>
literal|2
condition|)
block|{
name|QString
name|optionName
init|=
name|argument
operator|.
name|mid
argument_list|(
literal|2
argument_list|)
operator|.
name|section
argument_list|(
name|assignChar
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|registerFoundOption
argument_list|(
name|optionName
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|parseOptionValue
argument_list|(
name|optionName
argument_list|,
name|argument
argument_list|,
operator|&
name|argumentIterator
argument_list|,
name|args
operator|.
name|end
argument_list|()
argument_list|)
condition|)
name|error
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|forcePositional
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argument
operator|.
name|startsWith
argument_list|(
name|dashChar
argument_list|)
condition|)
block|{
if|if
condition|(
name|argument
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// single dash ("stdin")
name|positionalArgumentList
operator|.
name|append
argument_list|(
name|argument
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|singleDashWordOptionMode
condition|)
block|{
case|case
name|QCommandLineParser
operator|::
name|ParseAsCompactedShortOptions
case|:
block|{
name|QString
name|optionName
decl_stmt|;
name|bool
name|valueFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|1
init|;
name|pos
operator|<
name|argument
operator|.
name|size
argument_list|()
condition|;
operator|++
name|pos
control|)
block|{
name|optionName
operator|=
name|argument
operator|.
name|mid
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|registerFoundOption
argument_list|(
name|optionName
argument_list|)
condition|)
block|{
name|error
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|NameHash_t
operator|::
name|const_iterator
name|nameHashIt
init|=
name|nameHash
operator|.
name|constFind
argument_list|(
name|optionName
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|nameHashIt
operator|!=
name|nameHash
operator|.
name|constEnd
argument_list|()
argument_list|)
expr_stmt|;
comment|// checked by registerFoundOption
specifier|const
name|NameHash_t
operator|::
name|mapped_type
name|optionOffset
init|=
operator|*
name|nameHashIt
decl_stmt|;
specifier|const
name|bool
name|withValue
init|=
operator|!
name|commandLineOptionList
operator|.
name|at
argument_list|(
name|optionOffset
argument_list|)
operator|.
name|valueName
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|withValue
condition|)
block|{
if|if
condition|(
name|pos
operator|+
literal|1
operator|<
name|argument
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|argument
operator|.
name|at
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|==
name|assignChar
condition|)
operator|++
name|pos
expr_stmt|;
name|optionValuesHash
index|[
name|optionOffset
index|]
operator|.
name|append
argument_list|(
name|argument
operator|.
name|mid
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|valueFound
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|pos
operator|+
literal|1
operator|<
name|argument
operator|.
name|size
argument_list|()
operator|&&
name|argument
operator|.
name|at
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|==
name|assignChar
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|valueFound
operator|&&
operator|!
name|parseOptionValue
argument_list|(
name|optionName
argument_list|,
name|argument
argument_list|,
operator|&
name|argumentIterator
argument_list|,
name|args
operator|.
name|end
argument_list|()
argument_list|)
condition|)
name|error
operator|=
literal|true
expr_stmt|;
break|break;
block|}
case|case
name|QCommandLineParser
operator|::
name|ParseAsLongOptions
case|:
block|{
specifier|const
name|QString
name|optionName
init|=
name|argument
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
operator|.
name|section
argument_list|(
name|assignChar
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|registerFoundOption
argument_list|(
name|optionName
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|parseOptionValue
argument_list|(
name|optionName
argument_list|,
name|argument
argument_list|,
operator|&
name|argumentIterator
argument_list|,
name|args
operator|.
name|end
argument_list|()
argument_list|)
condition|)
name|error
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
else|else
block|{
name|positionalArgumentList
operator|.
name|append
argument_list|(
name|argument
argument_list|)
expr_stmt|;
if|if
condition|(
name|optionsAfterPositionalArgumentsMode
operator|==
name|QCommandLineParser
operator|::
name|ParseAsPositionalArguments
condition|)
name|forcePositional
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|argumentIterator
operator|==
name|args
operator|.
name|end
argument_list|()
condition|)
break|break;
block|}
return|return
operator|!
name|error
return|;
block|}
end_function
begin_comment
comment|/*!     Checks whether the option \a name was passed to the application.      Returns \c true if the option \a name was set, false otherwise.      The name provided can be any long or short name of any option that was     added with \c addOption(). All the options names are treated as being     equivalent. If the name is not recognized or that option was not present,     false is returned.      Example:     \snippet code/src_corelib_tools_qcommandlineparser.cpp 0  */
end_comment
begin_function
DECL|function|isSet
name|bool
name|QCommandLineParser
operator|::
name|isSet
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
name|d
operator|->
name|checkParsed
argument_list|(
literal|"isSet"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|optionNames
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|true
return|;
specifier|const
name|QStringList
name|aliases
init|=
name|d
operator|->
name|aliases
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
specifier|const
name|QString
modifier|&
name|optionName
range|:
name|qAsConst
argument_list|(
name|d
operator|->
name|optionNames
argument_list|)
control|)
block|{
if|if
condition|(
name|aliases
operator|.
name|contains
argument_list|(
name|optionName
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the option value found for the given option name \a optionName, or     an empty string if not found.      The name provided can be any long or short name of any option that was     added with \c addOption(). All the option names are treated as being     equivalent. If the name is not recognized or that option was not present, an     empty string is returned.      For options found by the parser, the last value found for     that option is returned. If the option wasn't specified on the command line,     the default value is returned.      An empty string is returned if the option does not take a value.      \sa values(), QCommandLineOption::setDefaultValue(), QCommandLineOption::setDefaultValues()  */
end_comment
begin_function
DECL|function|value
name|QString
name|QCommandLineParser
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|)
specifier|const
block|{
name|d
operator|->
name|checkParsed
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
specifier|const
name|QStringList
name|valueList
init|=
name|values
argument_list|(
name|optionName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|valueList
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|valueList
operator|.
name|last
argument_list|()
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of option values found for the given option name \a     optionName, or an empty list if not found.      The name provided can be any long or short name of any option that was     added with \c addOption(). All the options names are treated as being     equivalent. If the name is not recognized or that option was not present, an     empty list is returned.      For options found by the parser, the list will contain an entry for     each time the option was encountered by the parser. If the option wasn't     specified on the command line, the default values are returned.      An empty list is returned if the option does not take a value.      \sa value(), QCommandLineOption::setDefaultValue(), QCommandLineOption::setDefaultValues()  */
end_comment
begin_function
DECL|function|values
name|QStringList
name|QCommandLineParser
operator|::
name|values
parameter_list|(
specifier|const
name|QString
modifier|&
name|optionName
parameter_list|)
specifier|const
block|{
name|d
operator|->
name|checkParsed
argument_list|(
literal|"values"
argument_list|)
expr_stmt|;
specifier|const
name|NameHash_t
operator|::
name|const_iterator
name|it
init|=
name|d
operator|->
name|nameHash
operator|.
name|constFind
argument_list|(
name|optionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|d
operator|->
name|nameHash
operator|.
name|cend
argument_list|()
condition|)
block|{
specifier|const
name|int
name|optionOffset
init|=
operator|*
name|it
decl_stmt|;
name|QStringList
name|values
init|=
name|d
operator|->
name|optionValuesHash
operator|.
name|value
argument_list|(
name|optionOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
name|values
operator|=
name|d
operator|->
name|commandLineOptionList
operator|.
name|at
argument_list|(
name|optionOffset
argument_list|)
operator|.
name|defaultValues
argument_list|()
expr_stmt|;
return|return
name|values
return|;
block|}
name|qWarning
argument_list|(
literal|"QCommandLineParser: option not defined: \"%s\""
argument_list|,
name|qPrintable
argument_list|(
name|optionName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QStringList
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Checks whether the \a option was passed to the application.      Returns \c true if the \a option was set, false otherwise.      This is the recommended way to check for options with no values.      Example:     \snippet code/src_corelib_tools_qcommandlineparser.cpp 1 */
end_comment
begin_function
DECL|function|isSet
name|bool
name|QCommandLineParser
operator|::
name|isSet
parameter_list|(
specifier|const
name|QCommandLineOption
modifier|&
name|option
parameter_list|)
specifier|const
block|{
comment|// option.names() might be empty if the constructor failed
return|return
operator|!
name|option
operator|.
name|names
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|isSet
argument_list|(
name|option
operator|.
name|names
argument_list|()
operator|.
name|first
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Returns the option value found for the given \a option, or     an empty string if not found.      For options found by the parser, the last value found for     that option is returned. If the option wasn't specified on the command line,     the default value is returned.      An empty string is returned if the option does not take a value.      \sa values(), QCommandLineOption::setDefaultValue(), QCommandLineOption::setDefaultValues() */
end_comment
begin_function
DECL|function|value
name|QString
name|QCommandLineParser
operator|::
name|value
parameter_list|(
specifier|const
name|QCommandLineOption
modifier|&
name|option
parameter_list|)
specifier|const
block|{
return|return
name|value
argument_list|(
name|option
operator|.
name|names
argument_list|()
operator|.
name|first
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     Returns a list of option values found for the given \a option,     or an empty list if not found.      For options found by the parser, the list will contain an entry for     each time the option was encountered by the parser. If the option wasn't     specified on the command line, the default values are returned.      An empty list is returned if the option does not take a value.      \sa value(), QCommandLineOption::setDefaultValue(), QCommandLineOption::setDefaultValues() */
end_comment
begin_function
DECL|function|values
name|QStringList
name|QCommandLineParser
operator|::
name|values
parameter_list|(
specifier|const
name|QCommandLineOption
modifier|&
name|option
parameter_list|)
specifier|const
block|{
return|return
name|values
argument_list|(
name|option
operator|.
name|names
argument_list|()
operator|.
name|first
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of positional arguments.      These are all of the arguments that were not recognized as part of an     option.  */
end_comment
begin_function
DECL|function|positionalArguments
name|QStringList
name|QCommandLineParser
operator|::
name|positionalArguments
parameter_list|()
specifier|const
block|{
name|d
operator|->
name|checkParsed
argument_list|(
literal|"positionalArguments"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|positionalArgumentList
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of option names that were found.      This returns a list of all the recognized option names found by the     parser, in the order in which they were found. For any long options     that were in the form {--option=value}, the value part will have been     dropped.      The names in this list do not include the preceding dash characters.     Names may appear more than once in this list if they were encountered     more than once by the parser.      Any entry in the list can be used with \c value() or with     \c values() to get any relevant option values.  */
end_comment
begin_function
DECL|function|optionNames
name|QStringList
name|QCommandLineParser
operator|::
name|optionNames
parameter_list|()
specifier|const
block|{
name|d
operator|->
name|checkParsed
argument_list|(
literal|"optionNames"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|optionNames
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of unknown option names.      This list will include both long an short name options that were not     recognized. For any long options that were in the form {--option=value},     the value part will have been dropped and only the long name is added.      The names in this list do not include the preceding dash characters.     Names may appear more than once in this list if they were encountered     more than once by the parser.      \sa optionNames()  */
end_comment
begin_function
DECL|function|unknownOptionNames
name|QStringList
name|QCommandLineParser
operator|::
name|unknownOptionNames
parameter_list|()
specifier|const
block|{
name|d
operator|->
name|checkParsed
argument_list|(
literal|"unknownOptionNames"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|unknownOptionNames
return|;
block|}
end_function
begin_comment
comment|/*!     Displays the version information from QCoreApplication::applicationVersion(),     and exits the application.     This is automatically triggered by the --version option, but can also     be used to display the version when not using process().     The exit code is set to EXIT_SUCCESS (0).      \sa addVersionOption()     \since 5.4 */
end_comment
begin_function
DECL|function|showVersion
name|Q_NORETURN
name|void
name|QCommandLineParser
operator|::
name|showVersion
parameter_list|()
block|{
name|showParserMessage
argument_list|(
name|QCoreApplication
operator|::
name|applicationName
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|QCoreApplication
operator|::
name|applicationVersion
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|,
name|UsageMessage
argument_list|)
expr_stmt|;
operator|::
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Displays the help information, and exits the application.     This is automatically triggered by the --help option, but can also     be used to display the help when the user is not invoking the     application correctly.     The exit code is set to \a exitCode. It should be set to 0 if the     user requested to see the help, and to any other value in case of     an error.      \sa helpText() */
end_comment
begin_function
DECL|function|showHelp
name|Q_NORETURN
name|void
name|QCommandLineParser
operator|::
name|showHelp
parameter_list|(
name|int
name|exitCode
parameter_list|)
block|{
name|showParserMessage
argument_list|(
name|d
operator|->
name|helpText
argument_list|()
argument_list|,
name|UsageMessage
argument_list|)
expr_stmt|;
operator|::
name|exit
argument_list|(
name|exitCode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a string containing the complete help information.      \sa showHelp() */
end_comment
begin_function
DECL|function|helpText
name|QString
name|QCommandLineParser
operator|::
name|helpText
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|helpText
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|wrapText
specifier|static
name|QString
name|wrapText
parameter_list|(
specifier|const
name|QString
modifier|&
name|names
parameter_list|,
name|int
name|longestOptionNameString
parameter_list|,
specifier|const
name|QString
modifier|&
name|description
parameter_list|)
block|{
specifier|const
name|QLatin1Char
name|nl
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
name|QString
name|text
init|=
name|QStringLiteral
argument_list|(
literal|"  "
argument_list|)
operator|+
name|names
operator|.
name|leftJustified
argument_list|(
name|longestOptionNameString
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
specifier|const
name|int
name|indent
init|=
name|text
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|lineStart
init|=
literal|0
decl_stmt|;
name|int
name|lastBreakable
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|int
name|max
init|=
literal|79
operator|-
name|indent
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|len
init|=
name|description
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
operator|++
name|x
expr_stmt|;
specifier|const
name|QChar
name|c
init|=
name|description
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|isSpace
argument_list|()
condition|)
name|lastBreakable
operator|=
name|i
expr_stmt|;
name|int
name|breakAt
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|nextLineStart
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|x
operator|>
name|max
operator|&&
name|lastBreakable
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// time to break and we know where
name|breakAt
operator|=
name|lastBreakable
expr_stmt|;
name|nextLineStart
operator|=
name|lastBreakable
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|>
name|max
operator|-
literal|1
operator|&&
name|lastBreakable
operator|==
operator|-
literal|1
operator|)
operator|||
name|i
operator|==
name|len
operator|-
literal|1
condition|)
block|{
comment|// time to break but found nowhere [-> break here], or end of last line
name|breakAt
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|nextLineStart
operator|=
name|breakAt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|nl
condition|)
block|{
comment|// forced break
name|breakAt
operator|=
name|i
expr_stmt|;
name|nextLineStart
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|breakAt
operator|!=
operator|-
literal|1
condition|)
block|{
specifier|const
name|int
name|numChars
init|=
name|breakAt
operator|-
name|lineStart
decl_stmt|;
comment|//qDebug()<< "breakAt="<< description.at(breakAt)<< "breakAtSpace="<< breakAtSpace<< lineStart<< "to"<< breakAt<< description.mid(lineStart, numChars);
if|if
condition|(
name|lineStart
operator|>
literal|0
condition|)
name|text
operator|+=
name|QString
argument_list|(
name|indent
argument_list|,
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|+=
name|description
operator|.
name|midRef
argument_list|(
name|lineStart
argument_list|,
name|numChars
argument_list|)
operator|+
name|nl
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
name|lastBreakable
operator|=
operator|-
literal|1
expr_stmt|;
name|lineStart
operator|=
name|nextLineStart
expr_stmt|;
if|if
condition|(
name|lineStart
operator|<
name|len
operator|&&
name|description
operator|.
name|at
argument_list|(
name|lineStart
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
operator|++
name|lineStart
expr_stmt|;
comment|// don't start a line with a space
name|i
operator|=
name|lineStart
expr_stmt|;
block|}
block|}
return|return
name|text
return|;
block|}
end_function
begin_function
DECL|function|helpText
name|QString
name|QCommandLineParserPrivate
operator|::
name|helpText
parameter_list|()
specifier|const
block|{
specifier|const
name|QLatin1Char
name|nl
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
name|QString
name|text
decl_stmt|;
name|QString
name|usage
decl_stmt|;
name|usage
operator|+=
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|->
name|arguments
argument_list|()
operator|.
name|constFirst
argument_list|()
expr_stmt|;
comment|// executable name
if|if
condition|(
operator|!
name|commandLineOptionList
operator|.
name|isEmpty
argument_list|()
condition|)
name|usage
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|QCommandLineParser
operator|::
name|tr
argument_list|(
literal|"[options]"
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
name|PositionalArgumentDefinition
modifier|&
name|arg
range|:
name|positionalArgumentDefinitions
control|)
name|usage
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|+
name|arg
operator|.
name|syntax
expr_stmt|;
name|text
operator|+=
name|QCommandLineParser
operator|::
name|tr
argument_list|(
literal|"Usage: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|usage
argument_list|)
operator|+
name|nl
expr_stmt|;
if|if
condition|(
operator|!
name|description
operator|.
name|isEmpty
argument_list|()
condition|)
name|text
operator|+=
name|description
operator|+
name|nl
expr_stmt|;
name|text
operator|+=
name|nl
expr_stmt|;
if|if
condition|(
operator|!
name|commandLineOptionList
operator|.
name|isEmpty
argument_list|()
condition|)
name|text
operator|+=
name|QCommandLineParser
operator|::
name|tr
argument_list|(
literal|"Options:"
argument_list|)
operator|+
name|nl
expr_stmt|;
name|QStringList
name|optionNameList
decl_stmt|;
name|optionNameList
operator|.
name|reserve
argument_list|(
name|commandLineOptionList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|longestOptionNameString
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|const
name|QCommandLineOption
modifier|&
name|option
range|:
name|commandLineOptionList
control|)
block|{
if|if
condition|(
name|option
operator|.
name|isHidden
argument_list|()
condition|)
continue|continue;
specifier|const
name|QStringList
name|optionNames
init|=
name|option
operator|.
name|names
argument_list|()
decl_stmt|;
name|QString
name|optionNamesString
decl_stmt|;
for|for
control|(
specifier|const
name|QString
modifier|&
name|optionName
range|:
name|optionNames
control|)
block|{
specifier|const
name|int
name|numDashes
init|=
name|optionName
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|?
literal|1
else|:
literal|2
decl_stmt|;
name|optionNamesString
operator|+=
name|QLatin1String
argument_list|(
literal|"--"
argument_list|,
name|numDashes
argument_list|)
operator|+
name|optionName
operator|+
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|optionNames
operator|.
name|isEmpty
argument_list|()
condition|)
name|optionNamesString
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|// remove trailing ", "
specifier|const
specifier|auto
name|valueName
init|=
name|option
operator|.
name|valueName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|valueName
operator|.
name|isEmpty
argument_list|()
condition|)
name|optionNamesString
operator|+=
name|QLatin1String
argument_list|(
literal|"<"
argument_list|)
operator|+
name|valueName
operator|+
name|QLatin1Char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|optionNameList
operator|.
name|append
argument_list|(
name|optionNamesString
argument_list|)
expr_stmt|;
name|longestOptionNameString
operator|=
name|qMax
argument_list|(
name|longestOptionNameString
argument_list|,
name|optionNamesString
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|++
name|longestOptionNameString
expr_stmt|;
name|auto
name|optionNameIterator
init|=
name|optionNameList
operator|.
name|cbegin
argument_list|()
decl_stmt|;
for|for
control|(
specifier|const
name|QCommandLineOption
modifier|&
name|option
range|:
name|commandLineOptionList
control|)
block|{
if|if
condition|(
name|option
operator|.
name|isHidden
argument_list|()
condition|)
continue|continue;
name|text
operator|+=
name|wrapText
argument_list|(
operator|*
name|optionNameIterator
argument_list|,
name|longestOptionNameString
argument_list|,
name|option
operator|.
name|description
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|optionNameIterator
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|positionalArgumentDefinitions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|commandLineOptionList
operator|.
name|isEmpty
argument_list|()
condition|)
name|text
operator|+=
name|nl
expr_stmt|;
name|text
operator|+=
name|QCommandLineParser
operator|::
name|tr
argument_list|(
literal|"Arguments:"
argument_list|)
operator|+
name|nl
expr_stmt|;
for|for
control|(
specifier|const
name|PositionalArgumentDefinition
modifier|&
name|arg
range|:
name|positionalArgumentDefinitions
control|)
name|text
operator|+=
name|wrapText
argument_list|(
name|arg
operator|.
name|name
argument_list|,
name|longestOptionNameString
argument_list|,
name|arg
operator|.
name|description
argument_list|)
expr_stmt|;
block|}
return|return
name|text
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
