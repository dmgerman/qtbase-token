begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*  | *property* | *Used for type* | | period     | QEasingCurve::{In,Out,InOut,OutIn}Elastic | | amplitude  | QEasingCurve::{In,Out,InOut,OutIn}Bounce, QEasingCurve::{In,Out,InOut,OutIn}Elastic | | overshoot  | QEasingCurve::{In,Out,InOut,OutIn}Back   |  */
end_comment
begin_comment
comment|/*!     \class QEasingCurve     \inmodule QtCore     \since 4.6     \ingroup animation     \brief The QEasingCurve class provides easing curves for controlling animation.      Easing curves describe a function that controls how the speed of the interpolation     between 0 and 1 should be. Easing curves allow transitions from     one value to another to appear more natural than a simple constant speed would allow.     The QEasingCurve class is usually used in conjunction with the QVariantAnimation and     QPropertyAnimation classes but can be used on its own. It is usually used to accelerate     the interpolation from zero velocity (ease in) or decelerate to zero velocity (ease out).     Ease in and ease out can also be combined in the same easing curve.      To calculate the speed of the interpolation, the easing curve provides the function     valueForProgress(), where the \a progress argument specifies the progress of the     interpolation: 0 is the start value of the interpolation, 1 is the end value of the     interpolation. The returned value is the effective progress of the interpolation.     If the returned value is the same as the input value for all input values the easing     curve is a linear curve. This is the default behaviour.      For example,     \code     QEasingCurve easing(QEasingCurve::InOutQuad);      for(qreal t = 0.0; t< 1.0; t+=0.1)         qWarning()<< "Effective progress"<< t<< " is<< easing.valueForProgress(t);     \endcode     will print the effective progress of the interpolation between 0 and 1.      When using a QPropertyAnimation, the associated easing curve will be used to control the     progress of the interpolation between startValue and endValue:     \code     QPropertyAnimation animation;     animation.setStartValue(0);     animation.setEndValue(1000);     animation.setDuration(1000);     animation.setEasingCurve(QEasingCurve::InOutQuad);     \endcode      The ability to set an amplitude, overshoot, or period depends on     the QEasingCurve type. Amplitude access is available to curves     that behave as springs such as elastic and bounce curves. Changing     the amplitude changes the height of the curve. Period access is     only available to elastic curves and setting a higher period slows     the rate of bounce. Only curves that have "boomerang" behaviors     such as the InBack, OutBack, InOutBack, and OutInBack have     overshoot settings. These curves will interpolate beyond the end     points and return to the end point, acting similar to a boomerang.      The \l{Easing Curves Example} contains samples of QEasingCurve     types and lets you change the curve settings.   */
end_comment
begin_comment
comment|/*!     \enum QEasingCurve::Type      The type of easing curve.      \value Linear       \image qeasingcurve-linear.png                         \caption Easing curve for a linear (t) function:                         velocity is constant.     \value InQuad       \image qeasingcurve-inquad.png                         \caption Easing curve for a quadratic (t^2) function:                         accelerating from zero velocity.     \value OutQuad      \image qeasingcurve-outquad.png                         \caption Easing curve for a quadratic (t^2) function:                         decelerating to zero velocity.     \value InOutQuad    \image qeasingcurve-inoutquad.png                         \caption Easing curve for a quadratic (t^2) function:                         acceleration until halfway, then deceleration.     \value OutInQuad    \image qeasingcurve-outinquad.png                         \caption Easing curve for a quadratic (t^2) function:                         deceleration until halfway, then acceleration.     \value InCubic      \image qeasingcurve-incubic.png                         \caption Easing curve for a cubic (t^3) function:                         accelerating from zero velocity.     \value OutCubic     \image qeasingcurve-outcubic.png                         \caption Easing curve for a cubic (t^3) function:                         decelerating to zero velocity.     \value InOutCubic   \image qeasingcurve-inoutcubic.png                         \caption Easing curve for a cubic (t^3) function:                         acceleration until halfway, then deceleration.     \value OutInCubic   \image qeasingcurve-outincubic.png                         \caption Easing curve for a cubic (t^3) function:                         deceleration until halfway, then acceleration.     \value InQuart      \image qeasingcurve-inquart.png                         \caption Easing curve for a quartic (t^4) function:                         accelerating from zero velocity.     \value OutQuart     \image qeasingcurve-outquart.png                         \caption                         Easing curve for a quartic (t^4) function:                         decelerating to zero velocity.     \value InOutQuart   \image qeasingcurve-inoutquart.png                         \caption                         Easing curve for a quartic (t^4) function:                         acceleration until halfway, then deceleration.     \value OutInQuart   \image qeasingcurve-outinquart.png                         \caption                         Easing curve for a quartic (t^4) function:                         deceleration until halfway, then acceleration.     \value InQuint      \image qeasingcurve-inquint.png                         \caption                         Easing curve for a quintic (t^5) easing                         in: accelerating from zero velocity.     \value OutQuint     \image qeasingcurve-outquint.png                         \caption                         Easing curve for a quintic (t^5) function:                         decelerating to zero velocity.     \value InOutQuint   \image qeasingcurve-inoutquint.png                         \caption                         Easing curve for a quintic (t^5) function:                         acceleration until halfway, then deceleration.     \value OutInQuint   \image qeasingcurve-outinquint.png                         \caption                         Easing curve for a quintic (t^5) function:                         deceleration until halfway, then acceleration.     \value InSine       \image qeasingcurve-insine.png                         \caption                         Easing curve for a sinusoidal (sin(t)) function:                         accelerating from zero velocity.     \value OutSine      \image qeasingcurve-outsine.png                         \caption                         Easing curve for a sinusoidal (sin(t)) function:                         decelerating from zero velocity.     \value InOutSine    \image qeasingcurve-inoutsine.png                         \caption                         Easing curve for a sinusoidal (sin(t)) function:                         acceleration until halfway, then deceleration.     \value OutInSine    \image qeasingcurve-outinsine.png                         \caption                         Easing curve for a sinusoidal (sin(t)) function:                         deceleration until halfway, then acceleration.     \value InExpo       \image qeasingcurve-inexpo.png                         \caption                         Easing curve for an exponential (2^t) function:                         accelerating from zero velocity.     \value OutExpo      \image qeasingcurve-outexpo.png                         \caption                         Easing curve for an exponential (2^t) function:                         decelerating from zero velocity.     \value InOutExpo    \image qeasingcurve-inoutexpo.png                         \caption                         Easing curve for an exponential (2^t) function:                         acceleration until halfway, then deceleration.     \value OutInExpo    \image qeasingcurve-outinexpo.png                         \caption                         Easing curve for an exponential (2^t) function:                         deceleration until halfway, then acceleration.     \value InCirc       \image qeasingcurve-incirc.png                         \caption                         Easing curve for a circular (sqrt(1-t^2)) function:                         accelerating from zero velocity.     \value OutCirc      \image qeasingcurve-outcirc.png                         \caption                         Easing curve for a circular (sqrt(1-t^2)) function:                         decelerating from zero velocity.     \value InOutCirc    \image qeasingcurve-inoutcirc.png                         \caption                         Easing curve for a circular (sqrt(1-t^2)) function:                         acceleration until halfway, then deceleration.     \value OutInCirc    \image qeasingcurve-outincirc.png                         \caption                         Easing curve for a circular (sqrt(1-t^2)) function:                         deceleration until halfway, then acceleration.     \value InElastic    \image qeasingcurve-inelastic.png                         \caption                         Easing curve for an elastic                         (exponentially decaying sine wave) function:                         accelerating from zero velocity.  The peak amplitude                         can be set with the \e amplitude parameter, and the                         period of decay by the \e period parameter.     \value OutElastic   \image qeasingcurve-outelastic.png                         \caption                         Easing curve for an elastic                         (exponentially decaying sine wave) function:                         decelerating from zero velocity.  The peak amplitude                         can be set with the \e amplitude parameter, and the                         period of decay by the \e period parameter.     \value InOutElastic \image qeasingcurve-inoutelastic.png                         \caption                         Easing curve for an elastic                         (exponentially decaying sine wave) function:                         acceleration until halfway, then deceleration.     \value OutInElastic \image qeasingcurve-outinelastic.png                         \caption                         Easing curve for an elastic                         (exponentially decaying sine wave) function:                         deceleration until halfway, then acceleration.     \value InBack       \image qeasingcurve-inback.png                         \caption                         Easing curve for a back (overshooting                         cubic function: (s+1)*t^3 - s*t^2) easing in:                         accelerating from zero velocity.     \value OutBack      \image qeasingcurve-outback.png                         \caption                         Easing curve for a back (overshooting                         cubic function: (s+1)*t^3 - s*t^2) easing out:                         decelerating to zero velocity.     \value InOutBack    \image qeasingcurve-inoutback.png                         \caption                         Easing curve for a back (overshooting                         cubic function: (s+1)*t^3 - s*t^2) easing in/out:                         acceleration until halfway, then deceleration.     \value OutInBack    \image qeasingcurve-outinback.png                         \caption                         Easing curve for a back (overshooting                         cubic easing: (s+1)*t^3 - s*t^2) easing out/in:                         deceleration until halfway, then acceleration.     \value InBounce     \image qeasingcurve-inbounce.png                         \caption                         Easing curve for a bounce (exponentially                         decaying parabolic bounce) function: accelerating                         from zero velocity.     \value OutBounce    \image qeasingcurve-outbounce.png                         \caption                         Easing curve for a bounce (exponentially                         decaying parabolic bounce) function: decelerating                         from zero velocity.     \value InOutBounce  \image qeasingcurve-inoutbounce.png                         \caption                         Easing curve for a bounce (exponentially                         decaying parabolic bounce) function easing in/out:                         acceleration until halfway, then deceleration.     \value OutInBounce  \image qeasingcurve-outinbounce.png                         \caption                         Easing curve for a bounce (exponentially                         decaying parabolic bounce) function easing out/in:                         deceleration until halfway, then acceleration.     \omitvalue InCurve     \omitvalue OutCurve     \omitvalue SineCurve     \omitvalue CosineCurve     \value BezierSpline Allows defining a custom easing curve using a cubic bezier spline                         \sa addCubicBezierSegment()     \value TCBSpline    Allows defining a custom easing curve using a TCB spline                         \sa addTCBSegment()     \value Custom       This is returned if the user specified a custom curve type with                         setCustomType(). Note that you cannot call setType() with this value,                         but type() can return it.     \omitvalue NCurveTypes */
end_comment
begin_comment
comment|/*!     \typedef QEasingCurve::EasingFunction      This is a typedef for a pointer to a function with the following     signature:      \snippet code/src_corelib_tools_qeasingcurve.cpp 0 */
end_comment
begin_include
include|#
directive|include
file|"qeasingcurve.h"
end_include
begin_include
include|#
directive|include
file|<cmath>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qstring.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_include
include|#
directive|include
file|<QtCore/qdatastream.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QtCore/qpoint.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvector.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|isConfigFunction
specifier|static
name|bool
name|isConfigFunction
parameter_list|(
name|QEasingCurve
operator|::
name|Type
name|type
parameter_list|)
block|{
return|return
operator|(
name|type
operator|>=
name|QEasingCurve
operator|::
name|InElastic
operator|&&
name|type
operator|<=
name|QEasingCurve
operator|::
name|OutInBounce
operator|)
operator|||
name|type
operator|==
name|QEasingCurve
operator|::
name|BezierSpline
operator|||
name|type
operator|==
name|QEasingCurve
operator|::
name|TCBSpline
return|;
block|}
end_function
begin_struct
DECL|struct|TCBPoint
struct|struct
name|TCBPoint
block|{
DECL|member|_point
name|QPointF
name|_point
decl_stmt|;
DECL|member|_t
name|qreal
name|_t
decl_stmt|;
DECL|member|_c
name|qreal
name|_c
decl_stmt|;
DECL|member|_b
name|qreal
name|_b
decl_stmt|;
DECL|function|TCBPoint
name|TCBPoint
parameter_list|()
block|{}
DECL|function|TCBPoint
name|TCBPoint
parameter_list|(
name|QPointF
name|point
parameter_list|,
name|qreal
name|t
parameter_list|,
name|qreal
name|c
parameter_list|,
name|qreal
name|b
parameter_list|)
member_init_list|:
name|_point
argument_list|(
name|point
argument_list|)
member_init_list|,
name|_t
argument_list|(
name|t
argument_list|)
member_init_list|,
name|_c
argument_list|(
name|c
argument_list|)
member_init_list|,
name|_b
argument_list|(
name|b
argument_list|)
block|{}
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|TCBPoint
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|_point
operator|==
name|other
operator|.
name|_point
operator|&&
name|qFuzzyCompare
argument_list|(
name|_t
argument_list|,
name|other
operator|.
name|_t
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|_c
argument_list|,
name|other
operator|.
name|_c
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|_b
argument_list|,
name|other
operator|.
name|_b
argument_list|)
return|;
block|}
block|}
struct|;
end_struct
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|TCBPoint
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_typedef
DECL|typedef|TCBPoints
typedef|typedef
name|QVector
argument_list|<
name|TCBPoint
argument_list|>
name|TCBPoints
typedef|;
end_typedef
begin_class
DECL|class|QEasingCurveFunction
class|class
name|QEasingCurveFunction
block|{
public|public:
DECL|function|QEasingCurveFunction
name|QEasingCurveFunction
parameter_list|(
name|QEasingCurve
operator|::
name|Type
name|type
parameter_list|,
name|qreal
name|period
init|=
literal|0.3
parameter_list|,
name|qreal
name|amplitude
init|=
literal|1.0
parameter_list|,
name|qreal
name|overshoot
init|=
literal|1.70158
parameter_list|)
member_init_list|:
name|_t
argument_list|(
name|type
argument_list|)
member_init_list|,
name|_p
argument_list|(
name|period
argument_list|)
member_init_list|,
name|_a
argument_list|(
name|amplitude
argument_list|)
member_init_list|,
name|_o
argument_list|(
name|overshoot
argument_list|)
block|{ }
DECL|function|~QEasingCurveFunction
specifier|virtual
name|~
name|QEasingCurveFunction
parameter_list|()
block|{}
specifier|virtual
name|qreal
name|value
parameter_list|(
name|qreal
name|t
parameter_list|)
function_decl|;
specifier|virtual
name|QEasingCurveFunction
modifier|*
name|copy
parameter_list|()
specifier|const
function_decl|;
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QEasingCurveFunction
modifier|&
name|other
parameter_list|)
specifier|const
function_decl|;
DECL|member|_t
name|QEasingCurve
operator|::
name|Type
name|_t
decl_stmt|;
DECL|member|_p
name|qreal
name|_p
decl_stmt|;
DECL|member|_a
name|qreal
name|_a
decl_stmt|;
DECL|member|_o
name|qreal
name|_o
decl_stmt|;
DECL|member|_bezierCurves
name|QVector
argument_list|<
name|QPointF
argument_list|>
name|_bezierCurves
decl_stmt|;
DECL|member|_tcbPoints
name|TCBPoints
name|_tcbPoints
decl_stmt|;
block|}
class|;
end_class
begin_function_decl
specifier|static
name|QEasingCurve
operator|::
name|EasingFunction
name|curveToFunc
parameter_list|(
name|QEasingCurve
operator|::
name|Type
name|curve
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|value
name|qreal
name|QEasingCurveFunction
operator|::
name|value
parameter_list|(
name|qreal
name|t
parameter_list|)
block|{
name|QEasingCurve
operator|::
name|EasingFunction
name|func
init|=
name|curveToFunc
argument_list|(
name|_t
argument_list|)
decl_stmt|;
return|return
name|func
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|copy
name|QEasingCurveFunction
modifier|*
name|QEasingCurveFunction
operator|::
name|copy
parameter_list|()
specifier|const
block|{
name|QEasingCurveFunction
modifier|*
name|rv
init|=
operator|new
name|QEasingCurveFunction
argument_list|(
name|_t
argument_list|,
name|_p
argument_list|,
name|_a
argument_list|,
name|_o
argument_list|)
decl_stmt|;
name|rv
operator|->
name|_bezierCurves
operator|=
name|_bezierCurves
expr_stmt|;
name|rv
operator|->
name|_tcbPoints
operator|=
name|_tcbPoints
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function
begin_function
DECL|function|operator ==
name|bool
name|QEasingCurveFunction
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QEasingCurveFunction
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|_t
operator|==
name|other
operator|.
name|_t
operator|&&
name|qFuzzyCompare
argument_list|(
name|_p
argument_list|,
name|other
operator|.
name|_p
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|_a
argument_list|,
name|other
operator|.
name|_a
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|_o
argument_list|,
name|other
operator|.
name|_o
argument_list|)
operator|&&
name|_bezierCurves
operator|==
name|other
operator|.
name|_bezierCurves
operator|&&
name|_tcbPoints
operator|==
name|other
operator|.
name|_tcbPoints
return|;
block|}
end_function
begin_expr_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|"../../3rdparty/easing/easing.cpp"
name|QT_END_INCLUDE_NAMESPACE
DECL|class|QEasingCurvePrivate
name|class
name|QEasingCurvePrivate
block|{
specifier|public
operator|:
DECL|function|QEasingCurvePrivate
name|QEasingCurvePrivate
argument_list|()
operator|:
name|type
argument_list|(
name|QEasingCurve
operator|::
name|Linear
argument_list|)
block|,
name|config
argument_list|(
literal|0
argument_list|)
block|,
name|func
argument_list|(
argument|&easeNone
argument_list|)
block|{ }
DECL|function|QEasingCurvePrivate
name|QEasingCurvePrivate
argument_list|(
specifier|const
name|QEasingCurvePrivate
operator|&
name|other
argument_list|)
operator|:
name|type
argument_list|(
name|other
operator|.
name|type
argument_list|)
block|,
name|config
argument_list|(
name|other
operator|.
name|config
operator|?
name|other
operator|.
name|config
operator|->
name|copy
argument_list|()
operator|:
literal|0
argument_list|)
block|,
name|func
argument_list|(
argument|other.func
argument_list|)
block|{ }
DECL|function|~QEasingCurvePrivate
operator|~
name|QEasingCurvePrivate
argument_list|()
block|{
operator|delete
name|config
block|; }
name|void
name|setType_helper
argument_list|(
name|QEasingCurve
operator|::
name|Type
argument_list|)
block|;
DECL|member|type
name|QEasingCurve
operator|::
name|Type
name|type
block|;
DECL|member|config
name|QEasingCurveFunction
operator|*
name|config
block|;
DECL|member|func
name|QEasingCurve
operator|::
name|EasingFunction
name|func
block|; }
expr_stmt|;
end_expr_stmt
begin_struct
DECL|struct|BezierEase
struct|struct
name|BezierEase
super|:
specifier|public
name|QEasingCurveFunction
block|{
DECL|struct|SingleCubicBezier
struct|struct
name|SingleCubicBezier
block|{
DECL|member|p0x
DECL|member|p0y
name|qreal
name|p0x
decl_stmt|,
name|p0y
decl_stmt|;
DECL|member|p1x
DECL|member|p1y
name|qreal
name|p1x
decl_stmt|,
name|p1y
decl_stmt|;
DECL|member|p2x
DECL|member|p2y
name|qreal
name|p2x
decl_stmt|,
name|p2y
decl_stmt|;
DECL|member|p3x
DECL|member|p3y
name|qreal
name|p3x
decl_stmt|,
name|p3y
decl_stmt|;
block|}
struct|;
DECL|member|_curves
name|QVector
argument_list|<
name|SingleCubicBezier
argument_list|>
name|_curves
decl_stmt|;
DECL|member|_intervals
name|QVector
argument_list|<
name|qreal
argument_list|>
name|_intervals
decl_stmt|;
DECL|member|_curveCount
name|int
name|_curveCount
decl_stmt|;
DECL|member|_init
name|bool
name|_init
decl_stmt|;
DECL|member|_valid
name|bool
name|_valid
decl_stmt|;
DECL|function|BezierEase
name|BezierEase
parameter_list|(
name|QEasingCurve
operator|::
name|Type
name|type
init|=
name|QEasingCurve
operator|::
name|BezierSpline
parameter_list|)
member_init_list|:
name|QEasingCurveFunction
argument_list|(
name|type
argument_list|)
member_init_list|,
name|_curves
argument_list|(
literal|10
argument_list|)
member_init_list|,
name|_intervals
argument_list|(
literal|10
argument_list|)
member_init_list|,
name|_init
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|_valid
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|init
name|void
name|init
parameter_list|()
block|{
if|if
condition|(
name|_bezierCurves
operator|.
name|last
argument_list|()
operator|==
name|QPointF
argument_list|(
literal|1.0
argument_list|,
literal|1.0
argument_list|)
condition|)
block|{
name|_init
operator|=
literal|true
expr_stmt|;
name|_curveCount
operator|=
name|_bezierCurves
operator|.
name|count
argument_list|()
operator|/
literal|3
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|_curveCount
condition|;
name|i
operator|++
control|)
block|{
name|_intervals
index|[
name|i
index|]
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|i
operator|*
literal|3
operator|+
literal|2
argument_list|)
operator|.
name|x
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|_curves
index|[
literal|0
index|]
operator|.
name|p0x
operator|=
literal|0.0
expr_stmt|;
name|_curves
index|[
literal|0
index|]
operator|.
name|p0y
operator|=
literal|0.0
expr_stmt|;
name|_curves
index|[
literal|0
index|]
operator|.
name|p1x
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|x
argument_list|()
expr_stmt|;
name|_curves
index|[
literal|0
index|]
operator|.
name|p1y
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|y
argument_list|()
expr_stmt|;
name|_curves
index|[
literal|0
index|]
operator|.
name|p2x
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|x
argument_list|()
expr_stmt|;
name|_curves
index|[
literal|0
index|]
operator|.
name|p2y
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|y
argument_list|()
expr_stmt|;
name|_curves
index|[
literal|0
index|]
operator|.
name|p3x
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|x
argument_list|()
expr_stmt|;
name|_curves
index|[
literal|0
index|]
operator|.
name|p3y
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
operator|(
name|_curveCount
operator|-
literal|1
operator|)
condition|)
block|{
name|_curves
index|[
name|i
index|]
operator|.
name|p0x
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|_bezierCurves
operator|.
name|count
argument_list|()
operator|-
literal|4
argument_list|)
operator|.
name|x
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p0y
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|_bezierCurves
operator|.
name|count
argument_list|()
operator|-
literal|4
argument_list|)
operator|.
name|y
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p1x
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|_bezierCurves
operator|.
name|count
argument_list|()
operator|-
literal|3
argument_list|)
operator|.
name|x
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p1y
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|_bezierCurves
operator|.
name|count
argument_list|()
operator|-
literal|3
argument_list|)
operator|.
name|y
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p2x
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|_bezierCurves
operator|.
name|count
argument_list|()
operator|-
literal|2
argument_list|)
operator|.
name|x
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p2y
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|_bezierCurves
operator|.
name|count
argument_list|()
operator|-
literal|2
argument_list|)
operator|.
name|y
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p3x
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|_bezierCurves
operator|.
name|count
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|x
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p3y
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|_bezierCurves
operator|.
name|count
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|_curves
index|[
name|i
index|]
operator|.
name|p0x
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|i
operator|*
literal|3
operator|-
literal|1
argument_list|)
operator|.
name|x
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p0y
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|i
operator|*
literal|3
operator|-
literal|1
argument_list|)
operator|.
name|y
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p1x
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|i
operator|*
literal|3
argument_list|)
operator|.
name|x
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p1y
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|i
operator|*
literal|3
argument_list|)
operator|.
name|y
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p2x
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|i
operator|*
literal|3
operator|+
literal|1
argument_list|)
operator|.
name|x
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p2y
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|i
operator|*
literal|3
operator|+
literal|1
argument_list|)
operator|.
name|y
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p3x
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|i
operator|*
literal|3
operator|+
literal|2
argument_list|)
operator|.
name|x
argument_list|()
expr_stmt|;
name|_curves
index|[
name|i
index|]
operator|.
name|p3y
operator|=
name|_bezierCurves
operator|.
name|at
argument_list|(
name|i
operator|*
literal|3
operator|+
literal|2
argument_list|)
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
block|}
name|_valid
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|_valid
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|QEasingCurveFunction
modifier|*
name|copy
parameter_list|()
specifier|const
name|Q_DECL_OVERRIDE
block|{
name|BezierEase
modifier|*
name|rv
init|=
operator|new
name|BezierEase
argument_list|()
decl_stmt|;
name|rv
operator|->
name|_t
operator|=
name|_t
expr_stmt|;
name|rv
operator|->
name|_p
operator|=
name|_p
expr_stmt|;
name|rv
operator|->
name|_a
operator|=
name|_a
expr_stmt|;
name|rv
operator|->
name|_o
operator|=
name|_o
expr_stmt|;
name|rv
operator|->
name|_bezierCurves
operator|=
name|_bezierCurves
expr_stmt|;
name|rv
operator|->
name|_tcbPoints
operator|=
name|_tcbPoints
expr_stmt|;
return|return
name|rv
return|;
block|}
DECL|function|getBezierSegment
name|void
name|getBezierSegment
parameter_list|(
name|SingleCubicBezier
modifier|*
modifier|&
name|singleCubicBezier
parameter_list|,
name|qreal
name|x
parameter_list|)
block|{
name|int
name|currentSegment
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|currentSegment
operator|<
name|_curveCount
condition|)
block|{
if|if
condition|(
name|x
operator|<=
name|_intervals
operator|.
name|data
argument_list|()
index|[
name|currentSegment
index|]
condition|)
break|break;
name|currentSegment
operator|++
expr_stmt|;
block|}
name|singleCubicBezier
operator|=
operator|&
name|_curves
operator|.
name|data
argument_list|()
index|[
name|currentSegment
index|]
expr_stmt|;
block|}
DECL|function|newtonIteration
name|qreal
specifier|static
specifier|inline
name|newtonIteration
parameter_list|(
specifier|const
name|SingleCubicBezier
modifier|&
name|singleCubicBezier
parameter_list|,
name|qreal
name|t
parameter_list|,
name|qreal
name|x
parameter_list|)
block|{
name|qreal
name|currentXValue
init|=
name|evaluateForX
argument_list|(
name|singleCubicBezier
argument_list|,
name|t
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|newT
init|=
name|t
operator|-
operator|(
name|currentXValue
operator|-
name|x
operator|)
operator|/
name|evaluateDerivateForX
argument_list|(
name|singleCubicBezier
argument_list|,
name|t
argument_list|)
decl_stmt|;
return|return
name|newT
return|;
block|}
name|qreal
name|value
parameter_list|(
name|qreal
name|x
parameter_list|)
name|Q_DECL_OVERRIDE
block|{
name|Q_ASSERT
argument_list|(
name|_bezierCurves
operator|.
name|count
argument_list|()
operator|%
literal|3
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bezierCurves
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|x
return|;
block|}
if|if
condition|(
operator|!
name|_init
condition|)
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|_valid
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEasingCurve: Invalid bezier curve"
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
name|SingleCubicBezier
modifier|*
name|singleCubicBezier
init|=
literal|0
decl_stmt|;
name|getBezierSegment
argument_list|(
name|singleCubicBezier
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|evaluateSegmentForY
argument_list|(
operator|*
name|singleCubicBezier
argument_list|,
name|findTForX
argument_list|(
operator|*
name|singleCubicBezier
argument_list|,
name|x
argument_list|)
argument_list|)
return|;
block|}
DECL|function|evaluateSegmentForY
name|qreal
specifier|static
specifier|inline
name|evaluateSegmentForY
parameter_list|(
specifier|const
name|SingleCubicBezier
modifier|&
name|singleCubicBezier
parameter_list|,
name|qreal
name|t
parameter_list|)
block|{
specifier|const
name|qreal
name|p0
init|=
name|singleCubicBezier
operator|.
name|p0y
decl_stmt|;
specifier|const
name|qreal
name|p1
init|=
name|singleCubicBezier
operator|.
name|p1y
decl_stmt|;
specifier|const
name|qreal
name|p2
init|=
name|singleCubicBezier
operator|.
name|p2y
decl_stmt|;
specifier|const
name|qreal
name|p3
init|=
name|singleCubicBezier
operator|.
name|p3y
decl_stmt|;
specifier|const
name|qreal
name|s
init|=
literal|1
operator|-
name|t
decl_stmt|;
specifier|const
name|qreal
name|s_squared
init|=
name|s
operator|*
name|s
decl_stmt|;
specifier|const
name|qreal
name|t_squared
init|=
name|t
operator|*
name|t
decl_stmt|;
specifier|const
name|qreal
name|s_cubic
init|=
name|s_squared
operator|*
name|s
decl_stmt|;
specifier|const
name|qreal
name|t_cubic
init|=
name|t_squared
operator|*
name|t
decl_stmt|;
return|return
name|s_cubic
operator|*
name|p0
operator|+
literal|3
operator|*
name|s_squared
operator|*
name|t
operator|*
name|p1
operator|+
literal|3
operator|*
name|s
operator|*
name|t_squared
operator|*
name|p2
operator|+
name|t_cubic
operator|*
name|p3
return|;
block|}
DECL|function|evaluateForX
name|qreal
specifier|static
specifier|inline
name|evaluateForX
parameter_list|(
specifier|const
name|SingleCubicBezier
modifier|&
name|singleCubicBezier
parameter_list|,
name|qreal
name|t
parameter_list|)
block|{
specifier|const
name|qreal
name|p0
init|=
name|singleCubicBezier
operator|.
name|p0x
decl_stmt|;
specifier|const
name|qreal
name|p1
init|=
name|singleCubicBezier
operator|.
name|p1x
decl_stmt|;
specifier|const
name|qreal
name|p2
init|=
name|singleCubicBezier
operator|.
name|p2x
decl_stmt|;
specifier|const
name|qreal
name|p3
init|=
name|singleCubicBezier
operator|.
name|p3x
decl_stmt|;
specifier|const
name|qreal
name|s
init|=
literal|1
operator|-
name|t
decl_stmt|;
specifier|const
name|qreal
name|s_squared
init|=
name|s
operator|*
name|s
decl_stmt|;
specifier|const
name|qreal
name|t_squared
init|=
name|t
operator|*
name|t
decl_stmt|;
specifier|const
name|qreal
name|s_cubic
init|=
name|s_squared
operator|*
name|s
decl_stmt|;
specifier|const
name|qreal
name|t_cubic
init|=
name|t_squared
operator|*
name|t
decl_stmt|;
return|return
name|s_cubic
operator|*
name|p0
operator|+
literal|3
operator|*
name|s_squared
operator|*
name|t
operator|*
name|p1
operator|+
literal|3
operator|*
name|s
operator|*
name|t_squared
operator|*
name|p2
operator|+
name|t_cubic
operator|*
name|p3
return|;
block|}
DECL|function|evaluateDerivateForX
name|qreal
specifier|static
specifier|inline
name|evaluateDerivateForX
parameter_list|(
specifier|const
name|SingleCubicBezier
modifier|&
name|singleCubicBezier
parameter_list|,
name|qreal
name|t
parameter_list|)
block|{
specifier|const
name|qreal
name|p0
init|=
name|singleCubicBezier
operator|.
name|p0x
decl_stmt|;
specifier|const
name|qreal
name|p1
init|=
name|singleCubicBezier
operator|.
name|p1x
decl_stmt|;
specifier|const
name|qreal
name|p2
init|=
name|singleCubicBezier
operator|.
name|p2x
decl_stmt|;
specifier|const
name|qreal
name|p3
init|=
name|singleCubicBezier
operator|.
name|p3x
decl_stmt|;
specifier|const
name|qreal
name|t_squared
init|=
name|t
operator|*
name|t
decl_stmt|;
return|return
operator|-
literal|3
operator|*
name|p0
operator|+
literal|3
operator|*
name|p1
operator|+
literal|6
operator|*
name|p0
operator|*
name|t
operator|-
literal|12
operator|*
name|p1
operator|*
name|t
operator|+
literal|6
operator|*
name|p2
operator|*
name|t
operator|+
literal|3
operator|*
name|p3
operator|*
name|t_squared
operator|-
literal|3
operator|*
name|p0
operator|*
name|t_squared
operator|+
literal|9
operator|*
name|p1
operator|*
name|t_squared
operator|-
literal|9
operator|*
name|p2
operator|*
name|t_squared
return|;
block|}
DECL|function|_cbrt
name|qreal
specifier|static
specifier|inline
name|_cbrt
parameter_list|(
name|qreal
name|d
parameter_list|)
block|{
name|qreal
name|sign
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|=
name|d
operator|*
name|sign
expr_stmt|;
name|qreal
name|t
init|=
name|_fast_cbrt
argument_list|(
name|d
argument_list|)
decl_stmt|;
comment|//one step of Halley's Method to get a better approximation
specifier|const
name|qreal
name|t_cubic
init|=
name|t
operator|*
name|t
operator|*
name|t
decl_stmt|;
specifier|const
name|qreal
name|f
init|=
name|t_cubic
operator|+
name|t_cubic
operator|+
name|d
decl_stmt|;
if|if
condition|(
name|f
operator|!=
name|qreal
argument_list|(
literal|0.0
argument_list|)
condition|)
name|t
operator|=
name|t
operator|*
operator|(
name|t_cubic
operator|+
name|d
operator|+
name|d
operator|)
operator|/
name|f
expr_stmt|;
comment|//another step
comment|/*qreal t_i = t;          t_i_cubic = pow(t_i, 3);          t = t_i * (t_i_cubic + d + d) / (t_i_cubic + t_i_cubic + d);*/
return|return
name|t
operator|*
name|sign
return|;
block|}
DECL|function|_fast_cbrt
name|float
specifier|static
specifier|inline
name|_fast_cbrt
parameter_list|(
name|float
name|x
parameter_list|)
block|{
union|union
block|{
name|float
name|f
decl_stmt|;
name|quint32
name|i
decl_stmt|;
block|}
name|ux
union|;
specifier|const
name|unsigned
name|int
name|B1
init|=
literal|709921077
decl_stmt|;
name|ux
operator|.
name|f
operator|=
name|x
expr_stmt|;
name|ux
operator|.
name|i
operator|=
operator|(
name|ux
operator|.
name|i
operator|/
literal|3
operator|+
name|B1
operator|)
expr_stmt|;
return|return
name|ux
operator|.
name|f
return|;
block|}
DECL|function|_fast_cbrt
name|double
specifier|static
specifier|inline
name|_fast_cbrt
parameter_list|(
name|double
name|d
parameter_list|)
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|quint32
name|pt
index|[
literal|2
index|]
decl_stmt|;
block|}
name|ut
union|,
name|ux
union|;
specifier|const
name|unsigned
name|int
name|B1
init|=
literal|715094163
decl_stmt|;
if|#
directive|if
name|Q_BYTE_ORDER
operator|==
name|Q_LITTLE_ENDIAN
specifier|const
name|int
name|h0
init|=
literal|1
decl_stmt|;
else|#
directive|else
specifier|const
name|int
name|h0
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|ut
operator|.
name|d
operator|=
literal|0.0
expr_stmt|;
name|ux
operator|.
name|d
operator|=
name|d
expr_stmt|;
name|quint32
name|hx
init|=
name|ux
operator|.
name|pt
index|[
name|h0
index|]
decl_stmt|;
comment|//high word of d
name|ut
operator|.
name|pt
index|[
name|h0
index|]
operator|=
name|hx
operator|/
literal|3
operator|+
name|B1
expr_stmt|;
return|return
name|ut
operator|.
name|d
return|;
block|}
DECL|function|_acos
name|qreal
specifier|static
specifier|inline
name|_acos
parameter_list|(
name|qreal
name|x
parameter_list|)
block|{
return|return
name|std
operator|::
name|sqrt
argument_list|(
literal|1
operator|-
name|x
argument_list|)
operator|*
operator|(
literal|1.5707963267948966192313216916398f
operator|+
name|x
operator|*
operator|(
operator|-
literal|0.213300989f
operator|+
name|x
operator|*
operator|(
literal|0.077980478f
operator|+
name|x
operator|*
operator|-
literal|0.02164095f
operator|)
operator|)
operator|)
return|;
block|}
DECL|function|_cos
name|qreal
specifier|static
specifier|inline
name|_cos
parameter_list|(
name|qreal
name|x
parameter_list|)
comment|//super fast _cos
block|{
specifier|const
name|qreal
name|pi_times2
init|=
literal|2
operator|*
name|M_PI
decl_stmt|;
specifier|const
name|qreal
name|pi_neg
init|=
operator|-
literal|1
operator|*
name|M_PI
decl_stmt|;
specifier|const
name|qreal
name|pi_by2
init|=
name|M_PI
operator|/
literal|2.0
decl_stmt|;
name|x
operator|+=
name|pi_by2
expr_stmt|;
comment|//the polynom is for sin
if|if
condition|(
name|x
operator|<
name|pi_neg
condition|)
name|x
operator|+=
name|pi_times2
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|>
name|M_PI
condition|)
name|x
operator|-=
name|pi_times2
expr_stmt|;
specifier|const
name|qreal
name|a
init|=
literal|0.405284735
decl_stmt|;
specifier|const
name|qreal
name|b
init|=
literal|1.27323954
decl_stmt|;
specifier|const
name|qreal
name|x_squared
init|=
name|x
operator|*
name|x
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|qreal
name|cos
init|=
name|b
operator|*
name|x
operator|+
name|a
operator|*
name|x_squared
decl_stmt|;
if|if
condition|(
name|cos
operator|<
literal|0
condition|)
return|return
literal|0.225
operator|*
operator|(
name|cos
operator|*
operator|-
literal|1
operator|*
name|cos
operator|-
name|cos
operator|)
operator|+
name|cos
return|;
return|return
literal|0.225
operator|*
operator|(
name|cos
operator|*
name|cos
operator|-
name|cos
operator|)
operator|+
name|cos
return|;
block|}
comment|//else
name|qreal
name|cos
init|=
name|b
operator|*
name|x
operator|-
name|a
operator|*
name|x_squared
decl_stmt|;
if|if
condition|(
name|cos
operator|<
literal|0
condition|)
return|return
literal|0.225
operator|*
operator|(
name|cos
operator|*
literal|1
operator|*
operator|-
name|cos
operator|-
name|cos
operator|)
operator|+
name|cos
return|;
return|return
literal|0.225
operator|*
operator|(
name|cos
operator|*
name|cos
operator|-
name|cos
operator|)
operator|+
name|cos
return|;
block|}
DECL|function|inRange
name|bool
specifier|static
specifier|inline
name|inRange
parameter_list|(
name|qreal
name|f
parameter_list|)
block|{
return|return
operator|(
name|f
operator|>=
operator|-
literal|0.01
operator|&&
name|f
operator|<=
literal|1.01
operator|)
return|;
block|}
DECL|function|cosacos
name|void
specifier|static
specifier|inline
name|cosacos
parameter_list|(
name|qreal
name|x
parameter_list|,
name|qreal
modifier|&
name|s1
parameter_list|,
name|qreal
modifier|&
name|s2
parameter_list|,
name|qreal
modifier|&
name|s3
parameter_list|)
block|{
comment|//This function has no proper algebraic representation in real numbers.
comment|//We use approximations instead
specifier|const
name|qreal
name|x_squared
init|=
name|x
operator|*
name|x
decl_stmt|;
specifier|const
name|qreal
name|x_plus_one_sqrt
init|=
name|qSqrt
argument_list|(
literal|1.0
operator|+
name|x
argument_list|)
decl_stmt|;
specifier|const
name|qreal
name|one_minus_x_sqrt
init|=
name|qSqrt
argument_list|(
literal|1.0
operator|-
name|x
argument_list|)
decl_stmt|;
comment|//cos(acos(x) / 3)
comment|//s1 = _cos(_acos(x) / 3);
name|s1
operator|=
literal|0.463614
operator|-
literal|0.0347815
operator|*
name|x
operator|+
literal|0.00218245
operator|*
name|x_squared
operator|+
literal|0.402421
operator|*
name|x_plus_one_sqrt
expr_stmt|;
comment|//cos(acos((x) -  M_PI) / 3)
comment|//s3 = _cos((_acos(x) - M_PI) / 3);
name|s3
operator|=
literal|0.463614
operator|+
literal|0.402421
operator|*
name|one_minus_x_sqrt
operator|+
literal|0.0347815
operator|*
name|x
operator|+
literal|0.00218245
operator|*
name|x_squared
expr_stmt|;
comment|//cos((acos(x) +  M_PI) / 3)
comment|//s2 = _cos((_acos(x) + M_PI) / 3);
name|s2
operator|=
operator|-
literal|0.401644
operator|*
name|one_minus_x_sqrt
operator|-
literal|0.0686804
operator|*
name|x
operator|+
literal|0.401644
operator|*
name|x_plus_one_sqrt
expr_stmt|;
block|}
DECL|function|singleRealSolutionForCubic
name|qreal
specifier|static
specifier|inline
name|singleRealSolutionForCubic
parameter_list|(
name|qreal
name|a
parameter_list|,
name|qreal
name|b
parameter_list|,
name|qreal
name|c
parameter_list|)
block|{
comment|//returns the real solutiuon in [0..1]
comment|//We use the Cardano formula
comment|//substituiton: x = z - a/3
comment|// z^3+pz+q=0
if|if
condition|(
name|c
argument_list|<
literal|0.000001
operator|&&
name|c
argument_list|>
operator|-
literal|0.000001
condition|)
return|return
literal|0
return|;
specifier|const
name|qreal
name|a_by3
init|=
name|a
operator|/
literal|3.0
decl_stmt|;
specifier|const
name|qreal
name|a_cubic
init|=
name|a
operator|*
name|a
operator|*
name|a
decl_stmt|;
specifier|const
name|qreal
name|p
init|=
name|b
operator|-
name|a
operator|*
name|a_by3
decl_stmt|;
specifier|const
name|qreal
name|q
init|=
literal|2.0
operator|*
name|a_cubic
operator|/
literal|27.0
operator|-
name|a
operator|*
name|b
operator|/
literal|3.0
operator|+
name|c
decl_stmt|;
specifier|const
name|qreal
name|q_squared
init|=
name|q
operator|*
name|q
decl_stmt|;
specifier|const
name|qreal
name|p_cubic
init|=
name|p
operator|*
name|p
operator|*
name|p
decl_stmt|;
specifier|const
name|qreal
name|D
init|=
literal|0.25
operator|*
name|q_squared
operator|+
name|p_cubic
operator|/
literal|27.0
decl_stmt|;
if|if
condition|(
name|D
operator|>=
literal|0
condition|)
block|{
specifier|const
name|qreal
name|D_sqrt
init|=
name|qSqrt
argument_list|(
name|D
argument_list|)
decl_stmt|;
name|qreal
name|u
init|=
name|_cbrt
argument_list|(
operator|-
name|q
operator|*
literal|0.5
operator|+
name|D_sqrt
argument_list|)
decl_stmt|;
name|qreal
name|v
init|=
name|_cbrt
argument_list|(
operator|-
name|q
operator|*
literal|0.5
operator|-
name|D_sqrt
argument_list|)
decl_stmt|;
name|qreal
name|z1
init|=
name|u
operator|+
name|v
decl_stmt|;
name|qreal
name|t1
init|=
name|z1
operator|-
name|a_by3
decl_stmt|;
if|if
condition|(
name|inRange
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t1
return|;
name|qreal
name|z2
init|=
operator|-
literal|1
operator|*
name|u
decl_stmt|;
name|qreal
name|t2
init|=
name|z2
operator|-
name|a_by3
decl_stmt|;
return|return
name|t2
return|;
block|}
comment|//casus irreducibilis
specifier|const
name|qreal
name|p_minus_sqrt
init|=
name|qSqrt
argument_list|(
operator|-
name|p
argument_list|)
decl_stmt|;
comment|//const qreal f = sqrt(4.0 / 3.0 * -p);
specifier|const
name|qreal
name|f
init|=
name|qSqrt
argument_list|(
literal|4.0
operator|/
literal|3.0
argument_list|)
operator|*
name|p_minus_sqrt
decl_stmt|;
comment|//const qreal sqrtP = sqrt(27.0 / -p_cubic);
specifier|const
name|qreal
name|sqrtP
init|=
operator|-
literal|3.0
operator|*
name|qSqrt
argument_list|(
literal|3.0
argument_list|)
operator|/
operator|(
name|p_minus_sqrt
operator|*
name|p
operator|)
decl_stmt|;
specifier|const
name|qreal
name|g
init|=
operator|-
name|q
operator|*
literal|0.5
operator|*
name|sqrtP
decl_stmt|;
name|qreal
name|s1
decl_stmt|;
name|qreal
name|s2
decl_stmt|;
name|qreal
name|s3
decl_stmt|;
name|cosacos
argument_list|(
name|g
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
name|qreal
name|z1
init|=
operator|-
literal|1
operator|*
name|f
operator|*
name|s2
decl_stmt|;
name|qreal
name|t1
init|=
name|z1
operator|-
name|a_by3
decl_stmt|;
if|if
condition|(
name|inRange
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t1
return|;
name|qreal
name|z2
init|=
name|f
operator|*
name|s1
decl_stmt|;
name|qreal
name|t2
init|=
name|z2
operator|-
name|a_by3
decl_stmt|;
if|if
condition|(
name|inRange
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|t2
return|;
name|qreal
name|z3
init|=
operator|-
literal|1
operator|*
name|f
operator|*
name|s3
decl_stmt|;
name|qreal
name|t3
init|=
name|z3
operator|-
name|a_by3
decl_stmt|;
return|return
name|t3
return|;
block|}
DECL|function|findTForX
name|qreal
specifier|static
specifier|inline
name|findTForX
parameter_list|(
specifier|const
name|SingleCubicBezier
modifier|&
name|singleCubicBezier
parameter_list|,
name|qreal
name|x
parameter_list|)
block|{
specifier|const
name|qreal
name|p0
init|=
name|singleCubicBezier
operator|.
name|p0x
decl_stmt|;
specifier|const
name|qreal
name|p1
init|=
name|singleCubicBezier
operator|.
name|p1x
decl_stmt|;
specifier|const
name|qreal
name|p2
init|=
name|singleCubicBezier
operator|.
name|p2x
decl_stmt|;
specifier|const
name|qreal
name|p3
init|=
name|singleCubicBezier
operator|.
name|p3x
decl_stmt|;
specifier|const
name|qreal
name|factorT3
init|=
name|p3
operator|-
name|p0
operator|+
literal|3
operator|*
name|p1
operator|-
literal|3
operator|*
name|p2
decl_stmt|;
specifier|const
name|qreal
name|factorT2
init|=
literal|3
operator|*
name|p0
operator|-
literal|6
operator|*
name|p1
operator|+
literal|3
operator|*
name|p2
decl_stmt|;
specifier|const
name|qreal
name|factorT1
init|=
operator|-
literal|3
operator|*
name|p0
operator|+
literal|3
operator|*
name|p1
decl_stmt|;
specifier|const
name|qreal
name|factorT0
init|=
name|p0
operator|-
name|x
decl_stmt|;
specifier|const
name|qreal
name|a
init|=
name|factorT2
operator|/
name|factorT3
decl_stmt|;
specifier|const
name|qreal
name|b
init|=
name|factorT1
operator|/
name|factorT3
decl_stmt|;
specifier|const
name|qreal
name|c
init|=
name|factorT0
operator|/
name|factorT3
decl_stmt|;
return|return
name|singleRealSolutionForCubic
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
return|;
comment|//one new iteration to increase numeric stability
comment|//return newtonIteration(singleCubicBezier, t, x);
block|}
block|}
struct|;
end_struct
begin_struct
DECL|struct|TCBEase
struct|struct
name|TCBEase
super|:
specifier|public
name|BezierEase
block|{
DECL|function|TCBEase
name|TCBEase
parameter_list|()
member_init_list|:
name|BezierEase
argument_list|(
name|QEasingCurve
operator|::
name|TCBSpline
argument_list|)
block|{ }
name|qreal
name|value
parameter_list|(
name|qreal
name|x
parameter_list|)
name|Q_DECL_OVERRIDE
block|{
name|Q_ASSERT
argument_list|(
name|_bezierCurves
operator|.
name|count
argument_list|()
operator|%
literal|3
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bezierCurves
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEasingCurve: Invalid tcb curve"
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
name|BezierEase
operator|::
name|value
argument_list|(
name|x
argument_list|)
return|;
block|}
block|}
struct|;
end_struct
begin_struct
DECL|struct|ElasticEase
struct|struct
name|ElasticEase
super|:
specifier|public
name|QEasingCurveFunction
block|{
DECL|function|ElasticEase
name|ElasticEase
parameter_list|(
name|QEasingCurve
operator|::
name|Type
name|type
parameter_list|)
member_init_list|:
name|QEasingCurveFunction
argument_list|(
name|type
argument_list|,
name|qreal
argument_list|(
literal|0.3
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|)
block|{ }
name|QEasingCurveFunction
modifier|*
name|copy
parameter_list|()
specifier|const
name|Q_DECL_OVERRIDE
block|{
name|ElasticEase
modifier|*
name|rv
init|=
operator|new
name|ElasticEase
argument_list|(
name|_t
argument_list|)
decl_stmt|;
name|rv
operator|->
name|_p
operator|=
name|_p
expr_stmt|;
name|rv
operator|->
name|_a
operator|=
name|_a
expr_stmt|;
name|rv
operator|->
name|_bezierCurves
operator|=
name|_bezierCurves
expr_stmt|;
name|rv
operator|->
name|_tcbPoints
operator|=
name|_tcbPoints
expr_stmt|;
return|return
name|rv
return|;
block|}
name|qreal
name|value
parameter_list|(
name|qreal
name|t
parameter_list|)
name|Q_DECL_OVERRIDE
block|{
name|qreal
name|p
init|=
operator|(
name|_p
operator|<
literal|0
operator|)
condition|?
name|qreal
argument_list|(
literal|0.3
argument_list|)
else|:
name|_p
decl_stmt|;
name|qreal
name|a
init|=
operator|(
name|_a
operator|<
literal|0
operator|)
condition|?
name|qreal
argument_list|(
literal|1.0
argument_list|)
else|:
name|_a
decl_stmt|;
switch|switch
condition|(
name|_t
condition|)
block|{
case|case
name|QEasingCurve
operator|::
name|InElastic
case|:
return|return
name|easeInElastic
argument_list|(
name|t
argument_list|,
name|a
argument_list|,
name|p
argument_list|)
return|;
case|case
name|QEasingCurve
operator|::
name|OutElastic
case|:
return|return
name|easeOutElastic
argument_list|(
name|t
argument_list|,
name|a
argument_list|,
name|p
argument_list|)
return|;
case|case
name|QEasingCurve
operator|::
name|InOutElastic
case|:
return|return
name|easeInOutElastic
argument_list|(
name|t
argument_list|,
name|a
argument_list|,
name|p
argument_list|)
return|;
case|case
name|QEasingCurve
operator|::
name|OutInElastic
case|:
return|return
name|easeOutInElastic
argument_list|(
name|t
argument_list|,
name|a
argument_list|,
name|p
argument_list|)
return|;
default|default:
return|return
name|t
return|;
block|}
block|}
block|}
struct|;
end_struct
begin_struct
DECL|struct|BounceEase
struct|struct
name|BounceEase
super|:
specifier|public
name|QEasingCurveFunction
block|{
DECL|function|BounceEase
name|BounceEase
parameter_list|(
name|QEasingCurve
operator|::
name|Type
name|type
parameter_list|)
member_init_list|:
name|QEasingCurveFunction
argument_list|(
name|type
argument_list|,
name|qreal
argument_list|(
literal|0.3
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|)
block|{ }
name|QEasingCurveFunction
modifier|*
name|copy
parameter_list|()
specifier|const
name|Q_DECL_OVERRIDE
block|{
name|BounceEase
modifier|*
name|rv
init|=
operator|new
name|BounceEase
argument_list|(
name|_t
argument_list|)
decl_stmt|;
name|rv
operator|->
name|_a
operator|=
name|_a
expr_stmt|;
name|rv
operator|->
name|_bezierCurves
operator|=
name|_bezierCurves
expr_stmt|;
name|rv
operator|->
name|_tcbPoints
operator|=
name|_tcbPoints
expr_stmt|;
return|return
name|rv
return|;
block|}
name|qreal
name|value
parameter_list|(
name|qreal
name|t
parameter_list|)
name|Q_DECL_OVERRIDE
block|{
name|qreal
name|a
init|=
operator|(
name|_a
operator|<
literal|0
operator|)
condition|?
name|qreal
argument_list|(
literal|1.0
argument_list|)
else|:
name|_a
decl_stmt|;
switch|switch
condition|(
name|_t
condition|)
block|{
case|case
name|QEasingCurve
operator|::
name|InBounce
case|:
return|return
name|easeInBounce
argument_list|(
name|t
argument_list|,
name|a
argument_list|)
return|;
case|case
name|QEasingCurve
operator|::
name|OutBounce
case|:
return|return
name|easeOutBounce
argument_list|(
name|t
argument_list|,
name|a
argument_list|)
return|;
case|case
name|QEasingCurve
operator|::
name|InOutBounce
case|:
return|return
name|easeInOutBounce
argument_list|(
name|t
argument_list|,
name|a
argument_list|)
return|;
case|case
name|QEasingCurve
operator|::
name|OutInBounce
case|:
return|return
name|easeOutInBounce
argument_list|(
name|t
argument_list|,
name|a
argument_list|)
return|;
default|default:
return|return
name|t
return|;
block|}
block|}
block|}
struct|;
end_struct
begin_struct
DECL|struct|BackEase
struct|struct
name|BackEase
super|:
specifier|public
name|QEasingCurveFunction
block|{
DECL|function|BackEase
name|BackEase
parameter_list|(
name|QEasingCurve
operator|::
name|Type
name|type
parameter_list|)
member_init_list|:
name|QEasingCurveFunction
argument_list|(
name|type
argument_list|,
name|qreal
argument_list|(
literal|0.3
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|1.70158
argument_list|)
argument_list|)
block|{ }
name|QEasingCurveFunction
modifier|*
name|copy
parameter_list|()
specifier|const
name|Q_DECL_OVERRIDE
block|{
name|BackEase
modifier|*
name|rv
init|=
operator|new
name|BackEase
argument_list|(
name|_t
argument_list|)
decl_stmt|;
name|rv
operator|->
name|_o
operator|=
name|_o
expr_stmt|;
name|rv
operator|->
name|_bezierCurves
operator|=
name|_bezierCurves
expr_stmt|;
name|rv
operator|->
name|_tcbPoints
operator|=
name|_tcbPoints
expr_stmt|;
return|return
name|rv
return|;
block|}
name|qreal
name|value
parameter_list|(
name|qreal
name|t
parameter_list|)
name|Q_DECL_OVERRIDE
block|{
name|qreal
name|o
init|=
operator|(
name|_o
operator|<
literal|0
operator|)
condition|?
name|qreal
argument_list|(
literal|1.70158
argument_list|)
else|:
name|_o
decl_stmt|;
switch|switch
condition|(
name|_t
condition|)
block|{
case|case
name|QEasingCurve
operator|::
name|InBack
case|:
return|return
name|easeInBack
argument_list|(
name|t
argument_list|,
name|o
argument_list|)
return|;
case|case
name|QEasingCurve
operator|::
name|OutBack
case|:
return|return
name|easeOutBack
argument_list|(
name|t
argument_list|,
name|o
argument_list|)
return|;
case|case
name|QEasingCurve
operator|::
name|InOutBack
case|:
return|return
name|easeInOutBack
argument_list|(
name|t
argument_list|,
name|o
argument_list|)
return|;
case|case
name|QEasingCurve
operator|::
name|OutInBack
case|:
return|return
name|easeOutInBack
argument_list|(
name|t
argument_list|,
name|o
argument_list|)
return|;
default|default:
return|return
name|t
return|;
block|}
block|}
block|}
struct|;
end_struct
begin_function
DECL|function|curveToFunc
specifier|static
name|QEasingCurve
operator|::
name|EasingFunction
name|curveToFunc
parameter_list|(
name|QEasingCurve
operator|::
name|Type
name|curve
parameter_list|)
block|{
switch|switch
condition|(
name|curve
condition|)
block|{
case|case
name|QEasingCurve
operator|::
name|Linear
case|:
return|return
operator|&
name|easeNone
return|;
case|case
name|QEasingCurve
operator|::
name|InQuad
case|:
return|return
operator|&
name|easeInQuad
return|;
case|case
name|QEasingCurve
operator|::
name|OutQuad
case|:
return|return
operator|&
name|easeOutQuad
return|;
case|case
name|QEasingCurve
operator|::
name|InOutQuad
case|:
return|return
operator|&
name|easeInOutQuad
return|;
case|case
name|QEasingCurve
operator|::
name|OutInQuad
case|:
return|return
operator|&
name|easeOutInQuad
return|;
case|case
name|QEasingCurve
operator|::
name|InCubic
case|:
return|return
operator|&
name|easeInCubic
return|;
case|case
name|QEasingCurve
operator|::
name|OutCubic
case|:
return|return
operator|&
name|easeOutCubic
return|;
case|case
name|QEasingCurve
operator|::
name|InOutCubic
case|:
return|return
operator|&
name|easeInOutCubic
return|;
case|case
name|QEasingCurve
operator|::
name|OutInCubic
case|:
return|return
operator|&
name|easeOutInCubic
return|;
case|case
name|QEasingCurve
operator|::
name|InQuart
case|:
return|return
operator|&
name|easeInQuart
return|;
case|case
name|QEasingCurve
operator|::
name|OutQuart
case|:
return|return
operator|&
name|easeOutQuart
return|;
case|case
name|QEasingCurve
operator|::
name|InOutQuart
case|:
return|return
operator|&
name|easeInOutQuart
return|;
case|case
name|QEasingCurve
operator|::
name|OutInQuart
case|:
return|return
operator|&
name|easeOutInQuart
return|;
case|case
name|QEasingCurve
operator|::
name|InQuint
case|:
return|return
operator|&
name|easeInQuint
return|;
case|case
name|QEasingCurve
operator|::
name|OutQuint
case|:
return|return
operator|&
name|easeOutQuint
return|;
case|case
name|QEasingCurve
operator|::
name|InOutQuint
case|:
return|return
operator|&
name|easeInOutQuint
return|;
case|case
name|QEasingCurve
operator|::
name|OutInQuint
case|:
return|return
operator|&
name|easeOutInQuint
return|;
case|case
name|QEasingCurve
operator|::
name|InSine
case|:
return|return
operator|&
name|easeInSine
return|;
case|case
name|QEasingCurve
operator|::
name|OutSine
case|:
return|return
operator|&
name|easeOutSine
return|;
case|case
name|QEasingCurve
operator|::
name|InOutSine
case|:
return|return
operator|&
name|easeInOutSine
return|;
case|case
name|QEasingCurve
operator|::
name|OutInSine
case|:
return|return
operator|&
name|easeOutInSine
return|;
case|case
name|QEasingCurve
operator|::
name|InExpo
case|:
return|return
operator|&
name|easeInExpo
return|;
case|case
name|QEasingCurve
operator|::
name|OutExpo
case|:
return|return
operator|&
name|easeOutExpo
return|;
case|case
name|QEasingCurve
operator|::
name|InOutExpo
case|:
return|return
operator|&
name|easeInOutExpo
return|;
case|case
name|QEasingCurve
operator|::
name|OutInExpo
case|:
return|return
operator|&
name|easeOutInExpo
return|;
case|case
name|QEasingCurve
operator|::
name|InCirc
case|:
return|return
operator|&
name|easeInCirc
return|;
case|case
name|QEasingCurve
operator|::
name|OutCirc
case|:
return|return
operator|&
name|easeOutCirc
return|;
case|case
name|QEasingCurve
operator|::
name|InOutCirc
case|:
return|return
operator|&
name|easeInOutCirc
return|;
case|case
name|QEasingCurve
operator|::
name|OutInCirc
case|:
return|return
operator|&
name|easeOutInCirc
return|;
comment|// Internal for, compatibility with QTimeLine only ??
case|case
name|QEasingCurve
operator|::
name|InCurve
case|:
return|return
operator|&
name|easeInCurve
return|;
case|case
name|QEasingCurve
operator|::
name|OutCurve
case|:
return|return
operator|&
name|easeOutCurve
return|;
case|case
name|QEasingCurve
operator|::
name|SineCurve
case|:
return|return
operator|&
name|easeSineCurve
return|;
case|case
name|QEasingCurve
operator|::
name|CosineCurve
case|:
return|return
operator|&
name|easeCosineCurve
return|;
default|default:
return|return
literal|0
return|;
block|}
empty_stmt|;
block|}
end_function
begin_function
DECL|function|curveToFunctionObject
specifier|static
name|QEasingCurveFunction
modifier|*
name|curveToFunctionObject
parameter_list|(
name|QEasingCurve
operator|::
name|Type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QEasingCurve
operator|::
name|InElastic
case|:
case|case
name|QEasingCurve
operator|::
name|OutElastic
case|:
case|case
name|QEasingCurve
operator|::
name|InOutElastic
case|:
case|case
name|QEasingCurve
operator|::
name|OutInElastic
case|:
return|return
operator|new
name|ElasticEase
argument_list|(
name|type
argument_list|)
return|;
case|case
name|QEasingCurve
operator|::
name|OutBounce
case|:
case|case
name|QEasingCurve
operator|::
name|InBounce
case|:
case|case
name|QEasingCurve
operator|::
name|OutInBounce
case|:
case|case
name|QEasingCurve
operator|::
name|InOutBounce
case|:
return|return
operator|new
name|BounceEase
argument_list|(
name|type
argument_list|)
return|;
case|case
name|QEasingCurve
operator|::
name|InBack
case|:
case|case
name|QEasingCurve
operator|::
name|OutBack
case|:
case|case
name|QEasingCurve
operator|::
name|InOutBack
case|:
case|case
name|QEasingCurve
operator|::
name|OutInBack
case|:
return|return
operator|new
name|BackEase
argument_list|(
name|type
argument_list|)
return|;
case|case
name|QEasingCurve
operator|::
name|BezierSpline
case|:
return|return
operator|new
name|BezierEase
return|;
case|case
name|QEasingCurve
operator|::
name|TCBSpline
case|:
return|return
operator|new
name|TCBEase
return|;
default|default:
return|return
operator|new
name|QEasingCurveFunction
argument_list|(
name|type
argument_list|,
name|qreal
argument_list|(
literal|0.3
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|1.0
argument_list|)
argument_list|,
name|qreal
argument_list|(
literal|1.70158
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QEasingCurve::QEasingCurve(QEasingCurve&&other)      Move-constructs a QEasingCurve instance, making it point at the same     object that \a other was pointing to.      \since 5.2 */
end_comment
begin_comment
comment|/*!     Constructs an easing curve of the given \a type.  */
end_comment
begin_constructor
DECL|function|QEasingCurve
name|QEasingCurve
operator|::
name|QEasingCurve
parameter_list|(
name|Type
name|type
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QEasingCurvePrivate
argument_list|)
block|{
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Construct a copy of \a other.  */
end_comment
begin_constructor
DECL|function|QEasingCurve
name|QEasingCurve
operator|::
name|QEasingCurve
parameter_list|(
specifier|const
name|QEasingCurve
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QEasingCurvePrivate
argument_list|(
operator|*
name|other
operator|.
name|d_ptr
argument_list|)
argument_list|)
block|{
comment|// ### non-atomic, requires malloc on shallow copy
block|}
end_constructor
begin_comment
comment|/*!     Destructor.  */
end_comment
begin_destructor
DECL|function|~QEasingCurve
name|QEasingCurve
operator|::
name|~
name|QEasingCurve
parameter_list|()
block|{
operator|delete
name|d_ptr
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn QEasingCurve&QEasingCurve::operator=(const QEasingCurve&other)     Copy \a other.  */
end_comment
begin_comment
comment|/*!     \fn QEasingCurve&QEasingCurve::operator=(QEasingCurve&&other)      Move-assigns \a other to this QEasingCurve instance.      \since 5.2 */
end_comment
begin_comment
comment|/*!     \fn void QEasingCurve::swap(QEasingCurve&other)     \since 5.0      Swaps curve \a other with this curve. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!     Compare this easing curve with \a other and returns \c true if they are     equal. It will also compare the properties of a curve.  */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QEasingCurve
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QEasingCurve
modifier|&
name|other
parameter_list|)
specifier|const
block|{
name|bool
name|res
init|=
name|d_ptr
operator|->
name|func
operator|==
name|other
operator|.
name|d_ptr
operator|->
name|func
operator|&&
name|d_ptr
operator|->
name|type
operator|==
name|other
operator|.
name|d_ptr
operator|->
name|type
decl_stmt|;
if|if
condition|(
name|res
condition|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|config
operator|&&
name|other
operator|.
name|d_ptr
operator|->
name|config
condition|)
block|{
comment|// catch the config content
name|res
operator|=
name|d_ptr
operator|->
name|config
operator|->
name|operator
name|==
argument_list|(
operator|*
operator|(
name|other
operator|.
name|d_ptr
operator|->
name|config
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d_ptr
operator|->
name|config
operator|||
name|other
operator|.
name|d_ptr
operator|->
name|config
condition|)
block|{
comment|// one one has a config object, which could contain default values
name|res
operator|=
name|qFuzzyCompare
argument_list|(
name|amplitude
argument_list|()
argument_list|,
name|other
operator|.
name|amplitude
argument_list|()
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|period
argument_list|()
argument_list|,
name|other
operator|.
name|period
argument_list|()
argument_list|)
operator|&&
name|qFuzzyCompare
argument_list|(
name|overshoot
argument_list|()
argument_list|,
name|other
operator|.
name|overshoot
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QEasingCurve::operator!=(const QEasingCurve&other) const     Compare this easing curve with \a other and returns \c true if they are not equal.     It will also compare the properties of a curve.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns the amplitude. This is not applicable for all curve types.     It is only applicable for bounce and elastic curves (curves of type()     QEasingCurve::InBounce, QEasingCurve::OutBounce, QEasingCurve::InOutBounce,     QEasingCurve::OutInBounce, QEasingCurve::InElastic, QEasingCurve::OutElastic,     QEasingCurve::InOutElastic or QEasingCurve::OutInElastic).  */
end_comment
begin_function
DECL|function|amplitude
name|qreal
name|QEasingCurve
operator|::
name|amplitude
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|config
condition|?
name|d_ptr
operator|->
name|config
operator|->
name|_a
else|:
name|qreal
argument_list|(
literal|1.0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the amplitude to \a amplitude.      This will set the amplitude of the bounce or the amplitude of the     elastic "spring" effect. The higher the number, the higher the amplitude.     \sa amplitude() */
end_comment
begin_function
DECL|function|setAmplitude
name|void
name|QEasingCurve
operator|::
name|setAmplitude
parameter_list|(
name|qreal
name|amplitude
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|config
condition|)
name|d_ptr
operator|->
name|config
operator|=
name|curveToFunctionObject
argument_list|(
name|d_ptr
operator|->
name|type
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|config
operator|->
name|_a
operator|=
name|amplitude
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the period. This is not applicable for all curve types.     It is only applicable if type() is QEasingCurve::InElastic, QEasingCurve::OutElastic,     QEasingCurve::InOutElastic or QEasingCurve::OutInElastic.  */
end_comment
begin_function
DECL|function|period
name|qreal
name|QEasingCurve
operator|::
name|period
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|config
condition|?
name|d_ptr
operator|->
name|config
operator|->
name|_p
else|:
name|qreal
argument_list|(
literal|0.3
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the period to \a period.     Setting a small period value will give a high frequency of the curve. A     large period will give it a small frequency.      \sa period() */
end_comment
begin_function
DECL|function|setPeriod
name|void
name|QEasingCurve
operator|::
name|setPeriod
parameter_list|(
name|qreal
name|period
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|config
condition|)
name|d_ptr
operator|->
name|config
operator|=
name|curveToFunctionObject
argument_list|(
name|d_ptr
operator|->
name|type
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|config
operator|->
name|_p
operator|=
name|period
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the overshoot. This is not applicable for all curve types.     It is only applicable if type() is QEasingCurve::InBack, QEasingCurve::OutBack,     QEasingCurve::InOutBack or QEasingCurve::OutInBack.  */
end_comment
begin_function
DECL|function|overshoot
name|qreal
name|QEasingCurve
operator|::
name|overshoot
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|config
condition|?
name|d_ptr
operator|->
name|config
operator|->
name|_o
else|:
name|qreal
argument_list|(
literal|1.70158
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the overshoot to \a overshoot.      0 produces no overshoot, and the default value of 1.70158 produces an overshoot of 10 percent.      \sa overshoot() */
end_comment
begin_function
DECL|function|setOvershoot
name|void
name|QEasingCurve
operator|::
name|setOvershoot
parameter_list|(
name|qreal
name|overshoot
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|config
condition|)
name|d_ptr
operator|->
name|config
operator|=
name|curveToFunctionObject
argument_list|(
name|d_ptr
operator|->
name|type
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|config
operator|->
name|_o
operator|=
name|overshoot
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds a segment of a cubic bezier spline to define a custom easing curve.     It is only applicable if type() is QEasingCurve::BezierSpline.     Note that the spline implicitly starts at (0.0, 0.0) and has to end at (1.0, 1.0) to     be a valid easing curve.     \a c1 and \a c2 are the control points used for drawing the curve.     \a endPoint is the endpoint of the curve.  */
end_comment
begin_function
DECL|function|addCubicBezierSegment
name|void
name|QEasingCurve
operator|::
name|addCubicBezierSegment
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|c1
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|c2
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|endPoint
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|config
condition|)
name|d_ptr
operator|->
name|config
operator|=
name|curveToFunctionObject
argument_list|(
name|d_ptr
operator|->
name|type
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|config
operator|->
name|_bezierCurves
operator|<<
name|c1
operator|<<
name|c2
operator|<<
name|endPoint
expr_stmt|;
block|}
end_function
begin_function
DECL|function|tcbToBezier
name|QVector
argument_list|<
name|QPointF
argument_list|>
specifier|static
specifier|inline
name|tcbToBezier
parameter_list|(
specifier|const
name|TCBPoints
modifier|&
name|tcbPoints
parameter_list|)
block|{
specifier|const
name|int
name|count
init|=
name|tcbPoints
operator|.
name|count
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|QPointF
argument_list|>
name|bezierPoints
decl_stmt|;
name|bezierPoints
operator|.
name|reserve
argument_list|(
literal|3
operator|*
operator|(
name|count
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|qreal
name|t_0
init|=
name|tcbPoints
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|_t
decl_stmt|;
specifier|const
name|qreal
name|c_0
init|=
name|tcbPoints
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|_c
decl_stmt|;
name|qreal
name|b_0
init|=
operator|-
literal|1
decl_stmt|;
name|qreal
specifier|const
name|t_1
init|=
name|tcbPoints
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|_t
decl_stmt|;
name|qreal
specifier|const
name|c_1
init|=
name|tcbPoints
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|_c
decl_stmt|;
name|qreal
name|b_1
init|=
literal|1
decl_stmt|;
name|QPointF
name|c_minusOne
decl_stmt|;
comment|//P1 last segment - not available for the first point
specifier|const
name|QPointF
name|c0
argument_list|(
name|tcbPoints
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|_point
argument_list|)
decl_stmt|;
comment|//P0 Hermite/TBC
specifier|const
name|QPointF
name|c3
argument_list|(
name|tcbPoints
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|_point
argument_list|)
decl_stmt|;
comment|//P1 Hermite/TBC
name|QPointF
name|c4
decl_stmt|;
comment|//P0 next segment - not available for the last point
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
comment|//first point no left tangent
name|c_minusOne
operator|=
name|tcbPoints
operator|.
name|at
argument_list|(
name|i
operator|-
literal|2
argument_list|)
operator|.
name|_point
expr_stmt|;
name|b_0
operator|=
name|tcbPoints
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|_b
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
operator|(
name|count
operator|-
literal|1
operator|)
condition|)
block|{
comment|//last point no right tangent
name|c4
operator|=
name|tcbPoints
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|.
name|_point
expr_stmt|;
name|b_1
operator|=
name|tcbPoints
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|_b
expr_stmt|;
block|}
specifier|const
name|qreal
name|dx_0
init|=
literal|0.5
operator|*
operator|(
literal|1
operator|-
name|t_0
operator|)
operator|*
operator|(
operator|(
literal|1
operator|+
name|b_0
operator|)
operator|*
operator|(
literal|1
operator|+
name|c_0
operator|)
operator|*
operator|(
name|c0
operator|.
name|x
argument_list|()
operator|-
name|c_minusOne
operator|.
name|x
argument_list|()
operator|)
operator|+
operator|(
literal|1
operator|-
name|b_0
operator|)
operator|*
operator|(
literal|1
operator|-
name|c_0
operator|)
operator|*
operator|(
name|c3
operator|.
name|x
argument_list|()
operator|-
name|c0
operator|.
name|x
argument_list|()
operator|)
operator|)
decl_stmt|;
specifier|const
name|qreal
name|dy_0
init|=
literal|0.5
operator|*
operator|(
literal|1
operator|-
name|t_0
operator|)
operator|*
operator|(
operator|(
literal|1
operator|+
name|b_0
operator|)
operator|*
operator|(
literal|1
operator|+
name|c_0
operator|)
operator|*
operator|(
name|c0
operator|.
name|y
argument_list|()
operator|-
name|c_minusOne
operator|.
name|y
argument_list|()
operator|)
operator|+
operator|(
literal|1
operator|-
name|b_0
operator|)
operator|*
operator|(
literal|1
operator|-
name|c_0
operator|)
operator|*
operator|(
name|c3
operator|.
name|y
argument_list|()
operator|-
name|c0
operator|.
name|y
argument_list|()
operator|)
operator|)
decl_stmt|;
specifier|const
name|qreal
name|dx_1
init|=
literal|0.5
operator|*
operator|(
literal|1
operator|-
name|t_1
operator|)
operator|*
operator|(
operator|(
literal|1
operator|+
name|b_1
operator|)
operator|*
operator|(
literal|1
operator|-
name|c_1
operator|)
operator|*
operator|(
name|c3
operator|.
name|x
argument_list|()
operator|-
name|c0
operator|.
name|x
argument_list|()
operator|)
operator|+
operator|(
literal|1
operator|-
name|b_1
operator|)
operator|*
operator|(
literal|1
operator|+
name|c_1
operator|)
operator|*
operator|(
name|c4
operator|.
name|x
argument_list|()
operator|-
name|c3
operator|.
name|x
argument_list|()
operator|)
operator|)
decl_stmt|;
specifier|const
name|qreal
name|dy_1
init|=
literal|0.5
operator|*
operator|(
literal|1
operator|-
name|t_1
operator|)
operator|*
operator|(
operator|(
literal|1
operator|+
name|b_1
operator|)
operator|*
operator|(
literal|1
operator|-
name|c_1
operator|)
operator|*
operator|(
name|c3
operator|.
name|y
argument_list|()
operator|-
name|c0
operator|.
name|y
argument_list|()
operator|)
operator|+
operator|(
literal|1
operator|-
name|b_1
operator|)
operator|*
operator|(
literal|1
operator|+
name|c_1
operator|)
operator|*
operator|(
name|c4
operator|.
name|y
argument_list|()
operator|-
name|c3
operator|.
name|y
argument_list|()
operator|)
operator|)
decl_stmt|;
specifier|const
name|QPointF
name|d_0
init|=
name|QPointF
argument_list|(
name|dx_0
argument_list|,
name|dy_0
argument_list|)
decl_stmt|;
specifier|const
name|QPointF
name|d_1
init|=
name|QPointF
argument_list|(
name|dx_1
argument_list|,
name|dy_1
argument_list|)
decl_stmt|;
name|QPointF
name|c1
init|=
operator|(
literal|3
operator|*
name|c0
operator|+
name|d_0
operator|)
operator|/
literal|3
decl_stmt|;
name|QPointF
name|c2
init|=
operator|(
literal|3
operator|*
name|c3
operator|-
name|d_1
operator|)
operator|/
literal|3
decl_stmt|;
name|bezierPoints
operator|<<
name|c1
operator|<<
name|c2
operator|<<
name|c3
expr_stmt|;
block|}
return|return
name|bezierPoints
return|;
block|}
end_function
begin_comment
comment|/*!     Adds a segment of a TCB bezier spline to define a custom easing curve.     It is only applicable if type() is QEasingCurve::TCBSpline.     The spline has to start explitly at (0.0, 0.0) and has to end at (1.0, 1.0) to     be a valid easing curve.     The tension \a t changes the length of the tangent vector.     The continuity \a c changes the sharpness in change between the tangents.     The bias \a b changes the direction of the tangent vector.     \a nextPoint is the sample position.     All three parameters are valid between -1 and 1 and define the     tangent of the control point.     If all three parameters are 0 the resulting spline is a Catmull-Rom spline.     The begin and endpoint always have a bias of -1 and 1, since the outer tangent is not defined.  */
end_comment
begin_function
DECL|function|addTCBSegment
name|void
name|QEasingCurve
operator|::
name|addTCBSegment
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|nextPoint
parameter_list|,
name|qreal
name|t
parameter_list|,
name|qreal
name|c
parameter_list|,
name|qreal
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d_ptr
operator|->
name|config
condition|)
name|d_ptr
operator|->
name|config
operator|=
name|curveToFunctionObject
argument_list|(
name|d_ptr
operator|->
name|type
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|config
operator|->
name|_tcbPoints
operator|.
name|append
argument_list|(
name|TCBPoint
argument_list|(
name|nextPoint
argument_list|,
name|t
argument_list|,
name|c
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextPoint
operator|==
name|QPointF
argument_list|(
literal|1.0
argument_list|,
literal|1.0
argument_list|)
condition|)
block|{
name|d_ptr
operator|->
name|config
operator|->
name|_bezierCurves
operator|=
name|tcbToBezier
argument_list|(
name|d_ptr
operator|->
name|config
operator|->
name|_tcbPoints
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|config
operator|->
name|_tcbPoints
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QList<QPointF> QEasingCurve::cubicBezierSpline() const     \obsolete Use toCubicSpline() instead.  */
end_comment
begin_comment
comment|/*!     \since 5.0      Returns the cubicBezierSpline that defines a custom easing curve.     If the easing curve does not have a custom bezier easing curve the list     is empty. */
end_comment
begin_function
DECL|function|toCubicSpline
name|QVector
argument_list|<
name|QPointF
argument_list|>
name|QEasingCurve
operator|::
name|toCubicSpline
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|config
condition|?
name|d_ptr
operator|->
name|config
operator|->
name|_bezierCurves
else|:
name|QVector
argument_list|<
name|QPointF
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the type of the easing curve. */
end_comment
begin_function
DECL|function|type
name|QEasingCurve
operator|::
name|Type
name|QEasingCurve
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|type
return|;
block|}
end_function
begin_function
DECL|function|setType_helper
name|void
name|QEasingCurvePrivate
operator|::
name|setType_helper
parameter_list|(
name|QEasingCurve
operator|::
name|Type
name|newType
parameter_list|)
block|{
name|qreal
name|amp
init|=
operator|-
literal|1.0
decl_stmt|;
name|qreal
name|period
init|=
operator|-
literal|1.0
decl_stmt|;
name|qreal
name|overshoot
init|=
operator|-
literal|1.0
decl_stmt|;
name|QVector
argument_list|<
name|QPointF
argument_list|>
name|bezierCurves
decl_stmt|;
name|QVector
argument_list|<
name|TCBPoint
argument_list|>
name|tcbPoints
decl_stmt|;
if|if
condition|(
name|config
condition|)
block|{
name|amp
operator|=
name|config
operator|->
name|_a
expr_stmt|;
name|period
operator|=
name|config
operator|->
name|_p
expr_stmt|;
name|overshoot
operator|=
name|config
operator|->
name|_o
expr_stmt|;
name|bezierCurves
operator|=
name|config
operator|->
name|_bezierCurves
expr_stmt|;
name|tcbPoints
operator|=
name|config
operator|->
name|_tcbPoints
expr_stmt|;
operator|delete
name|config
expr_stmt|;
name|config
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|isConfigFunction
argument_list|(
name|newType
argument_list|)
operator|||
operator|(
name|amp
operator|!=
operator|-
literal|1.0
operator|)
operator|||
operator|(
name|period
operator|!=
operator|-
literal|1.0
operator|)
operator|||
operator|(
name|overshoot
operator|!=
operator|-
literal|1.0
operator|)
operator|||
operator|!
name|bezierCurves
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|config
operator|=
name|curveToFunctionObject
argument_list|(
name|newType
argument_list|)
expr_stmt|;
if|if
condition|(
name|amp
operator|!=
operator|-
literal|1.0
condition|)
name|config
operator|->
name|_a
operator|=
name|amp
expr_stmt|;
if|if
condition|(
name|period
operator|!=
operator|-
literal|1.0
condition|)
name|config
operator|->
name|_p
operator|=
name|period
expr_stmt|;
if|if
condition|(
name|overshoot
operator|!=
operator|-
literal|1.0
condition|)
name|config
operator|->
name|_o
operator|=
name|overshoot
expr_stmt|;
name|config
operator|->
name|_bezierCurves
operator|=
name|bezierCurves
expr_stmt|;
name|config
operator|->
name|_tcbPoints
operator|=
name|tcbPoints
expr_stmt|;
name|func
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newType
operator|!=
name|QEasingCurve
operator|::
name|Custom
condition|)
block|{
name|func
operator|=
name|curveToFunc
argument_list|(
name|newType
argument_list|)
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
operator|(
name|func
operator|==
literal|0
operator|)
operator|==
operator|(
name|config
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|newType
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the type of the easing curve to \a type. */
end_comment
begin_function
DECL|function|setType
name|void
name|QEasingCurve
operator|::
name|setType
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|d_ptr
operator|->
name|type
operator|==
name|type
condition|)
return|return;
if|if
condition|(
name|type
operator|<
name|Linear
operator|||
name|type
operator|>=
name|NCurveTypes
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEasingCurve: Invalid curve type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
name|d_ptr
operator|->
name|setType_helper
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets a custom easing curve that is defined by the user in the function \a func.     The signature of the function is qreal myEasingFunction(qreal progress),     where \e progress and the return value are considered to be normalized between 0 and 1.     (In some cases the return value can be outside that range)     After calling this function type() will return QEasingCurve::Custom.     \a func cannot be zero.      \sa customType()     \sa valueForProgress() */
end_comment
begin_function
DECL|function|setCustomType
name|void
name|QEasingCurve
operator|::
name|setCustomType
parameter_list|(
name|EasingFunction
name|func
parameter_list|)
block|{
if|if
condition|(
operator|!
name|func
condition|)
block|{
name|qWarning
argument_list|(
literal|"Function pointer must not be null"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d_ptr
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|d_ptr
operator|->
name|setType_helper
argument_list|(
name|Custom
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the function pointer to the custom easing curve.     If type() does not return QEasingCurve::Custom, this function     will return 0. */
end_comment
begin_function
DECL|function|customType
name|QEasingCurve
operator|::
name|EasingFunction
name|QEasingCurve
operator|::
name|customType
parameter_list|()
specifier|const
block|{
return|return
name|d_ptr
operator|->
name|type
operator|==
name|Custom
condition|?
name|d_ptr
operator|->
name|func
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Return the effective progress for the easing curve at \a progress.     Whereas \a progress must be between 0 and 1, the returned effective progress     can be outside those bounds. For example, QEasingCurve::InBack will     return negative values in the beginning of the function.  */
end_comment
begin_function
DECL|function|valueForProgress
name|qreal
name|QEasingCurve
operator|::
name|valueForProgress
parameter_list|(
name|qreal
name|progress
parameter_list|)
specifier|const
block|{
name|progress
operator|=
name|qBound
argument_list|<
name|qreal
argument_list|>
argument_list|(
literal|0
argument_list|,
name|progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_ptr
operator|->
name|func
condition|)
return|return
name|d_ptr
operator|->
name|func
argument_list|(
name|progress
argument_list|)
return|;
elseif|else
if|if
condition|(
name|d_ptr
operator|->
name|config
condition|)
return|return
name|d_ptr
operator|->
name|config
operator|->
name|value
argument_list|(
name|progress
argument_list|)
return|;
else|else
return|return
name|progress
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
specifier|const
name|QEasingCurve
modifier|&
name|item
parameter_list|)
block|{
name|QDebugStateSaver
name|saver
argument_list|(
name|debug
argument_list|)
decl_stmt|;
name|debug
operator|<<
literal|"type:"
operator|<<
name|item
operator|.
name|d_ptr
operator|->
name|type
operator|<<
literal|"func:"
operator|<<
name|item
operator|.
name|d_ptr
operator|->
name|func
expr_stmt|;
if|if
condition|(
name|item
operator|.
name|d_ptr
operator|->
name|config
condition|)
block|{
name|debug
operator|<<
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"period:%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|item
operator|.
name|d_ptr
operator|->
name|config
operator|->
name|_p
argument_list|,
literal|0
argument_list|,
literal|'f'
argument_list|,
literal|20
argument_list|)
operator|<<
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"amp:%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|item
operator|.
name|d_ptr
operator|->
name|config
operator|->
name|_a
argument_list|,
literal|0
argument_list|,
literal|'f'
argument_list|,
literal|20
argument_list|)
operator|<<
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"overshoot:%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|item
operator|.
name|d_ptr
operator|->
name|config
operator|->
name|_o
argument_list|,
literal|0
argument_list|,
literal|'f'
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
return|return
name|debug
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DEBUG_STREAM
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \fn QDataStream&operator<<(QDataStream&stream, const QEasingCurve&easing)     \relates QEasingCurve      Writes the given \a easing curve to the given \a stream and returns a     reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
specifier|const
name|QEasingCurve
modifier|&
name|easing
parameter_list|)
block|{
name|stream
operator|<<
name|quint8
argument_list|(
name|easing
operator|.
name|d_ptr
operator|->
name|type
argument_list|)
expr_stmt|;
name|stream
operator|<<
name|quint64
argument_list|(
name|quintptr
argument_list|(
name|easing
operator|.
name|d_ptr
operator|->
name|func
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|hasConfig
init|=
name|easing
operator|.
name|d_ptr
operator|->
name|config
decl_stmt|;
name|stream
operator|<<
name|hasConfig
expr_stmt|;
if|if
condition|(
name|hasConfig
condition|)
block|{
name|stream
operator|<<
name|easing
operator|.
name|d_ptr
operator|->
name|config
operator|->
name|_p
expr_stmt|;
name|stream
operator|<<
name|easing
operator|.
name|d_ptr
operator|->
name|config
operator|->
name|_a
expr_stmt|;
name|stream
operator|<<
name|easing
operator|.
name|d_ptr
operator|->
name|config
operator|->
name|_o
expr_stmt|;
block|}
return|return
name|stream
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDataStream&operator>>(QDataStream&stream, QEasingCurve&easing)     \relates QEasingCurve      Reads an easing curve from the given \a stream into the given \a     easing curve and returns a reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|stream
parameter_list|,
name|QEasingCurve
modifier|&
name|easing
parameter_list|)
block|{
name|QEasingCurve
operator|::
name|Type
name|type
decl_stmt|;
name|quint8
name|int_type
decl_stmt|;
name|stream
operator|>>
name|int_type
expr_stmt|;
name|type
operator|=
cast|static_cast
argument_list|<
name|QEasingCurve
operator|::
name|Type
argument_list|>
argument_list|(
name|int_type
argument_list|)
expr_stmt|;
name|easing
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|quint64
name|ptr_func
decl_stmt|;
name|stream
operator|>>
name|ptr_func
expr_stmt|;
name|easing
operator|.
name|d_ptr
operator|->
name|func
operator|=
name|QEasingCurve
operator|::
name|EasingFunction
argument_list|(
name|quintptr
argument_list|(
name|ptr_func
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|hasConfig
decl_stmt|;
name|stream
operator|>>
name|hasConfig
expr_stmt|;
operator|delete
name|easing
operator|.
name|d_ptr
operator|->
name|config
expr_stmt|;
name|easing
operator|.
name|d_ptr
operator|->
name|config
operator|=
name|Q_NULLPTR
expr_stmt|;
if|if
condition|(
name|hasConfig
condition|)
block|{
name|QEasingCurveFunction
modifier|*
name|config
init|=
name|curveToFunctionObject
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|stream
operator|>>
name|config
operator|->
name|_p
expr_stmt|;
name|stream
operator|>>
name|config
operator|->
name|_a
expr_stmt|;
name|stream
operator|>>
name|config
operator|->
name|_o
expr_stmt|;
name|easing
operator|.
name|d_ptr
operator|->
name|config
operator|=
name|config
expr_stmt|;
block|}
return|return
name|stream
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
