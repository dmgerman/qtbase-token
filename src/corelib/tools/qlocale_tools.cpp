begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qlocale_tools_p.h"
end_include
begin_include
include|#
directive|include
file|"qlocale_p.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<float.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<math.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WINCE
end_ifdef
begin_include
include|#
directive|include
file|"qfunctions_wince.h"
end_include
begin_comment
comment|// for _control87
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__UCLIBC__
argument_list|)
end_if
begin_include
include|#
directive|include
file|<fenv.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Sizes as defined by the ISO C99 standard - fallback
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LLONG_MAX
end_ifndef
begin_define
DECL|macro|LLONG_MAX
define|#
directive|define
name|LLONG_MAX
value|Q_INT64_C(0x7fffffffffffffff)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|LLONG_MIN
end_ifndef
begin_define
DECL|macro|LLONG_MIN
define|#
directive|define
name|LLONG_MIN
value|(-LLONG_MAX - Q_INT64_C(1))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|ULLONG_MAX
end_ifndef
begin_define
DECL|macro|ULLONG_MAX
define|#
directive|define
name|ULLONG_MAX
value|Q_UINT64_C(0xffffffffffffffff)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|QT_BEGIN_NAMESPACE
ifndef|#
directive|ifndef
name|QT_QLOCALE_USES_FCVT
specifier|static
name|char
modifier|*
name|_qdtoa
parameter_list|(
name|NEEDS_VOLATILE
name|double
name|d
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|ndigits
parameter_list|,
name|int
modifier|*
name|decpt
parameter_list|,
name|int
modifier|*
name|sign
parameter_list|,
name|char
modifier|*
modifier|*
name|rve
parameter_list|,
name|char
modifier|*
modifier|*
name|digits_str
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qulltoa
name|QString
name|qulltoa
parameter_list|(
name|qulonglong
name|l
parameter_list|,
name|int
name|base
parameter_list|,
specifier|const
name|QChar
name|_zero
parameter_list|)
block|{
name|ushort
name|buff
index|[
literal|65
index|]
decl_stmt|;
comment|// length of MAX_ULLONG in base 2
name|ushort
modifier|*
name|p
init|=
name|buff
operator|+
literal|65
decl_stmt|;
if|if
condition|(
name|base
operator|!=
literal|10
operator|||
name|_zero
operator|.
name|unicode
argument_list|()
operator|==
literal|'0'
condition|)
block|{
while|while
condition|(
name|l
operator|!=
literal|0
condition|)
block|{
name|int
name|c
init|=
name|l
operator|%
name|base
decl_stmt|;
operator|--
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|10
condition|)
operator|*
name|p
operator|=
literal|'0'
operator|+
name|c
expr_stmt|;
else|else
operator|*
name|p
operator|=
name|c
operator|-
literal|10
operator|+
literal|'a'
expr_stmt|;
name|l
operator|/=
name|base
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|l
operator|!=
literal|0
condition|)
block|{
name|int
name|c
init|=
name|l
operator|%
name|base
decl_stmt|;
operator|*
operator|(
operator|--
name|p
operator|)
operator|=
name|_zero
operator|.
name|unicode
argument_list|()
operator|+
name|c
expr_stmt|;
name|l
operator|/=
name|base
expr_stmt|;
block|}
block|}
return|return
name|QString
argument_list|(
cast|reinterpret_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
name|p
argument_list|)
argument_list|,
literal|65
operator|-
operator|(
name|p
operator|-
name|buff
operator|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qlltoa
name|QString
name|qlltoa
parameter_list|(
name|qlonglong
name|l
parameter_list|,
name|int
name|base
parameter_list|,
specifier|const
name|QChar
name|zero
parameter_list|)
block|{
return|return
name|qulltoa
argument_list|(
name|l
operator|<
literal|0
condition|?
operator|-
name|l
else|:
name|l
argument_list|,
name|base
argument_list|,
name|zero
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|decimalForm
name|QString
modifier|&
name|decimalForm
parameter_list|(
name|QChar
name|zero
parameter_list|,
name|QChar
name|decimal
parameter_list|,
name|QChar
name|group
parameter_list|,
name|QString
modifier|&
name|digits
parameter_list|,
name|int
name|decpt
parameter_list|,
name|uint
name|precision
parameter_list|,
name|PrecisionMode
name|pm
parameter_list|,
name|bool
name|always_show_decpt
parameter_list|,
name|bool
name|thousands_group
parameter_list|)
block|{
if|if
condition|(
name|decpt
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|-
name|decpt
condition|;
operator|++
name|i
control|)
name|digits
operator|.
name|prepend
argument_list|(
name|zero
argument_list|)
expr_stmt|;
name|decpt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decpt
operator|>
name|digits
operator|.
name|length
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|digits
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|decpt
condition|;
operator|++
name|i
control|)
name|digits
operator|.
name|append
argument_list|(
name|zero
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pm
operator|==
name|PMDecimalDigits
condition|)
block|{
name|uint
name|decimal_digits
init|=
name|digits
operator|.
name|length
argument_list|()
operator|-
name|decpt
decl_stmt|;
for|for
control|(
name|uint
name|i
init|=
name|decimal_digits
init|;
name|i
operator|<
name|precision
condition|;
operator|++
name|i
control|)
name|digits
operator|.
name|append
argument_list|(
name|zero
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pm
operator|==
name|PMSignificantDigits
condition|)
block|{
for|for
control|(
name|uint
name|i
init|=
name|digits
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|precision
condition|;
operator|++
name|i
control|)
name|digits
operator|.
name|append
argument_list|(
name|zero
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// pm == PMChopTrailingZeros
block|}
if|if
condition|(
name|always_show_decpt
operator|||
name|decpt
operator|<
name|digits
operator|.
name|length
argument_list|()
condition|)
name|digits
operator|.
name|insert
argument_list|(
name|decpt
argument_list|,
name|decimal
argument_list|)
expr_stmt|;
if|if
condition|(
name|thousands_group
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|decpt
operator|-
literal|3
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
literal|3
control|)
name|digits
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decpt
operator|==
literal|0
condition|)
name|digits
operator|.
name|prepend
argument_list|(
name|zero
argument_list|)
expr_stmt|;
return|return
name|digits
return|;
block|}
end_function
begin_function
DECL|function|exponentForm
name|QString
modifier|&
name|exponentForm
parameter_list|(
name|QChar
name|zero
parameter_list|,
name|QChar
name|decimal
parameter_list|,
name|QChar
name|exponential
parameter_list|,
name|QChar
name|group
parameter_list|,
name|QChar
name|plus
parameter_list|,
name|QChar
name|minus
parameter_list|,
name|QString
modifier|&
name|digits
parameter_list|,
name|int
name|decpt
parameter_list|,
name|uint
name|precision
parameter_list|,
name|PrecisionMode
name|pm
parameter_list|,
name|bool
name|always_show_decpt
parameter_list|)
block|{
name|int
name|exp
init|=
name|decpt
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|pm
operator|==
name|PMDecimalDigits
condition|)
block|{
for|for
control|(
name|uint
name|i
init|=
name|digits
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|precision
operator|+
literal|1
condition|;
operator|++
name|i
control|)
name|digits
operator|.
name|append
argument_list|(
name|zero
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pm
operator|==
name|PMSignificantDigits
condition|)
block|{
for|for
control|(
name|uint
name|i
init|=
name|digits
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|precision
condition|;
operator|++
name|i
control|)
name|digits
operator|.
name|append
argument_list|(
name|zero
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// pm == PMChopTrailingZeros
block|}
if|if
condition|(
name|always_show_decpt
operator|||
name|digits
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
name|digits
operator|.
name|insert
argument_list|(
literal|1
argument_list|,
name|decimal
argument_list|)
expr_stmt|;
name|digits
operator|.
name|append
argument_list|(
name|exponential
argument_list|)
expr_stmt|;
name|digits
operator|.
name|append
argument_list|(
name|QLocalePrivate
operator|::
name|longLongToString
argument_list|(
name|zero
argument_list|,
name|group
argument_list|,
name|plus
argument_list|,
name|minus
argument_list|,
name|exp
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
operator|-
literal|1
argument_list|,
name|QLocalePrivate
operator|::
name|AlwaysShowSign
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|digits
return|;
block|}
end_function
begin_comment
comment|// Removes thousand-group separators in "C" locale.
end_comment
begin_function
DECL|function|removeGroupSeparators
name|bool
name|removeGroupSeparators
parameter_list|(
name|QLocalePrivate
operator|::
name|CharBuff
modifier|*
name|num
parameter_list|)
block|{
name|int
name|group_cnt
init|=
literal|0
decl_stmt|;
comment|// counts number of group chars
name|int
name|decpt_idx
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|num
operator|->
name|data
argument_list|()
decl_stmt|;
name|int
name|l
init|=
name|qstrlen
argument_list|(
name|data
argument_list|)
decl_stmt|;
comment|// Find the decimal point and check if there are any group chars
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|l
condition|;
operator|++
name|i
control|)
block|{
name|char
name|c
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|data
index|[
name|i
operator|-
literal|1
index|]
operator|<
literal|'0'
operator|||
name|data
index|[
name|i
operator|-
literal|1
index|]
operator|>
literal|'9'
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|i
operator|==
name|l
operator|-
literal|1
operator|||
name|data
index|[
name|i
operator|+
literal|1
index|]
operator|<
literal|'0'
operator|||
name|data
index|[
name|i
operator|+
literal|1
index|]
operator|>
literal|'9'
condition|)
return|return
literal|false
return|;
operator|++
name|group_cnt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
comment|// Fail if more than one decimal points
if|if
condition|(
name|decpt_idx
operator|!=
operator|-
literal|1
condition|)
return|return
literal|false
return|;
name|decpt_idx
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
comment|// an 'e' or 'E' - if we have not encountered a decimal
comment|// point, this is where it "is".
if|if
condition|(
name|decpt_idx
operator|==
operator|-
literal|1
condition|)
name|decpt_idx
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|// If no group chars, we're done
if|if
condition|(
name|group_cnt
operator|==
literal|0
condition|)
return|return
literal|true
return|;
comment|// No decimal point means that it "is" at the end of the string
if|if
condition|(
name|decpt_idx
operator|==
operator|-
literal|1
condition|)
name|decpt_idx
operator|=
name|l
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
argument_list|<
name|l
operator|&&
name|group_cnt
argument_list|>
literal|0
condition|)
block|{
name|char
name|c
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
comment|// Don't allow group chars after the decimal point
if|if
condition|(
name|i
operator|>
name|decpt_idx
condition|)
return|return
literal|false
return|;
comment|// Check that it is placed correctly relative to the decpt
if|if
condition|(
operator|(
name|decpt_idx
operator|-
name|i
operator|)
operator|%
literal|4
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
comment|// Remove it
name|memmove
argument_list|(
name|data
operator|+
name|i
argument_list|,
name|data
operator|+
name|i
operator|+
literal|1
argument_list|,
name|l
operator|-
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|data
index|[
operator|--
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|--
name|group_cnt
expr_stmt|;
operator|--
name|decpt_idx
expr_stmt|;
block|}
else|else
block|{
comment|// Check that we are not missing a separator
if|if
condition|(
name|i
operator|<
name|decpt_idx
operator|&&
operator|(
name|decpt_idx
operator|-
name|i
operator|)
operator|%
literal|4
operator|==
literal|0
operator|&&
operator|!
operator|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
operator|)
operator|)
condition|)
comment|// check for negative or positive sign at start of string
return|return
literal|false
return|;
operator|++
name|i
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *        The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *        This product includes software developed by the University of  *        California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment
begin_comment
comment|// static char sccsid[] = "@(#)strtouq.c        8.1 (Berkeley) 6/4/93";
end_comment
begin_comment
comment|//  "$FreeBSD: src/lib/libc/stdlib/strtoull.c,v 1.5.2.1 2001/03/02 09:45:20 obrien Exp $";
end_comment
begin_comment
comment|/*  * Convert a string to an unsigned long long integer.  *  * Ignores `locale' stuff.  Assumes that the upper and lower case  * alphabets and digits are each contiguous.  */
end_comment
begin_function
DECL|function|qstrtoull
name|qulonglong
name|qstrtoull
parameter_list|(
specifier|const
name|char
modifier|*
name|nptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endptr
parameter_list|,
specifier|register
name|int
name|base
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|s
init|=
name|nptr
decl_stmt|;
specifier|register
name|qulonglong
name|acc
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
specifier|register
name|qulonglong
name|qbase
decl_stmt|,
name|cutoff
decl_stmt|;
specifier|register
name|int
name|any
decl_stmt|,
name|cutlim
decl_stmt|;
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
comment|/*      * See strtoq for comments as to the logic used.      */
name|s
operator|=
name|nptr
expr_stmt|;
do|do
block|{
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|endptr
operator|!=
literal|0
condition|)
operator|*
name|endptr
operator|=
name|s
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|base
operator|==
literal|0
operator|||
name|base
operator|==
literal|16
operator|)
operator|&&
name|c
operator|==
literal|'0'
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'x'
operator|||
operator|*
name|s
operator|==
literal|'X'
operator|)
condition|)
block|{
name|c
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|base
operator|=
name|c
operator|==
literal|'0'
condition|?
literal|8
else|:
literal|10
expr_stmt|;
name|qbase
operator|=
name|unsigned
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|cutoff
operator|=
name|qulonglong
argument_list|(
name|ULLONG_MAX
argument_list|)
operator|/
name|qbase
expr_stmt|;
name|cutlim
operator|=
name|qulonglong
argument_list|(
name|ULLONG_MAX
argument_list|)
operator|%
name|qbase
expr_stmt|;
for|for
control|(
name|acc
operator|=
literal|0
operator|,
name|any
operator|=
literal|0
init|;
condition|;
name|c
operator|=
operator|*
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
literal|'A'
operator|-
literal|10
else|:
literal|'a'
operator|-
literal|10
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|c
operator|>=
name|base
condition|)
break|break;
if|if
condition|(
name|any
argument_list|<
literal|0
operator|||
name|acc
argument_list|>
name|cutoff
operator|||
operator|(
name|acc
operator|==
name|cutoff
operator|&&
name|c
operator|>
name|cutlim
operator|)
condition|)
name|any
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|any
operator|=
literal|1
expr_stmt|;
name|acc
operator|*=
name|qbase
expr_stmt|;
name|acc
operator|+=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|any
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|any
operator|<
literal|0
condition|)
block|{
name|acc
operator|=
name|ULLONG_MAX
expr_stmt|;
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|endptr
operator|!=
literal|0
condition|)
operator|*
name|endptr
operator|=
operator|(
name|any
condition|?
name|s
operator|-
literal|1
else|:
name|nptr
operator|)
expr_stmt|;
return|return
name|acc
return|;
block|}
end_function
begin_comment
comment|//  "$FreeBSD: src/lib/libc/stdlib/strtoll.c,v 1.5.2.1 2001/03/02 09:45:20 obrien Exp $";
end_comment
begin_comment
comment|/*  * Convert a string to a long long integer.  *  * Ignores `locale' stuff.  Assumes that the upper and lower case  * alphabets and digits are each contiguous.  */
end_comment
begin_function
DECL|function|qstrtoll
name|qlonglong
name|qstrtoll
parameter_list|(
specifier|const
name|char
modifier|*
name|nptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endptr
parameter_list|,
specifier|register
name|int
name|base
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|qulonglong
name|acc
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
specifier|register
name|qulonglong
name|qbase
decl_stmt|,
name|cutoff
decl_stmt|;
specifier|register
name|int
name|neg
decl_stmt|,
name|any
decl_stmt|,
name|cutlim
decl_stmt|;
comment|/*      * Skip white space and pick up leading +/- sign if any.      * If base is 0, allow 0x for hex and 0 for octal, else      * assume decimal; if base is already 16, allow 0x.      */
name|s
operator|=
name|nptr
expr_stmt|;
do|do
block|{
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|neg
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
name|neg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|base
operator|==
literal|0
operator|||
name|base
operator|==
literal|16
operator|)
operator|&&
name|c
operator|==
literal|'0'
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'x'
operator|||
operator|*
name|s
operator|==
literal|'X'
operator|)
condition|)
block|{
name|c
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|base
operator|=
name|c
operator|==
literal|'0'
condition|?
literal|8
else|:
literal|10
expr_stmt|;
comment|/*      * Compute the cutoff value between legal numbers and illegal      * numbers.  That is the largest legal value, divided by the      * base.  An input number that is greater than this value, if      * followed by a legal input character, is too big.  One that      * is equal to this value may be valid or not; the limit      * between valid and invalid numbers is then based on the last      * digit.  For instance, if the range for quads is      * [-9223372036854775808..9223372036854775807] and the input base      * is 10, cutoff will be set to 922337203685477580 and cutlim to      * either 7 (neg==0) or 8 (neg==1), meaning that if we have      * accumulated a value> 922337203685477580, or equal but the      * next digit is> 7 (or 8), the number is too big, and we will      * return a range error.      *      * Set any if any `digits' consumed; make it negative to indicate      * overflow.      */
name|qbase
operator|=
name|unsigned
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|cutoff
operator|=
name|neg
condition|?
name|qulonglong
argument_list|(
literal|0
operator|-
operator|(
name|LLONG_MIN
operator|+
name|LLONG_MAX
operator|)
argument_list|)
operator|+
name|LLONG_MAX
else|:
name|LLONG_MAX
expr_stmt|;
name|cutlim
operator|=
name|cutoff
operator|%
name|qbase
expr_stmt|;
name|cutoff
operator|/=
name|qbase
expr_stmt|;
for|for
control|(
name|acc
operator|=
literal|0
operator|,
name|any
operator|=
literal|0
init|;
condition|;
name|c
operator|=
operator|*
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
literal|'A'
operator|-
literal|10
else|:
literal|'a'
operator|-
literal|10
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|c
operator|>=
name|base
condition|)
break|break;
if|if
condition|(
name|any
argument_list|<
literal|0
operator|||
name|acc
argument_list|>
name|cutoff
operator|||
operator|(
name|acc
operator|==
name|cutoff
operator|&&
name|c
operator|>
name|cutlim
operator|)
condition|)
name|any
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|any
operator|=
literal|1
expr_stmt|;
name|acc
operator|*=
name|qbase
expr_stmt|;
name|acc
operator|+=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|any
operator|<
literal|0
condition|)
block|{
name|acc
operator|=
name|neg
condition|?
name|LLONG_MIN
else|:
name|LLONG_MAX
expr_stmt|;
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|neg
condition|)
block|{
name|acc
operator|=
operator|(
operator|~
name|acc
operator|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|endptr
operator|!=
literal|0
condition|)
operator|*
name|endptr
operator|=
operator|(
name|any
operator|>=
literal|0
condition|?
name|s
operator|-
literal|1
else|:
name|nptr
operator|)
expr_stmt|;
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
name|any
operator|>
literal|0
expr_stmt|;
return|return
name|acc
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_QLOCALE_USES_FCVT
end_ifndef
begin_comment
comment|/*        From: NetBSD: strtod.c,v 1.26 1998/02/03 18:44:21 perry Exp */
end_comment
begin_comment
comment|/* $FreeBSD: src/lib/libc/stdlib/netbsd_strtod.c,v 1.2.2.2 2001/03/02 17:14:15 tegge Exp $        */
end_comment
begin_comment
comment|/* Please send bug reports to         David M. Gay         AT&T Bell Laboratories, Room 2C-463         600 Mountain Avenue         Murray Hill, NJ 07974-2070         U.S.A.         dmg@research.att.com or research!dmg  */
end_comment
begin_comment
comment|/* strtod for IEEE-, VAX-, and IBM-arithmetic machines.  *  * This strtod returns a nearest machine number to the input decimal  * string (or sets errno to ERANGE).  With IEEE arithmetic, ties are  * broken by the IEEE round-even rule.  Otherwise ties are broken by  * biased rounding (add half and chop).  *  * Inspired loosely by William D. Clinger's paper "How to Read Floating  * Point Numbers Accurately" [Proc. ACM SIGPLAN '90, pp. 92-101].  *  * Modifications:  *  *        1. We only require IEEE, IBM, or VAX double-precision  *                arithmetic (not IEEE double-extended).  *        2. We get by with floating-point arithmetic in a case that  *                Clinger missed -- when we're computing d * 10^n  *                for a small integer d and the integer n is not too  *                much larger than 22 (the maximum integer k for which  *                we can represent 10^k exactly), we may be able to  *                compute (d*10^k) * 10^(e-k) with just one roundoff.  *        3. Rather than a bit-at-a-time adjustment of the binary  *                result in the hard case, we use floating-point  *                arithmetic to determine the adjustment to within  *                one bit; only in really hard cases do we need to  *                compute a second residual.  *        4. Because of 3., we don't need a large table of powers of 10  *                for ten-to-e (just some small tables, e.g. of 10^k  *                for 0<= k<= 22).  */
end_comment
begin_comment
comment|/*  * #define IEEE_LITTLE_ENDIAN for IEEE-arithmetic machines where the least  *        significant byte has the lowest address.  * #define IEEE_BIG_ENDIAN for IEEE-arithmetic machines where the most  *        significant byte has the lowest address.  * #define Long int on machines with 32-bit ints and 64-bit longs.  * #define Sudden_Underflow for IEEE-format machines without gradual  *        underflow (i.e., that flush to zero on underflow).  * #define IBM for IBM mainframe-style floating-point arithmetic.  * #define VAX for VAX-style floating-point arithmetic.  * #define Unsigned_Shifts if>> does treats its left operand as unsigned.  * #define No_leftright to omit left-right logic in fast floating-point  *        computation of dtoa.  * #define Check_FLT_ROUNDS if FLT_ROUNDS can assume the values 2 or 3.  * #define RND_PRODQUOT to use rnd_prod and rnd_quot (assembly routines  *        that use extended-precision instructions to compute rounded  *        products and quotients) with IBM.  * #define ROUND_BIASED for IEEE-format with biased rounding.  * #define Inaccurate_Divide for IEEE-format with correctly rounded  *        products but inaccurate quotients, e.g., for Intel i860.  * #define Just_16 to store 16 bits per 32-bit Long when doing high-precision  *        integer arithmetic.  Whether this speeds things up or slows things  *        down depends on the machine and the number being converted.  * #define KR_headers for old-style C function headers.  * #define Bad_float_h if your system lacks a float.h or if it does not  *        define some or all of DBL_DIG, DBL_MAX_10_EXP, DBL_MAX_EXP,  *        FLT_RADIX, FLT_ROUNDS, and DBL_MAX.  * #define MALLOC your_malloc, where your_malloc(n) acts like malloc(n)  *        if memory is available and otherwise does something you deem  *        appropriate.  If MALLOC is undefined, malloc will be invoked  *        directly -- and assumed always to succeed.  */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if
begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: strtod.c,v 1.26 1998/02/03 18:44:21 perry Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment
begin_comment
comment|/* #if defined(__m68k__)    || defined(__sparc__) || defined(__i386__) || \      defined(__mips__)    || defined(__ns32k__) || defined(__alpha__) || \      defined(__powerpc__) || defined(Q_OS_WIN) || defined(Q_OS_DARWIN) || defined(Q_OS_MAC) || \      defined(mips) || defined(Q_OS_AIX) || defined(Q_OS_SOLARIS) #           define IEEE_BIG_OR_LITTLE_ENDIAN 1 #endif */
end_comment
begin_comment
comment|// *All* of our architectures have IEEE arithmetic, don't they?
end_comment
begin_define
DECL|macro|IEEE_BIG_OR_LITTLE_ENDIAN
define|#
directive|define
name|IEEE_BIG_OR_LITTLE_ENDIAN
value|1
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|__arm32__
end_ifdef
begin_comment
comment|/*  * Although the CPU is little endian the FP has different  * byte and word endianness. The byte order is still little endian  * but the word order is big endian.  */
end_comment
begin_define
DECL|macro|IEEE_BIG_OR_LITTLE_ENDIAN
define|#
directive|define
name|IEEE_BIG_OR_LITTLE_ENDIAN
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef
begin_define
DECL|macro|VAX
define|#
directive|define
name|VAX
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Long
define|#
directive|define
name|Long
value|qint32
end_define
begin_define
DECL|macro|ULong
define|#
directive|define
name|ULong
value|quint32
end_define
begin_define
DECL|macro|MALLOC
define|#
directive|define
name|MALLOC
value|malloc
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|BSD_QDTOA_DEBUG
end_ifdef
begin_function
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<stdio.h>
name|QT_END_INCLUDE_NAMESPACE
DECL|macro|Bug
define|#
directive|define
name|Bug
parameter_list|(
name|x
parameter_list|)
value|{fprintf(stderr, "%s\n", x); exit(1);}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Unsigned_Shifts
DECL|macro|Sign_Extend
define|#
directive|define
name|Sign_Extend
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|if (b< 0) a |= 0xffff0000;
else|#
directive|else
define|#
directive|define
name|Sign_Extend
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
comment|/*no-op*/
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
argument_list|(
name|IEEE_BIG_OR_LITTLE_ENDIAN
argument_list|)
operator|+
name|defined
argument_list|(
name|VAX
argument_list|)
operator|+
name|defined
argument_list|(
name|IBM
argument_list|)
operator|)
operator|!=
literal|1
error|#
directive|error
error|Exactly one of IEEE_BIG_OR_LITTLE_ENDIAN, VAX, or IBM should be defined.
endif|#
directive|endif
DECL|function|getWord0
specifier|static
specifier|inline
name|ULong
name|getWord0
parameter_list|(
specifier|const
name|NEEDS_VOLATILE
name|double
name|x
parameter_list|)
block|{
specifier|const
name|NEEDS_VOLATILE
name|uchar
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|NEEDS_VOLATILE
name|uchar
operator|*
argument_list|>
argument_list|(
operator|&
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
return|return
operator|(
name|ptr
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|ptr
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|ptr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|ptr
index|[
literal|3
index|]
return|;
block|}
else|else
block|{
return|return
operator|(
name|ptr
index|[
literal|7
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|ptr
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|ptr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|+
name|ptr
index|[
literal|4
index|]
return|;
block|}
block|}
end_function
begin_function
DECL|function|setWord0
specifier|static
specifier|inline
name|void
name|setWord0
parameter_list|(
name|NEEDS_VOLATILE
name|double
modifier|*
name|x
parameter_list|,
name|ULong
name|l
parameter_list|)
block|{
name|NEEDS_VOLATILE
name|uchar
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
name|NEEDS_VOLATILE
name|uchar
operator|*
argument_list|>
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
name|ptr
index|[
literal|0
index|]
operator|=
name|uchar
argument_list|(
name|l
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|uchar
argument_list|(
name|l
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
name|uchar
argument_list|(
name|l
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
name|uchar
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptr
index|[
literal|7
index|]
operator|=
name|uchar
argument_list|(
name|l
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|6
index|]
operator|=
name|uchar
argument_list|(
name|l
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|5
index|]
operator|=
name|uchar
argument_list|(
name|l
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|4
index|]
operator|=
name|uchar
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|getWord1
specifier|static
specifier|inline
name|ULong
name|getWord1
parameter_list|(
specifier|const
name|NEEDS_VOLATILE
name|double
name|x
parameter_list|)
block|{
specifier|const
name|NEEDS_VOLATILE
name|uchar
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|NEEDS_VOLATILE
name|uchar
operator|*
argument_list|>
argument_list|(
operator|&
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
return|return
operator|(
name|ptr
index|[
literal|4
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|ptr
index|[
literal|5
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|ptr
index|[
literal|6
index|]
operator|<<
literal|8
operator|)
operator|+
name|ptr
index|[
literal|7
index|]
return|;
block|}
else|else
block|{
return|return
operator|(
name|ptr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|ptr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|ptr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
name|ptr
index|[
literal|0
index|]
return|;
block|}
block|}
end_function
begin_function
DECL|function|setWord1
specifier|static
specifier|inline
name|void
name|setWord1
parameter_list|(
name|NEEDS_VOLATILE
name|double
modifier|*
name|x
parameter_list|,
name|ULong
name|l
parameter_list|)
block|{
name|NEEDS_VOLATILE
name|uchar
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
name|uchar
name|NEEDS_VOLATILE
operator|*
argument_list|>
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
block|{
name|ptr
index|[
literal|4
index|]
operator|=
name|uchar
argument_list|(
name|l
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|5
index|]
operator|=
name|uchar
argument_list|(
name|l
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|6
index|]
operator|=
name|uchar
argument_list|(
name|l
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|7
index|]
operator|=
name|uchar
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptr
index|[
literal|3
index|]
operator|=
name|uchar
argument_list|(
name|l
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
name|uchar
argument_list|(
name|l
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|uchar
argument_list|(
name|l
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|uchar
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|Storeinc
specifier|static
specifier|inline
name|void
name|Storeinc
parameter_list|(
name|ULong
modifier|*
modifier|&
name|a
parameter_list|,
specifier|const
name|ULong
modifier|&
name|b
parameter_list|,
specifier|const
name|ULong
modifier|&
name|c
parameter_list|)
block|{
operator|*
name|a
operator|=
operator|(
name|ushort
argument_list|(
name|b
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|ushort
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|++
name|a
expr_stmt|;
block|}
end_function
begin_comment
comment|/* #define P DBL_MANT_DIG */
end_comment
begin_comment
comment|/* Ten_pmax = floor(P*log(2)/log(5)) */
end_comment
begin_comment
comment|/* Bletch = (highest power of 2< DBL_MAX_10_EXP) / 16 */
end_comment
begin_comment
comment|/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */
end_comment
begin_comment
comment|/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|IEEE_BIG_OR_LITTLE_ENDIAN
argument_list|)
end_if
begin_define
DECL|macro|Exp_shift
define|#
directive|define
name|Exp_shift
value|20
end_define
begin_define
DECL|macro|Exp_shift1
define|#
directive|define
name|Exp_shift1
value|20
end_define
begin_define
DECL|macro|Exp_msk1
define|#
directive|define
name|Exp_msk1
value|0x100000
end_define
begin_define
DECL|macro|Exp_msk11
define|#
directive|define
name|Exp_msk11
value|0x100000
end_define
begin_define
DECL|macro|Exp_mask
define|#
directive|define
name|Exp_mask
value|0x7ff00000
end_define
begin_define
DECL|macro|P
define|#
directive|define
name|P
value|53
end_define
begin_define
DECL|macro|Bias
define|#
directive|define
name|Bias
value|1023
end_define
begin_define
DECL|macro|IEEE_Arith
define|#
directive|define
name|IEEE_Arith
end_define
begin_define
DECL|macro|Emin
define|#
directive|define
name|Emin
value|(-1022)
end_define
begin_define
DECL|macro|Exp_1
define|#
directive|define
name|Exp_1
value|0x3ff00000
end_define
begin_define
DECL|macro|Exp_11
define|#
directive|define
name|Exp_11
value|0x3ff00000
end_define
begin_define
DECL|macro|Ebits
define|#
directive|define
name|Ebits
value|11
end_define
begin_define
DECL|macro|Frac_mask
define|#
directive|define
name|Frac_mask
value|0xfffff
end_define
begin_define
DECL|macro|Frac_mask1
define|#
directive|define
name|Frac_mask1
value|0xfffff
end_define
begin_define
DECL|macro|Ten_pmax
define|#
directive|define
name|Ten_pmax
value|22
end_define
begin_define
DECL|macro|Bletch
define|#
directive|define
name|Bletch
value|0x10
end_define
begin_define
DECL|macro|Bndry_mask
define|#
directive|define
name|Bndry_mask
value|0xfffff
end_define
begin_define
DECL|macro|Bndry_mask1
define|#
directive|define
name|Bndry_mask1
value|0xfffff
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|LSB
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
end_if
begin_undef
DECL|macro|LSB
undef|#
directive|undef
name|LSB
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|LSB
define|#
directive|define
name|LSB
value|1
end_define
begin_define
DECL|macro|Sign_bit
define|#
directive|define
name|Sign_bit
value|0x80000000
end_define
begin_define
DECL|macro|Log2P
define|#
directive|define
name|Log2P
value|1
end_define
begin_define
DECL|macro|Tiny0
define|#
directive|define
name|Tiny0
value|0
end_define
begin_define
DECL|macro|Tiny1
define|#
directive|define
name|Tiny1
value|1
end_define
begin_define
DECL|macro|Quick_max
define|#
directive|define
name|Quick_max
value|14
end_define
begin_define
DECL|macro|Int_max
define|#
directive|define
name|Int_max
value|14
end_define
begin_define
DECL|macro|Infinite
define|#
directive|define
name|Infinite
parameter_list|(
name|x
parameter_list|)
value|(getWord0(x) == 0x7ff00000)
end_define
begin_comment
DECL|macro|Infinite
comment|/* sufficient test for here */
end_comment
begin_else
else|#
directive|else
end_else
begin_undef
DECL|macro|Sudden_Underflow
undef|#
directive|undef
name|Sudden_Underflow
end_undef
begin_define
DECL|macro|Sudden_Underflow
define|#
directive|define
name|Sudden_Underflow
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef
begin_define
DECL|macro|Exp_shift
define|#
directive|define
name|Exp_shift
value|24
end_define
begin_define
DECL|macro|Exp_shift1
define|#
directive|define
name|Exp_shift1
value|24
end_define
begin_define
DECL|macro|Exp_msk1
define|#
directive|define
name|Exp_msk1
value|0x1000000
end_define
begin_define
DECL|macro|Exp_msk11
define|#
directive|define
name|Exp_msk11
value|0x1000000
end_define
begin_define
DECL|macro|Exp_mask
define|#
directive|define
name|Exp_mask
value|0x7f000000
end_define
begin_define
DECL|macro|P
define|#
directive|define
name|P
value|14
end_define
begin_define
DECL|macro|Bias
define|#
directive|define
name|Bias
value|65
end_define
begin_define
DECL|macro|Exp_1
define|#
directive|define
name|Exp_1
value|0x41000000
end_define
begin_define
DECL|macro|Exp_11
define|#
directive|define
name|Exp_11
value|0x41000000
end_define
begin_define
DECL|macro|Ebits
define|#
directive|define
name|Ebits
value|8
end_define
begin_comment
DECL|macro|Ebits
comment|/* exponent has 7 bits, but 8 is the right value in b2d */
end_comment
begin_define
DECL|macro|Frac_mask
define|#
directive|define
name|Frac_mask
value|0xffffff
end_define
begin_define
DECL|macro|Frac_mask1
define|#
directive|define
name|Frac_mask1
value|0xffffff
end_define
begin_define
DECL|macro|Bletch
define|#
directive|define
name|Bletch
value|4
end_define
begin_define
DECL|macro|Ten_pmax
define|#
directive|define
name|Ten_pmax
value|22
end_define
begin_define
DECL|macro|Bndry_mask
define|#
directive|define
name|Bndry_mask
value|0xefffff
end_define
begin_define
DECL|macro|Bndry_mask1
define|#
directive|define
name|Bndry_mask1
value|0xffffff
end_define
begin_define
DECL|macro|LSB
define|#
directive|define
name|LSB
value|1
end_define
begin_define
DECL|macro|Sign_bit
define|#
directive|define
name|Sign_bit
value|0x80000000
end_define
begin_define
DECL|macro|Log2P
define|#
directive|define
name|Log2P
value|4
end_define
begin_define
DECL|macro|Tiny0
define|#
directive|define
name|Tiny0
value|0x100000
end_define
begin_define
DECL|macro|Tiny1
define|#
directive|define
name|Tiny1
value|0
end_define
begin_define
DECL|macro|Quick_max
define|#
directive|define
name|Quick_max
value|14
end_define
begin_define
DECL|macro|Int_max
define|#
directive|define
name|Int_max
value|15
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* VAX */
end_comment
begin_define
DECL|macro|Exp_shift
define|#
directive|define
name|Exp_shift
value|23
end_define
begin_define
DECL|macro|Exp_shift1
define|#
directive|define
name|Exp_shift1
value|7
end_define
begin_define
DECL|macro|Exp_msk1
define|#
directive|define
name|Exp_msk1
value|0x80
end_define
begin_define
DECL|macro|Exp_msk11
define|#
directive|define
name|Exp_msk11
value|0x800000
end_define
begin_define
DECL|macro|Exp_mask
define|#
directive|define
name|Exp_mask
value|0x7f80
end_define
begin_define
DECL|macro|P
define|#
directive|define
name|P
value|56
end_define
begin_define
DECL|macro|Bias
define|#
directive|define
name|Bias
value|129
end_define
begin_define
DECL|macro|Exp_1
define|#
directive|define
name|Exp_1
value|0x40800000
end_define
begin_define
DECL|macro|Exp_11
define|#
directive|define
name|Exp_11
value|0x4080
end_define
begin_define
DECL|macro|Ebits
define|#
directive|define
name|Ebits
value|8
end_define
begin_define
DECL|macro|Frac_mask
define|#
directive|define
name|Frac_mask
value|0x7fffff
end_define
begin_define
DECL|macro|Frac_mask1
define|#
directive|define
name|Frac_mask1
value|0xffff007f
end_define
begin_define
DECL|macro|Ten_pmax
define|#
directive|define
name|Ten_pmax
value|24
end_define
begin_define
DECL|macro|Bletch
define|#
directive|define
name|Bletch
value|2
end_define
begin_define
DECL|macro|Bndry_mask
define|#
directive|define
name|Bndry_mask
value|0xffff007f
end_define
begin_define
DECL|macro|Bndry_mask1
define|#
directive|define
name|Bndry_mask1
value|0xffff007f
end_define
begin_define
DECL|macro|LSB
define|#
directive|define
name|LSB
value|0x10000
end_define
begin_define
DECL|macro|Sign_bit
define|#
directive|define
name|Sign_bit
value|0x8000
end_define
begin_define
DECL|macro|Log2P
define|#
directive|define
name|Log2P
value|1
end_define
begin_define
DECL|macro|Tiny0
define|#
directive|define
name|Tiny0
value|0x80
end_define
begin_define
DECL|macro|Tiny1
define|#
directive|define
name|Tiny1
value|0
end_define
begin_define
DECL|macro|Quick_max
define|#
directive|define
name|Quick_max
value|15
end_define
begin_define
DECL|macro|Int_max
define|#
directive|define
name|Int_max
value|15
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|IEEE_Arith
end_ifndef
begin_define
DECL|macro|ROUND_BIASED
define|#
directive|define
name|ROUND_BIASED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|RND_PRODQUOT
end_ifdef
begin_define
DECL|macro|rounded_product
define|#
directive|define
name|rounded_product
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a = rnd_prod(a, b)
end_define
begin_define
DECL|macro|rounded_quotient
define|#
directive|define
name|rounded_quotient
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a = rnd_quot(a, b)
end_define
begin_decl_stmt
specifier|extern
name|double
name|rnd_prod
argument_list|(
name|double
argument_list|,
name|double
argument_list|)
decl_stmt|,
name|rnd_quot
argument_list|(
name|double
argument_list|,
name|double
argument_list|)
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|rounded_product
define|#
directive|define
name|rounded_product
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a *= b
end_define
begin_define
DECL|macro|rounded_quotient
define|#
directive|define
name|rounded_quotient
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a /= b
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Big0
define|#
directive|define
name|Big0
value|(Frac_mask1 | Exp_msk1*(DBL_MAX_EXP+Bias-1))
end_define
begin_define
DECL|macro|Big1
define|#
directive|define
name|Big1
value|0xffffffff
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|Just_16
end_ifndef
begin_comment
comment|/* When Pack_32 is not defined, we store 16 bits per 32-bit Long.  * This makes some inner loops simpler and sometimes saves work  * during multiplications, but it often seems to make things slightly  * slower.  Hence the default is now to store 32 bits per Long.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|Pack_32
end_ifndef
begin_define
DECL|macro|Pack_32
define|#
directive|define
name|Pack_32
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Kmax
define|#
directive|define
name|Kmax
value|15
end_define
begin_struct
struct|struct
DECL|struct|Bigint
name|Bigint
block|{
DECL|member|next
name|struct
name|Bigint
modifier|*
name|next
decl_stmt|;
DECL|member|k
DECL|member|maxwds
DECL|member|sign
DECL|member|wds
name|int
name|k
decl_stmt|,
name|maxwds
decl_stmt|,
name|sign
decl_stmt|,
name|wds
decl_stmt|;
DECL|member|x
name|ULong
name|x
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|Bigint
typedef|typedef
name|struct
name|Bigint
name|Bigint
typedef|;
end_typedef
begin_function
DECL|function|Balloc
specifier|static
name|Bigint
modifier|*
name|Balloc
parameter_list|(
name|int
name|k
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|Bigint
modifier|*
name|rv
decl_stmt|;
name|x
operator|=
literal|1
operator|<<
name|k
expr_stmt|;
name|rv
operator|=
cast|static_cast
argument_list|<
name|Bigint
operator|*
argument_list|>
argument_list|(
name|MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Bigint
argument_list|)
operator|+
operator|(
name|x
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Long
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|->
name|k
operator|=
name|k
expr_stmt|;
name|rv
operator|->
name|maxwds
operator|=
name|x
expr_stmt|;
name|rv
operator|->
name|sign
operator|=
name|rv
operator|->
name|wds
operator|=
literal|0
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function
begin_function
DECL|function|Bfree
specifier|static
name|void
name|Bfree
parameter_list|(
name|Bigint
modifier|*
name|v
parameter_list|)
block|{
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|Bcopy
define|#
directive|define
name|Bcopy
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|memcpy(reinterpret_cast<char *>(&x->sign), reinterpret_cast<char *>(&y->sign), \ y->wds*sizeof(Long) + 2*sizeof(int))
end_define
begin_comment
comment|/* multiply by m and add a */
end_comment
begin_function
DECL|function|multadd
specifier|static
name|Bigint
modifier|*
name|multadd
parameter_list|(
name|Bigint
modifier|*
name|b
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|a
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|wds
decl_stmt|;
name|ULong
modifier|*
name|x
decl_stmt|,
name|y
decl_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
name|ULong
name|xi
decl_stmt|,
name|z
decl_stmt|;
endif|#
directive|endif
name|Bigint
modifier|*
name|b1
decl_stmt|;
name|wds
operator|=
name|b
operator|->
name|wds
expr_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|Pack_32
name|xi
operator|=
operator|*
name|x
expr_stmt|;
name|y
operator|=
operator|(
name|xi
operator|&
literal|0xffff
operator|)
operator|*
name|m
operator|+
name|a
expr_stmt|;
name|z
operator|=
operator|(
name|xi
operator|>>
literal|16
operator|)
operator|*
name|m
operator|+
operator|(
name|y
operator|>>
literal|16
operator|)
expr_stmt|;
name|a
operator|=
operator|(
name|z
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|x
operator|++
operator|=
operator|(
name|z
operator|<<
literal|16
operator|)
operator|+
operator|(
name|y
operator|&
literal|0xffff
operator|)
expr_stmt|;
else|#
directive|else
name|y
operator|=
operator|*
name|x
operator|*
name|m
operator|+
name|a
expr_stmt|;
name|a
operator|=
operator|(
name|y
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|x
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|wds
condition|)
do|;
if|if
condition|(
name|a
condition|)
block|{
if|if
condition|(
name|wds
operator|>=
name|b
operator|->
name|maxwds
condition|)
block|{
name|b1
operator|=
name|Balloc
argument_list|(
name|b
operator|->
name|k
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|b1
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|b1
expr_stmt|;
block|}
name|b
operator|->
name|x
index|[
name|wds
operator|++
index|]
operator|=
name|a
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|wds
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function
begin_function
DECL|function|s2b
specifier|static
name|Bigint
modifier|*
name|s2b
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|nd0
parameter_list|,
name|int
name|nd
parameter_list|,
name|ULong
name|y9
parameter_list|)
block|{
name|Bigint
modifier|*
name|b
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|Long
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
operator|(
name|nd
operator|+
literal|8
operator|)
operator|/
literal|9
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|y
operator|=
literal|1
init|;
name|x
operator|>
name|y
condition|;
name|y
operator|<<=
literal|1
operator|,
name|k
operator|++
control|)
empty_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
name|b
operator|=
name|Balloc
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|=
name|y9
expr_stmt|;
name|b
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|b
operator|=
name|Balloc
argument_list|(
name|k
operator|+
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|=
name|y9
operator|&
literal|0xffff
expr_stmt|;
name|b
operator|->
name|wds
operator|=
operator|(
name|b
operator|->
name|x
index|[
literal|1
index|]
operator|=
name|y9
operator|>>
literal|16
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|9
expr_stmt|;
if|if
condition|(
literal|9
operator|<
name|nd0
condition|)
block|{
name|s
operator|+=
literal|9
expr_stmt|;
do|do
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
operator|*
name|s
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
do|while
condition|(
operator|++
name|i
operator|<
name|nd0
condition|)
do|;
name|s
operator|++
expr_stmt|;
block|}
else|else
name|s
operator|+=
literal|10
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nd
condition|;
name|i
operator|++
control|)
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
operator|*
name|s
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_function
DECL|function|hi0bits
specifier|static
name|int
name|hi0bits
parameter_list|(
name|ULong
name|x
parameter_list|)
block|{
name|int
name|k
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xffff0000
operator|)
condition|)
block|{
name|k
operator|=
literal|16
expr_stmt|;
name|x
operator|<<=
literal|16
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xff000000
operator|)
condition|)
block|{
name|k
operator|+=
literal|8
expr_stmt|;
name|x
operator|<<=
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xf0000000
operator|)
condition|)
block|{
name|k
operator|+=
literal|4
expr_stmt|;
name|x
operator|<<=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xc0000000
operator|)
condition|)
block|{
name|k
operator|+=
literal|2
expr_stmt|;
name|x
operator|<<=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0x80000000
operator|)
condition|)
block|{
name|k
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0x40000000
operator|)
condition|)
return|return
literal|32
return|;
block|}
return|return
name|k
return|;
block|}
end_function
begin_function
DECL|function|lo0bits
specifier|static
name|int
name|lo0bits
parameter_list|(
name|ULong
modifier|*
name|y
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|ULong
name|x
init|=
operator|*
name|y
decl_stmt|;
if|if
condition|(
name|x
operator|&
literal|7
condition|)
block|{
if|if
condition|(
name|x
operator|&
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|x
operator|&
literal|2
condition|)
block|{
operator|*
name|y
operator|=
name|x
operator|>>
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|y
operator|=
name|x
operator|>>
literal|2
expr_stmt|;
return|return
literal|2
return|;
block|}
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xffff
operator|)
condition|)
block|{
name|k
operator|=
literal|16
expr_stmt|;
name|x
operator|>>=
literal|16
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xff
operator|)
condition|)
block|{
name|k
operator|+=
literal|8
expr_stmt|;
name|x
operator|>>=
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xf
operator|)
condition|)
block|{
name|k
operator|+=
literal|4
expr_stmt|;
name|x
operator|>>=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0x3
operator|)
condition|)
block|{
name|k
operator|+=
literal|2
expr_stmt|;
name|x
operator|>>=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|1
operator|)
condition|)
block|{
name|k
operator|++
expr_stmt|;
name|x
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|x
operator|&
literal|1
condition|)
return|return
literal|32
return|;
block|}
operator|*
name|y
operator|=
name|x
expr_stmt|;
return|return
name|k
return|;
block|}
end_function
begin_function
DECL|function|i2b
specifier|static
name|Bigint
modifier|*
name|i2b
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|Bigint
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|Balloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|b
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_function
DECL|function|mult
specifier|static
name|Bigint
modifier|*
name|mult
parameter_list|(
name|Bigint
modifier|*
name|a
parameter_list|,
name|Bigint
modifier|*
name|b
parameter_list|)
block|{
name|Bigint
modifier|*
name|c
decl_stmt|;
name|int
name|k
decl_stmt|,
name|wa
decl_stmt|,
name|wb
decl_stmt|,
name|wc
decl_stmt|;
name|ULong
name|carry
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|ULong
modifier|*
name|x
decl_stmt|,
modifier|*
name|xa
decl_stmt|,
modifier|*
name|xae
decl_stmt|,
modifier|*
name|xb
decl_stmt|,
modifier|*
name|xbe
decl_stmt|,
modifier|*
name|xc
decl_stmt|,
modifier|*
name|xc0
decl_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
name|ULong
name|z2
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|a
operator|->
name|wds
operator|<
name|b
operator|->
name|wds
condition|)
block|{
name|c
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|c
expr_stmt|;
block|}
name|k
operator|=
name|a
operator|->
name|k
expr_stmt|;
name|wa
operator|=
name|a
operator|->
name|wds
expr_stmt|;
name|wb
operator|=
name|b
operator|->
name|wds
expr_stmt|;
name|wc
operator|=
name|wa
operator|+
name|wb
expr_stmt|;
if|if
condition|(
name|wc
operator|>
name|a
operator|->
name|maxwds
condition|)
name|k
operator|++
expr_stmt|;
name|c
operator|=
name|Balloc
argument_list|(
name|k
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|c
operator|->
name|x
operator|,
name|xa
operator|=
name|x
operator|+
name|wc
init|;
name|x
operator|<
name|xa
condition|;
name|x
operator|++
control|)
operator|*
name|x
operator|=
literal|0
expr_stmt|;
name|xa
operator|=
name|a
operator|->
name|x
expr_stmt|;
name|xae
operator|=
name|xa
operator|+
name|wa
expr_stmt|;
name|xb
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|xbe
operator|=
name|xb
operator|+
name|wb
expr_stmt|;
name|xc0
operator|=
name|c
operator|->
name|x
expr_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
for|for
control|(
init|;
name|xb
operator|<
name|xbe
condition|;
name|xb
operator|++
operator|,
name|xc0
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|y
operator|=
operator|*
name|xb
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|xa
expr_stmt|;
name|xc
operator|=
name|xc0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|z
operator|=
operator|(
operator|*
name|x
operator|&
literal|0xffff
operator|)
operator|*
name|y
operator|+
operator|(
operator|*
name|xc
operator|&
literal|0xffff
operator|)
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|z2
operator|=
operator|(
operator|*
name|x
operator|++
operator|>>
literal|16
operator|)
operator|*
name|y
operator|+
operator|(
operator|*
name|xc
operator|>>
literal|16
operator|)
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z2
operator|>>
literal|16
expr_stmt|;
name|Storeinc
argument_list|(
name|xc
argument_list|,
name|z2
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xae
condition|)
do|;
operator|*
name|xc
operator|=
name|carry
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
operator|*
name|xb
operator|>>
literal|16
operator|)
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|xa
expr_stmt|;
name|xc
operator|=
name|xc0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|z2
operator|=
operator|*
name|xc
expr_stmt|;
do|do
block|{
name|z
operator|=
operator|(
operator|*
name|x
operator|&
literal|0xffff
operator|)
operator|*
name|y
operator|+
operator|(
operator|*
name|xc
operator|>>
literal|16
operator|)
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Storeinc
argument_list|(
name|xc
argument_list|,
name|z
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|z2
operator|=
operator|(
operator|*
name|x
operator|++
operator|>>
literal|16
operator|)
operator|*
name|y
operator|+
operator|(
operator|*
name|xc
operator|&
literal|0xffff
operator|)
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z2
operator|>>
literal|16
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xae
condition|)
do|;
operator|*
name|xc
operator|=
name|z2
expr_stmt|;
block|}
block|}
else|#
directive|else
for|for
control|(
init|;
name|xb
operator|<
name|xbe
condition|;
name|xc0
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|=
operator|*
name|xb
operator|++
condition|)
block|{
name|x
operator|=
name|xa
expr_stmt|;
name|xc
operator|=
name|xc0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|z
operator|=
operator|*
name|x
operator|++
operator|*
name|y
operator|+
operator|*
name|xc
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
operator|*
name|xc
operator|++
operator|=
name|z
operator|&
literal|0xffff
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xae
condition|)
do|;
operator|*
name|xc
operator|=
name|carry
expr_stmt|;
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|xc0
operator|=
name|c
operator|->
name|x
operator|,
name|xc
operator|=
name|xc0
operator|+
name|wc
init|;
name|wc
operator|>
literal|0
operator|&&
operator|!
operator|*
operator|--
name|xc
condition|;
operator|--
name|wc
control|)
empty_stmt|;
name|c
operator|->
name|wds
operator|=
name|wc
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|p5s
specifier|static
name|Bigint
modifier|*
name|p5s
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|p5s_deleter
struct|struct
name|p5s_deleter
block|{
DECL|function|~p5s_deleter
name|~
name|p5s_deleter
parameter_list|()
block|{
while|while
condition|(
name|p5s
condition|)
block|{
name|Bigint
modifier|*
name|next
init|=
name|p5s
operator|->
name|next
decl_stmt|;
name|Bfree
argument_list|(
name|p5s
argument_list|)
expr_stmt|;
name|p5s
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
struct|;
end_struct
begin_function
DECL|function|pow5mult
specifier|static
name|Bigint
modifier|*
name|pow5mult
parameter_list|(
name|Bigint
modifier|*
name|b
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|Bigint
modifier|*
name|b1
decl_stmt|,
modifier|*
name|p5
decl_stmt|,
modifier|*
name|p51
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|int
name|p05
index|[
literal|3
index|]
init|=
block|{
literal|5
block|,
literal|25
block|,
literal|125
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|k
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_IRIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
block|{
comment|// work around a bug on 64 bit IRIX gcc
name|int
modifier|*
name|p
init|=
operator|(
name|int
operator|*
operator|)
name|p05
decl_stmt|;
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
name|p
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
name|p05
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|k
operator|>>=
literal|2
operator|)
condition|)
return|return
name|b
return|;
if|if
condition|(
operator|!
operator|(
name|p5
operator|=
name|p5s
operator|)
condition|)
block|{
comment|/* first time */
specifier|static
name|p5s_deleter
name|deleter
decl_stmt|;
name|p5
operator|=
name|p5s
operator|=
name|i2b
argument_list|(
literal|625
argument_list|)
expr_stmt|;
name|p5
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|k
operator|&
literal|1
condition|)
block|{
name|b1
operator|=
name|mult
argument_list|(
name|b
argument_list|,
name|p5
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|b1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|k
operator|>>=
literal|1
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|p51
operator|=
name|p5
operator|->
name|next
operator|)
condition|)
block|{
name|p51
operator|=
name|p5
operator|->
name|next
operator|=
name|mult
argument_list|(
name|p5
argument_list|,
name|p5
argument_list|)
expr_stmt|;
name|p51
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
name|p5
operator|=
name|p51
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function
begin_function
DECL|function|lshift
specifier|static
name|Bigint
modifier|*
name|lshift
parameter_list|(
name|Bigint
modifier|*
name|b
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|k1
decl_stmt|,
name|n
decl_stmt|,
name|n1
decl_stmt|;
name|Bigint
modifier|*
name|b1
decl_stmt|;
name|ULong
modifier|*
name|x
decl_stmt|,
modifier|*
name|x1
decl_stmt|,
modifier|*
name|xe
decl_stmt|,
name|z
decl_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
name|n
operator|=
name|k
operator|>>
literal|5
expr_stmt|;
else|#
directive|else
name|n
operator|=
name|k
operator|>>
literal|4
expr_stmt|;
endif|#
directive|endif
name|k1
operator|=
name|b
operator|->
name|k
expr_stmt|;
name|n1
operator|=
name|n
operator|+
name|b
operator|->
name|wds
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|b
operator|->
name|maxwds
init|;
name|n1
operator|>
name|i
condition|;
name|i
operator|<<=
literal|1
control|)
name|k1
operator|++
expr_stmt|;
name|b1
operator|=
name|Balloc
argument_list|(
name|k1
argument_list|)
expr_stmt|;
name|x1
operator|=
name|b1
operator|->
name|x
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
operator|*
name|x1
operator|++
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|xe
operator|=
name|x
operator|+
name|b
operator|->
name|wds
expr_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
if|if
condition|(
name|k
operator|&=
literal|0x1f
condition|)
block|{
name|k1
operator|=
literal|32
operator|-
name|k
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
do|do
block|{
operator|*
name|x1
operator|++
operator|=
operator|*
name|x
operator|<<
name|k
operator||
name|z
expr_stmt|;
name|z
operator|=
operator|*
name|x
operator|++
operator|>>
name|k1
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xe
condition|)
do|;
if|if
condition|(
operator|(
operator|*
name|x1
operator|=
name|z
operator|)
operator|!=
literal|0
condition|)
operator|++
name|n1
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|k
operator|&=
literal|0xf
condition|)
block|{
name|k1
operator|=
literal|16
operator|-
name|k
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
do|do
block|{
operator|*
name|x1
operator|++
operator|=
operator|*
name|x
operator|<<
name|k
operator|&
literal|0xffff
operator||
name|z
expr_stmt|;
name|z
operator|=
operator|*
name|x
operator|++
operator|>>
name|k1
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xe
condition|)
do|;
if|if
condition|(
operator|*
name|x1
operator|=
name|z
condition|)
operator|++
name|n1
expr_stmt|;
block|}
endif|#
directive|endif
else|else
do|do
operator|*
name|x1
operator|++
operator|=
operator|*
name|x
operator|++
expr_stmt|;
do|while
condition|(
name|x
operator|<
name|xe
condition|)
do|;
name|b1
operator|->
name|wds
operator|=
name|n1
operator|-
literal|1
expr_stmt|;
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|b1
return|;
block|}
end_function
begin_function
DECL|function|cmp
specifier|static
name|int
name|cmp
parameter_list|(
name|Bigint
modifier|*
name|a
parameter_list|,
name|Bigint
modifier|*
name|b
parameter_list|)
block|{
name|ULong
modifier|*
name|xa
decl_stmt|,
modifier|*
name|xa0
decl_stmt|,
modifier|*
name|xb
decl_stmt|,
modifier|*
name|xb0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
name|a
operator|->
name|wds
expr_stmt|;
name|j
operator|=
name|b
operator|->
name|wds
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD_QDTOA_DEBUG
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
operator|!
name|a
operator|->
name|x
index|[
name|i
operator|-
literal|1
index|]
condition|)
name|Bug
argument_list|(
literal|"cmp called with a->x[a->wds-1] == 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|1
operator|&&
operator|!
name|b
operator|->
name|x
index|[
name|j
operator|-
literal|1
index|]
condition|)
name|Bug
argument_list|(
literal|"cmp called with b->x[b->wds-1] == 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|-=
name|j
condition|)
return|return
name|i
return|;
name|xa0
operator|=
name|a
operator|->
name|x
expr_stmt|;
name|xa
operator|=
name|xa0
operator|+
name|j
expr_stmt|;
name|xb0
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|xb
operator|=
name|xb0
operator|+
name|j
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|--
name|xa
operator|!=
operator|*
operator|--
name|xb
condition|)
return|return
operator|*
name|xa
operator|<
operator|*
name|xb
condition|?
operator|-
literal|1
else|:
literal|1
return|;
if|if
condition|(
name|xa
operator|<=
name|xa0
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|diff
specifier|static
name|Bigint
modifier|*
name|diff
parameter_list|(
name|Bigint
modifier|*
name|a
parameter_list|,
name|Bigint
modifier|*
name|b
parameter_list|)
block|{
name|Bigint
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|wa
decl_stmt|,
name|wb
decl_stmt|;
name|Long
name|borrow
decl_stmt|,
name|y
decl_stmt|;
comment|/* We need signed shifts here. */
name|ULong
modifier|*
name|xa
decl_stmt|,
modifier|*
name|xae
decl_stmt|,
modifier|*
name|xb
decl_stmt|,
modifier|*
name|xbe
decl_stmt|,
modifier|*
name|xc
decl_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
name|Long
name|z
decl_stmt|;
endif|#
directive|endif
name|i
operator|=
name|cmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|c
operator|=
name|Balloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|x
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|c
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|c
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|Balloc
argument_list|(
name|a
operator|->
name|k
argument_list|)
expr_stmt|;
name|c
operator|->
name|sign
operator|=
name|i
expr_stmt|;
name|wa
operator|=
name|a
operator|->
name|wds
expr_stmt|;
name|xa
operator|=
name|a
operator|->
name|x
expr_stmt|;
name|xae
operator|=
name|xa
operator|+
name|wa
expr_stmt|;
name|wb
operator|=
name|b
operator|->
name|wds
expr_stmt|;
name|xb
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|xbe
operator|=
name|xb
operator|+
name|wb
expr_stmt|;
name|xc
operator|=
name|c
operator|->
name|x
expr_stmt|;
name|borrow
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
do|do
block|{
name|y
operator|=
operator|(
operator|*
name|xa
operator|&
literal|0xffff
operator|)
operator|-
operator|(
operator|*
name|xb
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|xa
operator|++
operator|>>
literal|16
operator|)
operator|-
operator|(
operator|*
name|xb
operator|++
operator|>>
literal|16
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|Storeinc
argument_list|(
name|xc
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|xb
operator|<
name|xbe
condition|)
do|;
while|while
condition|(
name|xa
operator|<
name|xae
condition|)
block|{
name|y
operator|=
operator|(
operator|*
name|xa
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|xa
operator|++
operator|>>
literal|16
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|Storeinc
argument_list|(
name|xc
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
do|do
block|{
name|y
operator|=
operator|*
name|xa
operator|++
operator|-
operator|*
name|xb
operator|++
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|xc
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
block|}
do|while
condition|(
name|xb
operator|<
name|xbe
condition|)
do|;
while|while
condition|(
name|xa
operator|<
name|xae
condition|)
block|{
name|y
operator|=
operator|*
name|xa
operator|++
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|xc
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|!
operator|*
operator|--
name|xc
condition|)
name|wa
operator|--
expr_stmt|;
name|c
operator|->
name|wds
operator|=
name|wa
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|ulp
specifier|static
name|double
name|ulp
parameter_list|(
name|double
name|x
parameter_list|)
block|{
name|Long
name|L
decl_stmt|;
name|double
name|a
decl_stmt|;
name|L
operator|=
operator|(
name|getWord0
argument_list|(
name|x
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|-
operator|(
name|P
operator|-
literal|1
operator|)
operator|*
name|Exp_msk1
expr_stmt|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
name|L
operator|>
literal|0
condition|)
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
name|L
operator||=
name|Exp_msk1
operator|>>
literal|4
expr_stmt|;
endif|#
directive|endif
name|setWord0
argument_list|(
operator|&
name|a
argument_list|,
name|L
argument_list|)
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
block|}
else|else
block|{
name|L
operator|=
operator|-
name|L
operator|>>
name|Exp_shift
expr_stmt|;
if|if
condition|(
name|L
operator|<
name|Exp_shift
condition|)
block|{
name|setWord0
argument_list|(
operator|&
name|a
argument_list|,
literal|0x80000
operator|>>
name|L
argument_list|)
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setWord0
argument_list|(
operator|&
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|L
operator|-=
name|Exp_shift
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|a
argument_list|,
name|L
operator|>=
literal|31
condition|?
literal|1U
else|:
literal|1U
operator|<<
operator|(
literal|31
operator|-
name|L
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|b2d
specifier|static
name|double
name|b2d
parameter_list|(
name|Bigint
modifier|*
name|a
parameter_list|,
name|int
modifier|*
name|e
parameter_list|)
block|{
name|ULong
modifier|*
name|xa
decl_stmt|,
modifier|*
name|xa0
decl_stmt|,
name|w
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|int
name|k
decl_stmt|;
name|double
name|d
decl_stmt|;
name|xa0
operator|=
name|a
operator|->
name|x
expr_stmt|;
name|xa
operator|=
name|xa0
operator|+
name|a
operator|->
name|wds
expr_stmt|;
name|y
operator|=
operator|*
operator|--
name|xa
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD_QDTOA_DEBUG
if|if
condition|(
operator|!
name|y
condition|)
name|Bug
argument_list|(
literal|"zero y in b2d"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|k
operator|=
name|hi0bits
argument_list|(
name|y
argument_list|)
expr_stmt|;
operator|*
name|e
operator|=
literal|32
operator|-
name|k
expr_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
if|if
condition|(
name|k
operator|<
name|Ebits
condition|)
block|{
name|setWord0
argument_list|(
operator|&
name|d
argument_list|,
name|Exp_1
operator||
name|y
operator|>>
operator|(
name|Ebits
operator|-
name|k
operator|)
argument_list|)
expr_stmt|;
name|w
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|d
argument_list|,
name|y
operator|<<
operator|(
operator|(
literal|32
operator|-
name|Ebits
operator|)
operator|+
name|k
operator|)
operator||
name|w
operator|>>
operator|(
name|Ebits
operator|-
name|k
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|ret_d
goto|;
block|}
name|z
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|k
operator|-=
name|Ebits
condition|)
block|{
name|setWord0
argument_list|(
operator|&
name|d
argument_list|,
name|Exp_1
operator||
name|y
operator|<<
name|k
operator||
name|z
operator|>>
operator|(
literal|32
operator|-
name|k
operator|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|d
argument_list|,
name|z
operator|<<
name|k
operator||
name|y
operator|>>
operator|(
literal|32
operator|-
name|k
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setWord0
argument_list|(
operator|&
name|d
argument_list|,
name|Exp_1
operator||
name|y
argument_list|)
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|d
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|k
operator|<
name|Ebits
operator|+
literal|16
condition|)
block|{
name|z
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|setWord0
argument_list|(
operator|&
name|d
argument_list|,
name|Exp_1
operator||
name|y
operator|<<
name|k
operator|-
name|Ebits
operator||
name|z
operator|>>
name|Ebits
operator|+
literal|16
operator|-
name|k
argument_list|)
expr_stmt|;
name|w
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|y
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|d
argument_list|,
name|z
operator|<<
name|k
operator|+
literal|16
operator|-
name|Ebits
operator||
name|w
operator|<<
name|k
operator|-
name|Ebits
operator||
name|y
operator|>>
literal|16
operator|+
name|Ebits
operator|-
name|k
argument_list|)
expr_stmt|;
goto|goto
name|ret_d
goto|;
block|}
name|z
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|w
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|k
operator|-=
name|Ebits
operator|+
literal|16
expr_stmt|;
name|setWord0
argument_list|(
operator|&
name|d
argument_list|,
name|Exp_1
operator||
name|y
operator|<<
name|k
operator|+
literal|16
operator||
name|z
operator|<<
name|k
operator||
name|w
operator|>>
literal|16
operator|-
name|k
argument_list|)
expr_stmt|;
name|y
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|d
argument_list|,
name|w
operator|<<
name|k
operator|+
literal|16
operator||
name|y
operator|<<
name|k
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret_d
label|:
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|d2b
specifier|static
name|Bigint
modifier|*
name|d2b
parameter_list|(
name|double
name|d
parameter_list|,
name|int
modifier|*
name|e
parameter_list|,
name|int
modifier|*
name|bits
parameter_list|)
block|{
name|Bigint
modifier|*
name|b
decl_stmt|;
name|int
name|de
decl_stmt|,
name|i
decl_stmt|,
name|k
decl_stmt|;
name|ULong
modifier|*
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
name|b
operator|=
name|Balloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|b
operator|=
name|Balloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|z
operator|=
name|getWord0
argument_list|(
name|d
argument_list|)
operator|&
name|Frac_mask
expr_stmt|;
name|setWord0
argument_list|(
operator|&
name|d
argument_list|,
name|getWord0
argument_list|(
name|d
argument_list|)
operator|&
literal|0x7fffffff
argument_list|)
expr_stmt|;
comment|/* clear sign bit, which we ignore */
ifdef|#
directive|ifdef
name|Sudden_Underflow
name|de
operator|=
call|(
name|int
call|)
argument_list|(
name|getWord0
argument_list|(
name|d
argument_list|)
operator|>>
name|Exp_shift
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IBM
name|z
operator||=
name|Exp_msk11
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
operator|(
name|de
operator|=
name|int
argument_list|(
name|getWord0
argument_list|(
name|d
argument_list|)
operator|>>
name|Exp_shift
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|z
operator||=
name|Exp_msk1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Pack_32
if|if
condition|(
operator|(
name|y
operator|=
name|getWord1
argument_list|(
name|d
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|lo0bits
argument_list|(
operator|&
name|y
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|x
index|[
literal|0
index|]
operator|=
name|y
operator||
name|z
operator|<<
operator|(
literal|32
operator|-
name|k
operator|)
expr_stmt|;
name|z
operator|>>=
name|k
expr_stmt|;
block|}
else|else
name|x
index|[
literal|0
index|]
operator|=
name|y
expr_stmt|;
name|i
operator|=
name|b
operator|->
name|wds
operator|=
operator|(
name|x
index|[
literal|1
index|]
operator|=
name|z
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|BSD_QDTOA_DEBUG
if|if
condition|(
operator|!
name|z
condition|)
name|Bug
argument_list|(
literal|"Zero passed to d2b"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|k
operator|=
name|lo0bits
argument_list|(
operator|&
name|z
argument_list|)
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
name|z
expr_stmt|;
name|i
operator|=
name|b
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
name|k
operator|+=
literal|32
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|y
operator|=
name|getWord1
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
name|k
operator|=
name|lo0bits
argument_list|(
operator|&
name|y
argument_list|)
condition|)
if|if
condition|(
name|k
operator|>=
literal|16
condition|)
block|{
name|x
index|[
literal|0
index|]
operator|=
name|y
operator||
name|z
operator|<<
literal|32
operator|-
name|k
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
name|z
operator|>>
name|k
operator|-
literal|16
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
name|z
operator|>>
name|k
expr_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|x
index|[
literal|0
index|]
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
name|y
operator|>>
literal|16
operator||
name|z
operator|<<
literal|16
operator|-
name|k
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
name|z
operator|>>
name|k
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|3
index|]
operator|=
name|z
operator|>>
name|k
operator|+
literal|16
expr_stmt|;
name|i
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|x
index|[
literal|0
index|]
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
name|z
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|3
index|]
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|i
operator|=
literal|3
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|BSD_QDTOA_DEBUG
if|if
condition|(
operator|!
name|z
condition|)
name|Bug
argument_list|(
literal|"Zero passed to d2b"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|k
operator|=
name|lo0bits
argument_list|(
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>=
literal|16
condition|)
block|{
name|x
index|[
literal|0
index|]
operator|=
name|z
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|x
index|[
literal|0
index|]
operator|=
name|z
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
name|k
operator|+=
literal|32
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|x
index|[
name|i
index|]
condition|)
operator|--
name|i
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|i
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
name|de
condition|)
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
operator|*
name|e
operator|=
operator|(
name|de
operator|-
name|Bias
operator|-
operator|(
name|P
operator|-
literal|1
operator|)
operator|<<
literal|2
operator|)
operator|+
name|k
expr_stmt|;
operator|*
name|bits
operator|=
literal|4
operator|*
name|P
operator|+
literal|8
operator|-
name|k
operator|-
name|hi0bits
argument_list|(
name|getWord0
argument_list|(
name|d
argument_list|)
operator|&
name|Frac_mask
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|e
operator|=
name|de
operator|-
name|Bias
operator|-
operator|(
name|P
operator|-
literal|1
operator|)
operator|+
name|k
expr_stmt|;
operator|*
name|bits
operator|=
name|P
operator|-
name|k
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Sudden_Underflow
block|}
else|else
block|{
operator|*
name|e
operator|=
name|de
operator|-
name|Bias
operator|-
operator|(
name|P
operator|-
literal|1
operator|)
operator|+
literal|1
operator|+
name|k
expr_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
operator|*
name|bits
operator|=
literal|32
operator|*
name|i
operator|-
name|hi0bits
argument_list|(
name|x
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|bits
operator|=
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
literal|16
operator|-
name|hi0bits
argument_list|(
name|x
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
return|return
name|b
return|;
block|}
end_function
begin_function
DECL|function|ratio
specifier|static
name|double
name|ratio
parameter_list|(
name|Bigint
modifier|*
name|a
parameter_list|,
name|Bigint
modifier|*
name|b
parameter_list|)
block|{
name|double
name|da
decl_stmt|,
name|db
decl_stmt|;
name|int
name|k
decl_stmt|,
name|ka
decl_stmt|,
name|kb
decl_stmt|;
name|da
operator|=
name|b2d
argument_list|(
name|a
argument_list|,
operator|&
name|ka
argument_list|)
expr_stmt|;
name|db
operator|=
name|b2d
argument_list|(
name|b
argument_list|,
operator|&
name|kb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
name|k
operator|=
name|ka
operator|-
name|kb
operator|+
literal|32
operator|*
operator|(
name|a
operator|->
name|wds
operator|-
name|b
operator|->
name|wds
operator|)
expr_stmt|;
else|#
directive|else
name|k
operator|=
name|ka
operator|-
name|kb
operator|+
literal|16
operator|*
operator|(
name|a
operator|->
name|wds
operator|-
name|b
operator|->
name|wds
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|setWord0
argument_list|(
operator|&
name|da
argument_list|,
name|getWord0
argument_list|(
name|da
argument_list|)
operator|+
operator|(
name|k
operator|>>
literal|2
operator|)
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|&=
literal|3
condition|)
name|da
operator|*=
literal|1
operator|<<
name|k
expr_stmt|;
block|}
else|else
block|{
name|k
operator|=
operator|-
name|k
expr_stmt|;
name|setWord0
argument_list|(
operator|&
name|db
argument_list|,
name|getWord0
argument_list|(
name|db
argument_list|)
operator|+
operator|(
name|k
operator|>>
literal|2
operator|)
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|&=
literal|3
condition|)
name|db
operator|*=
literal|1
operator|<<
name|k
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|setWord0
argument_list|(
operator|&
name|da
argument_list|,
name|getWord0
argument_list|(
name|da
argument_list|)
operator|+
name|k
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
else|else
block|{
name|k
operator|=
operator|-
name|k
expr_stmt|;
name|setWord0
argument_list|(
operator|&
name|db
argument_list|,
name|getWord0
argument_list|(
name|db
argument_list|)
operator|+
name|k
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|da
operator|/
name|db
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|tens
specifier|static
specifier|const
name|double
name|tens
index|[]
init|=
block|{
literal|1e0
block|,
literal|1e1
block|,
literal|1e2
block|,
literal|1e3
block|,
literal|1e4
block|,
literal|1e5
block|,
literal|1e6
block|,
literal|1e7
block|,
literal|1e8
block|,
literal|1e9
block|,
literal|1e10
block|,
literal|1e11
block|,
literal|1e12
block|,
literal|1e13
block|,
literal|1e14
block|,
literal|1e15
block|,
literal|1e16
block|,
literal|1e17
block|,
literal|1e18
block|,
literal|1e19
block|,
literal|1e20
block|,
literal|1e21
block|,
literal|1e22
ifdef|#
directive|ifdef
name|VAX
block|,
literal|1e23
block|,
literal|1e24
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_Arith
end_ifdef
begin_decl_stmt
DECL|variable|bigtens
specifier|static
specifier|const
name|double
name|bigtens
index|[]
init|=
block|{
literal|1e16
block|,
literal|1e32
block|,
literal|1e64
block|,
literal|1e128
block|,
literal|1e256
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|tinytens
specifier|static
specifier|const
name|double
name|tinytens
index|[]
init|=
block|{
literal|1e-16
block|,
literal|1e-32
block|,
literal|1e-64
block|,
literal|1e-128
block|,
literal|1e-256
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|n_bigtens
define|#
directive|define
name|n_bigtens
value|5
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef
begin_decl_stmt
DECL|variable|bigtens
specifier|static
specifier|const
name|double
name|bigtens
index|[]
init|=
block|{
literal|1e16
block|,
literal|1e32
block|,
literal|1e64
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|tinytens
specifier|static
specifier|const
name|double
name|tinytens
index|[]
init|=
block|{
literal|1e-16
block|,
literal|1e-32
block|,
literal|1e-64
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|n_bigtens
define|#
directive|define
name|n_bigtens
value|3
end_define
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|variable|bigtens
specifier|static
specifier|const
name|double
name|bigtens
index|[]
init|=
block|{
literal|1e16
block|,
literal|1e32
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|tinytens
specifier|static
specifier|const
name|double
name|tinytens
index|[]
init|=
block|{
literal|1e-16
block|,
literal|1e-32
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|n_bigtens
define|#
directive|define
name|n_bigtens
value|2
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*   The pre-release gcc3.3 shipped with SuSE 8.2 has a bug which causes   the comparison 1e-100 == 0.0 to return true. As a workaround, we   compare it to a global variable containing 0.0, which produces   correct assembler output.    ### consider detecting the broken compilers and using the static   ### double for these, and use a #define for all working compilers */
end_comment
begin_decl_stmt
DECL|variable|g_double_zero
specifier|static
name|double
name|g_double_zero
init|=
literal|0.0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qstrtod
name|Q_CORE_EXPORT
name|double
name|qstrtod
parameter_list|(
specifier|const
name|char
modifier|*
name|s00
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|se
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
name|int
name|bb2
decl_stmt|,
name|bb5
decl_stmt|,
name|bbe
decl_stmt|,
name|bd2
decl_stmt|,
name|bd5
decl_stmt|,
name|bbbits
decl_stmt|,
name|bs2
decl_stmt|,
name|c
decl_stmt|,
name|dsign
decl_stmt|,
name|e
decl_stmt|,
name|e1
decl_stmt|,
name|esign
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|nd
decl_stmt|,
name|nd0
decl_stmt|,
name|nf
decl_stmt|,
name|nz
decl_stmt|,
name|nz0
decl_stmt|,
name|sign
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s0
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
name|double
name|aadj
decl_stmt|,
name|aadj1
decl_stmt|,
name|adj
decl_stmt|,
name|rv
decl_stmt|,
name|rv0
decl_stmt|;
name|Long
name|L
decl_stmt|;
name|ULong
name|y
decl_stmt|,
name|z
decl_stmt|;
name|Bigint
modifier|*
name|bb1
decl_stmt|,
modifier|*
name|bd0
decl_stmt|;
name|Bigint
modifier|*
name|bb
init|=
name|NULL
decl_stmt|,
modifier|*
name|bd
init|=
name|NULL
decl_stmt|,
modifier|*
name|bs
init|=
name|NULL
decl_stmt|,
modifier|*
name|delta
init|=
name|NULL
decl_stmt|;
comment|/* pacify gcc */
comment|/*       #ifndef KR_headers       const char decimal_point = localeconv()->decimal_point[0];       #else       const char decimal_point = '.';       #endif */
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
specifier|const
name|char
name|decimal_point
init|=
literal|'.'
decl_stmt|;
name|sign
operator|=
name|nz0
operator|=
name|nz
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
literal|0.
expr_stmt|;
for|for
control|(
name|s
operator|=
name|s00
init|;
name|isspace
argument_list|(
name|uchar
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
block|{
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
name|s
operator|=
name|s00
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
block|{
name|nz0
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|'0'
condition|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
goto|goto
name|ret
goto|;
block|}
name|s0
operator|=
name|s
expr_stmt|;
name|y
operator|=
name|z
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nd
operator|=
name|nf
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|;
name|nd
operator|++
operator|,
name|s
operator|++
control|)
if|if
condition|(
name|nd
operator|<
literal|9
condition|)
name|y
operator|=
literal|10
operator|*
name|y
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<
literal|16
condition|)
name|z
operator|=
literal|10
operator|*
name|z
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|nd0
operator|=
name|nd
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|decimal_point
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|nd
condition|)
block|{
for|for
control|(
init|;
name|c
operator|==
literal|'0'
condition|;
name|c
operator|=
operator|*
operator|++
name|s
control|)
name|nz
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|s0
operator|=
name|s
expr_stmt|;
name|nf
operator|+=
name|nz
expr_stmt|;
name|nz
operator|=
literal|0
expr_stmt|;
goto|goto
name|have_dig
goto|;
block|}
goto|goto
name|dig_done
goto|;
block|}
for|for
control|(
init|;
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|=
operator|*
operator|++
name|s
control|)
block|{
name|have_dig
label|:
name|nz
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|-=
literal|'0'
condition|)
block|{
name|nf
operator|+=
name|nz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nz
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nd
operator|++
operator|<
literal|9
condition|)
name|y
operator|*=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
operator|+
literal|1
condition|)
name|z
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|nd
operator|++
operator|<
literal|9
condition|)
name|y
operator|=
literal|10
operator|*
name|y
operator|+
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
operator|+
literal|1
condition|)
name|z
operator|=
literal|10
operator|*
name|z
operator|+
name|c
expr_stmt|;
name|nz
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|dig_done
label|:
name|e
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
if|if
condition|(
operator|!
name|nd
operator|&&
operator|!
name|nz
operator|&&
operator|!
name|nz0
condition|)
block|{
name|s
operator|=
name|s00
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|s00
operator|=
name|s
expr_stmt|;
name|esign
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'-'
case|:
name|esign
operator|=
literal|1
expr_stmt|;
case|case
literal|'+'
case|:
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'0'
condition|)
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|L
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|s
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|L
operator|=
literal|10
operator|*
name|L
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|s1
operator|>
literal|8
operator|||
name|L
operator|>
literal|19999
condition|)
comment|/* Avoid confusion from exponents                      * so large that e might overflow.                      */
name|e
operator|=
literal|19999
expr_stmt|;
comment|/* safe for 16 bit ints */
else|else
name|e
operator|=
name|int
argument_list|(
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
name|esign
condition|)
name|e
operator|=
operator|-
name|e
expr_stmt|;
block|}
else|else
name|e
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|s
operator|=
name|s00
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nd
condition|)
block|{
if|if
condition|(
operator|!
name|nz
operator|&&
operator|!
name|nz0
condition|)
name|s
operator|=
name|s00
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|e1
operator|=
name|e
operator|-=
name|nf
expr_stmt|;
comment|/* Now we have nd0 digits, starting at s0, followed by a      * decimal point, followed by nd-nd0 digits.  The number we're      * after is the integer represented by those digits times      * 10**e */
if|if
condition|(
operator|!
name|nd0
condition|)
name|nd0
operator|=
name|nd
expr_stmt|;
name|k
operator|=
name|nd
operator|<
name|DBL_DIG
operator|+
literal|1
condition|?
name|nd
else|:
name|DBL_DIG
operator|+
literal|1
expr_stmt|;
name|rv
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|9
condition|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_IRIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
block|{
comment|// work around a bug on 64 bit IRIX gcc
name|double
modifier|*
name|t
init|=
operator|(
name|double
operator|*
operator|)
name|tens
decl_stmt|;
name|rv
operator|=
name|t
index|[
name|k
operator|-
literal|9
index|]
operator|*
name|rv
operator|+
name|z
expr_stmt|;
block|}
else|#
directive|else
name|rv
operator|=
name|tens
index|[
name|k
operator|-
literal|9
index|]
operator|*
name|rv
operator|+
name|z
expr_stmt|;
endif|#
directive|endif
name|bd0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
ifndef|#
directive|ifndef
name|RND_PRODQUOT
operator|&&
name|FLT_ROUNDS
operator|==
literal|1
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
operator|!
name|e
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
name|e
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|<=
name|Ten_pmax
condition|)
block|{
ifdef|#
directive|ifdef
name|VAX
goto|goto
name|vax_ovfl_check
goto|;
else|#
directive|else
comment|/* rv = */
name|rounded_product
argument_list|(
name|rv
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
endif|#
directive|endif
block|}
name|i
operator|=
name|DBL_DIG
operator|-
name|nd
expr_stmt|;
if|if
condition|(
name|e
operator|<=
name|Ten_pmax
operator|+
name|i
condition|)
block|{
comment|/* A fancier test would sometimes let us do                  * this for larger i values.                  */
name|e
operator|-=
name|i
expr_stmt|;
name|rv
operator|*=
name|tens
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|VAX
comment|/* VAX exponent range is so narrow we must                  * worry about overflow here...                  */
name|vax_ovfl_check
label|:
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|-
name|P
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
comment|/* rv = */
name|rounded_product
argument_list|(
name|rv
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|-
name|P
operator|)
condition|)
goto|goto
name|ovfl
goto|;
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|+
name|P
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* rv = */
name|rounded_product
argument_list|(
name|rv
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|ret
goto|;
block|}
block|}
ifndef|#
directive|ifndef
name|Inaccurate_Divide
elseif|else
if|if
condition|(
name|e
operator|>=
operator|-
name|Ten_pmax
condition|)
block|{
comment|/* rv = */
name|rounded_quotient
argument_list|(
name|rv
argument_list|,
name|tens
index|[
operator|-
name|e
index|]
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
endif|#
directive|endif
block|}
name|e1
operator|+=
name|nd
operator|-
name|k
expr_stmt|;
comment|/* Get starting approximation = rv * 10**e1 */
if|if
condition|(
name|e1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|e1
operator|&
literal|15
operator|)
operator|!=
literal|0
condition|)
name|rv
operator|*=
name|tens
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e1
operator|&=
operator|~
literal|15
condition|)
block|{
if|if
condition|(
name|e1
operator|>
name|DBL_MAX_10_EXP
condition|)
block|{
name|ovfl
label|:
comment|//                                errno = ERANGE;
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
ifdef|#
directive|ifdef
name|__STDC__
name|rv
operator|=
name|HUGE_VAL
expr_stmt|;
else|#
directive|else
comment|/* Can't trust HUGE_VAL */
ifdef|#
directive|ifdef
name|IEEE_Arith
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|Exp_mask
argument_list|)
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|rv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|Big0
argument_list|)
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|rv
argument_list|,
name|Big1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|bd0
condition|)
goto|goto
name|retfree
goto|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|e1
operator|>>=
literal|4
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|1
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|rv
operator|*=
name|bigtens
index|[
name|j
index|]
expr_stmt|;
comment|/* The last multiplication could overflow. */
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|-
name|P
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
name|rv
operator|*=
name|bigtens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|=
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
name|P
operator|)
condition|)
goto|goto
name|ovfl
goto|;
if|if
condition|(
name|z
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|-
name|P
operator|)
condition|)
block|{
comment|/* set to largest number */
comment|/* (Can't trust DBL_MAX) */
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|Big0
argument_list|)
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|rv
argument_list|,
name|Big1
argument_list|)
expr_stmt|;
block|}
else|else
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|+
name|P
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|e1
operator|<
literal|0
condition|)
block|{
name|e1
operator|=
operator|-
name|e1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|e1
operator|&
literal|15
operator|)
operator|!=
literal|0
condition|)
name|rv
operator|/=
name|tens
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e1
operator|&=
operator|~
literal|15
condition|)
block|{
name|e1
operator|>>=
literal|4
expr_stmt|;
if|if
condition|(
name|e1
operator|>=
literal|1
operator|<<
name|n_bigtens
condition|)
goto|goto
name|undfl
goto|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|1
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|rv
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
comment|/* The last multiplication could underflow. */
name|rv0
operator|=
name|rv
expr_stmt|;
name|rv
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|g_double_zero
condition|)
block|{
name|rv
operator|=
literal|2.
operator|*
name|rv0
expr_stmt|;
name|rv
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|g_double_zero
condition|)
block|{
name|undfl
label|:
name|rv
operator|=
literal|0.
expr_stmt|;
comment|//                                        errno = ERANGE;
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|bd0
condition|)
goto|goto
name|retfree
goto|;
goto|goto
name|ret
goto|;
block|}
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|Tiny0
argument_list|)
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|rv
argument_list|,
name|Tiny1
argument_list|)
expr_stmt|;
comment|/* The refinement below will clean                      * this approximation up.                      */
block|}
block|}
block|}
comment|/* Now the hard part -- adjusting rv to the correct value.*/
comment|/* Put digits into bd: true value = bd * 10^e */
name|bd0
operator|=
name|s2b
argument_list|(
name|s0
argument_list|,
name|nd0
argument_list|,
name|nd
argument_list|,
name|y
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bd
operator|=
name|Balloc
argument_list|(
name|bd0
operator|->
name|k
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|bd
argument_list|,
name|bd0
argument_list|)
expr_stmt|;
name|bb
operator|=
name|d2b
argument_list|(
name|rv
argument_list|,
operator|&
name|bbe
argument_list|,
operator|&
name|bbbits
argument_list|)
expr_stmt|;
comment|/* rv = bb * 2^bbe */
name|bs
operator|=
name|i2b
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|>=
literal|0
condition|)
block|{
name|bb2
operator|=
name|bb5
operator|=
literal|0
expr_stmt|;
name|bd2
operator|=
name|bd5
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|bb2
operator|=
name|bb5
operator|=
operator|-
name|e
expr_stmt|;
name|bd2
operator|=
name|bd5
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bbe
operator|>=
literal|0
condition|)
name|bb2
operator|+=
name|bbe
expr_stmt|;
else|else
name|bd2
operator|-=
name|bbe
expr_stmt|;
name|bs2
operator|=
name|bb2
expr_stmt|;
ifdef|#
directive|ifdef
name|Sudden_Underflow
ifdef|#
directive|ifdef
name|IBM
name|j
operator|=
literal|1
operator|+
literal|4
operator|*
name|P
operator|-
literal|3
operator|-
name|bbbits
operator|+
operator|(
operator|(
name|bbe
operator|+
name|bbbits
operator|-
literal|1
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
else|#
directive|else
name|j
operator|=
name|P
operator|+
literal|1
operator|-
name|bbbits
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|i
operator|=
name|bbe
operator|+
name|bbbits
operator|-
literal|1
expr_stmt|;
comment|/* logb(rv) */
if|if
condition|(
name|i
operator|<
name|Emin
condition|)
comment|/* denormal */
name|j
operator|=
name|bbe
operator|+
operator|(
name|P
operator|-
name|Emin
operator|)
expr_stmt|;
else|else
name|j
operator|=
name|P
operator|+
literal|1
operator|-
name|bbbits
expr_stmt|;
endif|#
directive|endif
name|bb2
operator|+=
name|j
expr_stmt|;
name|bd2
operator|+=
name|j
expr_stmt|;
name|i
operator|=
name|bb2
operator|<
name|bd2
condition|?
name|bb2
else|:
name|bd2
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|bs2
condition|)
name|i
operator|=
name|bs2
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|bb2
operator|-=
name|i
expr_stmt|;
name|bd2
operator|-=
name|i
expr_stmt|;
name|bs2
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bb5
operator|>
literal|0
condition|)
block|{
name|bs
operator|=
name|pow5mult
argument_list|(
name|bs
argument_list|,
name|bb5
argument_list|)
expr_stmt|;
name|bb1
operator|=
name|mult
argument_list|(
name|bs
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bb
operator|=
name|bb1
expr_stmt|;
block|}
if|if
condition|(
name|bb2
operator|>
literal|0
condition|)
name|bb
operator|=
name|lshift
argument_list|(
name|bb
argument_list|,
name|bb2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd5
operator|>
literal|0
condition|)
name|bd
operator|=
name|pow5mult
argument_list|(
name|bd
argument_list|,
name|bd5
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd2
operator|>
literal|0
condition|)
name|bd
operator|=
name|lshift
argument_list|(
name|bd
argument_list|,
name|bd2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs2
operator|>
literal|0
condition|)
name|bs
operator|=
name|lshift
argument_list|(
name|bs
argument_list|,
name|bs2
argument_list|)
expr_stmt|;
name|delta
operator|=
name|diff
argument_list|(
name|bb
argument_list|,
name|bd
argument_list|)
expr_stmt|;
name|dsign
operator|=
name|delta
operator|->
name|sign
expr_stmt|;
name|delta
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Error is less than half an ulp -- check for              * special case of mantissa a power of two.              */
if|if
condition|(
name|dsign
operator|||
name|getWord1
argument_list|(
name|rv
argument_list|)
operator|||
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
condition|)
break|break;
name|delta
operator|=
name|lshift
argument_list|(
name|delta
argument_list|,
name|Log2P
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|drop_down
goto|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* exactly half-way between */
if|if
condition|(
name|dsign
condition|)
block|{
if|if
condition|(
operator|(
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask1
operator|)
operator|==
name|Bndry_mask1
operator|&&
name|getWord1
argument_list|(
name|rv
argument_list|)
operator|==
literal|0xffffffff
condition|)
block|{
comment|/*boundary case -- increment exponent*/
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
operator|(
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|+
name|Exp_msk1
ifdef|#
directive|ifdef
name|IBM
operator||
name|Exp_msk1
operator|>>
literal|4
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|rv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
operator|)
operator|&&
operator|!
name|getWord1
argument_list|(
name|rv
argument_list|)
condition|)
block|{
name|drop_down
label|:
comment|/* boundary case -- decrement exponent */
ifdef|#
directive|ifdef
name|Sudden_Underflow
name|L
operator|=
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
name|L
operator|<
name|Exp_msk1
condition|)
else|#
directive|else
if|if
condition|(
name|L
operator|<=
name|Exp_msk1
condition|)
endif|#
directive|endif
goto|goto
name|undfl
goto|;
name|L
operator|-=
name|Exp_msk1
expr_stmt|;
else|#
directive|else
name|L
operator|=
operator|(
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|-
name|Exp_msk1
expr_stmt|;
endif|#
directive|endif
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|L
operator||
name|Bndry_mask1
argument_list|)
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|rv
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
goto|goto
name|cont
goto|;
else|#
directive|else
break|break;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|ROUND_BIASED
if|if
condition|(
operator|!
operator|(
name|getWord1
argument_list|(
name|rv
argument_list|)
operator|&
name|LSB
operator|)
condition|)
break|break;
endif|#
directive|endif
if|if
condition|(
name|dsign
condition|)
name|rv
operator|+=
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ROUND_BIASED
else|else
block|{
name|rv
operator|-=
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
name|rv
operator|==
name|g_double_zero
condition|)
goto|goto
name|undfl
goto|;
endif|#
directive|endif
block|}
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
operator|(
name|aadj
operator|=
name|ratio
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|)
operator|<=
literal|2.
condition|)
block|{
if|if
condition|(
name|dsign
condition|)
name|aadj
operator|=
name|aadj1
operator|=
literal|1.
expr_stmt|;
elseif|else
if|if
condition|(
name|getWord1
argument_list|(
name|rv
argument_list|)
operator|||
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
condition|)
block|{
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
name|getWord1
argument_list|(
name|rv
argument_list|)
operator|==
name|Tiny1
operator|&&
operator|!
name|getWord0
argument_list|(
name|rv
argument_list|)
condition|)
goto|goto
name|undfl
goto|;
endif|#
directive|endif
name|aadj
operator|=
literal|1.
expr_stmt|;
name|aadj1
operator|=
operator|-
literal|1.
expr_stmt|;
block|}
else|else
block|{
comment|/* special case -- power of FLT_RADIX to be */
comment|/* rounded down... */
if|if
condition|(
name|aadj
operator|<
literal|2.
operator|/
name|FLT_RADIX
condition|)
name|aadj
operator|=
literal|1.
operator|/
name|FLT_RADIX
expr_stmt|;
else|else
name|aadj
operator|*=
literal|0.5
expr_stmt|;
name|aadj1
operator|=
operator|-
name|aadj
expr_stmt|;
block|}
block|}
else|else
block|{
name|aadj
operator|*=
literal|0.5
expr_stmt|;
name|aadj1
operator|=
name|dsign
condition|?
name|aadj
else|:
operator|-
name|aadj
expr_stmt|;
ifdef|#
directive|ifdef
name|Check_FLT_ROUNDS
switch|switch
condition|(
name|FLT_ROUNDS
condition|)
block|{
case|case
literal|2
case|:
comment|/* towards +infinity */
name|aadj1
operator|-=
literal|0.5
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* towards 0 */
case|case
literal|3
case|:
comment|/* towards -infinity */
name|aadj1
operator|+=
literal|0.5
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|FLT_ROUNDS
operator|==
literal|0
condition|)
name|aadj1
operator|+=
literal|0.5
expr_stmt|;
endif|#
directive|endif
block|}
name|y
operator|=
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
comment|/* Check for overflow */
if|if
condition|(
name|y
operator|==
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|)
condition|)
block|{
name|rv0
operator|=
name|rv
expr_stmt|;
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|-
name|P
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|+=
name|adj
expr_stmt|;
if|if
condition|(
operator|(
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>=
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
name|P
operator|)
condition|)
block|{
if|if
condition|(
name|getWord0
argument_list|(
name|rv0
argument_list|)
operator|==
name|Big0
operator|&&
name|getWord1
argument_list|(
name|rv0
argument_list|)
operator|==
name|Big1
condition|)
goto|goto
name|ovfl
goto|;
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|Big0
argument_list|)
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|rv
argument_list|,
name|Big1
argument_list|)
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
else|else
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|+
name|P
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|Sudden_Underflow
if|if
condition|(
operator|(
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
block|{
name|rv0
operator|=
name|rv
expr_stmt|;
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|+
name|P
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|+=
name|adj
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
operator|(
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<
name|P
operator|*
name|Exp_msk1
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|getWord0
argument_list|(
name|rv0
argument_list|)
operator|==
name|Tiny0
operator|&&
name|getWord1
argument_list|(
name|rv0
argument_list|)
operator|==
name|Tiny1
condition|)
goto|goto
name|undfl
goto|;
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|Tiny0
argument_list|)
expr_stmt|;
name|setWord1
argument_list|(
operator|&
name|rv
argument_list|,
name|Tiny1
argument_list|)
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
else|else
name|setWord0
argument_list|(
operator|&
name|rv
argument_list|,
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|-
name|P
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|+=
name|adj
expr_stmt|;
block|}
else|#
directive|else
comment|/* Compute adj so that the IEEE rounding rules will              * correctly round rv + adj in some half-way cases.              * If rv * ulp(rv) is denormalized (i.e.,              * y<= (P-1)*Exp_msk1), we must adjust aadj to avoid              * trouble from bits lost to denormalization;              * example: 1.2e-307 .              */
if|if
condition|(
name|y
operator|<=
operator|(
name|P
operator|-
literal|1
operator|)
operator|*
name|Exp_msk1
operator|&&
name|aadj
operator|>=
literal|1.
condition|)
block|{
name|aadj1
operator|=
name|int
argument_list|(
name|aadj
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsign
condition|)
name|aadj1
operator|=
operator|-
name|aadj1
expr_stmt|;
block|}
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|+=
name|adj
expr_stmt|;
endif|#
directive|endif
block|}
name|z
operator|=
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|z
condition|)
block|{
comment|/* Can we stop now? */
name|L
operator|=
name|Long
argument_list|(
name|aadj
argument_list|)
expr_stmt|;
name|aadj
operator|-=
name|L
expr_stmt|;
comment|/* The tolerances below are conservative. */
if|if
condition|(
name|dsign
operator|||
name|getWord1
argument_list|(
name|rv
argument_list|)
operator|||
name|getWord0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
condition|)
block|{
if|if
condition|(
name|aadj
argument_list|<
literal|.4999999
operator|||
name|aadj
argument_list|>
literal|.5000001
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|aadj
operator|<
literal|.4999999
operator|/
name|FLT_RADIX
condition|)
break|break;
block|}
name|cont
label|:
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
name|retfree
label|:
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bd0
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|ret
label|:
if|if
condition|(
name|se
condition|)
operator|*
name|se
operator|=
name|s
expr_stmt|;
return|return
name|sign
condition|?
operator|-
name|rv
else|:
name|rv
return|;
block|}
end_function
begin_function
DECL|function|quorem
specifier|static
name|int
name|quorem
parameter_list|(
name|Bigint
modifier|*
name|b
parameter_list|,
name|Bigint
modifier|*
name|S
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|Long
name|borrow
decl_stmt|,
name|y
decl_stmt|;
name|ULong
name|carry
decl_stmt|,
name|q
decl_stmt|,
name|ys
decl_stmt|;
name|ULong
modifier|*
name|bx
decl_stmt|,
modifier|*
name|bxe
decl_stmt|,
modifier|*
name|sx
decl_stmt|,
modifier|*
name|sxe
decl_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
name|Long
name|z
decl_stmt|;
name|ULong
name|si
decl_stmt|,
name|zs
decl_stmt|;
endif|#
directive|endif
name|n
operator|=
name|S
operator|->
name|wds
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD_QDTOA_DEBUG
comment|/*debug*/
if|if
condition|(
name|b
operator|->
name|wds
operator|>
name|n
condition|)
comment|/*debug*/
name|Bug
argument_list|(
literal|"oversize b in quorem"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|b
operator|->
name|wds
operator|<
name|n
condition|)
return|return
literal|0
return|;
name|sx
operator|=
name|S
operator|->
name|x
expr_stmt|;
name|sxe
operator|=
name|sx
operator|+
operator|--
name|n
expr_stmt|;
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|bxe
operator|=
name|bx
operator|+
name|n
expr_stmt|;
name|q
operator|=
operator|*
name|bxe
operator|/
operator|(
operator|*
name|sxe
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* ensure q<= true quotient */
ifdef|#
directive|ifdef
name|BSD_QDTOA_DEBUG
comment|/*debug*/
if|if
condition|(
name|q
operator|>
literal|9
condition|)
comment|/*debug*/
name|Bug
argument_list|(
literal|"oversized quotient in quorem"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|q
condition|)
block|{
name|borrow
operator|=
literal|0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|Pack_32
name|si
operator|=
operator|*
name|sx
operator|++
expr_stmt|;
name|ys
operator|=
operator|(
name|si
operator|&
literal|0xffff
operator|)
operator|*
name|q
operator|+
name|carry
expr_stmt|;
name|zs
operator|=
operator|(
name|si
operator|>>
literal|16
operator|)
operator|*
name|q
operator|+
operator|(
name|ys
operator|>>
literal|16
operator|)
expr_stmt|;
name|carry
operator|=
name|zs
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|(
operator|*
name|bx
operator|&
literal|0xffff
operator|)
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|bx
operator|>>
literal|16
operator|)
operator|-
operator|(
name|zs
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|Storeinc
argument_list|(
name|bx
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|#
directive|else
name|ys
operator|=
operator|*
name|sx
operator|++
operator|*
name|q
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|ys
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|*
name|bx
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|bx
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
name|sx
operator|<=
name|sxe
condition|)
do|;
if|if
condition|(
operator|!
operator|*
name|bxe
condition|)
block|{
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
while|while
condition|(
operator|--
name|bxe
operator|>
name|bx
operator|&&
operator|!
operator|*
name|bxe
condition|)
operator|--
name|n
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|q
operator|++
expr_stmt|;
name|borrow
operator|=
literal|0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|sx
operator|=
name|S
operator|->
name|x
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|Pack_32
name|si
operator|=
operator|*
name|sx
operator|++
expr_stmt|;
name|ys
operator|=
operator|(
name|si
operator|&
literal|0xffff
operator|)
operator|+
name|carry
expr_stmt|;
name|zs
operator|=
operator|(
name|si
operator|>>
literal|16
operator|)
operator|+
operator|(
name|ys
operator|>>
literal|16
operator|)
expr_stmt|;
name|carry
operator|=
name|zs
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|(
operator|*
name|bx
operator|&
literal|0xffff
operator|)
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|bx
operator|>>
literal|16
operator|)
operator|-
operator|(
name|zs
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|Storeinc
argument_list|(
name|bx
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|#
directive|else
name|ys
operator|=
operator|*
name|sx
operator|++
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|ys
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|*
name|bx
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|bx
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
name|sx
operator|<=
name|sxe
condition|)
do|;
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|bxe
operator|=
name|bx
operator|+
name|n
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|bxe
condition|)
block|{
while|while
condition|(
operator|--
name|bxe
operator|>
name|bx
operator|&&
operator|!
operator|*
name|bxe
condition|)
operator|--
name|n
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|n
expr_stmt|;
block|}
block|}
return|return
name|q
return|;
block|}
end_function
begin_comment
comment|/* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.  *  * Inspired by "How to Print Floating-Point Numbers Accurately" by  * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 92-101].  *  * Modifications:  *        1. Rather than iterating, we use a simple numeric overestimate  *           to determine k = floor(log10(d)).  We scale relevant  *           quantities using O(log2(k)) rather than O(k) multiplications.  *        2. For some modes> 2 (corresponding to ecvt and fcvt), we don't  *           try to generate digits strictly left to right.  Instead, we  *           compute with fewer bits and propagate the carry if necessary  *           when rounding the final digit up.  This is often faster.  *        3. Under the assumption that input will be rounded nearest,  *           mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.  *           That is, we allow equality in stopping tests when the  *           round-nearest rule will give the same floating-point value  *           as would satisfaction of the stopping test with strict  *           inequality.  *        4. We remove common factors of powers of 2 from relevant  *           quantities.  *        5. When converting floating-point integers less than 1e16,  *           we use floating-point arithmetic rather than resorting  *           to multiple-precision integers.  *        6. When asked to produce fewer than 15 digits, we first try  *           to get by with floating-point arithmetic; we resort to  *           multiple-precision integer arithmetic only if we cannot  *           guarantee that the floating-point calculation has given  *           the correctly rounded result.  For k requested digits and  *           "uniformly" distributed input, the probability is  *           something like 10^(k-15) that we must resort to the Long  *           calculation.  */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_clear87
argument_list|)
end_if
begin_comment
comment|// See QTBUG-7576
end_comment
begin_extern
extern|extern
literal|"C"
block|{
name|__attribute__
argument_list|(
argument|(dllimport)
argument_list|)
name|unsigned
name|int
name|__cdecl
name|__MINGW_NOTHROW
name|_control87
parameter_list|(
name|unsigned
name|int
name|unNew
parameter_list|,
name|unsigned
name|int
name|unMask
parameter_list|)
function_decl|;
name|__attribute__
argument_list|(
argument|(dllimport)
argument_list|)
name|unsigned
name|int
name|__cdecl
name|__MINGW_NOTHROW
name|_clearfp
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Clear the FPU status word */
block|}
end_extern
begin_define
DECL|macro|_clear87
define|#
directive|define
name|_clear87
value|_clearfp
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* This actually sometimes returns a pointer to a string literal    cast to a char*. Do NOT try to modify the return value. */
end_comment
begin_function
DECL|function|qdtoa
name|Q_CORE_EXPORT
name|char
modifier|*
name|qdtoa
parameter_list|(
name|double
name|d
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|ndigits
parameter_list|,
name|int
modifier|*
name|decpt
parameter_list|,
name|int
modifier|*
name|sign
parameter_list|,
name|char
modifier|*
modifier|*
name|rve
parameter_list|,
name|char
modifier|*
modifier|*
name|resultp
parameter_list|)
block|{
comment|// Some values of the floating-point control word can cause _qdtoa to crash with an underflow.
comment|// We set a safe value here.
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|_clear87
argument_list|()
expr_stmt|;
name|unsigned
name|int
name|oldbits
init|=
name|_control87
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|MCW_EM
ifdef|#
directive|ifdef
name|_MCW_EM
DECL|macro|MCW_EM
define|#
directive|define
name|MCW_EM
value|_MCW_EM
else|#
directive|else
define|#
directive|define
name|MCW_EM
value|0x0008001F
endif|#
directive|endif
endif|#
directive|endif
name|_control87
argument_list|(
name|MCW_EM
argument_list|,
name|MCW_EM
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__UCLIBC__
argument_list|)
name|fenv_t
name|envp
decl_stmt|;
name|feholdexcept
argument_list|(
operator|&
name|envp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|s
init|=
name|_qdtoa
argument_list|(
name|d
argument_list|,
name|mode
argument_list|,
name|ndigits
argument_list|,
name|decpt
argument_list|,
name|sign
argument_list|,
name|rve
argument_list|,
name|resultp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|_clear87
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|_M_X64
name|_control87
argument_list|(
name|oldbits
argument_list|,
literal|0xFFFFF
argument_list|)
expr_stmt|;
else|#
directive|else
name|_control87
argument_list|(
name|oldbits
argument_list|,
name|_MCW_EM
operator||
name|_MCW_DN
operator||
name|_MCW_RC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//_M_X64
endif|#
directive|endif
comment|//Q_OS_WIN
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__UCLIBC__
argument_list|)
name|fesetenv
argument_list|(
operator|&
name|envp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|_qdtoa
specifier|static
name|char
modifier|*
name|_qdtoa
parameter_list|(
name|NEEDS_VOLATILE
name|double
name|d
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|ndigits
parameter_list|,
name|int
modifier|*
name|decpt
parameter_list|,
name|int
modifier|*
name|sign
parameter_list|,
name|char
modifier|*
modifier|*
name|rve
parameter_list|,
name|char
modifier|*
modifier|*
name|resultp
parameter_list|)
block|{
comment|/*       Arguments ndigits, decpt, sign are similar to those       of ecvt and fcvt; trailing zeros are suppressed from       the returned string.  If not null, *rve is set to point       to the end of the return value.  If d is +-Infinity or NaN,       then *decpt is set to 9999.        mode:       0 ==> shortest string that yields d when read in       and rounded to nearest.       1 ==> like 0, but with Steele& White stopping rule;       e.g. with IEEE P754 arithmetic , mode 0 gives       1e23 whereas mode 1 gives 9.999999999999999e22.       2 ==> max(1,ndigits) significant digits.  This gives a       return value similar to that of ecvt, except       that trailing zeros are suppressed.       3 ==> through ndigits past the decimal point.  This       gives a return value similar to that from fcvt,       except that trailing zeros are suppressed, and       ndigits can be negative.       4-9 should give the same return values as 2-3, i.e.,       4<= mode<= 9 ==> same return as mode       2 + (mode& 1).  These modes are mainly for       debugging; often they run slower but sometimes       faster than modes 2-3.       4,5,8,9 ==> left-to-right digit generation.       6-9 ==> don't try fast floating-point estimate       (if applicable).        Values of mode other than 0-9 are treated as mode 0.        Sufficient space is allocated to the return value       to hold the suppressed trailing zeros.     */
name|int
name|bbits
decl_stmt|,
name|b2
decl_stmt|,
name|b5
decl_stmt|,
name|be
decl_stmt|,
name|dig
decl_stmt|,
name|i
decl_stmt|,
name|ieps
decl_stmt|,
name|ilim0
decl_stmt|,
name|j
decl_stmt|,
name|j1
decl_stmt|,
name|k
decl_stmt|,
name|k0
decl_stmt|,
name|k_check
decl_stmt|,
name|leftright
decl_stmt|,
name|m2
decl_stmt|,
name|m5
decl_stmt|,
name|s2
decl_stmt|,
name|s5
decl_stmt|,
name|try_quick
decl_stmt|;
name|int
name|ilim
init|=
literal|0
decl_stmt|,
name|ilim1
init|=
literal|0
decl_stmt|,
name|spec_case
init|=
literal|0
decl_stmt|;
comment|/* pacify gcc */
name|Long
name|L
decl_stmt|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
name|int
name|denorm
decl_stmt|;
name|ULong
name|x
decl_stmt|;
endif|#
directive|endif
name|Bigint
modifier|*
name|b
decl_stmt|,
modifier|*
name|b1
decl_stmt|,
modifier|*
name|delta
decl_stmt|,
modifier|*
name|mhi
decl_stmt|,
modifier|*
name|S
decl_stmt|;
name|Bigint
modifier|*
name|mlo
init|=
name|NULL
decl_stmt|;
comment|/* pacify gcc */
name|double
name|d2
decl_stmt|;
name|double
name|ds
decl_stmt|,
name|eps
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s0
decl_stmt|;
if|if
condition|(
name|getWord0
argument_list|(
name|d
argument_list|)
operator|&
name|Sign_bit
condition|)
block|{
comment|/* set sign for everything, including 0's and NaNs */
operator|*
name|sign
operator|=
literal|1
expr_stmt|;
name|setWord0
argument_list|(
operator|&
name|d
argument_list|,
name|getWord0
argument_list|(
name|d
argument_list|)
operator|&
operator|~
name|Sign_bit
argument_list|)
expr_stmt|;
comment|/* clear sign bit */
block|}
else|else
operator|*
name|sign
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IEEE_Arith
argument_list|)
operator|+
name|defined
argument_list|(
name|VAX
argument_list|)
ifdef|#
directive|ifdef
name|IEEE_Arith
if|if
condition|(
operator|(
name|getWord0
argument_list|(
name|d
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|==
name|Exp_mask
condition|)
else|#
directive|else
if|if
condition|(
name|getWord0
argument_list|(
name|d
argument_list|)
operator|==
literal|0x8000
condition|)
endif|#
directive|endif
block|{
comment|/* Infinity or NaN */
operator|*
name|decpt
operator|=
literal|9999
expr_stmt|;
name|s
operator|=
ifdef|#
directive|ifdef
name|IEEE_Arith
operator|!
name|getWord1
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
operator|(
name|getWord0
argument_list|(
name|d
argument_list|)
operator|&
literal|0xfffff
operator|)
condition|?
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
literal|"Infinity"
argument_list|)
else|:
endif|#
directive|endif
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
literal|"NaN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rve
condition|)
operator|*
name|rve
operator|=
ifdef|#
directive|ifdef
name|IEEE_Arith
name|s
index|[
literal|3
index|]
condition|?
name|s
operator|+
literal|8
else|:
endif|#
directive|endif
name|s
operator|+
literal|3
expr_stmt|;
return|return
name|s
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
name|d
operator|+=
literal|0
expr_stmt|;
comment|/* normalize */
endif|#
directive|endif
if|if
condition|(
name|d
operator|==
name|g_double_zero
condition|)
block|{
operator|*
name|decpt
operator|=
literal|1
expr_stmt|;
name|s
operator|=
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rve
condition|)
operator|*
name|rve
operator|=
name|s
operator|+
literal|1
expr_stmt|;
return|return
name|s
return|;
block|}
name|b
operator|=
name|d2b
argument_list|(
name|d
argument_list|,
operator|&
name|be
argument_list|,
operator|&
name|bbits
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Sudden_Underflow
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|getWord0
argument_list|(
name|d
argument_list|)
operator|>>
name|Exp_shift1
operator|&
operator|(
name|Exp_mask
operator|>>
name|Exp_shift1
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|i
operator|=
name|int
argument_list|(
name|getWord0
argument_list|(
name|d
argument_list|)
operator|>>
name|Exp_shift1
operator|&
operator|(
name|Exp_mask
operator|>>
name|Exp_shift1
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
endif|#
directive|endif
name|d2
operator|=
name|d
expr_stmt|;
name|setWord0
argument_list|(
operator|&
name|d2
argument_list|,
name|getWord0
argument_list|(
name|d2
argument_list|)
operator|&
name|Frac_mask1
argument_list|)
expr_stmt|;
name|setWord0
argument_list|(
operator|&
name|d2
argument_list|,
name|getWord0
argument_list|(
name|d2
argument_list|)
operator||
name|Exp_11
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
name|j
operator|=
literal|11
operator|-
name|hi0bits
argument_list|(
name|getWord0
argument_list|(
name|d2
argument_list|)
operator|&
name|Frac_mask
argument_list|)
condition|)
name|d2
operator|/=
literal|1
operator|<<
name|j
expr_stmt|;
endif|#
directive|endif
comment|/* log(x)        ~=~ log(1.5) + (x-1.5)/1.5          * log10(x)         =  log(x) / log(10)          *                ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))          * log10(d) = (i-Bias)*log(2)/log(10) + log10(d2)          *          * This suggests computing an approximation k to log10(d) by          *          * k = (i - Bias)*0.301029995663981          *        + ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );          *          * We want k to be too large rather than too small.          * The error in the first-order Taylor series approximation          * is in our favor, so we just round up the constant enough          * to compensate for any error in the multiplication of          * (i - Bias) by 0.301029995663981; since |i - Bias|<= 1077,          * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,          * adding 1e-13 to the constant term more than suffices.          * Hence we adjust the constant term to 0.1760912590558.          * (We could get a more accurate k by invoking log10,          *  but this is probably not worthwhile.)          */
name|i
operator|-=
name|Bias
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
name|i
operator|<<=
literal|2
expr_stmt|;
name|i
operator|+=
name|j
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Sudden_Underflow
name|denorm
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* d is denormalized */
name|i
operator|=
name|bbits
operator|+
name|be
operator|+
operator|(
name|Bias
operator|+
operator|(
name|P
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|x
operator|=
name|i
operator|>
literal|32
condition|?
name|getWord0
argument_list|(
name|d
argument_list|)
operator|<<
operator|(
literal|64
operator|-
name|i
operator|)
operator||
name|getWord1
argument_list|(
name|d
argument_list|)
operator|>>
operator|(
name|i
operator|-
literal|32
operator|)
else|:
name|getWord1
argument_list|(
name|d
argument_list|)
operator|<<
operator|(
literal|32
operator|-
name|i
operator|)
expr_stmt|;
name|d2
operator|=
name|x
expr_stmt|;
name|setWord0
argument_list|(
operator|&
name|d2
argument_list|,
name|getWord0
argument_list|(
name|d2
argument_list|)
operator|-
literal|31
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
comment|/* adjust exponent */
name|i
operator|-=
operator|(
name|Bias
operator|+
operator|(
name|P
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|denorm
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|ds
operator|=
operator|(
name|d2
operator|-
literal|1.5
operator|)
operator|*
literal|0.289529654602168
operator|+
literal|0.1760912590558
operator|+
name|i
operator|*
literal|0.301029995663981
expr_stmt|;
name|k
operator|=
name|int
argument_list|(
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|<
literal|0.
operator|&&
name|ds
operator|!=
name|k
condition|)
name|k
operator|--
expr_stmt|;
comment|/* want k = floor(ds) */
name|k_check
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|>=
literal|0
operator|&&
name|k
operator|<=
name|Ten_pmax
condition|)
block|{
if|if
condition|(
name|d
operator|<
name|tens
index|[
name|k
index|]
condition|)
name|k
operator|--
expr_stmt|;
name|k_check
operator|=
literal|0
expr_stmt|;
block|}
name|j
operator|=
name|bbits
operator|-
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
name|b2
operator|=
literal|0
expr_stmt|;
name|s2
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
name|b2
operator|=
operator|-
name|j
expr_stmt|;
name|s2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|>=
literal|0
condition|)
block|{
name|b5
operator|=
literal|0
expr_stmt|;
name|s5
operator|=
name|k
expr_stmt|;
name|s2
operator|+=
name|k
expr_stmt|;
block|}
else|else
block|{
name|b2
operator|-=
name|k
expr_stmt|;
name|b5
operator|=
operator|-
name|k
expr_stmt|;
name|s5
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mode
argument_list|<
literal|0
operator|||
name|mode
argument_list|>
literal|9
condition|)
name|mode
operator|=
literal|0
expr_stmt|;
name|try_quick
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mode
operator|>
literal|5
condition|)
block|{
name|mode
operator|-=
literal|4
expr_stmt|;
name|try_quick
operator|=
literal|0
expr_stmt|;
block|}
name|leftright
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ilim
operator|=
name|ilim1
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|18
expr_stmt|;
name|ndigits
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|leftright
operator|=
literal|0
expr_stmt|;
comment|/* no break */
case|case
literal|4
case|:
if|if
condition|(
name|ndigits
operator|<=
literal|0
condition|)
name|ndigits
operator|=
literal|1
expr_stmt|;
name|ilim
operator|=
name|ilim1
operator|=
name|i
operator|=
name|ndigits
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|leftright
operator|=
literal|0
expr_stmt|;
comment|/* no break */
case|case
literal|5
case|:
name|i
operator|=
name|ndigits
operator|+
name|k
operator|+
literal|1
expr_stmt|;
name|ilim
operator|=
name|i
expr_stmt|;
name|ilim1
operator|=
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
block|}
name|QT_TRY
block|{
operator|*
name|resultp
operator|=
cast|static_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|malloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
operator|*
name|resultp
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
name|s
operator|=
name|s0
operator|=
operator|*
name|resultp
expr_stmt|;
if|if
condition|(
name|ilim
operator|>=
literal|0
operator|&&
name|ilim
operator|<=
name|Quick_max
operator|&&
name|try_quick
condition|)
block|{
comment|/* Try to get by with floating-point arithmetic. */
name|i
operator|=
literal|0
expr_stmt|;
name|d2
operator|=
name|d
expr_stmt|;
name|k0
operator|=
name|k
expr_stmt|;
name|ilim0
operator|=
name|ilim
expr_stmt|;
name|ieps
operator|=
literal|2
expr_stmt|;
comment|/* conservative */
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|ds
operator|=
name|tens
index|[
name|k
operator|&
literal|0xf
index|]
expr_stmt|;
name|j
operator|=
name|k
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|Bletch
condition|)
block|{
comment|/* prevent overflows */
name|j
operator|&=
name|Bletch
operator|-
literal|1
expr_stmt|;
name|d
operator|/=
name|bigtens
index|[
name|n_bigtens
operator|-
literal|1
index|]
expr_stmt|;
name|ieps
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|j
condition|;
name|j
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|j
operator|&
literal|1
condition|)
block|{
name|ieps
operator|++
expr_stmt|;
name|ds
operator|*=
name|bigtens
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
operator|/=
name|ds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|j1
operator|=
operator|-
name|k
operator|)
operator|!=
literal|0
condition|)
block|{
name|d
operator|*=
name|tens
index|[
name|j1
operator|&
literal|0xf
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|j1
operator|>>
literal|4
init|;
name|j
condition|;
name|j
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|j
operator|&
literal|1
condition|)
block|{
name|ieps
operator|++
expr_stmt|;
name|d
operator|*=
name|bigtens
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k_check
operator|&&
name|d
argument_list|<
literal|1.
operator|&&
name|ilim
argument_list|>
literal|0
condition|)
block|{
if|if
condition|(
name|ilim1
operator|<=
literal|0
condition|)
goto|goto
name|fast_failed
goto|;
name|ilim
operator|=
name|ilim1
expr_stmt|;
name|k
operator|--
expr_stmt|;
name|d
operator|*=
literal|10.
expr_stmt|;
name|ieps
operator|++
expr_stmt|;
block|}
name|eps
operator|=
name|ieps
operator|*
name|d
operator|+
literal|7.
expr_stmt|;
name|setWord0
argument_list|(
operator|&
name|eps
argument_list|,
name|getWord0
argument_list|(
name|eps
argument_list|)
operator|-
operator|(
name|P
operator|-
literal|1
operator|)
operator|*
name|Exp_msk1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilim
operator|==
literal|0
condition|)
block|{
name|S
operator|=
name|mhi
operator|=
literal|0
expr_stmt|;
name|d
operator|-=
literal|5.
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|eps
condition|)
goto|goto
name|one_digit
goto|;
if|if
condition|(
name|d
operator|<
operator|-
name|eps
condition|)
goto|goto
name|no_digits
goto|;
goto|goto
name|fast_failed
goto|;
block|}
ifndef|#
directive|ifndef
name|No_leftright
if|if
condition|(
name|leftright
condition|)
block|{
comment|/* Use Steele& White method of only              * generating digits needed.              */
name|eps
operator|=
literal|0.5
operator|/
name|tens
index|[
name|ilim
operator|-
literal|1
index|]
operator|-
name|eps
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|L
operator|=
name|Long
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|-=
name|L
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
name|int
argument_list|(
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|eps
condition|)
goto|goto
name|ret1
goto|;
if|if
condition|(
literal|1.
operator|-
name|d
operator|<
name|eps
condition|)
goto|goto
name|bump_up
goto|;
if|if
condition|(
operator|++
name|i
operator|>=
name|ilim
condition|)
break|break;
name|eps
operator|*=
literal|10.
expr_stmt|;
name|d
operator|*=
literal|10.
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* Generate ilim digits, then fix them up. */
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_IRIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
comment|// work around a bug on 64 bit IRIX gcc
name|double
modifier|*
name|t
init|=
operator|(
name|double
operator|*
operator|)
name|tens
decl_stmt|;
name|eps
operator|*=
name|t
index|[
name|ilim
operator|-
literal|1
index|]
expr_stmt|;
else|#
directive|else
name|eps
operator|*=
name|tens
index|[
name|ilim
operator|-
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
operator|,
name|d
operator|*=
literal|10.
control|)
block|{
name|L
operator|=
name|Long
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|-=
name|L
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
name|int
argument_list|(
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ilim
condition|)
block|{
if|if
condition|(
name|d
operator|>
literal|0.5
operator|+
name|eps
condition|)
goto|goto
name|bump_up
goto|;
elseif|else
if|if
condition|(
name|d
operator|<
literal|0.5
operator|-
name|eps
condition|)
block|{
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'0'
condition|)
block|{}
name|s
operator|++
expr_stmt|;
goto|goto
name|ret1
goto|;
block|}
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|No_leftright
block|}
endif|#
directive|endif
name|fast_failed
label|:
name|s
operator|=
name|s0
expr_stmt|;
name|d
operator|=
name|d2
expr_stmt|;
name|k
operator|=
name|k0
expr_stmt|;
name|ilim
operator|=
name|ilim0
expr_stmt|;
block|}
comment|/* Do we have a "small" integer? */
if|if
condition|(
name|be
operator|>=
literal|0
operator|&&
name|k
operator|<=
name|Int_max
condition|)
block|{
comment|/* Yes. */
name|ds
operator|=
name|tens
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|ndigits
operator|<
literal|0
operator|&&
name|ilim
operator|<=
literal|0
condition|)
block|{
name|S
operator|=
name|mhi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ilim
operator|<
literal|0
operator|||
name|d
operator|<=
literal|5
operator|*
name|ds
condition|)
goto|goto
name|no_digits
goto|;
goto|goto
name|one_digit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
name|L
operator|=
name|Long
argument_list|(
name|d
operator|/
name|ds
argument_list|)
expr_stmt|;
name|d
operator|-=
name|L
operator|*
name|ds
expr_stmt|;
ifdef|#
directive|ifdef
name|Check_FLT_ROUNDS
comment|/* If FLT_ROUNDS == 2, L will usually be high by 1 */
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
name|L
operator|--
expr_stmt|;
name|d
operator|+=
name|ds
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
name|int
argument_list|(
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ilim
condition|)
block|{
name|d
operator|+=
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|ds
operator|||
operator|(
name|d
operator|==
name|ds
operator|&&
name|L
operator|&
literal|1
operator|)
condition|)
block|{
name|bump_up
label|:
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'9'
condition|)
if|if
condition|(
name|s
operator|==
name|s0
condition|)
block|{
name|k
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'0'
expr_stmt|;
break|break;
block|}
operator|++
operator|*
name|s
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|d
operator|*=
literal|10.
operator|)
operator|==
name|g_double_zero
condition|)
break|break;
block|}
goto|goto
name|ret1
goto|;
block|}
name|m2
operator|=
name|b2
expr_stmt|;
name|m5
operator|=
name|b5
expr_stmt|;
name|mhi
operator|=
name|mlo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|leftright
condition|)
block|{
if|if
condition|(
name|mode
operator|<
literal|2
condition|)
block|{
name|i
operator|=
ifndef|#
directive|ifndef
name|Sudden_Underflow
name|denorm
condition|?
name|be
operator|+
operator|(
name|Bias
operator|+
operator|(
name|P
operator|-
literal|1
operator|)
operator|-
literal|1
operator|+
literal|1
operator|)
else|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
literal|1
operator|+
literal|4
operator|*
name|P
operator|-
literal|3
operator|-
name|bbits
operator|+
operator|(
operator|(
name|bbits
operator|+
name|be
operator|-
literal|1
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
else|#
directive|else
literal|1
operator|+
name|P
operator|-
name|bbits
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|j
operator|=
name|ilim
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|m5
operator|>=
name|j
condition|)
name|m5
operator|-=
name|j
expr_stmt|;
else|else
block|{
name|s5
operator|+=
name|j
operator|-=
name|m5
expr_stmt|;
name|b5
operator|+=
name|j
expr_stmt|;
name|m5
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|ilim
operator|)
operator|<
literal|0
condition|)
block|{
name|m2
operator|-=
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|b2
operator|+=
name|i
expr_stmt|;
name|s2
operator|+=
name|i
expr_stmt|;
name|mhi
operator|=
name|i2b
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m2
operator|>
literal|0
operator|&&
name|s2
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|m2
operator|<
name|s2
condition|?
name|m2
else|:
name|s2
expr_stmt|;
name|b2
operator|-=
name|i
expr_stmt|;
name|m2
operator|-=
name|i
expr_stmt|;
name|s2
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|b5
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|leftright
condition|)
block|{
if|if
condition|(
name|m5
operator|>
literal|0
condition|)
block|{
name|mhi
operator|=
name|pow5mult
argument_list|(
name|mhi
argument_list|,
name|m5
argument_list|)
expr_stmt|;
name|b1
operator|=
name|mult
argument_list|(
name|mhi
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|b1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|j
operator|=
name|b5
operator|-
name|m5
operator|)
operator|!=
literal|0
condition|)
name|b
operator|=
name|pow5mult
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|=
name|pow5mult
argument_list|(
name|b
argument_list|,
name|b5
argument_list|)
expr_stmt|;
block|}
name|S
operator|=
name|i2b
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s5
operator|>
literal|0
condition|)
name|S
operator|=
name|pow5mult
argument_list|(
name|S
argument_list|,
name|s5
argument_list|)
expr_stmt|;
comment|/* Check for special case that d is a normalized power of 2. */
if|if
condition|(
name|mode
operator|<
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|getWord1
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
operator|(
name|getWord0
argument_list|(
name|d
argument_list|)
operator|&
name|Bndry_mask
operator|)
ifndef|#
directive|ifndef
name|Sudden_Underflow
operator|&&
name|getWord0
argument_list|(
name|d
argument_list|)
operator|&
name|Exp_mask
endif|#
directive|endif
condition|)
block|{
comment|/* The special case */
name|b2
operator|+=
name|Log2P
expr_stmt|;
name|s2
operator|+=
name|Log2P
expr_stmt|;
name|spec_case
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|spec_case
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Arrange for convenient computation of quotients:      * shift left if necessary so divisor has 4 leading 0 bits.      *      * Perhaps we should just compute leading 28 bits of S once      * and for all and pass them and a shift to quorem, so it      * can do shifts and ors to compute the numerator for q.      */
ifdef|#
directive|ifdef
name|Pack_32
if|if
condition|(
operator|(
name|i
operator|=
operator|(
operator|(
name|s5
condition|?
literal|32
operator|-
name|hi0bits
argument_list|(
name|S
operator|->
name|x
index|[
name|S
operator|->
name|wds
operator|-
literal|1
index|]
argument_list|)
else|:
literal|1
operator|)
operator|+
name|s2
operator|)
operator|&
literal|0x1f
operator|)
operator|!=
literal|0
condition|)
name|i
operator|=
literal|32
operator|-
name|i
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|i
operator|=
operator|(
operator|(
name|s5
condition|?
literal|32
operator|-
name|hi0bits
argument_list|(
name|S
operator|->
name|x
index|[
name|S
operator|->
name|wds
operator|-
literal|1
index|]
argument_list|)
else|:
literal|1
operator|)
operator|+
name|s2
operator|)
operator|&
literal|0xf
condition|)
name|i
operator|=
literal|16
operator|-
name|i
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|>
literal|4
condition|)
block|{
name|i
operator|-=
literal|4
expr_stmt|;
name|b2
operator|+=
name|i
expr_stmt|;
name|m2
operator|+=
name|i
expr_stmt|;
name|s2
operator|+=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
literal|4
condition|)
block|{
name|i
operator|+=
literal|28
expr_stmt|;
name|b2
operator|+=
name|i
expr_stmt|;
name|m2
operator|+=
name|i
expr_stmt|;
name|s2
operator|+=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|b2
operator|>
literal|0
condition|)
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
name|b2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|>
literal|0
condition|)
name|S
operator|=
name|lshift
argument_list|(
name|S
argument_list|,
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|k_check
condition|)
block|{
if|if
condition|(
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|<
literal|0
condition|)
block|{
name|k
operator|--
expr_stmt|;
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we botched the k estimate */
if|if
condition|(
name|leftright
condition|)
name|mhi
operator|=
name|multadd
argument_list|(
name|mhi
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ilim
operator|=
name|ilim1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ilim
operator|<=
literal|0
operator|&&
name|mode
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|ilim
operator|<
literal|0
operator|||
name|cmp
argument_list|(
name|b
argument_list|,
name|S
operator|=
name|multadd
argument_list|(
name|S
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|/* no digits, fcvt style */
name|no_digits
label|:
name|k
operator|=
operator|-
literal|1
operator|-
name|ndigits
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|one_digit
label|:
operator|*
name|s
operator|++
operator|=
literal|'1'
expr_stmt|;
name|k
operator|++
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|leftright
condition|)
block|{
if|if
condition|(
name|m2
operator|>
literal|0
condition|)
name|mhi
operator|=
name|lshift
argument_list|(
name|mhi
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|/* Compute mlo -- check for special case          * that d is a normalized power of 2.          */
name|mlo
operator|=
name|mhi
expr_stmt|;
if|if
condition|(
name|spec_case
condition|)
block|{
name|mhi
operator|=
name|Balloc
argument_list|(
name|mhi
operator|->
name|k
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|mhi
argument_list|,
name|mlo
argument_list|)
expr_stmt|;
name|mhi
operator|=
name|lshift
argument_list|(
name|mhi
argument_list|,
name|Log2P
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
name|dig
operator|=
name|quorem
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|+
literal|'0'
expr_stmt|;
comment|/* Do we yet have the shortest decimal string              * that will round to d?              */
name|j
operator|=
name|cmp
argument_list|(
name|b
argument_list|,
name|mlo
argument_list|)
expr_stmt|;
name|delta
operator|=
name|diff
argument_list|(
name|S
argument_list|,
name|mhi
argument_list|)
expr_stmt|;
name|j1
operator|=
name|delta
operator|->
name|sign
condition|?
literal|1
else|:
name|cmp
argument_list|(
name|b
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ROUND_BIASED
if|if
condition|(
name|j1
operator|==
literal|0
operator|&&
operator|!
name|mode
operator|&&
operator|!
operator|(
name|getWord1
argument_list|(
name|d
argument_list|)
operator|&
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|dig
operator|==
literal|'9'
condition|)
goto|goto
name|round_9_up
goto|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|dig
operator|++
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|j
operator|<
literal|0
operator|||
operator|(
name|j
operator|==
literal|0
operator|&&
operator|!
name|mode
ifndef|#
directive|ifndef
name|ROUND_BIASED
operator|&&
operator|!
operator|(
name|getWord1
argument_list|(
name|d
argument_list|)
operator|&
literal|1
operator|)
endif|#
directive|endif
operator|)
condition|)
block|{
if|if
condition|(
name|j1
operator|>
literal|0
condition|)
block|{
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|j1
operator|=
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j1
operator|>
literal|0
operator|||
operator|(
name|j1
operator|==
literal|0
operator|&&
name|dig
operator|&
literal|1
operator|)
operator|)
operator|&&
name|dig
operator|++
operator|==
literal|'9'
condition|)
goto|goto
name|round_9_up
goto|;
block|}
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|j1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|dig
operator|==
literal|'9'
condition|)
block|{
comment|/* possible if i == 1 */
name|round_9_up
label|:
operator|*
name|s
operator|++
operator|=
literal|'9'
expr_stmt|;
goto|goto
name|roundoff
goto|;
block|}
operator|*
name|s
operator|++
operator|=
name|dig
operator|+
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ilim
condition|)
break|break;
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlo
operator|==
name|mhi
condition|)
name|mlo
operator|=
name|mhi
operator|=
name|multadd
argument_list|(
name|mhi
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|mlo
operator|=
name|multadd
argument_list|(
name|mlo
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mhi
operator|=
name|multadd
argument_list|(
name|mhi
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|s
operator|++
operator|=
name|dig
operator|=
name|quorem
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|+
literal|'0'
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|ilim
condition|)
break|break;
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Round off last digit */
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|j
operator|=
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
operator|||
operator|(
name|j
operator|==
literal|0
operator|&&
name|dig
operator|&
literal|1
operator|)
condition|)
block|{
name|roundoff
label|:
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'9'
condition|)
if|if
condition|(
name|s
operator|==
name|s0
condition|)
block|{
name|k
operator|++
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'1'
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
operator|++
operator|*
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'0'
condition|)
block|{}
name|s
operator|++
expr_stmt|;
block|}
name|ret
label|:
name|Bfree
argument_list|(
name|S
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhi
condition|)
block|{
if|if
condition|(
name|mlo
operator|&&
name|mlo
operator|!=
name|mhi
condition|)
name|Bfree
argument_list|(
name|mlo
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|mhi
argument_list|)
expr_stmt|;
block|}
name|ret1
label|:
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|s0
condition|)
block|{
comment|/* don't return empty string */
operator|*
name|s
operator|++
operator|=
literal|'0'
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|0
expr_stmt|;
operator|*
name|decpt
operator|=
name|k
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rve
condition|)
operator|*
name|rve
operator|=
name|s
expr_stmt|;
return|return
name|s0
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|// NOT thread safe!
end_comment
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_function
DECL|function|qdtoa
name|Q_CORE_EXPORT
name|char
modifier|*
name|qdtoa
parameter_list|(
name|double
name|d
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|ndigits
parameter_list|,
name|int
modifier|*
name|decpt
parameter_list|,
name|int
modifier|*
name|sign
parameter_list|,
name|char
modifier|*
modifier|*
name|rve
parameter_list|,
name|char
modifier|*
modifier|*
name|resultp
parameter_list|)
block|{
if|if
condition|(
name|rve
condition|)
operator|*
name|rve
operator|=
literal|0
expr_stmt|;
name|char
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|ndigits
operator|=
literal|80
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|3
condition|)
name|res
operator|=
name|fcvt
argument_list|(
name|d
argument_list|,
name|ndigits
argument_list|,
name|decpt
argument_list|,
name|sign
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|ecvt
argument_list|(
name|d
argument_list|,
name|ndigits
argument_list|,
name|decpt
argument_list|,
name|sign
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|qstrlen
argument_list|(
name|res
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
block|{
comment|// remove trailing 0's
specifier|const
name|int
name|stop
init|=
name|qMax
argument_list|(
literal|1
argument_list|,
operator|*
name|decpt
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>=
name|stop
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|res
index|[
name|i
index|]
operator|!=
literal|'0'
condition|)
break|break;
block|}
name|n
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
operator|*
name|resultp
operator|=
cast|static_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|malloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|resultp
argument_list|)
expr_stmt|;
name|qstrncpy
argument_list|(
operator|*
name|resultp
argument_list|,
name|res
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|*
name|resultp
return|;
block|}
end_function
begin_function
DECL|function|qstrtod
name|Q_CORE_EXPORT
name|double
name|qstrtod
parameter_list|(
specifier|const
name|char
modifier|*
name|s00
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|se
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
name|double
name|ret
init|=
name|strtod
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s00
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|se
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|==
literal|0.0l
operator|&&
name|errno
operator|==
name|ERANGE
operator|)
operator|||
name|ret
operator|==
name|HUGE_VAL
operator|||
name|ret
operator|==
operator|-
name|HUGE_VAL
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
else|else
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
comment|// the result will be that we don't report underflow in this case
block|}
return|return
name|ret
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_QLOCALE_USES_FCVT
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
