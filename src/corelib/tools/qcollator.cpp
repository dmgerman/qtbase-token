begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qcollator.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QT_USE_ICU
end_ifdef
begin_include
include|#
directive|include
file|<unicode/utypes.h>
end_include
begin_include
include|#
directive|include
file|<unicode/ucol.h>
end_include
begin_include
include|#
directive|include
file|<unicode/ustring.h>
end_include
begin_include
include|#
directive|include
file|<unicode/ures.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QCollatorPrivate
class|class
name|QCollatorPrivate
block|{
public|public:
DECL|member|ref
name|QAtomicInt
name|ref
decl_stmt|;
DECL|member|locale
name|QLocale
name|locale
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_USE_ICU
DECL|member|collator
name|UCollator
modifier|*
name|collator
decl_stmt|;
else|#
directive|else
DECL|member|collator
name|void
modifier|*
name|collator
decl_stmt|;
endif|#
directive|endif
DECL|function|clear
name|void
name|clear
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_USE_ICU
if|if
condition|(
name|collator
condition|)
name|ucol_close
argument_list|(
name|collator
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|collator
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|QCollatorPrivate
name|QCollatorPrivate
parameter_list|()
member_init_list|:
name|ref
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|collator
argument_list|(
literal|0
argument_list|)
block|{     }
name|~
name|QCollatorPrivate
parameter_list|()
destructor_decl|;
name|void
name|init
parameter_list|()
function_decl|;
private|private:
name|Q_DISABLE_COPY
argument_list|(
argument|QCollatorPrivate
argument_list|)
block|}
class|;
end_class
begin_class
DECL|class|QCollatorSortKeyPrivate
class|class
name|QCollatorSortKeyPrivate
super|:
specifier|public
name|QSharedData
block|{
friend|friend
class_decl|class
name|QCollator
class_decl|;
public|public:
DECL|function|QCollatorSortKeyPrivate
name|QCollatorSortKeyPrivate
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|key
parameter_list|)
member_init_list|:
name|QSharedData
argument_list|()
member_init_list|,
name|m_key
argument_list|(
name|key
argument_list|)
block|{     }
DECL|member|m_key
name|QByteArray
name|m_key
decl_stmt|;
private|private:
name|Q_DISABLE_COPY
argument_list|(
argument|QCollatorSortKeyPrivate
argument_list|)
block|}
class|;
end_class
begin_destructor
DECL|function|~QCollatorPrivate
name|QCollatorPrivate
operator|::
name|~
name|QCollatorPrivate
parameter_list|()
block|{
name|clear
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \class QCollator     \inmodule QtCore     \brief The QCollator class compares strings according to a localized collation algorithm.      \since 5.2      \reentrant     \ingroup i18n     \ingroup string-processing     \ingroup shared      QCollator is initialized with a QLocale and an optional collation strategy. It tries to     initialize the collator with the specified values. The collator can then be used to compare     and sort strings in a locale dependent fashion.      A QCollator object can be used together with template based sorting algorithms such as std::sort     to sort a list of QStrings.      In addition to the locale and collation strategy, several optional flags can be set that influence     the result of the collation.      QCollator currently depends on Qt being compiled with ICU support enabled. */
end_comment
begin_comment
comment|/*!     Constructs a QCollator from \a locale. If \a locale is not specified QLocale::default()     is being used.      \sa setLocale()  */
end_comment
begin_constructor
DECL|function|QCollator
name|QCollator
operator|::
name|QCollator
parameter_list|(
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QCollatorPrivate
argument_list|)
block|{
name|d
operator|->
name|locale
operator|=
name|locale
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a copy of \a other.  */
end_comment
begin_constructor
DECL|function|QCollator
name|QCollator
operator|::
name|QCollator
parameter_list|(
specifier|const
name|QCollator
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the collator.  */
end_comment
begin_destructor
DECL|function|~QCollator
name|QCollator
operator|::
name|~
name|QCollator
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Assigns \a other to this collator.  */
end_comment
begin_function
DECL|function|operator =
name|QCollator
modifier|&
name|QCollator
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QCollator
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|!=
operator|&
name|other
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|init
name|void
name|QCollatorPrivate
operator|::
name|init
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QT_USE_ICU
name|UErrorCode
name|status
init|=
name|U_ZERO_ERROR
decl_stmt|;
name|QByteArray
name|name
init|=
name|locale
operator|.
name|bcp47Name
argument_list|()
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
decl_stmt|;
name|collator
operator|=
name|ucol_open
argument_list|(
name|name
operator|.
name|constData
argument_list|()
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|U_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"Could not create collator: %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|// enable normalization by default
name|ucol_setAttribute
argument_list|(
name|collator
argument_list|,
name|UCOL_NORMALIZATION_MODE
argument_list|,
name|UCOL_ON
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|detach
name|void
name|QCollator
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|QCollatorPrivate
modifier|*
name|x
init|=
operator|new
name|QCollatorPrivate
decl_stmt|;
name|x
operator|->
name|ref
operator|.
name|store
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|x
operator|->
name|locale
operator|=
name|d
operator|->
name|locale
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Sets the locale of the collator to \a locale.  */
end_comment
begin_function
DECL|function|setLocale
name|void
name|QCollator
operator|::
name|setLocale
parameter_list|(
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|locale
operator|=
name|locale
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the locale of the collator.  */
end_comment
begin_function
DECL|function|locale
name|QLocale
name|QCollator
operator|::
name|locale
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|locale
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the case \a cs of the collator.  */
end_comment
begin_function
DECL|function|setCaseSensitivity
name|void
name|QCollator
operator|::
name|setCaseSensitivity
parameter_list|(
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
name|detach
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_USE_ICU
name|UColAttributeValue
name|val
init|=
operator|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
operator|)
condition|?
name|UCOL_UPPER_FIRST
else|:
name|UCOL_OFF
decl_stmt|;
name|UErrorCode
name|status
init|=
name|U_ZERO_ERROR
decl_stmt|;
name|ucol_setAttribute
argument_list|(
name|d
operator|->
name|collator
argument_list|,
name|UCOL_CASE_FIRST
argument_list|,
name|val
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|U_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"ucol_setAttribute: Case First failed: %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|cs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Returns case preference of the collator.  */
end_comment
begin_function
DECL|function|caseSensitivity
name|Qt
operator|::
name|CaseSensitivity
name|QCollator
operator|::
name|caseSensitivity
parameter_list|()
specifier|const
block|{
ifdef|#
directive|ifdef
name|QT_USE_ICU
name|UErrorCode
name|status
init|=
name|U_ZERO_ERROR
decl_stmt|;
name|UColAttributeValue
name|attribute
init|=
name|ucol_getAttribute
argument_list|(
name|d
operator|->
name|collator
argument_list|,
name|UCOL_CASE_FIRST
argument_list|,
operator|&
name|status
argument_list|)
decl_stmt|;
return|return
operator|(
name|attribute
operator|==
name|UCOL_OFF
operator|)
condition|?
name|Qt
operator|::
name|CaseInsensitive
else|:
name|Qt
operator|::
name|CaseSensitive
return|;
endif|#
directive|endif
return|return
name|Qt
operator|::
name|CaseSensitive
return|;
block|}
end_function
begin_comment
comment|/*!     Enables numeric sorting mode when \a on is set to true.      This will enable proper sorting of numeric digits, so that e.g. 100 sorts after 99.      By default this mode is off.  */
end_comment
begin_function
DECL|function|setNumericMode
name|void
name|QCollator
operator|::
name|setNumericMode
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
name|detach
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_USE_ICU
name|UErrorCode
name|status
init|=
name|U_ZERO_ERROR
decl_stmt|;
name|ucol_setAttribute
argument_list|(
name|d
operator|->
name|collator
argument_list|,
name|UCOL_NUMERIC_COLLATION
argument_list|,
name|on
condition|?
name|UCOL_ON
else|:
name|UCOL_OFF
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|U_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"ucol_setAttribute: numeric collation failed: %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|on
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Returns true if numeric sorting is enabled, false otherwise.      \sa setNumericMode()  */
end_comment
begin_function
DECL|function|numericMode
name|bool
name|QCollator
operator|::
name|numericMode
parameter_list|()
specifier|const
block|{
ifdef|#
directive|ifdef
name|QT_USE_ICU
name|UErrorCode
name|status
decl_stmt|;
if|if
condition|(
name|ucol_getAttribute
argument_list|(
name|d
operator|->
name|collator
argument_list|,
name|UCOL_NUMERIC_COLLATION
argument_list|,
operator|&
name|status
argument_list|)
operator|==
name|UCOL_ON
condition|)
return|return
literal|true
return|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     If \a on is set to true, punctuation characters and symbols are ignored when determining sort order.      The default is locale dependent.  */
end_comment
begin_function
DECL|function|setIgnorePunctuation
name|void
name|QCollator
operator|::
name|setIgnorePunctuation
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|!=
literal|1
condition|)
name|detach
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_USE_ICU
name|UErrorCode
name|status
decl_stmt|;
name|ucol_setAttribute
argument_list|(
name|d
operator|->
name|collator
argument_list|,
name|UCOL_ALTERNATE_HANDLING
argument_list|,
name|on
condition|?
name|UCOL_SHIFTED
else|:
name|UCOL_NON_IGNORABLE
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|U_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"ucol_setAttribute: Alternate handling failed: %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|on
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Returns true if punctuation characters and symbols are ignored when determining sort order.      \sa setIgnorePunctuation()  */
end_comment
begin_function
DECL|function|ignorePunctuation
name|bool
name|QCollator
operator|::
name|ignorePunctuation
parameter_list|()
specifier|const
block|{
ifdef|#
directive|ifdef
name|QT_USE_ICU
name|UErrorCode
name|status
decl_stmt|;
if|if
condition|(
name|ucol_getAttribute
argument_list|(
name|d
operator|->
name|collator
argument_list|,
name|UCOL_ALTERNATE_HANDLING
argument_list|,
operator|&
name|status
argument_list|)
operator|==
name|UCOL_SHIFTED
condition|)
return|return
literal|true
return|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Compares \a s1 with \a s2. Returns -1, 0 or 1 depending on whether \a s1 is     smaller, equal or larger than \a s2.  */
end_comment
begin_function
DECL|function|compare
name|int
name|QCollator
operator|::
name|compare
parameter_list|(
specifier|const
name|QString
modifier|&
name|s1
parameter_list|,
specifier|const
name|QString
modifier|&
name|s2
parameter_list|)
specifier|const
block|{
return|return
name|compare
argument_list|(
name|s1
operator|.
name|constData
argument_list|()
argument_list|,
name|s1
operator|.
name|size
argument_list|()
argument_list|,
name|s2
operator|.
name|constData
argument_list|()
argument_list|,
name|s2
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Compares \a s1 with \a s2. Returns -1, 0 or 1 depending on whether \a s1 is     smaller, equal or larger than \a s2.  */
end_comment
begin_function
DECL|function|compare
name|int
name|QCollator
operator|::
name|compare
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|s1
parameter_list|,
specifier|const
name|QStringRef
modifier|&
name|s2
parameter_list|)
specifier|const
block|{
return|return
name|compare
argument_list|(
name|s1
operator|.
name|constData
argument_list|()
argument_list|,
name|s1
operator|.
name|size
argument_list|()
argument_list|,
name|s2
operator|.
name|constData
argument_list|()
argument_list|,
name|s2
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Compares \a s1 with \a s2. \a len1 and \a len2 specify the length of the     QChar arrays pointer to by \a s1 and \a s2.      Returns -1, 0 or 1 depending on whether \a s1 is smaller, equal or larger than \a s2.  */
end_comment
begin_function
DECL|function|compare
name|int
name|QCollator
operator|::
name|compare
parameter_list|(
specifier|const
name|QChar
modifier|*
name|s1
parameter_list|,
name|int
name|len1
parameter_list|,
specifier|const
name|QChar
modifier|*
name|s2
parameter_list|,
name|int
name|len2
parameter_list|)
specifier|const
block|{
ifdef|#
directive|ifdef
name|QT_USE_ICU
specifier|const
name|UCollationResult
name|result
init|=
name|ucol_strcoll
argument_list|(
name|d
operator|->
name|collator
argument_list|,
operator|(
specifier|const
name|UChar
operator|*
operator|)
name|s1
argument_list|,
name|len1
argument_list|,
operator|(
specifier|const
name|UChar
operator|*
operator|)
name|s2
argument_list|,
name|len2
argument_list|)
decl_stmt|;
return|return
name|result
return|;
else|#
directive|else
return|return
name|QString
operator|::
name|compare_helper
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|s1
argument_list|,
name|len1
argument_list|,
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|s2
argument_list|,
name|len2
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Returns a sortKey for \a string.      Creating the sort key is usually somewhat slower, than using the compare()     methods directly. But if the string is compared repeatedly (e.g. when sorting     a whole list of strings), it's usually faster to create the sort keys for each     string and then sort using the keys.  */
end_comment
begin_function
DECL|function|sortKey
name|QCollatorSortKey
name|QCollator
operator|::
name|sortKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|string
parameter_list|)
specifier|const
block|{
name|QByteArray
name|key
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_USE_ICU
name|QByteArray
name|result
argument_list|(
literal|16
operator|+
name|string
operator|.
name|size
argument_list|()
operator|+
operator|(
name|string
operator|.
name|size
argument_list|()
operator|>>
literal|2
operator|)
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|ucol_getSortKey
argument_list|(
name|d
operator|->
name|collator
argument_list|,
operator|(
specifier|const
name|UChar
operator|*
operator|)
name|string
operator|.
name|constData
argument_list|()
argument_list|,
name|string
operator|.
name|size
argument_list|()
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|result
operator|.
name|data
argument_list|()
argument_list|,
name|result
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|result
operator|.
name|size
argument_list|()
condition|)
block|{
name|result
operator|.
name|resize
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
name|ucol_getSortKey
argument_list|(
name|d
operator|->
name|collator
argument_list|,
operator|(
specifier|const
name|UChar
operator|*
operator|)
name|string
operator|.
name|constData
argument_list|()
argument_list|,
name|string
operator|.
name|size
argument_list|()
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|result
operator|.
name|data
argument_list|()
argument_list|,
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|truncate
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|key
operator|=
name|result
expr_stmt|;
else|#
directive|else
name|key
operator|=
name|string
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|QCollatorSortKey
argument_list|(
operator|new
name|QCollatorSortKeyPrivate
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QCollator::operator()(const QString&s1, const QString&s2) const     \internal */
end_comment
begin_comment
comment|/*!     \class QCollatorSortKey     \inmodule QtCore     \brief The QCollatorSortKey class can be used to speed up string collation.      \since 5.2      The QCollatorSortKey class is always created by QCollator::sortKey()     and is used for fast strings collation, for example when collating many strings.      \reentrant     \ingroup i18n     \ingroup string-processing     \ingroup shared      \sa QCollator, QCollator::sortKey() */
end_comment
begin_comment
comment|/*!     \internal  */
end_comment
begin_constructor
DECL|function|QCollatorSortKey
name|QCollatorSortKey
operator|::
name|QCollatorSortKey
parameter_list|(
name|QCollatorSortKeyPrivate
modifier|*
name|d
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a copy of the \a other collator sorting key.  */
end_comment
begin_constructor
DECL|function|QCollatorSortKey
name|QCollatorSortKey
operator|::
name|QCollatorSortKey
parameter_list|(
specifier|const
name|QCollatorSortKey
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the collator key.  */
end_comment
begin_destructor
DECL|function|~QCollatorSortKey
name|QCollatorSortKey
operator|::
name|~
name|QCollatorSortKey
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Assigns \a other to this collator key.  */
end_comment
begin_function
DECL|function|operator =
name|QCollatorSortKey
modifier|&
name|QCollatorSortKey
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QCollatorSortKey
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|!=
operator|&
name|other
condition|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     According to the QCollator that created the key, returns true if the     key should be sorted before than \a otherKey; otherwise returns false.      \sa compare()  */
end_comment
begin_function
DECL|function|operator <
name|bool
name|QCollatorSortKey
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QCollatorSortKey
modifier|&
name|otherKey
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|m_key
operator|<
name|otherKey
operator|.
name|d
operator|->
name|m_key
return|;
block|}
end_function
begin_comment
comment|/*!     Compares the key to \a otherKey. Returns a negative value if the key     is less than \a otherKey, 0 if the key is equal to \a otherKey or a     positive value if the key is greater than \a otherKey.      \sa operator<()  */
end_comment
begin_function
DECL|function|compare
name|int
name|QCollatorSortKey
operator|::
name|compare
parameter_list|(
specifier|const
name|QCollatorSortKey
modifier|&
name|otherKey
parameter_list|)
specifier|const
block|{
return|return
name|qstrcmp
argument_list|(
name|d
operator|->
name|m_key
argument_list|,
name|otherKey
operator|.
name|d
operator|->
name|m_key
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
