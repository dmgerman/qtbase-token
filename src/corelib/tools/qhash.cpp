begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Copyright (C) 2012 Giuseppe D'Angelo<dangelog@gmail.com>. ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|// for rand_s, _CRT_RAND_S must be #defined before #including stdlib.h.
end_comment
begin_comment
comment|// put it at the beginning so some indirect inclusion doesn't break it
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_CRT_RAND_S
end_ifndef
begin_define
DECL|macro|_CRT_RAND_S
define|#
directive|define
name|_CRT_RAND_S
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|truncate
end_ifdef
begin_undef
DECL|macro|truncate
undef|#
directive|undef
name|truncate
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<qbitarray.h>
end_include
begin_include
include|#
directive|include
file|<qstring.h>
end_include
begin_include
include|#
directive|include
file|<qglobal.h>
end_include
begin_include
include|#
directive|include
file|<qbytearray.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<qbasicatomic.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BOOTSTRAPPED
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|"private/qcore_unix_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_OS_UNIX
end_comment
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*     The Java's hashing algorithm for strings is a variation of D. J. Bernstein     hashing algorithm appeared here http://cr.yp.to/cdb/cdb.txt     and informally known as DJB33XX - DJB's 33 Times Xor.     Java uses DJB31XA, that is, 31 Times Add.      The original algorithm was a loop around         (h<< 5) + h ^ c     (which is indeed h*33 ^ c); it was then changed to         (h<< 5) - h ^ c     (so h*31^c: DJB31XX), and the XOR changed to a sum:         (h<< 5) - h + c     (DJB31XA), which can save some assembly instructions.      Still, we can avoid writing the multiplication as "(h<< 5) - h"     -- the compiler will turn it into a shift and an addition anyway     (for instance, gcc 4.4 does that even at -O0). */
specifier|static
specifier|inline
name|uint
name|hash
parameter_list|(
specifier|const
name|uchar
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
name|uint
name|h
init|=
name|seed
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|h
operator|=
literal|31
operator|*
name|h
operator|+
name|p
index|[
name|i
index|]
expr_stmt|;
return|return
name|h
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|uint
name|hash
parameter_list|(
specifier|const
name|QChar
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
name|uint
name|h
init|=
name|seed
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|h
operator|=
literal|31
operator|*
name|h
operator|+
name|p
index|[
name|i
index|]
operator|.
name|unicode
argument_list|()
expr_stmt|;
return|return
name|h
return|;
block|}
end_function
begin_function
name|uint
name|qHash
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|hash
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|key
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|,
name|key
operator|.
name|size
argument_list|()
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_function
name|uint
name|qHash
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|hash
argument_list|(
name|key
operator|.
name|unicode
argument_list|()
argument_list|,
name|key
operator|.
name|size
argument_list|()
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_function
name|uint
name|qHash
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|hash
argument_list|(
name|key
operator|.
name|unicode
argument_list|()
argument_list|,
name|key
operator|.
name|size
argument_list|()
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_function
name|uint
name|qHash
parameter_list|(
specifier|const
name|QBitArray
modifier|&
name|bitArray
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
name|int
name|m
init|=
name|bitArray
operator|.
name|d
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
name|uint
name|result
init|=
name|hash
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|bitArray
operator|.
name|d
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|,
name|qMax
argument_list|(
literal|0
argument_list|,
name|m
argument_list|)
argument_list|,
name|seed
argument_list|)
decl_stmt|;
comment|// deal with the last 0 to 7 bits manually, because we can't trust that
comment|// the padding is initialized to 0 in bitArray.d
name|int
name|n
init|=
name|bitArray
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|&
literal|0x7
condition|)
name|result
operator|=
operator|(
operator|(
name|result
operator|<<
literal|4
operator|)
operator|+
name|bitArray
operator|.
name|d
operator|.
name|at
argument_list|(
name|m
argument_list|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|n
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
name|uint
name|qHash
parameter_list|(
name|QLatin1String
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|hash
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|key
operator|.
name|data
argument_list|()
argument_list|)
argument_list|,
name|key
operator|.
name|size
argument_list|()
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Creates the QHash random seed from various sources.     In order of decreasing precedence:     - under Unix, it attemps to read from /dev/urandom;     - under Unix, it attemps to read from /dev/random;     - under Windows, it attempts to use rand_s;     - as a general fallback, the application's PID, a timestamp and the       address of a stack-local variable are used. */
end_comment
begin_function
DECL|function|qt_create_qhash_seed
specifier|static
name|uint
name|qt_create_qhash_seed
parameter_list|()
block|{
name|QByteArray
name|envSeed
init|=
name|qgetenv
argument_list|(
literal|"QT_HASH_SEED"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|envSeed
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|envSeed
operator|.
name|toUInt
argument_list|()
return|;
name|uint
name|seed
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|int
name|randomfd
init|=
name|qt_safe_open
argument_list|(
literal|"/dev/urandom"
argument_list|,
name|O_RDONLY
argument_list|)
decl_stmt|;
if|if
condition|(
name|randomfd
operator|==
operator|-
literal|1
condition|)
name|randomfd
operator|=
name|qt_safe_open
argument_list|(
literal|"/dev/random"
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|randomfd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|qt_safe_read
argument_list|(
name|randomfd
argument_list|,
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|seed
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
condition|)
block|{
name|qt_safe_close
argument_list|(
name|randomfd
argument_list|)
expr_stmt|;
return|return
name|seed
return|;
block|}
name|qt_safe_close
argument_list|(
name|randomfd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Q_OS_UNIX
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
name|errno_t
name|err
decl_stmt|;
name|err
operator|=
name|rand_s
argument_list|(
operator|&
name|seed
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
return|return
name|seed
return|;
endif|#
directive|endif
comment|// Q_OS_WIN32
comment|// general fallback: initialize from the current timestamp, pid,
comment|// and address of a stack-local variable
name|quint64
name|timestamp
init|=
name|QDateTime
operator|::
name|currentMSecsSinceEpoch
argument_list|()
decl_stmt|;
name|seed
operator|^=
name|timestamp
expr_stmt|;
name|seed
operator|^=
operator|(
name|timestamp
operator|>>
literal|32
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|quint64
name|pid
init|=
name|QCoreApplication
operator|::
name|applicationPid
argument_list|()
decl_stmt|;
name|seed
operator|^=
name|pid
expr_stmt|;
name|seed
operator|^=
operator|(
name|pid
operator|>>
literal|32
operator|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_BOOTSTRAPPED
name|quintptr
name|seedPtr
init|=
cast|reinterpret_cast
argument_list|<
name|quintptr
argument_list|>
argument_list|(
operator|&
name|seed
argument_list|)
decl_stmt|;
name|seed
operator|^=
name|seedPtr
expr_stmt|;
if|#
directive|if
name|QT_POINTER_SIZE
operator|==
literal|8
name|seed
operator|^=
operator|(
name|seedPtr
operator|>>
literal|32
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|seed
return|;
block|}
end_function
begin_comment
comment|/*     The QHash seed itself. */
end_comment
begin_decl_stmt
DECL|variable|qt_qhash_seed
name|Q_CORE_EXPORT
name|QBasicAtomicInt
name|qt_qhash_seed
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     \internal      Seed == -1 means it that it was not initialized yet.      We let qt_create_qhash_seed return any unsigned integer,     but convert it to signed in order to initialize the seed.      We don't actually care about the fact that different calls to     qt_create_qhash_seed() might return different values,     as long as in the end everyone uses the very same value. */
end_comment
begin_function
DECL|function|qt_initialize_qhash_seed
specifier|static
name|void
name|qt_initialize_qhash_seed
parameter_list|()
block|{
if|if
condition|(
name|qt_qhash_seed
operator|.
name|load
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|x
argument_list|(
name|qt_create_qhash_seed
argument_list|()
operator|&
name|INT_MAX
argument_list|)
decl_stmt|;
name|qt_qhash_seed
operator|.
name|testAndSetRelaxed
argument_list|(
operator|-
literal|1
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Private copy of the implementation of the Qt 4 qHash algorithm for strings,     (that is, QChar-based arrays, so all QString-like classes),     to be used wherever the result is somehow stored or reused across multiple     Qt versions. The public qHash implementation can change at any time,     therefore one must not rely on the fact that it will always give the same     results.      The qt_hash functions must *never* change their results. */
end_comment
begin_function
specifier|static
name|uint
name|qt_hash
parameter_list|(
specifier|const
name|QChar
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|)
name|Q_DECL_NOTHROW
block|{
name|uint
name|h
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
operator|(
operator|*
name|p
operator|++
operator|)
operator|.
name|unicode
argument_list|()
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|&
literal|0xf0000000
operator|)
operator|>>
literal|23
expr_stmt|;
name|h
operator|&=
literal|0x0fffffff
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \overload */
end_comment
begin_function
name|uint
name|qt_hash
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|qt_hash
argument_list|(
name|key
operator|.
name|unicode
argument_list|()
argument_list|,
name|key
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \overload */
end_comment
begin_function
name|uint
name|qt_hash
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|key
parameter_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|qt_hash
argument_list|(
name|key
operator|.
name|unicode
argument_list|()
argument_list|,
name|key
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*     The prime_deltas array is a table of selected prime values, even     though it doesn't look like one. The primes we are using are 1,     2, 5, 11, 17, 37, 67, 131, 257, ..., i.e. primes in the immediate     surrounding of a power of two.      The primeForNumBits() function returns the prime associated to a     power of two. For example, primeForNumBits(8) returns 257. */
end_comment
begin_decl_stmt
DECL|variable|prime_deltas
specifier|static
specifier|const
name|uchar
name|prime_deltas
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|9
block|,
literal|7
block|,
literal|5
block|,
literal|3
block|,
literal|9
block|,
literal|25
block|,
literal|3
block|,
literal|1
block|,
literal|21
block|,
literal|3
block|,
literal|21
block|,
literal|7
block|,
literal|15
block|,
literal|9
block|,
literal|5
block|,
literal|3
block|,
literal|29
block|,
literal|15
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|primeForNumBits
specifier|static
specifier|inline
name|int
name|primeForNumBits
parameter_list|(
name|int
name|numBits
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|<<
name|numBits
operator|)
operator|+
name|prime_deltas
index|[
name|numBits
index|]
return|;
block|}
end_function
begin_comment
comment|/*     Returns the smallest integer n such that     primeForNumBits(n)>= hint. */
end_comment
begin_function
DECL|function|countBits
specifier|static
name|int
name|countBits
parameter_list|(
name|int
name|hint
parameter_list|)
block|{
name|int
name|numBits
init|=
literal|0
decl_stmt|;
name|int
name|bits
init|=
name|hint
decl_stmt|;
while|while
condition|(
name|bits
operator|>
literal|1
condition|)
block|{
name|bits
operator|>>=
literal|1
expr_stmt|;
name|numBits
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|numBits
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|prime_deltas
argument_list|)
condition|)
block|{
name|numBits
operator|=
sizeof|sizeof
argument_list|(
name|prime_deltas
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|primeForNumBits
argument_list|(
name|numBits
argument_list|)
operator|<
name|hint
condition|)
block|{
operator|++
name|numBits
expr_stmt|;
block|}
return|return
name|numBits
return|;
block|}
end_function
begin_comment
comment|/*     A QHash has initially around pow(2, MinNumBits) buckets. For     example, if MinNumBits is 4, it has 17 buckets. */
end_comment
begin_decl_stmt
DECL|variable|MinNumBits
specifier|const
name|int
name|MinNumBits
init|=
literal|4
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|shared_null
specifier|const
name|QHashData
name|QHashData
operator|::
name|shared_null
init|=
block|{
literal|0
block|,
literal|0
block|,
name|Q_REFCOUNT_INITIALIZE_STATIC
block|,
literal|0
block|,
literal|0
block|,
name|MinNumBits
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|true
block|,
literal|false
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|allocateNode
name|void
modifier|*
name|QHashData
operator|::
name|allocateNode
parameter_list|(
name|int
name|nodeAlign
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|strictAlignment
condition|?
name|qMallocAligned
argument_list|(
name|nodeSize
argument_list|,
name|nodeAlign
argument_list|)
else|:
name|malloc
argument_list|(
name|nodeSize
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function
begin_function
DECL|function|freeNode
name|void
name|QHashData
operator|::
name|freeNode
parameter_list|(
name|void
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|strictAlignment
condition|)
name|qFreeAligned
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|detach_helper
name|QHashData
modifier|*
name|QHashData
operator|::
name|detach_helper
parameter_list|(
name|void
function_decl|(
modifier|*
name|node_duplicate
function_decl|)
parameter_list|(
name|Node
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|node_delete
function_decl|)
parameter_list|(
name|Node
modifier|*
parameter_list|)
parameter_list|,
name|int
name|nodeSize
parameter_list|,
name|int
name|nodeAlign
parameter_list|)
block|{
union|union
block|{
name|QHashData
modifier|*
name|d
decl_stmt|;
name|Node
modifier|*
name|e
decl_stmt|;
block|}
union|;
if|if
condition|(
name|this
operator|==
operator|&
name|shared_null
condition|)
name|qt_initialize_qhash_seed
argument_list|()
expr_stmt|;
name|d
operator|=
operator|new
name|QHashData
expr_stmt|;
name|d
operator|->
name|fakeNext
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|buckets
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|initializeOwned
argument_list|()
expr_stmt|;
name|d
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|d
operator|->
name|nodeSize
operator|=
name|nodeSize
expr_stmt|;
name|d
operator|->
name|userNumBits
operator|=
name|userNumBits
expr_stmt|;
name|d
operator|->
name|numBits
operator|=
name|numBits
expr_stmt|;
name|d
operator|->
name|numBuckets
operator|=
name|numBuckets
expr_stmt|;
name|d
operator|->
name|seed
operator|=
name|uint
argument_list|(
name|qt_qhash_seed
operator|.
name|load
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|sharable
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|strictAlignment
operator|=
name|nodeAlign
operator|>
literal|8
expr_stmt|;
name|d
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numBuckets
condition|)
block|{
name|QT_TRY
block|{
name|d
operator|->
name|buckets
operator|=
operator|new
name|Node
operator|*
index|[
name|numBuckets
index|]
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// restore a consistent state for d
name|d
operator|->
name|numBuckets
operator|=
literal|0
expr_stmt|;
comment|// roll back
name|d
operator|->
name|free_helper
argument_list|(
name|node_delete
argument_list|)
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
name|Node
modifier|*
name|this_e
init|=
cast|reinterpret_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBuckets
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
modifier|*
name|nextNode
init|=
operator|&
name|d
operator|->
name|buckets
index|[
name|i
index|]
decl_stmt|;
name|Node
modifier|*
name|oldNode
init|=
name|buckets
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|oldNode
operator|!=
name|this_e
condition|)
block|{
name|QT_TRY
block|{
name|Node
modifier|*
name|dup
init|=
cast|static_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|allocateNode
argument_list|(
name|nodeAlign
argument_list|)
argument_list|)
decl_stmt|;
name|QT_TRY
block|{
name|node_duplicate
argument_list|(
name|oldNode
argument_list|,
name|dup
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
name|freeNode
argument_list|(
name|dup
argument_list|)
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
operator|*
name|nextNode
operator|=
name|dup
expr_stmt|;
name|nextNode
operator|=
operator|&
name|dup
operator|->
name|next
expr_stmt|;
name|oldNode
operator|=
name|oldNode
operator|->
name|next
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// restore a consistent state for d
operator|*
name|nextNode
operator|=
name|e
expr_stmt|;
name|d
operator|->
name|numBuckets
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|// roll back
name|d
operator|->
name|free_helper
argument_list|(
name|node_delete
argument_list|)
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
block|}
operator|*
name|nextNode
operator|=
name|e
expr_stmt|;
block|}
block|}
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|free_helper
name|void
name|QHashData
operator|::
name|free_helper
parameter_list|(
name|void
function_decl|(
modifier|*
name|node_delete
function_decl|)
parameter_list|(
name|Node
modifier|*
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|node_delete
condition|)
block|{
name|Node
modifier|*
name|this_e
init|=
cast|reinterpret_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|Node
modifier|*
modifier|*
name|bucket
init|=
cast|reinterpret_cast
argument_list|<
name|Node
operator|*
operator|*
argument_list|>
argument_list|(
name|this
operator|->
name|buckets
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|numBuckets
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|Node
modifier|*
name|cur
init|=
operator|*
name|bucket
operator|++
decl_stmt|;
while|while
condition|(
name|cur
operator|!=
name|this_e
condition|)
block|{
name|Node
modifier|*
name|next
init|=
name|cur
operator|->
name|next
decl_stmt|;
name|node_delete
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|freeNode
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|cur
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
operator|delete
index|[]
name|buckets
expr_stmt|;
operator|delete
name|this
expr_stmt|;
block|}
end_function
begin_function
DECL|function|nextNode
name|QHashData
operator|::
name|Node
modifier|*
name|QHashData
operator|::
name|nextNode
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
union|union
block|{
name|Node
modifier|*
name|next
decl_stmt|;
name|Node
modifier|*
name|e
decl_stmt|;
name|QHashData
modifier|*
name|d
decl_stmt|;
block|}
union|;
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
name|next
argument_list|,
literal|"QHash"
argument_list|,
literal|"Iterating beyond end()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|next
condition|)
return|return
name|next
return|;
name|int
name|start
init|=
operator|(
name|node
operator|->
name|h
operator|%
name|d
operator|->
name|numBuckets
operator|)
operator|+
literal|1
decl_stmt|;
name|Node
modifier|*
modifier|*
name|bucket
init|=
name|d
operator|->
name|buckets
operator|+
name|start
decl_stmt|;
name|int
name|n
init|=
name|d
operator|->
name|numBuckets
operator|-
name|start
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|bucket
operator|!=
name|e
condition|)
return|return
operator|*
name|bucket
return|;
operator|++
name|bucket
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
end_function
begin_function
DECL|function|previousNode
name|QHashData
operator|::
name|Node
modifier|*
name|QHashData
operator|::
name|previousNode
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
union|union
block|{
name|Node
modifier|*
name|e
decl_stmt|;
name|QHashData
modifier|*
name|d
decl_stmt|;
block|}
union|;
name|e
operator|=
name|node
expr_stmt|;
while|while
condition|(
name|e
operator|->
name|next
condition|)
name|e
operator|=
name|e
operator|->
name|next
expr_stmt|;
name|int
name|start
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|e
condition|)
name|start
operator|=
name|d
operator|->
name|numBuckets
operator|-
literal|1
expr_stmt|;
else|else
name|start
operator|=
name|node
operator|->
name|h
operator|%
name|d
operator|->
name|numBuckets
expr_stmt|;
name|Node
modifier|*
name|sentinel
init|=
name|node
decl_stmt|;
name|Node
modifier|*
modifier|*
name|bucket
init|=
name|d
operator|->
name|buckets
operator|+
name|start
decl_stmt|;
while|while
condition|(
name|start
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|bucket
operator|!=
name|sentinel
condition|)
block|{
name|Node
modifier|*
name|prev
init|=
operator|*
name|bucket
decl_stmt|;
while|while
condition|(
name|prev
operator|->
name|next
operator|!=
name|sentinel
condition|)
name|prev
operator|=
name|prev
operator|->
name|next
expr_stmt|;
return|return
name|prev
return|;
block|}
name|sentinel
operator|=
name|e
expr_stmt|;
operator|--
name|bucket
expr_stmt|;
operator|--
name|start
expr_stmt|;
block|}
name|Q_ASSERT_X
argument_list|(
name|start
operator|>=
literal|0
argument_list|,
literal|"QHash"
argument_list|,
literal|"Iterating backward beyond begin()"
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function
begin_comment
comment|/*     If hint is negative, -hint gives the approximate number of     buckets that should be used for the hash table. If hint is     nonnegative, (1<< hint) gives the approximate number     of buckets that should be used. */
end_comment
begin_function
DECL|function|rehash
name|void
name|QHashData
operator|::
name|rehash
parameter_list|(
name|int
name|hint
parameter_list|)
block|{
if|if
condition|(
name|hint
operator|<
literal|0
condition|)
block|{
name|hint
operator|=
name|countBits
argument_list|(
operator|-
name|hint
argument_list|)
expr_stmt|;
if|if
condition|(
name|hint
operator|<
name|MinNumBits
condition|)
name|hint
operator|=
name|MinNumBits
expr_stmt|;
name|userNumBits
operator|=
name|hint
expr_stmt|;
while|while
condition|(
name|primeForNumBits
argument_list|(
name|hint
argument_list|)
operator|<
operator|(
name|size
operator|>>
literal|1
operator|)
condition|)
operator|++
name|hint
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hint
operator|<
name|MinNumBits
condition|)
block|{
name|hint
operator|=
name|MinNumBits
expr_stmt|;
block|}
if|if
condition|(
name|numBits
operator|!=
name|hint
condition|)
block|{
name|Node
modifier|*
name|e
init|=
cast|reinterpret_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|Node
modifier|*
modifier|*
name|oldBuckets
init|=
name|buckets
decl_stmt|;
name|int
name|oldNumBuckets
init|=
name|numBuckets
decl_stmt|;
name|int
name|nb
init|=
name|primeForNumBits
argument_list|(
name|hint
argument_list|)
decl_stmt|;
name|buckets
operator|=
operator|new
name|Node
operator|*
index|[
name|nb
index|]
expr_stmt|;
name|numBits
operator|=
name|hint
expr_stmt|;
name|numBuckets
operator|=
name|nb
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBuckets
condition|;
operator|++
name|i
control|)
name|buckets
index|[
name|i
index|]
operator|=
name|e
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldNumBuckets
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|firstNode
init|=
name|oldBuckets
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|firstNode
operator|!=
name|e
condition|)
block|{
name|uint
name|h
init|=
name|firstNode
operator|->
name|h
decl_stmt|;
name|Node
modifier|*
name|lastNode
init|=
name|firstNode
decl_stmt|;
while|while
condition|(
name|lastNode
operator|->
name|next
operator|!=
name|e
operator|&&
name|lastNode
operator|->
name|next
operator|->
name|h
operator|==
name|h
condition|)
name|lastNode
operator|=
name|lastNode
operator|->
name|next
expr_stmt|;
name|Node
modifier|*
name|afterLastNode
init|=
name|lastNode
operator|->
name|next
decl_stmt|;
name|Node
modifier|*
modifier|*
name|beforeFirstNode
init|=
operator|&
name|buckets
index|[
name|h
operator|%
name|numBuckets
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|beforeFirstNode
operator|!=
name|e
condition|)
name|beforeFirstNode
operator|=
operator|&
operator|(
operator|*
name|beforeFirstNode
operator|)
operator|->
name|next
expr_stmt|;
name|lastNode
operator|->
name|next
operator|=
operator|*
name|beforeFirstNode
expr_stmt|;
operator|*
name|beforeFirstNode
operator|=
name|firstNode
expr_stmt|;
name|firstNode
operator|=
name|afterLastNode
expr_stmt|;
block|}
block|}
operator|delete
index|[]
name|oldBuckets
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_QHASH_DEBUG
end_ifdef
begin_function
DECL|function|dump
name|void
name|QHashData
operator|::
name|dump
parameter_list|()
block|{
name|qDebug
argument_list|(
literal|"Hash data (ref = %d, size = %d, nodeSize = %d, userNumBits = %d, numBits = %d, numBuckets = %d)"
argument_list|,
name|int
argument_list|(
name|ref
argument_list|)
argument_list|,
name|size
argument_list|,
name|nodeSize
argument_list|,
name|userNumBits
argument_list|,
name|numBits
argument_list|,
name|numBuckets
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"    %p (fakeNode = %p)"
argument_list|,
name|this
argument_list|,
name|fakeNext
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBuckets
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|line
decl_stmt|;
name|Node
modifier|*
name|n
init|=
name|buckets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|!=
cast|reinterpret_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|line
operator|.
name|sprintf
argument_list|(
literal|"%d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|!=
cast|reinterpret_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|line
operator|+=
name|QString
argument_list|()
operator|.
name|sprintf
argument_list|(
literal|" -> [%p]"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|line
operator|+=
literal|" (CORRUPT)"
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
name|qDebug
argument_list|(
literal|"%s"
argument_list|,
name|qPrintable
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|checkSanity
name|void
name|QHashData
operator|::
name|checkSanity
parameter_list|()
block|{
if|if
condition|(
name|fakeNext
condition|)
name|qFatal
argument_list|(
literal|"Fake next isn't 0"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBuckets
condition|;
operator|++
name|i
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|buckets
index|[
name|i
index|]
decl_stmt|;
name|Node
modifier|*
name|p
init|=
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|qFatal
argument_list|(
literal|"%d: Bucket entry is 0"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
cast|reinterpret_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
condition|)
block|{
while|while
condition|(
name|n
operator|!=
cast|reinterpret_cast
argument_list|<
name|Node
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|n
operator|->
name|next
condition|)
name|qFatal
argument_list|(
literal|"%d: Next of %p is 0, should be %p"
argument_list|,
name|i
argument_list|,
name|n
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn uint qHash(const QPair<T1, T2>&key, uint seed = 0)     \since 5.0     \relates QHash      Returns the hash value for the \a key, using \a seed to seed the calculation.      Types \c T1 and \c T2 must be supported by qHash(). */
end_comment
begin_comment
comment|/*! \fn uint qHash(char key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(uchar key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(signed char key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(ushort key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(short key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(uint key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(int key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(ulong key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(long key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(quint64 key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(qint64 key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(QChar key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(const QByteArray&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(const QBitArray&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(const QString&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(const QStringRef&key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(QLatin1String key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*! \fn uint qHash(const T *key, uint seed = 0)     \relates QHash     \since 5.0      Returns the hash value for the \a key, using \a seed to seed the calculation. */
end_comment
begin_comment
comment|/*!     \class QHash     \inmodule QtCore     \brief The QHash class is a template class that provides a hash-table-based dictionary.      \ingroup tools     \ingroup shared      \reentrant      QHash\<Key, T\> is one of Qt's generic \l{container classes}. It     stores (key, value) pairs and provides very fast lookup of the     value associated with a key.      QHash provides very similar functionality to QMap. The     differences are:      \list     \li QHash provides faster lookups than QMap. (See \l{Algorithmic        Complexity} for details.)     \li When iterating over a QMap, the items are always sorted by        key. With QHash, the items are arbitrarily ordered.     \li The key type of a QMap must provide operator<(). The key        type of a QHash must provide operator==() and a global        hash function called qHash() (see \l{qHash}).     \endlist      Here's an example QHash with QString keys and \c int values:     \snippet code/src_corelib_tools_qhash.cpp 0      To insert a (key, value) pair into the hash, you can use operator[]():      \snippet code/src_corelib_tools_qhash.cpp 1      This inserts the following three (key, value) pairs into the     QHash: ("one", 1), ("three", 3), and ("seven", 7). Another way to     insert items into the hash is to use insert():      \snippet code/src_corelib_tools_qhash.cpp 2      To look up a value, use operator[]() or value():      \snippet code/src_corelib_tools_qhash.cpp 3      If there is no item with the specified key in the hash, these     functions return a \l{default-constructed value}.      If you want to check whether the hash contains a particular key,     use contains():      \snippet code/src_corelib_tools_qhash.cpp 4      There is also a value() overload that uses its second argument as     a default value if there is no item with the specified key:      \snippet code/src_corelib_tools_qhash.cpp 5      In general, we recommend that you use contains() and value()     rather than operator[]() for looking up a key in a hash. The     reason is that operator[]() silently inserts an item into the     hash if no item exists with the same key (unless the hash is     const). For example, the following code snippet will create 1000     items in memory:      \snippet code/src_corelib_tools_qhash.cpp 6      To avoid this problem, replace \c hash[i] with \c hash.value(i)     in the code above.      Internally, QHash uses a hash table to perform lookups. Unlike Qt     3's \c QDict class, which needed to be initialized with a prime     number, QHash's hash table automatically grows and shrinks to     provide fast lookups without wasting too much memory. You can     still control the size of the hash table by calling reserve() if     you already know approximately how many items the QHash will     contain, but this isn't necessary to obtain good performance. You     can also call capacity() to retrieve the hash table's size.      If you want to navigate through all the (key, value) pairs stored     in a QHash, you can use an iterator. QHash provides both     \l{Java-style iterators} (QHashIterator and QMutableHashIterator)     and \l{STL-style iterators} (QHash::const_iterator and     QHash::iterator). Here's how to iterate over a QHash<QString,     int> using a Java-style iterator:      \snippet code/src_corelib_tools_qhash.cpp 7      Here's the same code, but using an STL-style iterator:      \snippet code/src_corelib_tools_qhash.cpp 8      QHash is unordered, so an iterator's sequence cannot be assumed     to be predictable. If ordering by key is required, use a QMap.      Normally, a QHash allows only one value per key. If you call     insert() with a key that already exists in the QHash, the     previous value is erased. For example:      \snippet code/src_corelib_tools_qhash.cpp 9      However, you can store multiple values per key by using     insertMulti() instead of insert() (or using the convenience     subclass QMultiHash). If you want to retrieve all     the values for a single key, you can use values(const Key&key),     which returns a QList<T>:      \snippet code/src_corelib_tools_qhash.cpp 10      The items that share the same key are available from most     recently to least recently inserted. A more efficient approach is     to call find() to get the iterator for the first item with a key     and iterate from there:      \snippet code/src_corelib_tools_qhash.cpp 11      If you only need to extract the values from a hash (not the keys),     you can also use \l{foreach}:      \snippet code/src_corelib_tools_qhash.cpp 12      Items can be removed from the hash in several ways. One way is to     call remove(); this will remove any item with the given key.     Another way is to use QMutableHashIterator::remove(). In addition,     you can clear the entire hash using clear().      QHash's key and value data types must be \l{assignable data     types}. You cannot, for example, store a QWidget as a value;     instead, store a QWidget *.      \target qHash     \section2 The qHash() hashing function      A QHash's key type has additional requirements other than being an     assignable data type: it must provide operator==(), and there must also be     a global qHash() function that returns a hash value for an argument of the     key's type.      The qHash() function computes a numeric value based on a key. It     can use any algorithm imaginable, as long as it always returns     the same value if given the same argument. In other words, if     \c{e1 == e2}, then \c{qHash(e1) == qHash(e2)} must hold as well.     However, to obtain good performance, the qHash() function should     attempt to return different hash values for different keys to the     largest extent possible.      For a key type \c{K}, the qHash function must have one of these signatures:      \code     uint qHash(K key);     uint qHash(const K&key);      uint qHash(K key, uint seed);     uint qHash(const K&key, uint seed);     \endcode      The two-arguments overloads take an unsigned integer that should be used to     seed the calculation of the hash function. This seed is provided by QHash     in order to prevent a family of \l{algorithmic complexity attacks}. If both     a one-argument and a two-arguments overload are defined for a key type,     the latter is used by QHash (note that you can simply define a     two-arguments version, and use a default value for the seed parameter).      Here's a partial list of the C++ and Qt types that can serve as keys in a     QHash: any integer type (char, unsigned long, etc.), any pointer type,     QChar, QString, and QByteArray. For all of these, the \c<QHash> header     defines a qHash() function that computes an adequate hash value. Many other     Qt classes also declare a qHash overload for their type; please refer to     the documentation of each class.      If you want to use other types as the key, make sure that you provide     operator==() and a qHash() implementation.      Example:     \snippet code/src_corelib_tools_qhash.cpp 13      In the example above, we've relied on Qt's global qHash(const     QString&, uint) to give us a hash value for the employee's name, and     XOR'ed this with the day they were born to help produce unique     hashes for people with the same name.      Note that the implementation of the qHash() overloads offered by Qt     may change at any time. You \b{must not} rely on the fact that qHash()     will give the same results (for the same inputs) across different Qt     versions.      \section2 Algorithmic complexity attacks      All hash tables are vulnerable to a particular class of denial of service     attacks, in which the attacker carefully pre-computes a set of different     keys that are going to be hashed in the same bucket of a hash table (or     even have the very same hash value). The attack aims at getting the     worst-case algorithmic behavior (O(n) instead of amortized O(1), see     \l{Algorithmic Complexity} for the details) when the data is fed into the     table.      In order to avoid this worst-case behavior, the calculation of the hash     value done by qHash() can be salted by a random seed, that nullifies the     attack's extent. This seed is automatically generated by QHash once per     process, and then passed by QHash as the second argument of the     two-arguments overload of the qHash() function.      This randomization of QHash is enabled by default. Even though programs     should never depend on a particular QHash ordering, there may be situations     where you temporarily need deterministic behavior, e.g. for debugging or     regression testing. To disable the randomization, define the environment     variable \c QT_HASH_SEED. The contents of that variable, interpreted as a     decimal value, will be used as the seed for qHash().      \sa QHashIterator, QMutableHashIterator, QMap, QSet */
end_comment
begin_comment
comment|/*! \fn QHash::QHash()      Constructs an empty hash.      \sa clear() */
end_comment
begin_comment
comment|/*! \fn QHash::QHash(std::initializer_list<std::pair<Key,T>> list)     \since 5.1      Constructs a hash with a copy of each of the elements in the     initializer list \a list.      This function is only available if the program is being     compiled in C++11 mode. */
end_comment
begin_comment
comment|/*! \fn QHash::QHash(const QHash<Key, T>&other)      Constructs a copy of \a other.      This operation occurs in \l{constant time}, because QHash is     \l{implicitly shared}. This makes returning a QHash from a     function very fast. If a shared instance is modified, it will be     copied (copy-on-write), and this takes \l{linear time}.      \sa operator=() */
end_comment
begin_comment
comment|/*! \fn QHash::~QHash()      Destroys the hash. References to the values in the hash and all     iterators of this hash become invalid. */
end_comment
begin_comment
comment|/*! \fn QHash<Key, T>&QHash::operator=(const QHash<Key, T>&other)      Assigns \a other to this hash and returns a reference to this hash. */
end_comment
begin_comment
comment|/*! \fn void QHash::swap(QHash<Key, T>&other)     \since 4.8      Swaps hash \a other with this hash. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*! \fn void QMultiHash::swap(QMultiHash<Key, T>&other)     \since 4.8      Swaps hash \a other with this hash. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*! \fn bool QHash::operator==(const QHash<Key, T>&other) const      Returns true if \a other is equal to this hash; otherwise returns     false.      Two hashes are considered equal if they contain the same (key,     value) pairs.      This function requires the value type to implement \c operator==().      \sa operator!=() */
end_comment
begin_comment
comment|/*! \fn bool QHash::operator!=(const QHash<Key, T>&other) const      Returns true if \a other is not equal to this hash; otherwise     returns false.      Two hashes are considered equal if they contain the same (key,     value) pairs.      This function requires the value type to implement \c operator==().      \sa operator==() */
end_comment
begin_comment
comment|/*! \fn int QHash::size() const      Returns the number of items in the hash.      \sa isEmpty(), count() */
end_comment
begin_comment
comment|/*! \fn bool QHash::isEmpty() const      Returns true if the hash contains no items; otherwise returns     false.      \sa size() */
end_comment
begin_comment
comment|/*! \fn int QHash::capacity() const      Returns the number of buckets in the QHash's internal hash table.      The sole purpose of this function is to provide a means of fine     tuning QHash's memory usage. In general, you will rarely ever     need to call this function. If you want to know how many items are     in the hash, call size().      \sa reserve(), squeeze() */
end_comment
begin_comment
comment|/*! \fn void QHash::reserve(int size)      Ensures that the QHash's internal hash table consists of at least     \a size buckets.      This function is useful for code that needs to build a huge hash     and wants to avoid repeated reallocation. For example:      \snippet code/src_corelib_tools_qhash.cpp 14      Ideally, \a size should be slightly more than the maximum number     of items expected in the hash. \a size doesn't have to be prime,     because QHash will use a prime number internally anyway. If \a size     is an underestimate, the worst that will happen is that the QHash     will be a bit slower.      In general, you will rarely ever need to call this function.     QHash's internal hash table automatically shrinks or grows to     provide good performance without wasting too much memory.      \sa squeeze(), capacity() */
end_comment
begin_comment
comment|/*! \fn void QHash::squeeze()      Reduces the size of the QHash's internal hash table to save     memory.      The sole purpose of this function is to provide a means of fine     tuning QHash's memory usage. In general, you will rarely ever     need to call this function.      \sa reserve(), capacity() */
end_comment
begin_comment
comment|/*! \fn void QHash::detach()      \internal      Detaches this hash from any other hashes with which it may share     data.      \sa isDetached() */
end_comment
begin_comment
comment|/*! \fn bool QHash::isDetached() const      \internal      Returns true if the hash's internal data isn't shared with any     other hash object; otherwise returns false.      \sa detach() */
end_comment
begin_comment
comment|/*! \fn void QHash::setSharable(bool sharable)      \internal */
end_comment
begin_comment
comment|/*! \fn bool QHash::isSharedWith(const QHash<Key, T>&other) const      \internal */
end_comment
begin_comment
comment|/*! \fn void QHash::clear()      Removes all items from the hash.      \sa remove() */
end_comment
begin_comment
comment|/*! \fn int QHash::remove(const Key&key)      Removes all the items that have the \a key from the hash.     Returns the number of items removed which is usually 1 but will     be 0 if the key isn't in the hash, or greater than 1 if     insertMulti() has been used with the \a key.      \sa clear(), take(), QMultiHash::remove() */
end_comment
begin_comment
comment|/*! \fn T QHash::take(const Key&key)      Removes the item with the \a key from the hash and returns     the value associated with it.      If the item does not exist in the hash, the function simply     returns a \l{default-constructed value}. If there are multiple     items for \a key in the hash, only the most recently inserted one     is removed.      If you don't use the return value, remove() is more efficient.      \sa remove() */
end_comment
begin_comment
comment|/*! \fn bool QHash::contains(const Key&key) const      Returns true if the hash contains an item with the \a key;     otherwise returns false.      \sa count(), QMultiHash::contains() */
end_comment
begin_comment
comment|/*! \fn const T QHash::value(const Key&key) const      Returns the value associated with the \a key.      If the hash contains no item with the \a key, the function     returns a \l{default-constructed value}. If there are multiple     items for the \a key in the hash, the value of the most recently     inserted one is returned.      \sa key(), values(), contains(), operator[]() */
end_comment
begin_comment
comment|/*! \fn const T QHash::value(const Key&key, const T&defaultValue) const     \overload      If the hash contains no item with the given \a key, the function returns     \a defaultValue. */
end_comment
begin_comment
comment|/*! \fn T&QHash::operator[](const Key&key)      Returns the value associated with the \a key as a modifiable     reference.      If the hash contains no item with the \a key, the function inserts     a \l{default-constructed value} into the hash with the \a key, and     returns a reference to it. If the hash contains multiple items     with the \a key, this function returns a reference to the most     recently inserted value.      \sa insert(), value() */
end_comment
begin_comment
comment|/*! \fn const T QHash::operator[](const Key&key) const      \overload      Same as value(). */
end_comment
begin_comment
comment|/*! \fn QList<Key> QHash::uniqueKeys() const     \since 4.2      Returns a list containing all the keys in the map. Keys that occur multiple     times in the map (because items were inserted with insertMulti(), or     unite() was used) occur only once in the returned list.      \sa keys(), values() */
end_comment
begin_comment
comment|/*! \fn QList<Key> QHash::keys() const      Returns a list containing all the keys in the hash, in an     arbitrary order. Keys that occur multiple times in the hash     (because items were inserted with insertMulti(), or unite() was     used) also occur multiple times in the list.      To obtain a list of unique keys, where each key from the map only     occurs once, use uniqueKeys().      The order is guaranteed to be the same as that used by values().      \sa uniqueKeys(), values(), key() */
end_comment
begin_comment
comment|/*! \fn QList<Key> QHash::keys(const T&value) const      \overload      Returns a list containing all the keys associated with value \a     value, in an arbitrary order.      This function can be slow (\l{linear time}), because QHash's     internal data structure is optimized for fast lookup by key, not     by value. */
end_comment
begin_comment
comment|/*! \fn QList<T> QHash::values() const      Returns a list containing all the values in the hash, in an     arbitrary order. If a key is associated multiple values, all of     its values will be in the list, and not just the most recently     inserted one.      The order is guaranteed to be the same as that used by keys().      \sa keys(), value() */
end_comment
begin_comment
comment|/*! \fn QList<T> QHash::values(const Key&key) const      \overload      Returns a list of all the values associated with the \a key,     from the most recently inserted to the least recently inserted.      \sa count(), insertMulti() */
end_comment
begin_comment
comment|/*! \fn Key QHash::key(const T&value) const      Returns the first key mapped to \a value.      If the hash contains no item with the \a value, the function     returns a \l{default-constructed value}{default-constructed key}.      This function can be slow (\l{linear time}), because QHash's     internal data structure is optimized for fast lookup by key, not     by value.      \sa value(), keys() */
end_comment
begin_comment
comment|/*!     \fn Key QHash::key(const T&value, const Key&defaultKey) const     \since 4.3     \overload      Returns the first key mapped to \a value, or \a defaultKey if the     hash contains no item mapped to \a value.      This function can be slow (\l{linear time}), because QHash's     internal data structure is optimized for fast lookup by key, not     by value. */
end_comment
begin_comment
comment|/*! \fn int QHash::count(const Key&key) const      Returns the number of items associated with the \a key.      \sa contains(), insertMulti() */
end_comment
begin_comment
comment|/*! \fn int QHash::count() const      \overload      Same as size(). */
end_comment
begin_comment
comment|/*! \fn QHash::iterator QHash::begin()      Returns an \l{STL-style iterators}{STL-style iterator} pointing to the first item in     the hash.      \sa constBegin(), end() */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator QHash::begin() const      \overload */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator QHash::cbegin() const     \since 5.0      Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first item     in the hash.      \sa begin(), cend() */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator QHash::constBegin() const      Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first item     in the hash.      \sa begin(), constEnd() */
end_comment
begin_comment
comment|/*! \fn QHash::iterator QHash::end()      Returns an \l{STL-style iterators}{STL-style iterator} pointing to the imaginary item     after the last item in the hash.      \sa begin(), constEnd() */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator QHash::end() const      \overload */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator QHash::constEnd() const      Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary     item after the last item in the hash.      \sa constBegin(), end() */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator QHash::cend() const     \since 5.0      Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary     item after the last item in the hash.      \sa cbegin(), end() */
end_comment
begin_comment
comment|/*! \fn QHash::iterator QHash::erase(iterator pos)      Removes the (key, value) pair associated with the iterator \a pos     from the hash, and returns an iterator to the next item in the     hash.      Unlike remove() and take(), this function never causes QHash to     rehash its internal data structure. This means that it can safely     be called while iterating, and won't affect the order of items in     the hash. For example:      \snippet code/src_corelib_tools_qhash.cpp 15      \sa remove(), take(), find() */
end_comment
begin_comment
comment|/*! \fn QHash::iterator QHash::find(const Key&key)      Returns an iterator pointing to the item with the \a key in the     hash.      If the hash contains no item with the \a key, the function     returns end().      If the hash contains multiple items with the \a key, this     function returns an iterator that points to the most recently     inserted value. The other values are accessible by incrementing     the iterator. For example, here's some code that iterates over all     the items with the same key:      \snippet code/src_corelib_tools_qhash.cpp 16      \sa value(), values(), QMultiHash::find() */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator QHash::find(const Key&key) const      \overload */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator QHash::constFind(const Key&key) const     \since 4.1      Returns an iterator pointing to the item with the \a key in the     hash.      If the hash contains no item with the \a key, the function     returns constEnd().      \sa find(), QMultiHash::constFind() */
end_comment
begin_comment
comment|/*! \fn QHash::iterator QHash::insert(const Key&key, const T&value)      Inserts a new item with the \a key and a value of \a value.      If there is already an item with the \a key, that item's value     is replaced with \a value.      If there are multiple items with the \a key, the most     recently inserted item's value is replaced with \a value.      \sa insertMulti() */
end_comment
begin_comment
comment|/*! \fn QHash::iterator QHash::insertMulti(const Key&key, const T&value)      Inserts a new item with the \a key and a value of \a value.      If there is already an item with the same key in the hash, this     function will simply create a new one. (This behavior is     different from insert(), which overwrites the value of an     existing item.)      \sa insert(), values() */
end_comment
begin_comment
comment|/*! \fn QHash<Key, T>&QHash::unite(const QHash<Key, T>&other)      Inserts all the items in the \a other hash into this hash. If a     key is common to both hashes, the resulting hash will contain the     key multiple times.      \sa insertMulti() */
end_comment
begin_comment
comment|/*! \fn bool QHash::empty() const      This function is provided for STL compatibility. It is equivalent     to isEmpty(), returning true if the hash is empty; otherwise     returns false. */
end_comment
begin_comment
comment|/*! \typedef QHash::ConstIterator      Qt-style synonym for QHash::const_iterator. */
end_comment
begin_comment
comment|/*! \typedef QHash::Iterator      Qt-style synonym for QHash::iterator. */
end_comment
begin_comment
comment|/*! \typedef QHash::difference_type      Typedef for ptrdiff_t. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*! \typedef QHash::key_type      Typedef for Key. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*! \typedef QHash::mapped_type      Typedef for T. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*! \typedef QHash::size_type      Typedef for int. Provided for STL compatibility. */
end_comment
begin_comment
comment|/*! \typedef QHash::iterator::difference_type     \internal */
end_comment
begin_comment
comment|/*! \typedef QHash::iterator::iterator_category     \internal */
end_comment
begin_comment
comment|/*! \typedef QHash::iterator::pointer     \internal */
end_comment
begin_comment
comment|/*! \typedef QHash::iterator::reference     \internal */
end_comment
begin_comment
comment|/*! \typedef QHash::iterator::value_type     \internal */
end_comment
begin_comment
comment|/*! \typedef QHash::const_iterator::difference_type     \internal */
end_comment
begin_comment
comment|/*! \typedef QHash::const_iterator::iterator_category     \internal */
end_comment
begin_comment
comment|/*! \typedef QHash::const_iterator::pointer     \internal */
end_comment
begin_comment
comment|/*! \typedef QHash::const_iterator::reference     \internal */
end_comment
begin_comment
comment|/*! \typedef QHash::const_iterator::value_type     \internal */
end_comment
begin_comment
comment|/*! \class QHash::iterator     \inmodule QtCore     \brief The QHash::iterator class provides an STL-style non-const iterator for QHash and QMultiHash.      QHash features both \l{STL-style iterators} and \l{Java-style     iterators}. The STL-style iterators are more low-level and more     cumbersome to use; on the other hand, they are slightly faster     and, for developers who already know STL, have the advantage of     familiarity.      QHash\<Key, T\>::iterator allows you to iterate over a QHash (or     QMultiHash) and to modify the value (but not the key) associated     with a particular key. If you want to iterate over a const QHash,     you should use QHash::const_iterator. It is generally good     practice to use QHash::const_iterator on a non-const QHash as     well, unless you need to change the QHash through the iterator.     Const iterators are slightly faster, and can improve code     readability.      The default QHash::iterator constructor creates an uninitialized     iterator. You must initialize it using a QHash function like     QHash::begin(), QHash::end(), or QHash::find() before you can     start iterating. Here's a typical loop that prints all the (key,     value) pairs stored in a hash:      \snippet code/src_corelib_tools_qhash.cpp 17      Unlike QMap, which orders its items by key, QHash stores its     items in an arbitrary order. The only guarantee is that items that     share the same key (because they were inserted using     QHash::insertMulti()) will appear consecutively, from the most     recently to the least recently inserted value.      Let's see a few examples of things we can do with a     QHash::iterator that we cannot do with a QHash::const_iterator.     Here's an example that increments every value stored in the QHash     by 2:      \snippet code/src_corelib_tools_qhash.cpp 18      Here's an example that removes all the items whose key is a     string that starts with an underscore character:      \snippet code/src_corelib_tools_qhash.cpp 19      The call to QHash::erase() removes the item pointed to by the     iterator from the hash, and returns an iterator to the next item.     Here's another way of removing an item while iterating:      \snippet code/src_corelib_tools_qhash.cpp 20      It might be tempting to write code like this:      \snippet code/src_corelib_tools_qhash.cpp 21      However, this will potentially crash in \c{++i}, because \c i is     a dangling iterator after the call to erase().      Multiple iterators can be used on the same hash. However, be     aware that any modification performed directly on the QHash has     the potential of dramatically changing the order in which the     items are stored in the hash, as they might cause QHash to rehash     its internal data structure. There is one notable exception:     QHash::erase(). This function can safely be called while     iterating, and won't affect the order of items in the hash. If you     need to keep iterators over a long period of time, we recommend     that you use QMap rather than QHash.      \sa QHash::const_iterator, QMutableHashIterator */
end_comment
begin_comment
comment|/*! \fn QHash::iterator::iterator()      Constructs an uninitialized iterator.      Functions like key(), value(), and operator++() must not be     called on an uninitialized iterator. Use operator=() to assign a     value to it before using it.      \sa QHash::begin(), QHash::end() */
end_comment
begin_comment
comment|/*! \fn QHash::iterator::iterator(void *node)      \internal */
end_comment
begin_comment
comment|/*! \fn const Key&QHash::iterator::key() const      Returns the current item's key as a const reference.      There is no direct way of changing an item's key through an     iterator, although it can be done by calling QHash::erase()     followed by QHash::insert() or QHash::insertMulti().      \sa value() */
end_comment
begin_comment
comment|/*! \fn T&QHash::iterator::value() const      Returns a modifiable reference to the current item's value.      You can change the value of an item by using value() on     the left side of an assignment, for example:      \snippet code/src_corelib_tools_qhash.cpp 22      \sa key(), operator*() */
end_comment
begin_comment
comment|/*! \fn T&QHash::iterator::operator*() const      Returns a modifiable reference to the current item's value.      Same as value().      \sa key() */
end_comment
begin_comment
comment|/*! \fn T *QHash::iterator::operator->() const      Returns a pointer to the current item's value.      \sa value() */
end_comment
begin_comment
comment|/*!     \fn bool QHash::iterator::operator==(const iterator&other) const     \fn bool QHash::iterator::operator==(const const_iterator&other) const      Returns true if \a other points to the same item as this     iterator; otherwise returns false.      \sa operator!=() */
end_comment
begin_comment
comment|/*!     \fn bool QHash::iterator::operator!=(const iterator&other) const     \fn bool QHash::iterator::operator!=(const const_iterator&other) const      Returns true if \a other points to a different item than this     iterator; otherwise returns false.      \sa operator==() */
end_comment
begin_comment
comment|/*!     \fn QHash::iterator&QHash::iterator::operator++()      The prefix ++ operator (\c{++i}) advances the iterator to the     next item in the hash and returns an iterator to the new current     item.      Calling this function on QHash::end() leads to undefined results.      \sa operator--() */
end_comment
begin_comment
comment|/*! \fn QHash::iterator QHash::iterator::operator++(int)      \overload      The postfix ++ operator (\c{i++}) advances the iterator to the     next item in the hash and returns an iterator to the previously     current item. */
end_comment
begin_comment
comment|/*!     \fn QHash::iterator&QHash::iterator::operator--()      The prefix -- operator (\c{--i}) makes the preceding item     current and returns an iterator pointing to the new current item.      Calling this function on QHash::begin() leads to undefined     results.      \sa operator++() */
end_comment
begin_comment
comment|/*!     \fn QHash::iterator QHash::iterator::operator--(int)      \overload      The postfix -- operator (\c{i--}) makes the preceding item     current and returns an iterator pointing to the previously     current item. */
end_comment
begin_comment
comment|/*! \fn QHash::iterator QHash::iterator::operator+(int j) const      Returns an iterator to the item at \a j positions forward from     this iterator. (If \a j is negative, the iterator goes backward.)      This operation can be slow for large \a j values.      \sa operator-()  */
end_comment
begin_comment
comment|/*! \fn QHash::iterator QHash::iterator::operator-(int j) const      Returns an iterator to the item at \a j positions backward from     this iterator. (If \a j is negative, the iterator goes forward.)      This operation can be slow for large \a j values.      \sa operator+() */
end_comment
begin_comment
comment|/*! \fn QHash::iterator&QHash::iterator::operator+=(int j)      Advances the iterator by \a j items. (If \a j is negative, the     iterator goes backward.)      \sa operator-=(), operator+() */
end_comment
begin_comment
comment|/*! \fn QHash::iterator&QHash::iterator::operator-=(int j)      Makes the iterator go back by \a j items. (If \a j is negative,     the iterator goes forward.)      \sa operator+=(), operator-() */
end_comment
begin_comment
comment|/*! \class QHash::const_iterator     \inmodule QtCore     \brief The QHash::const_iterator class provides an STL-style const iterator for QHash and QMultiHash.      QHash features both \l{STL-style iterators} and \l{Java-style     iterators}. The STL-style iterators are more low-level and more     cumbersome to use; on the other hand, they are slightly faster     and, for developers who already know STL, have the advantage of     familiarity.      QHash\<Key, T\>::const_iterator allows you to iterate over a     QHash (or a QMultiHash). If you want to modify the QHash as you     iterate over it, you must use QHash::iterator instead. It is     generally good practice to use QHash::const_iterator on a     non-const QHash as well, unless you need to change the QHash     through the iterator. Const iterators are slightly faster, and     can improve code readability.      The default QHash::const_iterator constructor creates an     uninitialized iterator. You must initialize it using a QHash     function like QHash::constBegin(), QHash::constEnd(), or     QHash::find() before you can start iterating. Here's a typical     loop that prints all the (key, value) pairs stored in a hash:      \snippet code/src_corelib_tools_qhash.cpp 23      Unlike QMap, which orders its items by key, QHash stores its     items in an arbitrary order. The only guarantee is that items that     share the same key (because they were inserted using     QHash::insertMulti()) will appear consecutively, from the most     recently to the least recently inserted value.      Multiple iterators can be used on the same hash. However, be aware     that any modification performed directly on the QHash has the     potential of dramatically changing the order in which the items     are stored in the hash, as they might cause QHash to rehash its     internal data structure. If you need to keep iterators over a long     period of time, we recommend that you use QMap rather than QHash.      \sa QHash::iterator, QHashIterator */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator::const_iterator()      Constructs an uninitialized iterator.      Functions like key(), value(), and operator++() must not be     called on an uninitialized iterator. Use operator=() to assign a     value to it before using it.      \sa QHash::constBegin(), QHash::constEnd() */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator::const_iterator(void *node)      \internal */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator::const_iterator(const iterator&other)      Constructs a copy of \a other. */
end_comment
begin_comment
comment|/*! \fn const Key&QHash::const_iterator::key() const      Returns the current item's key.      \sa value() */
end_comment
begin_comment
comment|/*! \fn const T&QHash::const_iterator::value() const      Returns the current item's value.      \sa key(), operator*() */
end_comment
begin_comment
comment|/*! \fn const T&QHash::const_iterator::operator*() const      Returns the current item's value.      Same as value().      \sa key() */
end_comment
begin_comment
comment|/*! \fn const T *QHash::const_iterator::operator->() const      Returns a pointer to the current item's value.      \sa value() */
end_comment
begin_comment
comment|/*! \fn bool QHash::const_iterator::operator==(const const_iterator&other) const      Returns true if \a other points to the same item as this     iterator; otherwise returns false.      \sa operator!=() */
end_comment
begin_comment
comment|/*! \fn bool QHash::const_iterator::operator!=(const const_iterator&other) const      Returns true if \a other points to a different item than this     iterator; otherwise returns false.      \sa operator==() */
end_comment
begin_comment
comment|/*!     \fn QHash::const_iterator&QHash::const_iterator::operator++()      The prefix ++ operator (\c{++i}) advances the iterator to the     next item in the hash and returns an iterator to the new current     item.      Calling this function on QHash::end() leads to undefined results.      \sa operator--() */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator QHash::const_iterator::operator++(int)      \overload      The postfix ++ operator (\c{i++}) advances the iterator to the     next item in the hash and returns an iterator to the previously     current item. */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator&QHash::const_iterator::operator--()      The prefix -- operator (\c{--i}) makes the preceding item     current and returns an iterator pointing to the new current item.      Calling this function on QHash::begin() leads to undefined     results.      \sa operator++() */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator QHash::const_iterator::operator--(int)      \overload      The postfix -- operator (\c{i--}) makes the preceding item     current and returns an iterator pointing to the previously     current item. */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator QHash::const_iterator::operator+(int j) const      Returns an iterator to the item at \a j positions forward from     this iterator. (If \a j is negative, the iterator goes backward.)      This operation can be slow for large \a j values.      \sa operator-() */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator QHash::const_iterator::operator-(int j) const      Returns an iterator to the item at \a j positions backward from     this iterator. (If \a j is negative, the iterator goes forward.)      This operation can be slow for large \a j values.      \sa operator+() */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator&QHash::const_iterator::operator+=(int j)      Advances the iterator by \a j items. (If \a j is negative, the     iterator goes backward.)      This operation can be slow for large \a j values.      \sa operator-=(), operator+() */
end_comment
begin_comment
comment|/*! \fn QHash::const_iterator&QHash::const_iterator::operator-=(int j)      Makes the iterator go back by \a j items. (If \a j is negative,     the iterator goes forward.)      This operation can be slow for large \a j values.      \sa operator+=(), operator-() */
end_comment
begin_comment
comment|/*! \fn QDataStream&operator<<(QDataStream&out, const QHash<Key, T>& hash)     \relates QHash      Writes the hash \a hash to stream \a out.      This function requires the key and value types to implement \c     operator<<().      \sa {Serializing Qt Data Types} */
end_comment
begin_comment
comment|/*! \fn QDataStream&operator>>(QDataStream&in, QHash<Key, T>&hash)     \relates QHash      Reads a hash from stream \a in into \a hash.      This function requires the key and value types to implement \c     operator>>().      \sa {Serializing Qt Data Types} */
end_comment
begin_comment
comment|/*! \class QMultiHash     \inmodule QtCore     \brief The QMultiHash class is a convenience QHash subclass that provides multi-valued hashes.      \ingroup tools     \ingroup shared      \reentrant      QMultiHash\<Key, T\> is one of Qt's generic \l{container classes}.     It inherits QHash and extends it with a few convenience functions     that make it more suitable than QHash for storing multi-valued     hashes. A multi-valued hash is a hash that allows multiple values     with the same key; QHash normally doesn't allow that, unless you     call QHash::insertMulti().      Because QMultiHash inherits QHash, all of QHash's functionality also     applies to QMultiHash. For example, you can use isEmpty() to test     whether the hash is empty, and you can traverse a QMultiHash using     QHash's iterator classes (for example, QHashIterator). But in     addition, it provides an insert() function that corresponds to     QHash::insertMulti(), and a replace() function that corresponds to     QHash::insert(). It also provides convenient operator+() and     operator+=().      Example:     \snippet code/src_corelib_tools_qhash.cpp 24      Unlike QHash, QMultiHash provides no operator[]. Use value() or     replace() if you want to access the most recently inserted item     with a certain key.      If you want to retrieve all the values for a single key, you can     use values(const Key&key), which returns a QList<T>:      \snippet code/src_corelib_tools_qhash.cpp 25      The items that share the same key are available from most     recently to least recently inserted.      A more efficient approach is to call find() to get     the STL-style iterator for the first item with a key and iterate from     there:      \snippet code/src_corelib_tools_qhash.cpp 26      QMultiHash's key and value data types must be \l{assignable data     types}. You cannot, for example, store a QWidget as a value;     instead, store a QWidget *. In addition, QMultiHash's key type     must provide operator==(), and there must also be a global     qHash() function that returns a hash value for an argument of the     key's type. See the QHash documentation for details.      \sa QHash, QHashIterator, QMutableHashIterator, QMultiMap */
end_comment
begin_comment
comment|/*! \fn QMultiHash::QMultiHash()      Constructs an empty hash. */
end_comment
begin_comment
comment|/*! \fn QMultiHash::QMultiHash(std::initializer_list<std::pair<Key,T>> list)     \since 5.1      Constructs a multi hash with a copy of each of the elements in the     initializer list \a list.      This function is only available if the program is being     compiled in C++11 mode. */
end_comment
begin_comment
comment|/*! \fn QMultiHash::QMultiHash(const QHash<Key, T>&other)      Constructs a copy of \a other (which can be a QHash or a     QMultiHash).      \sa operator=() */
end_comment
begin_comment
comment|/*! \fn QMultiHash::iterator QMultiHash::replace(const Key&key, const T&value)      Inserts a new item with the \a key and a value of \a value.      If there is already an item with the \a key, that item's value     is replaced with \a value.      If there are multiple items with the \a key, the most     recently inserted item's value is replaced with \a value.      \sa insert() */
end_comment
begin_comment
comment|/*! \fn QMultiHash::iterator QMultiHash::insert(const Key&key, const T&value)      Inserts a new item with the \a key and a value of \a value.      If there is already an item with the same key in the hash, this     function will simply create a new one. (This behavior is     different from replace(), which overwrites the value of an     existing item.)      \sa replace() */
end_comment
begin_comment
comment|/*! \fn QMultiHash&QMultiHash::operator+=(const QMultiHash&other)      Inserts all the items in the \a other hash into this hash     and returns a reference to this hash.      \sa insert() */
end_comment
begin_comment
comment|/*! \fn QMultiHash QMultiHash::operator+(const QMultiHash&other) const      Returns a hash that contains all the items in this hash in     addition to all the items in \a other. If a key is common to both     hashes, the resulting hash will contain the key multiple times.      \sa operator+=() */
end_comment
begin_comment
comment|/*!     \fn bool QMultiHash::contains(const Key&key, const T&value) const     \since 4.3      Returns true if the hash contains an item with the \a key and     \a value; otherwise returns false.      \sa QHash::contains() */
end_comment
begin_comment
comment|/*!     \fn bool QMultiHash::contains(const Key&key) const     \overload     \sa QHash::contains() */
end_comment
begin_comment
comment|/*!     \fn int QMultiHash::remove(const Key&key, const T&value)     \since 4.3      Removes all the items that have the \a key and the value \a     value from the hash. Returns the number of items removed.      \sa QHash::remove() */
end_comment
begin_comment
comment|/*!     \fn int QMultiHash::remove(const Key&key)     \overload     \sa QHash::remove() */
end_comment
begin_comment
comment|/*!     \fn int QMultiHash::count(const Key&key, const T&value) const     \since 4.3      Returns the number of items with the \a key and \a value.      \sa QHash::count() */
end_comment
begin_comment
comment|/*!     \fn int QMultiHash::count(const Key&key) const     \overload     \sa QHash::count() */
end_comment
begin_comment
comment|/*!     \fn int QMultiHash::count() const     \overload     \sa QHash::count() */
end_comment
begin_comment
comment|/*!     \fn typename QHash<Key, T>::iterator QMultiHash::find(const Key&key, const T&value)     \since 4.3      Returns an iterator pointing to the item with the \a key and \a value.     If the hash contains no such item, the function returns end().      If the hash contains multiple items with the \a key and \a value, the     iterator returned points to the most recently inserted item.      \sa QHash::find() */
end_comment
begin_comment
comment|/*!     \fn typename QHash<Key, T>::iterator QMultiHash::find(const Key&key)     \overload     \sa QHash::find() */
end_comment
begin_comment
comment|/*!     \fn typename QHash<Key, T>::const_iterator QMultiHash::find(const Key&key, const T&value) const     \since 4.3     \overload */
end_comment
begin_comment
comment|/*!     \fn typename QHash<Key, T>::const_iterator QMultiHash::find(const Key&key) const     \overload     \sa QHash::find() */
end_comment
begin_comment
comment|/*!     \fn typename QHash<Key, T>::const_iterator QMultiHash::constFind(const Key&key, const T&value) const     \since 4.3      Returns an iterator pointing to the item with the \a key and the     \a value in the hash.      If the hash contains no such item, the function returns     constEnd().      \sa QHash::constFind() */
end_comment
begin_comment
comment|/*!     \fn typename QHash<Key, T>::const_iterator QMultiHash::constFind(const Key&key) const     \overload     \sa QHash::constFind() */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
