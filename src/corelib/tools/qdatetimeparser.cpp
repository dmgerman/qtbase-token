begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"private/qdatetimeparser_p.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qset.h"
end_include
begin_include
include|#
directive|include
file|"qlocale.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qregexp.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_comment
comment|//#define QDATETIMEPARSER_DEBUG
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QDATETIMEPARSER_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
end_if
begin_define
DECL|macro|QDTPDEBUG
define|#
directive|define
name|QDTPDEBUG
value|qDebug()<< QString("%1:%2").arg(__FILE__).arg(__LINE__)
end_define
begin_define
DECL|macro|QDTPDEBUGN
define|#
directive|define
name|QDTPDEBUGN
value|qDebug
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QDTPDEBUG
define|#
directive|define
name|QDTPDEBUG
value|if (false) qDebug()
end_define
begin_define
DECL|macro|QDTPDEBUGN
define|#
directive|define
name|QDTPDEBUGN
value|if (false) qDebug
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
comment|/*!   \internal   Gets the digit from a datetime. E.g.    QDateTime var(QDate(2004, 02, 02));   int digit = getDigit(var, Year);   // digit = 2004 */
DECL|function|getDigit
name|int
name|QDateTimeParser
operator|::
name|getDigit
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|t
parameter_list|,
name|int
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|sectionNodes
operator|.
name|size
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
name|qWarning
argument_list|(
literal|"QDateTimeParser::getDigit() Internal error (%s %d)"
argument_list|,
name|qPrintable
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"QDateTimeParser::getDigit() Internal error (%d)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
specifier|const
name|SectionNode
modifier|&
name|node
init|=
name|sectionNodes
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
return|;
case|case
name|MinuteSection
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|minute
argument_list|()
return|;
case|case
name|SecondSection
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|second
argument_list|()
return|;
case|case
name|MSecSection
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|msec
argument_list|()
return|;
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
return|return
name|t
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
return|;
case|case
name|MonthSection
case|:
return|return
name|t
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
return|;
case|case
name|DaySection
case|:
return|return
name|t
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
return|;
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
return|return
name|t
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
return|;
case|case
name|AmPmSection
case|:
return|return
name|t
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
operator|>
literal|11
condition|?
literal|1
else|:
literal|0
return|;
default|default:
break|break;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
name|qWarning
argument_list|(
literal|"QDateTimeParser::getDigit() Internal error 2 (%s %d)"
argument_list|,
name|qPrintable
argument_list|(
name|t
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"QDateTimeParser::getDigit() Internal error 2 (%d)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Sets a digit in a datetime. E.g.    QDateTime var(QDate(2004, 02, 02));   int digit = getDigit(var, Year);   // digit = 2004   setDigit(&var, Year, 2005);   digit = getDigit(var, Year);   // digit = 2005 */
end_comment
begin_function
DECL|function|setDigit
name|bool
name|QDateTimeParser
operator|::
name|setDigit
parameter_list|(
name|QDateTime
modifier|&
name|v
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|newVal
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|sectionNodes
operator|.
name|size
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
name|qWarning
argument_list|(
literal|"QDateTimeParser::setDigit() Internal error (%s %d %d)"
argument_list|,
name|qPrintable
argument_list|(
name|v
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|index
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"QDateTimeParser::setDigit() Internal error (%d %d)"
argument_list|,
name|index
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
specifier|const
name|SectionNode
modifier|&
name|node
init|=
name|sectionNodes
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|,
name|msec
decl_stmt|;
name|year
operator|=
name|v
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
expr_stmt|;
name|month
operator|=
name|v
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
expr_stmt|;
name|day
operator|=
name|v
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
expr_stmt|;
name|hour
operator|=
name|v
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
expr_stmt|;
name|minute
operator|=
name|v
operator|.
name|time
argument_list|()
operator|.
name|minute
argument_list|()
expr_stmt|;
name|second
operator|=
name|v
operator|.
name|time
argument_list|()
operator|.
name|second
argument_list|()
expr_stmt|;
name|msec
operator|=
name|v
operator|.
name|time
argument_list|()
operator|.
name|msec
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|node
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
name|hour
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|MinuteSection
case|:
name|minute
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|SecondSection
case|:
name|second
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|MSecSection
case|:
name|msec
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
name|year
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|MonthSection
case|:
name|month
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|DaySection
case|:
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
if|if
condition|(
name|newVal
operator|>
literal|31
condition|)
block|{
comment|// have to keep legacy behavior. setting the
comment|// date to 32 should return false. Setting it
comment|// to 31 for february should return true
return|return
literal|false
return|;
block|}
name|day
operator|=
name|newVal
expr_stmt|;
break|break;
case|case
name|AmPmSection
case|:
name|hour
operator|=
operator|(
name|newVal
operator|==
literal|0
condition|?
name|hour
operator|%
literal|12
else|:
operator|(
name|hour
operator|%
literal|12
operator|)
operator|+
literal|12
operator|)
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::setDigit() Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|node
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|node
operator|.
name|type
operator|&
operator|(
name|DaySection
operator||
name|DayOfWeekSectionShort
operator||
name|DayOfWeekSectionLong
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|day
operator|<
name|cachedDay
condition|)
name|day
operator|=
name|cachedDay
expr_stmt|;
specifier|const
name|int
name|max
init|=
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
literal|1
argument_list|)
operator|.
name|daysInMonth
argument_list|()
decl_stmt|;
if|if
condition|(
name|day
operator|>
name|max
condition|)
block|{
name|day
operator|=
name|max
expr_stmt|;
block|}
block|}
if|if
condition|(
name|QDate
operator|::
name|isValid
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
operator|&&
name|QTime
operator|::
name|isValid
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|msec
argument_list|)
condition|)
block|{
name|v
operator|=
name|QDateTime
argument_list|(
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
argument_list|,
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|msec
argument_list|)
argument_list|,
name|spec
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \    Returns the absolute maximum for a section */
end_comment
begin_function
DECL|function|absoluteMax
name|int
name|QDateTimeParser
operator|::
name|absoluteMax
parameter_list|(
name|int
name|s
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|cur
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|s
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
return|return
literal|23
return|;
comment|// this is special-cased in
comment|// parseSection. We want it to be
comment|// 23 for the stepBy case.
case|case
name|MinuteSection
case|:
case|case
name|SecondSection
case|:
return|return
literal|59
return|;
case|case
name|MSecSection
case|:
return|return
literal|999
return|;
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
return|return
literal|9999
return|;
comment|// sectionMaxSize will prevent
comment|// people from typing in a larger
comment|// number in count == 2 sections.
comment|// stepBy() will work on real years anyway
case|case
name|MonthSection
case|:
return|return
literal|12
return|;
case|case
name|DaySection
case|:
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
return|return
name|cur
operator|.
name|isValid
argument_list|()
condition|?
name|cur
operator|.
name|date
argument_list|()
operator|.
name|daysInMonth
argument_list|()
else|:
literal|31
return|;
case|case
name|AmPmSection
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
name|qWarning
argument_list|(
literal|"QDateTimeParser::absoluteMax() Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the absolute minimum for a section */
end_comment
begin_function
DECL|function|absoluteMin
name|int
name|QDateTimeParser
operator|::
name|absoluteMin
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|s
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
case|case
name|MinuteSection
case|:
case|case
name|SecondSection
case|:
case|case
name|MSecSection
case|:
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
return|return
literal|0
return|;
case|case
name|MonthSection
case|:
case|case
name|DaySection
case|:
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
return|return
literal|1
return|;
case|case
name|AmPmSection
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
name|qWarning
argument_list|(
literal|"QDateTimeParser::absoluteMin() Internal error (%s, %0x)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|,
name|sn
operator|.
name|type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the sectionNode for the Section \a s. */
end_comment
begin_function
DECL|function|sectionNode
specifier|const
name|QDateTimeParser
operator|::
name|SectionNode
modifier|&
name|QDateTimeParser
operator|::
name|sectionNode
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|sectionIndex
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|sectionIndex
condition|)
block|{
case|case
name|FirstSectionIndex
case|:
return|return
name|first
return|;
case|case
name|LastSectionIndex
case|:
return|return
name|last
return|;
case|case
name|NoSectionIndex
case|:
return|return
name|none
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sectionIndex
operator|<
name|sectionNodes
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|sectionNodes
operator|.
name|at
argument_list|(
name|sectionIndex
argument_list|)
return|;
block|}
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionNode() Internal error (%d)"
argument_list|,
name|sectionIndex
argument_list|)
expr_stmt|;
return|return
name|none
return|;
block|}
end_function
begin_function
DECL|function|sectionType
name|QDateTimeParser
operator|::
name|Section
name|QDateTimeParser
operator|::
name|sectionType
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
return|return
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
operator|.
name|type
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the starting position for section \a s. */
end_comment
begin_function
DECL|function|sectionPos
name|int
name|QDateTimeParser
operator|::
name|sectionPos
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
return|return
name|sectionPos
argument_list|(
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sectionPos
name|int
name|QDateTimeParser
operator|::
name|sectionPos
parameter_list|(
specifier|const
name|SectionNode
modifier|&
name|sn
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|FirstSection
case|:
return|return
literal|0
return|;
case|case
name|LastSection
case|:
return|return
name|displayText
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|sn
operator|.
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionPos Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|sn
operator|.
name|pos
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    helper function for parseFormat. removes quotes that are   not escaped and removes the escaping on those that are escaped  */
end_comment
begin_function
DECL|function|unquote
specifier|static
name|QString
name|unquote
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
specifier|const
name|QChar
name|quote
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\''
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QChar
name|slash
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QChar
name|zero
argument_list|(
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|ret
decl_stmt|;
name|QChar
name|status
argument_list|(
name|zero
argument_list|)
decl_stmt|;
specifier|const
name|int
name|max
init|=
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|quote
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|quote
condition|)
block|{
name|status
operator|=
name|quote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ret
operator|.
name|isEmpty
argument_list|()
operator|&&
name|str
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|==
name|slash
condition|)
block|{
name|ret
index|[
name|ret
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
operator|=
name|quote
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|zero
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|+=
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Parses the format \a newFormat. If successful, returns true and   sets up the format. Else keeps the old format and returns false.  */
end_comment
begin_function
DECL|function|countRepeat
specifier|static
specifier|inline
name|int
name|countRepeat
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|maxCount
parameter_list|)
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
specifier|const
name|QChar
name|ch
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|int
name|max
init|=
name|qMin
argument_list|(
name|index
operator|+
name|maxCount
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|index
operator|+
name|count
operator|<
name|max
operator|&&
name|str
operator|.
name|at
argument_list|(
name|index
operator|+
name|count
argument_list|)
operator|==
name|ch
condition|)
block|{
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function
begin_function
DECL|function|appendSeparator
specifier|static
specifier|inline
name|void
name|appendSeparator
parameter_list|(
name|QStringList
modifier|*
name|list
parameter_list|,
specifier|const
name|QString
modifier|&
name|string
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|lastQuote
parameter_list|)
block|{
name|QString
name|str
argument_list|(
name|string
operator|.
name|mid
argument_list|(
name|from
argument_list|,
name|size
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastQuote
operator|>=
name|from
condition|)
name|str
operator|=
name|unquote
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|list
operator|->
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseFormat
name|bool
name|QDateTimeParser
operator|::
name|parseFormat
parameter_list|(
specifier|const
name|QString
modifier|&
name|newFormat
parameter_list|)
block|{
specifier|const
name|QLatin1Char
name|quote
argument_list|(
literal|'\''
argument_list|)
decl_stmt|;
specifier|const
name|QLatin1Char
name|slash
argument_list|(
literal|'\\'
argument_list|)
decl_stmt|;
specifier|const
name|QLatin1Char
name|zero
argument_list|(
literal|'0'
argument_list|)
decl_stmt|;
if|if
condition|(
name|newFormat
operator|==
name|displayFormat
operator|&&
operator|!
name|newFormat
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|QDTPDEBUGN
argument_list|(
literal|"parseFormat: %s"
argument_list|,
name|newFormat
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|SectionNode
argument_list|>
name|newSectionNodes
decl_stmt|;
name|Sections
name|newDisplay
init|=
literal|0
decl_stmt|;
name|QStringList
name|newSeparators
decl_stmt|;
name|int
name|i
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
name|int
name|add
init|=
literal|0
decl_stmt|;
name|QChar
name|status
argument_list|(
name|zero
argument_list|)
decl_stmt|;
specifier|const
name|int
name|max
init|=
name|newFormat
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|lastQuote
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|newFormat
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|quote
condition|)
block|{
name|lastQuote
operator|=
name|i
expr_stmt|;
operator|++
name|add
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|quote
condition|)
block|{
name|status
operator|=
name|quote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newFormat
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|!=
name|slash
condition|)
block|{
name|status
operator|=
name|zero
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|quote
condition|)
block|{
specifier|const
name|char
name|sect
init|=
name|newFormat
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|sect
condition|)
block|{
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|Section
name|hour
init|=
operator|(
name|sect
operator|==
literal|'h'
operator|)
condition|?
name|Hour12Section
else|:
name|Hour24Section
decl_stmt|;
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|hour
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|hour
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|MinuteSection
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|MinuteSection
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|SecondSection
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|SecondSection
expr_stmt|;
block|}
break|break;
case|case
literal|'z'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|MSecSection
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
operator|?
literal|1
operator|:
literal|3
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|MSecSection
expr_stmt|;
block|}
break|break;
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
specifier|const
name|bool
name|cap
init|=
operator|(
name|sect
operator|==
literal|'A'
operator|)
decl_stmt|;
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|AmPmSection
block|,
name|i
operator|-
name|add
block|,
operator|(
name|cap
operator|?
literal|1
operator|:
literal|0
operator|)
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|newDisplay
operator||=
name|AmPmSection
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|newFormat
operator|.
name|size
argument_list|()
operator|&&
name|newFormat
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
operator|(
name|cap
condition|?
name|QLatin1Char
argument_list|(
literal|'P'
argument_list|)
else|:
name|QLatin1Char
argument_list|(
literal|'p'
argument_list|)
operator|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'y'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Time
condition|)
block|{
specifier|const
name|int
name|repeat
init|=
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|repeat
operator|>=
literal|2
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|repeat
operator|==
literal|4
operator|?
name|YearSection
operator|:
name|YearSection2Digits
block|,
name|i
operator|-
name|add
block|,
name|repeat
operator|==
literal|4
operator|?
literal|4
operator|:
literal|2
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|sn
operator|.
name|type
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Time
condition|)
block|{
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|MonthSection
block|,
name|i
operator|-
name|add
block|,
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|newSeparators
operator|.
name|append
argument_list|(
name|unquote
argument_list|(
name|newFormat
operator|.
name|mid
argument_list|(
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|MonthSection
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Time
condition|)
block|{
specifier|const
name|int
name|repeat
init|=
name|countRepeat
argument_list|(
name|newFormat
argument_list|,
name|i
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|const
name|Section
name|sectionType
init|=
operator|(
name|repeat
operator|==
literal|4
condition|?
name|DayOfWeekSectionLong
else|:
operator|(
name|repeat
operator|==
literal|3
condition|?
name|DayOfWeekSectionShort
else|:
name|DaySection
operator|)
operator|)
decl_stmt|;
specifier|const
name|SectionNode
name|sn
init|=
block|{
name|sectionType
block|,
name|i
operator|-
name|add
block|,
name|repeat
block|,
literal|0
block|}
decl_stmt|;
name|newSectionNodes
operator|.
name|append
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|i
operator|-
name|index
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
name|i
operator|+=
name|sn
operator|.
name|count
operator|-
literal|1
expr_stmt|;
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|newDisplay
operator||=
name|sn
operator|.
name|type
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
if|if
condition|(
name|newSectionNodes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|context
operator|==
name|DateTimeEdit
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|newDisplay
operator|&
operator|(
name|AmPmSection
operator||
name|Hour12Section
operator|)
operator|)
operator|==
name|Hour12Section
condition|)
block|{
specifier|const
name|int
name|max
init|=
name|newSectionNodes
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
name|SectionNode
modifier|&
name|node
init|=
name|newSectionNodes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|type
operator|==
name|Hour12Section
condition|)
name|node
operator|.
name|type
operator|=
name|Hour24Section
expr_stmt|;
block|}
block|}
if|if
condition|(
name|index
operator|<
name|newFormat
operator|.
name|size
argument_list|()
condition|)
block|{
name|appendSeparator
argument_list|(
operator|&
name|newSeparators
argument_list|,
name|newFormat
argument_list|,
name|index
argument_list|,
name|index
operator|-
name|max
argument_list|,
name|lastQuote
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newSeparators
operator|.
name|append
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|displayFormat
operator|=
name|newFormat
expr_stmt|;
name|separators
operator|=
name|newSeparators
expr_stmt|;
name|sectionNodes
operator|=
name|newSectionNodes
expr_stmt|;
name|display
operator|=
name|newDisplay
expr_stmt|;
name|last
operator|.
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
comment|//     for (int i=0; i<sectionNodes.size(); ++i) {
comment|//         QDTPDEBUG<< sectionName(sectionNodes.at(i).type)<< sectionNodes.at(i).count;
comment|//     }
name|QDTPDEBUG
operator|<<
name|newFormat
operator|<<
name|displayFormat
expr_stmt|;
name|QDTPDEBUGN
argument_list|(
literal|"separators:\n'%s'"
argument_list|,
name|separators
operator|.
name|join
argument_list|(
name|QLatin1String
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the size of section \a s. */
end_comment
begin_function
DECL|function|sectionSize
name|int
name|QDateTimeParser
operator|::
name|sectionSize
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|sectionIndex
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sectionIndex
operator|>=
name|sectionNodes
operator|.
name|size
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionSize Internal error (%d)"
argument_list|,
name|sectionIndex
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|sectionIndex
operator|==
name|sectionNodes
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
comment|// In some cases there is a difference between displayText() and text.
comment|// e.g. when text is 2000/01/31 and displayText() is "2000/2/31" - text
comment|// is the previous value and displayText() is the new value.
comment|// The size difference is always due to leading zeroes.
name|int
name|sizeAdjustment
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|displayText
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|text
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// Any zeroes added before this section will affect our size.
name|int
name|preceedingZeroesAdded
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sectionNodes
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|&&
name|context
operator|==
name|DateTimeEdit
condition|)
block|{
for|for
control|(
name|QVector
argument_list|<
name|SectionNode
argument_list|>
operator|::
name|ConstIterator
name|sectionIt
init|=
name|sectionNodes
operator|.
name|constBegin
argument_list|()
init|;
name|sectionIt
operator|!=
name|sectionNodes
operator|.
name|constBegin
argument_list|()
operator|+
name|sectionIndex
condition|;
operator|++
name|sectionIt
control|)
block|{
name|preceedingZeroesAdded
operator|+=
name|sectionIt
operator|->
name|zeroesAdded
expr_stmt|;
block|}
block|}
name|sizeAdjustment
operator|=
name|preceedingZeroesAdded
expr_stmt|;
block|}
return|return
name|displayText
argument_list|()
operator|.
name|size
argument_list|()
operator|+
name|sizeAdjustment
operator|-
name|sectionPos
argument_list|(
name|sectionIndex
argument_list|)
operator|-
name|separators
operator|.
name|last
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|sectionPos
argument_list|(
name|sectionIndex
operator|+
literal|1
argument_list|)
operator|-
name|sectionPos
argument_list|(
name|sectionIndex
argument_list|)
operator|-
name|separators
operator|.
name|at
argument_list|(
name|sectionIndex
operator|+
literal|1
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
block|}
end_function
begin_function
DECL|function|sectionMaxSize
name|int
name|QDateTimeParser
operator|::
name|sectionMaxSize
parameter_list|(
name|Section
name|s
parameter_list|,
name|int
name|count
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
name|int
name|mcount
init|=
literal|12
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|FirstSection
case|:
case|case
name|NoSection
case|:
case|case
name|LastSection
case|:
return|return
literal|0
return|;
case|case
name|AmPmSection
case|:
block|{
specifier|const
name|int
name|lowerMax
init|=
name|qMin
argument_list|(
name|getAmPmText
argument_list|(
name|AmText
argument_list|,
name|LowerCase
argument_list|)
operator|.
name|size
argument_list|()
argument_list|,
name|getAmPmText
argument_list|(
name|PmText
argument_list|,
name|LowerCase
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|int
name|upperMax
init|=
name|qMin
argument_list|(
name|getAmPmText
argument_list|(
name|AmText
argument_list|,
name|UpperCase
argument_list|)
operator|.
name|size
argument_list|()
argument_list|,
name|getAmPmText
argument_list|(
name|PmText
argument_list|,
name|UpperCase
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|qMin
argument_list|(
literal|4
argument_list|,
name|qMin
argument_list|(
name|lowerMax
argument_list|,
name|upperMax
argument_list|)
argument_list|)
return|;
block|}
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
case|case
name|MinuteSection
case|:
case|case
name|SecondSection
case|:
case|case
name|DaySection
case|:
return|return
literal|2
return|;
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
ifdef|#
directive|ifdef
name|QT_NO_TEXTDATE
return|return
literal|2
return|;
else|#
directive|else
name|mcount
operator|=
literal|7
expr_stmt|;
comment|// fall through
endif|#
directive|endif
case|case
name|MonthSection
case|:
if|if
condition|(
name|count
operator|<=
literal|2
condition|)
return|return
literal|2
return|;
ifdef|#
directive|ifdef
name|QT_NO_TEXTDATE
return|return
literal|2
return|;
else|#
directive|else
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|QLocale
name|l
init|=
name|locale
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|mcount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
name|str
init|=
operator|(
name|s
operator|==
name|MonthSection
condition|?
name|l
operator|.
name|monthName
argument_list|(
name|i
argument_list|,
name|count
operator|==
literal|4
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
else|:
name|l
operator|.
name|dayName
argument_list|(
name|i
argument_list|,
name|count
operator|==
literal|4
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
operator|)
decl_stmt|;
name|ret
operator|=
name|qMax
argument_list|(
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
endif|#
directive|endif
case|case
name|MSecSection
case|:
return|return
literal|3
return|;
case|case
name|YearSection
case|:
return|return
literal|4
return|;
case|case
name|YearSection2Digits
case|:
return|return
literal|2
return|;
case|case
name|CalendarPopupSection
case|:
case|case
name|Internal
case|:
case|case
name|TimeSectionMask
case|:
case|case
name|DateSectionMask
case|:
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionMaxSize: Invalid section %s"
argument_list|,
name|sectionName
argument_list|(
name|s
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|NoSectionIndex
case|:
case|case
name|FirstSectionIndex
case|:
case|case
name|LastSectionIndex
case|:
case|case
name|CalendarPopupIndex
case|:
comment|// these cases can't happen
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|sectionMaxSize
name|int
name|QDateTimeParser
operator|::
name|sectionMaxSize
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|sectionMaxSize
argument_list|(
name|sn
operator|.
name|type
argument_list|,
name|sn
operator|.
name|count
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns the text of section \a s. This function operates on the   arg text rather than edit->text(). */
end_comment
begin_function
DECL|function|sectionText
name|QString
name|QDateTimeParser
operator|::
name|sectionText
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|int
name|sectionIndex
parameter_list|,
name|int
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|NoSectionIndex
case|:
case|case
name|FirstSectionIndex
case|:
case|case
name|LastSectionIndex
case|:
return|return
name|QString
argument_list|()
return|;
default|default:
break|break;
block|}
return|return
name|text
operator|.
name|mid
argument_list|(
name|index
argument_list|,
name|sectionSize
argument_list|(
name|sectionIndex
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sectionText
name|QString
name|QDateTimeParser
operator|::
name|sectionText
parameter_list|(
name|int
name|sectionIndex
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|NoSectionIndex
case|:
case|case
name|FirstSectionIndex
case|:
case|case
name|LastSectionIndex
case|:
return|return
name|QString
argument_list|()
return|;
default|default:
break|break;
block|}
return|return
name|displayText
argument_list|()
operator|.
name|mid
argument_list|(
name|sn
operator|.
name|pos
argument_list|,
name|sectionSize
argument_list|(
name|sectionIndex
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_comment
comment|/*!   \internal:skipToNextSection    Parses the part of \a text that corresponds to \a s and returns   the value of that field. Sets *stateptr to the right state if   stateptr != 0. */
end_comment
begin_function
DECL|function|parseSection
name|int
name|QDateTimeParser
operator|::
name|parseSection
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|currentValue
parameter_list|,
name|int
name|sectionIndex
parameter_list|,
name|QString
modifier|&
name|text
parameter_list|,
name|int
modifier|&
name|cursorPosition
parameter_list|,
name|int
name|index
parameter_list|,
name|State
modifier|&
name|state
parameter_list|,
name|int
modifier|*
name|usedptr
parameter_list|)
specifier|const
block|{
name|state
operator|=
name|Invalid
expr_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sn
operator|.
name|type
operator|&
name|Internal
operator|)
operator|==
name|Internal
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::parseSection Internal error (%s %d)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|,
name|sectionIndex
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
specifier|const
name|int
name|sectionmaxsize
init|=
name|sectionMaxSize
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
name|QString
name|sectiontext
init|=
name|text
operator|.
name|mid
argument_list|(
name|index
argument_list|,
name|sectionmaxsize
argument_list|)
decl_stmt|;
name|int
name|sectiontextSize
init|=
name|sectiontext
operator|.
name|size
argument_list|()
decl_stmt|;
name|QDTPDEBUG
operator|<<
literal|"sectionValue for"
operator|<<
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
operator|<<
literal|"with text"
operator|<<
name|text
operator|<<
literal|"and st"
operator|<<
name|sectiontext
operator|<<
name|text
operator|.
name|mid
argument_list|(
name|index
argument_list|,
name|sectionmaxsize
argument_list|)
operator|<<
name|index
expr_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|AmPmSection
case|:
block|{
specifier|const
name|int
name|ampm
init|=
name|findAmPm
argument_list|(
name|sectiontext
argument_list|,
name|sectionIndex
argument_list|,
operator|&
name|used
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ampm
condition|)
block|{
case|case
name|AM
case|:
comment|// sectiontext == AM
case|case
name|PM
case|:
comment|// sectiontext == PM
name|num
operator|=
name|ampm
expr_stmt|;
name|state
operator|=
name|Acceptable
expr_stmt|;
break|break;
case|case
name|PossibleAM
case|:
comment|// sectiontext => AM
case|case
name|PossiblePM
case|:
comment|// sectiontext => PM
name|num
operator|=
name|ampm
operator|-
literal|2
expr_stmt|;
name|state
operator|=
name|Intermediate
expr_stmt|;
break|break;
case|case
name|PossibleBoth
case|:
comment|// sectiontext => AM|PM
name|num
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|Intermediate
expr_stmt|;
break|break;
case|case
name|Neither
case|:
name|state
operator|=
name|Invalid
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"invalid because findAmPm("
operator|<<
name|sectiontext
operator|<<
literal|") returned -1"
expr_stmt|;
break|break;
default|default:
name|QDTPDEBUGN
argument_list|(
literal|"This should never happen (findAmPm returned %d)"
argument_list|,
name|ampm
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|state
operator|!=
name|Invalid
condition|)
block|{
name|QString
name|str
init|=
name|text
decl_stmt|;
name|text
operator|.
name|replace
argument_list|(
name|index
argument_list|,
name|used
argument_list|,
name|sectiontext
operator|.
name|left
argument_list|(
name|used
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MonthSection
case|:
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
if|if
condition|(
name|sn
operator|.
name|count
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|sn
operator|.
name|type
operator|==
name|MonthSection
condition|)
block|{
name|int
name|min
init|=
literal|1
decl_stmt|;
specifier|const
name|QDate
name|minDate
init|=
name|getMinimum
argument_list|()
operator|.
name|date
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
operator|==
name|minDate
operator|.
name|year
argument_list|()
condition|)
block|{
name|min
operator|=
name|minDate
operator|.
name|month
argument_list|()
expr_stmt|;
block|}
name|num
operator|=
name|findMonth
argument_list|(
name|sectiontext
operator|.
name|toLower
argument_list|()
argument_list|,
name|min
argument_list|,
name|sectionIndex
argument_list|,
operator|&
name|sectiontext
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|=
name|findDay
argument_list|(
name|sectiontext
operator|.
name|toLower
argument_list|()
argument_list|,
literal|1
argument_list|,
name|sectionIndex
argument_list|,
operator|&
name|sectiontext
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
name|state
operator|=
operator|(
name|used
operator|==
name|sectiontext
operator|.
name|size
argument_list|()
condition|?
name|Acceptable
else|:
name|Intermediate
operator|)
expr_stmt|;
name|QString
name|str
init|=
name|text
decl_stmt|;
name|text
operator|.
name|replace
argument_list|(
name|index
argument_list|,
name|used
argument_list|,
name|sectiontext
operator|.
name|left
argument_list|(
name|used
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|Intermediate
expr_stmt|;
block|}
break|break;
block|}
comment|// fall through
case|case
name|DaySection
case|:
case|case
name|YearSection
case|:
case|case
name|YearSection2Digits
case|:
case|case
name|Hour12Section
case|:
case|case
name|Hour24Section
case|:
case|case
name|MinuteSection
case|:
case|case
name|SecondSection
case|:
case|case
name|MSecSection
case|:
block|{
if|if
condition|(
name|sectiontextSize
operator|==
literal|0
condition|)
block|{
name|num
operator|=
literal|0
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|Intermediate
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|absMax
init|=
name|absoluteMax
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
name|QLocale
name|loc
decl_stmt|;
name|bool
name|ok
init|=
literal|true
decl_stmt|;
name|int
name|last
init|=
operator|-
literal|1
decl_stmt|;
name|used
operator|=
operator|-
literal|1
expr_stmt|;
name|QString
name|digitsStr
argument_list|(
name|sectiontext
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sectiontextSize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|digitsStr
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
block|{
name|sectiontextSize
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
specifier|const
name|int
name|max
init|=
name|qMin
argument_list|(
name|sectionmaxsize
argument_list|,
name|sectiontextSize
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|digits
init|=
name|max
init|;
name|digits
operator|>=
literal|1
condition|;
operator|--
name|digits
control|)
block|{
name|digitsStr
operator|.
name|truncate
argument_list|(
name|digits
argument_list|)
expr_stmt|;
name|int
name|tmp
init|=
operator|(
name|int
operator|)
name|loc
operator|.
name|toUInt
argument_list|(
name|digitsStr
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
operator|&&
name|sn
operator|.
name|type
operator|==
name|Hour12Section
condition|)
block|{
if|if
condition|(
name|tmp
operator|>
literal|12
condition|)
block|{
name|tmp
operator|=
operator|-
literal|1
expr_stmt|;
name|ok
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmp
operator|==
literal|12
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ok
operator|&&
name|tmp
operator|<=
name|absMax
condition|)
block|{
name|QDTPDEBUG
operator|<<
name|sectiontext
operator|.
name|left
argument_list|(
name|digits
argument_list|)
operator|<<
name|tmp
operator|<<
name|digits
expr_stmt|;
name|last
operator|=
name|tmp
expr_stmt|;
name|used
operator|=
name|digits
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|last
operator|==
operator|-
literal|1
condition|)
block|{
name|QChar
name|first
argument_list|(
name|sectiontext
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|separators
operator|.
name|at
argument_list|(
name|sectionIndex
operator|+
literal|1
argument_list|)
operator|.
name|startsWith
argument_list|(
name|first
argument_list|)
condition|)
block|{
name|used
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|Intermediate
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|Invalid
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"invalid because"
operator|<<
name|sectiontext
operator|<<
literal|"can't become a uint"
operator|<<
name|last
operator|<<
name|ok
expr_stmt|;
block|}
block|}
else|else
block|{
name|num
operator|+=
name|last
expr_stmt|;
specifier|const
name|FieldInfo
name|fi
init|=
name|fieldInfo
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
specifier|const
name|bool
name|done
init|=
operator|(
name|used
operator|==
name|sectionmaxsize
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|done
operator|&&
name|fi
operator|&
name|Fraction
condition|)
block|{
comment|// typing 2 in a zzz field should be .200, not .002
for|for
control|(
name|int
name|i
init|=
name|used
init|;
name|i
operator|<
name|sectionmaxsize
condition|;
operator|++
name|i
control|)
block|{
name|num
operator|*=
literal|10
expr_stmt|;
block|}
block|}
specifier|const
name|int
name|absMin
init|=
name|absoluteMin
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|<
name|absMin
condition|)
block|{
name|state
operator|=
name|done
condition|?
name|Invalid
else|:
name|Intermediate
expr_stmt|;
if|if
condition|(
name|done
condition|)
name|QDTPDEBUG
operator|<<
literal|"invalid because"
operator|<<
name|num
operator|<<
literal|"is less than absoluteMin"
operator|<<
name|absMin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num
operator|>
name|absMax
condition|)
block|{
name|state
operator|=
name|Intermediate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|done
operator|&&
operator|(
name|fi
operator|&
operator|(
name|FixedWidth
operator||
name|Numeric
operator|)
operator|)
operator|==
operator|(
name|FixedWidth
operator||
name|Numeric
operator|)
condition|)
block|{
if|if
condition|(
name|skipToNextSection
argument_list|(
name|sectionIndex
argument_list|,
name|currentValue
argument_list|,
name|digitsStr
argument_list|)
condition|)
block|{
name|state
operator|=
name|Acceptable
expr_stmt|;
specifier|const
name|int
name|missingZeroes
init|=
name|sectionmaxsize
operator|-
name|digitsStr
operator|.
name|size
argument_list|()
decl_stmt|;
name|text
operator|.
name|insert
argument_list|(
name|index
argument_list|,
name|QString
argument_list|()
operator|.
name|fill
argument_list|(
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|,
name|missingZeroes
argument_list|)
argument_list|)
expr_stmt|;
name|used
operator|=
name|sectionmaxsize
expr_stmt|;
name|cursorPosition
operator|+=
name|missingZeroes
expr_stmt|;
operator|++
operator|(
cast|const_cast
argument_list|<
name|QDateTimeParser
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|sectionNodes
index|[
name|sectionIndex
index|]
operator|.
name|zeroesAdded
operator|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|Intermediate
expr_stmt|;
empty_stmt|;
block|}
block|}
else|else
block|{
name|state
operator|=
name|Acceptable
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::parseSection Internal error (%s %d)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|,
name|sectionIndex
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|usedptr
condition|)
operator|*
name|usedptr
operator|=
name|used
expr_stmt|;
return|return
operator|(
name|state
operator|!=
name|Invalid
condition|?
name|num
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTDATE
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|parse
name|QDateTimeParser
operator|::
name|StateNode
name|QDateTimeParser
operator|::
name|parse
parameter_list|(
name|QString
modifier|&
name|input
parameter_list|,
name|int
modifier|&
name|cursorPosition
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|currentValue
parameter_list|,
name|bool
name|fixup
parameter_list|)
specifier|const
block|{
specifier|const
name|QDateTime
name|minimum
init|=
name|getMinimum
argument_list|()
decl_stmt|;
specifier|const
name|QDateTime
name|maximum
init|=
name|getMaximum
argument_list|()
decl_stmt|;
name|State
name|state
init|=
name|Acceptable
decl_stmt|;
name|QDateTime
name|newCurrentValue
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|bool
name|conflicts
init|=
literal|false
decl_stmt|;
specifier|const
name|int
name|sectionNodesCount
init|=
name|sectionNodes
operator|.
name|size
argument_list|()
decl_stmt|;
name|QDTPDEBUG
operator|<<
literal|"parse"
operator|<<
name|input
expr_stmt|;
block|{
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hour12
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|,
name|msec
decl_stmt|,
name|ampm
decl_stmt|,
name|dayofweek
decl_stmt|,
name|year2digits
decl_stmt|;
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|getDate
argument_list|(
operator|&
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|)
expr_stmt|;
name|year2digits
operator|=
name|year
operator|%
literal|100
expr_stmt|;
name|hour
operator|=
name|currentValue
operator|.
name|time
argument_list|()
operator|.
name|hour
argument_list|()
expr_stmt|;
name|hour12
operator|=
operator|-
literal|1
expr_stmt|;
name|minute
operator|=
name|currentValue
operator|.
name|time
argument_list|()
operator|.
name|minute
argument_list|()
expr_stmt|;
name|second
operator|=
name|currentValue
operator|.
name|time
argument_list|()
operator|.
name|second
argument_list|()
expr_stmt|;
name|msec
operator|=
name|currentValue
operator|.
name|time
argument_list|()
operator|.
name|msec
argument_list|()
expr_stmt|;
name|dayofweek
operator|=
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|dayOfWeek
argument_list|()
expr_stmt|;
name|ampm
operator|=
operator|-
literal|1
expr_stmt|;
name|Sections
name|isSet
init|=
name|NoSection
decl_stmt|;
name|int
name|num
decl_stmt|;
name|State
name|tmpstate
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|state
operator|!=
name|Invalid
operator|&&
name|index
operator|<
name|sectionNodesCount
condition|;
operator|++
name|index
control|)
block|{
if|if
condition|(
name|QStringRef
argument_list|(
operator|&
name|input
argument_list|,
name|pos
argument_list|,
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
operator|!=
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"invalid because"
operator|<<
name|input
operator|.
name|mid
argument_list|(
name|pos
argument_list|,
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
operator|<<
literal|"!="
operator|<<
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|<<
name|index
operator|<<
name|pos
operator|<<
name|currentSectionIndex
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|pos
operator|+=
name|separators
operator|.
name|at
argument_list|(
name|index
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
name|sectionNodes
index|[
name|index
index|]
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
name|int
modifier|*
name|current
init|=
literal|0
decl_stmt|;
specifier|const
name|SectionNode
name|sn
init|=
name|sectionNodes
operator|.
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|used
decl_stmt|;
name|num
operator|=
name|parseSection
argument_list|(
name|currentValue
argument_list|,
name|index
argument_list|,
name|input
argument_list|,
name|cursorPosition
argument_list|,
name|pos
argument_list|,
name|tmpstate
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"sectionValue"
operator|<<
name|sectionName
argument_list|(
name|sectionType
argument_list|(
name|index
argument_list|)
argument_list|)
operator|<<
name|input
operator|<<
literal|"pos"
operator|<<
name|pos
operator|<<
literal|"used"
operator|<<
name|used
operator|<<
name|stateName
argument_list|(
name|tmpstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixup
operator|&&
name|tmpstate
operator|==
name|Intermediate
operator|&&
name|used
operator|<
name|sn
operator|.
name|count
condition|)
block|{
specifier|const
name|FieldInfo
name|fi
init|=
name|fieldInfo
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|fi
operator|&
operator|(
name|Numeric
operator||
name|FixedWidth
operator|)
operator|)
operator|==
operator|(
name|Numeric
operator||
name|FixedWidth
operator|)
condition|)
block|{
specifier|const
name|QString
name|newText
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1"
argument_list|)
operator|.
name|arg
argument_list|(
name|num
argument_list|,
name|sn
operator|.
name|count
argument_list|,
literal|10
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
argument_list|)
argument_list|)
decl_stmt|;
name|input
operator|.
name|replace
argument_list|(
name|pos
argument_list|,
name|used
argument_list|,
name|newText
argument_list|)
expr_stmt|;
name|used
operator|=
name|sn
operator|.
name|count
expr_stmt|;
block|}
block|}
name|pos
operator|+=
name|qMax
argument_list|(
literal|0
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|state
operator|=
name|qMin
argument_list|<
name|State
argument_list|>
argument_list|(
name|state
argument_list|,
name|tmpstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|Intermediate
operator|&&
name|context
operator|==
name|FromString
condition|)
block|{
name|state
operator|=
name|Invalid
expr_stmt|;
break|break;
block|}
name|QDTPDEBUG
operator|<<
name|index
operator|<<
name|sectionName
argument_list|(
name|sectionType
argument_list|(
name|index
argument_list|)
argument_list|)
operator|<<
literal|"is set to"
operator|<<
name|pos
operator|<<
literal|"state is"
operator|<<
name|stateName
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|Invalid
condition|)
block|{
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|Hour24Section
case|:
name|current
operator|=
operator|&
name|hour
expr_stmt|;
break|break;
case|case
name|Hour12Section
case|:
name|current
operator|=
operator|&
name|hour12
expr_stmt|;
break|break;
case|case
name|MinuteSection
case|:
name|current
operator|=
operator|&
name|minute
expr_stmt|;
break|break;
case|case
name|SecondSection
case|:
name|current
operator|=
operator|&
name|second
expr_stmt|;
break|break;
case|case
name|MSecSection
case|:
name|current
operator|=
operator|&
name|msec
expr_stmt|;
break|break;
case|case
name|YearSection
case|:
name|current
operator|=
operator|&
name|year
expr_stmt|;
break|break;
case|case
name|YearSection2Digits
case|:
name|current
operator|=
operator|&
name|year2digits
expr_stmt|;
break|break;
case|case
name|MonthSection
case|:
name|current
operator|=
operator|&
name|month
expr_stmt|;
break|break;
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
name|current
operator|=
operator|&
name|dayofweek
expr_stmt|;
break|break;
case|case
name|DaySection
case|:
name|current
operator|=
operator|&
name|day
expr_stmt|;
name|num
operator|=
name|qMax
argument_list|<
name|int
argument_list|>
argument_list|(
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
name|AmPmSection
case|:
name|current
operator|=
operator|&
name|ampm
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::parse Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|current
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::parse Internal error 2"
argument_list|)
expr_stmt|;
return|return
name|StateNode
argument_list|()
return|;
block|}
if|if
condition|(
name|isSet
operator|&
name|sn
operator|.
name|type
operator|&&
operator|*
name|current
operator|!=
name|num
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"CONFLICT "
operator|<<
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
operator|<<
operator|*
name|current
operator|<<
name|num
expr_stmt|;
name|conflicts
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|index
operator|!=
name|currentSectionIndex
operator|||
name|num
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
operator|*
name|current
operator|=
name|num
expr_stmt|;
name|isSet
operator||=
name|sn
operator|.
name|type
expr_stmt|;
block|}
block|}
if|if
condition|(
name|state
operator|!=
name|Invalid
operator|&&
name|QStringRef
argument_list|(
operator|&
name|input
argument_list|,
name|pos
argument_list|,
name|input
operator|.
name|size
argument_list|()
operator|-
name|pos
argument_list|)
operator|!=
name|separators
operator|.
name|last
argument_list|()
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"invalid because"
operator|<<
name|input
operator|.
name|mid
argument_list|(
name|pos
argument_list|)
operator|<<
literal|"!="
operator|<<
name|separators
operator|.
name|last
argument_list|()
operator|<<
name|pos
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|!=
name|Invalid
condition|)
block|{
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Time
condition|)
block|{
if|if
condition|(
name|year
operator|%
literal|100
operator|!=
name|year2digits
condition|)
block|{
switch|switch
condition|(
name|isSet
operator|&
operator|(
name|YearSection2Digits
operator||
name|YearSection
operator|)
condition|)
block|{
case|case
name|YearSection2Digits
case|:
name|year
operator|=
operator|(
name|year
operator|/
literal|100
operator|)
operator|*
literal|100
expr_stmt|;
name|year
operator|+=
name|year2digits
expr_stmt|;
break|break;
case|case
operator|(
operator|(
name|uint
operator|)
name|YearSection2Digits
operator||
operator|(
name|uint
operator|)
name|YearSection
operator|)
case|:
block|{
name|conflicts
operator|=
literal|true
expr_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|currentSectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|==
name|YearSection2Digits
condition|)
block|{
name|year
operator|=
operator|(
name|year
operator|/
literal|100
operator|)
operator|*
literal|100
expr_stmt|;
name|year
operator|+=
name|year2digits
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
specifier|const
name|QDate
name|date
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
decl_stmt|;
specifier|const
name|int
name|diff
init|=
name|dayofweek
operator|-
name|date
operator|.
name|dayOfWeek
argument_list|()
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
operator|&&
name|state
operator|==
name|Acceptable
operator|&&
name|isSet
operator|&
operator|(
name|DayOfWeekSectionShort
operator||
name|DayOfWeekSectionLong
operator|)
condition|)
block|{
name|conflicts
operator|=
name|isSet
operator|&
name|DaySection
expr_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|currentSectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|&
operator|(
name|DayOfWeekSectionShort
operator||
name|DayOfWeekSectionLong
operator|)
operator|||
name|currentSectionIndex
operator|==
operator|-
literal|1
condition|)
block|{
comment|// dayofweek should be preferred
name|day
operator|+=
name|diff
expr_stmt|;
if|if
condition|(
name|day
operator|<=
literal|0
condition|)
block|{
name|day
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|day
operator|>
name|date
operator|.
name|daysInMonth
argument_list|()
condition|)
block|{
name|day
operator|-=
literal|7
expr_stmt|;
block|}
name|QDTPDEBUG
operator|<<
name|year
operator|<<
name|month
operator|<<
name|day
operator|<<
name|dayofweek
operator|<<
name|diff
operator|<<
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
operator|.
name|dayOfWeek
argument_list|()
expr_stmt|;
block|}
block|}
name|bool
name|needfixday
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|sectionType
argument_list|(
name|currentSectionIndex
argument_list|)
operator|&
operator|(
name|DaySection
operator||
name|DayOfWeekSectionShort
operator||
name|DayOfWeekSectionLong
operator|)
condition|)
block|{
name|cachedDay
operator|=
name|day
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cachedDay
operator|>
name|day
condition|)
block|{
name|day
operator|=
name|cachedDay
expr_stmt|;
name|needfixday
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|QDate
operator|::
name|isValid
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
condition|)
block|{
if|if
condition|(
name|day
operator|<
literal|32
condition|)
block|{
name|cachedDay
operator|=
name|day
expr_stmt|;
block|}
if|if
condition|(
name|day
operator|>
literal|28
operator|&&
name|QDate
operator|::
name|isValid
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|needfixday
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needfixday
condition|)
block|{
if|if
condition|(
name|context
operator|==
name|FromString
condition|)
block|{
name|state
operator|=
name|Invalid
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|state
operator|==
name|Acceptable
operator|&&
name|fixday
condition|)
block|{
name|day
operator|=
name|qMin
argument_list|<
name|int
argument_list|>
argument_list|(
name|day
argument_list|,
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
literal|1
argument_list|)
operator|.
name|daysInMonth
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|QLocale
name|loc
init|=
name|locale
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sectionNodesCount
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|Section
name|thisSectionType
init|=
name|sectionType
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|thisSectionType
operator|&
operator|(
name|DaySection
operator|)
condition|)
block|{
name|input
operator|.
name|replace
argument_list|(
name|sectionPos
argument_list|(
name|i
argument_list|)
argument_list|,
name|sectionSize
argument_list|(
name|i
argument_list|)
argument_list|,
name|loc
operator|.
name|toString
argument_list|(
name|day
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|thisSectionType
operator|&
operator|(
name|DayOfWeekSectionShort
operator||
name|DayOfWeekSectionLong
operator|)
condition|)
block|{
specifier|const
name|int
name|dayOfWeek
init|=
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
operator|.
name|dayOfWeek
argument_list|()
decl_stmt|;
specifier|const
name|QLocale
operator|::
name|FormatType
name|dayFormat
init|=
operator|(
name|thisSectionType
operator|==
name|DayOfWeekSectionShort
condition|?
name|QLocale
operator|::
name|ShortFormat
else|:
name|QLocale
operator|::
name|LongFormat
operator|)
decl_stmt|;
specifier|const
name|QString
name|dayName
argument_list|(
name|loc
operator|.
name|dayName
argument_list|(
name|dayOfWeek
argument_list|,
name|dayFormat
argument_list|)
argument_list|)
decl_stmt|;
name|input
operator|.
name|replace
argument_list|(
name|sectionPos
argument_list|(
name|i
argument_list|)
argument_list|,
name|sectionSize
argument_list|(
name|i
argument_list|)
argument_list|,
name|dayName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|state
operator|=
name|qMin
argument_list|(
name|Intermediate
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|parserType
operator|!=
name|QVariant
operator|::
name|Date
condition|)
block|{
if|if
condition|(
name|isSet
operator|&
name|Hour12Section
condition|)
block|{
specifier|const
name|bool
name|hasHour
init|=
name|isSet
operator|&
name|Hour24Section
decl_stmt|;
if|if
condition|(
name|ampm
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|hasHour
condition|)
block|{
name|ampm
operator|=
operator|(
name|hour
operator|<
literal|12
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ampm
operator|=
literal|0
expr_stmt|;
comment|// no way to tell if this is am or pm so I assume am
block|}
block|}
name|hour12
operator|=
operator|(
name|ampm
operator|==
literal|0
condition|?
name|hour12
operator|%
literal|12
else|:
operator|(
name|hour12
operator|%
literal|12
operator|)
operator|+
literal|12
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasHour
condition|)
block|{
name|hour
operator|=
name|hour12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hour
operator|!=
name|hour12
condition|)
block|{
name|conflicts
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ampm
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isSet
operator|&
operator|(
name|Hour24Section
operator|)
operator|)
condition|)
block|{
name|hour
operator|=
operator|(
literal|12
operator|*
name|ampm
operator|)
expr_stmt|;
comment|// special case. Only ap section
block|}
elseif|else
if|if
condition|(
operator|(
name|ampm
operator|==
literal|0
operator|)
operator|!=
operator|(
name|hour
operator|<
literal|12
operator|)
condition|)
block|{
name|conflicts
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|newCurrentValue
operator|=
name|QDateTime
argument_list|(
name|QDate
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
argument_list|,
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
name|msec
argument_list|)
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
name|year
operator|<<
name|month
operator|<<
name|day
operator|<<
name|hour
operator|<<
name|minute
operator|<<
name|second
operator|<<
name|msec
expr_stmt|;
block|}
name|QDTPDEBUGN
argument_list|(
literal|"'%s' => '%s'(%s)"
argument_list|,
name|input
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|newCurrentValue
operator|.
name|toString
argument_list|(
name|QLatin1String
argument_list|(
literal|"yyyy/MM/dd hh:mm:ss.zzz"
argument_list|)
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|stateName
argument_list|(
name|state
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|newCurrentValue
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|context
operator|!=
name|FromString
operator|&&
name|state
operator|!=
name|Invalid
operator|&&
name|newCurrentValue
operator|<
name|minimum
condition|)
block|{
specifier|const
name|QLatin1Char
name|space
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|newCurrentValue
operator|>=
name|minimum
condition|)
name|qWarning
argument_list|(
literal|"QDateTimeParser::parse Internal error 3 (%s %s)"
argument_list|,
name|qPrintable
argument_list|(
name|newCurrentValue
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|minimum
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|done
init|=
literal|false
decl_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sectionNodesCount
operator|&&
operator|!
name|done
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNodes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QString
name|t
init|=
name|sectionText
argument_list|(
name|input
argument_list|,
name|i
argument_list|,
name|sn
operator|.
name|pos
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|.
name|size
argument_list|()
operator|<
name|sectionMaxSize
argument_list|(
name|i
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|int
operator|)
name|fieldInfo
argument_list|(
name|i
argument_list|)
operator|&
operator|(
name|FixedWidth
operator||
name|Numeric
operator|)
operator|)
operator|!=
name|Numeric
operator|)
operator|)
operator|||
name|t
operator|.
name|contains
argument_list|(
name|space
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
case|case
name|AmPmSection
case|:
switch|switch
condition|(
name|findAmPm
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
block|{
case|case
name|AM
case|:
case|case
name|PM
case|:
name|state
operator|=
name|Acceptable
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|Neither
case|:
name|state
operator|=
name|Invalid
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|PossibleAM
case|:
case|case
name|PossiblePM
case|:
case|case
name|PossibleBoth
case|:
block|{
specifier|const
name|QDateTime
name|copy
argument_list|(
name|newCurrentValue
operator|.
name|addSecs
argument_list|(
literal|12
operator|*
literal|60
operator|*
literal|60
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy
operator|>=
name|minimum
operator|&&
name|copy
operator|<=
name|maximum
condition|)
block|{
name|state
operator|=
name|Intermediate
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
block|}
case|case
name|MonthSection
case|:
if|if
condition|(
name|sn
operator|.
name|count
operator|>=
literal|3
condition|)
block|{
name|int
name|tmp
init|=
name|newCurrentValue
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
decl_stmt|;
comment|// I know the first possible month makes the date too early
while|while
condition|(
operator|(
name|tmp
operator|=
name|findMonth
argument_list|(
name|t
argument_list|,
name|tmp
operator|+
literal|1
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
specifier|const
name|QDateTime
name|copy
argument_list|(
name|newCurrentValue
operator|.
name|addMonths
argument_list|(
name|tmp
operator|-
name|newCurrentValue
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy
operator|>=
name|minimum
operator|&&
name|copy
operator|<=
name|maximum
condition|)
break|break;
comment|// break out of while
block|}
if|if
condition|(
name|tmp
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|state
operator|=
name|Intermediate
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
comment|// fallthrough
default|default:
block|{
name|int
name|toMin
decl_stmt|;
name|int
name|toMax
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|&
name|TimeSectionMask
condition|)
block|{
if|if
condition|(
name|newCurrentValue
operator|.
name|daysTo
argument_list|(
name|minimum
argument_list|)
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|toMin
operator|=
name|newCurrentValue
operator|.
name|time
argument_list|()
operator|.
name|msecsTo
argument_list|(
name|minimum
operator|.
name|time
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newCurrentValue
operator|.
name|daysTo
argument_list|(
name|maximum
argument_list|)
operator|>
literal|0
condition|)
block|{
name|toMax
operator|=
operator|-
literal|1
expr_stmt|;
comment|// can't get to max
block|}
else|else
block|{
name|toMax
operator|=
name|newCurrentValue
operator|.
name|time
argument_list|()
operator|.
name|msecsTo
argument_list|(
name|maximum
operator|.
name|time
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|toMin
operator|=
name|newCurrentValue
operator|.
name|daysTo
argument_list|(
name|minimum
argument_list|)
expr_stmt|;
name|toMax
operator|=
name|newCurrentValue
operator|.
name|daysTo
argument_list|(
name|maximum
argument_list|)
expr_stmt|;
block|}
specifier|const
name|int
name|maxChange
init|=
name|QDateTimeParser
operator|::
name|maxChange
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|toMin
operator|>
name|maxChange
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"invalid because toMin> maxChange"
operator|<<
name|toMin
operator|<<
name|maxChange
operator|<<
name|t
operator|<<
name|newCurrentValue
operator|<<
name|minimum
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|toMax
operator|>
name|maxChange
condition|)
block|{
name|toMax
operator|=
operator|-
literal|1
expr_stmt|;
comment|// can't get to max
block|}
specifier|const
name|int
name|min
init|=
name|getDigit
argument_list|(
name|minimum
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|min
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::parse Internal error 4 (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|int
name|max
init|=
name|toMax
operator|!=
operator|-
literal|1
condition|?
name|getDigit
argument_list|(
name|maximum
argument_list|,
name|i
argument_list|)
else|:
name|absoluteMax
argument_list|(
name|i
argument_list|,
name|newCurrentValue
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|cursorPosition
operator|-
name|sn
operator|.
name|pos
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>=
name|t
operator|.
name|size
argument_list|()
condition|)
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|potentialValue
argument_list|(
name|t
operator|.
name|simplified
argument_list|()
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|i
argument_list|,
name|newCurrentValue
argument_list|,
name|pos
argument_list|)
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"invalid because potentialValue("
operator|<<
name|t
operator|.
name|simplified
argument_list|()
operator|<<
name|min
operator|<<
name|max
operator|<<
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
operator|<<
literal|"returned"
operator|<<
name|toMax
operator|<<
name|toMin
operator|<<
name|pos
expr_stmt|;
name|state
operator|=
name|Invalid
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|state
operator|=
name|Intermediate
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|context
operator|==
name|FromString
condition|)
block|{
comment|// optimization
name|Q_ASSERT
argument_list|(
name|getMaximum
argument_list|()
operator|.
name|date
argument_list|()
operator|.
name|toJulianDay
argument_list|()
operator|==
literal|4642999
argument_list|)
expr_stmt|;
if|if
condition|(
name|newCurrentValue
operator|.
name|date
argument_list|()
operator|.
name|toJulianDay
argument_list|()
operator|>
literal|4642999
condition|)
name|state
operator|=
name|Invalid
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|newCurrentValue
operator|>
name|getMaximum
argument_list|()
condition|)
name|state
operator|=
name|Invalid
expr_stmt|;
block|}
name|QDTPDEBUG
operator|<<
literal|"not checking intermediate because newCurrentValue is"
operator|<<
name|newCurrentValue
operator|<<
name|getMinimum
argument_list|()
operator|<<
name|getMaximum
argument_list|()
expr_stmt|;
block|}
block|}
name|StateNode
name|node
decl_stmt|;
name|node
operator|.
name|input
operator|=
name|input
expr_stmt|;
name|node
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|node
operator|.
name|conflicts
operator|=
name|conflicts
expr_stmt|;
name|node
operator|.
name|value
operator|=
name|newCurrentValue
operator|.
name|toTimeSpec
argument_list|(
name|spec
argument_list|)
expr_stmt|;
name|text
operator|=
name|input
expr_stmt|;
return|return
name|node
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTDATE
end_ifndef
begin_comment
comment|/*!   \internal   finds the first possible monthname that \a str1 can   match. Starting from \a index; str should already by lowered */
end_comment
begin_function
DECL|function|findMonth
name|int
name|QDateTimeParser
operator|::
name|findMonth
parameter_list|(
specifier|const
name|QString
modifier|&
name|str1
parameter_list|,
name|int
name|startMonth
parameter_list|,
name|int
name|sectionIndex
parameter_list|,
name|QString
modifier|*
name|usedMonth
parameter_list|,
name|int
modifier|*
name|used
parameter_list|)
specifier|const
block|{
name|int
name|bestMatch
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bestCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|str1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|!=
name|MonthSection
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::findMonth Internal error"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|QLocale
operator|::
name|FormatType
name|type
init|=
name|sn
operator|.
name|count
operator|==
literal|3
condition|?
name|QLocale
operator|::
name|ShortFormat
else|:
name|QLocale
operator|::
name|LongFormat
decl_stmt|;
name|QLocale
name|l
init|=
name|locale
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|month
init|=
name|startMonth
init|;
name|month
operator|<=
literal|12
condition|;
operator|++
name|month
control|)
block|{
name|QString
name|str2
init|=
name|l
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|type
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|str1
operator|.
name|startsWith
argument_list|(
name|str2
argument_list|)
condition|)
block|{
if|if
condition|(
name|used
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"used is set to"
operator|<<
name|str2
operator|.
name|size
argument_list|()
expr_stmt|;
operator|*
name|used
operator|=
name|str2
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|usedMonth
condition|)
operator|*
name|usedMonth
operator|=
name|l
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|month
return|;
block|}
if|if
condition|(
name|context
operator|==
name|FromString
condition|)
continue|continue;
specifier|const
name|int
name|limit
init|=
name|qMin
argument_list|(
name|str1
operator|.
name|size
argument_list|()
argument_list|,
name|str2
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|QDTPDEBUG
operator|<<
literal|"limit is"
operator|<<
name|limit
operator|<<
name|str1
operator|<<
name|str2
expr_stmt|;
name|bool
name|equal
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|str1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|str2
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|equal
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|bestCount
condition|)
block|{
name|bestCount
operator|=
name|i
expr_stmt|;
name|bestMatch
operator|=
name|month
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|equal
condition|)
block|{
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|usedMonth
condition|)
operator|*
name|usedMonth
operator|=
name|l
operator|.
name|monthName
argument_list|(
name|month
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|month
return|;
block|}
block|}
if|if
condition|(
name|usedMonth
operator|&&
name|bestMatch
operator|!=
operator|-
literal|1
condition|)
operator|*
name|usedMonth
operator|=
name|l
operator|.
name|monthName
argument_list|(
name|bestMatch
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|used
condition|)
block|{
name|QDTPDEBUG
operator|<<
literal|"used is set to"
operator|<<
name|bestCount
expr_stmt|;
operator|*
name|used
operator|=
name|bestCount
expr_stmt|;
block|}
return|return
name|bestMatch
return|;
block|}
end_function
begin_function
DECL|function|findDay
name|int
name|QDateTimeParser
operator|::
name|findDay
parameter_list|(
specifier|const
name|QString
modifier|&
name|str1
parameter_list|,
name|int
name|startDay
parameter_list|,
name|int
name|sectionIndex
parameter_list|,
name|QString
modifier|*
name|usedDay
parameter_list|,
name|int
modifier|*
name|used
parameter_list|)
specifier|const
block|{
name|int
name|bestMatch
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bestCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|str1
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|sectionIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sn
operator|.
name|type
operator|&
operator|(
name|DaySection
operator||
name|DayOfWeekSectionShort
operator||
name|DayOfWeekSectionLong
operator|)
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::findDay Internal error"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
specifier|const
name|QLocale
name|l
init|=
name|locale
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|day
init|=
name|startDay
init|;
name|day
operator|<=
literal|7
condition|;
operator|++
name|day
control|)
block|{
specifier|const
name|QString
name|str2
init|=
name|l
operator|.
name|dayName
argument_list|(
name|day
argument_list|,
name|sn
operator|.
name|count
operator|==
literal|4
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
decl_stmt|;
if|if
condition|(
name|str1
operator|.
name|startsWith
argument_list|(
name|str2
operator|.
name|toLower
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|str2
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|usedDay
condition|)
block|{
operator|*
name|usedDay
operator|=
name|str2
expr_stmt|;
block|}
return|return
name|day
return|;
block|}
if|if
condition|(
name|context
operator|==
name|FromString
condition|)
continue|continue;
specifier|const
name|int
name|limit
init|=
name|qMin
argument_list|(
name|str1
operator|.
name|size
argument_list|()
argument_list|,
name|str2
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|found
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|str1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|str2
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|str1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|isSpace
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|bestCount
condition|)
block|{
name|bestCount
operator|=
name|i
expr_stmt|;
name|bestMatch
operator|=
name|day
expr_stmt|;
block|}
name|found
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|usedDay
condition|)
operator|*
name|usedDay
operator|=
name|str2
expr_stmt|;
return|return
name|day
return|;
block|}
block|}
if|if
condition|(
name|usedDay
operator|&&
name|bestMatch
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|usedDay
operator|=
name|l
operator|.
name|dayName
argument_list|(
name|bestMatch
argument_list|,
name|sn
operator|.
name|count
operator|==
literal|4
condition|?
name|QLocale
operator|::
name|LongFormat
else|:
name|QLocale
operator|::
name|ShortFormat
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|bestCount
expr_stmt|;
return|return
name|bestMatch
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTDATE
end_comment
begin_comment
comment|/*!   \internal    returns   0 if str == QDateTimeEdit::tr("AM")   1 if str == QDateTimeEdit::tr("PM")   2 if str can become QDateTimeEdit::tr("AM")   3 if str can become QDateTimeEdit::tr("PM")   4 if str can become QDateTimeEdit::tr("PM") and can become QDateTimeEdit::tr("AM")   -1 can't become anything sensible  */
end_comment
begin_function
DECL|function|findAmPm
name|int
name|QDateTimeParser
operator|::
name|findAmPm
parameter_list|(
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|index
parameter_list|,
name|int
modifier|*
name|used
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|s
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|type
operator|!=
name|AmPmSection
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::findAmPm Internal error"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|str
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|trimmed
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|PossibleBoth
return|;
block|}
specifier|const
name|QLatin1Char
name|space
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|sectionMaxSize
argument_list|(
name|index
argument_list|)
decl_stmt|;
enum|enum
block|{
name|amindex
init|=
literal|0
block|,
name|pmindex
init|=
literal|1
block|}
enum|;
name|QString
name|ampm
index|[
literal|2
index|]
decl_stmt|;
name|ampm
index|[
name|amindex
index|]
operator|=
name|getAmPmText
argument_list|(
name|AmText
argument_list|,
name|s
operator|.
name|count
operator|==
literal|1
condition|?
name|UpperCase
else|:
name|LowerCase
argument_list|)
expr_stmt|;
name|ampm
index|[
name|pmindex
index|]
operator|=
name|getAmPmText
argument_list|(
name|PmText
argument_list|,
name|s
operator|.
name|count
operator|==
literal|1
condition|?
name|UpperCase
else|:
name|LowerCase
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
name|ampm
index|[
name|i
index|]
operator|.
name|truncate
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"findAmPm"
operator|<<
name|str
operator|<<
name|ampm
index|[
literal|0
index|]
operator|<<
name|ampm
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|indexOf
argument_list|(
name|ampm
index|[
name|amindex
index|]
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
condition|)
block|{
name|str
operator|=
name|ampm
index|[
name|amindex
index|]
expr_stmt|;
return|return
name|AM
return|;
block|}
elseif|else
if|if
condition|(
name|str
operator|.
name|indexOf
argument_list|(
name|ampm
index|[
name|pmindex
index|]
argument_list|,
literal|0
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
condition|)
block|{
name|str
operator|=
name|ampm
index|[
name|pmindex
index|]
expr_stmt|;
return|return
name|PM
return|;
block|}
elseif|else
if|if
condition|(
name|context
operator|==
name|FromString
operator|||
operator|(
name|str
operator|.
name|count
argument_list|(
name|space
argument_list|)
operator|==
literal|0
operator|&&
name|str
operator|.
name|size
argument_list|()
operator|>=
name|size
operator|)
condition|)
block|{
return|return
name|Neither
return|;
block|}
name|size
operator|=
name|qMin
argument_list|(
name|size
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|bool
name|broken
index|[
literal|2
index|]
init|=
block|{
literal|false
block|,
literal|false
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|space
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
name|broken
index|[
name|j
index|]
condition|)
block|{
name|int
name|index
init|=
name|ampm
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|QDTPDEBUG
operator|<<
literal|"looking for"
operator|<<
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|<<
literal|"in"
operator|<<
name|ampm
index|[
name|j
index|]
operator|<<
literal|"and got"
operator|<<
name|index
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|category
argument_list|()
operator|==
name|QChar
operator|::
name|Letter_Uppercase
condition|)
block|{
name|index
operator|=
name|ampm
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLower
argument_list|()
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"trying with"
operator|<<
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLower
argument_list|()
operator|<<
literal|"in"
operator|<<
name|ampm
index|[
name|j
index|]
operator|<<
literal|"and got"
operator|<<
name|index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|category
argument_list|()
operator|==
name|QChar
operator|::
name|Letter_Lowercase
condition|)
block|{
name|index
operator|=
name|ampm
index|[
name|j
index|]
operator|.
name|indexOf
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toUpper
argument_list|()
argument_list|)
expr_stmt|;
name|QDTPDEBUG
operator|<<
literal|"trying with"
operator|<<
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toUpper
argument_list|()
operator|<<
literal|"in"
operator|<<
name|ampm
index|[
name|j
index|]
operator|<<
literal|"and got"
operator|<<
name|index
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|broken
index|[
name|j
index|]
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|broken
index|[
name|amindex
index|]
operator|&&
name|broken
index|[
name|pmindex
index|]
condition|)
block|{
name|QDTPDEBUG
operator|<<
name|str
operator|<<
literal|"didn't make it"
expr_stmt|;
return|return
name|Neither
return|;
block|}
continue|continue;
block|}
else|else
block|{
name|str
index|[
name|i
index|]
operator|=
name|ampm
index|[
name|j
index|]
operator|.
name|at
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|// fix case
block|}
block|}
name|ampm
index|[
name|j
index|]
operator|.
name|remove
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|broken
index|[
name|pmindex
index|]
operator|&&
operator|!
name|broken
index|[
name|amindex
index|]
condition|)
return|return
name|PossibleBoth
return|;
return|return
operator|(
operator|!
name|broken
index|[
name|amindex
index|]
condition|?
name|PossibleAM
else|:
name|PossiblePM
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   Max number of units that can be changed by this section. */
end_comment
begin_function
DECL|function|maxChange
name|int
name|QDateTimeParser
operator|::
name|maxChange
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sn
operator|.
name|type
condition|)
block|{
comment|// Time. unit is msec
case|case
name|MSecSection
case|:
return|return
literal|999
return|;
case|case
name|SecondSection
case|:
return|return
literal|59
operator|*
literal|1000
return|;
case|case
name|MinuteSection
case|:
return|return
literal|59
operator|*
literal|60
operator|*
literal|1000
return|;
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
return|return
literal|59
operator|*
literal|60
operator|*
literal|60
operator|*
literal|1000
return|;
comment|// Date. unit is day
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
return|return
literal|7
return|;
case|case
name|DaySection
case|:
return|return
literal|30
return|;
case|case
name|MonthSection
case|:
return|return
literal|365
operator|-
literal|31
return|;
case|case
name|YearSection
case|:
return|return
literal|9999
operator|*
literal|365
return|;
case|case
name|YearSection2Digits
case|:
return|return
literal|100
operator|*
literal|365
return|;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::maxChange() Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sectionType
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|fieldInfo
name|QDateTimeParser
operator|::
name|FieldInfo
name|QDateTimeParser
operator|::
name|fieldInfo
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|FieldInfo
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|const
name|Section
name|s
init|=
name|sn
operator|.
name|type
decl_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|MSecSection
case|:
name|ret
operator||=
name|Fraction
expr_stmt|;
comment|// fallthrough
case|case
name|SecondSection
case|:
case|case
name|MinuteSection
case|:
case|case
name|Hour24Section
case|:
case|case
name|Hour12Section
case|:
case|case
name|YearSection
case|:
case|case
name|YearSection2Digits
case|:
name|ret
operator||=
name|Numeric
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|YearSection
condition|)
block|{
name|ret
operator||=
name|AllowPartial
expr_stmt|;
block|}
if|if
condition|(
name|sn
operator|.
name|count
operator|!=
literal|1
condition|)
block|{
name|ret
operator||=
name|FixedWidth
expr_stmt|;
block|}
break|break;
case|case
name|MonthSection
case|:
case|case
name|DaySection
case|:
switch|switch
condition|(
name|sn
operator|.
name|count
condition|)
block|{
case|case
literal|2
case|:
name|ret
operator||=
name|FixedWidth
expr_stmt|;
comment|// fallthrough
case|case
literal|1
case|:
name|ret
operator||=
operator|(
name|Numeric
operator||
name|AllowPartial
operator|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
if|if
condition|(
name|sn
operator|.
name|count
operator|==
literal|3
condition|)
name|ret
operator||=
name|FixedWidth
expr_stmt|;
break|break;
case|case
name|AmPmSection
case|:
name|ret
operator||=
name|FixedWidth
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::fieldInfo Internal error 2 (%d %s %d)"
argument_list|,
name|index
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|sn
operator|.
name|type
argument_list|)
argument_list|)
argument_list|,
name|sn
operator|.
name|count
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Get a number that str can become which is between min   and max or -1 if this is not possible. */
end_comment
begin_function
DECL|function|sectionFormat
name|QString
name|QDateTimeParser
operator|::
name|sectionFormat
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|sectionFormat
argument_list|(
name|sn
operator|.
name|type
argument_list|,
name|sn
operator|.
name|count
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sectionFormat
name|QString
name|QDateTimeParser
operator|::
name|sectionFormat
parameter_list|(
name|Section
name|s
parameter_list|,
name|int
name|count
parameter_list|)
specifier|const
block|{
name|QChar
name|fillChar
decl_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|AmPmSection
case|:
return|return
name|count
operator|==
literal|1
condition|?
name|QLatin1String
argument_list|(
literal|"AP"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"ap"
argument_list|)
return|;
case|case
name|MSecSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'z'
argument_list|)
expr_stmt|;
break|break;
case|case
name|SecondSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
break|break;
case|case
name|MinuteSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'m'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Hour24Section
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'H'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Hour12Section
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'h'
argument_list|)
expr_stmt|;
break|break;
case|case
name|DayOfWeekSectionShort
case|:
case|case
name|DayOfWeekSectionLong
case|:
case|case
name|DaySection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
break|break;
case|case
name|MonthSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
break|break;
case|case
name|YearSection2Digits
case|:
case|case
name|YearSection
case|:
name|fillChar
operator|=
name|QLatin1Char
argument_list|(
literal|'y'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionFormat Internal error (%s)"
argument_list|,
name|qPrintable
argument_list|(
name|sectionName
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
if|if
condition|(
name|fillChar
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QDateTimeParser::sectionFormat Internal error 2"
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QString
name|str
decl_stmt|;
name|str
operator|.
name|fill
argument_list|(
name|fillChar
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Returns true if str can be modified to represent a   number that is within min and max. */
end_comment
begin_function
DECL|function|potentialValue
name|bool
name|QDateTimeParser
operator|::
name|potentialValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|currentValue
parameter_list|,
name|int
name|insert
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|const
name|int
name|size
init|=
name|sectionMaxSize
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|val
init|=
operator|(
name|int
operator|)
name|locale
argument_list|()
operator|.
name|toUInt
argument_list|(
name|str
argument_list|)
decl_stmt|;
specifier|const
name|SectionNode
modifier|&
name|sn
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|.
name|type
operator|==
name|YearSection2Digits
condition|)
block|{
name|val
operator|+=
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
operator|-
operator|(
name|currentValue
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
operator|%
literal|100
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|>=
name|min
operator|&&
name|val
operator|<=
name|max
operator|&&
name|str
operator|.
name|size
argument_list|()
operator|==
name|size
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|val
operator|>
name|max
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|str
operator|.
name|size
argument_list|()
operator|==
name|size
operator|&&
name|val
operator|<
name|min
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|const
name|int
name|len
init|=
name|size
operator|-
name|str
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|potentialValue
argument_list|(
name|str
operator|+
name|QLatin1Char
argument_list|(
literal|'0'
operator|+
name|j
argument_list|)
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|index
argument_list|,
name|currentValue
argument_list|,
name|insert
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|insert
operator|>=
literal|0
condition|)
block|{
name|QString
name|tmp
init|=
name|str
decl_stmt|;
name|tmp
operator|.
name|insert
argument_list|(
name|insert
argument_list|,
name|QLatin1Char
argument_list|(
literal|'0'
operator|+
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|potentialValue
argument_list|(
name|tmp
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|index
argument_list|,
name|currentValue
argument_list|,
name|insert
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|skipToNextSection
name|bool
name|QDateTimeParser
operator|::
name|skipToNextSection
parameter_list|(
name|int
name|index
parameter_list|,
specifier|const
name|QDateTime
modifier|&
name|current
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|current
operator|>=
name|getMinimum
argument_list|()
operator|&&
name|current
operator|<=
name|getMaximum
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|SectionNode
modifier|&
name|node
init|=
name|sectionNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|text
operator|.
name|size
argument_list|()
operator|<
name|sectionMaxSize
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|QDateTime
name|maximum
init|=
name|getMaximum
argument_list|()
decl_stmt|;
specifier|const
name|QDateTime
name|minimum
init|=
name|getMinimum
argument_list|()
decl_stmt|;
name|QDateTime
name|tmp
init|=
name|current
decl_stmt|;
name|int
name|min
init|=
name|absoluteMin
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|setDigit
argument_list|(
name|tmp
argument_list|,
name|index
argument_list|,
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|minimum
condition|)
block|{
name|min
operator|=
name|getDigit
argument_list|(
name|minimum
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|max
init|=
name|absoluteMax
argument_list|(
name|index
argument_list|,
name|current
argument_list|)
decl_stmt|;
name|setDigit
argument_list|(
name|tmp
argument_list|,
name|index
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|maximum
condition|)
block|{
name|max
operator|=
name|getDigit
argument_list|(
name|maximum
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|int
name|pos
init|=
name|cursorPosition
argument_list|()
operator|-
name|node
operator|.
name|pos
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>=
name|text
operator|.
name|size
argument_list|()
condition|)
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
specifier|const
name|bool
name|potential
init|=
name|potentialValue
argument_list|(
name|text
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|index
argument_list|,
name|current
argument_list|,
name|pos
argument_list|)
decl_stmt|;
return|return
operator|!
name|potential
return|;
comment|/* If the value potentially can become another valid entry we      * don't want to skip to the next. E.g. In a M field (month      * without leading 0 if you type 1 we don't want to autoskip but      * if you type 3 we do     */
block|}
end_function
begin_comment
comment|/*!   \internal   For debugging. Returns the name of the section \a s. */
end_comment
begin_function
DECL|function|sectionName
name|QString
name|QDateTimeParser
operator|::
name|sectionName
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|QDateTimeParser
operator|::
name|AmPmSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"AmPmSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|DaySection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"DaySection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|DayOfWeekSectionShort
case|:
return|return
name|QLatin1String
argument_list|(
literal|"DayOfWeekSectionShort"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|DayOfWeekSectionLong
case|:
return|return
name|QLatin1String
argument_list|(
literal|"DayOfWeekSectionLong"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|Hour24Section
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Hour24Section"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|Hour12Section
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Hour12Section"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|MSecSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"MSecSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|MinuteSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"MinuteSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|MonthSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"MonthSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|SecondSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"SecondSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|YearSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"YearSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|YearSection2Digits
case|:
return|return
name|QLatin1String
argument_list|(
literal|"YearSection2Digits"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|NoSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"NoSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|FirstSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"FirstSection"
argument_list|)
return|;
case|case
name|QDateTimeParser
operator|::
name|LastSection
case|:
return|return
name|QLatin1String
argument_list|(
literal|"LastSection"
argument_list|)
return|;
default|default:
return|return
name|QLatin1String
argument_list|(
literal|"Unknown section "
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!   \internal   For debugging. Returns the name of the state \a s. */
end_comment
begin_function
DECL|function|stateName
name|QString
name|QDateTimeParser
operator|::
name|stateName
parameter_list|(
name|int
name|s
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|Invalid
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Invalid"
argument_list|)
return|;
case|case
name|Intermediate
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Intermediate"
argument_list|)
return|;
case|case
name|Acceptable
case|:
return|return
name|QLatin1String
argument_list|(
literal|"Acceptable"
argument_list|)
return|;
default|default:
return|return
name|QLatin1String
argument_list|(
literal|"Unknown state "
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_function
DECL|function|fromString
name|bool
name|QDateTimeParser
operator|::
name|fromString
parameter_list|(
specifier|const
name|QString
modifier|&
name|t
parameter_list|,
name|QDate
modifier|*
name|date
parameter_list|,
name|QTime
modifier|*
name|time
parameter_list|)
specifier|const
block|{
name|QDateTime
name|val
argument_list|(
name|QDate
argument_list|(
literal|1900
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|QDATETIMEEDIT_TIME_MIN
argument_list|)
decl_stmt|;
name|QString
name|text
init|=
name|t
decl_stmt|;
name|int
name|copy
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|StateNode
name|tmp
init|=
name|parse
argument_list|(
name|text
argument_list|,
name|copy
argument_list|,
name|val
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|state
operator|!=
name|Acceptable
operator|||
name|tmp
operator|.
name|conflicts
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|time
condition|)
block|{
specifier|const
name|QTime
name|t
init|=
name|tmp
operator|.
name|value
operator|.
name|time
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|time
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|date
condition|)
block|{
specifier|const
name|QDate
name|d
init|=
name|tmp
operator|.
name|value
operator|.
name|date
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|isValid
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
operator|*
name|date
operator|=
name|d
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATESTRING
end_comment
begin_function
DECL|function|getMinimum
name|QDateTime
name|QDateTimeParser
operator|::
name|getMinimum
parameter_list|()
specifier|const
block|{
return|return
name|QDateTime
argument_list|(
name|QDATETIMEEDIT_DATE_MIN
argument_list|,
name|QDATETIMEEDIT_TIME_MIN
argument_list|,
name|spec
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getMaximum
name|QDateTime
name|QDateTimeParser
operator|::
name|getMaximum
parameter_list|()
specifier|const
block|{
return|return
name|QDateTime
argument_list|(
name|QDATETIMEEDIT_DATE_MAX
argument_list|,
name|QDATETIMEEDIT_TIME_MAX
argument_list|,
name|spec
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getAmPmText
name|QString
name|QDateTimeParser
operator|::
name|getAmPmText
parameter_list|(
name|AmPm
name|ap
parameter_list|,
name|Case
name|cs
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|ap
operator|==
name|AmText
condition|)
block|{
return|return
operator|(
name|cs
operator|==
name|UpperCase
condition|?
name|QLatin1String
argument_list|(
literal|"AM"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"am"
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|cs
operator|==
name|UpperCase
condition|?
name|QLatin1String
argument_list|(
literal|"PM"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"pm"
argument_list|)
operator|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*   \internal    I give arg2 preference because arg1 is always a QDateTime. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QDateTimeParser
operator|::
name|SectionNode
modifier|&
name|s1
parameter_list|,
specifier|const
name|QDateTimeParser
operator|::
name|SectionNode
modifier|&
name|s2
parameter_list|)
block|{
return|return
operator|(
name|s1
operator|.
name|type
operator|==
name|s2
operator|.
name|type
operator|)
operator|&&
operator|(
name|s1
operator|.
name|pos
operator|==
name|s2
operator|.
name|pos
operator|)
operator|&&
operator|(
name|s1
operator|.
name|count
operator|==
name|s2
operator|.
name|count
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BOOTSTRAPPED
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
