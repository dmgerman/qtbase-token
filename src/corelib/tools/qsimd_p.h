begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QSIMD_P_H
end_ifndef
begin_define
DECL|macro|QSIMD_P_H
define|#
directive|define
name|QSIMD_P_H
end_define
begin_include
include|#
directive|include
file|<qglobal.h>
end_include
begin_include
include|#
directive|include
file|<qatomic.h>
end_include
begin_comment
comment|/*  * qt_module_config.prf defines the QT_COMPILER_SUPPORTS_XXX macros.  * They mean the compiler supports the necessary flags and the headers  * for the x86 and ARM intrinsics:  *  - GCC: the -mXXX or march=YYY flag is necessary before #include  *    up to 4.8; GCC>= 4.9 can include unconditionally  *  - Intel CC: #include can happen unconditionally  *  - MSVC: #include can happen unconditionally  *  - RVCT: ???  *  * We will try to include all headers possible under this configuration.  *  * MSVC does not define __SSE2__& family, so we will define them. MSVC 2013&  * up do define __AVX__ if the -arch:AVX option is passed on the command-line.  *  * Supported XXX are:  *   Flag    | Arch |  GCC  | Intel CC |  MSVC  |  *  ARM_NEON | ARM  | I& C | None     |   ?    |  *  IWMMXT   | ARM  | I& C | None     | I& C  |  *  SSE2     | x86  | I& C | I& C    | I& C  |  *  SSE3     | x86  | I& C | I& C    | I only |  *  SSSE3    | x86  | I& C | I& C    | I only |  *  SSE4_1   | x86  | I& C | I& C    | I only |  *  SSE4_2   | x86  | I& C | I& C    | I only |  *  AVX      | x86  | I& C | I& C    | I& C  |  *  AVX2     | x86  | I& C | I& C    | I only |  * I = intrinsics; C = code generation  *  * Code can use the following constructs to determine compiler support& status:  * - #ifdef __XXX__      (e.g: #ifdef __AVX__  or #ifdef __ARM_NEON__)  *   If this test passes, then the compiler is already generating code for that  *   given sub-architecture. The intrinsics for that sub-architecture are  *   #included and can be used without restriction or runtime check.  *  * - #if QT_COMPILER_SUPPORTS(XXX)  *   If this test passes, then the compiler is able to generate code for that  *   given sub-architecture in another translation unit, given the right set of  *   flags. Use of the intrinsics is not guaranteed. This is useful with  *   runtime detection (see below).  *  * - #if QT_COMPILER_SUPPORTS_HERE(XXX)  *   If this test passes, then the compiler is able to generate code for that  *   given sub-architecture in this translation unit, even if it is not doing  *   that now (it might be). Individual functions may be tagged with  *   QT_FUNCTION_TARGET(XXX) to cause the compiler to generate code for that  *   sub-arch. Only inside such functions is the use of the intrisics  *   guaranteed to work. This is useful with runtime detection (see below).  *  * Runtime detection of a CPU sub-architecture can be done with the  * qCpuHasFeature(XXX) function. There are two strategies for generating  * optimized code like that:  *  * 1) place the optimized code in a different translation unit (C or assembly  * sources) and pass the correct flags to the compiler to enable support. Those  * sources must not include qglobal.h, which means they cannot include this  * file either. The dispatcher function would look like this:  *  *      void foo()  *      {  *      #if QT_COMPILER_SUPPORTS(XXX)  *          if (qCpuHasFeature(XXX)) {  *              foo_optimized_xxx();  *              return;  *          }  *      #endif  *          foo_plain();  *      }  *  * 2) place the optimized code in a function tagged with QT_FUNCTION_TARGET and  * surrounded by #if QT_COMPILER_SUPPORTS_HERE(XXX). That code can freely use  * other Qt code. The dispatcher function would look like this:  *  *      void foo()  *      {  *      #if QT_COMPILER_SUPPORTS_HERE(XXX)  *          if (qCpuHasFeature(XXX)) {  *              foo_optimized_xxx();  *              return;  *          }  *      #endif  *          foo_plain();  *      }  */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MINGW64_VERSION_MAJOR
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|)
end_if
begin_include
include|#
directive|include
file|<intrin.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QT_COMPILER_SUPPORTS
define|#
directive|define
name|QT_COMPILER_SUPPORTS
parameter_list|(
name|x
parameter_list|)
value|(QT_COMPILER_SUPPORTS_ ## x - 0)
end_define
begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_CLANG
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|-
literal|0
operator|)
operator|*
literal|100
operator|+
operator|(
name|__GNUC_MINOR__
operator|-
literal|0
operator|)
operator|>=
literal|409
operator|)
operator|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
end_if
begin_define
DECL|macro|QT_COMPILER_SUPPORTS_SIMD_ALWAYS
define|#
directive|define
name|QT_COMPILER_SUPPORTS_SIMD_ALWAYS
end_define
begin_define
DECL|macro|QT_COMPILER_SUPPORTS_HERE
define|#
directive|define
name|QT_COMPILER_SUPPORTS_HERE
parameter_list|(
name|x
parameter_list|)
value|QT_COMPILER_SUPPORTS(x)
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
end_if
begin_comment
comment|/* GCC requires attributes for a function */
end_comment
begin_define
DECL|macro|QT_FUNCTION_TARGET
define|#
directive|define
name|QT_FUNCTION_TARGET
parameter_list|(
name|x
parameter_list|)
value|__attribute__((__target__(QT_FUNCTION_TARGET_STRING_ ## x)))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_FUNCTION_TARGET
define|#
directive|define
name|QT_FUNCTION_TARGET
parameter_list|(
name|x
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_COMPILER_SUPPORTS_HERE
define|#
directive|define
name|QT_COMPILER_SUPPORTS_HERE
parameter_list|(
name|x
parameter_list|)
value|defined(__ ## x ## __)
end_define
begin_define
DECL|macro|QT_FUNCTION_TARGET
define|#
directive|define
name|QT_FUNCTION_TARGET
parameter_list|(
name|x
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// SSE intrinsics
end_comment
begin_define
DECL|macro|QT_FUNCTION_TARGET_STRING_SSE2
define|#
directive|define
name|QT_FUNCTION_TARGET_STRING_SSE2
value|"sse2"
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SSE2__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SSE2
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SIMD_ALWAYS
argument_list|)
operator|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_LINUXBASE
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_ANDROID_NO_SDK
argument_list|)
end_if
begin_comment
comment|/// this is an evil hack - the posix_memalign declaration in LSB
end_comment
begin_comment
comment|/// is wrong - see http://bugs.linuxbase.org/show_bug.cgi?id=2431
end_comment
begin_define
DECL|macro|posix_memalign
define|#
directive|define
name|posix_memalign
value|_lsb_hack_posix_memalign
end_define
begin_include
include|#
directive|include
file|<emmintrin.h>
end_include
begin_undef
DECL|macro|posix_memalign
undef|#
directive|undef
name|posix_memalign
end_undef
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|<emmintrin.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|||
name|_M_IX86_FP
operator|>=
literal|2
operator|)
end_if
begin_define
DECL|macro|__SSE__
define|#
directive|define
name|__SSE__
value|1
end_define
begin_define
DECL|macro|__SSE2__
define|#
directive|define
name|__SSE2__
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// SSE3 intrinsics
end_comment
begin_define
DECL|macro|QT_FUNCTION_TARGET_STRING_SSE3
define|#
directive|define
name|QT_FUNCTION_TARGET_STRING_SSE3
value|"sse3"
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SSE3__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SSE3
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SIMD_ALWAYS
argument_list|)
operator|)
end_if
begin_include
include|#
directive|include
file|<pmmintrin.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// SSSE3 intrinsics
end_comment
begin_define
DECL|macro|QT_FUNCTION_TARGET_STRING_SSSE3
define|#
directive|define
name|QT_FUNCTION_TARGET_STRING_SSSE3
value|"ssse3"
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SSSE3__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SSSE3
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SIMD_ALWAYS
argument_list|)
operator|)
end_if
begin_include
include|#
directive|include
file|<tmmintrin.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// SSE4.1 intrinsics
end_comment
begin_define
DECL|macro|QT_FUNCTION_TARGET_STRING_SSE4_1
define|#
directive|define
name|QT_FUNCTION_TARGET_STRING_SSE4_1
value|"sse4.1"
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SSE4_1__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SSE4_1
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SIMD_ALWAYS
argument_list|)
operator|)
end_if
begin_include
include|#
directive|include
file|<smmintrin.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// SSE4.2 intrinsics
end_comment
begin_define
DECL|macro|QT_FUNCTION_TARGET_STRING_SSE4_2
define|#
directive|define
name|QT_FUNCTION_TARGET_STRING_SSE4_2
value|"sse4.2"
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SSE4_2__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SSE4_2
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SIMD_ALWAYS
argument_list|)
operator|)
end_if
begin_include
include|#
directive|include
file|<nmmintrin.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// AVX intrinsics
end_comment
begin_define
DECL|macro|QT_FUNCTION_TARGET_STRING_AVX
define|#
directive|define
name|QT_FUNCTION_TARGET_STRING_AVX
value|"avx"
end_define
begin_define
DECL|macro|QT_FUNCTION_TARGET_STRING_AVX2
define|#
directive|define
name|QT_FUNCTION_TARGET_STRING_AVX2
value|"avx2"
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__AVX__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_AVX
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_SIMD_ALWAYS
argument_list|)
operator|)
end_if
begin_comment
comment|// immintrin.h is the ultimate header, we don't need anything else after this
end_comment
begin_include
include|#
directive|include
file|<immintrin.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|_M_AVX
argument_list|)
operator|||
name|defined
argument_list|(
name|__AVX__
argument_list|)
operator|)
end_if
begin_comment
comment|// MS Visual Studio 2010 has no macro pre-defined to identify the use of /arch:AVX
end_comment
begin_comment
comment|// MS Visual Studio 2013 adds it: __AVX__
end_comment
begin_comment
comment|// See: http://connect.microsoft.com/VisualStudio/feedback/details/605858/arch-avx-should-define-a-predefined-macro-in-x64-and-set-a-unique-value-for-m-ix86-fp-in-win32
end_comment
begin_define
DECL|macro|__SSE3__
define|#
directive|define
name|__SSE3__
value|1
end_define
begin_define
DECL|macro|__SSSE3__
define|#
directive|define
name|__SSSE3__
value|1
end_define
begin_comment
comment|// no Intel CPU supports SSE4a, so don't define it
end_comment
begin_define
DECL|macro|__SSE4_1__
define|#
directive|define
name|__SSE4_1__
value|1
end_define
begin_define
DECL|macro|__SSE4_2__
define|#
directive|define
name|__SSE4_2__
value|1
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|__AVX__
end_ifndef
begin_define
DECL|macro|__AVX__
define|#
directive|define
name|__AVX__
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// other x86 intrinsics
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_PROCESSOR_X86
argument_list|)
operator|&&
operator|(
operator|(
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|*
literal|100
operator|+
name|__GNUC_MINOR__
operator|>=
literal|404
operator|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|Q_CC_CLANG
argument_list|)
operator|&&
operator|(
name|__clang_major__
operator|*
literal|100
operator|+
name|__clang_minor__
operator|>=
literal|208
operator|)
operator|)
expr|\
operator|||
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|)
end_if
begin_define
DECL|macro|QT_COMPILER_SUPPORTS_X86INTRIN
define|#
directive|define
name|QT_COMPILER_SUPPORTS_X86INTRIN
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|Q_CC_INTEL
end_ifndef
begin_comment
comment|// The Intel compiler has no<x86intrin.h> -- all intrinsics are in<immintrin.h>;
end_comment
begin_comment
comment|// GCC 4.4 and Clang 2.8 added a few more intrinsics there
end_comment
begin_include
include|#
directive|include
file|<x86intrin.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// NEON intrinsics
end_comment
begin_comment
comment|// note: as of GCC 4.9, does not support function targets for ARM
end_comment
begin_if
if|#
directive|if
name|defined
name|__ARM_NEON__
end_if
begin_include
include|#
directive|include
file|<arm_neon.h>
end_include
begin_define
DECL|macro|QT_FUNCTION_TARGET_STRING_ARM_NEON
define|#
directive|define
name|QT_FUNCTION_TARGET_STRING_ARM_NEON
value|"neon"
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// IWMMXT intrinsics
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_IWMMXT
argument_list|)
end_if
begin_include
include|#
directive|include
file|<mmintrin.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_COMPILER_SUPPORTS_IWMMXT
argument_list|)
end_if
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__IWMMXT__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_include
include|#
directive|include
file|<xmmintrin.h>
end_include
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WINCE_STD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_X86_
argument_list|)
end_elif
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4391
name|)
end_pragma
begin_include
include|#
directive|include
file|<xmmintrin.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|QT_COMPILER_SUPPORTS_SIMD_ALWAYS
undef|#
directive|undef
name|QT_COMPILER_SUPPORTS_SIMD_ALWAYS
end_undef
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|enum|CPUFeatures
name|enum
name|CPUFeatures
block|{
DECL|enumerator|IWMMXT
name|IWMMXT
operator|=
literal|0x1
operator|,
DECL|enumerator|NEON
DECL|enumerator|ARM_NEON
name|NEON
operator|=
literal|0x2
operator|,
name|ARM_NEON
operator|=
name|NEON
operator|,
DECL|enumerator|SSE2
name|SSE2
operator|=
literal|0x4
operator|,
DECL|enumerator|SSE3
name|SSE3
operator|=
literal|0x8
operator|,
DECL|enumerator|SSSE3
name|SSSE3
operator|=
literal|0x10
operator|,
DECL|enumerator|SSE4_1
name|SSE4_1
operator|=
literal|0x20
operator|,
DECL|enumerator|SSE4_2
name|SSE4_2
operator|=
literal|0x40
operator|,
DECL|enumerator|AVX
name|AVX
operator|=
literal|0x80
operator|,
DECL|enumerator|AVX2
name|AVX2
operator|=
literal|0x100
operator|,
DECL|enumerator|HLE
name|HLE
operator|=
literal|0x200
operator|,
DECL|enumerator|RTM
name|RTM
operator|=
literal|0x400
operator|,
comment|// used only to indicate that the CPU detection was initialised
DECL|enumerator|QSimdInitialized
name|QSimdInitialized
operator|=
literal|0x80000000
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_decl_stmt
DECL|variable|qCompilerCpuFeatures
specifier|static
specifier|const
name|uint
name|qCompilerCpuFeatures
init|=
literal|0
if|#
directive|if
name|defined
name|__RTM__
operator||
name|RTM
endif|#
directive|endif
if|#
directive|if
name|defined
name|__HLE__
operator||
name|HLE
endif|#
directive|endif
if|#
directive|if
name|defined
name|__AVX2__
operator||
name|AVX2
endif|#
directive|endif
if|#
directive|if
name|defined
name|__AVX__
operator||
name|AVX
endif|#
directive|endif
if|#
directive|if
name|defined
name|__SSE4_2__
operator||
name|SSE4_2
endif|#
directive|endif
if|#
directive|if
name|defined
name|__SSE4_1__
operator||
name|SSE4_1
endif|#
directive|endif
if|#
directive|if
name|defined
name|__SSSE3__
operator||
name|SSSE3
endif|#
directive|endif
if|#
directive|if
name|defined
name|__SSE3__
operator||
name|SSE3
endif|#
directive|endif
if|#
directive|if
name|defined
name|__SSE2__
operator||
name|SSE2
endif|#
directive|endif
if|#
directive|if
name|defined
name|__ARM_NEON__
operator||
name|NEON
endif|#
directive|endif
if|#
directive|if
name|defined
name|__IWMMXT__
operator||
name|IWMMXT
endif|#
directive|endif
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|Q_CORE_EXPORT
name|QBasicAtomicInt
name|qt_cpu_features
decl_stmt|;
end_decl_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qDetectCpuFeatures
parameter_list|()
function_decl|;
end_function_decl
begin_function
DECL|function|qCpuFeatures
specifier|static
specifier|inline
name|uint
name|qCpuFeatures
parameter_list|()
block|{
name|int
name|features
init|=
name|qt_cpu_features
operator|.
name|load
argument_list|()
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|features
operator|==
literal|0
argument_list|)
condition|)
block|{
name|qDetectCpuFeatures
argument_list|()
expr_stmt|;
name|features
operator|=
name|qt_cpu_features
operator|.
name|load
argument_list|()
expr_stmt|;
name|Q_ASSUME
argument_list|(
name|features
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|uint
argument_list|(
name|features
argument_list|)
return|;
block|}
end_function
begin_define
DECL|macro|qCpuHasFeature
define|#
directive|define
name|qCpuHasFeature
parameter_list|(
name|feature
parameter_list|)
value|((qCompilerCpuFeatures& (feature)) || (qCpuFeatures()& (feature)))
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|Q_PROCESSOR_X86
end_ifdef
begin_comment
comment|// Bit scan functions for x86
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_CC_MSVC
end_ifdef
begin_comment
comment|// MSVC calls it _BitScanReverse and returns the carry flag, which we don't need
end_comment
begin_function
DECL|function|_bit_scan_reverse
specifier|static
name|__forceinline
name|unsigned
name|long
name|_bit_scan_reverse
parameter_list|(
name|uint
name|val
parameter_list|)
block|{
name|unsigned
name|long
name|result
decl_stmt|;
name|_BitScanReverse
argument_list|(
operator|&
name|result
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|_bit_scan_forward
specifier|static
name|__forceinline
name|unsigned
name|long
name|_bit_scan_forward
parameter_list|(
name|uint
name|val
parameter_list|)
block|{
name|unsigned
name|long
name|result
decl_stmt|;
name|_BitScanForward
argument_list|(
operator|&
name|result
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|Q_CC_CLANG
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
name|__GNUC__
operator|*
literal|100
operator|+
name|__GNUC_MINOR__
operator|<
literal|405
operator|)
operator|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
end_elif
begin_comment
comment|// Clang is missing the intrinsic for _bit_scan_reverse
end_comment
begin_comment
comment|// GCC only added it in version 4.5
end_comment
begin_expr_stmt
specifier|static
specifier|inline
name|__attribute__
argument_list|(
argument|(always_inline)
argument_list|)
DECL|function|_bit_scan_reverse
name|unsigned
name|_bit_scan_reverse
argument_list|(
argument|unsigned val
argument_list|)
block|{
name|unsigned
name|result
block|;
name|asm
argument_list|(
literal|"bsr %1, %0"
operator|:
literal|"=r"
operator|(
name|result
operator|)
operator|:
literal|"r"
operator|(
name|val
operator|)
argument_list|)
block|;
return|return
name|result
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|static
specifier|inline
name|__attribute__
argument_list|(
argument|(always_inline)
argument_list|)
DECL|function|_bit_scan_forward
name|unsigned
name|_bit_scan_forward
argument_list|(
argument|unsigned val
argument_list|)
block|{
name|unsigned
name|result
block|;
name|asm
argument_list|(
literal|"bsf %1, %0"
operator|:
literal|"=r"
operator|(
name|result
operator|)
operator|:
literal|"r"
operator|(
name|val
operator|)
argument_list|)
block|;
return|return
name|result
return|;
block|}
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_PROCESSOR_X86
end_comment
begin_define
DECL|macro|ALIGNMENT_PROLOGUE_16BYTES
define|#
directive|define
name|ALIGNMENT_PROLOGUE_16BYTES
parameter_list|(
name|ptr
parameter_list|,
name|i
parameter_list|,
name|length
parameter_list|)
define|\
value|for (; i< static_cast<int>(qMin(static_cast<quintptr>(length), ((4 - ((reinterpret_cast<quintptr>(ptr)>> 2)& 0x3))& 0x3))); ++i)
end_define
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QSIMD_P_H
end_comment
end_unit
