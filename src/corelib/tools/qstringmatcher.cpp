begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qstringmatcher.h"
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|bm_init_skiptable
specifier|static
name|void
name|bm_init_skiptable
parameter_list|(
specifier|const
name|ushort
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|uchar
modifier|*
name|skiptable
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
name|int
name|l
init|=
name|qMin
argument_list|(
name|len
argument_list|,
literal|255
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|skiptable
argument_list|,
name|l
argument_list|,
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|uchar
argument_list|)
argument_list|)
expr_stmt|;
name|uc
operator|+=
name|len
operator|-
name|l
expr_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
while|while
condition|(
name|l
operator|--
condition|)
block|{
name|skiptable
index|[
operator|*
name|uc
operator|&
literal|0xff
index|]
operator|=
name|l
expr_stmt|;
name|uc
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|ushort
modifier|*
name|start
init|=
name|uc
decl_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
block|{
name|skiptable
index|[
name|foldCase
argument_list|(
name|uc
argument_list|,
name|start
argument_list|)
operator|&
literal|0xff
index|]
operator|=
name|l
expr_stmt|;
name|uc
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|bm_find
specifier|static
specifier|inline
name|int
name|bm_find
parameter_list|(
specifier|const
name|ushort
modifier|*
name|uc
parameter_list|,
name|uint
name|l
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|ushort
modifier|*
name|puc
parameter_list|,
name|uint
name|pl
parameter_list|,
specifier|const
name|uchar
modifier|*
name|skiptable
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
if|if
condition|(
name|pl
operator|==
literal|0
condition|)
return|return
name|index
operator|>
operator|(
name|int
operator|)
name|l
condition|?
operator|-
literal|1
else|:
name|index
return|;
specifier|const
name|uint
name|pl_minus_one
init|=
name|pl
operator|-
literal|1
decl_stmt|;
specifier|register
specifier|const
name|ushort
modifier|*
name|current
init|=
name|uc
operator|+
name|index
operator|+
name|pl_minus_one
decl_stmt|;
specifier|const
name|ushort
modifier|*
name|end
init|=
name|uc
operator|+
name|l
decl_stmt|;
if|if
condition|(
name|cs
operator|==
name|Qt
operator|::
name|CaseSensitive
condition|)
block|{
while|while
condition|(
name|current
operator|<
name|end
condition|)
block|{
name|uint
name|skip
init|=
name|skiptable
index|[
operator|*
name|current
operator|&
literal|0xff
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
block|{
comment|// possible match
while|while
condition|(
name|skip
operator|<
name|pl
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|current
operator|-
name|skip
operator|)
operator|!=
name|puc
index|[
name|pl_minus_one
operator|-
name|skip
index|]
condition|)
break|break;
name|skip
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|skip
operator|>
name|pl_minus_one
condition|)
comment|// we have a match
return|return
operator|(
name|current
operator|-
name|uc
operator|)
operator|-
name|pl_minus_one
return|;
comment|// in case we don't have a match we are a bit inefficient as we only skip by one
comment|// when we have the non matching char in the string.
if|if
condition|(
name|skiptable
index|[
operator|*
operator|(
name|current
operator|-
name|skip
operator|)
operator|&
literal|0xff
index|]
operator|==
name|pl
condition|)
name|skip
operator|=
name|pl
operator|-
name|skip
expr_stmt|;
else|else
name|skip
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|>
name|end
operator|-
name|skip
condition|)
break|break;
name|current
operator|+=
name|skip
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|current
operator|<
name|end
condition|)
block|{
name|uint
name|skip
init|=
name|skiptable
index|[
name|foldCase
argument_list|(
name|current
argument_list|,
name|uc
argument_list|)
operator|&
literal|0xff
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
block|{
comment|// possible match
while|while
condition|(
name|skip
operator|<
name|pl
condition|)
block|{
if|if
condition|(
name|foldCase
argument_list|(
name|current
operator|-
name|skip
argument_list|,
name|uc
argument_list|)
operator|!=
name|foldCase
argument_list|(
name|puc
operator|+
name|pl_minus_one
operator|-
name|skip
argument_list|,
name|puc
argument_list|)
condition|)
break|break;
name|skip
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|skip
operator|>
name|pl_minus_one
condition|)
comment|// we have a match
return|return
operator|(
name|current
operator|-
name|uc
operator|)
operator|-
name|pl_minus_one
return|;
comment|// in case we don't have a match we are a bit inefficient as we only skip by one
comment|// when we have the non matching char in the string.
if|if
condition|(
name|skiptable
index|[
name|foldCase
argument_list|(
name|current
operator|-
name|skip
argument_list|,
name|uc
argument_list|)
operator|&
literal|0xff
index|]
operator|==
name|pl
condition|)
name|skip
operator|=
name|pl
operator|-
name|skip
expr_stmt|;
else|else
name|skip
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|>
name|end
operator|-
name|skip
condition|)
break|break;
name|current
operator|+=
name|skip
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
comment|// not found
block|}
end_function
begin_comment
comment|/*!     \class QStringMatcher     \inmodule QtCore     \brief The QStringMatcher class holds a sequence of characters that     can be quickly matched in a Unicode string.      \ingroup tools     \ingroup string-processing      This class is useful when you have a sequence of \l{QChar}s that     you want to repeatedly match against some strings (perhaps in a     loop), or when you want to search for the same sequence of     characters multiple times in the same string. Using a matcher     object and indexIn() is faster than matching a plain QString with     QString::indexOf() if repeated matching takes place. This class     offers no benefit if you are doing one-off string matches.      Create the QStringMatcher with the QString you want to search     for. Then call indexIn() on the QString that you want to search.      \sa QString, QByteArrayMatcher, QRegExp */
end_comment
begin_comment
comment|/*!     Constructs an empty string matcher that won't match anything.     Call setPattern() to give it a pattern to match. */
end_comment
begin_constructor
DECL|function|QStringMatcher
name|QStringMatcher
operator|::
name|QStringMatcher
parameter_list|()
member_init_list|:
name|d_ptr
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|q_cs
argument_list|(
name|Qt
operator|::
name|CaseSensitive
argument_list|)
block|{
name|memset
argument_list|(
name|q_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|q_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a string matcher that will search for \a pattern, with     case sensitivity \a cs.      Call indexIn() to perform a search. */
end_comment
begin_constructor
DECL|function|QStringMatcher
name|QStringMatcher
operator|::
name|QStringMatcher
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|q_pattern
argument_list|(
name|pattern
argument_list|)
member_init_list|,
name|q_cs
argument_list|(
name|cs
argument_list|)
block|{
name|p
operator|.
name|uc
operator|=
name|pattern
operator|.
name|unicode
argument_list|()
expr_stmt|;
name|p
operator|.
name|len
operator|=
name|pattern
operator|.
name|size
argument_list|()
expr_stmt|;
name|bm_init_skiptable
argument_list|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|p
operator|.
name|uc
argument_list|,
name|p
operator|.
name|len
argument_list|,
name|p
operator|.
name|q_skiptable
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QStringMatcher::QStringMatcher(const QChar *uc, int length, Qt::CaseSensitivity cs)     \since 4.5      Constructs a string matcher that will search for the pattern referred to     by \a uc with the given \a length and case sensitivity specified by \a cs. */
end_comment
begin_constructor
DECL|function|QStringMatcher
name|QStringMatcher
operator|::
name|QStringMatcher
parameter_list|(
specifier|const
name|QChar
modifier|*
name|uc
parameter_list|,
name|int
name|len
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|q_cs
argument_list|(
name|cs
argument_list|)
block|{
name|p
operator|.
name|uc
operator|=
name|uc
expr_stmt|;
name|p
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|bm_init_skiptable
argument_list|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|p
operator|.
name|uc
argument_list|,
name|len
argument_list|,
name|p
operator|.
name|q_skiptable
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Copies the \a other string matcher to this string matcher. */
end_comment
begin_constructor
DECL|function|QStringMatcher
name|QStringMatcher
operator|::
name|QStringMatcher
parameter_list|(
specifier|const
name|QStringMatcher
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
literal|0
argument_list|)
block|{
name|operator
name|=
parameter_list|(
name|other
parameter_list|)
function_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the string matcher. */
end_comment
begin_destructor
DECL|function|~QStringMatcher
name|QStringMatcher
operator|::
name|~
name|QStringMatcher
parameter_list|()
block|{
name|Q_UNUSED
argument_list|(
name|d_ptr
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Assigns the \a other string matcher to this string matcher. */
end_comment
begin_function
DECL|function|operator =
name|QStringMatcher
modifier|&
name|QStringMatcher
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QStringMatcher
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|!=
operator|&
name|other
condition|)
block|{
name|q_pattern
operator|=
name|other
operator|.
name|q_pattern
expr_stmt|;
name|q_cs
operator|=
name|other
operator|.
name|q_cs
expr_stmt|;
name|memcpy
argument_list|(
name|q_data
argument_list|,
name|other
operator|.
name|q_data
argument_list|,
sizeof|sizeof
argument_list|(
name|q_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the string that this string matcher will search for to \a     pattern.      \sa pattern(), setCaseSensitivity(), indexIn() */
end_comment
begin_function
DECL|function|setPattern
name|void
name|QStringMatcher
operator|::
name|setPattern
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|)
block|{
name|q_pattern
operator|=
name|pattern
expr_stmt|;
name|p
operator|.
name|uc
operator|=
name|pattern
operator|.
name|unicode
argument_list|()
expr_stmt|;
name|p
operator|.
name|len
operator|=
name|pattern
operator|.
name|size
argument_list|()
expr_stmt|;
name|bm_init_skiptable
argument_list|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|pattern
operator|.
name|unicode
argument_list|()
argument_list|,
name|pattern
operator|.
name|size
argument_list|()
argument_list|,
name|p
operator|.
name|q_skiptable
argument_list|,
name|q_cs
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QStringMatcher::pattern() const      Returns the string pattern that this string matcher will search     for.      \sa setPattern() */
end_comment
begin_function
DECL|function|pattern
name|QString
name|QStringMatcher
operator|::
name|pattern
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|q_pattern
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|q_pattern
return|;
return|return
name|QString
argument_list|(
name|p
operator|.
name|uc
argument_list|,
name|p
operator|.
name|len
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the case sensitivity setting of this string matcher to \a     cs.      \sa caseSensitivity(), setPattern(), indexIn() */
end_comment
begin_function
DECL|function|setCaseSensitivity
name|void
name|QStringMatcher
operator|::
name|setCaseSensitivity
parameter_list|(
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
if|if
condition|(
name|cs
operator|==
name|q_cs
condition|)
return|return;
name|bm_init_skiptable
argument_list|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|q_pattern
operator|.
name|unicode
argument_list|()
argument_list|,
name|q_pattern
operator|.
name|size
argument_list|()
argument_list|,
name|p
operator|.
name|q_skiptable
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|q_cs
operator|=
name|cs
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Searches the string \a str from character position \a from     (default 0, i.e. from the first character), for the string     pattern() that was set in the constructor or in the most recent     call to setPattern(). Returns the position where the pattern()     matched in \a str, or -1 if no match was found.      \sa setPattern(), setCaseSensitivity() */
end_comment
begin_function
DECL|function|indexIn
name|int
name|QStringMatcher
operator|::
name|indexIn
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|=
literal|0
expr_stmt|;
return|return
name|bm_find
argument_list|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|size
argument_list|()
argument_list|,
name|from
argument_list|,
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|p
operator|.
name|uc
argument_list|,
name|p
operator|.
name|len
argument_list|,
name|p
operator|.
name|q_skiptable
argument_list|,
name|q_cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Searches the string starting at \a str (of length \a length) from     character position \a from (default 0, i.e. from the first     character), for the string pattern() that was set in the     constructor or in the most recent call to setPattern(). Returns     the position where the pattern() matched in \a str, or -1 if no     match was found.      \sa setPattern(), setCaseSensitivity() */
end_comment
begin_function
DECL|function|indexIn
name|int
name|QStringMatcher
operator|::
name|indexIn
parameter_list|(
specifier|const
name|QChar
modifier|*
name|str
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|from
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|from
operator|<
literal|0
condition|)
name|from
operator|=
literal|0
expr_stmt|;
return|return
name|bm_find
argument_list|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|str
argument_list|,
name|length
argument_list|,
name|from
argument_list|,
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|p
operator|.
name|uc
argument_list|,
name|p
operator|.
name|len
argument_list|,
name|p
operator|.
name|q_skiptable
argument_list|,
name|q_cs
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn Qt::CaseSensitivity QStringMatcher::caseSensitivity() const      Returns the case sensitivity setting for this string matcher.      \sa setCaseSensitivity() */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qFindStringBoyerMoore
name|int
name|qFindStringBoyerMoore
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
name|int
name|haystackOffset
parameter_list|,
specifier|const
name|QChar
modifier|*
name|needle
parameter_list|,
name|int
name|needleLen
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
name|uchar
name|skiptable
index|[
literal|256
index|]
decl_stmt|;
name|bm_init_skiptable
argument_list|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|needle
argument_list|,
name|needleLen
argument_list|,
name|skiptable
argument_list|,
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|haystackOffset
operator|<
literal|0
condition|)
name|haystackOffset
operator|=
literal|0
expr_stmt|;
return|return
name|bm_find
argument_list|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|haystack
argument_list|,
name|haystackLen
argument_list|,
name|haystackOffset
argument_list|,
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|needle
argument_list|,
name|needleLen
argument_list|,
name|skiptable
argument_list|,
name|cs
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
