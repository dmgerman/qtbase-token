begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qregexp.h"
end_include
begin_include
include|#
directive|include
file|"qalgorithms.h"
end_include
begin_include
include|#
directive|include
file|"qbitarray.h"
end_include
begin_include
include|#
directive|include
file|"qcache.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qmap.h"
end_include
begin_include
include|#
directive|include
file|"qmutex.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qstringmatcher.h"
end_include
begin_include
include|#
directive|include
file|"qvector.h"
end_include
begin_include
include|#
directive|include
file|"private/qfunctions_p.h"
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|int
name|qFindString
parameter_list|(
specifier|const
name|QChar
modifier|*
name|haystack
parameter_list|,
name|int
name|haystackLen
parameter_list|,
name|int
name|from
parameter_list|,
specifier|const
name|QChar
modifier|*
name|needle
parameter_list|,
name|int
name|needleLen
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// error strings for the regexp parser
end_comment
begin_define
DECL|macro|RXERR_OK
define|#
directive|define
name|RXERR_OK
value|QT_TRANSLATE_NOOP("QRegExp", "no error occurred")
end_define
begin_define
DECL|macro|RXERR_DISABLED
define|#
directive|define
name|RXERR_DISABLED
value|QT_TRANSLATE_NOOP("QRegExp", "disabled feature used")
end_define
begin_define
DECL|macro|RXERR_CHARCLASS
define|#
directive|define
name|RXERR_CHARCLASS
value|QT_TRANSLATE_NOOP("QRegExp", "bad char class syntax")
end_define
begin_define
DECL|macro|RXERR_LOOKAHEAD
define|#
directive|define
name|RXERR_LOOKAHEAD
value|QT_TRANSLATE_NOOP("QRegExp", "bad lookahead syntax")
end_define
begin_define
DECL|macro|RXERR_LOOKBEHIND
define|#
directive|define
name|RXERR_LOOKBEHIND
value|QT_TRANSLATE_NOOP("QRegExp", "lookbehinds not supported, see QTBUG-2371")
end_define
begin_define
DECL|macro|RXERR_REPETITION
define|#
directive|define
name|RXERR_REPETITION
value|QT_TRANSLATE_NOOP("QRegExp", "bad repetition syntax")
end_define
begin_define
DECL|macro|RXERR_OCTAL
define|#
directive|define
name|RXERR_OCTAL
value|QT_TRANSLATE_NOOP("QRegExp", "invalid octal value")
end_define
begin_define
DECL|macro|RXERR_LEFTDELIM
define|#
directive|define
name|RXERR_LEFTDELIM
value|QT_TRANSLATE_NOOP("QRegExp", "missing left delim")
end_define
begin_define
DECL|macro|RXERR_END
define|#
directive|define
name|RXERR_END
value|QT_TRANSLATE_NOOP("QRegExp", "unexpected end")
end_define
begin_define
DECL|macro|RXERR_LIMIT
define|#
directive|define
name|RXERR_LIMIT
value|QT_TRANSLATE_NOOP("QRegExp", "met internal limit")
end_define
begin_define
DECL|macro|RXERR_INTERVAL
define|#
directive|define
name|RXERR_INTERVAL
value|QT_TRANSLATE_NOOP("QRegExp", "invalid interval")
end_define
begin_define
DECL|macro|RXERR_CATEGORY
define|#
directive|define
name|RXERR_CATEGORY
value|QT_TRANSLATE_NOOP("QRegExp", "invalid category")
end_define
begin_comment
comment|/*!     \class QRegExp     \reentrant     \brief The QRegExp class provides pattern matching using regular expressions.      \ingroup tools     \ingroup shared      \keyword regular expression      A regular expression, or "regexp", is a pattern for matching     substrings in a text. This is useful in many contexts, e.g.,      \table     \row \i Validation          \i A regexp can test whether a substring meets some criteria,          e.g. is an integer or contains no whitespace.     \row \i Searching          \i A regexp provides more powerful pattern matching than          simple substring matching, e.g., match one of the words          \e{mail}, \e{letter} or \e{correspondence}, but none of the          words \e{email}, \e{mailman}, \e{mailer}, \e{letterbox}, etc.      \row \i Search and Replace          \i A regexp can replace all occurrences of a substring with a          different substring, e.g., replace all occurrences of \e{&}          with \e{\&amp;} except where the \e{&} is already followed by          an \e{amp;}.     \row \i String Splitting          \i A regexp can be used to identify where a string should be          split apart, e.g. splitting tab-delimited strings.     \endtable      A brief introduction to regexps is presented, a description of     Qt's regexp language, some examples, and the function     documentation itself. QRegExp is modeled on Perl's regexp     language. It fully supports Unicode. QRegExp can also be used in a     simpler, \e{wildcard mode} that is similar to the functionality     found in command shells. The syntax rules used by QRegExp can be     changed with setPatternSyntax(). In particular, the pattern syntax     can be set to QRegExp::FixedString, which means the pattern to be     matched is interpreted as a plain string, i.e., special characters     (e.g., backslash) are not escaped.      A good text on regexps is \e {Mastering Regular Expressions}     (Third Edition) by Jeffrey E. F.  Friedl, ISBN 0-596-52812-4.      \tableofcontents      \section1 Introduction      Regexps are built up from expressions, quantifiers, and     assertions. The simplest expression is a character, e.g. \bold{x}     or \bold{5}. An expression can also be a set of characters     enclosed in square brackets. \bold{[ABCD]} will match an \bold{A}     or a \bold{B} or a \bold{C} or a \bold{D}. We can write this same     expression as \bold{[A-D]}, and an experession to match any     captital letter in the English alphabet is written as     \bold{[A-Z]}.      A quantifier specifies the number of occurrences of an expression     that must be matched. \bold{x{1,1}} means match one and only one     \bold{x}. \bold{x{1,5}} means match a sequence of \bold{x}     characters that contains at least one \bold{x} but no more than     five.      Note that in general regexps cannot be used to check for balanced     brackets or tags. For example, a regexp can be written to match an     opening html \c{<b>} and its closing \c{</b>}, if the \c{<b>} tags     are not nested, but if the \c{<b>} tags are nested, that same     regexp will match an opening \c{<b>} tag with the wrong closing     \c{</b>}.  For the fragment \c{<b>bold<b>bolder</b></b>}, the     first \c{<b>} would be matched with the first \c{</b>}, which is     not correct. However, it is possible to write a regexp that will     match nested brackets or tags correctly, but only if the number of     nesting levels is fixed and known. If the number of nesting levels     is not fixed and known, it is impossible to write a regexp that     will not fail.      Suppose we want a regexp to match integers in the range 0 to 99.     At least one digit is required, so we start with the expression     \bold{[0-9]{1,1}}, which matches a single digit exactly once. This     regexp matches integers in the range 0 to 9. To match integers up     to 99, increase the maximum number of occurrences to 2, so the     regexp becomes \bold{[0-9]{1,2}}. This regexp satisfies the     original requirement to match integers from 0 to 99, but it will     also match integers that occur in the middle of strings. If we     want the matched integer to be the whole string, we must use the     anchor assertions, \bold{^} (caret) and \bold{$} (dollar). When     \bold{^} is the first character in a regexp, it means the regexp     must match from the beginning of the string. When \bold{$} is the     last character of the regexp, it means the regexp must match to     the end of the string. The regexp becomes \bold{^[0-9]{1,2}$}.     Note that assertions, e.g. \bold{^} and \bold{$}, do not match     characters but locations in the string.      If you have seen regexps described elsewhere, they may have looked     different from the ones shown here. This is because some sets of     characters and some quantifiers are so common that they have been     given special symbols to represent them. \bold{[0-9]} can be     replaced with the symbol \bold{\\d}. The quantifier to match     exactly one occurrence, \bold{{1,1}}, can be replaced with the     expression itself, i.e. \bold{x{1,1}} is the same as \bold{x}. So     our 0 to 99 matcher could be written as \bold{^\\d{1,2}$}. It can     also be written \bold{^\\d\\d{0,1}$}, i.e. \e{From the start of     the string, match a digit, followed immediately by 0 or 1 digits}.     In practice, it would be written as \bold{^\\d\\d?$}. The \bold{?}     is shorthand for the quantifier \bold{{0,1}}, i.e. 0 or 1     occurrences. \bold{?} makes an expression optional. The regexp     \bold{^\\d\\d?$} means \e{From the beginning of the string, match     one digit, followed immediately by 0 or 1 more digit, followed     immediately by end of string}.      To write a regexp that matches one of the words 'mail' \e or     'letter' \e or 'correspondence' but does not match words that     contain these words, e.g., 'email', 'mailman', 'mailer', and     'letterbox', start with a regexp that matches 'mail'. Expressed     fully, the regexp is \bold{m{1,1}a{1,1}i{1,1}l{1,1}}, but because     a character expression is automatically quantified by     \bold{{1,1}}, we can simplify the regexp to \bold{mail}, i.e., an     'm' followed by an 'a' followed by an 'i' followed by an 'l'. Now     we can use the vertical bar \bold{|}, which means \bold{or}, to     include the other two words, so our regexp for matching any of the     three words becomes \bold{mail|letter|correspondence}. Match     'mail' \bold{or} 'letter' \bold{or} 'correspondence'. While this     regexp will match one of the three words we want to match, it will     also match words we don't want to match, e.g., 'email'.  To     prevent the regexp from matching unwanted words, we must tell it     to begin and end the match at word boundaries. First we enclose     our regexp in parentheses, \bold{(mail|letter|correspondence)}.     Parentheses group expressions together, and they identify a part     of the regexp that we wish to \l{capturing text}{capture}.     Enclosing the expression in parentheses allows us to use it as a     component in more complex regexps. It also allows us to examine     which of the three words was actually matched. To force the match     to begin and end on word boundaries, we enclose the regexp in     \bold{\\b} \e{word boundary} assertions:     \bold{\\b(mail|letter|correspondence)\\b}.  Now the regexp means:     \e{Match a word boundary, followed by the regexp in parentheses,     followed by a word boundary}. The \bold{\\b} assertion matches a     \e position in the regexp, not a \e character. A word boundary is     any non-word character, e.g., a space, newline, or the beginning     or ending of a string.      If we want to replace ampersand characters with the HTML entity     \bold{\&amp;}, the regexp to match is simply \bold{\&}. But this     regexp will also match ampersands that have already been converted     to HTML entities. We want to replace only ampersands that are not     already followed by \bold{amp;}. For this, we need the negative     lookahead assertion, \bold{(?!}__\bold{)}. The regexp can then be     written as \bold{\&(?!amp;)}, i.e. \e{Match an ampersand that is}     \bold{not} \e{followed by} \bold{amp;}.      If we want to count all the occurrences of 'Eric' and 'Eirik' in a     string, two valid solutions are \bold{\\b(Eric|Eirik)\\b} and     \bold{\\bEi?ri[ck]\\b}. The word boundary assertion '\\b' is     required to avoid matching words that contain either name,     e.g. 'Ericsson'. Note that the second regexp matches more     spellings than we want: 'Eric', 'Erik', 'Eiric' and 'Eirik'.      Some of the examples discussed above are implemented in the     \link #code-examples code examples \endlink section.      \target characters-and-abbreviations-for-sets-of-characters     \section1 Characters and Abbreviations for Sets of Characters      \table     \header \i Element \i Meaning     \row \i \bold{c}          \i A character represents itself unless it has a special          regexp meaning. e.g. \bold{c} matches the character \e c.     \row \i \bold{\\c}          \i A character that follows a backslash matches the character          itself, except as specified below. e.g., To match a literal          caret at the beginning of a string, write \bold{\\^}.     \row \i \bold{\\a}          \i Matches the ASCII bell (BEL, 0x07).     \row \i \bold{\\f}          \i Matches the ASCII form feed (FF, 0x0C).     \row \i \bold{\\n}          \i Matches the ASCII line feed (LF, 0x0A, Unix newline).     \row \i \bold{\\r}          \i Matches the ASCII carriage return (CR, 0x0D).     \row \i \bold{\\t}          \i Matches the ASCII horizontal tab (HT, 0x09).     \row \i \bold{\\v}          \i Matches the ASCII vertical tab (VT, 0x0B).     \row \i \bold{\\x\e{hhhh}}          \i Matches the Unicode character corresponding to the          hexadecimal number \e{hhhh} (between 0x0000 and 0xFFFF).     \row \i \bold{\\0\e{ooo}} (i.e., \\zero \e{ooo})          \i matches the ASCII/Latin1 character for the octal number          \e{ooo} (between 0 and 0377).     \row \i \bold{. (dot)}          \i Matches any character (including newline).     \row \i \bold{\\d}          \i Matches a digit (QChar::isDigit()).     \row \i \bold{\\D}          \i Matches a non-digit.     \row \i \bold{\\s}          \i Matches a whitespace character (QChar::isSpace()).     \row \i \bold{\\S}          \i Matches a non-whitespace character.     \row \i \bold{\\w}          \i Matches a word character (QChar::isLetterOrNumber(), QChar::isMark(), or '_').     \row \i \bold{\\W}          \i Matches a non-word character.     \row \i \bold{\\\e{n}}          \i The \e{n}-th \l backreference, e.g. \\1, \\2, etc.     \endtable      \bold{Note:} The C++ compiler transforms backslashes in strings.     To include a \bold{\\} in a regexp, enter it twice, i.e. \c{\\}.     To match the backslash character itself, enter it four times, i.e.     \c{\\\\}.      \target sets-of-characters     \section1 Sets of Characters      Square brackets mean match any character contained in the square     brackets. The character set abbreviations described above can     appear in a character set in square brackets. Except for the     character set abbreviations and the following two exceptions,      characters do not have special meanings in square brackets.      \table     \row \i \bold{^}           \i The caret negates the character set if it occurs as the          first character (i.e. immediately after the opening square          bracket). \bold{[abc]} matches 'a' or 'b' or 'c', but          \bold{[^abc]} matches anything \e but 'a' or 'b' or 'c'.      \row \i \bold{-}           \i The dash indicates a range of characters. \bold{[W-Z]}          matches 'W' or 'X' or 'Y' or 'Z'.      \endtable      Using the predefined character set abbreviations is more portable     than using character ranges across platforms and languages. For     example, \bold{[0-9]} matches a digit in Western alphabets but     \bold{\\d} matches a digit in \e any alphabet.      Note: In other regexp documentation, sets of characters are often     called "character classes".      \target quantifiers     \section1 Quantifiers      By default, an expression is automatically quantified by     \bold{{1,1}}, i.e. it should occur exactly once. In the following     list, \bold{\e {E}} stands for expression. An expression is a     character, or an abbreviation for a set of characters, or a set of     characters in square brackets, or an expression in parentheses.      \table     \row \i \bold{\e {E}?}           \i Matches zero or one occurrences of \e E. This quantifier          means \e{The previous expression is optional}, because it          will match whether or not the expression is found. \bold{\e          {E}?} is the same as \bold{\e {E}{0,1}}. e.g., \bold{dents?}          matches 'dent' or 'dents'.      \row \i \bold{\e {E}+}           \i Matches one or more occurrences of \e E. \bold{\e {E}+} is          the same as \bold{\e {E}{1,}}. e.g., \bold{0+} matches '0',          '00', '000', etc.      \row \i \bold{\e {E}*}           \i Matches zero or more occurrences of \e E. It is the same          as \bold{\e {E}{0,}}. The \bold{*} quantifier is often used          in error where \bold{+} should be used. For example, if          \bold{\\s*$} is used in an expression to match strings that          end in whitespace, it will match every string because          \bold{\\s*$} means \e{Match zero or more whitespaces followed          by end of string}. The correct regexp to match strings that          have at least one trailing whitespace character is          \bold{\\s+$}.      \row \i \bold{\e {E}{n}}           \i Matches exactly \e n occurrences of \e E. \bold{\e {E}{n}}          is the same as repeating \e E \e n times. For example,          \bold{x{5}} is the same as \bold{xxxxx}. It is also the same          as \bold{\e {E}{n,n}}, e.g. \bold{x{5,5}}.      \row \i \bold{\e {E}{n,}}          \i Matches at least \e n occurrences of \e E.      \row \i \bold{\e {E}{,m}}          \i Matches at most \e m occurrences of \e E. \bold{\e {E}{,m}}          is the same as \bold{\e {E}{0,m}}.      \row \i \bold{\e {E}{n,m}}          \i Matches at least \e n and at most \e m occurrences of \e E.     \endtable      To apply a quantifier to more than just the preceding character,     use parentheses to group characters together in an expression. For     example, \bold{tag+} matches a 't' followed by an 'a' followed by     at least one 'g', whereas \bold{(tag)+} matches at least one     occurrence of 'tag'.      Note: Quantifiers are normally "greedy". They always match as much     text as they can. For example, \bold{0+} matches the first zero it     finds and all the consecutive zeros after the first zero. Applied     to '20005', it matches'2\underline{000}5'. Quantifiers can be made     non-greedy, see setMinimal().      \target capturing parentheses     \target backreferences     \section1 Capturing Text      Parentheses allow us to group elements together so that we can     quantify and capture them. For example if we have the expression     \bold{mail|letter|correspondence} that matches a string we know     that \e one of the words matched but not which one. Using     parentheses allows us to "capture" whatever is matched within     their bounds, so if we used \bold{(mail|letter|correspondence)}     and matched this regexp against the string "I sent you some email"     we can use the cap() or capturedTexts() functions to extract the     matched characters, in this case 'mail'.      We can use captured text within the regexp itself. To refer to the     captured text we use \e backreferences which are indexed from 1,     the same as for cap(). For example we could search for duplicate     words in a string using \bold{\\b(\\w+)\\W+\\1\\b} which means match a     word boundary followed by one or more word characters followed by     one or more non-word characters followed by the same text as the     first parenthesized expression followed by a word boundary.      If we want to use parentheses purely for grouping and not for     capturing we can use the non-capturing syntax, e.g.     \bold{(?:green|blue)}. Non-capturing parentheses begin '(?:' and     end ')'. In this example we match either 'green' or 'blue' but we     do not capture the match so we only know whether or not we matched     but not which color we actually found. Using non-capturing     parentheses is more efficient than using capturing parentheses     since the regexp engine has to do less book-keeping.      Both capturing and non-capturing parentheses may be nested.      \target greedy quantifiers      For historical reasons, quantifiers (e.g. \bold{*}) that apply to     capturing parentheses are more "greedy" than other quantifiers.     For example, \bold{a*(a*)} will match "aaa" with cap(1) == "aaa".     This behavior is different from what other regexp engines do     (notably, Perl). To obtain a more intuitive capturing behavior,     specify QRegExp::RegExp2 to the QRegExp constructor or call     setPatternSyntax(QRegExp::RegExp2).      \target cap_in_a_loop      When the number of matches cannot be determined in advance, a     common idiom is to use cap() in a loop. For example:      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 0      \target assertions     \section1 Assertions      Assertions make some statement about the text at the point where     they occur in the regexp but they do not match any characters. In     the following list \bold{\e {E}} stands for any expression.      \table     \row \i \bold{^}          \i The caret signifies the beginning of the string. If you          wish to match a literal \c{^} you must escape it by          writing \c{\\^}. For example, \bold{^#include} will only          match strings which \e begin with the characters '#include'.          (When the caret is the first character of a character set it          has a special meaning, see \link #sets-of-characters Sets of          Characters \endlink.)      \row \i \bold{$}          \i The dollar signifies the end of the string. For example          \bold{\\d\\s*$} will match strings which end with a digit          optionally followed by whitespace. If you wish to match a          literal \c{$} you must escape it by writing          \c{\\$}.      \row \i \bold{\\b}          \i A word boundary. For example the regexp          \bold{\\bOK\\b} means match immediately after a word          boundary (e.g. start of string or whitespace) the letter 'O'          then the letter 'K' immediately before another word boundary          (e.g. end of string or whitespace). But note that the          assertion does not actually match any whitespace so if we          write \bold{(\\bOK\\b)} and we have a match it will only          contain 'OK' even if the string is "It's \underline{OK} now".      \row \i \bold{\\B}          \i A non-word boundary. This assertion is true wherever          \bold{\\b} is false. For example if we searched for          \bold{\\Bon\\B} in "Left on" the match would fail (space          and end of string aren't non-word boundaries), but it would          match in "t\underline{on}ne".      \row \i \bold{(?=\e E)}          \i Positive lookahead. This assertion is true if the          expression matches at this point in the regexp. For example,          \bold{const(?=\\s+char)} matches 'const' whenever it is          followed by 'char', as in 'static \underline{const} char *'.          (Compare with \bold{const\\s+char}, which matches 'static          \underline{const char} *'.)      \row \i \bold{(?!\e E)}          \i Negative lookahead. This assertion is true if the          expression does not match at this point in the regexp. For          example, \bold{const(?!\\s+char)} matches 'const' \e except          when it is followed by 'char'.     \endtable      \keyword QRegExp wildcard matching     \section1 Wildcard Matching      Most command shells such as \e bash or \e cmd.exe support "file     globbing", the ability to identify a group of files by using     wildcards. The setPatternSyntax() function is used to switch     between regexp and wildcard mode. Wildcard matching is much     simpler than full regexps and has only four features:      \table     \row \i \bold{c}          \i Any character represents itself apart from those mentioned          below. Thus \bold{c} matches the character \e c.     \row \i \bold{?}          \i Matches any single character. It is the same as          \bold{.} in full regexps.     \row \i \bold{*}          \i Matches zero or more of any characters. It is the          same as \bold{.*} in full regexps.     \row \i \bold{[...]}          \i Sets of characters can be represented in square brackets,          similar to full regexps. Within the character class, like          outside, backslash has no special meaning.     \endtable      In the mode Wildcard, the wildcard characters cannot be     escaped. In the mode WildcardUnix, the character '\\' escapes the     wildcard.      For example if we are in wildcard mode and have strings which     contain filenames we could identify HTML files with \bold{*.html}.     This will match zero or more characters followed by a dot followed     by 'h', 't', 'm' and 'l'.      To test a string against a wildcard expression, use exactMatch().     For example:      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 1      \target perl-users     \section1 Notes for Perl Users      Most of the character class abbreviations supported by Perl are     supported by QRegExp, see \link     #characters-and-abbreviations-for-sets-of-characters characters     and abbreviations for sets of characters \endlink.      In QRegExp, apart from within character classes, \c{^} always     signifies the start of the string, so carets must always be     escaped unless used for that purpose. In Perl the meaning of caret     varies automagically depending on where it occurs so escaping it     is rarely necessary. The same applies to \c{$} which in     QRegExp always signifies the end of the string.      QRegExp's quantifiers are the same as Perl's greedy quantifiers     (but see the \l{greedy quantifiers}{note above}). Non-greedy     matching cannot be applied to individual quantifiers, but can be     applied to all the quantifiers in the pattern. For example, to     match the Perl regexp \bold{ro+?m} requires:      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 2      The equivalent of Perl's \c{/i} option is     setCaseSensitivity(Qt::CaseInsensitive).      Perl's \c{/g} option can be emulated using a \l{#cap_in_a_loop}{loop}.      In QRegExp \bold{.} matches any character, therefore all QRegExp     regexps have the equivalent of Perl's \c{/s} option. QRegExp     does not have an equivalent to Perl's \c{/m} option, but this     can be emulated in various ways for example by splitting the input     into lines or by looping with a regexp that searches for newlines.      Because QRegExp is string oriented, there are no \\A, \\Z, or \\z     assertions. The \\G assertion is not supported but can be emulated     in a loop.      Perl's $& is cap(0) or capturedTexts()[0]. There are no QRegExp     equivalents for $`, $' or $+. Perl's capturing variables, $1, $2,     ... correspond to cap(1) or capturedTexts()[1], cap(2) or     capturedTexts()[2], etc.      To substitute a pattern use QString::replace().      Perl's extended \c{/x} syntax is not supported, nor are     directives, e.g. (?i), or regexp comments, e.g. (?#comment). On     the other hand, C++'s rules for literal strings can be used to     achieve the same:      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 3      Both zero-width positive and zero-width negative lookahead     assertions (?=pattern) and (?!pattern) are supported with the same     syntax as Perl. Perl's lookbehind assertions, "independent"     subexpressions and conditional expressions are not supported.      Non-capturing parentheses are also supported, with the same     (?:pattern) syntax.      See QString::split() and QStringList::join() for equivalents     to Perl's split and join functions.      Note: because C++ transforms \\'s they must be written \e twice in     code, e.g. \bold{\\b} must be written \bold{\\\\b}.      \target code-examples     \section1 Code Examples      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 4      The third string matches '\underline{6}'. This is a simple validation     regexp for integers in the range 0 to 99.      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 5      The second string matches '\underline{This_is-OK}'. We've used the     character set abbreviation '\\S' (non-whitespace) and the anchors     to match strings which contain no whitespace.      In the following example we match strings containing 'mail' or     'letter' or 'correspondence' but only match whole words i.e. not     'email'      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 6      The second string matches "Please write the \underline{letter}". The     word 'letter' is also captured (because of the parentheses). We     can see what text we've captured like this:      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 7      This will capture the text from the first set of capturing     parentheses (counting capturing left parentheses from left to     right). The parentheses are counted from 1 since cap(0) is the     whole matched regexp (equivalent to '&' in most regexp engines).      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 8      Here we've passed the QRegExp to QString's replace() function to     replace the matched text with new text.      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 9      We've used the indexIn() function to repeatedly match the regexp in     the string. Note that instead of moving forward by one character     at a time \c pos++ we could have written \c {pos +=     rx.matchedLength()} to skip over the already matched string. The     count will equal 3, matching 'One \underline{Eric} another     \underline{Eirik}, and an Ericsson. How many Eiriks, \underline{Eric}?'; it     doesn't match 'Ericsson' or 'Eiriks' because they are not bounded     by non-word boundaries.      One common use of regexps is to split lines of delimited data into     their component fields.      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 10      In this example our input lines have the format company name, web     address and country. Unfortunately the regexp is rather long and     not very versatile -- the code will break if we add any more     fields. A simpler and better solution is to look for the     separator, '\\t' in this case, and take the surrounding text. The     QString::split() function can take a separator string or regexp     as an argument and split a string accordingly.      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 11      Here field[0] is the company, field[1] the web address and so on.      To imitate the matching of a shell we can use wildcard mode.      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 12      Wildcard matching can be convenient because of its simplicity, but     any wildcard regexp can be defined using full regexps, e.g.     \bold{.*\\.html$}. Notice that we can't match both \c .html and \c     .htm files with a wildcard unless we use \bold{*.htm*} which will     also match 'test.html.bak'. A full regexp gives us the precision     we need, \bold{.*\\.html?$}.      QRegExp can match case insensitively using setCaseSensitivity(),     and can use non-greedy matching, see setMinimal(). By     default QRegExp uses full regexps but this can be changed with     setWildcard(). Searching can be forward with indexIn() or backward     with lastIndexIn(). Captured text can be accessed using     capturedTexts() which returns a string list of all captured     strings, or using cap() which returns the captured string for the     given index. The pos() function takes a match index and returns     the position in the string where the match was made (or -1 if     there was no match).      \sa QString, QStringList, QRegExpValidator, QSortFilterProxyModel,         {tools/regexp}{Regular Expression Example} */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
operator|&&
name|defined
argument_list|(
name|EOS
argument_list|)
end_if
begin_undef
DECL|macro|EOS
undef|#
directive|undef
name|EOS
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|NumBadChars
specifier|const
name|int
name|NumBadChars
init|=
literal|64
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|BadChar
define|#
directive|define
name|BadChar
parameter_list|(
name|ch
parameter_list|)
value|((ch).unicode() % NumBadChars)
end_define
begin_decl_stmt
DECL|variable|NoOccurrence
specifier|const
name|int
name|NoOccurrence
init|=
name|INT_MAX
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|EmptyCapture
specifier|const
name|int
name|EmptyCapture
init|=
name|INT_MAX
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|InftyLen
specifier|const
name|int
name|InftyLen
init|=
name|INT_MAX
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|InftyRep
specifier|const
name|int
name|InftyRep
init|=
literal|1025
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|EOS
specifier|const
name|int
name|EOS
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|isWord
specifier|static
name|bool
name|isWord
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
return|return
name|ch
operator|.
name|isLetterOrNumber
argument_list|()
operator|||
name|ch
operator|.
name|isMark
argument_list|()
operator|||
name|ch
operator|==
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*   Merges two vectors of ints and puts the result into the first   one. */
end_comment
begin_function
DECL|function|mergeInto
specifier|static
name|void
name|mergeInto
parameter_list|(
name|QVector
argument_list|<
name|int
argument_list|>
modifier|*
name|a
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|b
parameter_list|)
block|{
name|int
name|asize
init|=
name|a
operator|->
name|size
argument_list|()
decl_stmt|;
name|int
name|bsize
init|=
name|b
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|asize
operator|==
literal|0
condition|)
block|{
operator|*
name|a
operator|=
name|b
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
block|}
elseif|else
if|if
condition|(
name|bsize
operator|==
literal|1
operator|&&
name|a
operator|->
name|at
argument_list|(
name|asize
operator|-
literal|1
argument_list|)
operator|<
name|b
operator|.
name|at
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|a
operator|->
name|resize
argument_list|(
name|asize
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|a
operator|)
index|[
name|asize
index|]
operator|=
name|b
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|bsize
operator|>=
literal|1
condition|)
block|{
name|int
name|csize
init|=
name|asize
operator|+
name|bsize
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
name|c
argument_list|(
name|csize
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|k
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|asize
condition|)
block|{
if|if
condition|(
name|j
operator|<
name|bsize
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|b
operator|.
name|at
argument_list|(
name|j
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
operator|--
name|csize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|<
name|b
operator|.
name|at
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|c
index|[
name|k
operator|++
index|]
operator|=
name|a
operator|->
name|at
argument_list|(
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
index|[
name|k
operator|++
index|]
operator|=
name|b
operator|.
name|at
argument_list|(
name|j
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|memcpy
argument_list|(
name|c
operator|.
name|data
argument_list|()
operator|+
name|k
argument_list|,
name|a
operator|->
name|constData
argument_list|()
operator|+
name|i
argument_list|,
operator|(
name|asize
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|c
operator|.
name|resize
argument_list|(
name|csize
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|bsize
condition|)
name|memcpy
argument_list|(
name|c
operator|.
name|data
argument_list|()
operator|+
name|k
argument_list|,
name|b
operator|.
name|constData
argument_list|()
operator|+
name|j
argument_list|,
operator|(
name|bsize
operator|-
name|j
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|a
operator|=
name|c
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_WILDCARD
end_ifndef
begin_comment
comment|/*   Translates a wildcard pattern to an equivalent regular expression   pattern (e.g., *.cpp to .*\.cpp).    If enableEscaping is true, it is possible to escape the wildcard   characters with \ */
end_comment
begin_function
DECL|function|wc2rx
specifier|static
name|QString
name|wc2rx
parameter_list|(
specifier|const
name|QString
modifier|&
name|wc_str
parameter_list|,
specifier|const
name|bool
name|enableEscaping
parameter_list|)
block|{
specifier|const
name|int
name|wclen
init|=
name|wc_str
operator|.
name|length
argument_list|()
decl_stmt|;
name|QString
name|rx
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|bool
name|isEscaping
init|=
literal|false
decl_stmt|;
comment|// the previous character is '\'
specifier|const
name|QChar
modifier|*
name|wc
init|=
name|wc_str
operator|.
name|unicode
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|wclen
condition|)
block|{
specifier|const
name|QChar
name|c
init|=
name|wc
index|[
name|i
operator|++
index|]
decl_stmt|;
switch|switch
condition|(
name|c
operator|.
name|unicode
argument_list|()
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|enableEscaping
condition|)
block|{
if|if
condition|(
name|isEscaping
condition|)
block|{
name|rx
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
block|}
comment|// we insert the \\ later if necessary
if|if
condition|(
name|i
operator|==
name|wclen
condition|)
block|{
comment|// the end
name|rx
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rx
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
block|}
name|isEscaping
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|isEscaping
condition|)
block|{
name|rx
operator|+=
name|QLatin1String
argument_list|(
literal|"\\*"
argument_list|)
expr_stmt|;
name|isEscaping
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|rx
operator|+=
name|QLatin1String
argument_list|(
literal|".*"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
name|isEscaping
condition|)
block|{
name|rx
operator|+=
name|QLatin1String
argument_list|(
literal|"\\?"
argument_list|)
expr_stmt|;
name|isEscaping
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|rx
operator|+=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'$'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'+'
case|:
case|case
literal|'.'
case|:
case|case
literal|'^'
case|:
case|case
literal|'{'
case|:
case|case
literal|'|'
case|:
case|case
literal|'}'
case|:
if|if
condition|(
name|isEscaping
condition|)
block|{
name|isEscaping
operator|=
literal|false
expr_stmt|;
name|rx
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
block|}
name|rx
operator|+=
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|rx
operator|+=
name|c
expr_stmt|;
break|break;
case|case
literal|'['
case|:
if|if
condition|(
name|isEscaping
condition|)
block|{
name|isEscaping
operator|=
literal|false
expr_stmt|;
name|rx
operator|+=
name|QLatin1String
argument_list|(
literal|"\\["
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rx
operator|+=
name|c
expr_stmt|;
if|if
condition|(
name|wc
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'^'
argument_list|)
condition|)
name|rx
operator|+=
name|wc
index|[
name|i
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|wclen
condition|)
block|{
if|if
condition|(
name|rx
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
condition|)
name|rx
operator|+=
name|wc
index|[
name|i
operator|++
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|wclen
operator|&&
name|wc
index|[
name|i
index|]
operator|!=
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
if|if
condition|(
name|wc
index|[
name|i
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
condition|)
name|rx
operator|+=
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|rx
operator|+=
name|wc
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|']'
case|:
if|if
condition|(
name|isEscaping
condition|)
block|{
name|isEscaping
operator|=
literal|false
expr_stmt|;
name|rx
operator|+=
name|QLatin1String
argument_list|(
literal|"\\"
argument_list|)
expr_stmt|;
block|}
name|rx
operator|+=
name|c
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isEscaping
condition|)
block|{
name|isEscaping
operator|=
literal|false
expr_stmt|;
name|rx
operator|+=
name|QLatin1String
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
block|}
name|rx
operator|+=
name|c
expr_stmt|;
block|}
block|}
return|return
name|rx
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|caretIndex
specifier|static
name|int
name|caretIndex
parameter_list|(
name|int
name|offset
parameter_list|,
name|QRegExp
operator|::
name|CaretMode
name|caretMode
parameter_list|)
block|{
if|if
condition|(
name|caretMode
operator|==
name|QRegExp
operator|::
name|CaretAtZero
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|caretMode
operator|==
name|QRegExp
operator|::
name|CaretAtOffset
condition|)
block|{
return|return
name|offset
return|;
block|}
else|else
block|{
comment|// QRegExp::CaretWontMatch
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function
begin_comment
comment|/*     The QRegExpEngineKey struct uniquely identifies an engine. */
end_comment
begin_struct
DECL|struct|QRegExpEngineKey
struct|struct
name|QRegExpEngineKey
block|{
DECL|member|pattern
name|QString
name|pattern
decl_stmt|;
DECL|member|patternSyntax
name|QRegExp
operator|::
name|PatternSyntax
name|patternSyntax
decl_stmt|;
DECL|member|cs
name|Qt
operator|::
name|CaseSensitivity
name|cs
decl_stmt|;
DECL|function|QRegExpEngineKey
specifier|inline
name|QRegExpEngineKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|,
name|QRegExp
operator|::
name|PatternSyntax
name|patternSyntax
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
member_init_list|:
name|pattern
argument_list|(
name|pattern
argument_list|)
member_init_list|,
name|patternSyntax
argument_list|(
name|patternSyntax
argument_list|)
member_init_list|,
name|cs
argument_list|(
name|cs
argument_list|)
block|{}
DECL|function|clear
specifier|inline
name|void
name|clear
parameter_list|()
block|{
name|pattern
operator|.
name|clear
argument_list|()
expr_stmt|;
name|patternSyntax
operator|=
name|QRegExp
operator|::
name|RegExp
expr_stmt|;
name|cs
operator|=
name|Qt
operator|::
name|CaseSensitive
expr_stmt|;
block|}
block|}
struct|;
end_struct
begin_function
DECL|function|operator ==
name|Q_STATIC_GLOBAL_OPERATOR
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QRegExpEngineKey
modifier|&
name|key1
parameter_list|,
specifier|const
name|QRegExpEngineKey
modifier|&
name|key2
parameter_list|)
block|{
return|return
name|key1
operator|.
name|pattern
operator|==
name|key2
operator|.
name|pattern
operator|&&
name|key1
operator|.
name|patternSyntax
operator|==
name|key2
operator|.
name|patternSyntax
operator|&&
name|key1
operator|.
name|cs
operator|==
name|key2
operator|.
name|cs
return|;
block|}
end_function
begin_class_decl
class_decl|class
name|QRegExpEngine
class_decl|;
end_class_decl
begin_comment
comment|//Q_DECLARE_TYPEINFO(QVector<int>, Q_MOVABLE_TYPE);
end_comment
begin_comment
comment|/*   This is the engine state during matching. */
end_comment
begin_struct
DECL|struct|QRegExpMatchState
struct|struct
name|QRegExpMatchState
block|{
DECL|member|in
specifier|const
name|QChar
modifier|*
name|in
decl_stmt|;
comment|// a pointer to the input string data
DECL|member|pos
name|int
name|pos
decl_stmt|;
comment|// the current position in the string
DECL|member|caretPos
name|int
name|caretPos
decl_stmt|;
DECL|member|len
name|int
name|len
decl_stmt|;
comment|// the length of the input string
DECL|member|minimal
name|bool
name|minimal
decl_stmt|;
comment|// minimal matching?
DECL|member|bigArray
name|int
modifier|*
name|bigArray
decl_stmt|;
comment|// big array holding the data for the next pointers
DECL|member|inNextStack
name|int
modifier|*
name|inNextStack
decl_stmt|;
comment|// is state is nextStack?
DECL|member|curStack
name|int
modifier|*
name|curStack
decl_stmt|;
comment|// stack of current states
DECL|member|nextStack
name|int
modifier|*
name|nextStack
decl_stmt|;
comment|// stack of next states
DECL|member|curCapBegin
name|int
modifier|*
name|curCapBegin
decl_stmt|;
comment|// start of current states' captures
DECL|member|nextCapBegin
name|int
modifier|*
name|nextCapBegin
decl_stmt|;
comment|// start of next states' captures
DECL|member|curCapEnd
name|int
modifier|*
name|curCapEnd
decl_stmt|;
comment|// end of current states' captures
DECL|member|nextCapEnd
name|int
modifier|*
name|nextCapEnd
decl_stmt|;
comment|// end of next states' captures
DECL|member|tempCapBegin
name|int
modifier|*
name|tempCapBegin
decl_stmt|;
comment|// start of temporary captures
DECL|member|tempCapEnd
name|int
modifier|*
name|tempCapEnd
decl_stmt|;
comment|// end of temporary captures
DECL|member|capBegin
name|int
modifier|*
name|capBegin
decl_stmt|;
comment|// start of captures for a next state
DECL|member|capEnd
name|int
modifier|*
name|capEnd
decl_stmt|;
comment|// end of captures for a next state
DECL|member|slideTab
name|int
modifier|*
name|slideTab
decl_stmt|;
comment|// bump-along slide table for bad-character heuristic
DECL|member|captured
name|int
modifier|*
name|captured
decl_stmt|;
comment|// what match() returned last
DECL|member|slideTabSize
name|int
name|slideTabSize
decl_stmt|;
comment|// size of slide table
DECL|member|capturedSize
name|int
name|capturedSize
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
DECL|member|sleeping
name|QList
argument_list|<
name|QVector
argument_list|<
name|int
argument_list|>
argument_list|>
name|sleeping
decl_stmt|;
comment|// list of back-reference sleepers
endif|#
directive|endif
DECL|member|matchLen
name|int
name|matchLen
decl_stmt|;
comment|// length of match
DECL|member|oneTestMatchedLen
name|int
name|oneTestMatchedLen
decl_stmt|;
comment|// length of partial match
DECL|member|eng
specifier|const
name|QRegExpEngine
modifier|*
name|eng
decl_stmt|;
DECL|function|QRegExpMatchState
specifier|inline
name|QRegExpMatchState
parameter_list|()
member_init_list|:
name|bigArray
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|captured
argument_list|(
literal|0
argument_list|)
block|{}
DECL|function|~QRegExpMatchState
specifier|inline
name|~
name|QRegExpMatchState
parameter_list|()
block|{
name|free
argument_list|(
name|bigArray
argument_list|)
expr_stmt|;
block|}
DECL|function|drain
name|void
name|drain
parameter_list|()
block|{
name|free
argument_list|(
name|bigArray
argument_list|)
expr_stmt|;
name|bigArray
operator|=
literal|0
expr_stmt|;
name|captured
operator|=
literal|0
expr_stmt|;
block|}
comment|// to save memory
name|void
name|prepareForMatch
parameter_list|(
name|QRegExpEngine
modifier|*
name|eng
parameter_list|)
function_decl|;
name|void
name|match
parameter_list|(
specifier|const
name|QChar
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|pos
parameter_list|,
name|bool
name|minimal
parameter_list|,
name|bool
name|oneTest
parameter_list|,
name|int
name|caretIndex
parameter_list|)
function_decl|;
name|bool
name|matchHere
parameter_list|()
function_decl|;
name|bool
name|testAnchor
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|a
parameter_list|,
specifier|const
name|int
modifier|*
name|capBegin
parameter_list|)
function_decl|;
block|}
struct|;
end_struct
begin_comment
comment|/*   The struct QRegExpAutomatonState represents one state in a modified NFA. The   input characters matched are stored in the state instead of on   the transitions, something possible for an automaton   constructed from a regular expression. */
end_comment
begin_struct
DECL|struct|QRegExpAutomatonState
struct|struct
name|QRegExpAutomatonState
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
DECL|member|atom
name|int
name|atom
decl_stmt|;
comment|// which atom does this state belong to?
endif|#
directive|endif
DECL|member|match
name|int
name|match
decl_stmt|;
comment|// what does it match? (see CharClassBit and BackRefBit)
DECL|member|outs
name|QVector
argument_list|<
name|int
argument_list|>
name|outs
decl_stmt|;
comment|// out-transitions
DECL|member|reenter
name|QMap
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|reenter
decl_stmt|;
comment|// atoms reentered when transiting out
DECL|member|anchors
name|QMap
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|anchors
decl_stmt|;
comment|// anchors met when transiting out
DECL|function|QRegExpAutomatonState
specifier|inline
name|QRegExpAutomatonState
parameter_list|()
block|{ }
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
DECL|function|QRegExpAutomatonState
specifier|inline
name|QRegExpAutomatonState
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|m
parameter_list|)
member_init_list|:
name|atom
argument_list|(
name|a
argument_list|)
member_init_list|,
name|match
argument_list|(
name|m
argument_list|)
block|{ }
else|#
directive|else
DECL|function|QRegExpAutomatonState
specifier|inline
name|QRegExpAutomatonState
parameter_list|(
name|int
name|m
parameter_list|)
member_init_list|:
name|match
argument_list|(
name|m
argument_list|)
block|{ }
endif|#
directive|endif
block|}
struct|;
end_struct
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|QRegExpAutomatonState
argument_list|,
name|Q_MOVABLE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/*   The struct QRegExpCharClassRange represents a range of characters (e.g.,   [0-9] denotes range 48 to 57). */
end_comment
begin_struct
DECL|struct|QRegExpCharClassRange
struct|struct
name|QRegExpCharClassRange
block|{
DECL|member|from
name|ushort
name|from
decl_stmt|;
comment|// 48
DECL|member|len
name|ushort
name|len
decl_stmt|;
comment|// 10
block|}
struct|;
end_struct
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|QRegExpCharClassRange
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
end_ifndef
begin_comment
comment|/*   The struct QRegExpAtom represents one node in the hierarchy of regular   expression atoms. */
end_comment
begin_struct
DECL|struct|QRegExpAtom
struct|struct
name|QRegExpAtom
block|{
DECL|enumerator|NoCapture
DECL|enumerator|OfficialCapture
DECL|enumerator|UnofficialCapture
enum|enum
block|{
name|NoCapture
init|=
operator|-
literal|1
block|,
name|OfficialCapture
init|=
operator|-
literal|2
block|,
name|UnofficialCapture
init|=
operator|-
literal|3
block|}
enum|;
DECL|member|parent
name|int
name|parent
decl_stmt|;
comment|// index of parent in array of atoms
DECL|member|capture
name|int
name|capture
decl_stmt|;
comment|// index of capture, from 1 to ncap - 1
block|}
struct|;
end_struct
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|QRegExpAtom
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_struct_decl
struct_decl|struct
name|QRegExpLookahead
struct_decl|;
end_struct_decl
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ANCHOR_ALT
end_ifndef
begin_comment
comment|/*   The struct QRegExpAnchorAlternation represents a pair of anchors with   OR semantics. */
end_comment
begin_struct
DECL|struct|QRegExpAnchorAlternation
struct|struct
name|QRegExpAnchorAlternation
block|{
DECL|member|a
name|int
name|a
decl_stmt|;
comment|// this anchor...
DECL|member|b
name|int
name|b
decl_stmt|;
comment|// ...or this one
block|}
struct|;
end_struct
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|QRegExpAnchorAlternation
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
end_ifndef
begin_define
DECL|macro|FLAG
define|#
directive|define
name|FLAG
parameter_list|(
name|x
parameter_list|)
value|(1<< (x))
end_define
begin_comment
comment|/*   The class QRegExpCharClass represents a set of characters, such as can   be found in regular expressions (e.g., [a-z] denotes the set   {a, b, ..., z}). */
end_comment
begin_class
DECL|class|QRegExpCharClass
class|class
name|QRegExpCharClass
block|{
public|public:
name|QRegExpCharClass
parameter_list|()
constructor_decl|;
DECL|function|QRegExpCharClass
specifier|inline
name|QRegExpCharClass
parameter_list|(
specifier|const
name|QRegExpCharClass
modifier|&
name|cc
parameter_list|)
block|{
name|operator
name|=
parameter_list|(
name|cc
parameter_list|)
function_decl|;
block|}
name|QRegExpCharClass
modifier|&
name|operator
name|=
parameter_list|(
specifier|const
name|QRegExpCharClass
modifier|&
name|cc
parameter_list|)
function_decl|;
name|void
name|clear
parameter_list|()
function_decl|;
DECL|function|negative
name|bool
name|negative
parameter_list|()
specifier|const
block|{
return|return
name|n
return|;
block|}
name|void
name|setNegative
parameter_list|(
name|bool
name|negative
parameter_list|)
function_decl|;
name|void
name|addCategories
parameter_list|(
name|uint
name|cats
parameter_list|)
function_decl|;
name|void
name|addRange
parameter_list|(
name|ushort
name|from
parameter_list|,
name|ushort
name|to
parameter_list|)
function_decl|;
DECL|function|addSingleton
name|void
name|addSingleton
parameter_list|(
name|ushort
name|ch
parameter_list|)
block|{
name|addRange
argument_list|(
name|ch
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
name|bool
name|in
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
function_decl|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
DECL|function|firstOccurrence
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|firstOccurrence
parameter_list|()
specifier|const
block|{
return|return
name|occ1
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
name|void
name|dump
parameter_list|()
specifier|const
function_decl|;
endif|#
directive|endif
private|private:
DECL|member|c
name|uint
name|c
decl_stmt|;
comment|// character classes
DECL|member|r
name|QVector
argument_list|<
name|QRegExpCharClassRange
argument_list|>
name|r
decl_stmt|;
comment|// character ranges
DECL|member|n
name|bool
name|n
decl_stmt|;
comment|// negative?
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
DECL|member|occ1
name|QVector
argument_list|<
name|int
argument_list|>
name|occ1
decl_stmt|;
comment|// first-occurrence array
endif|#
directive|endif
block|}
class|;
end_class
begin_else
else|#
directive|else
end_else
begin_struct
DECL|struct|QRegExpCharClass
struct|struct
name|QRegExpCharClass
block|{
DECL|member|dummy
name|int
name|dummy
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
DECL|function|QRegExpCharClass
name|QRegExpCharClass
parameter_list|()
block|{
name|occ1
operator|.
name|fill
argument_list|(
literal|0
argument_list|,
name|NumBadChars
argument_list|)
expr_stmt|;
block|}
DECL|function|firstOccurrence
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|firstOccurrence
parameter_list|()
specifier|const
block|{
return|return
name|occ1
return|;
block|}
DECL|member|occ1
name|QVector
argument_list|<
name|int
argument_list|>
name|occ1
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|QRegExpCharClass
argument_list|,
name|Q_MOVABLE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/*   The QRegExpEngine class encapsulates a modified nondeterministic   finite automaton (NFA). */
end_comment
begin_class
DECL|class|QRegExpEngine
class|class
name|QRegExpEngine
block|{
public|public:
DECL|function|QRegExpEngine
name|QRegExpEngine
parameter_list|(
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|,
name|bool
name|greedyQuantifiers
parameter_list|)
member_init_list|:
name|cs
argument_list|(
name|cs
argument_list|)
member_init_list|,
name|greedyQuantifiers
argument_list|(
name|greedyQuantifiers
argument_list|)
block|{
name|setup
argument_list|()
expr_stmt|;
block|}
name|QRegExpEngine
parameter_list|(
specifier|const
name|QRegExpEngineKey
modifier|&
name|key
parameter_list|)
constructor_decl|;
name|~
name|QRegExpEngine
parameter_list|()
destructor_decl|;
DECL|function|isValid
name|bool
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|valid
return|;
block|}
DECL|function|errorString
specifier|const
name|QString
modifier|&
name|errorString
parameter_list|()
specifier|const
block|{
return|return
name|yyError
return|;
block|}
DECL|function|captureCount
name|int
name|captureCount
parameter_list|()
specifier|const
block|{
return|return
name|officialncap
return|;
block|}
name|int
name|createState
parameter_list|(
name|QChar
name|ch
parameter_list|)
function_decl|;
name|int
name|createState
parameter_list|(
specifier|const
name|QRegExpCharClass
modifier|&
name|cc
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
name|int
name|createState
parameter_list|(
name|int
name|bref
parameter_list|)
function_decl|;
endif|#
directive|endif
name|void
name|addCatTransitions
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|from
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|to
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|void
name|addPlusTransitions
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|from
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|to
parameter_list|,
name|int
name|atom
parameter_list|)
function_decl|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ANCHOR_ALT
name|int
name|anchorAlternation
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
name|int
name|anchorConcatenation
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
else|#
directive|else
DECL|function|anchorAlternation
name|int
name|anchorAlternation
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|&
name|b
return|;
block|}
DECL|function|anchorConcatenation
name|int
name|anchorConcatenation
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator||
name|b
return|;
block|}
endif|#
directive|endif
name|void
name|addAnchors
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|a
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|void
name|heuristicallyChooseHeuristic
parameter_list|()
function_decl|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
name|void
name|dump
parameter_list|()
specifier|const
function_decl|;
endif|#
directive|endif
DECL|member|ref
name|QAtomicInt
name|ref
decl_stmt|;
private|private:
DECL|enumerator|CharClassBit
DECL|enumerator|BackRefBit
enum|enum
block|{
name|CharClassBit
init|=
literal|0x10000
block|,
name|BackRefBit
init|=
literal|0x20000
block|}
enum|;
DECL|enumerator|InitialState
DECL|enumerator|FinalState
enum|enum
block|{
name|InitialState
init|=
literal|0
block|,
name|FinalState
init|=
literal|1
block|}
enum|;
name|void
name|setup
parameter_list|()
function_decl|;
name|int
name|setupState
parameter_list|(
name|int
name|match
parameter_list|)
function_decl|;
comment|/*       Let's hope that 13 lookaheads and 14 back-references are       enough.      */
DECL|enumerator|MaxLookaheads
DECL|enumerator|MaxBackRefs
enum|enum
block|{
name|MaxLookaheads
init|=
literal|13
block|,
name|MaxBackRefs
init|=
literal|14
block|}
enum|;
DECL|enumerator|Anchor_Dollar
DECL|enumerator|Anchor_Caret
DECL|enumerator|Anchor_Word
enum|enum
block|{
name|Anchor_Dollar
init|=
literal|0x00000001
block|,
name|Anchor_Caret
init|=
literal|0x00000002
block|,
name|Anchor_Word
init|=
literal|0x00000004
block|,
DECL|enumerator|Anchor_NonWord
DECL|enumerator|Anchor_FirstLookahead
name|Anchor_NonWord
init|=
literal|0x00000008
block|,
name|Anchor_FirstLookahead
init|=
literal|0x00000010
block|,
DECL|enumerator|Anchor_BackRef1Empty
name|Anchor_BackRef1Empty
init|=
name|Anchor_FirstLookahead
operator|<<
name|MaxLookaheads
block|,
DECL|enumerator|Anchor_BackRef0Empty
name|Anchor_BackRef0Empty
init|=
name|Anchor_BackRef1Empty
operator|>>
literal|1
block|,
DECL|enumerator|Anchor_Alternation
name|Anchor_Alternation
init|=
name|unsigned
argument_list|(
name|Anchor_BackRef1Empty
argument_list|)
operator|<<
name|MaxBackRefs
block|,
DECL|enumerator|Anchor_LookaheadMask
name|Anchor_LookaheadMask
init|=
operator|(
name|Anchor_FirstLookahead
operator|-
literal|1
operator|)
operator|^
operator|(
operator|(
name|Anchor_FirstLookahead
operator|<<
name|MaxLookaheads
operator|)
operator|-
literal|1
operator|)
block|}
enum|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|int
name|startAtom
parameter_list|(
name|bool
name|officialCapture
parameter_list|)
function_decl|;
name|void
name|finishAtom
parameter_list|(
name|int
name|atom
parameter_list|,
name|bool
name|needCapture
parameter_list|)
function_decl|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_LOOKAHEAD
name|int
name|addLookahead
parameter_list|(
name|QRegExpEngine
modifier|*
name|eng
parameter_list|,
name|bool
name|negative
parameter_list|)
function_decl|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|bool
name|goodStringMatch
parameter_list|(
name|QRegExpMatchState
modifier|&
name|matchState
parameter_list|)
specifier|const
function_decl|;
name|bool
name|badCharMatch
parameter_list|(
name|QRegExpMatchState
modifier|&
name|matchState
parameter_list|)
specifier|const
function_decl|;
else|#
directive|else
name|bool
name|bruteMatch
parameter_list|(
name|QRegExpMatchState
modifier|&
name|matchState
parameter_list|)
specifier|const
function_decl|;
endif|#
directive|endif
DECL|member|s
name|QVector
argument_list|<
name|QRegExpAutomatonState
argument_list|>
name|s
decl_stmt|;
comment|// array of states
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
DECL|member|f
name|QVector
argument_list|<
name|QRegExpAtom
argument_list|>
name|f
decl_stmt|;
comment|// atom hierarchy
DECL|member|nf
name|int
name|nf
decl_stmt|;
comment|// number of atoms
DECL|member|cf
name|int
name|cf
decl_stmt|;
comment|// current atom
DECL|member|captureForOfficialCapture
name|QVector
argument_list|<
name|int
argument_list|>
name|captureForOfficialCapture
decl_stmt|;
endif|#
directive|endif
DECL|member|officialncap
name|int
name|officialncap
decl_stmt|;
comment|// number of captures, seen from the outside
DECL|member|ncap
name|int
name|ncap
decl_stmt|;
comment|// number of captures, seen from the inside
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
DECL|member|cl
name|QVector
argument_list|<
name|QRegExpCharClass
argument_list|>
name|cl
decl_stmt|;
comment|// array of character classes
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_LOOKAHEAD
DECL|member|ahead
name|QVector
argument_list|<
name|QRegExpLookahead
modifier|*
argument_list|>
name|ahead
decl_stmt|;
comment|// array of lookaheads
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ANCHOR_ALT
DECL|member|aa
name|QVector
argument_list|<
name|QRegExpAnchorAlternation
argument_list|>
name|aa
decl_stmt|;
comment|// array of (a, b) pairs of anchors
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
DECL|member|caretAnchored
name|bool
name|caretAnchored
decl_stmt|;
comment|// does the regexp start with ^?
DECL|member|trivial
name|bool
name|trivial
decl_stmt|;
comment|// is the good-string all that needs to match?
endif|#
directive|endif
DECL|member|valid
name|bool
name|valid
decl_stmt|;
comment|// is the regular expression valid?
DECL|member|cs
name|Qt
operator|::
name|CaseSensitivity
name|cs
decl_stmt|;
comment|// case sensitive?
DECL|member|greedyQuantifiers
name|bool
name|greedyQuantifiers
decl_stmt|;
comment|// RegExp2?
DECL|member|xmlSchemaExtensions
name|bool
name|xmlSchemaExtensions
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
DECL|member|nbrefs
name|int
name|nbrefs
decl_stmt|;
comment|// number of back-references
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
DECL|member|useGoodStringHeuristic
name|bool
name|useGoodStringHeuristic
decl_stmt|;
comment|// use goodStringMatch? otherwise badCharMatch
DECL|member|goodEarlyStart
name|int
name|goodEarlyStart
decl_stmt|;
comment|// the index where goodStr can first occur in a match
DECL|member|goodLateStart
name|int
name|goodLateStart
decl_stmt|;
comment|// the index where goodStr can last occur in a match
DECL|member|goodStr
name|QString
name|goodStr
decl_stmt|;
comment|// the string that any match has to contain
DECL|member|minl
name|int
name|minl
decl_stmt|;
comment|// the minimum length of a match
DECL|member|occ1
name|QVector
argument_list|<
name|int
argument_list|>
name|occ1
decl_stmt|;
comment|// first-occurrence array
endif|#
directive|endif
comment|/*       The class Box is an abstraction for a regular expression       fragment. It can also be seen as one node in the syntax tree of       a regular expression with synthetized attributes.        Its interface is ugly for performance reasons.     */
DECL|class|Box
class|class
name|Box
block|{
public|public:
name|Box
parameter_list|(
name|QRegExpEngine
modifier|*
name|engine
parameter_list|)
constructor_decl|;
DECL|function|Box
name|Box
parameter_list|(
specifier|const
name|Box
modifier|&
name|b
parameter_list|)
block|{
name|operator
name|=
parameter_list|(
name|b
parameter_list|)
function_decl|;
block|}
name|Box
modifier|&
name|operator
name|=
parameter_list|(
specifier|const
name|Box
modifier|&
name|b
parameter_list|)
function_decl|;
DECL|function|clear
name|void
name|clear
parameter_list|()
block|{
name|operator
name|=
argument_list|(
name|Box
argument_list|(
name|eng
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|set
parameter_list|(
name|QChar
name|ch
parameter_list|)
function_decl|;
name|void
name|set
parameter_list|(
specifier|const
name|QRegExpCharClass
modifier|&
name|cc
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
name|void
name|set
parameter_list|(
name|int
name|bref
parameter_list|)
function_decl|;
endif|#
directive|endif
name|void
name|cat
parameter_list|(
specifier|const
name|Box
modifier|&
name|b
parameter_list|)
function_decl|;
name|void
name|orx
parameter_list|(
specifier|const
name|Box
modifier|&
name|b
parameter_list|)
function_decl|;
name|void
name|plus
parameter_list|(
name|int
name|atom
parameter_list|)
function_decl|;
name|void
name|opt
parameter_list|()
function_decl|;
name|void
name|catAnchor
parameter_list|(
name|int
name|a
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|void
name|setupHeuristics
parameter_list|()
function_decl|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
name|void
name|dump
parameter_list|()
specifier|const
function_decl|;
endif|#
directive|endif
private|private:
name|void
name|addAnchorsToEngine
parameter_list|(
specifier|const
name|Box
modifier|&
name|to
parameter_list|)
specifier|const
function_decl|;
DECL|member|eng
name|QRegExpEngine
modifier|*
name|eng
decl_stmt|;
comment|// the automaton under construction
DECL|member|ls
name|QVector
argument_list|<
name|int
argument_list|>
name|ls
decl_stmt|;
comment|// the left states (firstpos)
DECL|member|rs
name|QVector
argument_list|<
name|int
argument_list|>
name|rs
decl_stmt|;
comment|// the right states (lastpos)
DECL|member|lanchors
name|QMap
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|lanchors
decl_stmt|;
comment|// the left anchors
DECL|member|ranchors
name|QMap
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
name|ranchors
decl_stmt|;
comment|// the right anchors
DECL|member|skipanchors
name|int
name|skipanchors
decl_stmt|;
comment|// the anchors to match if the box is skipped
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
DECL|member|earlyStart
name|int
name|earlyStart
decl_stmt|;
comment|// the index where str can first occur
DECL|member|lateStart
name|int
name|lateStart
decl_stmt|;
comment|// the index where str can last occur
DECL|member|str
name|QString
name|str
decl_stmt|;
comment|// a string that has to occur in any match
DECL|member|leftStr
name|QString
name|leftStr
decl_stmt|;
comment|// a string occurring at the left of this box
DECL|member|rightStr
name|QString
name|rightStr
decl_stmt|;
comment|// a string occurring at the right of this box
DECL|member|maxl
name|int
name|maxl
decl_stmt|;
comment|// the maximum length of this box (possibly InftyLen)
endif|#
directive|endif
DECL|member|minl
name|int
name|minl
decl_stmt|;
comment|// the minimum length of this box
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
DECL|member|occ1
name|QVector
argument_list|<
name|int
argument_list|>
name|occ1
decl_stmt|;
comment|// first-occurrence array
endif|#
directive|endif
block|}
class|;
friend|friend
class_decl|class
name|Box
class_decl|;
comment|/*       This is the lexical analyzer for regular expressions.     */
DECL|enumerator|Tok_Eos
DECL|enumerator|Tok_Dollar
DECL|enumerator|Tok_LeftParen
DECL|enumerator|Tok_MagicLeftParen
DECL|enumerator|Tok_PosLookahead
enum|enum
block|{
name|Tok_Eos
block|,
name|Tok_Dollar
block|,
name|Tok_LeftParen
block|,
name|Tok_MagicLeftParen
block|,
name|Tok_PosLookahead
block|,
DECL|enumerator|Tok_NegLookahead
DECL|enumerator|Tok_RightParen
DECL|enumerator|Tok_CharClass
DECL|enumerator|Tok_Caret
DECL|enumerator|Tok_Quantifier
DECL|enumerator|Tok_Bar
name|Tok_NegLookahead
block|,
name|Tok_RightParen
block|,
name|Tok_CharClass
block|,
name|Tok_Caret
block|,
name|Tok_Quantifier
block|,
name|Tok_Bar
block|,
DECL|enumerator|Tok_Word
DECL|enumerator|Tok_NonWord
DECL|enumerator|Tok_Char
DECL|enumerator|Tok_BackRef
name|Tok_Word
block|,
name|Tok_NonWord
block|,
name|Tok_Char
init|=
literal|0x10000
block|,
name|Tok_BackRef
init|=
literal|0x20000
block|}
enum|;
name|int
name|getChar
parameter_list|()
function_decl|;
name|int
name|getEscape
parameter_list|()
function_decl|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_INTERVAL
name|int
name|getRep
parameter_list|(
name|int
name|def
parameter_list|)
function_decl|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_LOOKAHEAD
name|void
name|skipChars
parameter_list|(
name|int
name|n
parameter_list|)
function_decl|;
endif|#
directive|endif
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
name|void
name|startTokenizer
parameter_list|(
specifier|const
name|QChar
modifier|*
name|rx
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|int
name|getToken
parameter_list|()
function_decl|;
DECL|member|yyIn
specifier|const
name|QChar
modifier|*
name|yyIn
decl_stmt|;
comment|// a pointer to the input regular expression pattern
DECL|member|yyPos0
name|int
name|yyPos0
decl_stmt|;
comment|// the position of yyTok in the input pattern
DECL|member|yyPos
name|int
name|yyPos
decl_stmt|;
comment|// the position of the next character to read
DECL|member|yyLen
name|int
name|yyLen
decl_stmt|;
comment|// the length of yyIn
DECL|member|yyCh
name|int
name|yyCh
decl_stmt|;
comment|// the last character read
DECL|member|yyCharClass
name|QScopedPointer
argument_list|<
name|QRegExpCharClass
argument_list|>
name|yyCharClass
decl_stmt|;
comment|// attribute for Tok_CharClass tokens
DECL|member|yyMinRep
name|int
name|yyMinRep
decl_stmt|;
comment|// attribute for Tok_Quantifier
DECL|member|yyMaxRep
name|int
name|yyMaxRep
decl_stmt|;
comment|// ditto
DECL|member|yyError
name|QString
name|yyError
decl_stmt|;
comment|// syntax error or overflow during parsing?
comment|/*       This is the syntactic analyzer for regular expressions.     */
name|int
name|parse
parameter_list|(
specifier|const
name|QChar
modifier|*
name|rx
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|void
name|parseAtom
parameter_list|(
name|Box
modifier|*
name|box
parameter_list|)
function_decl|;
name|void
name|parseFactor
parameter_list|(
name|Box
modifier|*
name|box
parameter_list|)
function_decl|;
name|void
name|parseTerm
parameter_list|(
name|Box
modifier|*
name|box
parameter_list|)
function_decl|;
name|void
name|parseExpression
parameter_list|(
name|Box
modifier|*
name|box
parameter_list|)
function_decl|;
DECL|member|yyTok
name|int
name|yyTok
decl_stmt|;
comment|// the last token read
DECL|member|yyMayCapture
name|bool
name|yyMayCapture
decl_stmt|;
comment|// set this to false to disable capturing
friend|friend
struct_decl|struct
name|QRegExpMatchState
struct_decl|;
block|}
class|;
end_class
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_LOOKAHEAD
end_ifndef
begin_comment
comment|/*   The struct QRegExpLookahead represents a lookahead a la Perl (e.g.,   (?=foo) and (?!bar)). */
end_comment
begin_struct
DECL|struct|QRegExpLookahead
struct|struct
name|QRegExpLookahead
block|{
DECL|member|eng
name|QRegExpEngine
modifier|*
name|eng
decl_stmt|;
comment|// NFA representing the embedded regular expression
DECL|member|neg
name|bool
name|neg
decl_stmt|;
comment|// negative lookahead?
DECL|function|QRegExpLookahead
specifier|inline
name|QRegExpLookahead
parameter_list|(
name|QRegExpEngine
modifier|*
name|eng0
parameter_list|,
name|bool
name|neg0
parameter_list|)
member_init_list|:
name|eng
argument_list|(
name|eng0
argument_list|)
member_init_list|,
name|neg
argument_list|(
name|neg0
argument_list|)
block|{ }
DECL|function|~QRegExpLookahead
specifier|inline
name|~
name|QRegExpLookahead
parameter_list|()
block|{
operator|delete
name|eng
expr_stmt|;
block|}
block|}
struct|;
end_struct
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \internal     convert the pattern string to the RegExp syntax.      This is also used by QScriptEngine::newRegExp to convert to a pattern that JavaScriptCore can understan  */
end_comment
begin_function
DECL|function|qt_regexp_toCanonical
name|Q_CORE_EXPORT
name|QString
name|qt_regexp_toCanonical
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|,
name|QRegExp
operator|::
name|PatternSyntax
name|patternSyntax
parameter_list|)
block|{
switch|switch
condition|(
name|patternSyntax
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_WILDCARD
case|case
name|QRegExp
operator|::
name|Wildcard
case|:
return|return
name|wc2rx
argument_list|(
name|pattern
argument_list|,
literal|false
argument_list|)
return|;
break|break;
case|case
name|QRegExp
operator|::
name|WildcardUnix
case|:
return|return
name|wc2rx
argument_list|(
name|pattern
argument_list|,
literal|true
argument_list|)
return|;
break|break;
endif|#
directive|endif
case|case
name|QRegExp
operator|::
name|FixedString
case|:
return|return
name|QRegExp
operator|::
name|escape
argument_list|(
name|pattern
argument_list|)
return|;
break|break;
case|case
name|QRegExp
operator|::
name|W3CXmlSchema11
case|:
default|default:
return|return
name|pattern
return|;
block|}
block|}
end_function
begin_constructor
DECL|function|QRegExpEngine
name|QRegExpEngine
operator|::
name|QRegExpEngine
parameter_list|(
specifier|const
name|QRegExpEngineKey
modifier|&
name|key
parameter_list|)
member_init_list|:
name|cs
argument_list|(
name|key
operator|.
name|cs
argument_list|)
member_init_list|,
name|greedyQuantifiers
argument_list|(
name|key
operator|.
name|patternSyntax
operator|==
name|QRegExp
operator|::
name|RegExp2
argument_list|)
member_init_list|,
name|xmlSchemaExtensions
argument_list|(
name|key
operator|.
name|patternSyntax
operator|==
name|QRegExp
operator|::
name|W3CXmlSchema11
argument_list|)
block|{
name|setup
argument_list|()
expr_stmt|;
name|QString
name|rx
init|=
name|qt_regexp_toCanonical
argument_list|(
name|key
operator|.
name|pattern
argument_list|,
name|key
operator|.
name|patternSyntax
argument_list|)
decl_stmt|;
name|valid
operator|=
operator|(
name|parse
argument_list|(
name|rx
operator|.
name|unicode
argument_list|()
argument_list|,
name|rx
operator|.
name|length
argument_list|()
argument_list|)
operator|==
name|rx
operator|.
name|length
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|trivial
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
name|error
argument_list|(
name|RXERR_LEFTDELIM
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~QRegExpEngine
name|QRegExpEngine
operator|::
name|~
name|QRegExpEngine
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_LOOKAHEAD
name|qDeleteAll
argument_list|(
name|ahead
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_function
DECL|function|prepareForMatch
name|void
name|QRegExpMatchState
operator|::
name|prepareForMatch
parameter_list|(
name|QRegExpEngine
modifier|*
name|eng
parameter_list|)
block|{
comment|/*       We use one QVector<int> for all the big data used a lot in       matchHere() and friends.     */
name|int
name|ns
init|=
name|eng
operator|->
name|s
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// number of states
name|int
name|ncap
init|=
name|eng
operator|->
name|ncap
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|int
name|newSlideTabSize
init|=
name|qMax
argument_list|(
name|eng
operator|->
name|minl
operator|+
literal|1
argument_list|,
literal|16
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|newSlideTabSize
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|numCaptures
init|=
name|eng
operator|->
name|captureCount
argument_list|()
decl_stmt|;
name|int
name|newCapturedSize
init|=
literal|2
operator|+
literal|2
operator|*
name|numCaptures
decl_stmt|;
name|bigArray
operator|=
name|q_check_ptr
argument_list|(
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|bigArray
argument_list|,
operator|(
operator|(
literal|3
operator|+
literal|4
operator|*
name|ncap
operator|)
operator|*
name|ns
operator|+
literal|4
operator|*
name|ncap
operator|+
name|newSlideTabSize
operator|+
name|newCapturedSize
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// set all internal variables only _after_ bigArray is realloc'ed
comment|// to prevent a broken regexp in oom case
name|slideTabSize
operator|=
name|newSlideTabSize
expr_stmt|;
name|capturedSize
operator|=
name|newCapturedSize
expr_stmt|;
name|inNextStack
operator|=
name|bigArray
expr_stmt|;
name|memset
argument_list|(
name|inNextStack
argument_list|,
operator|-
literal|1
argument_list|,
name|ns
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|curStack
operator|=
name|inNextStack
operator|+
name|ns
expr_stmt|;
name|nextStack
operator|=
name|inNextStack
operator|+
literal|2
operator|*
name|ns
expr_stmt|;
name|curCapBegin
operator|=
name|inNextStack
operator|+
literal|3
operator|*
name|ns
expr_stmt|;
name|nextCapBegin
operator|=
name|curCapBegin
operator|+
name|ncap
operator|*
name|ns
expr_stmt|;
name|curCapEnd
operator|=
name|curCapBegin
operator|+
literal|2
operator|*
name|ncap
operator|*
name|ns
expr_stmt|;
name|nextCapEnd
operator|=
name|curCapBegin
operator|+
literal|3
operator|*
name|ncap
operator|*
name|ns
expr_stmt|;
name|tempCapBegin
operator|=
name|curCapBegin
operator|+
literal|4
operator|*
name|ncap
operator|*
name|ns
expr_stmt|;
name|tempCapEnd
operator|=
name|tempCapBegin
operator|+
name|ncap
expr_stmt|;
name|capBegin
operator|=
name|tempCapBegin
operator|+
literal|2
operator|*
name|ncap
expr_stmt|;
name|capEnd
operator|=
name|tempCapBegin
operator|+
literal|3
operator|*
name|ncap
expr_stmt|;
name|slideTab
operator|=
name|tempCapBegin
operator|+
literal|4
operator|*
name|ncap
expr_stmt|;
name|captured
operator|=
name|slideTab
operator|+
name|slideTabSize
expr_stmt|;
name|memset
argument_list|(
name|captured
argument_list|,
operator|-
literal|1
argument_list|,
name|capturedSize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|eng
operator|=
name|eng
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   Tries to match in str and returns an array of (begin, length) pairs   for captured text. If there is no match, all pairs are (-1, -1). */
end_comment
begin_function
DECL|function|match
name|void
name|QRegExpMatchState
operator|::
name|match
parameter_list|(
specifier|const
name|QChar
modifier|*
name|str0
parameter_list|,
name|int
name|len0
parameter_list|,
name|int
name|pos0
parameter_list|,
name|bool
name|minimal0
parameter_list|,
name|bool
name|oneTest
parameter_list|,
name|int
name|caretIndex
parameter_list|)
block|{
name|bool
name|matched
init|=
literal|false
decl_stmt|;
name|QChar
name|char_null
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
if|if
condition|(
name|eng
operator|->
name|trivial
operator|&&
operator|!
name|oneTest
condition|)
block|{
name|pos
operator|=
name|qFindString
argument_list|(
name|str0
argument_list|,
name|len0
argument_list|,
name|pos0
argument_list|,
name|eng
operator|->
name|goodStr
operator|.
name|unicode
argument_list|()
argument_list|,
name|eng
operator|->
name|goodStr
operator|.
name|length
argument_list|()
argument_list|,
name|eng
operator|->
name|cs
argument_list|)
expr_stmt|;
name|matchLen
operator|=
name|eng
operator|->
name|goodStr
operator|.
name|length
argument_list|()
expr_stmt|;
name|matched
operator|=
operator|(
name|pos
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|in
operator|=
name|str0
expr_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
name|in
operator|=
operator|&
name|char_null
expr_stmt|;
name|pos
operator|=
name|pos0
expr_stmt|;
name|caretPos
operator|=
name|caretIndex
expr_stmt|;
name|len
operator|=
name|len0
expr_stmt|;
name|minimal
operator|=
name|minimal0
expr_stmt|;
name|matchLen
operator|=
literal|0
expr_stmt|;
name|oneTestMatchedLen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eng
operator|->
name|valid
operator|&&
name|pos
operator|>=
literal|0
operator|&&
name|pos
operator|<=
name|len
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
if|if
condition|(
name|oneTest
condition|)
block|{
name|matched
operator|=
name|matchHere
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pos
operator|<=
name|len
operator|-
name|eng
operator|->
name|minl
condition|)
block|{
if|if
condition|(
name|eng
operator|->
name|caretAnchored
condition|)
block|{
name|matched
operator|=
name|matchHere
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eng
operator|->
name|useGoodStringHeuristic
condition|)
block|{
name|matched
operator|=
name|eng
operator|->
name|goodStringMatch
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|matched
operator|=
name|eng
operator|->
name|badCharMatch
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
name|matched
operator|=
name|oneTest
condition|?
name|matchHere
argument_list|()
else|:
name|eng
operator|->
name|bruteMatch
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|matched
condition|)
block|{
name|int
modifier|*
name|c
init|=
name|captured
decl_stmt|;
operator|*
name|c
operator|++
operator|=
name|pos
expr_stmt|;
operator|*
name|c
operator|++
operator|=
name|matchLen
expr_stmt|;
name|int
name|numCaptures
init|=
operator|(
name|capturedSize
operator|-
literal|2
operator|)
operator|>>
literal|1
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCaptures
condition|;
operator|++
name|i
control|)
block|{
name|int
name|j
init|=
name|eng
operator|->
name|captureForOfficialCapture
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|capBegin
index|[
name|j
index|]
operator|!=
name|EmptyCapture
condition|)
block|{
name|int
name|len
init|=
name|capEnd
index|[
name|j
index|]
operator|-
name|capBegin
index|[
name|j
index|]
decl_stmt|;
operator|*
name|c
operator|++
operator|=
operator|(
name|len
operator|>
literal|0
operator|)
condition|?
name|pos
operator|+
name|capBegin
index|[
name|j
index|]
else|:
literal|0
expr_stmt|;
operator|*
name|c
operator|++
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
operator|*
name|c
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|c
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|// we rely on 2's complement here
name|memset
argument_list|(
name|captured
argument_list|,
operator|-
literal|1
argument_list|,
name|capturedSize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*   The three following functions add one state to the automaton and   return the number of the state. */
end_comment
begin_function
DECL|function|createState
name|int
name|QRegExpEngine
operator|::
name|createState
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
return|return
name|setupState
argument_list|(
name|ch
operator|.
name|unicode
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|createState
name|int
name|QRegExpEngine
operator|::
name|createState
parameter_list|(
specifier|const
name|QRegExpCharClass
modifier|&
name|cc
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
name|int
name|n
init|=
name|cl
operator|.
name|size
argument_list|()
decl_stmt|;
name|cl
operator|+=
name|QRegExpCharClass
argument_list|(
name|cc
argument_list|)
expr_stmt|;
return|return
name|setupState
argument_list|(
name|CharClassBit
operator||
name|n
argument_list|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|cc
argument_list|)
expr_stmt|;
return|return
name|setupState
argument_list|(
name|CharClassBit
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
end_ifndef
begin_function
DECL|function|createState
name|int
name|QRegExpEngine
operator|::
name|createState
parameter_list|(
name|int
name|bref
parameter_list|)
block|{
if|if
condition|(
name|bref
operator|>
name|nbrefs
condition|)
block|{
name|nbrefs
operator|=
name|bref
expr_stmt|;
if|if
condition|(
name|nbrefs
operator|>
name|MaxBackRefs
condition|)
block|{
name|error
argument_list|(
name|RXERR_LIMIT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|setupState
argument_list|(
name|BackRefBit
operator||
name|bref
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*   The two following functions add a transition between all pairs of   states (i, j) where i is found in from, and j is found in to.    Cat-transitions are distinguished from plus-transitions for   capturing. */
end_comment
begin_function
DECL|function|addCatTransitions
name|void
name|QRegExpEngine
operator|::
name|addCatTransitions
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|from
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|to
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|from
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
name|mergeInto
argument_list|(
operator|&
name|s
index|[
name|from
operator|.
name|at
argument_list|(
name|i
argument_list|)
index|]
operator|.
name|outs
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
end_ifndef
begin_function
DECL|function|addPlusTransitions
name|void
name|QRegExpEngine
operator|::
name|addPlusTransitions
parameter_list|(
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|from
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|to
parameter_list|,
name|int
name|atom
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|from
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QRegExpAutomatonState
modifier|&
name|st
init|=
name|s
index|[
name|from
operator|.
name|at
argument_list|(
name|i
argument_list|)
index|]
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
name|oldOuts
init|=
name|st
operator|.
name|outs
decl_stmt|;
name|mergeInto
argument_list|(
operator|&
name|st
operator|.
name|outs
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|at
argument_list|(
name|atom
argument_list|)
operator|.
name|capture
operator|!=
name|QRegExpAtom
operator|::
name|NoCapture
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|to
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
comment|// ### st.reenter.contains(to.at(j)) check looks suspicious
if|if
condition|(
operator|!
name|st
operator|.
name|reenter
operator|.
name|contains
argument_list|(
name|to
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
operator|&&
name|qBinaryFind
argument_list|(
name|oldOuts
operator|.
name|constBegin
argument_list|()
argument_list|,
name|oldOuts
operator|.
name|constEnd
argument_list|()
argument_list|,
name|to
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
operator|==
name|oldOuts
operator|.
name|end
argument_list|()
condition|)
name|st
operator|.
name|reenter
operator|.
name|insert
argument_list|(
name|to
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|,
name|atom
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ANCHOR_ALT
end_ifndef
begin_comment
comment|/*   Returns an anchor that means a OR b. */
end_comment
begin_function
DECL|function|anchorAlternation
name|int
name|QRegExpEngine
operator|::
name|anchorAlternation
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|a
operator|&
name|b
operator|)
operator|==
name|a
operator|||
operator|(
name|a
operator|&
name|b
operator|)
operator|==
name|b
operator|)
operator|&&
operator|(
operator|(
name|a
operator||
name|b
operator|)
operator|&
name|Anchor_Alternation
operator|)
operator|==
literal|0
condition|)
return|return
name|a
operator|&
name|b
return|;
name|int
name|n
init|=
name|aa
operator|.
name|size
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|aa
operator|.
name|at
argument_list|(
name|n
operator|-
literal|1
argument_list|)
operator|.
name|a
operator|==
name|a
operator|&&
name|aa
operator|.
name|at
argument_list|(
name|n
operator|-
literal|1
argument_list|)
operator|.
name|b
operator|==
name|b
condition|)
return|return
name|Anchor_Alternation
operator||
operator|(
name|n
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
name|QRegExpAnchorAlternation
name|element
init|=
block|{
name|a
block|,
name|b
block|}
decl_stmt|;
name|aa
operator|.
name|append
argument_list|(
name|element
argument_list|)
expr_stmt|;
return|return
name|Anchor_Alternation
operator||
name|n
return|;
block|}
end_function
begin_comment
comment|/*   Returns an anchor that means a AND b. */
end_comment
begin_function
DECL|function|anchorConcatenation
name|int
name|QRegExpEngine
operator|::
name|anchorConcatenation
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|a
operator||
name|b
operator|)
operator|&
name|Anchor_Alternation
operator|)
operator|==
literal|0
condition|)
return|return
name|a
operator||
name|b
return|;
if|if
condition|(
operator|(
name|b
operator|&
name|Anchor_Alternation
operator|)
operator|!=
literal|0
condition|)
name|qSwap
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|int
name|aprime
init|=
name|anchorConcatenation
argument_list|(
name|aa
operator|.
name|at
argument_list|(
name|a
operator|^
name|Anchor_Alternation
argument_list|)
operator|.
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|int
name|bprime
init|=
name|anchorConcatenation
argument_list|(
name|aa
operator|.
name|at
argument_list|(
name|a
operator|^
name|Anchor_Alternation
argument_list|)
operator|.
name|b
argument_list|,
name|b
argument_list|)
decl_stmt|;
return|return
name|anchorAlternation
argument_list|(
name|aprime
argument_list|,
name|bprime
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*   Adds anchor a on a transition caracterised by its from state and   its to state. */
end_comment
begin_function
DECL|function|addAnchors
name|void
name|QRegExpEngine
operator|::
name|addAnchors
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|,
name|int
name|a
parameter_list|)
block|{
name|QRegExpAutomatonState
modifier|&
name|st
init|=
name|s
index|[
name|from
index|]
decl_stmt|;
if|if
condition|(
name|st
operator|.
name|anchors
operator|.
name|contains
argument_list|(
name|to
argument_list|)
condition|)
name|a
operator|=
name|anchorAlternation
argument_list|(
name|st
operator|.
name|anchors
operator|.
name|value
argument_list|(
name|to
argument_list|)
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|st
operator|.
name|anchors
operator|.
name|insert
argument_list|(
name|to
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
end_ifndef
begin_comment
comment|/*   This function chooses between the good-string and the bad-character   heuristics. It computes two scores and chooses the heuristic with   the highest score.    Here are some common-sense constraints on the scores that should be   respected if the formulas are ever modified: (1) If goodStr is   empty, the good-string heuristic scores 0. (2) If the regular   expression is trivial, the good-string heuristic should be used.   (3) If the search is case insensitive, the good-string heuristic   should be used, unless it scores 0. (Case insensitivity turns all   entries of occ1 to 0.) (4) If (goodLateStart - goodEarlyStart) is   big, the good-string heuristic should score less. */
end_comment
begin_function
DECL|function|heuristicallyChooseHeuristic
name|void
name|QRegExpEngine
operator|::
name|heuristicallyChooseHeuristic
parameter_list|()
block|{
if|if
condition|(
name|minl
operator|==
literal|0
condition|)
block|{
name|useGoodStringHeuristic
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trivial
condition|)
block|{
name|useGoodStringHeuristic
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|/*           Magic formula: The good string has to constitute a good           proportion of the minimum-length string, and appear at a           more-or-less known index.         */
name|int
name|goodStringScore
init|=
operator|(
literal|64
operator|*
name|goodStr
operator|.
name|length
argument_list|()
operator|/
name|minl
operator|)
operator|-
operator|(
name|goodLateStart
operator|-
name|goodEarlyStart
operator|)
decl_stmt|;
comment|/*           Less magic formula: We pick some characters at random, and           check whether they are good or bad.         */
name|int
name|badCharScore
init|=
literal|0
decl_stmt|;
name|int
name|step
init|=
name|qMax
argument_list|(
literal|1
argument_list|,
name|NumBadChars
operator|/
literal|32
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|NumBadChars
condition|;
name|i
operator|+=
name|step
control|)
block|{
if|if
condition|(
name|occ1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|NoOccurrence
condition|)
name|badCharScore
operator|+=
name|minl
expr_stmt|;
else|else
name|badCharScore
operator|+=
name|occ1
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|badCharScore
operator|/=
name|minl
expr_stmt|;
name|useGoodStringHeuristic
operator|=
operator|(
name|goodStringScore
operator|>
name|badCharScore
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
end_if
begin_function
DECL|function|dump
name|void
name|QRegExpEngine
operator|::
name|dump
parameter_list|()
specifier|const
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|qDebug
argument_list|(
literal|"Case %ssensitive engine"
argument_list|,
name|cs
condition|?
literal|""
else|:
literal|"in"
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  States"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|qDebug
argument_list|(
literal|"  %d%s"
argument_list|,
name|i
argument_list|,
name|i
operator|==
name|InitialState
condition|?
literal|" (initial)"
else|:
name|i
operator|==
name|FinalState
condition|?
literal|" (final)"
else|:
literal|""
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
if|if
condition|(
name|nf
operator|>
literal|0
condition|)
name|qDebug
argument_list|(
literal|"    in atom %d"
argument_list|,
name|s
index|[
name|i
index|]
operator|.
name|atom
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|m
init|=
name|s
index|[
name|i
index|]
operator|.
name|match
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|&
name|CharClassBit
operator|)
operator|!=
literal|0
condition|)
block|{
name|qDebug
argument_list|(
literal|"    match character class %d"
argument_list|,
name|m
operator|^
name|CharClassBit
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
name|cl
index|[
name|m
operator|^
name|CharClassBit
index|]
operator|.
name|dump
argument_list|()
expr_stmt|;
else|#
directive|else
name|qDebug
argument_list|(
literal|"    negative character class"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|m
operator|&
name|BackRefBit
operator|)
operator|!=
literal|0
condition|)
block|{
name|qDebug
argument_list|(
literal|"    match back-reference %d"
argument_list|,
name|m
operator|^
name|BackRefBit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|>=
literal|0x20
operator|&&
name|m
operator|<=
literal|0x7e
condition|)
block|{
name|qDebug
argument_list|(
literal|"    match 0x%.4x (%c)"
argument_list|,
name|m
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qDebug
argument_list|(
literal|"    match 0x%.4x"
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
index|[
name|i
index|]
operator|.
name|outs
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|int
name|next
init|=
name|s
index|[
name|i
index|]
operator|.
name|outs
index|[
name|j
index|]
decl_stmt|;
name|qDebug
argument_list|(
literal|"    -> %d"
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|i
index|]
operator|.
name|reenter
operator|.
name|contains
argument_list|(
name|next
argument_list|)
condition|)
name|qDebug
argument_list|(
literal|"       [reenter %d]"
argument_list|,
name|s
index|[
name|i
index|]
operator|.
name|reenter
index|[
name|next
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|i
index|]
operator|.
name|anchors
operator|.
name|value
argument_list|(
name|next
argument_list|)
operator|!=
literal|0
condition|)
name|qDebug
argument_list|(
literal|"       [anchors 0x%.8x]"
argument_list|,
name|s
index|[
name|i
index|]
operator|.
name|anchors
index|[
name|next
index|]
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
if|if
condition|(
name|nf
operator|>
literal|0
condition|)
block|{
name|qDebug
argument_list|(
literal|"  Atom    Parent  Capture"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nf
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|f
index|[
name|i
index|]
operator|.
name|capture
operator|==
name|QRegExpAtom
operator|::
name|NoCapture
condition|)
block|{
name|qDebug
argument_list|(
literal|"  %6d  %6d     nil"
argument_list|,
name|i
argument_list|,
name|f
index|[
name|i
index|]
operator|.
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|cap
init|=
name|f
index|[
name|i
index|]
operator|.
name|capture
decl_stmt|;
name|bool
name|official
init|=
name|captureForOfficialCapture
operator|.
name|contains
argument_list|(
name|cap
argument_list|)
decl_stmt|;
name|qDebug
argument_list|(
literal|"  %6d  %6d  %6d  %s"
argument_list|,
name|i
argument_list|,
name|f
index|[
name|i
index|]
operator|.
name|parent
argument_list|,
name|f
index|[
name|i
index|]
operator|.
name|capture
argument_list|,
name|official
condition|?
literal|"official"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ANCHOR_ALT
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aa
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
name|qDebug
argument_list|(
literal|"  Anchor alternation 0x%.8x: 0x%.8x 0x%.9x"
argument_list|,
name|i
argument_list|,
name|aa
index|[
name|i
index|]
operator|.
name|a
argument_list|,
name|aa
index|[
name|i
index|]
operator|.
name|b
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|setup
name|void
name|QRegExpEngine
operator|::
name|setup
parameter_list|()
block|{
name|ref
operator|.
name|store
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|f
operator|.
name|resize
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|nf
operator|=
literal|0
expr_stmt|;
name|cf
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|officialncap
operator|=
literal|0
expr_stmt|;
name|ncap
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|caretAnchored
operator|=
literal|true
expr_stmt|;
name|trivial
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
name|valid
operator|=
literal|false
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
name|nbrefs
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|useGoodStringHeuristic
operator|=
literal|true
expr_stmt|;
name|minl
operator|=
literal|0
expr_stmt|;
name|occ1
operator|.
name|fill
argument_list|(
literal|0
argument_list|,
name|NumBadChars
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|setupState
name|int
name|QRegExpEngine
operator|::
name|setupState
parameter_list|(
name|int
name|match
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|s
operator|+=
name|QRegExpAutomatonState
argument_list|(
name|cf
argument_list|,
name|match
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|+=
name|QRegExpAutomatonState
argument_list|(
name|match
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|s
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
end_ifndef
begin_comment
comment|/*   Functions startAtom() and finishAtom() should be called to delimit   atoms. When a state is created, it is assigned to the current atom.   The information is later used for capturing. */
end_comment
begin_function
DECL|function|startAtom
name|int
name|QRegExpEngine
operator|::
name|startAtom
parameter_list|(
name|bool
name|officialCapture
parameter_list|)
block|{
if|if
condition|(
operator|(
name|nf
operator|&
operator|(
name|nf
operator|+
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
name|nf
operator|+
literal|1
operator|>=
name|f
operator|.
name|size
argument_list|()
condition|)
name|f
operator|.
name|resize
argument_list|(
operator|(
name|nf
operator|+
literal|1
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|f
index|[
name|nf
index|]
operator|.
name|parent
operator|=
name|cf
expr_stmt|;
name|cf
operator|=
name|nf
operator|++
expr_stmt|;
name|f
index|[
name|cf
index|]
operator|.
name|capture
operator|=
name|officialCapture
condition|?
name|QRegExpAtom
operator|::
name|OfficialCapture
else|:
name|QRegExpAtom
operator|::
name|NoCapture
expr_stmt|;
return|return
name|cf
return|;
block|}
end_function
begin_function
DECL|function|finishAtom
name|void
name|QRegExpEngine
operator|::
name|finishAtom
parameter_list|(
name|int
name|atom
parameter_list|,
name|bool
name|needCapture
parameter_list|)
block|{
if|if
condition|(
name|greedyQuantifiers
operator|&&
name|needCapture
operator|&&
name|f
index|[
name|atom
index|]
operator|.
name|capture
operator|==
name|QRegExpAtom
operator|::
name|NoCapture
condition|)
name|f
index|[
name|atom
index|]
operator|.
name|capture
operator|=
name|QRegExpAtom
operator|::
name|UnofficialCapture
expr_stmt|;
name|cf
operator|=
name|f
operator|.
name|at
argument_list|(
name|atom
argument_list|)
operator|.
name|parent
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_LOOKAHEAD
end_ifndef
begin_comment
comment|/*   Creates a lookahead anchor. */
end_comment
begin_function
DECL|function|addLookahead
name|int
name|QRegExpEngine
operator|::
name|addLookahead
parameter_list|(
name|QRegExpEngine
modifier|*
name|eng
parameter_list|,
name|bool
name|negative
parameter_list|)
block|{
name|int
name|n
init|=
name|ahead
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|MaxLookaheads
condition|)
block|{
name|error
argument_list|(
name|RXERR_LIMIT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ahead
operator|+=
operator|new
name|QRegExpLookahead
argument_list|(
name|eng
argument_list|,
name|negative
argument_list|)
expr_stmt|;
return|return
name|Anchor_FirstLookahead
operator|<<
name|n
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
end_ifndef
begin_comment
comment|/*   We want the longest leftmost captures. */
end_comment
begin_function
DECL|function|isBetterCapture
specifier|static
name|bool
name|isBetterCapture
parameter_list|(
name|int
name|ncap
parameter_list|,
specifier|const
name|int
modifier|*
name|begin1
parameter_list|,
specifier|const
name|int
modifier|*
name|end1
parameter_list|,
specifier|const
name|int
modifier|*
name|begin2
parameter_list|,
specifier|const
name|int
modifier|*
name|end2
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncap
condition|;
name|i
operator|++
control|)
block|{
name|int
name|delta
init|=
name|begin2
index|[
name|i
index|]
operator|-
name|begin1
index|[
name|i
index|]
decl_stmt|;
comment|// it has to start early...
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|delta
operator|=
name|end1
index|[
name|i
index|]
operator|-
name|end2
index|[
name|i
index|]
expr_stmt|;
comment|// ...and end late
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
return|return
name|delta
operator|>
literal|0
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*   Returns true if anchor a matches at position pos + i in the input   string, otherwise false. */
end_comment
begin_function
DECL|function|testAnchor
name|bool
name|QRegExpMatchState
operator|::
name|testAnchor
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|a
parameter_list|,
specifier|const
name|int
modifier|*
name|capBegin
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ANCHOR_ALT
if|if
condition|(
operator|(
name|a
operator|&
name|QRegExpEngine
operator|::
name|Anchor_Alternation
operator|)
operator|!=
literal|0
condition|)
return|return
name|testAnchor
argument_list|(
name|i
argument_list|,
name|eng
operator|->
name|aa
operator|.
name|at
argument_list|(
name|a
operator|^
name|QRegExpEngine
operator|::
name|Anchor_Alternation
argument_list|)
operator|.
name|a
argument_list|,
name|capBegin
argument_list|)
operator|||
name|testAnchor
argument_list|(
name|i
argument_list|,
name|eng
operator|->
name|aa
operator|.
name|at
argument_list|(
name|a
operator|^
name|QRegExpEngine
operator|::
name|Anchor_Alternation
argument_list|)
operator|.
name|b
argument_list|,
name|capBegin
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|a
operator|&
name|QRegExpEngine
operator|::
name|Anchor_Caret
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pos
operator|+
name|i
operator|!=
name|caretPos
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|a
operator|&
name|QRegExpEngine
operator|::
name|Anchor_Dollar
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pos
operator|+
name|i
operator|!=
name|len
condition|)
return|return
literal|false
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ESCAPE
if|if
condition|(
operator|(
name|a
operator|&
operator|(
name|QRegExpEngine
operator|::
name|Anchor_Word
operator||
name|QRegExpEngine
operator|::
name|Anchor_NonWord
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bool
name|before
init|=
literal|false
decl_stmt|;
name|bool
name|after
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|pos
operator|+
name|i
operator|!=
literal|0
condition|)
name|before
operator|=
name|isWord
argument_list|(
name|in
index|[
name|pos
operator|+
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|+
name|i
operator|!=
name|len
condition|)
name|after
operator|=
name|isWord
argument_list|(
name|in
index|[
name|pos
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|&
name|QRegExpEngine
operator|::
name|Anchor_Word
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|before
operator|==
name|after
operator|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|(
name|a
operator|&
name|QRegExpEngine
operator|::
name|Anchor_NonWord
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|before
operator|!=
name|after
operator|)
condition|)
return|return
literal|false
return|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_LOOKAHEAD
if|if
condition|(
operator|(
name|a
operator|&
name|QRegExpEngine
operator|::
name|Anchor_LookaheadMask
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|QVector
argument_list|<
name|QRegExpLookahead
modifier|*
argument_list|>
modifier|&
name|ahead
init|=
name|eng
operator|->
name|ahead
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ahead
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|a
operator|&
operator|(
name|QRegExpEngine
operator|::
name|Anchor_FirstLookahead
operator|<<
name|j
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|QRegExpMatchState
name|matchState
decl_stmt|;
name|matchState
operator|.
name|prepareForMatch
argument_list|(
name|ahead
index|[
name|j
index|]
operator|->
name|eng
argument_list|)
expr_stmt|;
name|matchState
operator|.
name|match
argument_list|(
name|in
operator|+
name|pos
operator|+
name|i
argument_list|,
name|len
operator|-
name|pos
operator|-
name|i
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|matchState
operator|.
name|caretPos
operator|-
name|matchState
operator|.
name|pos
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|matchState
operator|.
name|captured
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|==
name|ahead
index|[
name|j
index|]
operator|->
name|neg
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|eng
operator|->
name|nbrefs
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|a
operator|&
operator|(
name|QRegExpEngine
operator|::
name|Anchor_BackRef1Empty
operator|<<
name|j
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
init|=
name|eng
operator|->
name|captureForOfficialCapture
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|capBegin
index|[
name|i
index|]
operator|!=
name|EmptyCapture
condition|)
return|return
literal|false
return|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
end_ifndef
begin_comment
comment|/*   The three following functions are what Jeffrey Friedl would call   transmissions (or bump-alongs). Using one or the other should make   no difference except in performance. */
end_comment
begin_function
DECL|function|goodStringMatch
name|bool
name|QRegExpEngine
operator|::
name|goodStringMatch
parameter_list|(
name|QRegExpMatchState
modifier|&
name|matchState
parameter_list|)
specifier|const
block|{
name|int
name|k
init|=
name|matchState
operator|.
name|pos
operator|+
name|goodEarlyStart
decl_stmt|;
name|QStringMatcher
name|matcher
argument_list|(
name|goodStr
operator|.
name|unicode
argument_list|()
argument_list|,
name|goodStr
operator|.
name|length
argument_list|()
argument_list|,
name|cs
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|matcher
operator|.
name|indexIn
argument_list|(
name|matchState
operator|.
name|in
argument_list|,
name|matchState
operator|.
name|len
argument_list|,
name|k
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|from
init|=
name|k
operator|-
name|goodLateStart
decl_stmt|;
name|int
name|to
init|=
name|k
operator|-
name|goodEarlyStart
decl_stmt|;
if|if
condition|(
name|from
operator|>
name|matchState
operator|.
name|pos
condition|)
name|matchState
operator|.
name|pos
operator|=
name|from
expr_stmt|;
while|while
condition|(
name|matchState
operator|.
name|pos
operator|<=
name|to
condition|)
block|{
if|if
condition|(
name|matchState
operator|.
name|matchHere
argument_list|()
condition|)
return|return
literal|true
return|;
operator|++
name|matchState
operator|.
name|pos
expr_stmt|;
block|}
operator|++
name|k
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|badCharMatch
name|bool
name|QRegExpEngine
operator|::
name|badCharMatch
parameter_list|(
name|QRegExpMatchState
modifier|&
name|matchState
parameter_list|)
specifier|const
block|{
name|int
name|slideHead
init|=
literal|0
decl_stmt|;
name|int
name|slideNext
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|lastPos
init|=
name|matchState
operator|.
name|len
operator|-
name|minl
decl_stmt|;
name|memset
argument_list|(
name|matchState
operator|.
name|slideTab
argument_list|,
literal|0
argument_list|,
name|matchState
operator|.
name|slideTabSize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/*       Set up the slide table, used for the bad-character heuristic,       using the table of first occurrence of each character.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|minl
condition|;
name|i
operator|++
control|)
block|{
name|int
name|sk
init|=
name|occ1
index|[
name|BadChar
argument_list|(
name|matchState
operator|.
name|in
index|[
name|matchState
operator|.
name|pos
operator|+
name|i
index|]
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|sk
operator|==
name|NoOccurrence
condition|)
name|sk
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sk
operator|>
literal|0
condition|)
block|{
name|int
name|k
init|=
name|i
operator|+
literal|1
operator|-
name|sk
decl_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
block|{
name|sk
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sk
operator|>
name|matchState
operator|.
name|slideTab
index|[
name|k
index|]
condition|)
name|matchState
operator|.
name|slideTab
index|[
name|k
index|]
operator|=
name|sk
expr_stmt|;
block|}
block|}
if|if
condition|(
name|matchState
operator|.
name|pos
operator|>
name|lastPos
condition|)
return|return
literal|false
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|++
name|slideNext
operator|>=
name|matchState
operator|.
name|slideTabSize
condition|)
name|slideNext
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|matchState
operator|.
name|slideTab
index|[
name|slideHead
index|]
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|matchState
operator|.
name|slideTab
index|[
name|slideHead
index|]
operator|-
literal|1
operator|>
name|matchState
operator|.
name|slideTab
index|[
name|slideNext
index|]
condition|)
name|matchState
operator|.
name|slideTab
index|[
name|slideNext
index|]
operator|=
name|matchState
operator|.
name|slideTab
index|[
name|slideHead
index|]
operator|-
literal|1
expr_stmt|;
name|matchState
operator|.
name|slideTab
index|[
name|slideHead
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|matchState
operator|.
name|matchHere
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
if|if
condition|(
name|matchState
operator|.
name|pos
operator|==
name|lastPos
condition|)
break|break;
comment|/*           Update the slide table. This code has much in common with           the initialization code.         */
name|int
name|sk
init|=
name|occ1
index|[
name|BadChar
argument_list|(
name|matchState
operator|.
name|in
index|[
name|matchState
operator|.
name|pos
operator|+
name|minl
index|]
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|sk
operator|==
name|NoOccurrence
condition|)
block|{
name|matchState
operator|.
name|slideTab
index|[
name|slideNext
index|]
operator|=
name|minl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sk
operator|>
literal|0
condition|)
block|{
name|int
name|k
init|=
name|slideNext
operator|+
name|minl
operator|-
name|sk
decl_stmt|;
if|if
condition|(
name|k
operator|>=
name|matchState
operator|.
name|slideTabSize
condition|)
name|k
operator|-=
name|matchState
operator|.
name|slideTabSize
expr_stmt|;
if|if
condition|(
name|sk
operator|>
name|matchState
operator|.
name|slideTab
index|[
name|k
index|]
condition|)
name|matchState
operator|.
name|slideTab
index|[
name|k
index|]
operator|=
name|sk
expr_stmt|;
block|}
name|slideHead
operator|=
name|slideNext
expr_stmt|;
operator|++
name|matchState
operator|.
name|pos
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|bruteMatch
name|bool
name|QRegExpEngine
operator|::
name|bruteMatch
parameter_list|(
name|QRegExpMatchState
modifier|&
name|matchState
parameter_list|)
specifier|const
block|{
while|while
condition|(
name|matchState
operator|.
name|pos
operator|<=
name|matchState
operator|.
name|len
condition|)
block|{
if|if
condition|(
name|matchState
operator|.
name|matchHere
argument_list|()
condition|)
return|return
literal|true
return|;
operator|++
name|matchState
operator|.
name|pos
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*   Here's the core of the engine. It tries to do a match here and now. */
end_comment
begin_function
DECL|function|matchHere
name|bool
name|QRegExpMatchState
operator|::
name|matchHere
parameter_list|()
block|{
name|int
name|ncur
init|=
literal|1
decl_stmt|,
name|nnext
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|m
decl_stmt|;
name|bool
name|stop
init|=
literal|false
decl_stmt|;
name|matchLen
operator|=
operator|-
literal|1
expr_stmt|;
name|oneTestMatchedLen
operator|=
operator|-
literal|1
expr_stmt|;
name|curStack
index|[
literal|0
index|]
operator|=
name|QRegExpEngine
operator|::
name|InitialState
expr_stmt|;
name|int
name|ncap
init|=
name|eng
operator|->
name|ncap
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
if|if
condition|(
name|ncap
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ncap
condition|;
name|j
operator|++
control|)
block|{
name|curCapBegin
index|[
name|j
index|]
operator|=
name|EmptyCapture
expr_stmt|;
name|curCapEnd
index|[
name|j
index|]
operator|=
name|EmptyCapture
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
while|while
condition|(
operator|(
name|ncur
operator|>
literal|0
operator|||
operator|!
name|sleeping
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
name|i
operator|<=
name|len
operator|-
name|pos
operator|&&
operator|!
name|stop
condition|)
else|#
directive|else
while|while
condition|(
name|ncur
operator|>
literal|0
operator|&&
name|i
operator|<=
name|len
operator|-
name|pos
operator|&&
operator|!
name|stop
condition|)
endif|#
directive|endif
block|{
name|int
name|ch
init|=
operator|(
name|i
operator|<
name|len
operator|-
name|pos
operator|)
condition|?
name|in
index|[
name|pos
operator|+
name|i
index|]
operator|.
name|unicode
argument_list|()
else|:
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ncur
condition|;
name|j
operator|++
control|)
block|{
name|int
name|cur
init|=
name|curStack
index|[
name|j
index|]
decl_stmt|;
specifier|const
name|QRegExpAutomatonState
modifier|&
name|scur
init|=
name|eng
operator|->
name|s
operator|.
name|at
argument_list|(
name|cur
argument_list|)
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|outs
init|=
name|scur
operator|.
name|outs
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|outs
operator|.
name|size
argument_list|()
condition|;
name|k
operator|++
control|)
block|{
name|int
name|next
init|=
name|outs
operator|.
name|at
argument_list|(
name|k
argument_list|)
decl_stmt|;
specifier|const
name|QRegExpAutomatonState
modifier|&
name|snext
init|=
name|eng
operator|->
name|s
operator|.
name|at
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|bool
name|inside
init|=
literal|true
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_REGEXP_BACKREF
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_REGEXP_CAPTURE
argument_list|)
name|int
name|needSomeSleep
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/*                   First, check if the anchors are anchored properly.                 */
name|int
name|a
init|=
name|scur
operator|.
name|anchors
operator|.
name|value
argument_list|(
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|!=
literal|0
operator|&&
operator|!
name|testAnchor
argument_list|(
name|i
argument_list|,
name|a
argument_list|,
name|curCapBegin
operator|+
name|j
operator|*
name|ncap
argument_list|)
condition|)
name|inside
operator|=
literal|false
expr_stmt|;
comment|/*                   If indeed they are, check if the input character is                   correct for this transition.                 */
if|if
condition|(
name|inside
condition|)
block|{
name|m
operator|=
name|snext
operator|.
name|match
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|&
operator|(
name|QRegExpEngine
operator|::
name|CharClassBit
operator||
name|QRegExpEngine
operator|::
name|BackRefBit
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|eng
operator|->
name|cs
condition|)
name|inside
operator|=
operator|(
name|m
operator|==
name|ch
operator|)
expr_stmt|;
else|else
name|inside
operator|=
operator|(
name|QChar
argument_list|(
name|m
argument_list|)
operator|.
name|toLower
argument_list|()
operator|==
name|QChar
argument_list|(
name|ch
argument_list|)
operator|.
name|toLower
argument_list|()
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next
operator|==
name|QRegExpEngine
operator|::
name|FinalState
condition|)
block|{
name|matchLen
operator|=
name|i
expr_stmt|;
name|stop
operator|=
name|minimal
expr_stmt|;
name|inside
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|m
operator|&
name|QRegExpEngine
operator|::
name|CharClassBit
operator|)
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
specifier|const
name|QRegExpCharClass
modifier|&
name|cc
init|=
name|eng
operator|->
name|cl
operator|.
name|at
argument_list|(
name|m
operator|^
name|QRegExpEngine
operator|::
name|CharClassBit
argument_list|)
decl_stmt|;
if|if
condition|(
name|eng
operator|->
name|cs
condition|)
name|inside
operator|=
name|cc
operator|.
name|in
argument_list|(
name|ch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cc
operator|.
name|negative
argument_list|()
condition|)
name|inside
operator|=
name|cc
operator|.
name|in
argument_list|(
name|QChar
argument_list|(
name|ch
argument_list|)
operator|.
name|toLower
argument_list|()
argument_list|)
operator|&&
name|cc
operator|.
name|in
argument_list|(
name|QChar
argument_list|(
name|ch
argument_list|)
operator|.
name|toUpper
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|inside
operator|=
name|cc
operator|.
name|in
argument_list|(
name|QChar
argument_list|(
name|ch
argument_list|)
operator|.
name|toLower
argument_list|()
argument_list|)
operator|||
name|cc
operator|.
name|in
argument_list|(
name|QChar
argument_list|(
name|ch
argument_list|)
operator|.
name|toUpper
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_REGEXP_BACKREF
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_REGEXP_CAPTURE
argument_list|)
block|}
else|else
block|{
comment|/* ((m& QRegExpEngine::BackRefBit) != 0) */
name|int
name|bref
init|=
name|m
operator|^
name|QRegExpEngine
operator|::
name|BackRefBit
decl_stmt|;
name|int
name|ell
init|=
name|j
operator|*
name|ncap
operator|+
name|eng
operator|->
name|captureForOfficialCapture
operator|.
name|at
argument_list|(
name|bref
operator|-
literal|1
argument_list|)
decl_stmt|;
name|inside
operator|=
name|bref
operator|<=
name|ncap
operator|&&
name|curCapBegin
index|[
name|ell
index|]
operator|!=
name|EmptyCapture
expr_stmt|;
if|if
condition|(
name|inside
condition|)
block|{
if|if
condition|(
name|eng
operator|->
name|cs
condition|)
name|inside
operator|=
operator|(
name|in
index|[
name|pos
operator|+
name|curCapBegin
index|[
name|ell
index|]
index|]
operator|==
name|QChar
argument_list|(
name|ch
argument_list|)
operator|)
expr_stmt|;
else|else
name|inside
operator|=
operator|(
name|in
index|[
name|pos
operator|+
name|curCapBegin
index|[
name|ell
index|]
index|]
operator|.
name|toLower
argument_list|()
operator|==
name|QChar
argument_list|(
name|ch
argument_list|)
operator|.
name|toLower
argument_list|()
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|inside
condition|)
block|{
name|int
name|delta
decl_stmt|;
if|if
condition|(
name|curCapEnd
index|[
name|ell
index|]
operator|==
name|EmptyCapture
condition|)
name|delta
operator|=
name|i
operator|-
name|curCapBegin
index|[
name|ell
index|]
expr_stmt|;
else|else
name|delta
operator|=
name|curCapEnd
index|[
name|ell
index|]
operator|-
name|curCapBegin
index|[
name|ell
index|]
expr_stmt|;
name|inside
operator|=
operator|(
name|delta
operator|<=
name|len
operator|-
operator|(
name|pos
operator|+
name|i
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|inside
operator|&&
name|delta
operator|>
literal|1
condition|)
block|{
name|int
name|n
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|eng
operator|->
name|cs
condition|)
block|{
while|while
condition|(
name|n
operator|<
name|delta
condition|)
block|{
if|if
condition|(
name|in
index|[
name|pos
operator|+
name|curCapBegin
index|[
name|ell
index|]
operator|+
name|n
index|]
operator|!=
name|in
index|[
name|pos
operator|+
name|i
operator|+
name|n
index|]
condition|)
break|break;
operator|++
name|n
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|n
operator|<
name|delta
condition|)
block|{
name|QChar
name|a
init|=
name|in
index|[
name|pos
operator|+
name|curCapBegin
index|[
name|ell
index|]
operator|+
name|n
index|]
decl_stmt|;
name|QChar
name|b
init|=
name|in
index|[
name|pos
operator|+
name|i
operator|+
name|n
index|]
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|toLower
argument_list|()
operator|!=
name|b
operator|.
name|toLower
argument_list|()
condition|)
break|break;
operator|++
name|n
expr_stmt|;
block|}
block|}
name|inside
operator|=
operator|(
name|n
operator|==
name|delta
operator|)
expr_stmt|;
if|if
condition|(
name|inside
condition|)
name|needSomeSleep
operator|=
name|delta
operator|-
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
comment|/*                   We must now update our data structures.                 */
if|if
condition|(
name|inside
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|int
modifier|*
name|capBegin
decl_stmt|,
modifier|*
name|capEnd
decl_stmt|;
endif|#
directive|endif
comment|/*                       If the next state was not encountered yet, all                       is fine.                     */
if|if
condition|(
operator|(
name|m
operator|=
name|inNextStack
index|[
name|next
index|]
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|m
operator|=
name|nnext
operator|++
expr_stmt|;
name|nextStack
index|[
name|m
index|]
operator|=
name|next
expr_stmt|;
name|inNextStack
index|[
name|next
index|]
operator|=
name|m
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|capBegin
operator|=
name|nextCapBegin
operator|+
name|m
operator|*
name|ncap
expr_stmt|;
name|capEnd
operator|=
name|nextCapEnd
operator|+
name|m
operator|*
name|ncap
expr_stmt|;
comment|/*                       Otherwise, we'll first maintain captures in                       temporary arrays, and decide at the end whether                       it's best to keep the previous capture zones or                       the new ones.                     */
block|}
else|else
block|{
name|capBegin
operator|=
name|tempCapBegin
expr_stmt|;
name|capEnd
operator|=
name|tempCapEnd
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
comment|/*                       Updating the capture zones is much of a task.                     */
if|if
condition|(
name|ncap
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|capBegin
argument_list|,
name|curCapBegin
operator|+
name|j
operator|*
name|ncap
argument_list|,
name|ncap
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|capEnd
argument_list|,
name|curCapEnd
operator|+
name|j
operator|*
name|ncap
argument_list|,
name|ncap
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|c
init|=
name|scur
operator|.
name|atom
decl_stmt|,
name|n
init|=
name|snext
operator|.
name|atom
decl_stmt|;
name|int
name|p
init|=
operator|-
literal|1
decl_stmt|,
name|q
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|cap
decl_stmt|;
comment|/*                           Lemma 1. For any x in the range [0..nf), we                           have f[x].parent< x.                            Proof. By looking at startAtom(), it is                           clear that cf< nf holds all the time, and                           thus that f[nf].parent< nf.                         */
comment|/*                           If we are reentering an atom, we empty all                           capture zones inside it.                         */
if|if
condition|(
operator|(
name|q
operator|=
name|scur
operator|.
name|reenter
operator|.
name|value
argument_list|(
name|next
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|QBitArray
name|b
argument_list|(
name|eng
operator|->
name|nf
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|b
operator|.
name|setBit
argument_list|(
name|q
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|ell
init|=
name|q
operator|+
literal|1
init|;
name|ell
operator|<
name|eng
operator|->
name|nf
condition|;
name|ell
operator|++
control|)
block|{
if|if
condition|(
name|b
operator|.
name|testBit
argument_list|(
name|eng
operator|->
name|f
operator|.
name|at
argument_list|(
name|ell
argument_list|)
operator|.
name|parent
argument_list|)
condition|)
block|{
name|b
operator|.
name|setBit
argument_list|(
name|ell
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|cap
operator|=
name|eng
operator|->
name|f
operator|.
name|at
argument_list|(
name|ell
argument_list|)
operator|.
name|capture
expr_stmt|;
if|if
condition|(
name|cap
operator|>=
literal|0
condition|)
block|{
name|capBegin
index|[
name|cap
index|]
operator|=
name|EmptyCapture
expr_stmt|;
name|capEnd
index|[
name|cap
index|]
operator|=
name|EmptyCapture
expr_stmt|;
block|}
block|}
block|}
name|p
operator|=
name|eng
operator|->
name|f
operator|.
name|at
argument_list|(
name|q
argument_list|)
operator|.
name|parent
expr_stmt|;
comment|/*                           Otherwise, close the capture zones we are                           leaving. We are leaving f[c].capture,                           f[f[c].parent].capture,                           f[f[f[c].parent].parent].capture, ...,                           until f[x].capture, with x such that                           f[x].parent is the youngest common ancestor                           for c and n.                            We go up along c's and n's ancestry until                           we find x.                         */
block|}
else|else
block|{
name|p
operator|=
name|c
expr_stmt|;
name|q
operator|=
name|n
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|q
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|q
condition|)
block|{
name|cap
operator|=
name|eng
operator|->
name|f
operator|.
name|at
argument_list|(
name|p
argument_list|)
operator|.
name|capture
expr_stmt|;
if|if
condition|(
name|cap
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|capBegin
index|[
name|cap
index|]
operator|==
name|i
condition|)
block|{
name|capBegin
index|[
name|cap
index|]
operator|=
name|EmptyCapture
expr_stmt|;
name|capEnd
index|[
name|cap
index|]
operator|=
name|EmptyCapture
expr_stmt|;
block|}
else|else
block|{
name|capEnd
index|[
name|cap
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
name|p
operator|=
name|eng
operator|->
name|f
operator|.
name|at
argument_list|(
name|p
argument_list|)
operator|.
name|parent
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|eng
operator|->
name|f
operator|.
name|at
argument_list|(
name|q
argument_list|)
operator|.
name|parent
expr_stmt|;
block|}
block|}
block|}
comment|/*                           In any case, we now open the capture zones                           we are entering. We work upwards from n                           until we reach p (the parent of the atom we                           reenter or the youngest common ancestor).                         */
while|while
condition|(
name|n
operator|>
name|p
condition|)
block|{
name|cap
operator|=
name|eng
operator|->
name|f
operator|.
name|at
argument_list|(
name|n
argument_list|)
operator|.
name|capture
expr_stmt|;
if|if
condition|(
name|cap
operator|>=
literal|0
condition|)
block|{
name|capBegin
index|[
name|cap
index|]
operator|=
name|i
expr_stmt|;
name|capEnd
index|[
name|cap
index|]
operator|=
name|EmptyCapture
expr_stmt|;
block|}
name|n
operator|=
name|eng
operator|->
name|f
operator|.
name|at
argument_list|(
name|n
argument_list|)
operator|.
name|parent
expr_stmt|;
block|}
comment|/*                           If the next state was already in                           nextStack, we must choose carefully which                           capture zones we want to keep.                         */
if|if
condition|(
name|capBegin
operator|==
name|tempCapBegin
operator|&&
name|isBetterCapture
argument_list|(
name|ncap
argument_list|,
name|capBegin
argument_list|,
name|capEnd
argument_list|,
name|nextCapBegin
operator|+
name|m
operator|*
name|ncap
argument_list|,
name|nextCapEnd
operator|+
name|m
operator|*
name|ncap
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|nextCapBegin
operator|+
name|m
operator|*
name|ncap
argument_list|,
name|capBegin
argument_list|,
name|ncap
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nextCapEnd
operator|+
name|m
operator|*
name|ncap
argument_list|,
name|capEnd
argument_list|,
name|ncap
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
comment|/*                       We are done with updating the capture zones.                       It's now time to put the next state to sleep,                       if it needs to, and to remove it from                       nextStack.                     */
if|if
condition|(
name|needSomeSleep
operator|>
literal|0
condition|)
block|{
name|QVector
argument_list|<
name|int
argument_list|>
name|zzZ
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|ncap
argument_list|)
decl_stmt|;
name|zzZ
index|[
literal|0
index|]
operator|=
name|i
operator|+
name|needSomeSleep
expr_stmt|;
name|zzZ
index|[
literal|1
index|]
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|ncap
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|zzZ
operator|.
name|data
argument_list|()
operator|+
literal|2
argument_list|,
name|capBegin
argument_list|,
name|ncap
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|zzZ
operator|.
name|data
argument_list|()
operator|+
literal|2
operator|+
name|ncap
argument_list|,
name|capEnd
argument_list|,
name|ncap
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inNextStack
index|[
name|nextStack
index|[
operator|--
name|nnext
index|]
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|sleeping
operator|.
name|append
argument_list|(
name|zzZ
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
comment|/*           If we reached the final state, hurray! Copy the captured           zone.         */
if|if
condition|(
name|ncap
operator|>
literal|0
operator|&&
operator|(
name|m
operator|=
name|inNextStack
index|[
name|QRegExpEngine
operator|::
name|FinalState
index|]
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|capBegin
argument_list|,
name|nextCapBegin
operator|+
name|m
operator|*
name|ncap
argument_list|,
name|ncap
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|capEnd
argument_list|,
name|nextCapEnd
operator|+
name|m
operator|*
name|ncap
argument_list|,
name|ncap
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
comment|/*           It's time to wake up the sleepers.         */
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|sleeping
operator|.
name|count
argument_list|()
condition|)
block|{
if|if
condition|(
name|sleeping
operator|.
name|at
argument_list|(
name|j
argument_list|)
index|[
literal|0
index|]
operator|==
name|i
condition|)
block|{
specifier|const
name|QVector
argument_list|<
name|int
argument_list|>
modifier|&
name|zzZ
init|=
name|sleeping
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|int
name|next
init|=
name|zzZ
index|[
literal|1
index|]
decl_stmt|;
specifier|const
name|int
modifier|*
name|capBegin
init|=
name|zzZ
operator|.
name|data
argument_list|()
operator|+
literal|2
decl_stmt|;
specifier|const
name|int
modifier|*
name|capEnd
init|=
name|zzZ
operator|.
name|data
argument_list|()
operator|+
literal|2
operator|+
name|ncap
decl_stmt|;
name|bool
name|copyOver
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|inNextStack
index|[
name|next
index|]
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|m
operator|=
name|nnext
operator|++
expr_stmt|;
name|nextStack
index|[
name|m
index|]
operator|=
name|next
expr_stmt|;
name|inNextStack
index|[
name|next
index|]
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|copyOver
operator|=
name|isBetterCapture
argument_list|(
name|ncap
argument_list|,
name|nextCapBegin
operator|+
name|m
operator|*
name|ncap
argument_list|,
name|nextCapEnd
operator|+
name|m
operator|*
name|ncap
argument_list|,
name|capBegin
argument_list|,
name|capEnd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copyOver
condition|)
block|{
name|memcpy
argument_list|(
name|nextCapBegin
operator|+
name|m
operator|*
name|ncap
argument_list|,
name|capBegin
argument_list|,
name|ncap
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nextCapEnd
operator|+
name|m
operator|*
name|ncap
argument_list|,
name|capEnd
argument_list|,
name|ncap
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sleeping
operator|.
name|removeAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|j
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nnext
condition|;
name|j
operator|++
control|)
name|inNextStack
index|[
name|nextStack
index|[
name|j
index|]
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|// avoid needless iteration that confuses oneTestMatchedLen
if|if
condition|(
name|nnext
operator|==
literal|1
operator|&&
name|nextStack
index|[
literal|0
index|]
operator|==
name|QRegExpEngine
operator|::
name|FinalState
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
operator|&&
name|sleeping
operator|.
name|isEmpty
argument_list|()
endif|#
directive|endif
condition|)
name|stop
operator|=
literal|true
expr_stmt|;
name|qSwap
argument_list|(
name|curStack
argument_list|,
name|nextStack
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|qSwap
argument_list|(
name|curCapBegin
argument_list|,
name|nextCapBegin
argument_list|)
expr_stmt|;
name|qSwap
argument_list|(
name|curCapEnd
argument_list|,
name|nextCapEnd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ncur
operator|=
name|nnext
expr_stmt|;
name|nnext
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
comment|/*       If minimal matching is enabled, we might have some sleepers       left.     */
if|if
condition|(
operator|!
name|sleeping
operator|.
name|isEmpty
argument_list|()
condition|)
name|sleeping
operator|.
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|oneTestMatchedLen
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|matchLen
operator|>=
literal|0
operator|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
end_ifndef
begin_constructor
DECL|function|QRegExpCharClass
name|QRegExpCharClass
operator|::
name|QRegExpCharClass
parameter_list|()
member_init_list|:
name|c
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|n
argument_list|(
literal|false
argument_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|occ1
operator|.
name|fill
argument_list|(
name|NoOccurrence
argument_list|,
name|NumBadChars
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_function
DECL|function|operator =
name|QRegExpCharClass
modifier|&
name|QRegExpCharClass
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QRegExpCharClass
modifier|&
name|cc
parameter_list|)
block|{
name|c
operator|=
name|cc
operator|.
name|c
expr_stmt|;
name|r
operator|=
name|cc
operator|.
name|r
expr_stmt|;
name|n
operator|=
name|cc
operator|.
name|n
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|occ1
operator|=
name|cc
operator|.
name|occ1
expr_stmt|;
endif|#
directive|endif
return|return
operator|*
name|this
return|;
block|}
end_function
begin_function
DECL|function|clear
name|void
name|QRegExpCharClass
operator|::
name|clear
parameter_list|()
block|{
name|c
operator|=
literal|0
expr_stmt|;
name|r
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setNegative
name|void
name|QRegExpCharClass
operator|::
name|setNegative
parameter_list|(
name|bool
name|negative
parameter_list|)
block|{
name|n
operator|=
name|negative
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|occ1
operator|.
name|fill
argument_list|(
literal|0
argument_list|,
name|NumBadChars
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|addCategories
name|void
name|QRegExpCharClass
operator|::
name|addCategories
parameter_list|(
name|uint
name|cats
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|all_cats
init|=
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_NonSpacing
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_SpacingCombining
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_Enclosing
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_DecimalDigit
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Letter
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Other
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Space
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Line
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Paragraph
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_Control
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_Format
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_Surrogate
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_PrivateUse
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_NotAssigned
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Uppercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Lowercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Titlecase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Modifier
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Other
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Connector
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Dash
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Open
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Close
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_InitialQuote
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_FinalQuote
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Other
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Symbol_Math
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Symbol_Currency
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Symbol_Modifier
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Symbol_Other
argument_list|)
decl_stmt|;
name|c
operator||=
operator|(
name|all_cats
operator|&
name|cats
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|occ1
operator|.
name|fill
argument_list|(
literal|0
argument_list|,
name|NumBadChars
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|addRange
name|void
name|QRegExpCharClass
operator|::
name|addRange
parameter_list|(
name|ushort
name|from
parameter_list|,
name|ushort
name|to
parameter_list|)
block|{
if|if
condition|(
name|from
operator|>
name|to
condition|)
name|qSwap
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|int
name|m
init|=
name|r
operator|.
name|size
argument_list|()
decl_stmt|;
name|r
operator|.
name|resize
argument_list|(
name|m
operator|+
literal|1
argument_list|)
expr_stmt|;
name|r
index|[
name|m
index|]
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|r
index|[
name|m
index|]
operator|.
name|len
operator|=
name|to
operator|-
name|from
operator|+
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|int
name|i
decl_stmt|;
if|if
condition|(
name|to
operator|-
name|from
operator|<
name|NumBadChars
condition|)
block|{
if|if
condition|(
name|from
operator|%
name|NumBadChars
operator|<=
name|to
operator|%
name|NumBadChars
condition|)
block|{
for|for
control|(
name|i
operator|=
name|from
operator|%
name|NumBadChars
init|;
name|i
operator|<=
name|to
operator|%
name|NumBadChars
condition|;
name|i
operator|++
control|)
name|occ1
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|to
operator|%
name|NumBadChars
condition|;
name|i
operator|++
control|)
name|occ1
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
operator|%
name|NumBadChars
init|;
name|i
operator|<
name|NumBadChars
condition|;
name|i
operator|++
control|)
name|occ1
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|occ1
operator|.
name|fill
argument_list|(
literal|0
argument_list|,
name|NumBadChars
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|in
name|bool
name|QRegExpCharClass
operator|::
name|in
parameter_list|(
name|QChar
name|ch
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
if|if
condition|(
name|occ1
operator|.
name|at
argument_list|(
name|BadChar
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|==
name|NoOccurrence
condition|)
return|return
name|n
return|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|!=
literal|0
operator|&&
operator|(
name|c
operator|&
name|FLAG
argument_list|(
name|ch
operator|.
name|category
argument_list|()
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|!
name|n
return|;
specifier|const
name|int
name|uc
init|=
name|ch
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|r
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QRegExpCharClassRange
modifier|&
name|range
init|=
name|r
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|uc
operator|-
name|range
operator|.
name|from
argument_list|)
operator|<
name|uint
argument_list|(
name|r
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|len
argument_list|)
condition|)
return|return
operator|!
name|n
return|;
block|}
return|return
name|n
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
end_if
begin_function
DECL|function|dump
name|void
name|QRegExpCharClass
operator|::
name|dump
parameter_list|()
specifier|const
block|{
name|int
name|i
decl_stmt|;
name|qDebug
argument_list|(
literal|"    %stive character class"
argument_list|,
name|n
condition|?
literal|"nega"
else|:
literal|"posi"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
name|qDebug
argument_list|(
literal|"      categories 0x%.8x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
name|qDebug
argument_list|(
literal|"      0x%.4x through 0x%.4x"
argument_list|,
name|r
index|[
name|i
index|]
operator|.
name|from
argument_list|,
name|r
index|[
name|i
index|]
operator|.
name|from
operator|+
name|r
index|[
name|i
index|]
operator|.
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|Box
name|QRegExpEngine
operator|::
name|Box
operator|::
name|Box
parameter_list|(
name|QRegExpEngine
modifier|*
name|engine
parameter_list|)
member_init_list|:
name|eng
argument_list|(
name|engine
argument_list|)
member_init_list|,
name|skipanchors
argument_list|(
literal|0
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
member_init_list|,
name|earlyStart
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lateStart
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|maxl
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|occ1
operator|.
name|fill
argument_list|(
name|NoOccurrence
argument_list|,
name|NumBadChars
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|minl
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|operator =
name|QRegExpEngine
operator|::
name|Box
modifier|&
name|QRegExpEngine
operator|::
name|Box
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|Box
modifier|&
name|b
parameter_list|)
block|{
name|eng
operator|=
name|b
operator|.
name|eng
expr_stmt|;
name|ls
operator|=
name|b
operator|.
name|ls
expr_stmt|;
name|rs
operator|=
name|b
operator|.
name|rs
expr_stmt|;
name|lanchors
operator|=
name|b
operator|.
name|lanchors
expr_stmt|;
name|ranchors
operator|=
name|b
operator|.
name|ranchors
expr_stmt|;
name|skipanchors
operator|=
name|b
operator|.
name|skipanchors
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|earlyStart
operator|=
name|b
operator|.
name|earlyStart
expr_stmt|;
name|lateStart
operator|=
name|b
operator|.
name|lateStart
expr_stmt|;
name|str
operator|=
name|b
operator|.
name|str
expr_stmt|;
name|leftStr
operator|=
name|b
operator|.
name|leftStr
expr_stmt|;
name|rightStr
operator|=
name|b
operator|.
name|rightStr
expr_stmt|;
name|maxl
operator|=
name|b
operator|.
name|maxl
expr_stmt|;
name|occ1
operator|=
name|b
operator|.
name|occ1
expr_stmt|;
endif|#
directive|endif
name|minl
operator|=
name|b
operator|.
name|minl
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_function
DECL|function|set
name|void
name|QRegExpEngine
operator|::
name|Box
operator|::
name|set
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
name|ls
operator|.
name|resize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ls
index|[
literal|0
index|]
operator|=
name|eng
operator|->
name|createState
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|rs
operator|=
name|ls
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|str
operator|=
name|ch
expr_stmt|;
name|leftStr
operator|=
name|ch
expr_stmt|;
name|rightStr
operator|=
name|ch
expr_stmt|;
name|maxl
operator|=
literal|1
expr_stmt|;
name|occ1
index|[
name|BadChar
argument_list|(
name|ch
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|minl
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set
name|void
name|QRegExpEngine
operator|::
name|Box
operator|::
name|set
parameter_list|(
specifier|const
name|QRegExpCharClass
modifier|&
name|cc
parameter_list|)
block|{
name|ls
operator|.
name|resize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ls
index|[
literal|0
index|]
operator|=
name|eng
operator|->
name|createState
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|rs
operator|=
name|ls
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|maxl
operator|=
literal|1
expr_stmt|;
name|occ1
operator|=
name|cc
operator|.
name|firstOccurrence
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|minl
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
end_ifndef
begin_function
DECL|function|set
name|void
name|QRegExpEngine
operator|::
name|Box
operator|::
name|set
parameter_list|(
name|int
name|bref
parameter_list|)
block|{
name|ls
operator|.
name|resize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ls
index|[
literal|0
index|]
operator|=
name|eng
operator|->
name|createState
argument_list|(
name|bref
argument_list|)
expr_stmt|;
name|rs
operator|=
name|ls
expr_stmt|;
if|if
condition|(
name|bref
operator|>=
literal|1
operator|&&
name|bref
operator|<=
name|MaxBackRefs
condition|)
name|skipanchors
operator|=
name|Anchor_BackRef0Empty
operator|<<
name|bref
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|maxl
operator|=
name|InftyLen
expr_stmt|;
endif|#
directive|endif
name|minl
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cat
name|void
name|QRegExpEngine
operator|::
name|Box
operator|::
name|cat
parameter_list|(
specifier|const
name|Box
modifier|&
name|b
parameter_list|)
block|{
name|eng
operator|->
name|addCatTransitions
argument_list|(
name|rs
argument_list|,
name|b
operator|.
name|ls
argument_list|)
expr_stmt|;
name|addAnchorsToEngine
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|minl
operator|==
literal|0
condition|)
block|{
name|lanchors
operator|.
name|unite
argument_list|(
name|b
operator|.
name|lanchors
argument_list|)
expr_stmt|;
if|if
condition|(
name|skipanchors
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|b
operator|.
name|ls
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|a
init|=
name|eng
operator|->
name|anchorConcatenation
argument_list|(
name|lanchors
operator|.
name|value
argument_list|(
name|b
operator|.
name|ls
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|skipanchors
argument_list|)
decl_stmt|;
name|lanchors
operator|.
name|insert
argument_list|(
name|b
operator|.
name|ls
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
name|mergeInto
argument_list|(
operator|&
name|ls
argument_list|,
name|b
operator|.
name|ls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|.
name|minl
operator|==
literal|0
condition|)
block|{
name|ranchors
operator|.
name|unite
argument_list|(
name|b
operator|.
name|ranchors
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|skipanchors
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|a
init|=
name|eng
operator|->
name|anchorConcatenation
argument_list|(
name|ranchors
operator|.
name|value
argument_list|(
name|rs
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|b
operator|.
name|skipanchors
argument_list|)
decl_stmt|;
name|ranchors
operator|.
name|insert
argument_list|(
name|rs
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
name|mergeInto
argument_list|(
operator|&
name|rs
argument_list|,
name|b
operator|.
name|rs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ranchors
operator|=
name|b
operator|.
name|ranchors
expr_stmt|;
name|rs
operator|=
name|b
operator|.
name|rs
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
if|if
condition|(
name|maxl
operator|!=
name|InftyLen
condition|)
block|{
if|if
condition|(
name|rightStr
operator|.
name|length
argument_list|()
operator|+
name|b
operator|.
name|leftStr
operator|.
name|length
argument_list|()
operator|>
name|qMax
argument_list|(
name|str
operator|.
name|length
argument_list|()
argument_list|,
name|b
operator|.
name|str
operator|.
name|length
argument_list|()
argument_list|)
condition|)
block|{
name|earlyStart
operator|=
name|minl
operator|-
name|rightStr
operator|.
name|length
argument_list|()
expr_stmt|;
name|lateStart
operator|=
name|maxl
operator|-
name|rightStr
operator|.
name|length
argument_list|()
expr_stmt|;
name|str
operator|=
name|rightStr
operator|+
name|b
operator|.
name|leftStr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|.
name|str
operator|.
name|length
argument_list|()
operator|>
name|str
operator|.
name|length
argument_list|()
condition|)
block|{
name|earlyStart
operator|=
name|minl
operator|+
name|b
operator|.
name|earlyStart
expr_stmt|;
name|lateStart
operator|=
name|maxl
operator|+
name|b
operator|.
name|lateStart
expr_stmt|;
name|str
operator|=
name|b
operator|.
name|str
expr_stmt|;
block|}
block|}
if|if
condition|(
name|leftStr
operator|.
name|length
argument_list|()
operator|==
name|maxl
condition|)
name|leftStr
operator|+=
name|b
operator|.
name|leftStr
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|rightStr
operator|.
name|length
argument_list|()
operator|==
name|b
operator|.
name|maxl
condition|)
block|{
name|rightStr
operator|+=
name|b
operator|.
name|rightStr
expr_stmt|;
block|}
else|else
block|{
name|rightStr
operator|=
name|b
operator|.
name|rightStr
expr_stmt|;
block|}
if|if
condition|(
name|maxl
operator|==
name|InftyLen
operator|||
name|b
operator|.
name|maxl
operator|==
name|InftyLen
condition|)
block|{
name|maxl
operator|=
name|InftyLen
expr_stmt|;
block|}
else|else
block|{
name|maxl
operator|+=
name|b
operator|.
name|maxl
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumBadChars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|b
operator|.
name|occ1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|NoOccurrence
operator|&&
name|minl
operator|+
name|b
operator|.
name|occ1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|<
name|occ1
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
name|occ1
index|[
name|i
index|]
operator|=
name|minl
operator|+
name|b
operator|.
name|occ1
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|minl
operator|+=
name|b
operator|.
name|minl
expr_stmt|;
if|if
condition|(
name|minl
operator|==
literal|0
condition|)
name|skipanchors
operator|=
name|eng
operator|->
name|anchorConcatenation
argument_list|(
name|skipanchors
argument_list|,
name|b
operator|.
name|skipanchors
argument_list|)
expr_stmt|;
else|else
name|skipanchors
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|orx
name|void
name|QRegExpEngine
operator|::
name|Box
operator|::
name|orx
parameter_list|(
specifier|const
name|Box
modifier|&
name|b
parameter_list|)
block|{
name|mergeInto
argument_list|(
operator|&
name|ls
argument_list|,
name|b
operator|.
name|ls
argument_list|)
expr_stmt|;
name|lanchors
operator|.
name|unite
argument_list|(
name|b
operator|.
name|lanchors
argument_list|)
expr_stmt|;
name|mergeInto
argument_list|(
operator|&
name|rs
argument_list|,
name|b
operator|.
name|rs
argument_list|)
expr_stmt|;
name|ranchors
operator|.
name|unite
argument_list|(
name|b
operator|.
name|ranchors
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|minl
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|minl
operator|==
literal|0
condition|)
name|skipanchors
operator|=
name|eng
operator|->
name|anchorAlternation
argument_list|(
name|skipanchors
argument_list|,
name|b
operator|.
name|skipanchors
argument_list|)
expr_stmt|;
else|else
name|skipanchors
operator|=
name|b
operator|.
name|skipanchors
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumBadChars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|occ1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|>
name|b
operator|.
name|occ1
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
name|occ1
index|[
name|i
index|]
operator|=
name|b
operator|.
name|occ1
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|earlyStart
operator|=
literal|0
expr_stmt|;
name|lateStart
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|QString
argument_list|()
expr_stmt|;
name|leftStr
operator|=
name|QString
argument_list|()
expr_stmt|;
name|rightStr
operator|=
name|QString
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|maxl
operator|>
name|maxl
condition|)
name|maxl
operator|=
name|b
operator|.
name|maxl
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|b
operator|.
name|minl
operator|<
name|minl
condition|)
name|minl
operator|=
name|b
operator|.
name|minl
expr_stmt|;
block|}
end_function
begin_function
DECL|function|plus
name|void
name|QRegExpEngine
operator|::
name|Box
operator|::
name|plus
parameter_list|(
name|int
name|atom
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|eng
operator|->
name|addPlusTransitions
argument_list|(
name|rs
argument_list|,
name|ls
argument_list|,
name|atom
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|atom
argument_list|)
expr_stmt|;
name|eng
operator|->
name|addCatTransitions
argument_list|(
name|rs
argument_list|,
name|ls
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addAnchorsToEngine
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|maxl
operator|=
name|InftyLen
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|opt
name|void
name|QRegExpEngine
operator|::
name|Box
operator|::
name|opt
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|earlyStart
operator|=
literal|0
expr_stmt|;
name|lateStart
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|QString
argument_list|()
expr_stmt|;
name|leftStr
operator|=
name|QString
argument_list|()
expr_stmt|;
name|rightStr
operator|=
name|QString
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|skipanchors
operator|=
literal|0
expr_stmt|;
name|minl
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|catAnchor
name|void
name|QRegExpEngine
operator|::
name|Box
operator|::
name|catAnchor
parameter_list|(
name|int
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
name|eng
operator|->
name|anchorConcatenation
argument_list|(
name|ranchors
operator|.
name|value
argument_list|(
name|rs
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|ranchors
operator|.
name|insert
argument_list|(
name|rs
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minl
operator|==
literal|0
condition|)
name|skipanchors
operator|=
name|eng
operator|->
name|anchorConcatenation
argument_list|(
name|skipanchors
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
end_ifndef
begin_function
DECL|function|setupHeuristics
name|void
name|QRegExpEngine
operator|::
name|Box
operator|::
name|setupHeuristics
parameter_list|()
block|{
name|eng
operator|->
name|goodEarlyStart
operator|=
name|earlyStart
expr_stmt|;
name|eng
operator|->
name|goodLateStart
operator|=
name|lateStart
expr_stmt|;
name|eng
operator|->
name|goodStr
operator|=
name|eng
operator|->
name|cs
condition|?
name|str
else|:
name|str
operator|.
name|toLower
argument_list|()
expr_stmt|;
name|eng
operator|->
name|minl
operator|=
name|minl
expr_stmt|;
if|if
condition|(
name|eng
operator|->
name|cs
condition|)
block|{
comment|/*           A regular expression such as 112|1 has occ1['2'] = 2 and minl =           1 at this point. An entry of occ1 has to be at most minl or           infinity for the rest of the algorithm to go well.            We waited until here before normalizing these cases (instead of           doing it in Box::orx()) because sometimes things improve by           themselves. Consider for example (112|1)34.         */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumBadChars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|occ1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
name|NoOccurrence
operator|&&
name|occ1
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|>=
name|minl
condition|)
name|occ1
index|[
name|i
index|]
operator|=
name|minl
expr_stmt|;
block|}
name|eng
operator|->
name|occ1
operator|=
name|occ1
expr_stmt|;
block|}
else|else
block|{
name|eng
operator|->
name|occ1
operator|.
name|fill
argument_list|(
literal|0
argument_list|,
name|NumBadChars
argument_list|)
expr_stmt|;
block|}
name|eng
operator|->
name|heuristicallyChooseHeuristic
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
end_if
begin_function
DECL|function|dump
name|void
name|QRegExpEngine
operator|::
name|Box
operator|::
name|dump
parameter_list|()
specifier|const
block|{
name|int
name|i
decl_stmt|;
name|qDebug
argument_list|(
literal|"Box of at least %d character%s"
argument_list|,
name|minl
argument_list|,
name|minl
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  Left states:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ls
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lanchors
operator|.
name|value
argument_list|(
name|ls
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|qDebug
argument_list|(
literal|"    %d"
argument_list|,
name|ls
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|qDebug
argument_list|(
literal|"    %d [anchors 0x%.8x]"
argument_list|,
name|ls
index|[
name|i
index|]
argument_list|,
name|lanchors
index|[
name|ls
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|qDebug
argument_list|(
literal|"  Right states:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ranchors
operator|.
name|value
argument_list|(
name|rs
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|qDebug
argument_list|(
literal|"    %d"
argument_list|,
name|rs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|qDebug
argument_list|(
literal|"    %d [anchors 0x%.8x]"
argument_list|,
name|rs
index|[
name|i
index|]
argument_list|,
name|ranchors
index|[
name|rs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|qDebug
argument_list|(
literal|"  Skip anchors: 0x%.8x"
argument_list|,
name|skipanchors
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|addAnchorsToEngine
name|void
name|QRegExpEngine
operator|::
name|Box
operator|::
name|addAnchorsToEngine
parameter_list|(
specifier|const
name|Box
modifier|&
name|to
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|to
operator|.
name|ls
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|rs
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|int
name|a
init|=
name|eng
operator|->
name|anchorConcatenation
argument_list|(
name|ranchors
operator|.
name|value
argument_list|(
name|rs
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|to
operator|.
name|lanchors
operator|.
name|value
argument_list|(
name|to
operator|.
name|ls
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|eng
operator|->
name|addAnchors
argument_list|(
name|rs
index|[
name|j
index|]
argument_list|,
name|to
operator|.
name|ls
index|[
name|i
index|]
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
end_ifndef
begin_comment
comment|// fast lookup hash for xml schema extensions
end_comment
begin_comment
comment|// sorted by name for b-search
end_comment
begin_struct
DECL|struct|CategoriesRangeMapEntry
specifier|static
specifier|const
struct|struct
name|CategoriesRangeMapEntry
block|{
DECL|member|name
specifier|const
name|char
name|name
index|[
literal|40
index|]
decl_stmt|;
DECL|member|first
DECL|member|second
name|uint
name|first
decl_stmt|,
name|second
decl_stmt|;
block|}
DECL|variable|categoriesRangeMap
name|categoriesRangeMap
index|[]
init|=
block|{
block|{
literal|"AegeanNumbers"
block|,
literal|0x10100
block|,
literal|0x1013F
block|}
block|,
block|{
literal|"AlphabeticPresentationForms"
block|,
literal|0xFB00
block|,
literal|0xFB4F
block|}
block|,
block|{
literal|"AncientGreekMusicalNotation"
block|,
literal|0x1D200
block|,
literal|0x1D24F
block|}
block|,
block|{
literal|"AncientGreekNumbers"
block|,
literal|0x10140
block|,
literal|0x1018F
block|}
block|,
block|{
literal|"Arabic"
block|,
literal|0x0600
block|,
literal|0x06FF
block|}
block|,
block|{
literal|"ArabicPresentationForms-A"
block|,
literal|0xFB50
block|,
literal|0xFDFF
block|}
block|,
block|{
literal|"ArabicPresentationForms-B"
block|,
literal|0xFE70
block|,
literal|0xFEFF
block|}
block|,
block|{
literal|"ArabicSupplement"
block|,
literal|0x0750
block|,
literal|0x077F
block|}
block|,
block|{
literal|"Armenian"
block|,
literal|0x0530
block|,
literal|0x058F
block|}
block|,
block|{
literal|"Arrows"
block|,
literal|0x2190
block|,
literal|0x21FF
block|}
block|,
block|{
literal|"BasicLatin"
block|,
literal|0x0000
block|,
literal|0x007F
block|}
block|,
block|{
literal|"Bengali"
block|,
literal|0x0980
block|,
literal|0x09FF
block|}
block|,
block|{
literal|"BlockElements"
block|,
literal|0x2580
block|,
literal|0x259F
block|}
block|,
block|{
literal|"Bopomofo"
block|,
literal|0x3100
block|,
literal|0x312F
block|}
block|,
block|{
literal|"BopomofoExtended"
block|,
literal|0x31A0
block|,
literal|0x31BF
block|}
block|,
block|{
literal|"BoxDrawing"
block|,
literal|0x2500
block|,
literal|0x257F
block|}
block|,
block|{
literal|"BraillePatterns"
block|,
literal|0x2800
block|,
literal|0x28FF
block|}
block|,
block|{
literal|"Buginese"
block|,
literal|0x1A00
block|,
literal|0x1A1F
block|}
block|,
block|{
literal|"Buhid"
block|,
literal|0x1740
block|,
literal|0x175F
block|}
block|,
block|{
literal|"ByzantineMusicalSymbols"
block|,
literal|0x1D000
block|,
literal|0x1D0FF
block|}
block|,
block|{
literal|"CJKCompatibility"
block|,
literal|0x3300
block|,
literal|0x33FF
block|}
block|,
block|{
literal|"CJKCompatibilityForms"
block|,
literal|0xFE30
block|,
literal|0xFE4F
block|}
block|,
block|{
literal|"CJKCompatibilityIdeographs"
block|,
literal|0xF900
block|,
literal|0xFAFF
block|}
block|,
block|{
literal|"CJKCompatibilityIdeographsSupplement"
block|,
literal|0x2F800
block|,
literal|0x2FA1F
block|}
block|,
block|{
literal|"CJKRadicalsSupplement"
block|,
literal|0x2E80
block|,
literal|0x2EFF
block|}
block|,
block|{
literal|"CJKStrokes"
block|,
literal|0x31C0
block|,
literal|0x31EF
block|}
block|,
block|{
literal|"CJKSymbolsandPunctuation"
block|,
literal|0x3000
block|,
literal|0x303F
block|}
block|,
block|{
literal|"CJKUnifiedIdeographs"
block|,
literal|0x4E00
block|,
literal|0x9FFF
block|}
block|,
block|{
literal|"CJKUnifiedIdeographsExtensionA"
block|,
literal|0x3400
block|,
literal|0x4DB5
block|}
block|,
block|{
literal|"CJKUnifiedIdeographsExtensionB"
block|,
literal|0x20000
block|,
literal|0x2A6DF
block|}
block|,
block|{
literal|"Cherokee"
block|,
literal|0x13A0
block|,
literal|0x13FF
block|}
block|,
block|{
literal|"CombiningDiacriticalMarks"
block|,
literal|0x0300
block|,
literal|0x036F
block|}
block|,
block|{
literal|"CombiningDiacriticalMarksSupplement"
block|,
literal|0x1DC0
block|,
literal|0x1DFF
block|}
block|,
block|{
literal|"CombiningHalfMarks"
block|,
literal|0xFE20
block|,
literal|0xFE2F
block|}
block|,
block|{
literal|"CombiningMarksforSymbols"
block|,
literal|0x20D0
block|,
literal|0x20FF
block|}
block|,
block|{
literal|"ControlPictures"
block|,
literal|0x2400
block|,
literal|0x243F
block|}
block|,
block|{
literal|"Coptic"
block|,
literal|0x2C80
block|,
literal|0x2CFF
block|}
block|,
block|{
literal|"CurrencySymbols"
block|,
literal|0x20A0
block|,
literal|0x20CF
block|}
block|,
block|{
literal|"CypriotSyllabary"
block|,
literal|0x10800
block|,
literal|0x1083F
block|}
block|,
block|{
literal|"Cyrillic"
block|,
literal|0x0400
block|,
literal|0x04FF
block|}
block|,
block|{
literal|"CyrillicSupplement"
block|,
literal|0x0500
block|,
literal|0x052F
block|}
block|,
block|{
literal|"Deseret"
block|,
literal|0x10400
block|,
literal|0x1044F
block|}
block|,
block|{
literal|"Devanagari"
block|,
literal|0x0900
block|,
literal|0x097F
block|}
block|,
block|{
literal|"Dingbats"
block|,
literal|0x2700
block|,
literal|0x27BF
block|}
block|,
block|{
literal|"EnclosedAlphanumerics"
block|,
literal|0x2460
block|,
literal|0x24FF
block|}
block|,
block|{
literal|"EnclosedCJKLettersandMonths"
block|,
literal|0x3200
block|,
literal|0x32FF
block|}
block|,
block|{
literal|"Ethiopic"
block|,
literal|0x1200
block|,
literal|0x137F
block|}
block|,
block|{
literal|"EthiopicExtended"
block|,
literal|0x2D80
block|,
literal|0x2DDF
block|}
block|,
block|{
literal|"EthiopicSupplement"
block|,
literal|0x1380
block|,
literal|0x139F
block|}
block|,
block|{
literal|"GeneralPunctuation"
block|,
literal|0x2000
block|,
literal|0x206F
block|}
block|,
block|{
literal|"GeometricShapes"
block|,
literal|0x25A0
block|,
literal|0x25FF
block|}
block|,
block|{
literal|"Georgian"
block|,
literal|0x10A0
block|,
literal|0x10FF
block|}
block|,
block|{
literal|"GeorgianSupplement"
block|,
literal|0x2D00
block|,
literal|0x2D2F
block|}
block|,
block|{
literal|"Glagolitic"
block|,
literal|0x2C00
block|,
literal|0x2C5F
block|}
block|,
block|{
literal|"Gothic"
block|,
literal|0x10330
block|,
literal|0x1034F
block|}
block|,
block|{
literal|"Greek"
block|,
literal|0x0370
block|,
literal|0x03FF
block|}
block|,
block|{
literal|"GreekExtended"
block|,
literal|0x1F00
block|,
literal|0x1FFF
block|}
block|,
block|{
literal|"Gujarati"
block|,
literal|0x0A80
block|,
literal|0x0AFF
block|}
block|,
block|{
literal|"Gurmukhi"
block|,
literal|0x0A00
block|,
literal|0x0A7F
block|}
block|,
block|{
literal|"HalfwidthandFullwidthForms"
block|,
literal|0xFF00
block|,
literal|0xFFEF
block|}
block|,
block|{
literal|"HangulCompatibilityJamo"
block|,
literal|0x3130
block|,
literal|0x318F
block|}
block|,
block|{
literal|"HangulJamo"
block|,
literal|0x1100
block|,
literal|0x11FF
block|}
block|,
block|{
literal|"HangulSyllables"
block|,
literal|0xAC00
block|,
literal|0xD7A3
block|}
block|,
block|{
literal|"Hanunoo"
block|,
literal|0x1720
block|,
literal|0x173F
block|}
block|,
block|{
literal|"Hebrew"
block|,
literal|0x0590
block|,
literal|0x05FF
block|}
block|,
block|{
literal|"Hiragana"
block|,
literal|0x3040
block|,
literal|0x309F
block|}
block|,
block|{
literal|"IPAExtensions"
block|,
literal|0x0250
block|,
literal|0x02AF
block|}
block|,
block|{
literal|"IdeographicDescriptionCharacters"
block|,
literal|0x2FF0
block|,
literal|0x2FFF
block|}
block|,
block|{
literal|"Kanbun"
block|,
literal|0x3190
block|,
literal|0x319F
block|}
block|,
block|{
literal|"KangxiRadicals"
block|,
literal|0x2F00
block|,
literal|0x2FDF
block|}
block|,
block|{
literal|"Kannada"
block|,
literal|0x0C80
block|,
literal|0x0CFF
block|}
block|,
block|{
literal|"Katakana"
block|,
literal|0x30A0
block|,
literal|0x30FF
block|}
block|,
block|{
literal|"KatakanaPhoneticExtensions"
block|,
literal|0x31F0
block|,
literal|0x31FF
block|}
block|,
block|{
literal|"Kharoshthi"
block|,
literal|0x10A00
block|,
literal|0x10A5F
block|}
block|,
block|{
literal|"Khmer"
block|,
literal|0x1780
block|,
literal|0x17FF
block|}
block|,
block|{
literal|"KhmerSymbols"
block|,
literal|0x19E0
block|,
literal|0x19FF
block|}
block|,
block|{
literal|"Lao"
block|,
literal|0x0E80
block|,
literal|0x0EFF
block|}
block|,
block|{
literal|"Latin-1Supplement"
block|,
literal|0x0080
block|,
literal|0x00FF
block|}
block|,
block|{
literal|"LatinExtended-A"
block|,
literal|0x0100
block|,
literal|0x017F
block|}
block|,
block|{
literal|"LatinExtended-B"
block|,
literal|0x0180
block|,
literal|0x024F
block|}
block|,
block|{
literal|"LatinExtendedAdditional"
block|,
literal|0x1E00
block|,
literal|0x1EFF
block|}
block|,
block|{
literal|"LetterlikeSymbols"
block|,
literal|0x2100
block|,
literal|0x214F
block|}
block|,
block|{
literal|"Limbu"
block|,
literal|0x1900
block|,
literal|0x194F
block|}
block|,
block|{
literal|"LinearBIdeograms"
block|,
literal|0x10080
block|,
literal|0x100FF
block|}
block|,
block|{
literal|"LinearBSyllabary"
block|,
literal|0x10000
block|,
literal|0x1007F
block|}
block|,
block|{
literal|"Malayalam"
block|,
literal|0x0D00
block|,
literal|0x0D7F
block|}
block|,
block|{
literal|"MathematicalAlphanumericSymbols"
block|,
literal|0x1D400
block|,
literal|0x1D7FF
block|}
block|,
block|{
literal|"MathematicalOperators"
block|,
literal|0x2200
block|,
literal|0x22FF
block|}
block|,
block|{
literal|"MiscellaneousMathematicalSymbols-A"
block|,
literal|0x27C0
block|,
literal|0x27EF
block|}
block|,
block|{
literal|"MiscellaneousMathematicalSymbols-B"
block|,
literal|0x2980
block|,
literal|0x29FF
block|}
block|,
block|{
literal|"MiscellaneousSymbols"
block|,
literal|0x2600
block|,
literal|0x26FF
block|}
block|,
block|{
literal|"MiscellaneousSymbolsandArrows"
block|,
literal|0x2B00
block|,
literal|0x2BFF
block|}
block|,
block|{
literal|"MiscellaneousTechnical"
block|,
literal|0x2300
block|,
literal|0x23FF
block|}
block|,
block|{
literal|"ModifierToneLetters"
block|,
literal|0xA700
block|,
literal|0xA71F
block|}
block|,
block|{
literal|"Mongolian"
block|,
literal|0x1800
block|,
literal|0x18AF
block|}
block|,
block|{
literal|"MusicalSymbols"
block|,
literal|0x1D100
block|,
literal|0x1D1FF
block|}
block|,
block|{
literal|"Myanmar"
block|,
literal|0x1000
block|,
literal|0x109F
block|}
block|,
block|{
literal|"NewTaiLue"
block|,
literal|0x1980
block|,
literal|0x19DF
block|}
block|,
block|{
literal|"NumberForms"
block|,
literal|0x2150
block|,
literal|0x218F
block|}
block|,
block|{
literal|"Ogham"
block|,
literal|0x1680
block|,
literal|0x169F
block|}
block|,
block|{
literal|"OldItalic"
block|,
literal|0x10300
block|,
literal|0x1032F
block|}
block|,
block|{
literal|"OldPersian"
block|,
literal|0x103A0
block|,
literal|0x103DF
block|}
block|,
block|{
literal|"OpticalCharacterRecognition"
block|,
literal|0x2440
block|,
literal|0x245F
block|}
block|,
block|{
literal|"Oriya"
block|,
literal|0x0B00
block|,
literal|0x0B7F
block|}
block|,
block|{
literal|"Osmanya"
block|,
literal|0x10480
block|,
literal|0x104AF
block|}
block|,
block|{
literal|"PhoneticExtensions"
block|,
literal|0x1D00
block|,
literal|0x1D7F
block|}
block|,
block|{
literal|"PhoneticExtensionsSupplement"
block|,
literal|0x1D80
block|,
literal|0x1DBF
block|}
block|,
block|{
literal|"PrivateUse"
block|,
literal|0xE000
block|,
literal|0xF8FF
block|}
block|,
block|{
literal|"Runic"
block|,
literal|0x16A0
block|,
literal|0x16FF
block|}
block|,
block|{
literal|"Shavian"
block|,
literal|0x10450
block|,
literal|0x1047F
block|}
block|,
block|{
literal|"Sinhala"
block|,
literal|0x0D80
block|,
literal|0x0DFF
block|}
block|,
block|{
literal|"SmallFormVariants"
block|,
literal|0xFE50
block|,
literal|0xFE6F
block|}
block|,
block|{
literal|"SpacingModifierLetters"
block|,
literal|0x02B0
block|,
literal|0x02FF
block|}
block|,
block|{
literal|"Specials"
block|,
literal|0xFFF0
block|,
literal|0xFFFF
block|}
block|,
block|{
literal|"SuperscriptsandSubscripts"
block|,
literal|0x2070
block|,
literal|0x209F
block|}
block|,
block|{
literal|"SupplementalArrows-A"
block|,
literal|0x27F0
block|,
literal|0x27FF
block|}
block|,
block|{
literal|"SupplementalArrows-B"
block|,
literal|0x2900
block|,
literal|0x297F
block|}
block|,
block|{
literal|"SupplementalMathematicalOperators"
block|,
literal|0x2A00
block|,
literal|0x2AFF
block|}
block|,
block|{
literal|"SupplementalPunctuation"
block|,
literal|0x2E00
block|,
literal|0x2E7F
block|}
block|,
block|{
literal|"SupplementaryPrivateUseArea-A"
block|,
literal|0xF0000
block|,
literal|0xFFFFF
block|}
block|,
block|{
literal|"SupplementaryPrivateUseArea-B"
block|,
literal|0x100000
block|,
literal|0x10FFFF
block|}
block|,
block|{
literal|"SylotiNagri"
block|,
literal|0xA800
block|,
literal|0xA82F
block|}
block|,
block|{
literal|"Syriac"
block|,
literal|0x0700
block|,
literal|0x074F
block|}
block|,
block|{
literal|"Tagalog"
block|,
literal|0x1700
block|,
literal|0x171F
block|}
block|,
block|{
literal|"Tagbanwa"
block|,
literal|0x1760
block|,
literal|0x177F
block|}
block|,
block|{
literal|"Tags"
block|,
literal|0xE0000
block|,
literal|0xE007F
block|}
block|,
block|{
literal|"TaiLe"
block|,
literal|0x1950
block|,
literal|0x197F
block|}
block|,
block|{
literal|"TaiXuanJingSymbols"
block|,
literal|0x1D300
block|,
literal|0x1D35F
block|}
block|,
block|{
literal|"Tamil"
block|,
literal|0x0B80
block|,
literal|0x0BFF
block|}
block|,
block|{
literal|"Telugu"
block|,
literal|0x0C00
block|,
literal|0x0C7F
block|}
block|,
block|{
literal|"Thaana"
block|,
literal|0x0780
block|,
literal|0x07BF
block|}
block|,
block|{
literal|"Thai"
block|,
literal|0x0E00
block|,
literal|0x0E7F
block|}
block|,
block|{
literal|"Tibetan"
block|,
literal|0x0F00
block|,
literal|0x0FFF
block|}
block|,
block|{
literal|"Tifinagh"
block|,
literal|0x2D30
block|,
literal|0x2D7F
block|}
block|,
block|{
literal|"Ugaritic"
block|,
literal|0x10380
block|,
literal|0x1039F
block|}
block|,
block|{
literal|"UnifiedCanadianAboriginalSyllabics"
block|,
literal|0x1400
block|,
literal|0x167F
block|}
block|,
block|{
literal|"VariationSelectors"
block|,
literal|0xFE00
block|,
literal|0xFE0F
block|}
block|,
block|{
literal|"VariationSelectorsSupplement"
block|,
literal|0xE0100
block|,
literal|0xE01EF
block|}
block|,
block|{
literal|"VerticalForms"
block|,
literal|0xFE10
block|,
literal|0xFE1F
block|}
block|,
block|{
literal|"YiRadicals"
block|,
literal|0xA490
block|,
literal|0xA4CF
block|}
block|,
block|{
literal|"YiSyllables"
block|,
literal|0xA000
block|,
literal|0xA48F
block|}
block|,
block|{
literal|"YijingHexagramSymbols"
block|,
literal|0x4DC0
block|,
literal|0x4DFF
block|}
block|}
struct|;
end_struct
begin_function
DECL|function|operator <
specifier|inline
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|CategoriesRangeMapEntry
modifier|&
name|entry
parameter_list|)
block|{
return|return
name|qstrcmp
argument_list|(
name|name
argument_list|,
name|entry
operator|.
name|name
argument_list|)
operator|<
literal|0
return|;
block|}
end_function
begin_function
DECL|function|operator <
specifier|inline
name|bool
name|operator
name|<
parameter_list|(
specifier|const
name|CategoriesRangeMapEntry
modifier|&
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|qstrcmp
argument_list|(
name|entry
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|<
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGEXP_CCLASS
end_comment
begin_function
DECL|function|getChar
name|int
name|QRegExpEngine
operator|::
name|getChar
parameter_list|()
block|{
return|return
operator|(
name|yyPos
operator|==
name|yyLen
operator|)
condition|?
name|EOS
else|:
name|yyIn
index|[
name|yyPos
operator|++
index|]
operator|.
name|unicode
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|getEscape
name|int
name|QRegExpEngine
operator|::
name|getEscape
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ESCAPE
specifier|const
name|char
name|tab
index|[]
init|=
literal|"afnrtv"
decl_stmt|;
comment|// no b, as \b means word boundary
specifier|const
name|char
name|backTab
index|[]
init|=
literal|"\a\f\n\r\t\v"
decl_stmt|;
name|ushort
name|low
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|ushort
name|val
decl_stmt|;
name|int
name|prevCh
init|=
name|yyCh
decl_stmt|;
if|if
condition|(
name|prevCh
operator|==
name|EOS
condition|)
block|{
name|error
argument_list|(
name|RXERR_END
argument_list|)
expr_stmt|;
return|return
name|Tok_Char
operator||
literal|'\\'
return|;
block|}
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ESCAPE
if|if
condition|(
operator|(
name|prevCh
operator|&
operator|~
literal|0xff
operator|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|tab
argument_list|,
name|prevCh
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
return|return
name|Tok_Char
operator||
name|backTab
index|[
name|p
operator|-
name|tab
index|]
return|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|prevCh
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ESCAPE
case|case
literal|'0'
case|:
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|yyCh
operator|>=
literal|'0'
operator|&&
name|yyCh
operator|<=
literal|'7'
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|3
operator|)
operator||
operator|(
name|yyCh
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
break|break;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
operator|~
literal|0377
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|RXERR_OCTAL
argument_list|)
expr_stmt|;
return|return
name|Tok_Char
operator||
name|val
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ESCAPE
case|case
literal|'B'
case|:
return|return
name|Tok_NonWord
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
case|case
literal|'D'
case|:
comment|// see QChar::isDigit()
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|uint
argument_list|(
operator|-
literal|1
argument_list|)
operator|^
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_DecimalDigit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Tok_CharClass
return|;
case|case
literal|'S'
case|:
comment|// see QChar::isSpace()
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|uint
argument_list|(
operator|-
literal|1
argument_list|)
operator|^
operator|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Space
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Line
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Paragraph
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_Control
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x0000
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x000e
argument_list|,
literal|0x001f
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x007f
argument_list|,
literal|0x0084
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x0086
argument_list|,
literal|0x009f
argument_list|)
expr_stmt|;
return|return
name|Tok_CharClass
return|;
case|case
literal|'W'
case|:
comment|// see QChar::isLetterOrNumber() and QChar::isMark()
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|uint
argument_list|(
operator|-
literal|1
argument_list|)
operator|^
operator|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_NonSpacing
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_SpacingCombining
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_Enclosing
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_DecimalDigit
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Letter
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Other
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Uppercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Lowercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Titlecase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Modifier
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Other
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Connector
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x203f
argument_list|,
literal|0x2040
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0x2040
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0x2054
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0x30fb
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0xfe33
argument_list|,
literal|0xfe34
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0xfe4d
argument_list|,
literal|0xfe4f
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0xff3f
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0xff65
argument_list|)
expr_stmt|;
return|return
name|Tok_CharClass
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ESCAPE
case|case
literal|'b'
case|:
return|return
name|Tok_Word
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
case|case
literal|'d'
case|:
comment|// see QChar::isDigit()
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_DecimalDigit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Tok_CharClass
return|;
case|case
literal|'s'
case|:
comment|// see QChar::isSpace()
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Space
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Line
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Paragraph
argument_list|)
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x0009
argument_list|,
literal|0x000d
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0x0085
argument_list|)
expr_stmt|;
return|return
name|Tok_CharClass
return|;
case|case
literal|'w'
case|:
comment|// see QChar::isLetterOrNumber() and QChar::isMark()
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_NonSpacing
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_SpacingCombining
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_Enclosing
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_DecimalDigit
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Letter
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Other
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Uppercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Lowercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Titlecase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Modifier
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Other
argument_list|)
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0x005f
argument_list|)
expr_stmt|;
comment|// '_'
return|return
name|Tok_CharClass
return|;
case|case
literal|'I'
case|:
if|if
condition|(
name|xmlSchemaExtensions
condition|)
block|{
name|yyCharClass
operator|->
name|setNegative
argument_list|(
operator|!
name|yyCharClass
operator|->
name|negative
argument_list|()
argument_list|)
expr_stmt|;
comment|// fall through
block|}
case|case
literal|'i'
case|:
if|if
condition|(
name|xmlSchemaExtensions
condition|)
block|{
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_NonSpacing
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_SpacingCombining
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_Enclosing
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_DecimalDigit
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Letter
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Other
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Uppercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Lowercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Titlecase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Modifier
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Other
argument_list|)
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0x003a
argument_list|)
expr_stmt|;
comment|// ':'
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0x005f
argument_list|)
expr_stmt|;
comment|// '_'
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x0041
argument_list|,
literal|0x005a
argument_list|)
expr_stmt|;
comment|// [A-Z]
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x0061
argument_list|,
literal|0x007a
argument_list|)
expr_stmt|;
comment|// [a-z]
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0xc0
argument_list|,
literal|0xd6
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0xd8
argument_list|,
literal|0xf6
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0xf8
argument_list|,
literal|0x2ff
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x370
argument_list|,
literal|0x37d
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x37f
argument_list|,
literal|0x1fff
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x200c
argument_list|,
literal|0x200d
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x2070
argument_list|,
literal|0x218f
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x2c00
argument_list|,
literal|0x2fef
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x3001
argument_list|,
literal|0xd7ff
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0xf900
argument_list|,
literal|0xfdcf
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0xfdf0
argument_list|,
literal|0xfffd
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
operator|(
name|ushort
operator|)
literal|0x10000
argument_list|,
operator|(
name|ushort
operator|)
literal|0xeffff
argument_list|)
expr_stmt|;
block|}
return|return
name|Tok_CharClass
return|;
case|case
literal|'C'
case|:
if|if
condition|(
name|xmlSchemaExtensions
condition|)
block|{
name|yyCharClass
operator|->
name|setNegative
argument_list|(
operator|!
name|yyCharClass
operator|->
name|negative
argument_list|()
argument_list|)
expr_stmt|;
comment|// fall through
block|}
case|case
literal|'c'
case|:
if|if
condition|(
name|xmlSchemaExtensions
condition|)
block|{
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_NonSpacing
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_SpacingCombining
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_Enclosing
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_DecimalDigit
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Letter
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Other
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Uppercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Lowercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Titlecase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Modifier
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Other
argument_list|)
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0x002d
argument_list|)
expr_stmt|;
comment|// '-'
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0x002e
argument_list|)
expr_stmt|;
comment|// '.'
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0x003a
argument_list|)
expr_stmt|;
comment|// ':'
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0x005f
argument_list|)
expr_stmt|;
comment|// '_'
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|0xb7
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x0030
argument_list|,
literal|0x0039
argument_list|)
expr_stmt|;
comment|// [0-9]
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x0041
argument_list|,
literal|0x005a
argument_list|)
expr_stmt|;
comment|// [A-Z]
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x0061
argument_list|,
literal|0x007a
argument_list|)
expr_stmt|;
comment|// [a-z]
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0xc0
argument_list|,
literal|0xd6
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0xd8
argument_list|,
literal|0xf6
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0xf8
argument_list|,
literal|0x2ff
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x370
argument_list|,
literal|0x37d
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x37f
argument_list|,
literal|0x1fff
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x200c
argument_list|,
literal|0x200d
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x2070
argument_list|,
literal|0x218f
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x2c00
argument_list|,
literal|0x2fef
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x3001
argument_list|,
literal|0xd7ff
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0xf900
argument_list|,
literal|0xfdcf
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0xfdf0
argument_list|,
literal|0xfffd
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
operator|(
name|ushort
operator|)
literal|0x10000
argument_list|,
operator|(
name|ushort
operator|)
literal|0xeffff
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x0300
argument_list|,
literal|0x036f
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addRange
argument_list|(
literal|0x203f
argument_list|,
literal|0x2040
argument_list|)
expr_stmt|;
block|}
return|return
name|Tok_CharClass
return|;
case|case
literal|'P'
case|:
if|if
condition|(
name|xmlSchemaExtensions
condition|)
block|{
name|yyCharClass
operator|->
name|setNegative
argument_list|(
operator|!
name|yyCharClass
operator|->
name|negative
argument_list|()
argument_list|)
expr_stmt|;
comment|// fall through
block|}
case|case
literal|'p'
case|:
if|if
condition|(
name|xmlSchemaExtensions
condition|)
block|{
if|if
condition|(
name|yyCh
operator|!=
literal|'{'
condition|)
block|{
name|error
argument_list|(
name|RXERR_CHARCLASS
argument_list|)
expr_stmt|;
return|return
name|Tok_CharClass
return|;
block|}
name|QByteArray
name|category
decl_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
while|while
condition|(
name|yyCh
operator|!=
literal|'}'
condition|)
block|{
if|if
condition|(
name|yyCh
operator|==
name|EOS
condition|)
block|{
name|error
argument_list|(
name|RXERR_END
argument_list|)
expr_stmt|;
return|return
name|Tok_CharClass
return|;
block|}
name|category
operator|.
name|append
argument_list|(
name|yyCh
argument_list|)
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
comment|// skip closing '}'
name|int
name|catlen
init|=
name|category
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|catlen
operator|==
literal|1
operator|||
name|catlen
operator|==
literal|2
condition|)
block|{
switch|switch
condition|(
name|category
operator|.
name|at
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
literal|'M'
case|:
if|if
condition|(
name|catlen
operator|==
literal|1
condition|)
block|{
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_NonSpacing
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_SpacingCombining
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_Enclosing
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|category
operator|.
name|at
argument_list|(
literal|1
argument_list|)
condition|)
block|{
case|case
literal|'n'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_NonSpacing
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Mn
case|case
literal|'c'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_SpacingCombining
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Mc
case|case
literal|'e'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Mark_Enclosing
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Me
default|default:
name|error
argument_list|(
name|RXERR_CATEGORY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|catlen
operator|==
literal|1
condition|)
block|{
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_DecimalDigit
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Letter
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Other
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|category
operator|.
name|at
argument_list|(
literal|1
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_DecimalDigit
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Nd
case|case
literal|'l'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Letter
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Hl
case|case
literal|'o'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Number_Other
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// No
default|default:
name|error
argument_list|(
name|RXERR_CATEGORY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'Z'
case|:
if|if
condition|(
name|catlen
operator|==
literal|1
condition|)
block|{
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Space
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Line
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Paragraph
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|category
operator|.
name|at
argument_list|(
literal|1
argument_list|)
condition|)
block|{
case|case
literal|'s'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Space
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Zs
case|case
literal|'l'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Line
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Zl
case|case
literal|'p'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Separator_Paragraph
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Zp
default|default:
name|error
argument_list|(
name|RXERR_CATEGORY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|catlen
operator|==
literal|1
condition|)
block|{
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_Control
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_Format
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_Surrogate
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_PrivateUse
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_NotAssigned
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|category
operator|.
name|at
argument_list|(
literal|1
argument_list|)
condition|)
block|{
case|case
literal|'c'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_Control
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Cc
case|case
literal|'f'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_Format
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Cf
case|case
literal|'s'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_Surrogate
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Cs
case|case
literal|'o'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_PrivateUse
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Co
case|case
literal|'n'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Other_NotAssigned
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Cn
default|default:
name|error
argument_list|(
name|RXERR_CATEGORY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
name|catlen
operator|==
literal|1
condition|)
block|{
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Uppercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Lowercase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Titlecase
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Modifier
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Other
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|category
operator|.
name|at
argument_list|(
literal|1
argument_list|)
condition|)
block|{
case|case
literal|'u'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Uppercase
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Lu
case|case
literal|'l'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Lowercase
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Ll
case|case
literal|'t'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Titlecase
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Lt
case|case
literal|'m'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Modifier
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Lm
case|case
literal|'o'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Letter_Other
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Lo
default|default:
name|error
argument_list|(
name|RXERR_CATEGORY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|catlen
operator|==
literal|1
condition|)
block|{
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Connector
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Dash
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Open
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Close
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_InitialQuote
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_FinalQuote
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Other
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|category
operator|.
name|at
argument_list|(
literal|1
argument_list|)
condition|)
block|{
case|case
literal|'c'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Connector
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Pc
case|case
literal|'d'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Dash
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Pd
case|case
literal|'s'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Open
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Ps
case|case
literal|'e'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Close
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Pe
case|case
literal|'i'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_InitialQuote
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Pi
case|case
literal|'f'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_FinalQuote
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Pf
case|case
literal|'o'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Punctuation_Other
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Po
default|default:
name|error
argument_list|(
name|RXERR_CATEGORY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|catlen
operator|==
literal|1
condition|)
block|{
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Symbol_Math
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Symbol_Currency
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Symbol_Modifier
argument_list|)
operator||
name|FLAG
argument_list|(
name|QChar
operator|::
name|Symbol_Other
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|category
operator|.
name|at
argument_list|(
literal|1
argument_list|)
condition|)
block|{
case|case
literal|'m'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Symbol_Math
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Sm
case|case
literal|'c'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Symbol_Currency
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Sc
case|case
literal|'k'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Symbol_Modifier
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Sk
case|case
literal|'o'
case|:
name|yyCharClass
operator|->
name|addCategories
argument_list|(
name|FLAG
argument_list|(
name|QChar
operator|::
name|Symbol_Other
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// So
default|default:
name|error
argument_list|(
name|RXERR_CATEGORY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
name|error
argument_list|(
name|RXERR_CATEGORY
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|catlen
operator|>
literal|2
operator|&&
name|category
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'I'
operator|&&
name|category
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|==
literal|'s'
condition|)
block|{
specifier|static
specifier|const
name|int
name|N
init|=
sizeof|sizeof
argument_list|(
name|categoriesRangeMap
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|categoriesRangeMap
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|const
name|CategoriesRangeMapEntry
modifier|*
name|r
init|=
name|qBinaryFind
argument_list|(
name|categoriesRangeMap
argument_list|,
name|categoriesRangeMap
operator|+
name|N
argument_list|,
name|category
operator|.
name|constData
argument_list|()
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
name|categoriesRangeMap
operator|+
name|N
condition|)
name|yyCharClass
operator|->
name|addRange
argument_list|(
name|r
operator|->
name|first
argument_list|,
name|r
operator|->
name|second
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|RXERR_CATEGORY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|RXERR_CATEGORY
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Tok_CharClass
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ESCAPE
case|case
literal|'x'
case|:
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|low
operator|=
name|QChar
argument_list|(
name|yyCh
argument_list|)
operator|.
name|toLower
argument_list|()
operator|.
name|unicode
argument_list|()
expr_stmt|;
if|if
condition|(
name|low
operator|>=
literal|'0'
operator|&&
name|low
operator|<=
literal|'9'
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator||
operator|(
name|low
operator|-
literal|'0'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|low
operator|>=
literal|'a'
operator|&&
name|low
operator|<=
literal|'f'
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator||
operator|(
name|low
operator|-
literal|'a'
operator|+
literal|10
operator|)
expr_stmt|;
else|else
break|break;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
return|return
name|Tok_Char
operator||
name|val
return|;
endif|#
directive|endif
default|default:
if|if
condition|(
name|prevCh
operator|>=
literal|'1'
operator|&&
name|prevCh
operator|<=
literal|'9'
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
name|val
operator|=
name|prevCh
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|yyCh
operator|>=
literal|'0'
operator|&&
name|yyCh
operator|<=
literal|'9'
condition|)
block|{
name|val
operator|=
operator|(
name|val
operator|*
literal|10
operator|)
operator|+
operator|(
name|yyCh
operator|-
literal|'0'
operator|)
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
return|return
name|Tok_BackRef
operator||
name|val
return|;
else|#
directive|else
name|error
argument_list|(
name|RXERR_DISABLED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|Tok_Char
operator||
name|prevCh
return|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_INTERVAL
end_ifndef
begin_function
DECL|function|getRep
name|int
name|QRegExpEngine
operator|::
name|getRep
parameter_list|(
name|int
name|def
parameter_list|)
block|{
if|if
condition|(
name|yyCh
operator|>=
literal|'0'
operator|&&
name|yyCh
operator|<=
literal|'9'
condition|)
block|{
name|int
name|rep
init|=
literal|0
decl_stmt|;
do|do
block|{
name|rep
operator|=
literal|10
operator|*
name|rep
operator|+
name|yyCh
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|rep
operator|>=
name|InftyRep
condition|)
block|{
name|error
argument_list|(
name|RXERR_REPETITION
argument_list|)
expr_stmt|;
name|rep
operator|=
name|def
expr_stmt|;
block|}
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|yyCh
operator|>=
literal|'0'
operator|&&
name|yyCh
operator|<=
literal|'9'
condition|)
do|;
return|return
name|rep
return|;
block|}
else|else
block|{
return|return
name|def
return|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_LOOKAHEAD
end_ifndef
begin_function
DECL|function|skipChars
name|void
name|QRegExpEngine
operator|::
name|skipChars
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|yyPos
operator|+=
name|n
operator|-
literal|1
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|error
name|void
name|QRegExpEngine
operator|::
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|yyError
operator|.
name|isEmpty
argument_list|()
condition|)
name|yyError
operator|=
name|QLatin1String
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|startTokenizer
name|void
name|QRegExpEngine
operator|::
name|startTokenizer
parameter_list|(
specifier|const
name|QChar
modifier|*
name|rx
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|yyIn
operator|=
name|rx
expr_stmt|;
name|yyPos0
operator|=
literal|0
expr_stmt|;
name|yyPos
operator|=
literal|0
expr_stmt|;
name|yyLen
operator|=
name|len
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
name|yyCharClass
operator|.
name|reset
argument_list|(
operator|new
name|QRegExpCharClass
argument_list|)
expr_stmt|;
name|yyMinRep
operator|=
literal|0
expr_stmt|;
name|yyMaxRep
operator|=
literal|0
expr_stmt|;
name|yyError
operator|=
name|QString
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getToken
name|int
name|QRegExpEngine
operator|::
name|getToken
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
name|ushort
name|pendingCh
init|=
literal|0
decl_stmt|;
name|bool
name|charPending
decl_stmt|;
name|bool
name|rangePending
decl_stmt|;
name|int
name|tok
decl_stmt|;
endif|#
directive|endif
name|int
name|prevCh
init|=
name|yyCh
decl_stmt|;
name|yyPos0
operator|=
name|yyPos
operator|-
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
name|yyCharClass
operator|->
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|yyMinRep
operator|=
literal|0
expr_stmt|;
name|yyMaxRep
operator|=
literal|0
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|prevCh
condition|)
block|{
case|case
name|EOS
case|:
name|yyPos0
operator|=
name|yyPos
expr_stmt|;
return|return
name|Tok_Eos
return|;
case|case
literal|'$'
case|:
return|return
name|Tok_Dollar
return|;
case|case
literal|'('
case|:
if|if
condition|(
name|yyCh
operator|==
literal|'?'
condition|)
block|{
name|prevCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|prevCh
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_LOOKAHEAD
case|case
literal|'!'
case|:
return|return
name|Tok_NegLookahead
return|;
case|case
literal|'='
case|:
return|return
name|Tok_PosLookahead
return|;
endif|#
directive|endif
case|case
literal|':'
case|:
return|return
name|Tok_MagicLeftParen
return|;
case|case
literal|'<'
case|:
name|error
argument_list|(
name|RXERR_LOOKBEHIND
argument_list|)
expr_stmt|;
return|return
name|Tok_MagicLeftParen
return|;
default|default:
name|error
argument_list|(
name|RXERR_LOOKAHEAD
argument_list|)
expr_stmt|;
return|return
name|Tok_MagicLeftParen
return|;
block|}
block|}
else|else
block|{
return|return
name|Tok_LeftParen
return|;
block|}
case|case
literal|')'
case|:
return|return
name|Tok_RightParen
return|;
case|case
literal|'*'
case|:
name|yyMinRep
operator|=
literal|0
expr_stmt|;
name|yyMaxRep
operator|=
name|InftyRep
expr_stmt|;
return|return
name|Tok_Quantifier
return|;
case|case
literal|'+'
case|:
name|yyMinRep
operator|=
literal|1
expr_stmt|;
name|yyMaxRep
operator|=
name|InftyRep
expr_stmt|;
return|return
name|Tok_Quantifier
return|;
case|case
literal|'.'
case|:
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
name|yyCharClass
operator|->
name|setNegative
argument_list|(
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|Tok_CharClass
return|;
case|case
literal|'?'
case|:
name|yyMinRep
operator|=
literal|0
expr_stmt|;
name|yyMaxRep
operator|=
literal|1
expr_stmt|;
return|return
name|Tok_Quantifier
return|;
case|case
literal|'['
case|:
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CCLASS
if|if
condition|(
name|yyCh
operator|==
literal|'^'
condition|)
block|{
name|yyCharClass
operator|->
name|setNegative
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
name|charPending
operator|=
literal|false
expr_stmt|;
name|rangePending
operator|=
literal|false
expr_stmt|;
do|do
block|{
if|if
condition|(
name|yyCh
operator|==
literal|'-'
operator|&&
name|charPending
operator|&&
operator|!
name|rangePending
condition|)
block|{
name|rangePending
operator|=
literal|true
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|charPending
operator|&&
operator|!
name|rangePending
condition|)
block|{
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
name|pendingCh
argument_list|)
expr_stmt|;
name|charPending
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|yyCh
operator|==
literal|'\\'
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
name|tok
operator|=
name|getEscape
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|Tok_Word
condition|)
name|tok
operator|=
literal|'\b'
expr_stmt|;
block|}
else|else
block|{
name|tok
operator|=
name|Tok_Char
operator||
name|yyCh
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|==
name|Tok_CharClass
condition|)
block|{
if|if
condition|(
name|rangePending
condition|)
block|{
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
name|pendingCh
argument_list|)
expr_stmt|;
name|charPending
operator|=
literal|false
expr_stmt|;
name|rangePending
operator|=
literal|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|tok
operator|&
name|Tok_Char
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rangePending
condition|)
block|{
name|yyCharClass
operator|->
name|addRange
argument_list|(
name|pendingCh
argument_list|,
name|tok
operator|^
name|Tok_Char
argument_list|)
expr_stmt|;
name|charPending
operator|=
literal|false
expr_stmt|;
name|rangePending
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|pendingCh
operator|=
name|tok
operator|^
name|Tok_Char
expr_stmt|;
name|charPending
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
name|RXERR_CHARCLASS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|yyCh
operator|!=
literal|']'
operator|&&
name|yyCh
operator|!=
name|EOS
condition|)
do|;
if|if
condition|(
name|rangePending
condition|)
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|charPending
condition|)
name|yyCharClass
operator|->
name|addSingleton
argument_list|(
name|pendingCh
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
name|EOS
condition|)
name|error
argument_list|(
name|RXERR_END
argument_list|)
expr_stmt|;
else|else
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_CharClass
return|;
else|#
directive|else
name|error
argument_list|(
name|RXERR_END
argument_list|)
expr_stmt|;
return|return
name|Tok_Char
operator||
literal|'['
return|;
endif|#
directive|endif
case|case
literal|'\\'
case|:
return|return
name|getEscape
argument_list|()
return|;
case|case
literal|']'
case|:
name|error
argument_list|(
name|RXERR_LEFTDELIM
argument_list|)
expr_stmt|;
return|return
name|Tok_Char
operator||
literal|']'
return|;
case|case
literal|'^'
case|:
return|return
name|Tok_Caret
return|;
case|case
literal|'{'
case|:
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_INTERVAL
name|yyMinRep
operator|=
name|getRep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|yyMaxRep
operator|=
name|yyMinRep
expr_stmt|;
if|if
condition|(
name|yyCh
operator|==
literal|','
condition|)
block|{
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
name|yyMaxRep
operator|=
name|getRep
argument_list|(
name|InftyRep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yyMaxRep
operator|<
name|yyMinRep
condition|)
name|error
argument_list|(
name|RXERR_INTERVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyCh
operator|!=
literal|'}'
condition|)
name|error
argument_list|(
name|RXERR_REPETITION
argument_list|)
expr_stmt|;
name|yyCh
operator|=
name|getChar
argument_list|()
expr_stmt|;
return|return
name|Tok_Quantifier
return|;
else|#
directive|else
name|error
argument_list|(
name|RXERR_DISABLED
argument_list|)
expr_stmt|;
return|return
name|Tok_Char
operator||
literal|'{'
return|;
endif|#
directive|endif
case|case
literal|'|'
case|:
return|return
name|Tok_Bar
return|;
case|case
literal|'}'
case|:
name|error
argument_list|(
name|RXERR_LEFTDELIM
argument_list|)
expr_stmt|;
return|return
name|Tok_Char
operator||
literal|'}'
return|;
default|default:
return|return
name|Tok_Char
operator||
name|prevCh
return|;
block|}
block|}
end_function
begin_function
DECL|function|parse
name|int
name|QRegExpEngine
operator|::
name|parse
parameter_list|(
specifier|const
name|QChar
modifier|*
name|pattern
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|valid
operator|=
literal|true
expr_stmt|;
name|startTokenizer
argument_list|(
name|pattern
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|yyTok
operator|=
name|getToken
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|yyMayCapture
operator|=
literal|true
expr_stmt|;
else|#
directive|else
name|yyMayCapture
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|int
name|atom
init|=
name|startAtom
argument_list|(
literal|false
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|QRegExpCharClass
name|anything
decl_stmt|;
name|Box
name|box
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|// create InitialState
name|box
operator|.
name|set
argument_list|(
name|anything
argument_list|)
expr_stmt|;
name|Box
name|rightBox
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|// create FinalState
name|rightBox
operator|.
name|set
argument_list|(
name|anything
argument_list|)
expr_stmt|;
name|Box
name|middleBox
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|parseExpression
argument_list|(
operator|&
name|middleBox
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|finishAtom
argument_list|(
name|atom
argument_list|,
literal|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|middleBox
operator|.
name|setupHeuristics
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|box
operator|.
name|cat
argument_list|(
name|middleBox
argument_list|)
expr_stmt|;
name|box
operator|.
name|cat
argument_list|(
name|rightBox
argument_list|)
expr_stmt|;
name|yyCharClass
operator|.
name|reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nf
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|f
index|[
name|i
index|]
operator|.
name|capture
condition|)
block|{
case|case
name|QRegExpAtom
operator|::
name|NoCapture
case|:
break|break;
case|case
name|QRegExpAtom
operator|::
name|OfficialCapture
case|:
name|f
index|[
name|i
index|]
operator|.
name|capture
operator|=
name|ncap
expr_stmt|;
name|captureForOfficialCapture
operator|.
name|append
argument_list|(
name|ncap
argument_list|)
expr_stmt|;
operator|++
name|ncap
expr_stmt|;
operator|++
name|officialncap
expr_stmt|;
break|break;
case|case
name|QRegExpAtom
operator|::
name|UnofficialCapture
case|:
name|f
index|[
name|i
index|]
operator|.
name|capture
operator|=
name|greedyQuantifiers
condition|?
name|ncap
operator|++
else|:
name|QRegExpAtom
operator|::
name|NoCapture
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
if|if
condition|(
name|officialncap
operator|==
literal|0
operator|&&
name|nbrefs
operator|==
literal|0
condition|)
block|{
name|ncap
operator|=
name|nf
operator|=
literal|0
expr_stmt|;
name|f
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|// handle the case where there's a \5 with no corresponding capture
comment|// (captureForOfficialCapture.size() != officialncap)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nbrefs
operator|-
name|officialncap
condition|;
operator|++
name|i
control|)
block|{
name|captureForOfficialCapture
operator|.
name|append
argument_list|(
name|ncap
argument_list|)
expr_stmt|;
operator|++
name|ncap
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|yyError
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
specifier|const
name|QRegExpAutomatonState
modifier|&
name|sinit
init|=
name|s
operator|.
name|at
argument_list|(
name|InitialState
argument_list|)
decl_stmt|;
name|caretAnchored
operator|=
operator|!
name|sinit
operator|.
name|anchors
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
if|if
condition|(
name|caretAnchored
condition|)
block|{
specifier|const
name|QMap
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
modifier|&
name|anchors
init|=
name|sinit
operator|.
name|anchors
decl_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
operator|::
name|const_iterator
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|anchors
operator|.
name|constBegin
argument_list|()
init|;
name|a
operator|!=
name|anchors
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|a
control|)
block|{
if|if
condition|(
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ANCHOR_ALT
operator|(
operator|*
name|a
operator|&
name|Anchor_Alternation
operator|)
operator|!=
literal|0
operator|||
endif|#
directive|endif
operator|(
operator|*
name|a
operator|&
name|Anchor_Caret
operator|)
operator|==
literal|0
condition|)
block|{
name|caretAnchored
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|// cleanup anchors
name|int
name|numStates
init|=
name|s
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numStates
condition|;
operator|++
name|i
control|)
block|{
name|QRegExpAutomatonState
modifier|&
name|state
init|=
name|s
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|state
operator|.
name|anchors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QMap
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
operator|::
name|iterator
name|a
init|=
name|state
operator|.
name|anchors
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|a
operator|!=
name|state
operator|.
name|anchors
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|a
operator|.
name|value
argument_list|()
operator|==
literal|0
condition|)
name|a
operator|=
name|state
operator|.
name|anchors
operator|.
name|erase
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
operator|++
name|a
expr_stmt|;
block|}
block|}
block|}
return|return
name|yyPos0
return|;
block|}
end_function
begin_function
DECL|function|parseAtom
name|void
name|QRegExpEngine
operator|::
name|parseAtom
parameter_list|(
name|Box
modifier|*
name|box
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_LOOKAHEAD
name|QRegExpEngine
modifier|*
name|eng
init|=
literal|0
decl_stmt|;
name|bool
name|neg
decl_stmt|;
name|int
name|len
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|yyTok
operator|&
name|Tok_Char
operator|)
operator|!=
literal|0
condition|)
block|{
name|box
operator|->
name|set
argument_list|(
name|QChar
argument_list|(
name|yyTok
operator|^
name|Tok_Char
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|trivial
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|yyTok
condition|)
block|{
case|case
name|Tok_Dollar
case|:
name|box
operator|->
name|catAnchor
argument_list|(
name|Anchor_Dollar
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_Caret
case|:
name|box
operator|->
name|catAnchor
argument_list|(
name|Anchor_Caret
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_LOOKAHEAD
case|case
name|Tok_PosLookahead
case|:
case|case
name|Tok_NegLookahead
case|:
name|neg
operator|=
operator|(
name|yyTok
operator|==
name|Tok_NegLookahead
operator|)
expr_stmt|;
name|eng
operator|=
operator|new
name|QRegExpEngine
argument_list|(
name|cs
argument_list|,
name|greedyQuantifiers
argument_list|)
expr_stmt|;
name|len
operator|=
name|eng
operator|->
name|parse
argument_list|(
name|yyIn
operator|+
name|yyPos
operator|-
literal|1
argument_list|,
name|yyLen
operator|-
name|yyPos
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|0
condition|)
name|skipChars
argument_list|(
name|len
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|RXERR_LOOKAHEAD
argument_list|)
expr_stmt|;
name|box
operator|->
name|catAnchor
argument_list|(
name|addLookahead
argument_list|(
name|eng
argument_list|,
name|neg
argument_list|)
argument_list|)
expr_stmt|;
name|yyTok
operator|=
name|getToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyTok
operator|!=
name|Tok_RightParen
condition|)
name|error
argument_list|(
name|RXERR_LOOKAHEAD
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_ESCAPE
case|case
name|Tok_Word
case|:
name|box
operator|->
name|catAnchor
argument_list|(
name|Anchor_Word
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_NonWord
case|:
name|box
operator|->
name|catAnchor
argument_list|(
name|Anchor_NonWord
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|Tok_LeftParen
case|:
case|case
name|Tok_MagicLeftParen
case|:
name|yyTok
operator|=
name|getToken
argument_list|()
expr_stmt|;
name|parseExpression
argument_list|(
name|box
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyTok
operator|!=
name|Tok_RightParen
condition|)
name|error
argument_list|(
name|RXERR_END
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_CharClass
case|:
name|box
operator|->
name|set
argument_list|(
operator|*
name|yyCharClass
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tok_Quantifier
case|:
name|error
argument_list|(
name|RXERR_REPETITION
argument_list|)
expr_stmt|;
break|break;
default|default:
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_BACKREF
if|if
condition|(
operator|(
name|yyTok
operator|&
name|Tok_BackRef
operator|)
operator|!=
literal|0
condition|)
name|box
operator|->
name|set
argument_list|(
name|yyTok
operator|^
name|Tok_BackRef
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|error
argument_list|(
name|RXERR_DISABLED
argument_list|)
expr_stmt|;
block|}
block|}
name|yyTok
operator|=
name|getToken
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseFactor
name|void
name|QRegExpEngine
operator|::
name|parseFactor
parameter_list|(
name|Box
modifier|*
name|box
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|int
name|outerAtom
init|=
name|greedyQuantifiers
condition|?
name|startAtom
argument_list|(
literal|false
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
name|int
name|innerAtom
init|=
name|startAtom
argument_list|(
name|yyMayCapture
operator|&&
name|yyTok
operator|==
name|Tok_LeftParen
argument_list|)
decl_stmt|;
name|bool
name|magicLeftParen
init|=
operator|(
name|yyTok
operator|==
name|Tok_MagicLeftParen
operator|)
decl_stmt|;
else|#
directive|else
specifier|const
name|int
name|innerAtom
init|=
operator|-
literal|1
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_INTERVAL
DECL|macro|YYREDO
define|#
directive|define
name|YYREDO
parameter_list|()
define|\
value|yyIn = in, yyPos0 = pos0, yyPos = pos, yyLen = len, yyCh = ch, \         *yyCharClass = charClass, yyMinRep = 0, yyMaxRep = 0, yyTok = tok
specifier|const
name|QChar
modifier|*
name|in
init|=
name|yyIn
decl_stmt|;
name|int
name|pos0
init|=
name|yyPos0
decl_stmt|;
name|int
name|pos
init|=
name|yyPos
decl_stmt|;
name|int
name|len
init|=
name|yyLen
decl_stmt|;
name|int
name|ch
init|=
name|yyCh
decl_stmt|;
name|QRegExpCharClass
name|charClass
decl_stmt|;
if|if
condition|(
name|yyTok
operator|==
name|Tok_CharClass
condition|)
name|charClass
operator|=
operator|*
name|yyCharClass
expr_stmt|;
name|int
name|tok
init|=
name|yyTok
decl_stmt|;
name|bool
name|mayCapture
init|=
name|yyMayCapture
decl_stmt|;
endif|#
directive|endif
name|parseAtom
argument_list|(
name|box
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|finishAtom
argument_list|(
name|innerAtom
argument_list|,
name|magicLeftParen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bool
name|hasQuantifier
init|=
operator|(
name|yyTok
operator|==
name|Tok_Quantifier
operator|)
decl_stmt|;
if|if
condition|(
name|hasQuantifier
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|trivial
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yyMaxRep
operator|==
name|InftyRep
condition|)
block|{
name|box
operator|->
name|plus
argument_list|(
name|innerAtom
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_INTERVAL
block|}
elseif|else
if|if
condition|(
name|yyMaxRep
operator|==
literal|0
condition|)
block|{
name|box
operator|->
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|yyMinRep
operator|==
literal|0
condition|)
name|box
operator|->
name|opt
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_INTERVAL
name|yyMayCapture
operator|=
literal|false
expr_stmt|;
name|int
name|alpha
init|=
operator|(
name|yyMinRep
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|yyMinRep
operator|-
literal|1
decl_stmt|;
name|int
name|beta
init|=
operator|(
name|yyMaxRep
operator|==
name|InftyRep
operator|)
condition|?
literal|0
else|:
name|yyMaxRep
operator|-
operator|(
name|alpha
operator|+
literal|1
operator|)
decl_stmt|;
name|Box
name|rightBox
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|beta
condition|;
name|i
operator|++
control|)
block|{
name|YYREDO
argument_list|()
expr_stmt|;
name|Box
name|leftBox
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|parseAtom
argument_list|(
operator|&
name|leftBox
argument_list|)
expr_stmt|;
name|leftBox
operator|.
name|cat
argument_list|(
name|rightBox
argument_list|)
expr_stmt|;
name|leftBox
operator|.
name|opt
argument_list|()
expr_stmt|;
name|rightBox
operator|=
name|leftBox
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alpha
condition|;
name|i
operator|++
control|)
block|{
name|YYREDO
argument_list|()
expr_stmt|;
name|Box
name|leftBox
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|parseAtom
argument_list|(
operator|&
name|leftBox
argument_list|)
expr_stmt|;
name|leftBox
operator|.
name|cat
argument_list|(
name|rightBox
argument_list|)
expr_stmt|;
name|rightBox
operator|=
name|leftBox
expr_stmt|;
block|}
name|rightBox
operator|.
name|cat
argument_list|(
operator|*
name|box
argument_list|)
expr_stmt|;
operator|*
name|box
operator|=
name|rightBox
expr_stmt|;
endif|#
directive|endif
name|yyTok
operator|=
name|getToken
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_INTERVAL
name|yyMayCapture
operator|=
name|mayCapture
expr_stmt|;
endif|#
directive|endif
block|}
DECL|macro|YYREDO
undef|#
directive|undef
name|YYREDO
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
if|if
condition|(
name|greedyQuantifiers
condition|)
name|finishAtom
argument_list|(
name|outerAtom
argument_list|,
name|hasQuantifier
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|parseTerm
name|void
name|QRegExpEngine
operator|::
name|parseTerm
parameter_list|(
name|Box
modifier|*
name|box
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
if|if
condition|(
name|yyTok
operator|!=
name|Tok_Eos
operator|&&
name|yyTok
operator|!=
name|Tok_RightParen
operator|&&
name|yyTok
operator|!=
name|Tok_Bar
condition|)
name|parseFactor
argument_list|(
name|box
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|yyTok
operator|!=
name|Tok_Eos
operator|&&
name|yyTok
operator|!=
name|Tok_RightParen
operator|&&
name|yyTok
operator|!=
name|Tok_Bar
condition|)
block|{
name|Box
name|rightBox
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|parseFactor
argument_list|(
operator|&
name|rightBox
argument_list|)
expr_stmt|;
name|box
operator|->
name|cat
argument_list|(
name|rightBox
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|parseExpression
name|void
name|QRegExpEngine
operator|::
name|parseExpression
parameter_list|(
name|Box
modifier|*
name|box
parameter_list|)
block|{
name|parseTerm
argument_list|(
name|box
argument_list|)
expr_stmt|;
while|while
condition|(
name|yyTok
operator|==
name|Tok_Bar
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_OPTIM
name|trivial
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
name|Box
name|rightBox
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|yyTok
operator|=
name|getToken
argument_list|()
expr_stmt|;
name|parseTerm
argument_list|(
operator|&
name|rightBox
argument_list|)
expr_stmt|;
name|box
operator|->
name|orx
argument_list|(
name|rightBox
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*   The struct QRegExpPrivate contains the private data of a regular   expression other than the automaton. It makes it possible for many   QRegExp objects to use the same QRegExpEngine object with different   QRegExpPrivate objects. */
end_comment
begin_struct
DECL|struct|QRegExpPrivate
struct|struct
name|QRegExpPrivate
block|{
DECL|member|eng
name|QRegExpEngine
modifier|*
name|eng
decl_stmt|;
DECL|member|engineKey
name|QRegExpEngineKey
name|engineKey
decl_stmt|;
DECL|member|minimal
name|bool
name|minimal
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
DECL|member|t
name|QString
name|t
decl_stmt|;
comment|// last string passed to QRegExp::indexIn() or lastIndexIn()
DECL|member|capturedCache
name|QStringList
name|capturedCache
decl_stmt|;
comment|// what QRegExp::capturedTexts() returned last
endif|#
directive|endif
DECL|member|matchState
name|QRegExpMatchState
name|matchState
decl_stmt|;
DECL|function|QRegExpPrivate
specifier|inline
name|QRegExpPrivate
parameter_list|()
member_init_list|:
name|eng
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|engineKey
argument_list|(
name|QString
argument_list|()
argument_list|,
name|QRegExp
operator|::
name|RegExp
argument_list|,
name|Qt
operator|::
name|CaseSensitive
argument_list|)
member_init_list|,
name|minimal
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|QRegExpPrivate
specifier|inline
name|QRegExpPrivate
parameter_list|(
specifier|const
name|QRegExpEngineKey
modifier|&
name|key
parameter_list|)
member_init_list|:
name|eng
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|engineKey
argument_list|(
name|key
argument_list|)
member_init_list|,
name|minimal
argument_list|(
literal|false
argument_list|)
block|{}
block|}
struct|;
end_struct
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_REGEXP_OPTIM
argument_list|)
end_if
begin_function
DECL|function|qHash
name|uint
name|qHash
parameter_list|(
specifier|const
name|QRegExpEngineKey
modifier|&
name|key
parameter_list|)
block|{
return|return
name|qHash
argument_list|(
name|key
operator|.
name|pattern
argument_list|)
return|;
block|}
end_function
begin_typedef
DECL|typedef|EngineCache
typedef|typedef
name|QCache
argument_list|<
name|QRegExpEngineKey
argument_list|,
name|QRegExpEngine
argument_list|>
name|EngineCache
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|EngineCache
argument_list|,
argument|globalEngineCache
argument_list|)
end_macro
begin_decl_stmt
DECL|variable|globalEngineCacheMutex
specifier|static
name|QBasicMutex
name|globalEngineCacheMutex
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGEXP_OPTIM
end_comment
begin_function
DECL|function|derefEngine
specifier|static
name|void
name|derefEngine
parameter_list|(
name|QRegExpEngine
modifier|*
name|eng
parameter_list|,
specifier|const
name|QRegExpEngineKey
modifier|&
name|key
parameter_list|)
block|{
if|if
condition|(
operator|!
name|eng
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_REGEXP_OPTIM
argument_list|)
if|if
condition|(
name|globalEngineCache
argument_list|()
condition|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalEngineCacheMutex
argument_list|)
decl_stmt|;
name|QT_TRY
block|{
name|globalEngineCache
argument_list|()
operator|->
name|insert
argument_list|(
name|key
argument_list|,
name|eng
argument_list|,
literal|4
operator|+
name|key
operator|.
name|pattern
operator|.
name|length
argument_list|()
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::bad_alloc&
argument_list|)
block|{
comment|// in case of an exception (e.g. oom), just delete the engine
operator|delete
name|eng
expr_stmt|;
block|}
block|}
else|else
block|{
operator|delete
name|eng
expr_stmt|;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|key
argument_list|)
expr_stmt|;
operator|delete
name|eng
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_function
DECL|function|prepareEngine_helper
specifier|static
name|void
name|prepareEngine_helper
parameter_list|(
name|QRegExpPrivate
modifier|*
name|priv
parameter_list|)
block|{
name|bool
name|initMatchState
init|=
operator|!
name|priv
operator|->
name|eng
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_REGEXP_OPTIM
argument_list|)
if|if
condition|(
operator|!
name|priv
operator|->
name|eng
operator|&&
name|globalEngineCache
argument_list|()
condition|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalEngineCacheMutex
argument_list|)
decl_stmt|;
name|priv
operator|->
name|eng
operator|=
name|globalEngineCache
argument_list|()
operator|->
name|take
argument_list|(
name|priv
operator|->
name|engineKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|eng
operator|!=
literal|0
condition|)
name|priv
operator|->
name|eng
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
endif|#
directive|endif
comment|// QT_NO_REGEXP_OPTIM
if|if
condition|(
operator|!
name|priv
operator|->
name|eng
condition|)
name|priv
operator|->
name|eng
operator|=
operator|new
name|QRegExpEngine
argument_list|(
name|priv
operator|->
name|engineKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|initMatchState
condition|)
name|priv
operator|->
name|matchState
operator|.
name|prepareForMatch
argument_list|(
name|priv
operator|->
name|eng
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepareEngine
specifier|inline
specifier|static
name|void
name|prepareEngine
parameter_list|(
name|QRegExpPrivate
modifier|*
name|priv
parameter_list|)
block|{
if|if
condition|(
name|priv
operator|->
name|eng
condition|)
return|return;
name|prepareEngine_helper
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepareEngineForMatch
specifier|static
name|void
name|prepareEngineForMatch
parameter_list|(
name|QRegExpPrivate
modifier|*
name|priv
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|prepareEngine
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|priv
operator|->
name|matchState
operator|.
name|prepareForMatch
argument_list|(
name|priv
operator|->
name|eng
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|priv
operator|->
name|t
operator|=
name|str
expr_stmt|;
name|priv
operator|->
name|capturedCache
operator|.
name|clear
argument_list|()
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|str
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|invalidateEngine
specifier|static
name|void
name|invalidateEngine
parameter_list|(
name|QRegExpPrivate
modifier|*
name|priv
parameter_list|)
block|{
if|if
condition|(
name|priv
operator|->
name|eng
operator|!=
literal|0
condition|)
block|{
name|derefEngine
argument_list|(
name|priv
operator|->
name|eng
argument_list|,
name|priv
operator|->
name|engineKey
argument_list|)
expr_stmt|;
name|priv
operator|->
name|eng
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|matchState
operator|.
name|drain
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \enum QRegExp::CaretMode      The CaretMode enum defines the different meanings of the caret     (\bold{^}) in a regular expression. The possible values are:      \value CaretAtZero            The caret corresponds to index 0 in the searched string.      \value CaretAtOffset            The caret corresponds to the start offset of the search.      \value CaretWontMatch            The caret never matches. */
end_comment
begin_comment
comment|/*!     \enum QRegExp::PatternSyntax      The syntax used to interpret the meaning of the pattern.      \value RegExp A rich Perl-like pattern matching syntax. This is     the default.      \value RegExp2 Like RegExp, but with \l{greedy quantifiers}. This     will be the default in Qt 5. (Introduced in Qt 4.2.)      \value Wildcard This provides a simple pattern matching syntax     similar to that used by shells (command interpreters) for "file     globbing". See \l{Wildcard Matching}.      \value WildcardUnix This is similar to Wildcard but with the     behavior of a Unix shell. The wildcard characters can be escaped     with the character "\\".      \value FixedString The pattern is a fixed string. This is     equivalent to using the RegExp pattern on a string in     which all metacharacters are escaped using escape().      \value W3CXmlSchema11 The pattern is a regular expression as     defined by the W3C XML Schema 1.1 specification.      \sa setPatternSyntax() */
end_comment
begin_comment
comment|/*!     Constructs an empty regexp.      \sa isValid(), errorString() */
end_comment
begin_constructor
DECL|function|QRegExp
name|QRegExp
operator|::
name|QRegExp
parameter_list|()
block|{
name|priv
operator|=
operator|new
name|QRegExpPrivate
expr_stmt|;
name|prepareEngine
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a regular expression object for the given \a pattern     string. The pattern must be given using wildcard notation if \a     syntax is \l Wildcard; the default is \l RegExp. The pattern is     case sensitive, unless \a cs is Qt::CaseInsensitive. Matching is     greedy (maximal), but can be changed by calling     setMinimal().      \sa setPattern(), setCaseSensitivity(), setPatternSyntax() */
end_comment
begin_constructor
DECL|function|QRegExp
name|QRegExp
operator|::
name|QRegExp
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|,
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|,
name|PatternSyntax
name|syntax
parameter_list|)
block|{
name|priv
operator|=
operator|new
name|QRegExpPrivate
argument_list|(
name|QRegExpEngineKey
argument_list|(
name|pattern
argument_list|,
name|syntax
argument_list|,
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|prepareEngine
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a regular expression as a copy of \a rx.      \sa operator=() */
end_comment
begin_constructor
DECL|function|QRegExp
name|QRegExp
operator|::
name|QRegExp
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|)
block|{
name|priv
operator|=
operator|new
name|QRegExpPrivate
expr_stmt|;
name|operator
name|=
parameter_list|(
name|rx
parameter_list|)
function_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the regular expression and cleans up its internal data. */
end_comment
begin_destructor
DECL|function|~QRegExp
name|QRegExp
operator|::
name|~
name|QRegExp
parameter_list|()
block|{
name|invalidateEngine
argument_list|(
name|priv
argument_list|)
expr_stmt|;
operator|delete
name|priv
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Copies the regular expression \a rx and returns a reference to the     copy. The case sensitivity, wildcard, and minimal matching options     are also copied. */
end_comment
begin_function
DECL|function|operator =
name|QRegExp
modifier|&
name|QRegExp
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|)
block|{
name|prepareEngine
argument_list|(
name|rx
operator|.
name|priv
argument_list|)
expr_stmt|;
comment|// to allow sharing
name|QRegExpEngine
modifier|*
name|otherEng
init|=
name|rx
operator|.
name|priv
operator|->
name|eng
decl_stmt|;
if|if
condition|(
name|otherEng
condition|)
name|otherEng
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|invalidateEngine
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|priv
operator|->
name|eng
operator|=
name|otherEng
expr_stmt|;
name|priv
operator|->
name|engineKey
operator|=
name|rx
operator|.
name|priv
operator|->
name|engineKey
expr_stmt|;
name|priv
operator|->
name|minimal
operator|=
name|rx
operator|.
name|priv
operator|->
name|minimal
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
name|priv
operator|->
name|t
operator|=
name|rx
operator|.
name|priv
operator|->
name|t
expr_stmt|;
name|priv
operator|->
name|capturedCache
operator|=
name|rx
operator|.
name|priv
operator|->
name|capturedCache
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|priv
operator|->
name|eng
condition|)
name|priv
operator|->
name|matchState
operator|.
name|prepareForMatch
argument_list|(
name|priv
operator|->
name|eng
argument_list|)
expr_stmt|;
name|priv
operator|->
name|matchState
operator|.
name|captured
operator|=
name|rx
operator|.
name|priv
operator|->
name|matchState
operator|.
name|captured
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QRegExp::swap(QRegExp&other)     \since 4.8      Swaps regular expression \a other with this regular     expression. This operation is very fast and never fails. */
end_comment
begin_comment
comment|/*!     Returns true if this regular expression is equal to \a rx;     otherwise returns false.      Two QRegExp objects are equal if they have the same pattern     strings and the same settings for case sensitivity, wildcard and     minimal matching. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QRegExp
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|rx
parameter_list|)
specifier|const
block|{
return|return
name|priv
operator|->
name|engineKey
operator|==
name|rx
operator|.
name|priv
operator|->
name|engineKey
operator|&&
name|priv
operator|->
name|minimal
operator|==
name|rx
operator|.
name|priv
operator|->
name|minimal
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QRegExp::operator!=(const QRegExp&rx) const      Returns true if this regular expression is not equal to \a rx;     otherwise returns false.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Returns true if the pattern string is empty; otherwise returns     false.      If you call exactMatch() with an empty pattern on an empty string     it will return true; otherwise it returns false since it operates     over the whole string. If you call indexIn() with an empty pattern     on \e any string it will return the start offset (0 by default)     because the empty pattern matches the 'emptiness' at the start of     the string. In this case the length of the match returned by     matchedLength() will be 0.      See QString::isEmpty(). */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QRegExp
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|->
name|engineKey
operator|.
name|pattern
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the regular expression is valid; otherwise returns     false. An invalid regular expression never matches.      The pattern \bold{[a-z} is an example of an invalid pattern, since     it lacks a closing square bracket.      Note that the validity of a regexp may also depend on the setting     of the wildcard flag, for example \bold{*.html} is a valid     wildcard regexp but an invalid full regexp.      \sa errorString() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QRegExp
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|priv
operator|->
name|engineKey
operator|.
name|pattern
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
name|prepareEngine
argument_list|(
name|priv
argument_list|)
expr_stmt|;
return|return
name|priv
operator|->
name|eng
operator|->
name|isValid
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the pattern string of the regular expression. The pattern     has either regular expression syntax or wildcard syntax, depending     on patternSyntax().      \sa patternSyntax(), caseSensitivity() */
end_comment
begin_function
DECL|function|pattern
name|QString
name|QRegExp
operator|::
name|pattern
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|->
name|engineKey
operator|.
name|pattern
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the pattern string to \a pattern. The case sensitivity,     wildcard, and minimal matching options are not changed.      \sa setPatternSyntax(), setCaseSensitivity() */
end_comment
begin_function
DECL|function|setPattern
name|void
name|QRegExp
operator|::
name|setPattern
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|)
block|{
if|if
condition|(
name|priv
operator|->
name|engineKey
operator|.
name|pattern
operator|!=
name|pattern
condition|)
block|{
name|invalidateEngine
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|priv
operator|->
name|engineKey
operator|.
name|pattern
operator|=
name|pattern
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns Qt::CaseSensitive if the regexp is matched case     sensitively; otherwise returns Qt::CaseInsensitive.      \sa patternSyntax(), pattern(), isMinimal() */
end_comment
begin_function
DECL|function|caseSensitivity
name|Qt
operator|::
name|CaseSensitivity
name|QRegExp
operator|::
name|caseSensitivity
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|->
name|engineKey
operator|.
name|cs
return|;
block|}
end_function
begin_comment
comment|/*!     Sets case sensitive matching to \a cs.      If \a cs is Qt::CaseSensitive, \bold{\\.txt$} matches     \c{readme.txt} but not \c{README.TXT}.      \sa setPatternSyntax(), setPattern(), setMinimal() */
end_comment
begin_function
DECL|function|setCaseSensitivity
name|void
name|QRegExp
operator|::
name|setCaseSensitivity
parameter_list|(
name|Qt
operator|::
name|CaseSensitivity
name|cs
parameter_list|)
block|{
if|if
condition|(
operator|(
name|bool
operator|)
name|cs
operator|!=
operator|(
name|bool
operator|)
name|priv
operator|->
name|engineKey
operator|.
name|cs
condition|)
block|{
name|invalidateEngine
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|priv
operator|->
name|engineKey
operator|.
name|cs
operator|=
name|cs
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the syntax used by the regular expression. The default is     QRegExp::RegExp.      \sa pattern(), caseSensitivity() */
end_comment
begin_function
DECL|function|patternSyntax
name|QRegExp
operator|::
name|PatternSyntax
name|QRegExp
operator|::
name|patternSyntax
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|->
name|engineKey
operator|.
name|patternSyntax
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the syntax mode for the regular expression. The default is     QRegExp::RegExp.      Setting \a syntax to QRegExp::Wildcard enables simple shell-like     \l{wildcard matching}. For example, \bold{r*.txt} matches the     string \c{readme.txt} in wildcard mode, but does not match     \c{readme}.      Setting \a syntax to QRegExp::FixedString means that the pattern     is interpreted as a plain string. Special characters (e.g.,     backslash) don't need to be escaped then.      \sa setPattern(), setCaseSensitivity(), escape() */
end_comment
begin_function
DECL|function|setPatternSyntax
name|void
name|QRegExp
operator|::
name|setPatternSyntax
parameter_list|(
name|PatternSyntax
name|syntax
parameter_list|)
block|{
if|if
condition|(
name|syntax
operator|!=
name|priv
operator|->
name|engineKey
operator|.
name|patternSyntax
condition|)
block|{
name|invalidateEngine
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|priv
operator|->
name|engineKey
operator|.
name|patternSyntax
operator|=
name|syntax
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns true if minimal (non-greedy) matching is enabled;     otherwise returns false.      \sa caseSensitivity(), setMinimal() */
end_comment
begin_function
DECL|function|isMinimal
name|bool
name|QRegExp
operator|::
name|isMinimal
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|->
name|minimal
return|;
block|}
end_function
begin_comment
comment|/*!     Enables or disables minimal matching. If \a minimal is false,     matching is greedy (maximal) which is the default.      For example, suppose we have the input string "We must be<b>bold</b>, very<b>bold</b>!" and the pattern     \bold{<b>.*</b>}. With the default greedy (maximal) matching,     the match is "We must be \underline{<b>bold</b>, very<b>bold</b>}!". But with minimal (non-greedy) matching, the     first match is: "We must be \underline{<b>bold</b>}, very<b>bold</b>!" and the second match is "We must be<b>bold</b>,     very \underline{<b>bold</b>}!". In practice we might use the pattern     \bold{<b>[^<]*\</b>} instead, although this will still fail for     nested tags.      \sa setCaseSensitivity() */
end_comment
begin_function
DECL|function|setMinimal
name|void
name|QRegExp
operator|::
name|setMinimal
parameter_list|(
name|bool
name|minimal
parameter_list|)
block|{
name|priv
operator|->
name|minimal
operator|=
name|minimal
expr_stmt|;
block|}
end_function
begin_comment
comment|// ### Qt 5: make non-const
end_comment
begin_comment
comment|/*!     Returns true if \a str is matched exactly by this regular     expression; otherwise returns false. You can determine how much of     the string was matched by calling matchedLength().      For a given regexp string R, exactMatch("R") is the equivalent of     indexIn("^R$") since exactMatch() effectively encloses the regexp     in the start of string and end of string anchors, except that it     sets matchedLength() differently.      For example, if the regular expression is \bold{blue}, then     exactMatch() returns true only for input \c blue. For inputs \c     bluebell, \c blutak and \c lightblue, exactMatch() returns false     and matchedLength() will return 4, 3 and 0 respectively.      Although const, this function sets matchedLength(),     capturedTexts(), and pos().      \sa indexIn(), lastIndexIn() */
end_comment
begin_function
DECL|function|exactMatch
name|bool
name|QRegExp
operator|::
name|exactMatch
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
specifier|const
block|{
name|prepareEngineForMatch
argument_list|(
name|priv
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|priv
operator|->
name|matchState
operator|.
name|match
argument_list|(
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|,
literal|0
argument_list|,
name|priv
operator|->
name|minimal
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|matchState
operator|.
name|captured
index|[
literal|1
index|]
operator|==
name|str
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
name|priv
operator|->
name|matchState
operator|.
name|captured
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|matchState
operator|.
name|captured
index|[
literal|1
index|]
operator|=
name|priv
operator|->
name|matchState
operator|.
name|oneTestMatchedLen
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|// ### Qt 5: make non-const
end_comment
begin_comment
comment|/*!     Attempts to find a match in \a str from position \a offset (0 by     default). If \a offset is -1, the search starts at the last     character; if -2, at the next to last character; etc.      Returns the position of the first match, or -1 if there was no     match.      The \a caretMode parameter can be used to instruct whether \bold{^}     should match at index 0 or at \a offset.      You might prefer to use QString::indexOf(), QString::contains(),     or even QStringList::filter(). To replace matches use     QString::replace().      Example:     \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 13      Although const, this function sets matchedLength(),     capturedTexts() and pos().      If the QRegExp is a wildcard expression (see setPatternSyntax())     and want to test a string against the whole wildcard expression,     use exactMatch() instead of this function.      \sa lastIndexIn(), exactMatch() */
end_comment
begin_function
DECL|function|indexIn
name|int
name|QRegExp
operator|::
name|indexIn
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|offset
parameter_list|,
name|CaretMode
name|caretMode
parameter_list|)
specifier|const
block|{
name|prepareEngineForMatch
argument_list|(
name|priv
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|offset
operator|+=
name|str
operator|.
name|length
argument_list|()
expr_stmt|;
name|priv
operator|->
name|matchState
operator|.
name|match
argument_list|(
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|,
name|offset
argument_list|,
name|priv
operator|->
name|minimal
argument_list|,
literal|false
argument_list|,
name|caretIndex
argument_list|(
name|offset
argument_list|,
name|caretMode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|priv
operator|->
name|matchState
operator|.
name|captured
index|[
literal|0
index|]
return|;
block|}
end_function
begin_comment
comment|// ### Qt 5: make non-const
end_comment
begin_comment
comment|/*!     Attempts to find a match backwards in \a str from position \a     offset. If \a offset is -1 (the default), the search starts at the     last character; if -2, at the next to last character; etc.      Returns the position of the first match, or -1 if there was no     match.      The \a caretMode parameter can be used to instruct whether \bold{^}     should match at index 0 or at \a offset.      Although const, this function sets matchedLength(),     capturedTexts() and pos().      \warning Searching backwards is much slower than searching     forwards.      \sa indexIn(), exactMatch() */
end_comment
begin_function
DECL|function|lastIndexIn
name|int
name|QRegExp
operator|::
name|lastIndexIn
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|,
name|int
name|offset
parameter_list|,
name|CaretMode
name|caretMode
parameter_list|)
specifier|const
block|{
name|prepareEngineForMatch
argument_list|(
name|priv
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|offset
operator|+=
name|str
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|offset
argument_list|<
literal|0
operator|||
name|offset
argument_list|>
name|str
operator|.
name|length
argument_list|()
condition|)
block|{
name|memset
argument_list|(
name|priv
operator|->
name|matchState
operator|.
name|captured
argument_list|,
operator|-
literal|1
argument_list|,
name|priv
operator|->
name|matchState
operator|.
name|capturedSize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|offset
operator|>=
literal|0
condition|)
block|{
name|priv
operator|->
name|matchState
operator|.
name|match
argument_list|(
name|str
operator|.
name|unicode
argument_list|()
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|,
name|offset
argument_list|,
name|priv
operator|->
name|minimal
argument_list|,
literal|true
argument_list|,
name|caretIndex
argument_list|(
name|offset
argument_list|,
name|caretMode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|matchState
operator|.
name|captured
index|[
literal|0
index|]
operator|==
name|offset
condition|)
return|return
name|offset
return|;
operator|--
name|offset
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the length of the last matched string, or -1 if there was     no match.      \sa exactMatch(), indexIn(), lastIndexIn() */
end_comment
begin_function
DECL|function|matchedLength
name|int
name|QRegExp
operator|::
name|matchedLength
parameter_list|()
specifier|const
block|{
return|return
name|priv
operator|->
name|matchState
operator|.
name|captured
index|[
literal|1
index|]
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP_CAPTURE
end_ifndef
begin_comment
comment|/*!   \fn int QRegExp::numCaptures() const   \obsolete   Returns the number of captures contained in the regular expression.    \sa captureCount()  */
end_comment
begin_comment
comment|/*!   \since 4.6   Returns the number of captures contained in the regular expression.  */
end_comment
begin_function
DECL|function|captureCount
name|int
name|QRegExp
operator|::
name|captureCount
parameter_list|()
specifier|const
block|{
name|prepareEngine
argument_list|(
name|priv
argument_list|)
expr_stmt|;
return|return
name|priv
operator|->
name|eng
operator|->
name|captureCount
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of the captured text strings.      The first string in the list is the entire matched string. Each     subsequent list element contains a string that matched a     (capturing) subexpression of the regexp.      For example:     \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 14      The above example also captures elements that may be present but     which we have no interest in. This problem can be solved by using     non-capturing parentheses:      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 15      Note that if you want to iterate over the list, you should iterate     over a copy, e.g.     \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 16      Some regexps can match an indeterminate number of times. For     example if the input string is "Offsets: 12 14 99 231 7" and the     regexp, \c{rx}, is \bold{(\\d+)+}, we would hope to get a list of     all the numbers matched. However, after calling     \c{rx.indexIn(str)}, capturedTexts() will return the list ("12",     "12"), i.e. the entire match was "12" and the first subexpression     matched was "12". The correct approach is to use cap() in a     \l{QRegExp#cap_in_a_loop}{loop}.      The order of elements in the string list is as follows. The first     element is the entire matching string. Each subsequent element     corresponds to the next capturing open left parentheses. Thus     capturedTexts()[1] is the text of the first capturing parentheses,     capturedTexts()[2] is the text of the second and so on     (corresponding to $1, $2, etc., in some other regexp languages).      \sa cap(), pos() */
end_comment
begin_function
DECL|function|capturedTexts
name|QStringList
name|QRegExp
operator|::
name|capturedTexts
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|priv
operator|->
name|capturedCache
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|prepareEngine
argument_list|(
name|priv
argument_list|)
expr_stmt|;
specifier|const
name|int
modifier|*
name|captured
init|=
name|priv
operator|->
name|matchState
operator|.
name|captured
decl_stmt|;
name|int
name|n
init|=
name|priv
operator|->
name|matchState
operator|.
name|capturedSize
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|QString
name|m
decl_stmt|;
if|if
condition|(
name|captured
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
name|m
operator|=
name|QLatin1String
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|// ### Qt 5: don't distinguish between null and empty
elseif|else
if|if
condition|(
name|captured
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|m
operator|=
name|priv
operator|->
name|t
operator|.
name|mid
argument_list|(
name|captured
index|[
name|i
index|]
argument_list|,
name|captured
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|priv
operator|->
name|capturedCache
operator|.
name|append
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|priv
operator|->
name|t
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
name|priv
operator|->
name|capturedCache
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|capturedTexts
name|QStringList
name|QRegExp
operator|::
name|capturedTexts
parameter_list|()
block|{
return|return
cast|const_cast
argument_list|<
specifier|const
name|QRegExp
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|capturedTexts
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the text captured by the \a nth subexpression. The entire     match has index 0 and the parenthesized subexpressions have     indexes starting from 1 (excluding non-capturing parentheses).      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 17      The order of elements matched by cap() is as follows. The first     element, cap(0), is the entire matching string. Each subsequent     element corresponds to the next capturing open left parentheses.     Thus cap(1) is the text of the first capturing parentheses, cap(2)     is the text of the second, and so on.      \sa capturedTexts(), pos() */
end_comment
begin_function
DECL|function|cap
name|QString
name|QRegExp
operator|::
name|cap
parameter_list|(
name|int
name|nth
parameter_list|)
specifier|const
block|{
return|return
name|capturedTexts
argument_list|()
operator|.
name|value
argument_list|(
name|nth
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|cap
name|QString
name|QRegExp
operator|::
name|cap
parameter_list|(
name|int
name|nth
parameter_list|)
block|{
return|return
cast|const_cast
argument_list|<
specifier|const
name|QRegExp
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|cap
argument_list|(
name|nth
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the position of the \a nth captured text in the searched     string. If \a nth is 0 (the default), pos() returns the position     of the whole match.      Example:     \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 18      For zero-length matches, pos() always returns -1. (For example, if     cap(4) would return an empty string, pos(4) returns -1.) This is     a feature of the implementation.      \sa cap(), capturedTexts() */
end_comment
begin_function
DECL|function|pos
name|int
name|QRegExp
operator|::
name|pos
parameter_list|(
name|int
name|nth
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|nth
operator|<
literal|0
operator|||
name|nth
operator|>=
name|priv
operator|->
name|matchState
operator|.
name|capturedSize
operator|/
literal|2
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|priv
operator|->
name|matchState
operator|.
name|captured
index|[
literal|2
operator|*
name|nth
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|pos
name|int
name|QRegExp
operator|::
name|pos
parameter_list|(
name|int
name|nth
parameter_list|)
block|{
return|return
cast|const_cast
argument_list|<
specifier|const
name|QRegExp
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|pos
argument_list|(
name|nth
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns a text string that explains why a regexp pattern is   invalid the case being; otherwise returns "no error occurred".    \sa isValid() */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QRegExp
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isValid
argument_list|()
condition|)
block|{
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|RXERR_OK
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|priv
operator|->
name|eng
operator|->
name|errorString
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QRegExp
operator|::
name|errorString
parameter_list|()
block|{
return|return
cast|const_cast
argument_list|<
specifier|const
name|QRegExp
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|errorString
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Returns the string \a str with every regexp special character     escaped with a backslash. The special characters are $, (,), *, +,     ., ?, [, \,], ^, {, | and }.      Example:      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 19      This function is useful to construct regexp patterns dynamically:      \snippet doc/src/snippets/code/src_corelib_tools_qregexp.cpp 20      \sa setPatternSyntax() */
end_comment
begin_function
DECL|function|escape
name|QString
name|QRegExp
operator|::
name|escape
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|QString
name|quoted
decl_stmt|;
specifier|const
name|int
name|count
init|=
name|str
operator|.
name|count
argument_list|()
decl_stmt|;
name|quoted
operator|.
name|reserve
argument_list|(
name|count
operator|*
literal|2
argument_list|)
expr_stmt|;
specifier|const
name|QLatin1Char
name|backslash
argument_list|(
literal|'\\'
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLatin1
argument_list|()
condition|)
block|{
case|case
literal|'$'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|'.'
case|:
case|case
literal|'?'
case|:
case|case
literal|'['
case|:
case|case
literal|'\\'
case|:
case|case
literal|']'
case|:
case|case
literal|'^'
case|:
case|case
literal|'{'
case|:
case|case
literal|'|'
case|:
case|case
literal|'}'
case|:
name|quoted
operator|.
name|append
argument_list|(
name|backslash
argument_list|)
expr_stmt|;
block|}
name|quoted
operator|.
name|append
argument_list|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|quoted
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \relates QRegExp      Writes the regular expression \a regExp to stream \a out.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QRegExp
modifier|&
name|regExp
parameter_list|)
block|{
return|return
name|out
operator|<<
name|regExp
operator|.
name|pattern
argument_list|()
operator|<<
operator|(
name|quint8
operator|)
name|regExp
operator|.
name|caseSensitivity
argument_list|()
operator|<<
operator|(
name|quint8
operator|)
name|regExp
operator|.
name|patternSyntax
argument_list|()
operator|<<
operator|(
name|quint8
operator|)
operator|!
operator|!
name|regExp
operator|.
name|isMinimal
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QRegExp      Reads a regular expression from stream \a in into \a regExp.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QRegExp
modifier|&
name|regExp
parameter_list|)
block|{
name|QString
name|pattern
decl_stmt|;
name|quint8
name|cs
decl_stmt|;
name|quint8
name|patternSyntax
decl_stmt|;
name|quint8
name|isMinimal
decl_stmt|;
name|in
operator|>>
name|pattern
operator|>>
name|cs
operator|>>
name|patternSyntax
operator|>>
name|isMinimal
expr_stmt|;
name|QRegExp
name|newRegExp
argument_list|(
name|pattern
argument_list|,
name|Qt
operator|::
name|CaseSensitivity
argument_list|(
name|cs
argument_list|)
argument_list|,
name|QRegExp
operator|::
name|PatternSyntax
argument_list|(
name|patternSyntax
argument_list|)
argument_list|)
decl_stmt|;
name|newRegExp
operator|.
name|setMinimal
argument_list|(
name|isMinimal
argument_list|)
expr_stmt|;
name|regExp
operator|=
name|newRegExp
expr_stmt|;
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QRegExp
modifier|&
name|r
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QRegExp(patternSyntax="
operator|<<
name|r
operator|.
name|patternSyntax
argument_list|()
operator|<<
literal|", pattern='"
operator|<<
name|r
operator|.
name|pattern
argument_list|()
operator|<<
literal|"')"
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
