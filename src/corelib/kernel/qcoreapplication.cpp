begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication_p.h"
end_include
begin_include
include|#
directive|include
file|"qabstracteventdispatcher.h"
end_include
begin_include
include|#
directive|include
file|"qcoreevent.h"
end_include
begin_include
include|#
directive|include
file|"qeventloop.h"
end_include
begin_include
include|#
directive|include
file|"qcorecmdlineargs_p.h"
end_include
begin_include
include|#
directive|include
file|<qdatastream.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<private/qprocess_p.h>
end_include
begin_include
include|#
directive|include
file|<qtextcodec.h>
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|<qthreadpool.h>
end_include
begin_include
include|#
directive|include
file|<qthreadstorage.h>
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<qelapsedtimer.h>
end_include
begin_include
include|#
directive|include
file|<qlibraryinfo.h>
end_include
begin_include
include|#
directive|include
file|<qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<private/qfactoryloader_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfunctions_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qlocale_p.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
end_ifdef
begin_include
include|#
directive|include
file|<exception>
end_include
begin_include
include|#
directive|include
file|<f32file.h>
end_include
begin_include
include|#
directive|include
file|<e32ldr.h>
end_include
begin_include
include|#
directive|include
file|"qeventdispatcher_symbian_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qcore_symbian_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qfilesystemengine_p.h"
end_include
begin_include
include|#
directive|include
file|<apacmdln.h>
end_include
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
end_elif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_GLIB
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qeventdispatcher_glib_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qeventdispatcher_unix_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_include
include|#
directive|include
file|"qeventdispatcher_win_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_MAC
end_ifdef
begin_include
include|#
directive|include
file|"qcore_mac_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|<locale.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_VXWORKS
end_ifdef
begin_include
include|#
directive|include
file|<taskLib.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QMutexUnlocker
class|class
name|QMutexUnlocker
block|{
public|public:
DECL|function|QMutexUnlocker
specifier|inline
specifier|explicit
name|QMutexUnlocker
parameter_list|(
name|QMutex
modifier|*
name|m
parameter_list|)
member_init_list|:
name|mtx
argument_list|(
name|m
argument_list|)
block|{ }
DECL|function|~QMutexUnlocker
specifier|inline
name|~
name|QMutexUnlocker
parameter_list|()
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|function|unlock
specifier|inline
name|void
name|unlock
parameter_list|()
block|{
if|if
condition|(
name|mtx
condition|)
name|mtx
operator|->
name|unlock
argument_list|()
expr_stmt|;
name|mtx
operator|=
literal|0
expr_stmt|;
block|}
private|private:
name|Q_DISABLE_COPY
argument_list|(
argument|QMutexUnlocker
argument_list|)
DECL|member|mtx
name|QMutex
modifier|*
name|mtx
decl_stmt|;
block|}
class|;
end_class
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
end_ifdef
begin_typedef
DECL|typedef|SystemDriveFunc
typedef|typedef
name|TDriveNumber
function_decl|(
modifier|*
name|SystemDriveFunc
function_decl|)
parameter_list|(
name|RFs
modifier|&
parameter_list|)
function_decl|;
end_typedef
begin_decl_stmt
DECL|variable|PtrGetSystemDrive
specifier|static
name|SystemDriveFunc
name|PtrGetSystemDrive
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|apaCommandLine
specifier|static
name|CApaCommandLine
modifier|*
name|apaCommandLine
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|apaTail
specifier|static
name|char
modifier|*
name|apaTail
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|apaArgv
specifier|static
name|QVector
argument_list|<
name|char
modifier|*
argument_list|>
modifier|*
name|apaArgv
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_cleanup_apa_cmd_line
specifier|static
name|void
name|qt_cleanup_apa_cmd_line
parameter_list|()
block|{
operator|delete
name|apaCommandLine
expr_stmt|;
name|apaCommandLine
operator|=
literal|0
expr_stmt|;
operator|delete
name|apaArgv
expr_stmt|;
name|apaArgv
operator|=
literal|0
expr_stmt|;
operator|delete
name|apaTail
expr_stmt|;
name|apaTail
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_init_symbian_apa_arguments
specifier|static
specifier|inline
name|void
name|qt_init_symbian_apa_arguments
parameter_list|(
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
modifier|&
name|argv
parameter_list|)
block|{
comment|// If app is launched via CApaCommandLine::StartApp(), normal arguments only contain
comment|// application name.
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|CApaCommandLine
modifier|*
name|commandLine
init|=
name|QCoreApplicationPrivate
operator|::
name|symbianCommandLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|commandLine
condition|)
block|{
name|TPtrC8
name|apaCmdLine
init|=
name|commandLine
operator|->
name|TailEnd
argument_list|()
decl_stmt|;
name|int
name|tailLen
init|=
name|apaCmdLine
operator|.
name|Length
argument_list|()
decl_stmt|;
if|if
condition|(
name|tailLen
condition|)
block|{
name|apaTail
operator|=
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|qMalloc
argument_list|(
name|tailLen
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|qMemCopy
argument_list|(
name|apaTail
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|apaCmdLine
operator|.
name|Ptr
argument_list|()
argument_list|)
argument_list|,
name|tailLen
argument_list|)
expr_stmt|;
name|apaTail
index|[
name|tailLen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|apaArgv
operator|=
operator|new
name|QVector
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|// Reuse windows command line parsing
operator|*
name|apaArgv
operator|=
name|qWinCmdLine
argument_list|<
name|char
argument_list|>
argument_list|(
name|apaTail
argument_list|,
name|tailLen
argument_list|,
name|argc
argument_list|)
expr_stmt|;
name|apaArgv
operator|->
name|insert
argument_list|(
literal|0
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|argc
operator|++
expr_stmt|;
name|argv
operator|=
name|apaArgv
operator|->
name|data
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|symbianCommandLine
name|CApaCommandLine
modifier|*
name|QCoreApplicationPrivate
operator|::
name|symbianCommandLine
parameter_list|()
block|{
comment|// Getting of Apa command line needs to be static as it can only be called successfully
comment|// once per process.
if|if
condition|(
operator|!
name|apaCommandLine
condition|)
block|{
name|TInt
name|err
init|=
name|CApaCommandLine
operator|::
name|GetCommandLineFromProcessEnvironment
argument_list|(
name|apaCommandLine
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|KErrNone
condition|)
block|{
name|qAddPostRoutine
argument_list|(
name|qt_cleanup_apa_cmd_line
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|apaCommandLine
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
end_if
begin_function_decl
specifier|extern
name|QString
name|qAppFileName
parameter_list|()
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|member|app_compile_version
name|int
name|QCoreApplicationPrivate
operator|::
name|app_compile_version
init|=
literal|0x040000
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|app_compile_version
comment|//we don't know exactly, but it's at least 4.0.0
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT3_SUPPORT
argument_list|)
end_if
begin_decl_stmt
DECL|member|useQt3Support
name|bool
name|QCoreApplicationPrivate
operator|::
name|useQt3Support
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_MAC
end_ifdef
begin_function
DECL|function|macMenuBarName
name|QString
name|QCoreApplicationPrivate
operator|::
name|macMenuBarName
parameter_list|()
block|{
name|QString
name|bundleName
decl_stmt|;
name|CFTypeRef
name|string
init|=
name|CFBundleGetValueForInfoDictionaryKey
argument_list|(
name|CFBundleGetMainBundle
argument_list|()
argument_list|,
name|CFSTR
argument_list|(
literal|"CFBundleName"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|string
condition|)
name|bundleName
operator|=
name|QCFString
operator|::
name|toQString
argument_list|(
cast|static_cast
argument_list|<
name|CFStringRef
argument_list|>
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bundleName
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|appName
name|QString
name|QCoreApplicationPrivate
operator|::
name|appName
parameter_list|()
specifier|const
block|{
specifier|static
name|QString
name|applName
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
name|applName
operator|=
name|macMenuBarName
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|applName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|argv
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|applName
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|p
condition|?
name|p
operator|+
literal|1
else|:
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|applName
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|checkInstance
name|bool
name|QCoreApplicationPrivate
operator|::
name|checkInstance
parameter_list|(
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|bool
name|b
init|=
operator|(
name|QCoreApplication
operator|::
name|self
operator|!=
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|qWarning
argument_list|(
literal|"QApplication::%s: Please instantiate the QApplication object first"
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_comment
comment|// Support for introspection
end_comment
begin_decl_stmt
DECL|variable|qt_signal_spy_callback_set
name|QSignalSpyCallbackSet
name|Q_CORE_EXPORT
name|qt_signal_spy_callback_set
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_register_signal_spy_callbacks
name|void
name|qt_register_signal_spy_callbacks
parameter_list|(
specifier|const
name|QSignalSpyCallbackSet
modifier|&
name|callback_set
parameter_list|)
block|{
name|qt_signal_spy_callback_set
operator|=
name|callback_set
expr_stmt|;
block|}
end_function
begin_extern
DECL|function|qt_startup_hook
extern|extern
literal|"C"
name|void
name|Q_CORE_EXPORT
name|qt_startup_hook
parameter_list|()
block|{ }
end_extern
begin_typedef
DECL|typedef|QVFuncList
typedef|typedef
name|QList
argument_list|<
name|QtCleanUpFunction
argument_list|>
name|QVFuncList
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QVFuncList
argument_list|,
argument|postRList
argument_list|)
end_macro
begin_function
DECL|function|qAddPostRoutine
name|void
name|qAddPostRoutine
parameter_list|(
name|QtCleanUpFunction
name|p
parameter_list|)
block|{
name|QVFuncList
modifier|*
name|list
init|=
name|postRList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return;
name|list
operator|->
name|prepend
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qRemovePostRoutine
name|void
name|qRemovePostRoutine
parameter_list|(
name|QtCleanUpFunction
name|p
parameter_list|)
block|{
name|QVFuncList
modifier|*
name|list
init|=
name|postRList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return;
name|list
operator|->
name|removeAll
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_call_post_routines
name|void
name|Q_CORE_EXPORT
name|qt_call_post_routines
parameter_list|()
block|{
name|QVFuncList
modifier|*
name|list
init|=
literal|0
decl_stmt|;
name|QT_TRY
block|{
name|list
operator|=
name|postRList
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::bad_alloc&
argument_list|)
block|{
comment|// ignore - if we can't allocate a post routine list,
comment|// there's a high probability that there's no post
comment|// routine to be executed :)
block|}
if|if
condition|(
operator|!
name|list
condition|)
return|return;
while|while
condition|(
operator|!
name|list
operator|->
name|isEmpty
argument_list|()
condition|)
operator|(
name|list
operator|->
name|takeFirst
argument_list|()
operator|)
operator|(
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// app starting up if false
end_comment
begin_decl_stmt
DECL|member|is_app_running
name|bool
name|QCoreApplicationPrivate
operator|::
name|is_app_running
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|// app closing down if true
end_comment
begin_decl_stmt
DECL|member|is_app_closing
name|bool
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|// initialized in qcoreapplication and in qtextstream autotest when setlocale is called.
end_comment
begin_decl_stmt
DECL|variable|qt_locale_initialized
name|Q_CORE_EXPORT
name|bool
name|qt_locale_initialized
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*   Create an instance of Trolltech.conf. This ensures that the settings will not   be thrown out of QSetting's cache for unused settings.   */
end_comment
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|QSettings
argument_list|,
argument|staticTrolltechConf
argument_list|,
argument|(QSettings::UserScope, QLatin1String(
literal|"Trolltech"
argument|))
argument_list|)
end_macro
begin_function
DECL|function|trolltechConf
name|QSettings
modifier|*
name|QCoreApplicationPrivate
operator|::
name|trolltechConf
parameter_list|()
block|{
return|return
name|staticTrolltechConf
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|qGlobalPostedEventsCount
name|Q_CORE_EXPORT
name|uint
name|qGlobalPostedEventsCount
parameter_list|()
block|{
name|QThreadData
modifier|*
name|currentThreadData
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
return|return
name|currentThreadData
operator|->
name|postEventList
operator|.
name|size
argument_list|()
operator|-
name|currentThreadData
operator|->
name|postEventList
operator|.
name|startOffset
return|;
block|}
end_function
begin_function
DECL|function|qt_set_current_thread_to_main_thread
name|void
name|qt_set_current_thread_to_main_thread
parameter_list|()
block|{
name|QCoreApplicationPrivate
operator|::
name|theMainThread
operator|=
name|QThread
operator|::
name|currentThread
argument_list|()
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|member|self
name|QCoreApplication
modifier|*
name|QCoreApplication
operator|::
name|self
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|eventDispatcher
name|QAbstractEventDispatcher
modifier|*
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|attribs
name|uint
name|QCoreApplicationPrivate
operator|::
name|attribs
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_decl_stmt
DECL|variable|qt_application_thread_id
name|Qt
operator|::
name|HANDLE
name|qt_application_thread_id
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_struct
DECL|struct|QCoreApplicationData
struct|struct
name|QCoreApplicationData
block|{
DECL|function|QCoreApplicationData
name|QCoreApplicationData
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
name|app_libpaths
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
DECL|function|~QCoreApplicationData
name|~
name|QCoreApplicationData
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
operator|delete
name|app_libpaths
expr_stmt|;
endif|#
directive|endif
comment|// cleanup the QAdoptedThread created for the main() thread
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|theMainThread
condition|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|get2
argument_list|(
name|QCoreApplicationPrivate
operator|::
name|theMainThread
argument_list|)
decl_stmt|;
name|QCoreApplicationPrivate
operator|::
name|theMainThread
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|deref
argument_list|()
expr_stmt|;
comment|// deletes the data and the adopted thread
block|}
block|}
DECL|member|orgName
DECL|member|orgDomain
DECL|member|application
name|QString
name|orgName
decl_stmt|,
name|orgDomain
decl_stmt|,
name|application
decl_stmt|;
DECL|member|applicationVersion
name|QString
name|applicationVersion
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
DECL|member|app_libpaths
name|QStringList
modifier|*
name|app_libpaths
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QCoreApplicationData
argument_list|,
argument|coreappdata
argument_list|)
end_macro
begin_constructor
DECL|function|QCoreApplicationPrivate
name|QCoreApplicationPrivate
operator|::
name|QCoreApplicationPrivate
parameter_list|(
name|int
modifier|&
name|aargc
parameter_list|,
name|char
modifier|*
modifier|*
name|aargv
parameter_list|,
name|uint
name|flags
parameter_list|)
member_init_list|:
name|QObjectPrivate
argument_list|()
member_init_list|,
name|argc
argument_list|(
name|aargc
argument_list|)
member_init_list|,
name|argv
argument_list|(
name|aargv
argument_list|)
member_init_list|,
name|application_type
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|eventFilter
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|in_exec
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|aboutToQuitEmitted
argument_list|(
literal|false
argument_list|)
block|{
name|app_compile_version
operator|=
name|flags
operator|&
literal|0xffffff
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT3_SUPPORT
argument_list|)
name|useQt3Support
operator|=
operator|!
operator|(
name|flags
operator|&
literal|0x01000000
operator|)
expr_stmt|;
endif|#
directive|endif
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|empty
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|||
name|argv
operator|==
literal|0
condition|)
block|{
name|argc
operator|=
literal|0
expr_stmt|;
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|empty
expr_stmt|;
comment|// ouch! careful with QCoreApplication::argv()!
block|}
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
operator|=
literal|false
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
name|qt_init_symbian_apa_arguments
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|qt_application_thread_id
operator|=
name|QThread
operator|::
name|currentThreadId
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// note: this call to QThread::currentThread() may end up setting theMainThread!
if|if
condition|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|!=
name|theMainThread
condition|)
name|qWarning
argument_list|(
literal|"WARNING: QApplication was not created in the main() thread."
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QCoreApplicationPrivate
name|QCoreApplicationPrivate
operator|::
name|~
name|QCoreApplicationPrivate
parameter_list|()
block|{
if|if
condition|(
name|threadData
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|void
modifier|*
name|data
init|=
operator|&
name|threadData
operator|->
name|tls
decl_stmt|;
name|QThreadStorageData
operator|::
name|finish
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// need to clear the state of the mainData, just in case a new QCoreApplication comes along.
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|threadData
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadData
operator|->
name|postEventList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|pe
init|=
name|threadData
operator|->
name|postEventList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|pe
operator|.
name|event
condition|)
block|{
operator|--
name|pe
operator|.
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|pe
operator|.
name|event
operator|->
name|posted
operator|=
literal|false
expr_stmt|;
operator|delete
name|pe
operator|.
name|event
expr_stmt|;
block|}
block|}
name|threadData
operator|->
name|postEventList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|threadData
operator|->
name|postEventList
operator|.
name|recursion
operator|=
literal|0
expr_stmt|;
name|threadData
operator|->
name|quitNow
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|createEventDispatcher
name|void
name|QCoreApplicationPrivate
operator|::
name|createEventDispatcher
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QCoreApplication
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherSymbian
argument_list|(
name|q
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_GLIB
argument_list|)
if|if
condition|(
name|qgetenv
argument_list|(
literal|"QT_NO_GLIB"
argument_list|)
operator|.
name|isEmpty
argument_list|()
operator|&&
name|QEventDispatcherGlib
operator|::
name|versionSupported
argument_list|()
condition|)
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherGlib
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherUNIX
argument_list|(
name|q
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherWin32
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"QEventDispatcher not yet ported to this platform"
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|_q_initializeProcessManager
name|void
name|QCoreApplicationPrivate
operator|::
name|_q_initializeProcessManager
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_PROCESS
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|QProcessPrivate
operator|::
name|initializeProcessManager
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_decl_stmt
DECL|member|theMainThread
name|QThread
modifier|*
name|QCoreApplicationPrivate
operator|::
name|theMainThread
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|mainThread
name|QThread
modifier|*
name|QCoreApplicationPrivate
operator|::
name|mainThread
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|theMainThread
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|theMainThread
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_MAC_FRAMEWORK_BUILD
argument_list|)
end_if
begin_function
DECL|function|checkReceiverThread
name|void
name|QCoreApplicationPrivate
operator|::
name|checkReceiverThread
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|)
block|{
name|QThread
modifier|*
name|currentThread
init|=
name|QThread
operator|::
name|currentThread
argument_list|()
decl_stmt|;
name|QThread
modifier|*
name|thr
init|=
name|receiver
operator|->
name|thread
argument_list|()
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|currentThread
operator|==
name|thr
operator|||
operator|!
name|thr
argument_list|,
literal|"QCoreApplication::sendEvent"
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Cannot send events to objects owned by a different thread. "
literal|"Current thread %1. Receiver '%2' (of type '%3') was created in thread %4"
argument_list|)
operator|.
name|arg
argument_list|(
name|QString
operator|::
name|number
argument_list|(
operator|(
name|quintptr
operator|)
name|currentThread
argument_list|,
literal|16
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|receiver
operator|->
name|objectName
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|QString
operator|::
name|number
argument_list|(
operator|(
name|quintptr
operator|)
name|thr
argument_list|,
literal|16
argument_list|)
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|currentThread
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|thr
argument_list|)
expr_stmt|;
block|}
end_function
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
end_elif
begin_comment
comment|// no implementation in release builds, but keep the symbol present
end_comment
begin_function
DECL|function|checkReceiverThread
name|void
name|QCoreApplicationPrivate
operator|::
name|checkReceiverThread
parameter_list|(
name|QObject
modifier|*
comment|/* receiver */
parameter_list|)
block|{ }
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|appendApplicationPathToLibraryPaths
name|void
name|QCoreApplicationPrivate
operator|::
name|appendApplicationPathToLibraryPaths
parameter_list|()
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_LIBRARY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_SETTINGS
argument_list|)
name|QStringList
modifier|*
name|app_libpaths
init|=
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|app_libpaths
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
name|QString
name|app_location
argument_list|(
name|QCoreApplication
operator|::
name|applicationDirPath
argument_list|()
argument_list|)
decl_stmt|;
comment|// File existence check for application's private dir requires additional '\' or
comment|// platform security will not allow it.
if|if
condition|(
name|app_location
operator|!=
name|QLibraryInfo
operator|::
name|location
argument_list|(
name|QLibraryInfo
operator|::
name|PluginsPath
argument_list|)
operator|&&
name|QFile
operator|::
name|exists
argument_list|(
name|app_location
operator|+
name|QLatin1Char
argument_list|(
literal|'\\'
argument_list|)
argument_list|)
operator|&&
operator|!
name|app_libpaths
operator|->
name|contains
argument_list|(
name|app_location
argument_list|)
condition|)
else|#
directive|else
name|QString
name|app_location
argument_list|(
name|QCoreApplication
operator|::
name|applicationFilePath
argument_list|()
argument_list|)
decl_stmt|;
name|app_location
operator|.
name|truncate
argument_list|(
name|app_location
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|app_location
operator|=
name|QDir
argument_list|(
name|app_location
argument_list|)
operator|.
name|canonicalPath
argument_list|()
expr_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|app_location
argument_list|)
operator|&&
operator|!
name|app_libpaths
operator|->
name|contains
argument_list|(
name|app_location
argument_list|)
condition|)
endif|#
directive|endif
name|app_libpaths
operator|->
name|append
argument_list|(
name|app_location
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|qAppName
name|QString
name|qAppName
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"qAppName"
argument_list|)
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|appName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \class QCoreApplication     \brief The QCoreApplication class provides an event loop for console Qt     applications.      This class is used by non-GUI applications to provide their event     loop. For non-GUI application that uses Qt, there should be exactly     one QCoreApplication object. For GUI applications, see     QApplication.      QCoreApplication contains the main event loop, where all events     from the operating system (e.g., timer and network events) and     other sources are processed and dispatched. It also handles the     application's initialization and finalization, as well as     system-wide and application-wide settings.      \section1 The Event Loop and Event Handling      The event loop is started with a call to exec(). Long running     operations can call processEvents() to keep the application     responsive.      In general, we recommend that you create a QCoreApplication or a     QApplication object in your \c main() function as early as     possible. exec() will not return until the event loop exits; e.g.,     when quit() is called.      Several static convenience functions are also provided. The     QCoreApplication object is available from instance(). Events can     be sent or posted using sendEvent(), postEvent(), and     sendPostedEvents(). Pending events can be removed with     removePostedEvents() or flushed with flush().      The class provides a quit() slot and an aboutToQuit() signal.      \section1 Application and Library Paths      An application has an applicationDirPath() and an     applicationFilePath(). Library paths (see QLibrary) can be retrieved     with libraryPaths() and manipulated by setLibraryPaths(), addLibraryPath(),     and removeLibraryPath().      \section1 Internationalization and Translations      Translation files can be added or removed     using installTranslator() and removeTranslator(). Application     strings can be translated using translate(). The QObject::tr()     and QObject::trUtf8() functions are implemented in terms of     translate().      \section1 Accessing Command Line Arguments      The command line arguments which are passed to QCoreApplication's     constructor should be accessed using the arguments() function.     Note that some arguments supplied by the user may have been     processed and removed by QCoreApplication.      In cases where command line arguments need to be obtained using the     argv() function, you must convert them from the local string encoding     using QString::fromLocal8Bit().      \section1 Locale Settings      On Unix/Linux Qt is configured to use the system locale settings by     default. This can cause a conflict when using POSIX functions, for     instance, when converting between data types such as floats and     strings, since the notation may differ between locales. To get     around this problem, call the POSIX function \c{setlocale(LC_NUMERIC,"C")}     right after initializing QApplication or QCoreApplication to reset     the locale that is used for number formatting to "C"-locale.      \sa QApplication, QAbstractEventDispatcher, QEventLoop,     {Semaphores Example}, {Wait Conditions Example} */
end_comment
begin_comment
comment|/*!     \fn static QCoreApplication *QCoreApplication::instance()      Returns a pointer to the application's QCoreApplication (or     QApplication) instance.      If no instance has been allocated, \c null is returned. */
end_comment
begin_comment
comment|/*!\internal  */
end_comment
begin_constructor
DECL|function|QCoreApplication
name|QCoreApplication
operator|::
name|QCoreApplication
parameter_list|(
name|QCoreApplicationPrivate
modifier|&
name|p
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
block|{
name|init
argument_list|()
expr_stmt|;
comment|// note: it is the subclasses' job to call
comment|// QCoreApplicationPrivate::eventDispatcher->startingUp();
block|}
end_constructor
begin_comment
comment|/*!     Flushes the platform specific event queues.      If you are doing graphical changes inside a loop that does not     return to the event loop on asynchronous window systems like X11     or double buffered window systems like Mac OS X, and you want to     visualize these changes immediately (e.g. Splash Screens), call     this function.      \sa sendPostedEvents() */
end_comment
begin_function
DECL|function|flush
name|void
name|QCoreApplication
operator|::
name|flush
parameter_list|()
block|{
if|if
condition|(
name|self
operator|&&
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|eventDispatcher
condition|)
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|eventDispatcher
operator|->
name|flush
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a Qt kernel application. Kernel applications are     applications without a graphical user interface. These type of     applications are used at the console or as server processes.      The \a argc and \a argv arguments are processed by the application,     and made available in a more convenient form by the arguments()     function.      \warning The data referred to by \a argc and \a argv must stay valid     for the entire lifetime of the QCoreApplication object. In addition,     \a argc must be greater than zero and \a argv must contain at least     one valid character string. */
end_comment
begin_constructor
DECL|function|QCoreApplication
name|QCoreApplication
operator|::
name|QCoreApplication
parameter_list|(
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QCoreApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|0x040000
argument_list|)
argument_list|)
block|{
name|init
argument_list|()
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|startingUp
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_LIBRARY
argument_list|)
comment|// Refresh factoryloader, as text codecs are requested during lib path
comment|// resolving process and won't be therefore properly loaded.
comment|// Unknown if this is symbian specific issue.
name|QFactoryLoader
operator|::
name|refreshAll
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_SYSTEMLOCALE
argument_list|)
name|d_func
argument_list|()
operator|->
name|symbianInit
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_constructor
DECL|function|QCoreApplication
name|QCoreApplication
operator|::
name|QCoreApplication
parameter_list|(
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|_internal
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QCoreApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|_internal
argument_list|)
argument_list|)
block|{
name|init
argument_list|()
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|startingUp
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
comment|// Refresh factoryloader, as text codecs are requested during lib path
comment|// resolving process and won't be therefore properly loaded.
comment|// Unknown if this is symbian specific issue.
name|QFactoryLoader
operator|::
name|refreshAll
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SYSTEMLOCALE
name|d_func
argument_list|()
operator|->
name|symbianInit
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|//Q_OS_SYMBIAN
block|}
end_constructor
begin_comment
comment|// ### move to QCoreApplicationPrivate constructor?
end_comment
begin_function
DECL|function|init
name|void
name|QCoreApplication
operator|::
name|init
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QCoreApplication
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|// use correct char set mapping
name|qt_locale_initialized
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
name|Q_ASSERT_X
argument_list|(
operator|!
name|self
argument_list|,
literal|"QCoreApplication"
argument_list|,
literal|"there should be only one application object"
argument_list|)
expr_stmt|;
name|QCoreApplication
operator|::
name|self
operator|=
name|this
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
comment|//ensure temp and working directories exist
name|QFileSystemEngine
operator|::
name|createDirectory
argument_list|(
name|QFileSystemEntry
argument_list|(
name|QFileSystemEngine
operator|::
name|tempPath
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QFileSystemEngine
operator|::
name|createDirectory
argument_list|(
name|QFileSystemEntry
argument_list|(
name|QFileSystemEngine
operator|::
name|currentPath
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|QThread
operator|::
name|initialize
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// use the event dispatcher created by the app programmer (if any)
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
condition|)
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|=
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
expr_stmt|;
comment|// otherwise we create one
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
condition|)
name|d
operator|->
name|createEventDispatcher
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|parent
argument_list|()
condition|)
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|moveToThread
argument_list|(
name|d
operator|->
name|threadData
operator|->
name|thread
argument_list|)
expr_stmt|;
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|=
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_LIBRARY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_SETTINGS
argument_list|)
if|if
condition|(
operator|!
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
condition|)
block|{
comment|// make sure that library paths is initialized
name|libraryPaths
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|appendApplicationPathToLibraryPaths
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_EVAL
specifier|extern
name|void
name|qt_core_eval_init
argument_list|(
name|uint
argument_list|)
decl_stmt|;
name|qt_core_eval_init
argument_list|(
name|d
operator|->
name|application_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|Q_CC_NOKIAX86
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
comment|/**      * Prevent the executable from being locked in the Symbian emulator. The      * code dramatically simplifies debugging on Symbian, but beyond that has      * no impact.      *      * Force the ZLazyUnloadTimer to fire and therefore unload code segments      * immediately. The code affects Symbian's file server and on the other      * hand needs only to be run once in each emulator run.      */
block|{
name|RLoader
name|loader
decl_stmt|;
name|CleanupClosePushL
argument_list|(
name|loader
argument_list|)
expr_stmt|;
name|User
operator|::
name|LeaveIfError
argument_list|(
name|loader
operator|.
name|Connect
argument_list|()
argument_list|)
expr_stmt|;
name|User
operator|::
name|LeaveIfError
argument_list|(
name|loader
operator|.
name|CancelLazyDllUnload
argument_list|()
argument_list|)
expr_stmt|;
name|CleanupStack
operator|::
name|PopAndDestroy
argument_list|(
operator|&
name|loader
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|qt_startup_hook
argument_list|()
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_SYSTEMLOCALE
argument_list|)
end_if
begin_function
DECL|function|symbianInit
name|void
name|QCoreApplicationPrivate
operator|::
name|symbianInit
parameter_list|()
block|{
if|if
condition|(
operator|!
name|environmentChangeNotifier
condition|)
name|environmentChangeNotifier
operator|.
name|reset
argument_list|(
operator|new
name|QEnvironmentChangeNotifier
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Destroys the QCoreApplication object. */
end_comment
begin_destructor
DECL|function|~QCoreApplication
name|QCoreApplication
operator|::
name|~
name|QCoreApplication
parameter_list|()
block|{
name|qt_call_post_routines
argument_list|()
expr_stmt|;
name|self
operator|=
literal|0
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
operator|=
literal|true
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|is_app_running
operator|=
literal|false
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_CONCURRENT
argument_list|)
comment|// Synchronize and stop the global thread pool threads.
name|QThreadPool
modifier|*
name|globalThreadPool
init|=
literal|0
decl_stmt|;
name|QT_TRY
block|{
name|globalThreadPool
operator|=
name|QThreadPool
operator|::
name|globalInstance
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// swallow the exception, since destructors shouldn't throw
block|}
if|if
condition|(
name|globalThreadPool
condition|)
name|globalThreadPool
operator|->
name|waitForDone
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QThread
operator|::
name|cleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|d_func
argument_list|()
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
condition|)
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|closingDown
argument_list|()
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
operator|delete
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
expr_stmt|;
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_comment
comment|/*!     Sets the attribute \a attribute if \a on is true;     otherwise clears the attribute.      One of the attributes that can be set with this method is     Qt::AA_ImmediateWidgetCreation. It tells Qt to create toplevel     windows immediately. Normally, resources for widgets are allocated     on demand to improve efficiency and minimize resource usage.     Therefore, if it is important to minimize resource consumption, do     not set this attribute.      \sa testAttribute() */
end_comment
begin_function
DECL|function|setAttribute
name|void
name|QCoreApplication
operator|::
name|setAttribute
parameter_list|(
name|Qt
operator|::
name|ApplicationAttribute
name|attribute
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
if|if
condition|(
name|on
condition|)
name|QCoreApplicationPrivate
operator|::
name|attribs
operator||=
literal|1
operator|<<
name|attribute
expr_stmt|;
else|else
name|QCoreApplicationPrivate
operator|::
name|attribs
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|attribute
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
comment|// Turn on the no native menubar here, since we used to
comment|// do this implicitly. We DO NOT flip it off if someone sets
comment|// it to false.
comment|// Ideally, we'd have magic that would be something along the lines of
comment|// "follow MacPluginApplication" unless explicitly set.
comment|// Considering this attribute isn't only at the beginning
comment|// it's unlikely it will ever be a problem, but I want
comment|// to have the behavior documented here.
if|if
condition|(
name|attribute
operator|==
name|Qt
operator|::
name|AA_MacPluginApplication
operator|&&
name|on
operator|&&
operator|!
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_DontUseNativeMenuBar
argument_list|)
condition|)
block|{
name|setAttribute
argument_list|(
name|Qt
operator|::
name|AA_DontUseNativeMenuBar
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!   Returns true if attribute \a attribute is set;   otherwise returns false.    \sa setAttribute()  */
end_comment
begin_function
DECL|function|testAttribute
name|bool
name|QCoreApplication
operator|::
name|testAttribute
parameter_list|(
name|Qt
operator|::
name|ApplicationAttribute
name|attribute
parameter_list|)
block|{
return|return
name|QCoreApplicationPrivate
operator|::
name|testAttribute
argument_list|(
name|attribute
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    This function is here to make it possible for Qt extensions to   hook into event notification without subclassing QApplication */
end_comment
begin_function
DECL|function|notifyInternal
name|bool
name|QCoreApplication
operator|::
name|notifyInternal
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
comment|// Make it possible for Qt Jambi and QSA to hook into events even
comment|// though QApplication is subclassed...
name|bool
name|result
init|=
literal|false
decl_stmt|;
name|void
modifier|*
name|cbdata
index|[]
init|=
block|{
name|receiver
block|,
name|event
block|,
operator|&
name|result
block|}
decl_stmt|;
if|if
condition|(
name|QInternal
operator|::
name|activateCallbacks
argument_list|(
name|QInternal
operator|::
name|EventNotifyCallback
argument_list|,
name|cbdata
argument_list|)
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Qt enforces the rule that events can only be sent to objects in
comment|// the current thread, so receiver->d_func()->threadData is
comment|// equivalent to QThreadData::current(), just without the function
comment|// call overhead.
name|QObjectPrivate
modifier|*
name|d
init|=
name|receiver
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|QThreadData
modifier|*
name|threadData
init|=
name|d
operator|->
name|threadData
decl_stmt|;
operator|++
name|threadData
operator|->
name|loopLevel
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_JAMBI_BUILD
name|int
name|deleteWatch
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|oldDeleteWatch
init|=
name|QObjectPrivate
operator|::
name|setDeleteWatch
argument_list|(
name|d
argument_list|,
operator|&
name|deleteWatch
argument_list|)
decl_stmt|;
name|bool
name|inEvent
init|=
name|d
operator|->
name|inEventHandler
decl_stmt|;
name|d
operator|->
name|inEventHandler
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
name|bool
name|returnValue
decl_stmt|;
name|QT_TRY
block|{
name|returnValue
operator|=
name|notify
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
operator|--
name|threadData
operator|->
name|loopLevel
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_JAMBI_BUILD
comment|// Restore the previous state if the object was not deleted..
if|if
condition|(
operator|!
name|deleteWatch
condition|)
block|{
name|d
operator|->
name|inEventHandler
operator|=
name|inEvent
expr_stmt|;
block|}
name|QObjectPrivate
operator|::
name|resetDeleteWatch
argument_list|(
name|d
argument_list|,
name|oldDeleteWatch
argument_list|,
name|deleteWatch
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|threadData
operator|->
name|loopLevel
expr_stmt|;
return|return
name|returnValue
return|;
block|}
end_function
begin_comment
comment|/*!   Sends \a event to \a receiver: \a {receiver}->event(\a event).   Returns the value that is returned from the receiver's event   handler. Note that this function is called for all events sent to   any object in any thread.    For certain types of events (e.g. mouse and key events),   the event will be propagated to the receiver's parent and so on up to   the top-level object if the receiver is not interested in the event   (i.e., it returns false).    There are five different ways that events can be processed;   reimplementing this virtual function is just one of them. All five   approaches are listed below:   \list 1   \i Reimplementing paintEvent(), mousePressEvent() and so   on. This is the commonest, easiest and least powerful way.    \i Reimplementing this function. This is very powerful, providing   complete control; but only one subclass can be active at a time.    \i Installing an event filter on QCoreApplication::instance(). Such   an event filter is able to process all events for all widgets, so   it's just as powerful as reimplementing notify(); furthermore, it's   possible to have more than one application-global event filter.   Global event filters even see mouse events for   \l{QWidget::isEnabled()}{disabled widgets}. Note that application   event filters are only called for objects that live in the main   thread.    \i Reimplementing QObject::event() (as QWidget does). If you do   this you get Tab key presses, and you get to see the events before   any widget-specific event filters.    \i Installing an event filter on the object. Such an event filter gets all   the events, including Tab and Shift+Tab key press events, as long as they   do not change the focus widget.   \endlist    \sa QObject::event(), installEventFilter() */
end_comment
begin_function
DECL|function|notify
name|bool
name|QCoreApplication
operator|::
name|notify
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCoreApplication
argument_list|)
expr_stmt|;
comment|// no events are delivered after ~QCoreApplication() has started
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|receiver
operator|==
literal|0
condition|)
block|{
comment|// serious error
name|qWarning
argument_list|(
literal|"QCoreApplication::notify: Unexpected null receiver"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|d
operator|->
name|checkReceiverThread
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|receiver
operator|->
name|isWidgetType
argument_list|()
condition|?
literal|false
else|:
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sendThroughApplicationEventFilters
name|bool
name|QCoreApplicationPrivate
operator|::
name|sendThroughApplicationEventFilters
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|==
name|this
operator|->
name|threadData
condition|)
block|{
comment|// application event filters are only called for objects in the GUI thread
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|eventFilters
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|QObject
modifier|*
name|obj
init|=
name|eventFilters
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
if|if
condition|(
name|obj
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|!=
name|threadData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication: Application event filter cannot be in a different thread."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|obj
operator|->
name|eventFilter
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|sendThroughObjectEventFilters
name|bool
name|QCoreApplicationPrivate
operator|::
name|sendThroughObjectEventFilters
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QCoreApplication
argument_list|)
expr_stmt|;
if|if
condition|(
name|receiver
operator|!=
name|q
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|eventFilters
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|QObject
modifier|*
name|obj
init|=
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|eventFilters
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
if|if
condition|(
name|obj
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|!=
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication: Object event filter cannot be in a different thread."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|obj
operator|->
name|eventFilter
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!\internal    Helper function called by notify()  */
end_comment
begin_function
DECL|function|notify_helper
name|bool
name|QCoreApplicationPrivate
operator|::
name|notify_helper
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
comment|// send to all application event filters
if|if
condition|(
name|sendThroughApplicationEventFilters
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// send to all receiver event filters
if|if
condition|(
name|sendThroughObjectEventFilters
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// deliver the event
return|return
name|receiver
operator|->
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if an application object has not been created yet;   otherwise returns false.    \sa closingDown() */
end_comment
begin_function
DECL|function|startingUp
name|bool
name|QCoreApplication
operator|::
name|startingUp
parameter_list|()
block|{
return|return
operator|!
name|QCoreApplicationPrivate
operator|::
name|is_app_running
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if the application objects are being destroyed;   otherwise returns false.    \sa startingUp() */
end_comment
begin_function
DECL|function|closingDown
name|bool
name|QCoreApplication
operator|::
name|closingDown
parameter_list|()
block|{
return|return
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
return|;
block|}
end_function
begin_comment
comment|/*!     Processes all pending events for the calling thread according to     the specified \a flags until there are no more events to process.      You can call this function occasionally when your program is busy     performing a long operation (e.g. copying a file).      In event you are running a local loop which calls this function     continuously, without an event loop, the     \l{QEvent::DeferredDelete}{DeferredDelete} events will     not be processed. This can affect the behaviour of widgets,     e.g. QToolTip, that rely on \l{QEvent::DeferredDelete}{DeferredDelete}     events to function properly. An alternative would be to call     \l{QCoreApplication::sendPostedEvents()}{sendPostedEvents()} from     within that local loop.      Calling this function processes events only for the calling thread.      \threadsafe      \sa exec(), QTimer, QEventLoop::processEvents(), flush(), sendPostedEvents() */
end_comment
begin_function
DECL|function|processEvents
name|void
name|QCoreApplication
operator|::
name|processEvents
parameter_list|(
name|QEventLoop
operator|::
name|ProcessEventsFlags
name|flags
parameter_list|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|eventDispatcher
condition|)
return|return;
if|if
condition|(
name|flags
operator|&
name|QEventLoop
operator|::
name|DeferredDeletion
condition|)
name|QCoreApplication
operator|::
name|sendPostedEvents
argument_list|(
literal|0
argument_list|,
name|QEvent
operator|::
name|DeferredDelete
argument_list|)
expr_stmt|;
name|data
operator|->
name|eventDispatcher
operator|->
name|processEvents
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload processEvents()      Processes pending events for the calling thread for \a maxtime     milliseconds or until there are no more events to process,     whichever is shorter.      You can call this function occasionally when you program is busy     doing a long operation (e.g. copying a file).      Calling this function processes events only for the calling thread.      \threadsafe      \sa exec(), QTimer, QEventLoop::processEvents() */
end_comment
begin_function
DECL|function|processEvents
name|void
name|QCoreApplication
operator|::
name|processEvents
parameter_list|(
name|QEventLoop
operator|::
name|ProcessEventsFlags
name|flags
parameter_list|,
name|int
name|maxtime
parameter_list|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|eventDispatcher
condition|)
return|return;
name|QElapsedTimer
name|start
decl_stmt|;
name|start
operator|.
name|start
parameter_list|()
constructor_decl|;
if|if
condition|(
name|flags
operator|&
name|QEventLoop
operator|::
name|DeferredDeletion
condition|)
name|QCoreApplication
operator|::
name|sendPostedEvents
argument_list|(
literal|0
argument_list|,
name|QEvent
operator|::
name|DeferredDelete
argument_list|)
expr_stmt|;
while|while
condition|(
name|data
operator|->
name|eventDispatcher
operator|->
name|processEvents
argument_list|(
name|flags
operator|&
operator|~
name|QEventLoop
operator|::
name|WaitForMoreEvents
argument_list|)
condition|)
block|{
if|if
condition|(
name|start
operator|.
name|elapsed
argument_list|()
operator|>
name|maxtime
condition|)
break|break;
if|if
condition|(
name|flags
operator|&
name|QEventLoop
operator|::
name|DeferredDeletion
condition|)
name|QCoreApplication
operator|::
name|sendPostedEvents
argument_list|(
literal|0
argument_list|,
name|QEvent
operator|::
name|DeferredDelete
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*****************************************************************************   Main event loop wrappers  *****************************************************************************/
end_comment
begin_comment
comment|/*!     Enters the main event loop and waits until exit() is called.     Returns the value that was set to exit() (which is 0 if exit() is     called via quit()).      It is necessary to call this function to start event handling. The     main event loop receives events from the window system and     dispatches these to the application widgets.      To make your application perform idle processing (i.e. executing a     special function whenever there are no pending events), use a     QTimer with 0 timeout. More advanced idle processing schemes can     be achieved using processEvents().      We recommend that you connect clean-up code to the     \l{QCoreApplication::}{aboutToQuit()} signal, instead of putting it in     your application's \c{main()} function because on some platforms the     QCoreApplication::exec() call may not return. For example, on Windows     when the user logs off, the system terminates the process after Qt     closes all top-level windows. Hence, there is no guarantee that the     application will have time to exit its event loop and execute code at     the end of the \c{main()} function after the QCoreApplication::exec()     call.      \sa quit(), exit(), processEvents(), QApplication::exec() */
end_comment
begin_function
DECL|function|exec
name|int
name|QCoreApplication
operator|::
name|exec
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"exec"
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|QThreadData
modifier|*
name|threadData
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
decl_stmt|;
if|if
condition|(
name|threadData
operator|!=
name|QThreadData
operator|::
name|current
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"%s::exec: Must be called from the main thread"
argument_list|,
name|self
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|threadData
operator|->
name|eventLoops
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::exec: The event loop is already running"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|threadData
operator|->
name|quitNow
operator|=
literal|false
expr_stmt|;
name|QEventLoop
name|eventLoop
decl_stmt|;
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|in_exec
operator|=
literal|true
expr_stmt|;
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|aboutToQuitEmitted
operator|=
literal|false
expr_stmt|;
name|int
name|returnCode
init|=
name|eventLoop
operator|.
name|exec
argument_list|()
decl_stmt|;
name|threadData
operator|->
name|quitNow
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|self
condition|)
block|{
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|in_exec
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|aboutToQuitEmitted
condition|)
emit|emit
name|self
operator|->
name|aboutToQuit
argument_list|()
emit|;
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|aboutToQuitEmitted
operator|=
literal|true
expr_stmt|;
name|sendPostedEvents
argument_list|(
literal|0
argument_list|,
name|QEvent
operator|::
name|DeferredDelete
argument_list|)
expr_stmt|;
block|}
return|return
name|returnCode
return|;
block|}
end_function
begin_comment
comment|/*!   Tells the application to exit with a return code.      After this function has been called, the application leaves the     main event loop and returns from the call to exec(). The exec()     function returns \a returnCode. If the event loop is not running,     this function does nothing.    By convention, a \a returnCode of 0 means success, and any non-zero   value indicates an error.    Note that unlike the C library function of the same name, this   function \e does return to the caller -- it is event processing that   stops.    \sa quit(), exec() */
end_comment
begin_function
DECL|function|exit
name|void
name|QCoreApplication
operator|::
name|exit
parameter_list|(
name|int
name|returnCode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|self
condition|)
return|return;
name|QThreadData
modifier|*
name|data
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
decl_stmt|;
name|data
operator|->
name|quitNow
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|eventLoops
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QEventLoop
modifier|*
name|eventLoop
init|=
name|data
operator|->
name|eventLoops
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|eventLoop
operator|->
name|exit
argument_list|(
name|returnCode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*****************************************************************************   QCoreApplication management of posted events  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \fn bool QCoreApplication::sendEvent(QObject *receiver, QEvent *event)      Sends event \a event directly to receiver \a receiver, using the     notify() function. Returns the value that was returned from the     event handler.      The event is \e not deleted when the event has been sent. The normal     approach is to create the event on the stack, for example:      \snippet doc/src/snippets/code/src_corelib_kernel_qcoreapplication.cpp 0      \sa postEvent(), notify() */
end_comment
begin_comment
comment|/*!     Adds the event \a event, with the object \a receiver as the     receiver of the event, to an event queue and returns immediately.      The event must be allocated on the heap since the post event queue     will take ownership of the event and delete it once it has been     posted.  It is \e {not safe} to access the event after     it has been posted.      When control returns to the main event loop, all events that are     stored in the queue will be sent using the notify() function.      Events are processed in the order posted. For more control over     the processing order, use the postEvent() overload below, which     takes a priority argument. This function posts all event with a     Qt::NormalEventPriority.      \threadsafe      \sa sendEvent(), notify(), sendPostedEvents() */
end_comment
begin_function
DECL|function|postEvent
name|void
name|QCoreApplication
operator|::
name|postEvent
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|postEvent
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|,
name|Qt
operator|::
name|NormalEventPriority
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload postEvent()     \since 4.3      Adds the event \a event, with the object \a receiver as the     receiver of the event, to an event queue and returns immediately.      The event must be allocated on the heap since the post event queue     will take ownership of the event and delete it once it has been     posted.  It is \e {not safe} to access the event after     it has been posted.      When control returns to the main event loop, all events that are     stored in the queue will be sent using the notify() function.      Events are sorted in descending \a priority order, i.e. events     with a high \a priority are queued before events with a lower \a     priority. The \a priority can be any integer value, i.e. between     INT_MAX and INT_MIN, inclusive; see Qt::EventPriority for more     details. Events with equal \a priority will be processed in the     order posted.      \threadsafe      \sa sendEvent(), notify(), sendPostedEvents(), Qt::EventPriority */
end_comment
begin_function
DECL|function|postEvent
name|void
name|QCoreApplication
operator|::
name|postEvent
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
if|if
condition|(
name|receiver
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::postEvent: Unexpected null receiver"
argument_list|)
expr_stmt|;
operator|delete
name|event
expr_stmt|;
return|return;
block|}
name|QThreadData
modifier|*
specifier|volatile
modifier|*
name|pdata
init|=
operator|&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
decl_stmt|;
name|QThreadData
modifier|*
name|data
init|=
operator|*
name|pdata
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
comment|// posting during destruction? just delete the event to prevent a leak
operator|delete
name|event
expr_stmt|;
return|return;
block|}
comment|// lock the post event mutex
name|data
operator|->
name|postEventList
operator|.
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// if object has moved to another thread, follow it
while|while
condition|(
name|data
operator|!=
operator|*
name|pdata
condition|)
block|{
name|data
operator|->
name|postEventList
operator|.
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|data
operator|=
operator|*
name|pdata
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
comment|// posting during destruction? just delete the event to prevent a leak
operator|delete
name|event
expr_stmt|;
return|return;
block|}
name|data
operator|->
name|postEventList
operator|.
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
name|QMutexUnlocker
name|locker
argument_list|(
operator|&
name|data
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
comment|// if this is one of the compressible events, do compression
if|if
condition|(
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|&&
name|self
operator|&&
name|self
operator|->
name|compressEvent
argument_list|(
name|event
argument_list|,
name|receiver
argument_list|,
operator|&
name|data
operator|->
name|postEventList
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DeferredDelete
operator|&&
name|data
operator|==
name|QThreadData
operator|::
name|current
argument_list|()
condition|)
block|{
comment|// remember the current running eventloop for DeferredDelete
comment|// events posted in the receiver's thread
name|event
operator|->
name|d
operator|=
cast|reinterpret_cast
argument_list|<
name|QEventPrivate
operator|*
argument_list|>
argument_list|(
name|quintptr
argument_list|(
name|data
operator|->
name|loopLevel
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// delete the event on exceptions to protect against memory leaks till the event is
comment|// properly owned in the postEventList
name|QScopedPointer
argument_list|<
name|QEvent
argument_list|>
name|eventDeleter
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|postEventList
operator|.
name|isEmpty
argument_list|()
operator|||
name|data
operator|->
name|postEventList
operator|.
name|last
argument_list|()
operator|.
name|priority
operator|>=
name|priority
condition|)
block|{
comment|// optimization: we can simply append if the last event in
comment|// the queue has higher or equal priority
name|data
operator|->
name|postEventList
operator|.
name|append
argument_list|(
name|QPostEvent
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|,
name|priority
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// insert event in descending priority order, using upper
comment|// bound for a given priority (to ensure proper ordering
comment|// of events with the same priority)
name|QPostEventList
operator|::
name|iterator
name|begin
init|=
name|data
operator|->
name|postEventList
operator|.
name|begin
argument_list|()
operator|+
name|data
operator|->
name|postEventList
operator|.
name|insertionOffset
decl_stmt|,
name|end
init|=
name|data
operator|->
name|postEventList
operator|.
name|end
argument_list|()
decl_stmt|;
name|QPostEventList
operator|::
name|iterator
name|at
init|=
name|qUpperBound
argument_list|(
name|begin
argument_list|,
name|end
argument_list|,
name|priority
argument_list|)
decl_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|insert
argument_list|(
name|at
argument_list|,
name|QPostEvent
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|,
name|priority
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|eventDeleter
operator|.
name|take
argument_list|()
expr_stmt|;
name|event
operator|->
name|posted
operator|=
literal|true
expr_stmt|;
operator|++
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|data
operator|->
name|canWait
operator|=
literal|false
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|eventDispatcher
condition|)
name|data
operator|->
name|eventDispatcher
operator|->
name|wakeUp
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Returns true if \a event was compressed away (possibly deleted) and should not be added to the list. */
end_comment
begin_function
DECL|function|compressEvent
name|bool
name|QCoreApplication
operator|::
name|compressEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QPostEventList
modifier|*
name|postedEvents
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|Q_WS_WIN
name|Q_ASSERT
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|postedEvents
argument_list|)
expr_stmt|;
comment|// compress posted timers to this object.
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Timer
operator|&&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|>
literal|0
condition|)
block|{
name|int
name|timerId
init|=
operator|(
operator|(
name|QTimerEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|timerId
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|postedEvents
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|e
init|=
name|postedEvents
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|receiver
operator|==
name|receiver
operator|&&
name|e
operator|.
name|event
operator|&&
name|e
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Timer
operator|&&
operator|(
operator|(
name|QTimerEvent
operator|*
operator|)
name|e
operator|.
name|event
operator|)
operator|->
name|timerId
argument_list|()
operator|==
name|timerId
condition|)
block|{
operator|delete
name|event
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DeferredDelete
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Quit
operator|)
operator|&&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|postedEvents
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|cur
init|=
name|postedEvents
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur
operator|.
name|receiver
operator|!=
name|receiver
operator|||
name|cur
operator|.
name|event
operator|==
literal|0
operator|||
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|!=
name|event
operator|->
name|type
argument_list|()
condition|)
continue|continue;
comment|// found an event for this receiver
operator|delete
name|event
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \fn void QCoreApplication::sendPostedEvents()   \overload sendPostedEvents()      Dispatches all posted events, i.e. empties the event queue. */
end_comment
begin_comment
comment|/*!   Immediately dispatches all events which have been previously queued   with QCoreApplication::postEvent() and which are for the object \a receiver   and have the event type \a event_type.    Events from the window system are \e not dispatched by this   function, but by processEvents().    If \a receiver is null, the events of \a event_type are sent for all   objects. If \a event_type is 0, all the events are sent for \a receiver.    \note This method must be called from the same thread as its QObject parameter, \a receiver.    \sa flush(), postEvent() */
end_comment
begin_function
DECL|function|sendPostedEvents
name|void
name|QCoreApplication
operator|::
name|sendPostedEvents
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|event_type
parameter_list|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
name|QCoreApplicationPrivate
operator|::
name|sendPostedEvents
argument_list|(
name|receiver
argument_list|,
name|event_type
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendPostedEvents
name|void
name|QCoreApplicationPrivate
operator|::
name|sendPostedEvents
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|event_type
parameter_list|,
name|QThreadData
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|event_type
operator|==
operator|-
literal|1
condition|)
block|{
comment|// we were called by an obsolete event dispatcher.
name|event_type
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|receiver
operator|&&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|!=
name|data
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::sendPostedEvents: Cannot send "
literal|"posted events for objects in another thread"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|data
operator|->
name|postEventList
operator|.
name|recursion
expr_stmt|;
ifdef|#
directive|ifdef
name|QT3_SUPPORT
if|if
condition|(
name|event_type
operator|==
name|QEvent
operator|::
name|ChildInserted
condition|)
block|{
if|if
condition|(
name|receiver
condition|)
block|{
comment|// optimize sendPostedEvents(w, QEvent::ChildInserted) calls away
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|sendPendingChildInsertedEvents
argument_list|()
expr_stmt|;
operator|--
name|data
operator|->
name|postEventList
operator|.
name|recursion
expr_stmt|;
return|return;
block|}
comment|// ChildInserted events are sent in response to *Request
name|event_type
operator|=
name|QEvent
operator|::
name|ChildInsertedRequest
expr_stmt|;
block|}
endif|#
directive|endif
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|data
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
comment|// by default, we assume that the event dispatcher can go to sleep after
comment|// processing all events. if any new events are posted while we send
comment|// events, canWait will be set to false.
name|data
operator|->
name|canWait
operator|=
operator|(
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
operator|(
name|receiver
operator|&&
operator|!
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|)
condition|)
block|{
operator|--
name|data
operator|->
name|postEventList
operator|.
name|recursion
expr_stmt|;
return|return;
block|}
name|data
operator|->
name|canWait
operator|=
literal|true
expr_stmt|;
comment|// okay. here is the tricky loop. be careful about optimizing
comment|// this, it looks the way it does for good reasons.
name|int
name|startOffset
init|=
name|data
operator|->
name|postEventList
operator|.
name|startOffset
decl_stmt|;
name|int
modifier|&
name|i
init|=
operator|(
operator|!
name|event_type
operator|&&
operator|!
name|receiver
operator|)
condition|?
name|data
operator|->
name|postEventList
operator|.
name|startOffset
else|:
name|startOffset
decl_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|insertionOffset
operator|=
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// avoid live-lock
if|if
condition|(
name|i
operator|>=
name|data
operator|->
name|postEventList
operator|.
name|insertionOffset
condition|)
break|break;
specifier|const
name|QPostEvent
modifier|&
name|pe
init|=
name|data
operator|->
name|postEventList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|pe
operator|.
name|event
condition|)
continue|continue;
if|if
condition|(
operator|(
name|receiver
operator|&&
name|receiver
operator|!=
name|pe
operator|.
name|receiver
operator|)
operator|||
operator|(
name|event_type
operator|&&
name|event_type
operator|!=
name|pe
operator|.
name|event
operator|->
name|type
argument_list|()
operator|)
condition|)
block|{
name|data
operator|->
name|canWait
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pe
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DeferredDelete
condition|)
block|{
comment|// DeferredDelete events are only sent when we are explicitly asked to
comment|// (s.a. QEvent::DeferredDelete), and then only if the event loop that
comment|// posted the event has returned.
specifier|const
name|bool
name|allowDeferredDelete
init|=
operator|(
name|quintptr
argument_list|(
name|pe
operator|.
name|event
operator|->
name|d
argument_list|)
operator|>
name|unsigned
argument_list|(
name|data
operator|->
name|loopLevel
argument_list|)
operator|||
operator|(
operator|!
name|quintptr
argument_list|(
name|pe
operator|.
name|event
operator|->
name|d
argument_list|)
operator|&&
name|data
operator|->
name|loopLevel
operator|>
literal|0
operator|)
operator|||
operator|(
name|event_type
operator|==
name|QEvent
operator|::
name|DeferredDelete
operator|&&
name|quintptr
argument_list|(
name|pe
operator|.
name|event
operator|->
name|d
argument_list|)
operator|==
name|unsigned
argument_list|(
name|data
operator|->
name|loopLevel
argument_list|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowDeferredDelete
condition|)
block|{
comment|// cannot send deferred delete
if|if
condition|(
operator|!
name|event_type
operator|&&
operator|!
name|receiver
condition|)
block|{
comment|// don't lose the event
name|data
operator|->
name|postEventList
operator|.
name|append
argument_list|(
name|pe
argument_list|)
expr_stmt|;
cast|const_cast
argument_list|<
name|QPostEvent
operator|&
argument_list|>
argument_list|(
name|pe
argument_list|)
operator|.
name|event
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
block|}
comment|// first, we diddle the event so that we can deliver
comment|// it, and that no one will try to touch it later.
name|pe
operator|.
name|event
operator|->
name|posted
operator|=
literal|false
expr_stmt|;
name|QEvent
modifier|*
name|e
init|=
name|pe
operator|.
name|event
decl_stmt|;
name|QObject
modifier|*
name|r
init|=
name|pe
operator|.
name|receiver
decl_stmt|;
operator|--
name|r
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|r
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// next, update the data structure so that we're ready
comment|// for the next event.
cast|const_cast
argument_list|<
name|QPostEvent
operator|&
argument_list|>
argument_list|(
name|pe
argument_list|)
operator|.
name|event
operator|=
literal|0
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// after all that work, it's time to deliver the event.
ifdef|#
directive|ifdef
name|QT_NO_EXCEPTIONS
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|#
directive|else
try|try
block|{
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
modifier|...
parameter_list|)
block|{
operator|delete
name|e
expr_stmt|;
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
comment|// since we were interrupted, we need another pass to make sure we clean everything up
name|data
operator|->
name|canWait
operator|=
literal|false
expr_stmt|;
comment|// uglehack: copied from below
operator|--
name|data
operator|->
name|postEventList
operator|.
name|recursion
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|postEventList
operator|.
name|recursion
operator|&&
operator|!
name|data
operator|->
name|canWait
operator|&&
name|data
operator|->
name|eventDispatcher
condition|)
name|data
operator|->
name|eventDispatcher
operator|->
name|wakeUp
argument_list|()
expr_stmt|;
throw|throw;
comment|// rethrow
block|}
endif|#
directive|endif
operator|delete
name|e
expr_stmt|;
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
comment|// careful when adding anything below this point - the
comment|// sendEvent() call might invalidate any invariants this
comment|// function depends on.
block|}
operator|--
name|data
operator|->
name|postEventList
operator|.
name|recursion
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|postEventList
operator|.
name|recursion
operator|&&
operator|!
name|data
operator|->
name|canWait
operator|&&
name|data
operator|->
name|eventDispatcher
condition|)
name|data
operator|->
name|eventDispatcher
operator|->
name|wakeUp
argument_list|()
expr_stmt|;
comment|// clear the global list, i.e. remove everything that was
comment|// delivered.
if|if
condition|(
operator|!
name|event_type
operator|&&
operator|!
name|receiver
operator|&&
name|data
operator|->
name|postEventList
operator|.
name|startOffset
operator|>=
literal|0
condition|)
block|{
specifier|const
name|QPostEventList
operator|::
name|iterator
name|it
init|=
name|data
operator|->
name|postEventList
operator|.
name|begin
argument_list|()
decl_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|erase
argument_list|(
name|it
argument_list|,
name|it
operator|+
name|data
operator|->
name|postEventList
operator|.
name|startOffset
argument_list|)
expr_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|insertionOffset
operator|-=
name|data
operator|->
name|postEventList
operator|.
name|startOffset
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
operator|->
name|postEventList
operator|.
name|insertionOffset
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|startOffset
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Removes all events posted using postEvent() for \a receiver.    The events are \e not dispatched, instead they are removed from the   queue. You should never need to call this function. If you do call it,   be aware that killing events may cause \a receiver to break one or   more invariants.    \threadsafe */
end_comment
begin_function
DECL|function|removePostedEvents
name|void
name|QCoreApplication
operator|::
name|removePostedEvents
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|)
block|{
name|removePostedEvents
argument_list|(
name|receiver
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload removePostedEvents()     \since 4.3      Removes all events of the given \a eventType that were posted     using postEvent() for \a receiver.      The events are \e not dispatched, instead they are removed from     the queue. You should never need to call this function. If you do     call it, be aware that killing events may cause \a receiver to     break one or more invariants.      If \a receiver is null, the events of \a eventType are removed for     all objects. If \a eventType is 0, all the events are removed for     \a receiver.      \threadsafe */
end_comment
begin_function
DECL|function|removePostedEvents
name|void
name|QCoreApplication
operator|::
name|removePostedEvents
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|eventType
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT3_SUPPORT
if|if
condition|(
name|eventType
operator|==
name|QEvent
operator|::
name|ChildInserted
condition|)
name|eventType
operator|=
name|QEvent
operator|::
name|ChildInsertedRequest
expr_stmt|;
endif|#
directive|endif
name|QThreadData
modifier|*
name|data
init|=
name|receiver
condition|?
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
else|:
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|data
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
comment|// the QObject destructor calls this function directly.  this can
comment|// happen while the event loop is in the middle of posting events,
comment|// and when we get here, we may not have any more posted events
comment|// for this object.
if|if
condition|(
name|receiver
operator|&&
operator|!
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
condition|)
return|return;
comment|//we will collect all the posted events for the QObject
comment|//and we'll delete after the mutex was unlocked
name|QVarLengthArray
argument_list|<
name|QEvent
modifier|*
argument_list|>
name|events
decl_stmt|;
name|int
name|n
init|=
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|pe
init|=
name|data
operator|->
name|postEventList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|receiver
operator|||
name|pe
operator|.
name|receiver
operator|==
name|receiver
operator|)
operator|&&
operator|(
name|pe
operator|.
name|event
operator|&&
operator|(
name|eventType
operator|==
literal|0
operator|||
name|pe
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|eventType
operator|)
operator|)
condition|)
block|{
operator|--
name|pe
operator|.
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
ifdef|#
directive|ifdef
name|QT3_SUPPORT
if|if
condition|(
name|pe
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ChildInsertedRequest
condition|)
name|pe
operator|.
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|pendingChildInsertedEvents
operator|.
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|pe
operator|.
name|event
operator|->
name|posted
operator|=
literal|false
expr_stmt|;
name|events
operator|.
name|append
argument_list|(
name|pe
operator|.
name|event
argument_list|)
expr_stmt|;
cast|const_cast
argument_list|<
name|QPostEvent
operator|&
argument_list|>
argument_list|(
name|pe
argument_list|)
operator|.
name|event
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|data
operator|->
name|postEventList
operator|.
name|recursion
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|j
condition|)
name|data
operator|->
name|postEventList
operator|.
name|swap
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|QT_DEBUG
if|if
condition|(
name|receiver
operator|&&
name|eventType
operator|==
literal|0
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|data
operator|->
name|postEventList
operator|.
name|recursion
condition|)
block|{
comment|// truncate list
name|data
operator|->
name|postEventList
operator|.
name|erase
argument_list|(
name|data
operator|->
name|postEventList
operator|.
name|begin
argument_list|()
operator|+
name|j
argument_list|,
name|data
operator|->
name|postEventList
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|events
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
operator|delete
name|events
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Removes \a event from the queue of posted events, and emits a   warning message if appropriate.    \warning This function can be \e really slow. Avoid using it, if   possible.    \threadsafe */
end_comment
begin_function
DECL|function|removePostedEvent
name|void
name|QCoreApplicationPrivate
operator|::
name|removePostedEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|event
operator|||
operator|!
name|event
operator|->
name|posted
condition|)
return|return;
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|data
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QCoreApplication::removePostedEvent: Internal error: %p %d is posted"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|event
argument_list|,
name|event
operator|->
name|type
argument_list|()
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|pe
init|=
name|data
operator|->
name|postEventList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|pe
operator|.
name|event
operator|==
name|event
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QCoreApplication::removePostedEvent: Event of type %d deleted while posted to %s %s"
argument_list|,
name|event
operator|->
name|type
argument_list|()
argument_list|,
name|pe
operator|.
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|pe
operator|.
name|receiver
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|pe
operator|.
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|pe
operator|.
name|event
operator|->
name|posted
operator|=
literal|false
expr_stmt|;
operator|delete
name|pe
operator|.
name|event
expr_stmt|;
cast|const_cast
argument_list|<
name|QPostEvent
operator|&
argument_list|>
argument_list|(
name|pe
argument_list|)
operator|.
name|event
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!\reimp  */
end_comment
begin_function
DECL|function|event
name|bool
name|QCoreApplication
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Quit
condition|)
block|{
name|quit
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|QObject
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \enum QCoreApplication::Encoding      This enum type defines the 8-bit encoding of character string     arguments to translate():      \value CodecForTr  The encoding specified by                        QTextCodec::codecForTr() (Latin-1 if none has                        been set).     \value UnicodeUTF8  UTF-8.     \value DefaultCodec  (Obsolete) Use CodecForTr instead.      \sa QObject::tr(), QObject::trUtf8(), QString::fromUtf8() */
end_comment
begin_comment
comment|/*!     Tells the application to exit with return code 0 (success).     Equivalent to calling QCoreApplication::exit(0).      It's common to connect the QApplication::lastWindowClosed() signal     to quit(), and you also often connect e.g. QAbstractButton::clicked() or     signals in QAction, QMenu, or QMenuBar to it.      Example:      \snippet doc/src/snippets/code/src_corelib_kernel_qcoreapplication.cpp 1      \sa exit(), aboutToQuit(), QApplication::lastWindowClosed() */
end_comment
begin_function
DECL|function|quit
name|void
name|QCoreApplication
operator|::
name|quit
parameter_list|()
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \fn void QCoreApplication::aboutToQuit()    This signal is emitted when the application is about to quit the   main event loop, e.g. when the event loop level drops to zero.   This may happen either after a call to quit() from inside the   application or when the users shuts down the entire desktop session.    The signal is particularly useful if your application has to do some   last-second cleanup. Note that no user interaction is possible in   this state.    \sa quit() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TRANSLATION
end_ifndef
begin_comment
comment|/*!     Adds the translation file \a translationFile to the list of     translation files to be used for translations.      Multiple translation files can be installed. Translations are     searched for in the reverse order in which they were installed,     so the most recently installed translation file is searched first     and the first translation file installed is searched last.     The search stops as soon as a translation containing a matching     string is found.      Installing or removing a QTranslator, or changing an installed QTranslator     generates a \l{QEvent::LanguageChange}{LanguageChange} event for the     QCoreApplication instance. A QApplication instance will propagate the event     to all toplevel windows, where a reimplementation of changeEvent can     re-translate the user interface by passing user-visible strings via the     tr() function to the respective property setters. User-interface classes     generated by \l{Qt Designer} provide a \c retranslateUi() function that can be     called.      \sa removeTranslator() translate() QTranslator::load() {Dynamic Translation} */
end_comment
begin_function
DECL|function|installTranslator
name|void
name|QCoreApplication
operator|::
name|installTranslator
parameter_list|(
name|QTranslator
modifier|*
name|translationFile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|translationFile
condition|)
return|return;
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"installTranslator"
argument_list|)
condition|)
return|return;
name|QCoreApplicationPrivate
modifier|*
name|d
init|=
name|self
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|d
operator|->
name|translators
operator|.
name|prepend
argument_list|(
name|translationFile
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TRANSLATION_BUILDER
if|if
condition|(
name|translationFile
operator|->
name|isEmpty
argument_list|()
condition|)
return|return;
endif|#
directive|endif
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|LanguageChange
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|self
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes the translation file \a translationFile from the list of     translation files used by this application. (It does not delete the     translation file from the file system.)      \sa installTranslator() translate(), QObject::tr() */
end_comment
begin_function
DECL|function|removeTranslator
name|void
name|QCoreApplication
operator|::
name|removeTranslator
parameter_list|(
name|QTranslator
modifier|*
name|translationFile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|translationFile
condition|)
return|return;
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"removeTranslator"
argument_list|)
condition|)
return|return;
name|QCoreApplicationPrivate
modifier|*
name|d
init|=
name|self
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|translators
operator|.
name|removeAll
argument_list|(
name|translationFile
argument_list|)
operator|&&
operator|!
name|self
operator|->
name|closingDown
argument_list|()
condition|)
block|{
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|LanguageChange
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|self
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \overload translate() */
end_comment
begin_function
DECL|function|translate
name|QString
name|QCoreApplication
operator|::
name|translate
parameter_list|(
specifier|const
name|char
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|sourceText
parameter_list|,
specifier|const
name|char
modifier|*
name|disambiguation
parameter_list|,
name|Encoding
name|encoding
parameter_list|)
block|{
return|return
name|translate
argument_list|(
name|context
argument_list|,
name|sourceText
argument_list|,
name|disambiguation
argument_list|,
name|encoding
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|replacePercentN
specifier|static
name|void
name|replacePercentN
parameter_list|(
name|QString
modifier|*
name|result
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|int
name|percentPos
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|percentPos
operator|=
name|result
operator|->
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
argument_list|,
name|percentPos
operator|+
name|len
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
name|QString
name|fmt
decl_stmt|;
if|if
condition|(
name|result
operator|->
name|at
argument_list|(
name|percentPos
operator|+
name|len
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'L'
argument_list|)
condition|)
block|{
operator|++
name|len
expr_stmt|;
name|fmt
operator|=
name|QLatin1String
argument_list|(
literal|"%L1"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fmt
operator|=
name|QLatin1String
argument_list|(
literal|"%1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|->
name|at
argument_list|(
name|percentPos
operator|+
name|len
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'n'
argument_list|)
condition|)
block|{
name|fmt
operator|=
name|fmt
operator|.
name|arg
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|++
name|len
expr_stmt|;
name|result
operator|->
name|replace
argument_list|(
name|percentPos
argument_list|,
name|len
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|len
operator|=
name|fmt
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \reentrant     \since 4.5      Returns the translation text for \a sourceText, by querying the     installed translation files. The translation files are searched     from the most recently installed file back to the first     installed file.      QObject::tr() and QObject::trUtf8() provide this functionality     more conveniently.      \a context is typically a class name (e.g., "MyDialog") and \a     sourceText is either English text or a short identifying text.      \a disambiguation is an identifying string, for when the same \a     sourceText is used in different roles within the same context. By     default, it is null.      See the \l QTranslator and \l QObject::tr() documentation for     more information about contexts, disambiguations and comments.      \a encoding indicates the 8-bit encoding of character strings.      \a n is used in conjunction with \c %n to support plural forms.     See QObject::tr() for details.      If none of the translation files contain a translation for \a     sourceText in \a context, this function returns a QString     equivalent of \a sourceText. The encoding of \a sourceText is     specified by \e encoding; it defaults to CodecForTr.      This function is not virtual. You can use alternative translation     techniques by subclassing \l QTranslator.      \warning This method is reentrant only if all translators are     installed \e before calling this method. Installing or removing     translators while performing translations is not supported. Doing     so will most likely result in crashes or other undesirable     behavior.      \sa QObject::tr() installTranslator() QTextCodec::codecForTr() */
end_comment
begin_function
DECL|function|translate
name|QString
name|QCoreApplication
operator|::
name|translate
parameter_list|(
specifier|const
name|char
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|sourceText
parameter_list|,
specifier|const
name|char
modifier|*
name|disambiguation
parameter_list|,
name|Encoding
name|encoding
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|sourceText
condition|)
return|return
name|result
return|;
if|if
condition|(
name|self
operator|&&
operator|!
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|translators
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|QTranslator
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|it
decl_stmt|;
name|QTranslator
modifier|*
name|translationFile
decl_stmt|;
for|for
control|(
name|it
operator|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|translators
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|translators
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|translationFile
operator|=
operator|*
name|it
expr_stmt|;
name|result
operator|=
name|translationFile
operator|->
name|translate
argument_list|(
name|context
argument_list|,
name|sourceText
argument_list|,
name|disambiguation
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_TEXTCODEC
name|Q_UNUSED
argument_list|(
argument|encoding
argument_list|)
else|#
directive|else
if|if
condition|(
name|encoding
operator|==
name|UnicodeUTF8
condition|)
name|result
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|sourceText
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|QTextCodec
operator|::
name|codecForTr
argument_list|()
operator|!=
literal|0
condition|)
name|result
operator|=
name|QTextCodec
operator|::
name|codecForTr
argument_list|()
operator|->
name|toUnicode
argument_list|(
name|sourceText
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|result
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|sourceText
argument_list|)
expr_stmt|;
block|}
name|replacePercentN
argument_list|(
operator|&
name|result
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|// Declared in qglobal.h
end_comment
begin_function
DECL|function|qtTrId
name|QString
name|qtTrId
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|0
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
name|QCoreApplication
operator|::
name|UnicodeUTF8
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isTranslatorInstalled
name|bool
name|QCoreApplicationPrivate
operator|::
name|isTranslatorInstalled
parameter_list|(
name|QTranslator
modifier|*
name|translator
parameter_list|)
block|{
return|return
name|QCoreApplication
operator|::
name|self
operator|&&
name|QCoreApplication
operator|::
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|translators
operator|.
name|contains
argument_list|(
name|translator
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_TRANSLATE
end_comment
begin_comment
comment|/*!     Returns the directory that contains the application executable.      For example, if you have installed Qt in the \c{C:\Trolltech\Qt}     directory, and you run the \c{regexp} example, this function will     return "C:/Trolltech/Qt/examples/tools/regexp".      On Mac OS X this will point to the directory actually containing the     executable, which may be inside of an application bundle (if the     application is bundled).      \warning On Linux, this function will try to get the path from the     \c {/proc} file system. If that fails, it assumes that \c     {argv[0]} contains the absolute file name of the executable. The     function also assumes that the current directory has not been     changed by the application.      In Symbian this function will return the application private directory,     not the path to executable itself, as those are always in \c {/sys/bin}.     If the application is in a read only drive, i.e. ROM, then the private path     on the system drive will be returned.      \sa applicationFilePath() */
end_comment
begin_function
DECL|function|applicationDirPath
name|QString
name|QCoreApplication
operator|::
name|applicationDirPath
parameter_list|()
block|{
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::applicationDirPath: Please instantiate the QApplication object first"
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QCoreApplicationPrivate
modifier|*
name|d
init|=
name|self
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|cachedApplicationDirPath
operator|.
name|isNull
argument_list|()
condition|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
block|{
name|QString
name|appPath
decl_stmt|;
name|RFs
modifier|&
name|fs
init|=
name|qt_s60GetRFs
argument_list|()
decl_stmt|;
name|TChar
name|driveChar
decl_stmt|;
name|QChar
name|qDriveChar
decl_stmt|;
name|driveChar
operator|=
operator|(
name|RProcess
argument_list|()
operator|.
name|FileName
argument_list|()
operator|)
index|[
literal|0
index|]
expr_stmt|;
comment|//Check if the process is installed in a read only drive (typically ROM),
comment|//and use the system drive (typically C:) if so.
name|TInt
name|drive
decl_stmt|;
name|TDriveInfo
name|driveInfo
decl_stmt|;
name|TInt
name|err
init|=
name|fs
operator|.
name|CharToDrive
argument_list|(
name|driveChar
argument_list|,
name|drive
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|KErrNone
condition|)
block|{
name|err
operator|=
name|fs
operator|.
name|Drive
argument_list|(
name|driveInfo
argument_list|,
name|drive
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
name|KErrNone
operator|||
operator|(
name|driveInfo
operator|.
name|iDriveAtt
operator|&
name|KDriveAttRom
operator|)
operator|||
operator|(
name|driveInfo
operator|.
name|iMediaAtt
operator|&
name|KMediaAttWriteProtected
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|PtrGetSystemDrive
condition|)
name|PtrGetSystemDrive
operator|=
cast|reinterpret_cast
argument_list|<
name|SystemDriveFunc
argument_list|>
argument_list|(
name|qt_resolveS60PluginFunc
argument_list|(
name|S60Plugin_GetSystemDrive
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|PtrGetSystemDrive
argument_list|)
expr_stmt|;
name|drive
operator|=
name|PtrGetSystemDrive
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|fs
operator|.
name|DriveToChar
argument_list|(
name|drive
argument_list|,
name|driveChar
argument_list|)
expr_stmt|;
block|}
name|qDriveChar
operator|=
name|QChar
argument_list|(
name|QLatin1Char
argument_list|(
name|driveChar
argument_list|)
argument_list|)
operator|.
name|toUpper
argument_list|()
expr_stmt|;
name|TFileName
name|privatePath
decl_stmt|;
name|fs
operator|.
name|PrivatePath
argument_list|(
name|privatePath
argument_list|)
expr_stmt|;
name|appPath
operator|=
name|qt_TDesC2QString
argument_list|(
name|privatePath
argument_list|)
expr_stmt|;
name|appPath
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
operator|.
name|prepend
argument_list|(
name|qDriveChar
argument_list|)
expr_stmt|;
comment|// Create the appPath if it doesn't exist. Non-existing appPath will cause
comment|// Platform Security violations later on if the app doesn't have AllFiles capability.
name|err
operator|=
name|fs
operator|.
name|CreatePrivatePath
argument_list|(
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|KErrNone
condition|)
name|qWarning
argument_list|(
literal|"QCoreApplication::applicationDirPath: Failed to create private path."
argument_list|)
expr_stmt|;
name|d
operator|->
name|cachedApplicationDirPath
operator|=
name|QFileInfo
argument_list|(
name|appPath
argument_list|)
operator|.
name|path
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
name|d
operator|->
name|cachedApplicationDirPath
operator|=
name|QFileInfo
argument_list|(
name|applicationFilePath
argument_list|()
argument_list|)
operator|.
name|path
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|d
operator|->
name|cachedApplicationDirPath
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the file path of the application executable.      For example, if you have installed Qt in the \c{/usr/local/qt}     directory, and you run the \c{regexp} example, this function will     return "/usr/local/qt/examples/tools/regexp/regexp".      \warning On Linux, this function will try to get the path from the     \c {/proc} file system. If that fails, it assumes that \c     {argv[0]} contains the absolute file name of the executable. The     function also assumes that the current directory has not been     changed by the application.      \sa applicationDirPath() */
end_comment
begin_function
DECL|function|applicationFilePath
name|QString
name|QCoreApplication
operator|::
name|applicationFilePath
parameter_list|()
block|{
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::applicationFilePath: Please instantiate the QApplication object first"
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QCoreApplicationPrivate
modifier|*
name|d
init|=
name|self
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|cachedApplicationFilePath
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|d
operator|->
name|cachedApplicationFilePath
return|;
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
name|d
operator|->
name|cachedApplicationFilePath
operator|=
name|QFileInfo
argument_list|(
name|qAppFileName
argument_list|()
argument_list|)
operator|.
name|filePath
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cachedApplicationFilePath
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
name|QString
name|qAppFileName_str
init|=
name|qAppFileName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|qAppFileName_str
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QFileInfo
name|fi
argument_list|(
name|qAppFileName_str
argument_list|)
decl_stmt|;
name|d
operator|->
name|cachedApplicationFilePath
operator|=
name|fi
operator|.
name|exists
argument_list|()
condition|?
name|fi
operator|.
name|canonicalFilePath
argument_list|()
else|:
name|QString
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cachedApplicationFilePath
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
name|QString
name|appPath
decl_stmt|;
name|RProcess
name|proc
decl_stmt|;
name|TInt
name|err
init|=
name|proc
operator|.
name|Open
argument_list|(
name|proc
operator|.
name|Id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|KErrNone
condition|)
block|{
name|TFileName
name|procName
init|=
name|proc
operator|.
name|FileName
argument_list|()
decl_stmt|;
name|appPath
operator|.
name|append
argument_list|(
name|QString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|procName
operator|.
name|Ptr
argument_list|()
argument_list|)
argument_list|,
name|procName
operator|.
name|Length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|proc
operator|.
name|Close
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|cachedApplicationFilePath
operator|=
name|appPath
expr_stmt|;
return|return
name|d
operator|->
name|cachedApplicationFilePath
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
ifdef|#
directive|ifdef
name|Q_OS_LINUX
comment|// Try looking for a /proc/<pid>/exe symlink first which points to
comment|// the absolute path of the executable
name|QFileInfo
name|pfi
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"/proc/%1/exe"
argument_list|)
operator|.
name|arg
argument_list|(
name|getpid
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pfi
operator|.
name|exists
argument_list|()
operator|&&
name|pfi
operator|.
name|isSymLink
argument_list|()
condition|)
block|{
name|d
operator|->
name|cachedApplicationFilePath
operator|=
name|pfi
operator|.
name|canonicalFilePath
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cachedApplicationFilePath
return|;
block|}
endif|#
directive|endif
name|QString
name|argv0
init|=
name|QFile
operator|::
name|decodeName
argument_list|(
name|QByteArray
argument_list|(
name|argv
argument_list|()
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|absPath
decl_stmt|;
if|if
condition|(
operator|!
name|argv0
operator|.
name|isEmpty
argument_list|()
operator|&&
name|argv0
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
comment|/*           If argv0 starts with a slash, it is already an absolute           file path.         */
name|absPath
operator|=
name|argv0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv0
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
block|{
comment|/*           If argv0 contains one or more slashes, it is a file path           relative to the current directory.         */
name|absPath
operator|=
name|QDir
operator|::
name|current
argument_list|()
operator|.
name|absoluteFilePath
argument_list|(
name|argv0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*           Otherwise, the file path has to be determined using the           PATH environment variable.         */
name|QByteArray
name|pEnv
init|=
name|qgetenv
argument_list|(
literal|"PATH"
argument_list|)
decl_stmt|;
name|QDir
name|currentDir
init|=
name|QDir
operator|::
name|current
argument_list|()
decl_stmt|;
name|QStringList
name|paths
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|pEnv
operator|.
name|constData
argument_list|()
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|const_iterator
name|p
init|=
name|paths
operator|.
name|constBegin
argument_list|()
init|;
name|p
operator|!=
name|paths
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|QString
name|candidate
init|=
name|currentDir
operator|.
name|absoluteFilePath
argument_list|(
operator|*
name|p
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|argv0
argument_list|)
decl_stmt|;
name|QFileInfo
name|candidate_fi
argument_list|(
name|candidate
argument_list|)
decl_stmt|;
if|if
condition|(
name|candidate_fi
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|candidate_fi
operator|.
name|isDir
argument_list|()
condition|)
block|{
name|absPath
operator|=
name|candidate
expr_stmt|;
break|break;
block|}
block|}
block|}
name|absPath
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|absPath
argument_list|)
expr_stmt|;
name|QFileInfo
name|fi
argument_list|(
name|absPath
argument_list|)
decl_stmt|;
name|d
operator|->
name|cachedApplicationFilePath
operator|=
name|fi
operator|.
name|exists
argument_list|()
condition|?
name|fi
operator|.
name|canonicalFilePath
argument_list|()
else|:
name|QString
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cachedApplicationFilePath
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the current process ID for the application. */
end_comment
begin_function
DECL|function|applicationPid
name|qint64
name|QCoreApplication
operator|::
name|applicationPid
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
return|return
name|GetCurrentProcessId
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
return|return
operator|(
name|pid_t
operator|)
name|taskIdCurrent
return|;
else|#
directive|else
return|return
name|getpid
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use arguments().size() instead. */
end_comment
begin_function
DECL|function|argc
name|int
name|QCoreApplication
operator|::
name|argc
parameter_list|()
block|{
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::argc: Please instantiate the QApplication object first"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|argc
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Use arguments() instead. */
end_comment
begin_function
DECL|function|argv
name|char
modifier|*
modifier|*
name|QCoreApplication
operator|::
name|argv
parameter_list|()
block|{
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::argv: Please instantiate the QApplication object first"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|argv
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the list of command-line arguments.      Usually arguments().at(0) is the program name, arguments().at(1)     is the first argument, and arguments().last() is the last     argument. See the note below about Windows.      Calling this function is slow - you should store the result in a variable     when parsing the command line.      \warning On Unix, this list is built from the argc and argv parameters passed     to the constructor in the main() function. The string-data in argv is     interpreted using QString::fromLocal8Bit(); hence it is not possible to     pass, for example, Japanese command line arguments on a system that runs in a     Latin1 locale. Most modern Unix systems do not have this limitation, as they are     Unicode-based.      On NT-based Windows, this limitation does not apply either.     On Windows, the arguments() are not built from the contents of argv/argc, as     the content does not support Unicode. Instead, the arguments() are constructed     from the return value of     \l{http://msdn2.microsoft.com/en-us/library/ms683156(VS.85).aspx}{GetCommandLine()}.     As a result of this, the string given by arguments().at(0) might not be     the program name on Windows, depending on how the application was started.      For Symbian applications started with \c RApaLsSession::StartApp one can specify     arguments using \c CApaCommandLine::SetTailEndL function. Such arguments are only     available via this method; they will not be passed to \c main function. Also note     that only 8-bit string data set with \c CApaCommandLine::SetTailEndL is supported     by this function.      \sa applicationFilePath() */
end_comment
begin_function
DECL|function|arguments
name|QStringList
name|QCoreApplication
operator|::
name|arguments
parameter_list|()
block|{
name|QStringList
name|list
decl_stmt|;
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::arguments: Please instantiate the QApplication object first"
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|QString
name|cmdline
init|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|GetCommandLine
argument_list|()
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|wchar_t
name|tempFilename
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|GetModuleFileName
argument_list|(
literal|0
argument_list|,
name|tempFilename
argument_list|,
name|MAX_PATH
argument_list|)
condition|)
block|{
name|tempFilename
index|[
name|MAX_PATH
index|]
operator|=
literal|0
expr_stmt|;
name|cmdline
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
operator|+
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|tempFilename
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"\" "
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Q_OS_WINCE
name|list
operator|=
name|qWinCmdArgs
argument_list|(
name|cmdline
argument_list|)
expr_stmt|;
if|if
condition|(
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|application_type
condition|)
block|{
comment|// GUI app? Skip known - see qapplication.cpp
name|QStringList
name|stripped
decl_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|a
control|)
block|{
name|QString
name|arg
init|=
name|list
operator|.
name|at
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|QByteArray
name|l1arg
init|=
name|arg
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
if|if
condition|(
name|l1arg
operator|==
literal|"-qdevel"
operator|||
name|l1arg
operator|==
literal|"-qdebug"
operator|||
name|l1arg
operator|==
literal|"-reverse"
operator|||
name|l1arg
operator|==
literal|"-stylesheet"
operator|||
name|l1arg
operator|==
literal|"-widgetcount"
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|l1arg
operator|.
name|startsWith
argument_list|(
literal|"-style="
argument_list|)
operator|||
name|l1arg
operator|.
name|startsWith
argument_list|(
literal|"-qmljsdebugger="
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|l1arg
operator|==
literal|"-style"
operator|||
name|l1arg
operator|==
literal|"-session"
operator|||
name|l1arg
operator|==
literal|"-graphicssystem"
operator|||
name|l1arg
operator|==
literal|"-testability"
condition|)
operator|++
name|a
expr_stmt|;
else|else
name|stripped
operator|+=
name|arg
expr_stmt|;
block|}
name|list
operator|=
name|stripped
expr_stmt|;
block|}
else|#
directive|else
specifier|const
name|int
name|ac
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
specifier|const
name|av
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|argv
decl_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|ac
condition|;
operator|++
name|a
control|)
block|{
name|list
operator|<<
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|av
index|[
name|a
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCoreApplication::organizationName     \brief the name of the organization that wrote this application      The value is used by the QSettings class when it is constructed     using the empty constructor. This saves having to repeat this     information each time a QSettings object is created.      On Mac, QSettings uses organizationDomain() as the organization     if it's not an empty string; otherwise it uses     organizationName(). On all other platforms, QSettings uses     organizationName() as the organization.      \sa organizationDomain applicationName */
end_comment
begin_function
DECL|function|setOrganizationName
name|void
name|QCoreApplication
operator|::
name|setOrganizationName
parameter_list|(
specifier|const
name|QString
modifier|&
name|orgName
parameter_list|)
block|{
name|coreappdata
argument_list|()
operator|->
name|orgName
operator|=
name|orgName
expr_stmt|;
block|}
end_function
begin_function
DECL|function|organizationName
name|QString
name|QCoreApplication
operator|::
name|organizationName
parameter_list|()
block|{
return|return
name|coreappdata
argument_list|()
operator|->
name|orgName
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCoreApplication::organizationDomain     \brief the Internet domain of the organization that wrote this application      The value is used by the QSettings class when it is constructed     using the empty constructor. This saves having to repeat this     information each time a QSettings object is created.      On Mac, QSettings uses organizationDomain() as the organization     if it's not an empty string; otherwise it uses organizationName().     On all other platforms, QSettings uses organizationName() as the     organization.      \sa organizationName applicationName applicationVersion */
end_comment
begin_function
DECL|function|setOrganizationDomain
name|void
name|QCoreApplication
operator|::
name|setOrganizationDomain
parameter_list|(
specifier|const
name|QString
modifier|&
name|orgDomain
parameter_list|)
block|{
name|coreappdata
argument_list|()
operator|->
name|orgDomain
operator|=
name|orgDomain
expr_stmt|;
block|}
end_function
begin_function
DECL|function|organizationDomain
name|QString
name|QCoreApplication
operator|::
name|organizationDomain
parameter_list|()
block|{
return|return
name|coreappdata
argument_list|()
operator|->
name|orgDomain
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCoreApplication::applicationName     \brief the name of this application      The value is used by the QSettings class when it is constructed     using the empty constructor. This saves having to repeat this     information each time a QSettings object is created.      \sa organizationName organizationDomain applicationVersion */
end_comment
begin_function
DECL|function|setApplicationName
name|void
name|QCoreApplication
operator|::
name|setApplicationName
parameter_list|(
specifier|const
name|QString
modifier|&
name|application
parameter_list|)
block|{
name|coreappdata
argument_list|()
operator|->
name|application
operator|=
name|application
expr_stmt|;
block|}
end_function
begin_function
DECL|function|applicationName
name|QString
name|QCoreApplication
operator|::
name|applicationName
parameter_list|()
block|{
return|return
name|coreappdata
argument_list|()
operator|->
name|application
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCoreApplication::applicationVersion     \since 4.4     \brief the version of this application      \sa applicationName organizationName organizationDomain */
end_comment
begin_function
DECL|function|setApplicationVersion
name|void
name|QCoreApplication
operator|::
name|setApplicationVersion
parameter_list|(
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
block|{
name|coreappdata
argument_list|()
operator|->
name|applicationVersion
operator|=
name|version
expr_stmt|;
block|}
end_function
begin_function
DECL|function|applicationVersion
name|QString
name|QCoreApplication
operator|::
name|applicationVersion
parameter_list|()
block|{
return|return
name|coreappdata
argument_list|()
operator|->
name|applicationVersion
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
end_ifndef
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|QMutex
argument_list|,
argument|libraryPathMutex
argument_list|,
argument|(QMutex::Recursive)
argument_list|)
end_macro
begin_comment
comment|/*!     Returns a list of paths that the application will search when     dynamically loading libraries.      Qt provides default library paths, but they can also be set using     a \l{Using qt.conf}{qt.conf} file. Paths specified in this file     will override default values.      This list will include the installation directory for plugins if     it exists (the default installation directory for plugins is \c     INSTALL/plugins, where \c INSTALL is the directory where Qt was     installed).  The directory of the application executable (NOT the     working directory) is always added, as well as the colon separated     entries of the QT_PLUGIN_PATH environment variable.      If you want to iterate over the list, you can use the \l foreach     pseudo-keyword:      \snippet doc/src/snippets/code/src_corelib_kernel_qcoreapplication.cpp 2      \sa setLibraryPaths(), addLibraryPath(), removeLibraryPath(), QLibrary,         {How to Create Qt Plugins} */
end_comment
begin_function
DECL|function|libraryPaths
name|QStringList
name|QCoreApplication
operator|::
name|libraryPaths
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
name|libraryPathMutex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
condition|)
block|{
name|QStringList
modifier|*
name|app_libpaths
init|=
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|=
operator|new
name|QStringList
decl_stmt|;
name|QString
name|installPathPlugins
init|=
name|QLibraryInfo
operator|::
name|location
argument_list|(
name|QLibraryInfo
operator|::
name|PluginsPath
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
comment|// Add existing path on all drives for relative PluginsPath in Symbian
if|if
condition|(
name|installPathPlugins
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|!=
name|QChar
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
block|{
name|QString
name|tempPath
init|=
name|installPathPlugins
decl_stmt|;
if|if
condition|(
name|tempPath
operator|.
name|at
argument_list|(
name|tempPath
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|!=
name|QDir
operator|::
name|separator
argument_list|()
condition|)
block|{
name|tempPath
operator|+=
name|QDir
operator|::
name|separator
argument_list|()
expr_stmt|;
block|}
name|RFs
modifier|&
name|fs
init|=
name|qt_s60GetRFs
argument_list|()
decl_stmt|;
name|TPtrC
name|tempPathPtr
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|TText
operator|*
argument_list|>
argument_list|(
name|tempPath
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|TFindFile
name|finder
argument_list|(
name|fs
argument_list|)
decl_stmt|;
name|TInt
name|err
init|=
name|finder
operator|.
name|FindByDir
argument_list|(
name|tempPathPtr
argument_list|,
name|tempPathPtr
argument_list|)
decl_stmt|;
while|while
condition|(
name|err
operator|==
name|KErrNone
condition|)
block|{
name|QString
name|foundDir
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QChar
operator|*
argument_list|>
argument_list|(
name|finder
operator|.
name|File
argument_list|()
operator|.
name|Ptr
argument_list|()
argument_list|)
argument_list|,
name|finder
operator|.
name|File
argument_list|()
operator|.
name|Length
argument_list|()
argument_list|)
decl_stmt|;
name|foundDir
operator|=
name|QDir
argument_list|(
name|foundDir
argument_list|)
operator|.
name|canonicalPath
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|app_libpaths
operator|->
name|contains
argument_list|(
name|foundDir
argument_list|)
condition|)
name|app_libpaths
operator|->
name|append
argument_list|(
name|foundDir
argument_list|)
expr_stmt|;
name|err
operator|=
name|finder
operator|.
name|Find
argument_list|()
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|installPathPlugins
argument_list|)
condition|)
block|{
comment|// Make sure we convert from backslashes to slashes.
name|installPathPlugins
operator|=
name|QDir
argument_list|(
name|installPathPlugins
argument_list|)
operator|.
name|canonicalPath
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|app_libpaths
operator|->
name|contains
argument_list|(
name|installPathPlugins
argument_list|)
condition|)
name|app_libpaths
operator|->
name|append
argument_list|(
name|installPathPlugins
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// If QCoreApplication is not yet instantiated,
comment|// make sure we add the application path when we construct the QCoreApplication
if|if
condition|(
name|self
condition|)
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|appendApplicationPathToLibraryPaths
argument_list|()
expr_stmt|;
specifier|const
name|QByteArray
name|libPathEnv
init|=
name|qgetenv
argument_list|(
literal|"QT_PLUGIN_PATH"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|libPathEnv
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
name|QLatin1Char
name|pathSep
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
else|#
directive|else
name|QLatin1Char
name|pathSep
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|QStringList
name|paths
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|libPathEnv
argument_list|)
operator|.
name|split
argument_list|(
name|pathSep
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|const_iterator
name|it
init|=
name|paths
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|paths
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QString
name|canonicalPath
init|=
name|QDir
argument_list|(
operator|*
name|it
argument_list|)
operator|.
name|canonicalPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|canonicalPath
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|app_libpaths
operator|->
name|contains
argument_list|(
name|canonicalPath
argument_list|)
condition|)
block|{
name|app_libpaths
operator|->
name|append
argument_list|(
name|canonicalPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|*
operator|(
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!      Sets the list of directories to search when loading libraries to     \a paths. All existing paths will be deleted and the path list     will consist of the paths given in \a paths.      In Symbian this function is only useful for setting paths for     finding Qt extension plugin stubs, since the OS can only     load libraries from the \c{/sys/bin} directory.      \sa libraryPaths(), addLibraryPath(), removeLibraryPath(), QLibrary  */
end_comment
begin_function
DECL|function|setLibraryPaths
name|void
name|QCoreApplication
operator|::
name|setLibraryPaths
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|paths
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
name|libraryPathMutex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
condition|)
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|=
operator|new
name|QStringList
expr_stmt|;
operator|*
operator|(
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|)
operator|=
name|paths
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QFactoryLoader
operator|::
name|refreshAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Prepends \a path to the beginning of the library path list, ensuring that   it is searched for libraries first. If \a path is empty or already in the   path list, the path list is not changed.    The default path list consists of a single entry, the installation   directory for plugins.  The default installation directory for plugins   is \c INSTALL/plugins, where \c INSTALL is the directory where Qt was   installed.    In Symbian this function is only useful for adding paths for   finding Qt extension plugin stubs, since the OS can only   load libraries from the \c{/sys/bin} directory.    \sa removeLibraryPath(), libraryPaths(), setLibraryPaths()  */
end_comment
begin_function
DECL|function|addLibraryPath
name|void
name|QCoreApplication
operator|::
name|addLibraryPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QMutexLocker
name|locker
argument_list|(
name|libraryPathMutex
argument_list|()
argument_list|)
decl_stmt|;
comment|// make sure that library paths is initialized
name|libraryPaths
argument_list|()
expr_stmt|;
name|QString
name|canonicalPath
init|=
name|QDir
argument_list|(
name|path
argument_list|)
operator|.
name|canonicalPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|canonicalPath
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|->
name|contains
argument_list|(
name|canonicalPath
argument_list|)
condition|)
block|{
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|->
name|prepend
argument_list|(
name|canonicalPath
argument_list|)
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QFactoryLoader
operator|::
name|refreshAll
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Removes \a path from the library path list. If \a path is empty or not     in the path list, the list is not changed.      \sa addLibraryPath(), libraryPaths(), setLibraryPaths() */
end_comment
begin_function
DECL|function|removeLibraryPath
name|void
name|QCoreApplication
operator|::
name|removeLibraryPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QMutexLocker
name|locker
argument_list|(
name|libraryPathMutex
argument_list|()
argument_list|)
decl_stmt|;
comment|// make sure that library paths is initialized
name|libraryPaths
argument_list|()
expr_stmt|;
name|QString
name|canonicalPath
init|=
name|QDir
argument_list|(
name|path
argument_list|)
operator|.
name|canonicalPath
argument_list|()
decl_stmt|;
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|->
name|removeAll
argument_list|(
name|canonicalPath
argument_list|)
expr_stmt|;
name|QFactoryLoader
operator|::
name|refreshAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_LIBRARY
end_comment
begin_comment
comment|/*!     \typedef QCoreApplication::EventFilter      A function with the following signature that can be used as an     event filter:      \snippet doc/src/snippets/code/src_corelib_kernel_qcoreapplication.cpp 3      \sa setEventFilter() */
end_comment
begin_comment
comment|/*!     \fn EventFilter QCoreApplication::setEventFilter(EventFilter filter)      Replaces the event filter function for the QCoreApplication with     \a filter and returns the pointer to the replaced event filter     function. Only the current event filter function is called. If you     want to use both filter functions, save the replaced EventFilter     in a place where yours can call it.      The event filter function set here is called for all messages     received by all threads meant for all Qt objects. It is \e not     called for messages that are not meant for Qt objects.      The event filter function should return true if the message should     be filtered, (i.e. stopped). It should return false to allow     processing the message to continue.      By default, no event filter function is set (i.e., this function     returns a null EventFilter the first time it is called).      \note The filter function set here receives native messages,     i.e. MSG or XEvent structs, that are going to Qt objects. It is     called by QCoreApplication::filterEvent(). If the filter function     returns false to indicate the message should be processed further,     the native message can then be translated into a QEvent and     handled by the standard Qt \l{QEvent} {event} filering, e.g.     QObject::installEventFilter().      \note The filter function set here is different form the filter     function set via QAbstractEventDispatcher::setEventFilter(), which     gets all messages received by its thread, even messages meant for     objects that are not handled by Qt.      \sa QObject::installEventFilter(), QAbstractEventDispatcher::setEventFilter() */
end_comment
begin_function
name|QCoreApplication
operator|::
name|EventFilter
DECL|function|setEventFilter
name|QCoreApplication
operator|::
name|setEventFilter
parameter_list|(
name|QCoreApplication
operator|::
name|EventFilter
name|filter
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCoreApplication
argument_list|)
expr_stmt|;
name|EventFilter
name|old
init|=
name|d
operator|->
name|eventFilter
decl_stmt|;
name|d
operator|->
name|eventFilter
operator|=
name|filter
expr_stmt|;
return|return
name|old
return|;
block|}
end_function
begin_comment
comment|/*!     Sends \a message through the event filter that was set by     setEventFilter(). If no event filter has been set, this function     returns false; otherwise, this function returns the result of the     event filter function in the \a result parameter.      \sa setEventFilter() */
end_comment
begin_function
DECL|function|filterEvent
name|bool
name|QCoreApplication
operator|::
name|filterEvent
parameter_list|(
name|void
modifier|*
name|message
parameter_list|,
name|long
modifier|*
name|result
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCoreApplication
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|eventFilter
condition|)
return|return
name|d
operator|->
name|eventFilter
argument_list|(
name|message
argument_list|,
name|result
argument_list|)
return|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
return|return
name|winEventFilter
argument_list|(
cast|reinterpret_cast
argument_list|<
name|MSG
operator|*
argument_list|>
argument_list|(
name|message
argument_list|)
argument_list|,
name|result
argument_list|)
return|;
else|#
directive|else
return|return
literal|false
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     This function returns true if there are pending events; otherwise     returns false. Pending events can be either from the window     system or posted events using postEvent().      \sa QAbstractEventDispatcher::hasPendingEvents() */
end_comment
begin_function
DECL|function|hasPendingEvents
name|bool
name|QCoreApplication
operator|::
name|hasPendingEvents
parameter_list|()
block|{
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
init|=
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
name|eventDispatcher
condition|)
return|return
name|eventDispatcher
operator|->
name|hasPendingEvents
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT3_SUPPORT
end_ifdef
begin_comment
comment|/*! \fn void QCoreApplication::lock()      In Qt 3, this function locked the Qt library mutex, allowing     non-GUI threads to perform basic printing operations using     QPainter.      In Qt 4, this is no longer supported, since painting is only     supported from within a paint event handler. This function does     nothing.      \sa QWidget::paintEvent() */
end_comment
begin_comment
comment|/*! \fn void QCoreApplication::unlock(bool wakeUpGui)      In Qt 3, this function unlocked the Qt library mutex. The mutex     allowed non-GUI threads to perform basic printing operations     using QPainter.      In Qt 4, this is no longer supported, since painting is only     supported from within a paint event handler. This function does     nothing. */
end_comment
begin_comment
comment|/*! \fn bool QCoreApplication::locked()      This function does nothing. It is there to keep old code working.     It always returns false.      See lock() for details. */
end_comment
begin_comment
comment|/*! \fn bool QCoreApplication::tryLock()      This function does nothing. It is there to keep old code working.     It always returns false.      See lock() for details. */
end_comment
begin_comment
comment|/*! \fn void QCoreApplication::processOneEvent()     \obsolete      Waits for an event to occur, processes it, then returns.      This function is useful for adapting Qt to situations where the     event processing must be grafted onto existing program loops.      Using this function in new applications may be an indication of design     problems.      \sa processEvents(), exec(), QTimer */
end_comment
begin_comment
comment|/*! \obsolete      This function enters the main event loop (recursively). Do not call     it unless you really know what you are doing. */
end_comment
begin_function
DECL|function|enter_loop
name|int
name|QCoreApplication
operator|::
name|enter_loop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"enter_loop"
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|QThreadData
operator|::
name|current
argument_list|()
operator|!=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::enter_loop: Must be called from the main thread"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|QEventLoop
name|eventLoop
decl_stmt|;
name|int
name|returnCode
init|=
name|eventLoop
operator|.
name|exec
argument_list|()
decl_stmt|;
return|return
name|returnCode
return|;
block|}
end_function
begin_comment
comment|/*! \obsolete      This function exits from a recursive call to the main event loop.     Do not call it unless you are an expert. */
end_comment
begin_function
DECL|function|exit_loop
name|void
name|QCoreApplication
operator|::
name|exit_loop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"exit_loop"
argument_list|)
condition|)
return|return;
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
operator|!=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::exit_loop: Must be called from the main thread"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|data
operator|->
name|eventLoops
operator|.
name|isEmpty
argument_list|()
condition|)
name|data
operator|->
name|eventLoops
operator|.
name|top
argument_list|()
operator|->
name|exit
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \obsolete      Returns the current loop level. */
end_comment
begin_function
DECL|function|loopLevel
name|int
name|QCoreApplication
operator|::
name|loopLevel
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"loopLevel"
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|->
name|eventLoops
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*     \fn void QCoreApplication::watchUnixSignal(int signal, bool watch)     \internal */
end_comment
begin_comment
comment|/*!     \fn void QCoreApplication::unixSignal(int number)     \internal      This signal is emitted whenever a Unix signal is received by the     application. The Unix signal received is specified by its \a number. */
end_comment
begin_comment
comment|/*!     \fn void qAddPostRoutine(QtCleanUpFunction ptr)     \relates QCoreApplication      Adds a global routine that will be called from the QApplication     destructor. This function is normally used to add cleanup routines     for program-wide functionality.      The function specified by \a ptr should take no arguments and should     return nothing. For example:      \snippet doc/src/snippets/code/src_corelib_kernel_qcoreapplication.cpp 4      Note that for an application- or module-wide cleanup,     qAddPostRoutine() is often not suitable. For example, if the     program is split into dynamically loaded modules, the relevant     module may be unloaded long before the QApplication destructor is     called.      For modules and libraries, using a reference-counted     initialization manager or Qt's parent-child deletion mechanism may     be better. Here is an example of a private class that uses the     parent-child mechanism to call a cleanup function at the right     time:      \snippet doc/src/snippets/code/src_corelib_kernel_qcoreapplication.cpp 5      By selecting the right parent object, this can often be made to     clean up the module's data at the right moment. */
end_comment
begin_comment
comment|/*!     \macro Q_DECLARE_TR_FUNCTIONS(context)     \relates QCoreApplication      The Q_DECLARE_TR_FUNCTIONS() macro declares and implements two     translation functions, \c tr() and \c trUtf8(), with these     signatures:      \snippet doc/src/snippets/code/src_corelib_kernel_qcoreapplication.cpp 6      This macro is useful if you want to use QObject::tr() or     QObject::trUtf8() in classes that don't inherit from QObject.      Q_DECLARE_TR_FUNCTIONS() must appear at the very top of the     class definition (before the first \c{public:} or \c{protected:}).     For example:      \snippet doc/src/snippets/code/src_corelib_kernel_qcoreapplication.cpp 7      The \a context parameter is normally the class name, but it can     be any string.      \sa Q_OBJECT, QObject::tr(), QObject::trUtf8() */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qcoreapplication.cpp"
end_include
end_unit
