begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication_p.h"
end_include
begin_include
include|#
directive|include
file|"qabstracteventdispatcher.h"
end_include
begin_include
include|#
directive|include
file|"qcoreevent.h"
end_include
begin_include
include|#
directive|include
file|"qeventloop.h"
end_include
begin_include
include|#
directive|include
file|"qcorecmdlineargs_p.h"
end_include
begin_include
include|#
directive|include
file|<qdatastream.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<private/qprocess_p.h>
end_include
begin_include
include|#
directive|include
file|<qstandardpaths.h>
end_include
begin_include
include|#
directive|include
file|<qtextcodec.h>
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|<qthreadpool.h>
end_include
begin_include
include|#
directive|include
file|<qthreadstorage.h>
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<qelapsedtimer.h>
end_include
begin_include
include|#
directive|include
file|<qlibraryinfo.h>
end_include
begin_include
include|#
directive|include
file|<qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<private/qfactoryloader_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfunctions_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qlocale_p.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qeventdispatcher_blackberry_p.h"
end_include
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_GLIB
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qeventdispatcher_glib_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qeventdispatcher_unix_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_include
include|#
directive|include
file|"qeventdispatcher_win_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_MAC
end_ifdef
begin_include
include|#
directive|include
file|"qcore_mac_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|<locale.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_VXWORKS
end_ifdef
begin_include
include|#
directive|include
file|<taskLib.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QMutexUnlocker
class|class
name|QMutexUnlocker
block|{
public|public:
DECL|function|QMutexUnlocker
specifier|inline
specifier|explicit
name|QMutexUnlocker
parameter_list|(
name|QMutex
modifier|*
name|m
parameter_list|)
member_init_list|:
name|mtx
argument_list|(
name|m
argument_list|)
block|{ }
DECL|function|~QMutexUnlocker
specifier|inline
name|~
name|QMutexUnlocker
parameter_list|()
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|function|unlock
specifier|inline
name|void
name|unlock
parameter_list|()
block|{
if|if
condition|(
name|mtx
condition|)
name|mtx
operator|->
name|unlock
argument_list|()
expr_stmt|;
name|mtx
operator|=
literal|0
expr_stmt|;
block|}
private|private:
name|Q_DISABLE_COPY
argument_list|(
argument|QMutexUnlocker
argument_list|)
DECL|member|mtx
name|QMutex
modifier|*
name|mtx
decl_stmt|;
block|}
class|;
end_class
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_function_decl
specifier|extern
name|QString
name|qAppFileName
parameter_list|()
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|QT_VERSION
operator|>=
literal|0x060000
end_if
begin_error
error|#
directive|error
literal|"Bump QCoreApplicatoinPrivate::app_compile_version to 0x060000"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|member|app_compile_version
name|int
name|QCoreApplicationPrivate
operator|::
name|app_compile_version
init|=
literal|0x050000
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|app_compile_version
comment|//we don't know exactly, but it's at least 5.0.0
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_MAC
end_ifdef
begin_function
DECL|function|macMenuBarName
name|QString
name|QCoreApplicationPrivate
operator|::
name|macMenuBarName
parameter_list|()
block|{
name|QString
name|bundleName
decl_stmt|;
name|CFTypeRef
name|string
init|=
name|CFBundleGetValueForInfoDictionaryKey
argument_list|(
name|CFBundleGetMainBundle
argument_list|()
argument_list|,
name|CFSTR
argument_list|(
literal|"CFBundleName"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|string
condition|)
name|bundleName
operator|=
name|QCFString
operator|::
name|toQString
argument_list|(
cast|static_cast
argument_list|<
name|CFStringRef
argument_list|>
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bundleName
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|appName
name|QString
name|QCoreApplicationPrivate
operator|::
name|appName
parameter_list|()
specifier|const
block|{
specifier|static
name|QString
name|applName
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
name|applName
operator|=
name|macMenuBarName
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|applName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|argv
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|applName
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|p
condition|?
name|p
operator|+
literal|1
else|:
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|applName
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|checkInstance
name|bool
name|QCoreApplicationPrivate
operator|::
name|checkInstance
parameter_list|(
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|bool
name|b
init|=
operator|(
name|QCoreApplication
operator|::
name|self
operator|!=
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|qWarning
argument_list|(
literal|"QApplication::%s: Please instantiate the QApplication object first"
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_function
DECL|function|processCommandLineArguments
name|void
name|QCoreApplicationPrivate
operator|::
name|processCommandLineArguments
parameter_list|()
block|{
name|int
name|j
init|=
name|argc
condition|?
literal|1
else|:
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|&&
operator|*
name|argv
index|[
name|i
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
name|QByteArray
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|startsWith
argument_list|(
literal|"-qmljsdebugger="
argument_list|)
condition|)
block|{
name|qmljs_debug_arguments
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|arg
operator|.
name|right
argument_list|(
name|arg
operator|.
name|length
argument_list|()
operator|-
literal|15
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|<
name|argc
condition|)
block|{
name|argv
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|argc
operator|=
name|j
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Support for introspection
end_comment
begin_decl_stmt
DECL|variable|qt_signal_spy_callback_set
name|QSignalSpyCallbackSet
name|Q_CORE_EXPORT
name|qt_signal_spy_callback_set
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_register_signal_spy_callbacks
name|void
name|qt_register_signal_spy_callbacks
parameter_list|(
specifier|const
name|QSignalSpyCallbackSet
modifier|&
name|callback_set
parameter_list|)
block|{
name|qt_signal_spy_callback_set
operator|=
name|callback_set
expr_stmt|;
block|}
end_function
begin_extern
DECL|function|qt_startup_hook
extern|extern
literal|"C"
name|void
name|Q_CORE_EXPORT
name|qt_startup_hook
parameter_list|()
block|{ }
end_extern
begin_typedef
DECL|typedef|QVFuncList
typedef|typedef
name|QList
argument_list|<
name|QtCleanUpFunction
argument_list|>
name|QVFuncList
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QVFuncList
argument_list|,
argument|postRList
argument_list|)
end_macro
begin_function
DECL|function|qAddPostRoutine
name|void
name|qAddPostRoutine
parameter_list|(
name|QtCleanUpFunction
name|p
parameter_list|)
block|{
name|QVFuncList
modifier|*
name|list
init|=
name|postRList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return;
name|list
operator|->
name|prepend
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qRemovePostRoutine
name|void
name|qRemovePostRoutine
parameter_list|(
name|QtCleanUpFunction
name|p
parameter_list|)
block|{
name|QVFuncList
modifier|*
name|list
init|=
name|postRList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return;
name|list
operator|->
name|removeAll
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_call_post_routines
name|void
name|Q_CORE_EXPORT
name|qt_call_post_routines
parameter_list|()
block|{
name|QVFuncList
modifier|*
name|list
init|=
literal|0
decl_stmt|;
name|QT_TRY
block|{
name|list
operator|=
name|postRList
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::bad_alloc&
argument_list|)
block|{
comment|// ignore - if we can't allocate a post routine list,
comment|// there's a high probability that there's no post
comment|// routine to be executed :)
block|}
if|if
condition|(
operator|!
name|list
condition|)
return|return;
while|while
condition|(
operator|!
name|list
operator|->
name|isEmpty
argument_list|()
condition|)
operator|(
name|list
operator|->
name|takeFirst
argument_list|()
operator|)
operator|(
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// app starting up if false
end_comment
begin_decl_stmt
DECL|member|is_app_running
name|bool
name|QCoreApplicationPrivate
operator|::
name|is_app_running
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|// app closing down if true
end_comment
begin_decl_stmt
DECL|member|is_app_closing
name|bool
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|// initialized in qcoreapplication and in qtextstream autotest when setlocale is called.
end_comment
begin_decl_stmt
DECL|variable|qt_locale_initialized
specifier|static
name|bool
name|qt_locale_initialized
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qGlobalPostedEventsCount
name|Q_CORE_EXPORT
name|uint
name|qGlobalPostedEventsCount
parameter_list|()
block|{
name|QThreadData
modifier|*
name|currentThreadData
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
return|return
name|currentThreadData
operator|->
name|postEventList
operator|.
name|size
argument_list|()
operator|-
name|currentThreadData
operator|->
name|postEventList
operator|.
name|startOffset
return|;
block|}
end_function
begin_decl_stmt
DECL|member|self
name|QCoreApplication
modifier|*
name|QCoreApplication
operator|::
name|self
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|eventDispatcher
name|QAbstractEventDispatcher
modifier|*
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|attribs
name|uint
name|QCoreApplicationPrivate
operator|::
name|attribs
init|=
operator|(
literal|1
operator|<<
name|Qt
operator|::
name|AA_SynthesizeMouseForUnhandledTouchEvents
operator|)
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_decl_stmt
DECL|variable|qt_application_thread_id
name|Qt
operator|::
name|HANDLE
name|qt_application_thread_id
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_struct
DECL|struct|QCoreApplicationData
struct|struct
name|QCoreApplicationData
block|{
DECL|function|QCoreApplicationData
name|QCoreApplicationData
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
name|app_libpaths
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
DECL|function|~QCoreApplicationData
name|~
name|QCoreApplicationData
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
operator|delete
name|app_libpaths
expr_stmt|;
endif|#
directive|endif
comment|// cleanup the QAdoptedThread created for the main() thread
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|theMainThread
condition|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|get2
argument_list|(
name|QCoreApplicationPrivate
operator|::
name|theMainThread
argument_list|)
decl_stmt|;
name|QCoreApplicationPrivate
operator|::
name|theMainThread
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|deref
argument_list|()
expr_stmt|;
comment|// deletes the data and the adopted thread
block|}
block|}
ifdef|#
directive|ifdef
name|Q_OS_BLACKBERRY
comment|//The QCoreApplicationData struct is only populated on demand, because it is rarely needed and would
comment|//affect startup time
DECL|function|loadManifest
name|void
name|loadManifest
parameter_list|()
block|{
specifier|static
name|bool
name|manifestLoadAttempt
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|manifestLoadAttempt
condition|)
return|return;
name|manifestLoadAttempt
operator|=
literal|true
expr_stmt|;
name|QFile
name|metafile
argument_list|(
name|QStringLiteral
argument_list|(
literal|"app/META-INF/MANIFEST.MF"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|metafile
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"Could not open application metafile for reading"
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|!
name|metafile
operator|.
name|atEnd
argument_list|()
operator|&&
operator|(
name|application
operator|.
name|isEmpty
argument_list|()
operator|||
name|applicationVersion
operator|.
name|isEmpty
argument_list|()
operator|||
name|orgName
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|QByteArray
name|line
init|=
name|metafile
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"Application-Name:"
argument_list|)
condition|)
name|application
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|line
operator|.
name|mid
argument_list|(
literal|18
argument_list|)
operator|.
name|trimmed
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"Application-Version:"
argument_list|)
condition|)
name|applicationVersion
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|line
operator|.
name|mid
argument_list|(
literal|21
argument_list|)
operator|.
name|trimmed
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"Package-Author:"
argument_list|)
condition|)
name|orgName
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|line
operator|.
name|mid
argument_list|(
literal|16
argument_list|)
operator|.
name|trimmed
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|metafile
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
DECL|member|orgName
DECL|member|orgDomain
DECL|member|application
name|QString
name|orgName
decl_stmt|,
name|orgDomain
decl_stmt|,
name|application
decl_stmt|;
DECL|member|applicationVersion
name|QString
name|applicationVersion
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
DECL|member|app_libpaths
name|QStringList
modifier|*
name|app_libpaths
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QCoreApplicationData
argument_list|,
argument|coreappdata
argument_list|)
end_macro
begin_decl_stmt
DECL|variable|quitLockRefEnabled
specifier|static
name|bool
name|quitLockRefEnabled
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QCoreApplicationPrivate
name|QCoreApplicationPrivate
operator|::
name|QCoreApplicationPrivate
parameter_list|(
name|int
modifier|&
name|aargc
parameter_list|,
name|char
modifier|*
modifier|*
name|aargv
parameter_list|,
name|uint
name|flags
parameter_list|)
member_init_list|:
name|QObjectPrivate
argument_list|()
member_init_list|,
name|argc
argument_list|(
name|aargc
argument_list|)
member_init_list|,
name|argv
argument_list|(
name|aargv
argument_list|)
ifdef|#
directive|ifdef
name|Q_OS_WIN
member_init_list|,
name|origArgc
argument_list|(
name|aargc
argument_list|)
member_init_list|,
name|origArgv
argument_list|(
operator|new
name|char
operator|*
index|[
name|aargc
index|]
argument_list|)
endif|#
directive|endif
member_init_list|,
name|application_type
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|in_exec
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|aboutToQuitEmitted
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|threadData_clean
argument_list|(
literal|false
argument_list|)
block|{
name|app_compile_version
operator|=
name|flags
operator|&
literal|0xffffff
expr_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|empty
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|||
name|argv
operator|==
literal|0
condition|)
block|{
name|argc
operator|=
literal|0
expr_stmt|;
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|empty
expr_stmt|;
comment|// ouch! careful with QCoreApplication::argv()!
block|}
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
operator|=
literal|false
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|qt_application_thread_id
operator|=
name|QThread
operator|::
name|currentThreadId
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|qCopy
argument_list|(
name|argv
argument_list|,
name|argv
operator|+
name|argc
argument_list|,
name|origArgv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// note: this call to QThread::currentThread() may end up setting theMainThread!
if|if
condition|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|!=
name|theMainThread
condition|)
name|qWarning
argument_list|(
literal|"WARNING: QApplication was not created in the main() thread."
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QCoreApplicationPrivate
name|QCoreApplicationPrivate
operator|::
name|~
name|QCoreApplicationPrivate
parameter_list|()
block|{
name|cleanupThreadData
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
operator|delete
index|[]
name|origArgv
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_function
DECL|function|cleanupThreadData
name|void
name|QCoreApplicationPrivate
operator|::
name|cleanupThreadData
parameter_list|()
block|{
if|if
condition|(
name|threadData
operator|&&
operator|!
name|threadData_clean
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|void
modifier|*
name|data
init|=
operator|&
name|threadData
operator|->
name|tls
decl_stmt|;
name|QThreadStorageData
operator|::
name|finish
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// need to clear the state of the mainData, just in case a new QCoreApplication comes along.
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|threadData
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadData
operator|->
name|postEventList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|pe
init|=
name|threadData
operator|->
name|postEventList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|pe
operator|.
name|event
condition|)
block|{
operator|--
name|pe
operator|.
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|pe
operator|.
name|event
operator|->
name|posted
operator|=
literal|false
expr_stmt|;
operator|delete
name|pe
operator|.
name|event
expr_stmt|;
block|}
block|}
name|threadData
operator|->
name|postEventList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|threadData
operator|->
name|postEventList
operator|.
name|recursion
operator|=
literal|0
expr_stmt|;
name|threadData
operator|->
name|quitNow
operator|=
literal|false
expr_stmt|;
name|threadData_clean
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|createEventDispatcher
name|void
name|QCoreApplicationPrivate
operator|::
name|createEventDispatcher
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QCoreApplication
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherBlackberry
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_GLIB
argument_list|)
if|if
condition|(
name|qEnvironmentVariableIsEmpty
argument_list|(
literal|"QT_NO_GLIB"
argument_list|)
operator|&&
name|QEventDispatcherGlib
operator|::
name|versionSupported
argument_list|()
condition|)
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherGlib
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherUNIX
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherWin32
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"QEventDispatcher not yet ported to this platform"
endif|#
directive|endif
block|}
end_function
begin_decl_stmt
DECL|member|theMainThread
name|QThread
modifier|*
name|QCoreApplicationPrivate
operator|::
name|theMainThread
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|mainThread
name|QThread
modifier|*
name|QCoreApplicationPrivate
operator|::
name|mainThread
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|theMainThread
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|theMainThread
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_MAC_FRAMEWORK_BUILD
argument_list|)
end_if
begin_function
DECL|function|checkReceiverThread
name|void
name|QCoreApplicationPrivate
operator|::
name|checkReceiverThread
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|)
block|{
name|QThread
modifier|*
name|currentThread
init|=
name|QThread
operator|::
name|currentThread
argument_list|()
decl_stmt|;
name|QThread
modifier|*
name|thr
init|=
name|receiver
operator|->
name|thread
argument_list|()
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|currentThread
operator|==
name|thr
operator|||
operator|!
name|thr
argument_list|,
literal|"QCoreApplication::sendEvent"
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Cannot send events to objects owned by a different thread. "
literal|"Current thread %1. Receiver '%2' (of type '%3') was created in thread %4"
argument_list|)
operator|.
name|arg
argument_list|(
name|QString
operator|::
name|number
argument_list|(
operator|(
name|quintptr
operator|)
name|currentThread
argument_list|,
literal|16
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|receiver
operator|->
name|objectName
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|QString
operator|::
name|number
argument_list|(
operator|(
name|quintptr
operator|)
name|thr
argument_list|,
literal|16
argument_list|)
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|currentThread
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|thr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|appendApplicationPathToLibraryPaths
name|void
name|QCoreApplicationPrivate
operator|::
name|appendApplicationPathToLibraryPaths
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
name|QStringList
modifier|*
name|app_libpaths
init|=
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
decl_stmt|;
if|if
condition|(
operator|!
name|app_libpaths
condition|)
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|=
name|app_libpaths
operator|=
operator|new
name|QStringList
expr_stmt|;
name|QString
name|app_location
init|=
name|QCoreApplication
operator|::
name|applicationFilePath
argument_list|()
decl_stmt|;
name|app_location
operator|.
name|truncate
argument_list|(
name|app_location
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|app_location
operator|=
name|QDir
argument_list|(
name|app_location
argument_list|)
operator|.
name|canonicalPath
argument_list|()
expr_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|app_location
argument_list|)
operator|&&
operator|!
name|app_libpaths
operator|->
name|contains
argument_list|(
name|app_location
argument_list|)
condition|)
name|app_libpaths
operator|->
name|append
argument_list|(
name|app_location
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|qAppName
name|QString
name|qAppName
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"qAppName"
argument_list|)
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|appName
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|initLocale
name|void
name|QCoreApplicationPrivate
operator|::
name|initLocale
parameter_list|()
block|{
if|if
condition|(
name|qt_locale_initialized
condition|)
return|return;
name|qt_locale_initialized
operator|=
literal|true
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \class QCoreApplication     \inmodule QtCore     \brief The QCoreApplication class provides an event loop for console Qt     applications.      This class is used by non-GUI applications to provide their event     loop. For non-GUI application that uses Qt, there should be exactly     one QCoreApplication object. For GUI applications, see     QApplication.      QCoreApplication contains the main event loop, where all events     from the operating system (e.g., timer and network events) and     other sources are processed and dispatched. It also handles the     application's initialization and finalization, as well as     system-wide and application-wide settings.      \section1 The Event Loop and Event Handling      The event loop is started with a call to exec(). Long running     operations can call processEvents() to keep the application     responsive.      In general, we recommend that you create a QCoreApplication or a     QApplication object in your \c main() function as early as     possible. exec() will not return until the event loop exits; e.g.,     when quit() is called.      Several static convenience functions are also provided. The     QCoreApplication object is available from instance(). Events can     be sent or posted using sendEvent(), postEvent(), and     sendPostedEvents(). Pending events can be removed with     removePostedEvents() or flushed with flush().      The class provides a quit() slot and an aboutToQuit() signal.      \section1 Application and Library Paths      An application has an applicationDirPath() and an     applicationFilePath(). Library paths (see QLibrary) can be retrieved     with libraryPaths() and manipulated by setLibraryPaths(), addLibraryPath(),     and removeLibraryPath().      \section1 Internationalization and Translations      Translation files can be added or removed     using installTranslator() and removeTranslator(). Application     strings can be translated using translate(). The QObject::tr()     and QObject::trUtf8() functions are implemented in terms of     translate().      \section1 Accessing Command Line Arguments      The command line arguments which are passed to QCoreApplication's     constructor should be accessed using the arguments() function.     Note that some arguments supplied by the user may have been     processed and removed by QCoreApplication.      In cases where command line arguments need to be obtained using the     argv() function, you must convert them from the local string encoding     using QString::fromLocal8Bit().      \section1 Locale Settings      On Unix/Linux Qt is configured to use the system locale settings by     default. This can cause a conflict when using POSIX functions, for     instance, when converting between data types such as floats and     strings, since the notation may differ between locales. To get     around this problem, call the POSIX function \c{setlocale(LC_NUMERIC,"C")}     right after initializing QApplication or QCoreApplication to reset     the locale that is used for number formatting to "C"-locale.      \sa QGuiApplication, QAbstractEventDispatcher, QEventLoop,     {Semaphores Example}, {Wait Conditions Example} */
end_comment
begin_comment
comment|/*!     \fn static QCoreApplication *QCoreApplication::instance()      Returns a pointer to the application's QCoreApplication (or     QApplication) instance.      If no instance has been allocated, \c null is returned. */
end_comment
begin_comment
comment|/*!     \internal  */
end_comment
begin_constructor
DECL|function|QCoreApplication
name|QCoreApplication
operator|::
name|QCoreApplication
parameter_list|(
name|QCoreApplicationPrivate
modifier|&
name|p
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
block|{
name|init
argument_list|()
expr_stmt|;
comment|// note: it is the subclasses' job to call
comment|// QCoreApplicationPrivate::eventDispatcher->startingUp();
block|}
end_constructor
begin_comment
comment|/*!     Flushes the platform specific event queues.      If you are doing graphical changes inside a loop that does not     return to the event loop on asynchronous window systems like X11     or double buffered window systems like Mac OS X, and you want to     visualize these changes immediately (e.g. Splash Screens), call     this function.      \sa sendPostedEvents() */
end_comment
begin_function
DECL|function|flush
name|void
name|QCoreApplication
operator|::
name|flush
parameter_list|()
block|{
if|if
condition|(
name|self
operator|&&
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|eventDispatcher
condition|)
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|eventDispatcher
operator|->
name|flush
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a Qt kernel application. Kernel applications are     applications without a graphical user interface. These type of     applications are used at the console or as server processes.      The \a argc and \a argv arguments are processed by the application,     and made available in a more convenient form by the arguments()     function.      \warning The data referred to by \a argc and \a argv must stay valid     for the entire lifetime of the QCoreApplication object. In addition,     \a argc must be greater than zero and \a argv must contain at least     one valid character string. */
end_comment
begin_constructor
DECL|function|QCoreApplication
name|QCoreApplication
operator|::
name|QCoreApplication
parameter_list|(
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|_internal
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QCoreApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|_internal
argument_list|)
argument_list|)
block|{
name|init
argument_list|()
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|startingUp
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|// ### move to QCoreApplicationPrivate constructor?
end_comment
begin_function
DECL|function|init
name|void
name|QCoreApplication
operator|::
name|init
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QCoreApplication
argument_list|)
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|initLocale
argument_list|()
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
operator|!
name|self
argument_list|,
literal|"QCoreApplication"
argument_list|,
literal|"there should be only one application object"
argument_list|)
expr_stmt|;
name|QCoreApplication
operator|::
name|self
operator|=
name|this
expr_stmt|;
comment|// use the event dispatcher created by the app programmer (if any)
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
condition|)
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|=
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
expr_stmt|;
comment|// otherwise we create one
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
condition|)
name|d
operator|->
name|createEventDispatcher
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|parent
argument_list|()
condition|)
block|{
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|moveToThread
argument_list|(
name|d
operator|->
name|threadData
operator|->
name|thread
argument_list|)
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|=
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
if|if
condition|(
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
condition|)
name|d
operator|->
name|appendApplicationPathToLibraryPaths
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|QT_NO_PROCESS
argument_list|)
operator|)
comment|// Make sure the process manager thread object is created in the main
comment|// thread.
name|QProcessPrivate
operator|::
name|initializeProcessManager
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_EVAL
specifier|extern
name|void
name|qt_core_eval_init
argument_list|(
name|uint
argument_list|)
decl_stmt|;
name|qt_core_eval_init
argument_list|(
name|d
operator|->
name|application_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|processCommandLineArguments
argument_list|()
expr_stmt|;
name|qt_startup_hook
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Destroys the QCoreApplication object. */
end_comment
begin_destructor
DECL|function|~QCoreApplication
name|QCoreApplication
operator|::
name|~
name|QCoreApplication
parameter_list|()
block|{
name|qt_call_post_routines
argument_list|()
expr_stmt|;
name|self
operator|=
literal|0
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
operator|=
literal|true
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|is_app_running
operator|=
literal|false
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
comment|// Synchronize and stop the global thread pool threads.
name|QThreadPool
modifier|*
name|globalThreadPool
init|=
literal|0
decl_stmt|;
name|QT_TRY
block|{
name|globalThreadPool
operator|=
name|QThreadPool
operator|::
name|globalInstance
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// swallow the exception, since destructors shouldn't throw
block|}
if|if
condition|(
name|globalThreadPool
condition|)
name|globalThreadPool
operator|->
name|waitForDone
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|d_func
argument_list|()
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
condition|)
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|closingDown
argument_list|()
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
operator|delete
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
expr_stmt|;
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_comment
comment|/*!     Sets the attribute \a attribute if \a on is true;     otherwise clears the attribute.      One of the attributes that can be set with this method is     Qt::AA_ImmediateWidgetCreation. It tells Qt to create toplevel     windows immediately. Normally, resources for widgets are allocated     on demand to improve efficiency and minimize resource usage.     Therefore, if it is important to minimize resource consumption, do     not set this attribute.      \sa testAttribute() */
end_comment
begin_function
DECL|function|setAttribute
name|void
name|QCoreApplication
operator|::
name|setAttribute
parameter_list|(
name|Qt
operator|::
name|ApplicationAttribute
name|attribute
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
if|if
condition|(
name|on
condition|)
name|QCoreApplicationPrivate
operator|::
name|attribs
operator||=
literal|1
operator|<<
name|attribute
expr_stmt|;
else|else
name|QCoreApplicationPrivate
operator|::
name|attribs
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|attribute
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns true if attribute \a attribute is set;   otherwise returns false.    \sa setAttribute()  */
end_comment
begin_function
DECL|function|testAttribute
name|bool
name|QCoreApplication
operator|::
name|testAttribute
parameter_list|(
name|Qt
operator|::
name|ApplicationAttribute
name|attribute
parameter_list|)
block|{
return|return
name|QCoreApplicationPrivate
operator|::
name|testAttribute
argument_list|(
name|attribute
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!/     Returns true if the use of the QEventLoopLocker feature can cause the     application to quit, otherwise returns false.      \sa QEventLoopLocker  */
end_comment
begin_function
DECL|function|isQuitLockEnabled
name|bool
name|QCoreApplication
operator|::
name|isQuitLockEnabled
parameter_list|()
block|{
return|return
name|quitLockRefEnabled
return|;
block|}
end_function
begin_comment
comment|/*!     Enables the ability of the QEventLoopLocker feature to quit     the application.      If disabled, the use of QEventLoopLocker will not quit the application.      \sa QEventLoopLocker  */
end_comment
begin_function
DECL|function|setQuitLockEnabled
name|void
name|QCoreApplication
operator|::
name|setQuitLockEnabled
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|quitLockRefEnabled
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal    This function is here to make it possible for Qt extensions to   hook into event notification without subclassing QApplication */
end_comment
begin_function
DECL|function|notifyInternal
name|bool
name|QCoreApplication
operator|::
name|notifyInternal
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
comment|// Make it possible for QtScript to hook into events even
comment|// though QApplication is subclassed...
name|bool
name|result
init|=
literal|false
decl_stmt|;
name|void
modifier|*
name|cbdata
index|[]
init|=
block|{
name|receiver
block|,
name|event
block|,
operator|&
name|result
block|}
decl_stmt|;
if|if
condition|(
name|QInternal
operator|::
name|activateCallbacks
argument_list|(
name|QInternal
operator|::
name|EventNotifyCallback
argument_list|,
name|cbdata
argument_list|)
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Qt enforces the rule that events can only be sent to objects in
comment|// the current thread, so receiver->d_func()->threadData is
comment|// equivalent to QThreadData::current(), just without the function
comment|// call overhead.
name|QObjectPrivate
modifier|*
name|d
init|=
name|receiver
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|QThreadData
modifier|*
name|threadData
init|=
name|d
operator|->
name|threadData
decl_stmt|;
name|QScopedLoopLevelCounter
name|loopLevelCounter
argument_list|(
name|threadData
argument_list|)
decl_stmt|;
return|return
name|notify
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Sends \a event to \a receiver: \a {receiver}->event(\a event).   Returns the value that is returned from the receiver's event   handler. Note that this function is called for all events sent to   any object in any thread.    For certain types of events (e.g. mouse and key events),   the event will be propagated to the receiver's parent and so on up to   the top-level object if the receiver is not interested in the event   (i.e., it returns false).    There are five different ways that events can be processed;   reimplementing this virtual function is just one of them. All five   approaches are listed below:   \list 1   \li Reimplementing paintEvent(), mousePressEvent() and so   on. This is the commonest, easiest and least powerful way.    \li Reimplementing this function. This is very powerful, providing   complete control; but only one subclass can be active at a time.    \li Installing an event filter on QCoreApplication::instance(). Such   an event filter is able to process all events for all widgets, so   it's just as powerful as reimplementing notify(); furthermore, it's   possible to have more than one application-global event filter.   Global event filters even see mouse events for   \l{QWidget::isEnabled()}{disabled widgets}. Note that application   event filters are only called for objects that live in the main   thread.    \li Reimplementing QObject::event() (as QWidget does). If you do   this you get Tab key presses, and you get to see the events before   any widget-specific event filters.    \li Installing an event filter on the object. Such an event filter gets all   the events, including Tab and Shift+Tab key press events, as long as they   do not change the focus widget.   \endlist    \sa QObject::event(), installNativeEventFilter() */
end_comment
begin_function
DECL|function|notify
name|bool
name|QCoreApplication
operator|::
name|notify
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QCoreApplication
argument_list|)
expr_stmt|;
comment|// no events are delivered after ~QCoreApplication() has started
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|receiver
operator|==
literal|0
condition|)
block|{
comment|// serious error
name|qWarning
argument_list|(
literal|"QCoreApplication::notify: Unexpected null receiver"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|d
operator|->
name|checkReceiverThread
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|receiver
operator|->
name|isWidgetType
argument_list|()
condition|?
literal|false
else|:
name|d
operator|->
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sendThroughApplicationEventFilters
name|bool
name|QCoreApplicationPrivate
operator|::
name|sendThroughApplicationEventFilters
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|==
name|this
operator|->
name|threadData
operator|&&
name|extraData
condition|)
block|{
comment|// application event filters are only called for objects in the GUI thread
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|extraData
operator|->
name|eventFilters
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|QObject
modifier|*
name|obj
init|=
name|extraData
operator|->
name|eventFilters
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
if|if
condition|(
name|obj
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|!=
name|threadData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication: Application event filter cannot be in a different thread."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|obj
operator|->
name|eventFilter
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|sendThroughObjectEventFilters
name|bool
name|QCoreApplicationPrivate
operator|::
name|sendThroughObjectEventFilters
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QCoreApplication
argument_list|)
expr_stmt|;
if|if
condition|(
name|receiver
operator|!=
name|q
operator|&&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|extraData
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|extraData
operator|->
name|eventFilters
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|QObject
modifier|*
name|obj
init|=
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|extraData
operator|->
name|eventFilters
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
if|if
condition|(
name|obj
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|!=
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication: Object event filter cannot be in a different thread."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|obj
operator|->
name|eventFilter
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Helper function called by notify()  */
end_comment
begin_function
DECL|function|notify_helper
name|bool
name|QCoreApplicationPrivate
operator|::
name|notify_helper
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
comment|// send to all application event filters
if|if
condition|(
name|sendThroughApplicationEventFilters
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// send to all receiver event filters
if|if
condition|(
name|sendThroughObjectEventFilters
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// deliver the event
return|return
name|receiver
operator|->
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if an application object has not been created yet;   otherwise returns false.    \sa closingDown() */
end_comment
begin_function
DECL|function|startingUp
name|bool
name|QCoreApplication
operator|::
name|startingUp
parameter_list|()
block|{
return|return
operator|!
name|QCoreApplicationPrivate
operator|::
name|is_app_running
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if the application objects are being destroyed;   otherwise returns false.    \sa startingUp() */
end_comment
begin_function
DECL|function|closingDown
name|bool
name|QCoreApplication
operator|::
name|closingDown
parameter_list|()
block|{
return|return
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
return|;
block|}
end_function
begin_comment
comment|/*!     Processes all pending events for the calling thread according to     the specified \a flags until there are no more events to process.      You can call this function occasionally when your program is busy     performing a long operation (e.g. copying a file).      In event you are running a local loop which calls this function     continuously, without an event loop, the     \l{QEvent::DeferredDelete}{DeferredDelete} events will     not be processed. This can affect the behaviour of widgets,     e.g. QToolTip, that rely on \l{QEvent::DeferredDelete}{DeferredDelete}     events to function properly. An alternative would be to call     \l{QCoreApplication::sendPostedEvents()}{sendPostedEvents()} from     within that local loop.      Calling this function processes events only for the calling thread.      \threadsafe      \sa exec(), QTimer, QEventLoop::processEvents(), flush(), sendPostedEvents() */
end_comment
begin_function
DECL|function|processEvents
name|void
name|QCoreApplication
operator|::
name|processEvents
parameter_list|(
name|QEventLoop
operator|::
name|ProcessEventsFlags
name|flags
parameter_list|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|eventDispatcher
condition|)
return|return;
name|data
operator|->
name|eventDispatcher
operator|->
name|processEvents
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload processEvents()      Processes pending events for the calling thread for \a maxtime     milliseconds or until there are no more events to process,     whichever is shorter.      You can call this function occasionally when you program is busy     doing a long operation (e.g. copying a file).      Calling this function processes events only for the calling thread.      \threadsafe      \sa exec(), QTimer, QEventLoop::processEvents() */
end_comment
begin_function
DECL|function|processEvents
name|void
name|QCoreApplication
operator|::
name|processEvents
parameter_list|(
name|QEventLoop
operator|::
name|ProcessEventsFlags
name|flags
parameter_list|,
name|int
name|maxtime
parameter_list|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|eventDispatcher
condition|)
return|return;
name|QElapsedTimer
name|start
decl_stmt|;
name|start
operator|.
name|start
parameter_list|()
constructor_decl|;
while|while
condition|(
name|data
operator|->
name|eventDispatcher
operator|->
name|processEvents
argument_list|(
name|flags
operator|&
operator|~
name|QEventLoop
operator|::
name|WaitForMoreEvents
argument_list|)
condition|)
block|{
if|if
condition|(
name|start
operator|.
name|elapsed
argument_list|()
operator|>
name|maxtime
condition|)
break|break;
block|}
block|}
end_function
begin_comment
comment|/*****************************************************************************   Main event loop wrappers  *****************************************************************************/
end_comment
begin_comment
comment|/*!     Enters the main event loop and waits until exit() is called.     Returns the value that was set to exit() (which is 0 if exit() is     called via quit()).      It is necessary to call this function to start event handling. The     main event loop receives events from the window system and     dispatches these to the application widgets.      To make your application perform idle processing (i.e. executing a     special function whenever there are no pending events), use a     QTimer with 0 timeout. More advanced idle processing schemes can     be achieved using processEvents().      We recommend that you connect clean-up code to the     \l{QCoreApplication::}{aboutToQuit()} signal, instead of putting it in     your application's \c{main()} function because on some platforms the     QCoreApplication::exec() call may not return. For example, on Windows     when the user logs off, the system terminates the process after Qt     closes all top-level windows. Hence, there is no guarantee that the     application will have time to exit its event loop and execute code at     the end of the \c{main()} function after the QCoreApplication::exec()     call.      \sa quit(), exit(), processEvents(), QApplication::exec() */
end_comment
begin_function
DECL|function|exec
name|int
name|QCoreApplication
operator|::
name|exec
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"exec"
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|QThreadData
modifier|*
name|threadData
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
decl_stmt|;
if|if
condition|(
name|threadData
operator|!=
name|QThreadData
operator|::
name|current
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"%s::exec: Must be called from the main thread"
argument_list|,
name|self
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|threadData
operator|->
name|eventLoops
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::exec: The event loop is already running"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|threadData
operator|->
name|quitNow
operator|=
literal|false
expr_stmt|;
name|QEventLoop
name|eventLoop
decl_stmt|;
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|in_exec
operator|=
literal|true
expr_stmt|;
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|aboutToQuitEmitted
operator|=
literal|false
expr_stmt|;
name|int
name|returnCode
init|=
name|eventLoop
operator|.
name|exec
argument_list|()
decl_stmt|;
name|threadData
operator|->
name|quitNow
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|self
condition|)
block|{
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|in_exec
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|aboutToQuitEmitted
condition|)
emit|emit
name|self
operator|->
name|aboutToQuit
argument_list|()
emit|;
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|aboutToQuitEmitted
operator|=
literal|true
expr_stmt|;
name|sendPostedEvents
argument_list|(
literal|0
argument_list|,
name|QEvent
operator|::
name|DeferredDelete
argument_list|)
expr_stmt|;
block|}
return|return
name|returnCode
return|;
block|}
end_function
begin_comment
comment|/*!   Tells the application to exit with a return code.      After this function has been called, the application leaves the     main event loop and returns from the call to exec(). The exec()     function returns \a returnCode. If the event loop is not running,     this function does nothing.    By convention, a \a returnCode of 0 means success, and any non-zero   value indicates an error.    Note that unlike the C library function of the same name, this   function \e does return to the caller -- it is event processing that   stops.    \sa quit(), exec() */
end_comment
begin_function
DECL|function|exit
name|void
name|QCoreApplication
operator|::
name|exit
parameter_list|(
name|int
name|returnCode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|self
condition|)
return|return;
name|QThreadData
modifier|*
name|data
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
decl_stmt|;
name|data
operator|->
name|quitNow
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|eventLoops
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QEventLoop
modifier|*
name|eventLoop
init|=
name|data
operator|->
name|eventLoops
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|eventLoop
operator|->
name|exit
argument_list|(
name|returnCode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*****************************************************************************   QCoreApplication management of posted events  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \fn bool QCoreApplication::sendEvent(QObject *receiver, QEvent *event)      Sends event \a event directly to receiver \a receiver, using the     notify() function. Returns the value that was returned from the     event handler.      The event is \e not deleted when the event has been sent. The normal     approach is to create the event on the stack, for example:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 0      \sa postEvent(), notify() */
end_comment
begin_comment
comment|/*!     \since 4.3      Adds the event \a event, with the object \a receiver as the     receiver of the event, to an event queue and returns immediately.      The event must be allocated on the heap since the post event queue     will take ownership of the event and delete it once it has been     posted.  It is \e {not safe} to access the event after     it has been posted.      When control returns to the main event loop, all events that are     stored in the queue will be sent using the notify() function.      Events are sorted in descending \a priority order, i.e. events     with a high \a priority are queued before events with a lower \a     priority. The \a priority can be any integer value, i.e. between     INT_MAX and INT_MIN, inclusive; see Qt::EventPriority for more     details. Events with equal \a priority will be processed in the     order posted.      \threadsafe      \sa sendEvent(), notify(), sendPostedEvents(), Qt::EventPriority */
end_comment
begin_function
DECL|function|postEvent
name|void
name|QCoreApplication
operator|::
name|postEvent
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
if|if
condition|(
name|receiver
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::postEvent: Unexpected null receiver"
argument_list|)
expr_stmt|;
operator|delete
name|event
expr_stmt|;
return|return;
block|}
name|QThreadData
modifier|*
specifier|volatile
modifier|*
name|pdata
init|=
operator|&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
decl_stmt|;
name|QThreadData
modifier|*
name|data
init|=
operator|*
name|pdata
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
comment|// posting during destruction? just delete the event to prevent a leak
operator|delete
name|event
expr_stmt|;
return|return;
block|}
comment|// lock the post event mutex
name|data
operator|->
name|postEventList
operator|.
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// if object has moved to another thread, follow it
while|while
condition|(
name|data
operator|!=
operator|*
name|pdata
condition|)
block|{
name|data
operator|->
name|postEventList
operator|.
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|data
operator|=
operator|*
name|pdata
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
comment|// posting during destruction? just delete the event to prevent a leak
operator|delete
name|event
expr_stmt|;
return|return;
block|}
name|data
operator|->
name|postEventList
operator|.
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
name|QMutexUnlocker
name|locker
argument_list|(
operator|&
name|data
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
comment|// if this is one of the compressible events, do compression
if|if
condition|(
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|&&
name|self
operator|&&
name|self
operator|->
name|compressEvent
argument_list|(
name|event
argument_list|,
name|receiver
argument_list|,
operator|&
name|data
operator|->
name|postEventList
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DeferredDelete
operator|&&
name|data
operator|==
name|QThreadData
operator|::
name|current
argument_list|()
condition|)
block|{
comment|// remember the current running eventloop for DeferredDelete
comment|// events posted in the receiver's thread
cast|static_cast
argument_list|<
name|QDeferredDeleteEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|level
operator|=
name|data
operator|->
name|loopLevel
expr_stmt|;
block|}
comment|// delete the event on exceptions to protect against memory leaks till the event is
comment|// properly owned in the postEventList
name|QScopedPointer
argument_list|<
name|QEvent
argument_list|>
name|eventDeleter
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|addEvent
argument_list|(
name|QPostEvent
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|,
name|priority
argument_list|)
argument_list|)
expr_stmt|;
name|eventDeleter
operator|.
name|take
argument_list|()
expr_stmt|;
name|event
operator|->
name|posted
operator|=
literal|true
expr_stmt|;
operator|++
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|data
operator|->
name|canWait
operator|=
literal|false
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|eventDispatcher
condition|)
name|data
operator|->
name|eventDispatcher
operator|->
name|wakeUp
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Returns true if \a event was compressed away (possibly deleted) and should not be added to the list. */
end_comment
begin_function
DECL|function|compressEvent
name|bool
name|QCoreApplication
operator|::
name|compressEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QPostEventList
modifier|*
name|postedEvents
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|Q_ASSERT
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|postedEvents
argument_list|)
expr_stmt|;
comment|// compress posted timers to this object.
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Timer
operator|&&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|>
literal|0
condition|)
block|{
name|int
name|timerId
init|=
operator|(
operator|(
name|QTimerEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|timerId
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|postedEvents
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|e
init|=
name|postedEvents
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|receiver
operator|==
name|receiver
operator|&&
name|e
operator|.
name|event
operator|&&
name|e
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Timer
operator|&&
operator|(
operator|(
name|QTimerEvent
operator|*
operator|)
name|e
operator|.
name|event
operator|)
operator|->
name|timerId
argument_list|()
operator|==
name|timerId
condition|)
block|{
operator|delete
name|event
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DeferredDelete
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Quit
operator|)
operator|&&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|postedEvents
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|cur
init|=
name|postedEvents
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur
operator|.
name|receiver
operator|!=
name|receiver
operator|||
name|cur
operator|.
name|event
operator|==
literal|0
operator|||
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|!=
name|event
operator|->
name|type
argument_list|()
condition|)
continue|continue;
comment|// found an event for this receiver
operator|delete
name|event
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Immediately dispatches all events which have been previously queued   with QCoreApplication::postEvent() and which are for the object \a receiver   and have the event type \a event_type.    Events from the window system are \e not dispatched by this   function, but by processEvents().    If \a receiver is null, the events of \a event_type are sent for all   objects. If \a event_type is 0, all the events are sent for \a receiver.    \note This method must be called from the same thread as its QObject parameter, \a receiver.    \sa flush(), postEvent() */
end_comment
begin_function
DECL|function|sendPostedEvents
name|void
name|QCoreApplication
operator|::
name|sendPostedEvents
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|event_type
parameter_list|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
name|QCoreApplicationPrivate
operator|::
name|sendPostedEvents
argument_list|(
name|receiver
argument_list|,
name|event_type
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendPostedEvents
name|void
name|QCoreApplicationPrivate
operator|::
name|sendPostedEvents
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|event_type
parameter_list|,
name|QThreadData
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|event_type
operator|==
operator|-
literal|1
condition|)
block|{
comment|// we were called by an obsolete event dispatcher.
name|event_type
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|receiver
operator|&&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|!=
name|data
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::sendPostedEvents: Cannot send "
literal|"posted events for objects in another thread"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|data
operator|->
name|postEventList
operator|.
name|recursion
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|data
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
comment|// by default, we assume that the event dispatcher can go to sleep after
comment|// processing all events. if any new events are posted while we send
comment|// events, canWait will be set to false.
name|data
operator|->
name|canWait
operator|=
operator|(
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
operator|(
name|receiver
operator|&&
operator|!
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|)
condition|)
block|{
operator|--
name|data
operator|->
name|postEventList
operator|.
name|recursion
expr_stmt|;
return|return;
block|}
name|data
operator|->
name|canWait
operator|=
literal|true
expr_stmt|;
comment|// okay. here is the tricky loop. be careful about optimizing
comment|// this, it looks the way it does for good reasons.
name|int
name|startOffset
init|=
name|data
operator|->
name|postEventList
operator|.
name|startOffset
decl_stmt|;
name|int
modifier|&
name|i
init|=
operator|(
operator|!
name|event_type
operator|&&
operator|!
name|receiver
operator|)
condition|?
name|data
operator|->
name|postEventList
operator|.
name|startOffset
else|:
name|startOffset
decl_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|insertionOffset
operator|=
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
expr_stmt|;
comment|// Exception-safe cleaning up without the need for a try/catch block
struct|struct
name|CleanUp
block|{
name|QObject
modifier|*
name|receiver
decl_stmt|;
name|int
name|event_type
decl_stmt|;
name|QThreadData
modifier|*
name|data
decl_stmt|;
name|bool
name|exceptionCaught
decl_stmt|;
specifier|inline
name|CleanUp
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|event_type
parameter_list|,
name|QThreadData
modifier|*
name|data
parameter_list|)
member_init_list|:
name|receiver
argument_list|(
name|receiver
argument_list|)
member_init_list|,
name|event_type
argument_list|(
name|event_type
argument_list|)
member_init_list|,
name|data
argument_list|(
name|data
argument_list|)
member_init_list|,
name|exceptionCaught
argument_list|(
literal|true
argument_list|)
block|{}
specifier|inline
name|~
name|CleanUp
parameter_list|()
block|{
if|if
condition|(
name|exceptionCaught
condition|)
block|{
comment|// since we were interrupted, we need another pass to make sure we clean everything up
name|data
operator|->
name|canWait
operator|=
literal|false
expr_stmt|;
block|}
operator|--
name|data
operator|->
name|postEventList
operator|.
name|recursion
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|postEventList
operator|.
name|recursion
operator|&&
operator|!
name|data
operator|->
name|canWait
operator|&&
name|data
operator|->
name|eventDispatcher
condition|)
name|data
operator|->
name|eventDispatcher
operator|->
name|wakeUp
argument_list|()
expr_stmt|;
comment|// clear the global list, i.e. remove everything that was
comment|// delivered.
if|if
condition|(
operator|!
name|event_type
operator|&&
operator|!
name|receiver
operator|&&
name|data
operator|->
name|postEventList
operator|.
name|startOffset
operator|>=
literal|0
condition|)
block|{
specifier|const
name|QPostEventList
operator|::
name|iterator
name|it
init|=
name|data
operator|->
name|postEventList
operator|.
name|begin
argument_list|()
decl_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|erase
argument_list|(
name|it
argument_list|,
name|it
operator|+
name|data
operator|->
name|postEventList
operator|.
name|startOffset
argument_list|)
expr_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|insertionOffset
operator|-=
name|data
operator|->
name|postEventList
operator|.
name|startOffset
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
operator|->
name|postEventList
operator|.
name|insertionOffset
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|startOffset
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
struct|;
name|CleanUp
name|cleanup
argument_list|(
name|receiver
argument_list|,
name|event_type
argument_list|,
name|data
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// avoid live-lock
if|if
condition|(
name|i
operator|>=
name|data
operator|->
name|postEventList
operator|.
name|insertionOffset
condition|)
break|break;
specifier|const
name|QPostEvent
modifier|&
name|pe
init|=
name|data
operator|->
name|postEventList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|pe
operator|.
name|event
condition|)
continue|continue;
if|if
condition|(
operator|(
name|receiver
operator|&&
name|receiver
operator|!=
name|pe
operator|.
name|receiver
operator|)
operator|||
operator|(
name|event_type
operator|&&
name|event_type
operator|!=
name|pe
operator|.
name|event
operator|->
name|type
argument_list|()
operator|)
condition|)
block|{
name|data
operator|->
name|canWait
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pe
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DeferredDelete
condition|)
block|{
comment|// DeferredDelete events are only sent when we are explicitly asked to
comment|// (s.a. QEvent::DeferredDelete), and then only if the event loop that
comment|// posted the event has returned.
name|int
name|loopLevel
init|=
cast|static_cast
argument_list|<
name|QDeferredDeleteEvent
operator|*
argument_list|>
argument_list|(
name|pe
operator|.
name|event
argument_list|)
operator|->
name|loopLevel
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|allowDeferredDelete
init|=
operator|(
name|loopLevel
operator|>
name|data
operator|->
name|loopLevel
operator|||
operator|(
operator|!
name|loopLevel
operator|&&
name|data
operator|->
name|loopLevel
operator|>
literal|0
operator|)
operator|||
operator|(
name|event_type
operator|==
name|QEvent
operator|::
name|DeferredDelete
operator|&&
name|loopLevel
operator|==
name|data
operator|->
name|loopLevel
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowDeferredDelete
condition|)
block|{
comment|// cannot send deferred delete
if|if
condition|(
operator|!
name|event_type
operator|&&
operator|!
name|receiver
condition|)
block|{
comment|// we must copy it first; we want to re-post the event
comment|// with the event pointer intact, but we can't delay
comment|// nulling the event ptr until after re-posting, as
comment|// addEvent may invalidate pe.
name|QPostEvent
name|pe_copy
init|=
name|pe
decl_stmt|;
comment|// null out the event so if sendPostedEvents recurses, it
comment|// will ignore this one, as it's been re-posted.
cast|const_cast
argument_list|<
name|QPostEvent
operator|&
argument_list|>
argument_list|(
name|pe
argument_list|)
operator|.
name|event
operator|=
literal|0
expr_stmt|;
comment|// re-post the copied event so it isn't lost
name|data
operator|->
name|postEventList
operator|.
name|addEvent
argument_list|(
name|pe_copy
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
comment|// first, we diddle the event so that we can deliver
comment|// it, and that no one will try to touch it later.
name|pe
operator|.
name|event
operator|->
name|posted
operator|=
literal|false
expr_stmt|;
name|QScopedPointer
argument_list|<
name|QEvent
argument_list|>
name|e
argument_list|(
name|pe
operator|.
name|event
argument_list|)
decl_stmt|;
name|QObject
modifier|*
name|r
init|=
name|pe
operator|.
name|receiver
decl_stmt|;
operator|--
name|r
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|r
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// next, update the data structure so that we're ready
comment|// for the next event.
cast|const_cast
argument_list|<
name|QPostEvent
operator|&
argument_list|>
argument_list|(
name|pe
argument_list|)
operator|.
name|event
operator|=
literal|0
expr_stmt|;
struct|struct
name|MutexUnlocker
block|{
name|QMutexLocker
modifier|&
name|m
decl_stmt|;
name|MutexUnlocker
parameter_list|(
name|QMutexLocker
modifier|&
name|m
parameter_list|)
member_init_list|:
name|m
argument_list|(
name|m
argument_list|)
block|{
name|m
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|~
name|MutexUnlocker
parameter_list|()
block|{
name|m
operator|.
name|relock
argument_list|()
expr_stmt|;
block|}
block|}
struct|;
name|MutexUnlocker
name|unlocker
argument_list|(
name|locker
argument_list|)
decl_stmt|;
comment|// after all that work, it's time to deliver the event.
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|r
argument_list|,
name|e
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
comment|// careful when adding anything below this point - the
comment|// sendEvent() call might invalidate any invariants this
comment|// function depends on.
block|}
name|cleanup
operator|.
name|exceptionCaught
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Removes all events of the given \a eventType that were posted     using postEvent() for \a receiver.      The events are \e not dispatched, instead they are removed from     the queue. You should never need to call this function. If you do     call it, be aware that killing events may cause \a receiver to     break one or more invariants.      If \a receiver is null, the events of \a eventType are removed for     all objects. If \a eventType is 0, all the events are removed for     \a receiver. You should never call this function with \a eventType     of 0. If you do call it in this way, be aware that killing events     may cause \a receiver to break one or more invariants.      \threadsafe */
end_comment
begin_function
DECL|function|removePostedEvents
name|void
name|QCoreApplication
operator|::
name|removePostedEvents
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|eventType
parameter_list|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|receiver
condition|?
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
else|:
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|data
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
comment|// the QObject destructor calls this function directly.  this can
comment|// happen while the event loop is in the middle of posting events,
comment|// and when we get here, we may not have any more posted events
comment|// for this object.
if|if
condition|(
name|receiver
operator|&&
operator|!
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
condition|)
return|return;
comment|//we will collect all the posted events for the QObject
comment|//and we'll delete after the mutex was unlocked
name|QVarLengthArray
argument_list|<
name|QEvent
modifier|*
argument_list|>
name|events
decl_stmt|;
name|int
name|n
init|=
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|pe
init|=
name|data
operator|->
name|postEventList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|receiver
operator|||
name|pe
operator|.
name|receiver
operator|==
name|receiver
operator|)
operator|&&
operator|(
name|pe
operator|.
name|event
operator|&&
operator|(
name|eventType
operator|==
literal|0
operator|||
name|pe
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|eventType
operator|)
operator|)
condition|)
block|{
operator|--
name|pe
operator|.
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|pe
operator|.
name|event
operator|->
name|posted
operator|=
literal|false
expr_stmt|;
name|events
operator|.
name|append
argument_list|(
name|pe
operator|.
name|event
argument_list|)
expr_stmt|;
cast|const_cast
argument_list|<
name|QPostEvent
operator|&
argument_list|>
argument_list|(
name|pe
argument_list|)
operator|.
name|event
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|data
operator|->
name|postEventList
operator|.
name|recursion
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|j
condition|)
name|qSwap
argument_list|(
name|data
operator|->
name|postEventList
index|[
name|i
index|]
argument_list|,
name|data
operator|->
name|postEventList
index|[
name|j
index|]
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|QT_DEBUG
if|if
condition|(
name|receiver
operator|&&
name|eventType
operator|==
literal|0
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|data
operator|->
name|postEventList
operator|.
name|recursion
condition|)
block|{
comment|// truncate list
name|data
operator|->
name|postEventList
operator|.
name|erase
argument_list|(
name|data
operator|->
name|postEventList
operator|.
name|begin
argument_list|()
operator|+
name|j
argument_list|,
name|data
operator|->
name|postEventList
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|events
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
operator|delete
name|events
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Removes \a event from the queue of posted events, and emits a   warning message if appropriate.    \warning This function can be \e really slow. Avoid using it, if   possible.    \threadsafe */
end_comment
begin_function
DECL|function|removePostedEvent
name|void
name|QCoreApplicationPrivate
operator|::
name|removePostedEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|event
operator|||
operator|!
name|event
operator|->
name|posted
condition|)
return|return;
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|data
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QCoreApplication::removePostedEvent: Internal error: %p %d is posted"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|event
argument_list|,
name|event
operator|->
name|type
argument_list|()
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|pe
init|=
name|data
operator|->
name|postEventList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|pe
operator|.
name|event
operator|==
name|event
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QCoreApplication::removePostedEvent: Event of type %d deleted while posted to %s %s"
argument_list|,
name|event
operator|->
name|type
argument_list|()
argument_list|,
name|pe
operator|.
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|pe
operator|.
name|receiver
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|pe
operator|.
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|pe
operator|.
name|event
operator|->
name|posted
operator|=
literal|false
expr_stmt|;
operator|delete
name|pe
operator|.
name|event
expr_stmt|;
cast|const_cast
argument_list|<
name|QPostEvent
operator|&
argument_list|>
argument_list|(
name|pe
argument_list|)
operator|.
name|event
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!\reimp  */
end_comment
begin_function
DECL|function|event
name|bool
name|QCoreApplication
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Quit
condition|)
block|{
name|quit
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|QObject
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \enum QCoreApplication::Encoding     \obsolete      This enum type used to define the 8-bit encoding of character string     arguments to translate(). This enum is now obsolete and UTF-8 will be     used in all cases.      \value UnicodeUTF8   UTF-8.     \omitvalue Latin1     \omitvalue DefaultCodec  UTF-8.     \omitvalue CodecForTr      \sa QObject::tr(), QString::fromUtf8() */
end_comment
begin_function
DECL|function|ref
name|void
name|QCoreApplicationPrivate
operator|::
name|ref
parameter_list|()
block|{
name|quitLockRef
operator|.
name|ref
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|deref
name|void
name|QCoreApplicationPrivate
operator|::
name|deref
parameter_list|()
block|{
if|if
condition|(
operator|!
name|quitLockRef
operator|.
name|deref
argument_list|()
condition|)
name|maybeQuit
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|maybeQuit
name|void
name|QCoreApplicationPrivate
operator|::
name|maybeQuit
parameter_list|()
block|{
if|if
condition|(
name|quitLockRef
operator|.
name|load
argument_list|()
operator|==
literal|0
operator|&&
name|in_exec
operator|&&
name|quitLockRefEnabled
operator|&&
name|shouldQuit
argument_list|()
condition|)
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|Quit
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Tells the application to exit with return code 0 (success).     Equivalent to calling QCoreApplication::exit(0).      It's common to connect the QApplication::lastWindowClosed() signal     to quit(), and you also often connect e.g. QAbstractButton::clicked() or     signals in QAction, QMenu, or QMenuBar to it.      Example:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 1      \sa exit(), aboutToQuit(), QApplication::lastWindowClosed() */
end_comment
begin_function
DECL|function|quit
name|void
name|QCoreApplication
operator|::
name|quit
parameter_list|()
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \fn void QCoreApplication::aboutToQuit()    This signal is emitted when the application is about to quit the   main event loop, e.g. when the event loop level drops to zero.   This may happen either after a call to quit() from inside the   application or when the users shuts down the entire desktop session.    The signal is particularly useful if your application has to do some   last-second cleanup. Note that no user interaction is possible in   this state.    \sa quit() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TRANSLATION
end_ifndef
begin_comment
comment|/*!     Adds the translation file \a translationFile to the list of     translation files to be used for translations.      Multiple translation files can be installed. Translations are     searched for in the reverse order in which they were installed,     so the most recently installed translation file is searched first     and the first translation file installed is searched last.     The search stops as soon as a translation containing a matching     string is found.      Installing or removing a QTranslator, or changing an installed QTranslator     generates a \l{QEvent::LanguageChange}{LanguageChange} event for the     QCoreApplication instance. A QApplication instance will propagate the event     to all toplevel windows, where a reimplementation of changeEvent can     re-translate the user interface by passing user-visible strings via the     tr() function to the respective property setters. User-interface classes     generated by Qt Designer provide a \c retranslateUi() function that can be     called.      The function returns true on success and false on failure.      \sa removeTranslator(), translate(), QTranslator::load(), {Dynamic Translation} */
end_comment
begin_function
DECL|function|installTranslator
name|bool
name|QCoreApplication
operator|::
name|installTranslator
parameter_list|(
name|QTranslator
modifier|*
name|translationFile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|translationFile
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"installTranslator"
argument_list|)
condition|)
return|return
literal|false
return|;
name|QCoreApplicationPrivate
modifier|*
name|d
init|=
name|self
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|d
operator|->
name|translators
operator|.
name|prepend
argument_list|(
name|translationFile
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TRANSLATION_BUILDER
if|if
condition|(
name|translationFile
operator|->
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
endif|#
directive|endif
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|LanguageChange
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|self
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the translation file \a translationFile from the list of     translation files used by this application. (It does not delete the     translation file from the file system.)      The function returns true on success and false on failure.      \sa installTranslator(), translate(), QObject::tr() */
end_comment
begin_function
DECL|function|removeTranslator
name|bool
name|QCoreApplication
operator|::
name|removeTranslator
parameter_list|(
name|QTranslator
modifier|*
name|translationFile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|translationFile
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"removeTranslator"
argument_list|)
condition|)
return|return
literal|false
return|;
name|QCoreApplicationPrivate
modifier|*
name|d
init|=
name|self
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|translators
operator|.
name|removeAll
argument_list|(
name|translationFile
argument_list|)
operator|&&
operator|!
name|self
operator|->
name|closingDown
argument_list|()
condition|)
block|{
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|LanguageChange
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|self
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|replacePercentN
specifier|static
name|void
name|replacePercentN
parameter_list|(
name|QString
modifier|*
name|result
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|int
name|percentPos
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|percentPos
operator|=
name|result
operator|->
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
argument_list|,
name|percentPos
operator|+
name|len
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
name|QString
name|fmt
decl_stmt|;
if|if
condition|(
name|result
operator|->
name|at
argument_list|(
name|percentPos
operator|+
name|len
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'L'
argument_list|)
condition|)
block|{
operator|++
name|len
expr_stmt|;
name|fmt
operator|=
name|QLatin1String
argument_list|(
literal|"%L1"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fmt
operator|=
name|QLatin1String
argument_list|(
literal|"%1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|->
name|at
argument_list|(
name|percentPos
operator|+
name|len
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'n'
argument_list|)
condition|)
block|{
name|fmt
operator|=
name|fmt
operator|.
name|arg
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|++
name|len
expr_stmt|;
name|result
operator|->
name|replace
argument_list|(
name|percentPos
argument_list|,
name|len
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|len
operator|=
name|fmt
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \reentrant      Returns the translation text for \a sourceText, by querying the     installed translation files. The translation files are searched     from the most recently installed file back to the first     installed file.      QObject::tr() provides this functionality more conveniently.      \a context is typically a class name (e.g., "MyDialog") and \a     sourceText is either English text or a short identifying text.      \a disambiguation is an identifying string, for when the same \a     sourceText is used in different roles within the same context. By     default, it is null.      See the \l QTranslator and \l QObject::tr() documentation for     more information about contexts, disambiguations and comments.      \a n is used in conjunction with \c %n to support plural forms.     See QObject::tr() for details.      If none of the translation files contain a translation for \a     sourceText in \a context, this function returns a QString     equivalent of \a sourceText.      This function is not virtual. You can use alternative translation     techniques by subclassing \l QTranslator.      \warning This method is reentrant only if all translators are     installed \e before calling this method. Installing or removing     translators while performing translations is not supported. Doing     so will most likely result in crashes or other undesirable     behavior.      \sa QObject::tr(), installTranslator() */
end_comment
begin_function
DECL|function|translate
name|QString
name|QCoreApplication
operator|::
name|translate
parameter_list|(
specifier|const
name|char
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|sourceText
parameter_list|,
specifier|const
name|char
modifier|*
name|disambiguation
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|sourceText
condition|)
return|return
name|result
return|;
if|if
condition|(
name|self
operator|&&
operator|!
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|translators
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|QTranslator
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|it
decl_stmt|;
name|QTranslator
modifier|*
name|translationFile
decl_stmt|;
for|for
control|(
name|it
operator|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|translators
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|translators
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|translationFile
operator|=
operator|*
name|it
expr_stmt|;
name|result
operator|=
name|translationFile
operator|->
name|translate
argument_list|(
name|context
argument_list|,
name|sourceText
argument_list|,
name|disambiguation
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|isNull
argument_list|()
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|result
operator|.
name|isNull
argument_list|()
condition|)
name|result
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|sourceText
argument_list|)
expr_stmt|;
name|replacePercentN
argument_list|(
operator|&
name|result
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*! \fn static QString QCoreApplication::translate(const char *context, const char *key, const char *disambiguation, Encoding encoding, int n = -1)    \obsolete */
end_comment
begin_comment
comment|// Declared in qglobal.h
end_comment
begin_function
DECL|function|qtTrId
name|QString
name|qtTrId
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|0
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isTranslatorInstalled
name|bool
name|QCoreApplicationPrivate
operator|::
name|isTranslatorInstalled
parameter_list|(
name|QTranslator
modifier|*
name|translator
parameter_list|)
block|{
return|return
name|QCoreApplication
operator|::
name|self
operator|&&
name|QCoreApplication
operator|::
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|translators
operator|.
name|contains
argument_list|(
name|translator
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_TRANSLATE
end_comment
begin_comment
comment|/*!     Returns the directory that contains the application executable.      For example, if you have installed Qt in the \c{C:\Qt}     directory, and you run the \c{regexp} example, this function will     return "C:/Qt/examples/tools/regexp".      On Mac OS X this will point to the directory actually containing the     executable, which may be inside of an application bundle (if the     application is bundled).      \warning On Linux, this function will try to get the path from the     \c {/proc} file system. If that fails, it assumes that \c     {argv[0]} contains the absolute file name of the executable. The     function also assumes that the current directory has not been     changed by the application.      \sa applicationFilePath() */
end_comment
begin_function
DECL|function|applicationDirPath
name|QString
name|QCoreApplication
operator|::
name|applicationDirPath
parameter_list|()
block|{
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::applicationDirPath: Please instantiate the QApplication object first"
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QCoreApplicationPrivate
modifier|*
name|d
init|=
name|self
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|cachedApplicationDirPath
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|cachedApplicationDirPath
operator|=
name|QFileInfo
argument_list|(
name|applicationFilePath
argument_list|()
argument_list|)
operator|.
name|path
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cachedApplicationDirPath
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the file path of the application executable.      For example, if you have installed Qt in the \c{/usr/local/qt}     directory, and you run the \c{regexp} example, this function will     return "/usr/local/qt/examples/tools/regexp/regexp".      \warning On Linux, this function will try to get the path from the     \c {/proc} file system. If that fails, it assumes that \c     {argv[0]} contains the absolute file name of the executable. The     function also assumes that the current directory has not been     changed by the application.      \sa applicationDirPath() */
end_comment
begin_function
DECL|function|applicationFilePath
name|QString
name|QCoreApplication
operator|::
name|applicationFilePath
parameter_list|()
block|{
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::applicationFilePath: Please instantiate the QApplication object first"
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QCoreApplicationPrivate
modifier|*
name|d
init|=
name|self
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|cachedApplicationFilePath
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|d
operator|->
name|cachedApplicationFilePath
return|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|d
operator|->
name|cachedApplicationFilePath
operator|=
name|QFileInfo
argument_list|(
name|qAppFileName
argument_list|()
argument_list|)
operator|.
name|filePath
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cachedApplicationFilePath
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
name|QDir
name|dir
argument_list|(
name|QStringLiteral
argument_list|(
literal|"./app/native/"
argument_list|)
argument_list|)
decl_stmt|;
name|QStringList
name|executables
init|=
name|dir
operator|.
name|entryList
argument_list|(
name|QDir
operator|::
name|Executable
operator||
name|QDir
operator|::
name|Files
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|executables
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|//We assume that there is only one executable in the folder
return|return
name|dir
operator|.
name|absoluteFilePath
argument_list|(
name|executables
operator|.
name|first
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|QString
argument_list|()
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
name|QString
name|qAppFileName_str
init|=
name|qAppFileName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|qAppFileName_str
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QFileInfo
name|fi
argument_list|(
name|qAppFileName_str
argument_list|)
decl_stmt|;
name|d
operator|->
name|cachedApplicationFilePath
operator|=
name|fi
operator|.
name|exists
argument_list|()
condition|?
name|fi
operator|.
name|canonicalFilePath
argument_list|()
else|:
name|QString
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cachedApplicationFilePath
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
ifdef|#
directive|ifdef
name|Q_OS_LINUX
comment|// Try looking for a /proc/<pid>/exe symlink first which points to
comment|// the absolute path of the executable
name|QFileInfo
name|pfi
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"/proc/%1/exe"
argument_list|)
operator|.
name|arg
argument_list|(
name|getpid
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pfi
operator|.
name|exists
argument_list|()
operator|&&
name|pfi
operator|.
name|isSymLink
argument_list|()
condition|)
block|{
name|d
operator|->
name|cachedApplicationFilePath
operator|=
name|pfi
operator|.
name|canonicalFilePath
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cachedApplicationFilePath
return|;
block|}
endif|#
directive|endif
name|QString
name|argv0
init|=
name|QFile
operator|::
name|decodeName
argument_list|(
name|arguments
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|absPath
decl_stmt|;
if|if
condition|(
operator|!
name|argv0
operator|.
name|isEmpty
argument_list|()
operator|&&
name|argv0
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
comment|/*           If argv0 starts with a slash, it is already an absolute           file path.         */
name|absPath
operator|=
name|argv0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv0
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
block|{
comment|/*           If argv0 contains one or more slashes, it is a file path           relative to the current directory.         */
name|absPath
operator|=
name|QDir
operator|::
name|current
argument_list|()
operator|.
name|absoluteFilePath
argument_list|(
name|argv0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*           Otherwise, the file path has to be determined using the           PATH environment variable.         */
name|absPath
operator|=
name|QStandardPaths
operator|::
name|findExecutable
argument_list|(
name|argv0
argument_list|)
expr_stmt|;
block|}
name|absPath
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|absPath
argument_list|)
expr_stmt|;
name|QFileInfo
name|fi
argument_list|(
name|absPath
argument_list|)
decl_stmt|;
name|d
operator|->
name|cachedApplicationFilePath
operator|=
name|fi
operator|.
name|exists
argument_list|()
condition|?
name|fi
operator|.
name|canonicalFilePath
argument_list|()
else|:
name|QString
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cachedApplicationFilePath
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the current process ID for the application. */
end_comment
begin_function
DECL|function|applicationPid
name|qint64
name|QCoreApplication
operator|::
name|applicationPid
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
return|return
name|GetCurrentProcessId
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
return|return
operator|(
name|pid_t
operator|)
name|taskIdCurrent
return|;
else|#
directive|else
return|return
name|getpid
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the list of command-line arguments.      Usually arguments().at(0) is the program name, arguments().at(1)     is the first argument, and arguments().last() is the last     argument. See the note below about Windows.      Calling this function is slow - you should store the result in a variable     when parsing the command line.      \warning On Unix, this list is built from the argc and argv parameters passed     to the constructor in the main() function. The string-data in argv is     interpreted using QString::fromLocal8Bit(); hence it is not possible to     pass, for example, Japanese command line arguments on a system that runs in a     Latin1 locale. Most modern Unix systems do not have this limitation, as they are     Unicode-based.      On NT-based Windows, this limitation does not apply either.     On Windows, the arguments() are not built from the contents of argv/argc, as     the content does not support Unicode. Instead, the arguments() are constructed     from the return value of     \l{http://msdn2.microsoft.com/en-us/library/ms683156(VS.85).aspx}{GetCommandLine()}.     As a result of this, the string given by arguments().at(0) might not be     the program name on Windows, depending on how the application was started.      \sa applicationFilePath() */
end_comment
begin_function
DECL|function|arguments
name|QStringList
name|QCoreApplication
operator|::
name|arguments
parameter_list|()
block|{
name|QStringList
name|list
decl_stmt|;
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::arguments: Please instantiate the QApplication object first"
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
specifier|const
name|int
name|ac
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
specifier|const
name|av
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|argv
decl_stmt|;
name|list
operator|.
name|reserve
argument_list|(
name|ac
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|// On Windows, it is possible to pass Unicode arguments on
comment|// the command line. To restore those, we split the command line
comment|// and filter out arguments that were deleted by derived application
comment|// classes by index.
name|QString
name|cmdline
init|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|GetCommandLine
argument_list|()
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|wchar_t
name|tempFilename
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|GetModuleFileName
argument_list|(
literal|0
argument_list|,
name|tempFilename
argument_list|,
name|MAX_PATH
argument_list|)
condition|)
block|{
name|tempFilename
index|[
name|MAX_PATH
index|]
operator|=
literal|0
expr_stmt|;
name|cmdline
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
operator|+
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|tempFilename
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"\" "
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Q_OS_WINCE
name|char
modifier|*
modifier|*
specifier|const
name|origArgv
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|origArgv
decl_stmt|;
specifier|const
name|int
name|origArgc
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|origArgc
decl_stmt|;
name|char
modifier|*
modifier|*
specifier|const
name|avEnd
init|=
name|av
operator|+
name|ac
decl_stmt|;
specifier|const
name|QStringList
name|allArguments
init|=
name|qWinCmdArgs
argument_list|(
name|cmdline
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|allArguments
operator|.
name|size
argument_list|()
operator|==
name|origArgc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|origArgc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|qFind
argument_list|(
name|av
argument_list|,
name|avEnd
argument_list|,
name|origArgv
index|[
name|i
index|]
argument_list|)
operator|!=
name|avEnd
condition|)
name|list
operator|.
name|push_back
argument_list|(
name|allArguments
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|ac
condition|;
operator|++
name|a
control|)
block|{
name|list
operator|<<
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|av
index|[
name|a
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCoreApplication::organizationName     \brief the name of the organization that wrote this application      The value is used by the QSettings class when it is constructed     using the empty constructor. This saves having to repeat this     information each time a QSettings object is created.      On Mac, QSettings uses organizationDomain() as the organization     if it's not an empty string; otherwise it uses     organizationName(). On all other platforms, QSettings uses     organizationName() as the organization.      \sa organizationDomain, applicationName */
end_comment
begin_function
DECL|function|setOrganizationName
name|void
name|QCoreApplication
operator|::
name|setOrganizationName
parameter_list|(
specifier|const
name|QString
modifier|&
name|orgName
parameter_list|)
block|{
name|coreappdata
argument_list|()
operator|->
name|orgName
operator|=
name|orgName
expr_stmt|;
block|}
end_function
begin_function
DECL|function|organizationName
name|QString
name|QCoreApplication
operator|::
name|organizationName
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_OS_BLACKBERRY
name|coreappdata
argument_list|()
operator|->
name|loadManifest
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|coreappdata
argument_list|()
operator|->
name|orgName
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCoreApplication::organizationDomain     \brief the Internet domain of the organization that wrote this application      The value is used by the QSettings class when it is constructed     using the empty constructor. This saves having to repeat this     information each time a QSettings object is created.      On Mac, QSettings uses organizationDomain() as the organization     if it's not an empty string; otherwise it uses organizationName().     On all other platforms, QSettings uses organizationName() as the     organization.      \sa organizationName, applicationName, applicationVersion */
end_comment
begin_function
DECL|function|setOrganizationDomain
name|void
name|QCoreApplication
operator|::
name|setOrganizationDomain
parameter_list|(
specifier|const
name|QString
modifier|&
name|orgDomain
parameter_list|)
block|{
name|coreappdata
argument_list|()
operator|->
name|orgDomain
operator|=
name|orgDomain
expr_stmt|;
block|}
end_function
begin_function
DECL|function|organizationDomain
name|QString
name|QCoreApplication
operator|::
name|organizationDomain
parameter_list|()
block|{
return|return
name|coreappdata
argument_list|()
operator|->
name|orgDomain
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCoreApplication::applicationName     \brief the name of this application      The value is used by the QSettings class when it is constructed     using the empty constructor. This saves having to repeat this     information each time a QSettings object is created.      If not set, the application name defaults to the executable name (since 5.0).      \sa organizationName, organizationDomain, applicationVersion, applicationFilePath */
end_comment
begin_function
DECL|function|setApplicationName
name|void
name|QCoreApplication
operator|::
name|setApplicationName
parameter_list|(
specifier|const
name|QString
modifier|&
name|application
parameter_list|)
block|{
name|coreappdata
argument_list|()
operator|->
name|application
operator|=
name|application
expr_stmt|;
block|}
end_function
begin_function
DECL|function|applicationName
name|QString
name|QCoreApplication
operator|::
name|applicationName
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_OS_BLACKBERRY
name|coreappdata
argument_list|()
operator|->
name|loadManifest
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QString
name|appname
init|=
name|coreappdata
argument_list|()
condition|?
name|coreappdata
argument_list|()
operator|->
name|application
else|:
name|QString
argument_list|()
decl_stmt|;
if|if
condition|(
name|appname
operator|.
name|isEmpty
argument_list|()
operator|&&
name|QCoreApplication
operator|::
name|self
condition|)
name|appname
operator|=
name|QCoreApplication
operator|::
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|appName
argument_list|()
expr_stmt|;
return|return
name|appname
return|;
block|}
end_function
begin_comment
comment|// Exported for QDesktopServices (Qt4 behavior compatibility)
end_comment
begin_function
DECL|function|qt_applicationName_noFallback
name|Q_CORE_EXPORT
name|QString
name|qt_applicationName_noFallback
parameter_list|()
block|{
return|return
name|coreappdata
argument_list|()
operator|->
name|application
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCoreApplication::applicationVersion     \since 4.4     \brief the version of this application      \sa applicationName, organizationName, organizationDomain */
end_comment
begin_function
DECL|function|setApplicationVersion
name|void
name|QCoreApplication
operator|::
name|setApplicationVersion
parameter_list|(
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
block|{
name|coreappdata
argument_list|()
operator|->
name|applicationVersion
operator|=
name|version
expr_stmt|;
block|}
end_function
begin_function
DECL|function|applicationVersion
name|QString
name|QCoreApplication
operator|::
name|applicationVersion
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_OS_BLACKBERRY
name|coreappdata
argument_list|()
operator|->
name|loadManifest
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|coreappdata
argument_list|()
operator|->
name|applicationVersion
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
end_ifndef
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|QMutex
argument_list|,
argument|libraryPathMutex
argument_list|,
argument|(QMutex::Recursive)
argument_list|)
end_macro
begin_comment
comment|/*!     Returns a list of paths that the application will search when     dynamically loading libraries.      Qt provides default library paths, but they can also be set using     a \l{Using qt.conf}{qt.conf} file. Paths specified in this file     will override default values.      This list will include the installation directory for plugins if     it exists (the default installation directory for plugins is \c     INSTALL/plugins, where \c INSTALL is the directory where Qt was     installed).  The directory of the application executable (NOT the     working directory) is always added, as well as the colon separated     entries of the QT_PLUGIN_PATH environment variable.      If you want to iterate over the list, you can use the \l foreach     pseudo-keyword:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 2      \sa setLibraryPaths(), addLibraryPath(), removeLibraryPath(), QLibrary,         {How to Create Qt Plugins} */
end_comment
begin_function
DECL|function|libraryPaths
name|QStringList
name|QCoreApplication
operator|::
name|libraryPaths
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
name|libraryPathMutex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
condition|)
block|{
name|QStringList
modifier|*
name|app_libpaths
init|=
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|=
operator|new
name|QStringList
decl_stmt|;
name|QString
name|installPathPlugins
init|=
name|QLibraryInfo
operator|::
name|location
argument_list|(
name|QLibraryInfo
operator|::
name|PluginsPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|installPathPlugins
argument_list|)
condition|)
block|{
comment|// Make sure we convert from backslashes to slashes.
name|installPathPlugins
operator|=
name|QDir
argument_list|(
name|installPathPlugins
argument_list|)
operator|.
name|canonicalPath
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|app_libpaths
operator|->
name|contains
argument_list|(
name|installPathPlugins
argument_list|)
condition|)
name|app_libpaths
operator|->
name|append
argument_list|(
name|installPathPlugins
argument_list|)
expr_stmt|;
block|}
comment|// If QCoreApplication is not yet instantiated,
comment|// make sure we add the application path when we construct the QCoreApplication
if|if
condition|(
name|self
condition|)
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|appendApplicationPathToLibraryPaths
argument_list|()
expr_stmt|;
specifier|const
name|QByteArray
name|libPathEnv
init|=
name|qgetenv
argument_list|(
literal|"QT_PLUGIN_PATH"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|libPathEnv
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|QLatin1Char
name|pathSep
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
else|#
directive|else
name|QLatin1Char
name|pathSep
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|QStringList
name|paths
init|=
name|QFile
operator|::
name|decodeName
argument_list|(
name|libPathEnv
argument_list|)
operator|.
name|split
argument_list|(
name|pathSep
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|const_iterator
name|it
init|=
name|paths
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|paths
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QString
name|canonicalPath
init|=
name|QDir
argument_list|(
operator|*
name|it
argument_list|)
operator|.
name|canonicalPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|canonicalPath
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|app_libpaths
operator|->
name|contains
argument_list|(
name|canonicalPath
argument_list|)
condition|)
block|{
name|app_libpaths
operator|->
name|append
argument_list|(
name|canonicalPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|*
operator|(
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!      Sets the list of directories to search when loading libraries to     \a paths. All existing paths will be deleted and the path list     will consist of the paths given in \a paths.      \sa libraryPaths(), addLibraryPath(), removeLibraryPath(), QLibrary  */
end_comment
begin_function
DECL|function|setLibraryPaths
name|void
name|QCoreApplication
operator|::
name|setLibraryPaths
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|paths
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
name|libraryPathMutex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
condition|)
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|=
operator|new
name|QStringList
expr_stmt|;
operator|*
operator|(
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|)
operator|=
name|paths
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QFactoryLoader
operator|::
name|refreshAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Prepends \a path to the beginning of the library path list, ensuring that   it is searched for libraries first. If \a path is empty or already in the   path list, the path list is not changed.    The default path list consists of a single entry, the installation   directory for plugins.  The default installation directory for plugins   is \c INSTALL/plugins, where \c INSTALL is the directory where Qt was   installed.    \sa removeLibraryPath(), libraryPaths(), setLibraryPaths()  */
end_comment
begin_function
DECL|function|addLibraryPath
name|void
name|QCoreApplication
operator|::
name|addLibraryPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QMutexLocker
name|locker
argument_list|(
name|libraryPathMutex
argument_list|()
argument_list|)
decl_stmt|;
comment|// make sure that library paths is initialized
name|libraryPaths
argument_list|()
expr_stmt|;
name|QString
name|canonicalPath
init|=
name|QDir
argument_list|(
name|path
argument_list|)
operator|.
name|canonicalPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|canonicalPath
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|->
name|contains
argument_list|(
name|canonicalPath
argument_list|)
condition|)
block|{
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|->
name|prepend
argument_list|(
name|canonicalPath
argument_list|)
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QFactoryLoader
operator|::
name|refreshAll
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Removes \a path from the library path list. If \a path is empty or not     in the path list, the list is not changed.      \sa addLibraryPath(), libraryPaths(), setLibraryPaths() */
end_comment
begin_function
DECL|function|removeLibraryPath
name|void
name|QCoreApplication
operator|::
name|removeLibraryPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QMutexLocker
name|locker
argument_list|(
name|libraryPathMutex
argument_list|()
argument_list|)
decl_stmt|;
comment|// make sure that library paths is initialized
name|libraryPaths
argument_list|()
expr_stmt|;
name|QString
name|canonicalPath
init|=
name|QDir
argument_list|(
name|path
argument_list|)
operator|.
name|canonicalPath
argument_list|()
decl_stmt|;
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|->
name|removeAll
argument_list|(
name|canonicalPath
argument_list|)
expr_stmt|;
name|QFactoryLoader
operator|::
name|refreshAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_LIBRARY
end_comment
begin_comment
comment|/*!     Installs an event filter \a filterObj for all native events     received by the application in the main thread.      The event filter \a filterObj receives events via its nativeEventFilter()     function, which is called for all native events received in the main thread.      The nativeEventFilter() function should return true if the event should     be filtered, (i.e. stopped). It should return false to allow     normal Qt processing to continue: the native event can then be translated     into a QEvent and handled by the standard Qt \l{QEvent} {event} filtering,     e.g. QObject::installEventFilter().      If multiple event filters are installed, the filter that was     installed last is activated first.      \note The filter function set here receives native messages,     i.e. MSG or XCB event structs.      For maximum portability, you should always try to use QEvents     and QObject::installEventFilter() whenever possible.      \sa QObject::installEventFilter()      \since 5.0 */
end_comment
begin_function
DECL|function|installNativeEventFilter
name|void
name|QCoreApplication
operator|::
name|installNativeEventFilter
parameter_list|(
name|QAbstractNativeEventFilter
modifier|*
name|filterObj
parameter_list|)
block|{
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
init|=
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|(
name|QCoreApplicationPrivate
operator|::
name|theMainThread
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|filterObj
operator|||
operator|!
name|eventDispatcher
condition|)
return|return;
name|eventDispatcher
operator|->
name|installNativeEventFilter
argument_list|(
name|filterObj
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes an event filter object \a obj from this object. The     request is ignored if such an event filter has not been installed.      All event filters for this object are automatically removed when     this object is destroyed.      It is always safe to remove an event filter, even during event     filter activation (i.e. from the nativeEventFilter() function).      \sa installNativeEventFilter()     \since 5.0 */
end_comment
begin_function
DECL|function|removeNativeEventFilter
name|void
name|QCoreApplication
operator|::
name|removeNativeEventFilter
parameter_list|(
name|QAbstractNativeEventFilter
modifier|*
name|filterObj
parameter_list|)
block|{
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
init|=
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|filterObj
operator|||
operator|!
name|eventDispatcher
condition|)
return|return;
name|eventDispatcher
operator|->
name|removeNativeEventFilter
argument_list|(
name|filterObj
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function returns true if there are pending events; otherwise     returns false. Pending events can be either from the window     system or posted events using postEvent().      \sa QAbstractEventDispatcher::hasPendingEvents() */
end_comment
begin_function
DECL|function|hasPendingEvents
name|bool
name|QCoreApplication
operator|::
name|hasPendingEvents
parameter_list|()
block|{
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
init|=
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
name|eventDispatcher
condition|)
return|return
name|eventDispatcher
operator|->
name|hasPendingEvents
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the event dispatcher object for the main thread. If no     event dispatcher exists for the thread, this function returns 0. */
end_comment
begin_function
DECL|function|eventDispatcher
name|QAbstractEventDispatcher
modifier|*
name|QCoreApplication
operator|::
name|eventDispatcher
parameter_list|()
block|{
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|theMainThread
condition|)
return|return
name|QCoreApplicationPrivate
operator|::
name|theMainThread
operator|->
name|eventDispatcher
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the event dispatcher for the main thread to \a eventDispatcher. This     is only possible as long as there is no event dispatcher installed yet. That     is, before QCoreApplication has been instantiated. This method takes     ownership of the object. */
end_comment
begin_function
DECL|function|setEventDispatcher
name|void
name|QCoreApplication
operator|::
name|setEventDispatcher
parameter_list|(
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
parameter_list|)
block|{
name|QThread
modifier|*
name|mainThread
init|=
name|QCoreApplicationPrivate
operator|::
name|theMainThread
decl_stmt|;
if|if
condition|(
operator|!
name|mainThread
condition|)
name|mainThread
operator|=
name|QThread
operator|::
name|currentThread
argument_list|()
expr_stmt|;
comment|// will also setup theMainThread
name|mainThread
operator|->
name|setEventDispatcher
argument_list|(
name|eventDispatcher
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     \fn void QCoreApplication::watchUnixSignal(int signal, bool watch)     \internal */
end_comment
begin_comment
comment|/*!     \fn void QCoreApplication::unixSignal(int number)     \internal      This signal is emitted whenever a Unix signal is received by the     application. The Unix signal received is specified by its \a number. */
end_comment
begin_comment
comment|/*!     \fn void qAddPostRoutine(QtCleanUpFunction ptr)     \relates QCoreApplication      Adds a global routine that will be called from the QApplication     destructor. This function is normally used to add cleanup routines     for program-wide functionality.      The function specified by \a ptr should take no arguments and should     return nothing. For example:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 4      Note that for an application- or module-wide cleanup,     qAddPostRoutine() is often not suitable. For example, if the     program is split into dynamically loaded modules, the relevant     module may be unloaded long before the QApplication destructor is     called.      For modules and libraries, using a reference-counted     initialization manager or Qt's parent-child deletion mechanism may     be better. Here is an example of a private class that uses the     parent-child mechanism to call a cleanup function at the right     time:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 5      By selecting the right parent object, this can often be made to     clean up the module's data at the right moment. */
end_comment
begin_comment
comment|/*!     \macro Q_DECLARE_TR_FUNCTIONS(context)     \relates QCoreApplication      The Q_DECLARE_TR_FUNCTIONS() macro declares and implements two     translation functions, \c tr() and \c trUtf8(), with these     signatures:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 6      This macro is useful if you want to use QObject::tr() or     QObject::trUtf8() in classes that don't inherit from QObject.      Q_DECLARE_TR_FUNCTIONS() must appear at the very top of the     class definition (before the first \c{public:} or \c{protected:}).     For example:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 7      The \a context parameter is normally the class name, but it can     be any string.      \sa Q_OBJECT, QObject::tr(), QObject::trUtf8() */
end_comment
begin_comment
comment|/*!     \enum QCoreApplication::Type      \value Tty a console application     \value GuiClient a GUI application     \value GuiServer \e{Deprecated.} this value is only left for compatibility. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
