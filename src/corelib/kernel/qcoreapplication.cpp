begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Copyright (C) 2016 Intel Corporation. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_include
include|#
directive|include
file|"qabstracteventdispatcher.h"
end_include
begin_include
include|#
directive|include
file|"qcoreevent.h"
end_include
begin_include
include|#
directive|include
file|"qeventloop.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qcorecmdlineargs_p.h"
end_include
begin_include
include|#
directive|include
file|<qdatastream.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qmutex.h>
end_include
begin_include
include|#
directive|include
file|<private/qloggingregistry_p.h>
end_include
begin_include
include|#
directive|include
file|<qstandardpaths.h>
end_include
begin_include
include|#
directive|include
file|<qtextcodec.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|<qthreadpool.h>
end_include
begin_include
include|#
directive|include
file|<qthreadstorage.h>
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<qelapsedtimer.h>
end_include
begin_include
include|#
directive|include
file|<qlibraryinfo.h>
end_include
begin_include
include|#
directive|include
file|<qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<private/qfactoryloader_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfunctions_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qlocale_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qhooks_p.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_OSX
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qeventdispatcher_cf_p.h"
end_include
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_GLIB
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qeventdispatcher_glib_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qeventdispatcher_unix_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WINRT
end_ifdef
begin_include
include|#
directive|include
file|"qeventdispatcher_winrt_p.h"
end_include
begin_include
include|#
directive|include
file|"qfunctions_winrt.h"
end_include
begin_include
include|#
directive|include
file|<wrl.h>
end_include
begin_include
include|#
directive|include
file|<Windows.ApplicationModel.core.h>
end_include
begin_using
using|using
namespace|namespace
name|ABI
operator|::
name|Windows
operator|::
name|ApplicationModel
operator|::
name|Core
namespace|;
end_using
begin_using
using|using
namespace|namespace
name|Microsoft
operator|::
name|WRL
namespace|;
end_using
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|"qeventdispatcher_win_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QOBJECT
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_MAC
end_ifdef
begin_include
include|#
directive|include
file|"qcore_mac_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|<locale.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_VXWORKS
end_ifdef
begin_include
include|#
directive|include
file|<taskLib.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_class
DECL|class|QMutexUnlocker
class|class
name|QMutexUnlocker
block|{
public|public:
DECL|function|QMutexUnlocker
specifier|inline
specifier|explicit
name|QMutexUnlocker
parameter_list|(
name|QMutex
modifier|*
name|m
parameter_list|)
member_init_list|:
name|mtx
argument_list|(
name|m
argument_list|)
block|{ }
DECL|function|~QMutexUnlocker
specifier|inline
name|~
name|QMutexUnlocker
parameter_list|()
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|function|unlock
specifier|inline
name|void
name|unlock
parameter_list|()
block|{
if|if
condition|(
name|mtx
condition|)
name|mtx
operator|->
name|unlock
argument_list|()
expr_stmt|;
name|mtx
operator|=
literal|0
expr_stmt|;
block|}
private|private:
name|Q_DISABLE_COPY
argument_list|(
argument|QMutexUnlocker
argument_list|)
DECL|member|mtx
name|QMutex
modifier|*
name|mtx
decl_stmt|;
block|}
class|;
end_class
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_function_decl
specifier|extern
name|QString
name|qAppFileName
parameter_list|()
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|QT_VERSION
operator|>=
literal|0x060000
end_if
begin_error
error|#
directive|error
literal|"Bump QCoreApplicatoinPrivate::app_compile_version to 0x060000"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|member|app_compile_version
name|int
name|QCoreApplicationPrivate
operator|::
name|app_compile_version
init|=
literal|0x050000
decl_stmt|;
end_decl_stmt
begin_comment
DECL|member|app_compile_version
comment|//we don't know exactly, but it's at least 5.0.0
end_comment
begin_decl_stmt
DECL|member|setuidAllowed
name|bool
name|QCoreApplicationPrivate
operator|::
name|setuidAllowed
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_MAC
end_ifdef
begin_function
DECL|function|macMenuBarName
name|QString
name|QCoreApplicationPrivate
operator|::
name|macMenuBarName
parameter_list|()
block|{
name|QString
name|bundleName
decl_stmt|;
name|CFTypeRef
name|string
init|=
name|CFBundleGetValueForInfoDictionaryKey
argument_list|(
name|CFBundleGetMainBundle
argument_list|()
argument_list|,
name|CFSTR
argument_list|(
literal|"CFBundleName"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|string
condition|)
name|bundleName
operator|=
name|QCFString
operator|::
name|toQString
argument_list|(
cast|static_cast
argument_list|<
name|CFStringRef
argument_list|>
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bundleName
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|appName
name|QString
name|QCoreApplicationPrivate
operator|::
name|appName
parameter_list|()
specifier|const
block|{
name|QString
name|applicationName
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
name|applicationName
operator|=
name|macMenuBarName
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|applicationName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|argv
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|applicationName
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|p
condition|?
name|p
operator|+
literal|1
else|:
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|applicationName
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|member|cachedApplicationFilePath
name|QString
modifier|*
name|QCoreApplicationPrivate
operator|::
name|cachedApplicationFilePath
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|checkInstance
name|bool
name|QCoreApplicationPrivate
operator|::
name|checkInstance
parameter_list|(
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|bool
name|b
init|=
operator|(
name|QCoreApplication
operator|::
name|self
operator|!=
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|qWarning
argument_list|(
literal|"QApplication::%s: Please instantiate the QApplication object first"
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_function
DECL|function|processCommandLineArguments
name|void
name|QCoreApplicationPrivate
operator|::
name|processCommandLineArguments
parameter_list|()
block|{
name|int
name|j
init|=
name|argc
condition|?
literal|1
else|:
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|argv
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
operator|*
name|argv
index|[
name|i
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
specifier|const
name|char
modifier|*
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
comment|// startsWith("--")
operator|++
name|arg
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"-qmljsdebugger="
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
name|qmljs_debug_arguments
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|arg
operator|+
literal|15
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-qmljsdebugger"
argument_list|)
operator|==
literal|0
operator|&&
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
operator|++
name|i
expr_stmt|;
name|qmljs_debug_arguments
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argv
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|<
name|argc
condition|)
block|{
name|argv
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|argc
operator|=
name|j
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Support for introspection
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_decl_stmt
DECL|variable|qt_signal_spy_callback_set
name|QSignalSpyCallbackSet
name|Q_CORE_EXPORT
name|qt_signal_spy_callback_set
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qt_register_signal_spy_callbacks
name|void
name|qt_register_signal_spy_callbacks
parameter_list|(
specifier|const
name|QSignalSpyCallbackSet
modifier|&
name|callback_set
parameter_list|)
block|{
name|qt_signal_spy_callback_set
operator|=
name|callback_set
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_extern
DECL|function|qt_startup_hook
extern|extern
literal|"C"
name|void
name|Q_CORE_EXPORT
name|qt_startup_hook
parameter_list|()
block|{ }
end_extern
begin_typedef
DECL|typedef|QStartUpFuncList
typedef|typedef
name|QList
argument_list|<
name|QtStartUpFunction
argument_list|>
name|QStartUpFuncList
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QStartUpFuncList
argument_list|,
argument|preRList
argument_list|)
end_macro
begin_typedef
DECL|typedef|QVFuncList
typedef|typedef
name|QList
argument_list|<
name|QtCleanUpFunction
argument_list|>
name|QVFuncList
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QVFuncList
argument_list|,
argument|postRList
argument_list|)
end_macro
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_decl_stmt
DECL|variable|globalPreRoutinesMutex
specifier|static
name|QBasicMutex
name|globalPreRoutinesMutex
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal      Adds a global routine that will be called from the QCoreApplication     constructor. The public API is Q_COREAPP_STARTUP_FUNCTION. */
end_comment
begin_function
DECL|function|qAddPreRoutine
name|void
name|qAddPreRoutine
parameter_list|(
name|QtStartUpFunction
name|p
parameter_list|)
block|{
name|QStartUpFuncList
modifier|*
name|list
init|=
name|preRList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return;
comment|// Due to C++11 parallel dynamic initialization, this can be called
comment|// from multiple threads.
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalPreRoutinesMutex
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
condition|)
name|p
argument_list|()
expr_stmt|;
name|list
operator|->
name|prepend
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// in case QCoreApplication is re-created, see qt_call_pre_routines
block|}
end_function
begin_function
DECL|function|qAddPostRoutine
name|void
name|qAddPostRoutine
parameter_list|(
name|QtCleanUpFunction
name|p
parameter_list|)
block|{
name|QVFuncList
modifier|*
name|list
init|=
name|postRList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return;
name|list
operator|->
name|prepend
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qRemovePostRoutine
name|void
name|qRemovePostRoutine
parameter_list|(
name|QtCleanUpFunction
name|p
parameter_list|)
block|{
name|QVFuncList
modifier|*
name|list
init|=
name|postRList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return;
name|list
operator|->
name|removeAll
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_call_pre_routines
specifier|static
name|void
name|qt_call_pre_routines
parameter_list|()
block|{
name|QStartUpFuncList
modifier|*
name|list
init|=
name|preRList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalPreRoutinesMutex
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|// Unlike qt_call_post_routines, we don't empty the list, because
comment|// Q_COREAPP_STARTUP_FUNCTION is a macro, so the user expects
comment|// the function to be executed every time QCoreApplication is created.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|list
operator|->
name|at
function_decl|(
name|i
function_decl|)
parameter_list|()
function_decl|;
block|}
end_function
begin_function
DECL|function|qt_call_post_routines
name|void
name|Q_CORE_EXPORT
name|qt_call_post_routines
parameter_list|()
block|{
name|QVFuncList
modifier|*
name|list
init|=
literal|0
decl_stmt|;
name|QT_TRY
block|{
name|list
operator|=
name|postRList
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::bad_alloc&
argument_list|)
block|{
comment|// ignore - if we can't allocate a post routine list,
comment|// there's a high probability that there's no post
comment|// routine to be executed :)
block|}
if|if
condition|(
operator|!
name|list
condition|)
return|return;
while|while
condition|(
operator|!
name|list
operator|->
name|isEmpty
argument_list|()
condition|)
operator|(
name|list
operator|->
name|takeFirst
argument_list|()
operator|)
operator|(
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// initialized in qcoreapplication and in qtextstream autotest when setlocale is called.
end_comment
begin_decl_stmt
DECL|variable|qt_locale_initialized
specifier|static
name|bool
name|qt_locale_initialized
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_comment
comment|// app starting up if false
end_comment
begin_decl_stmt
DECL|member|is_app_running
name|bool
name|QCoreApplicationPrivate
operator|::
name|is_app_running
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|// app closing down if true
end_comment
begin_decl_stmt
DECL|member|is_app_closing
name|bool
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qGlobalPostedEventsCount
name|Q_CORE_EXPORT
name|uint
name|qGlobalPostedEventsCount
parameter_list|()
block|{
name|QThreadData
modifier|*
name|currentThreadData
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
return|return
name|currentThreadData
operator|->
name|postEventList
operator|.
name|size
argument_list|()
operator|-
name|currentThreadData
operator|->
name|postEventList
operator|.
name|startOffset
return|;
block|}
end_function
begin_decl_stmt
DECL|member|eventDispatcher
name|QAbstractEventDispatcher
modifier|*
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_decl_stmt
DECL|variable|qt_application_thread_id
name|Qt
operator|::
name|HANDLE
name|qt_application_thread_id
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QOBJECT
end_comment
begin_decl_stmt
DECL|member|self
name|QCoreApplication
modifier|*
name|QCoreApplication
operator|::
name|self
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|attribs
name|uint
name|QCoreApplicationPrivate
operator|::
name|attribs
init|=
operator|(
literal|1
operator|<<
name|Qt
operator|::
name|AA_SynthesizeMouseForUnhandledTouchEvents
operator|)
operator||
operator|(
literal|1
operator|<<
name|Qt
operator|::
name|AA_SynthesizeMouseForUnhandledTabletEvents
operator|)
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|QCoreApplicationData
struct|struct
name|QCoreApplicationData
block|{
name|QCoreApplicationData
parameter_list|()
name|Q_DECL_NOTHROW
block|{
name|applicationNameSet
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|~QCoreApplicationData
name|~
name|QCoreApplicationData
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
comment|// cleanup the QAdoptedThread created for the main() thread
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|theMainThread
condition|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|get2
argument_list|(
name|QCoreApplicationPrivate
operator|::
name|theMainThread
argument_list|)
decl_stmt|;
name|data
operator|->
name|deref
argument_list|()
expr_stmt|;
comment|// deletes the data and the adopted thread
block|}
endif|#
directive|endif
block|}
DECL|member|orgName
DECL|member|orgDomain
name|QString
name|orgName
decl_stmt|,
name|orgDomain
decl_stmt|;
DECL|member|application
name|QString
name|application
decl_stmt|;
comment|// application name, initially from argv[0], can then be modified.
DECL|member|applicationVersion
name|QString
name|applicationVersion
decl_stmt|;
DECL|member|applicationNameSet
name|bool
name|applicationNameSet
decl_stmt|;
comment|// true if setApplicationName was called
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
DECL|member|app_libpaths
name|QScopedPointer
argument_list|<
name|QStringList
argument_list|>
name|app_libpaths
decl_stmt|;
DECL|member|manual_libpaths
name|QScopedPointer
argument_list|<
name|QStringList
argument_list|>
name|manual_libpaths
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QCoreApplicationData
argument_list|,
argument|coreappdata
argument_list|)
end_macro
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_decl_stmt
DECL|variable|quitLockRefEnabled
specifier|static
name|bool
name|quitLockRefEnabled
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
end_if
begin_comment
comment|// Check whether the command line arguments match those passed to main()
end_comment
begin_comment
comment|// by comparing to the global __argv/__argc (MS extension).
end_comment
begin_comment
comment|// Deep comparison is required since argv/argc is rebuilt by WinMain for
end_comment
begin_comment
comment|// GUI apps or when using MinGW due to its globbing.
end_comment
begin_function
DECL|function|isArgvModified
specifier|static
specifier|inline
name|bool
name|isArgvModified
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|__argc
operator|!=
name|argc
operator|||
operator|!
name|__argv
comment|/* wmain() */
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|__argv
operator|==
name|argv
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|argc
condition|;
operator|++
name|a
control|)
block|{
if|if
condition|(
name|argv
index|[
name|a
index|]
operator|!=
name|__argv
index|[
name|a
index|]
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
name|a
index|]
argument_list|,
name|__argv
index|[
name|a
index|]
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|contains
specifier|static
specifier|inline
name|bool
name|contains
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|needle
parameter_list|)
block|{
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|argc
condition|;
operator|++
name|a
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|a
index|]
argument_list|,
name|needle
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_OS_WIN&& !Q_OS_WINRT
end_comment
begin_constructor
DECL|function|QCoreApplicationPrivate
name|QCoreApplicationPrivate
operator|::
name|QCoreApplicationPrivate
parameter_list|(
name|int
modifier|&
name|aargc
parameter_list|,
name|char
modifier|*
modifier|*
name|aargv
parameter_list|,
name|uint
name|flags
parameter_list|)
member_init_list|:
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|QObjectPrivate
argument_list|()
member_init_list|,
endif|#
directive|endif
name|argc
argument_list|(
name|aargc
argument_list|)
member_init_list|,
name|argv
argument_list|(
name|aargv
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
member_init_list|,
name|origArgc
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|origArgv
argument_list|(
name|Q_NULLPTR
argument_list|)
endif|#
directive|endif
member_init_list|,
name|application_type
argument_list|(
name|QCoreApplicationPrivate
operator|::
name|Tty
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
member_init_list|,
name|in_exec
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|aboutToQuitEmitted
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|threadData_clean
argument_list|(
literal|false
argument_list|)
else|#
directive|else
member_init_list|,
name|q_ptr
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
block|{
name|app_compile_version
operator|=
name|flags
operator|&
literal|0xffffff
expr_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|empty
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|||
name|argv
operator|==
literal|0
condition|)
block|{
name|argc
operator|=
literal|0
expr_stmt|;
name|argv
operator|=
cast|const_cast
argument_list|<
name|char
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|empty
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
if|if
condition|(
operator|!
name|isArgvModified
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
condition|)
block|{
name|origArgc
operator|=
name|argc
expr_stmt|;
name|origArgv
operator|=
operator|new
name|char
operator|*
index|[
name|argc
index|]
expr_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|argv
argument_list|,
name|argv
operator|+
name|argc
argument_list|,
name|QT_MAKE_CHECKED_ARRAY_ITERATOR
argument_list|(
name|origArgv
argument_list|,
name|argc
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Q_OS_WIN&& !Q_OS_WINRT
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
operator|=
literal|false
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
operator|!
name|setuidAllowed
operator|&&
operator|(
name|geteuid
argument_list|()
operator|!=
name|getuid
argument_list|()
operator|)
argument_list|)
condition|)
name|qFatal
argument_list|(
literal|"FATAL: The application binary appears to be running setuid, this is a security hole."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Q_OS_UNIX
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|qt_application_thread_id
operator|=
name|QThread
operator|::
name|currentThreadId
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QThread
modifier|*
name|cur
init|=
name|QThread
operator|::
name|currentThread
argument_list|()
decl_stmt|;
comment|// note: this may end up setting theMainThread!
if|if
condition|(
name|cur
operator|!=
name|theMainThread
condition|)
name|qWarning
argument_list|(
literal|"WARNING: QApplication was not created in the main() thread."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_destructor
DECL|function|~QCoreApplicationPrivate
name|QCoreApplicationPrivate
operator|::
name|~
name|QCoreApplicationPrivate
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|cleanupThreadData
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
operator|delete
index|[]
name|origArgv
expr_stmt|;
endif|#
directive|endif
name|QCoreApplicationPrivate
operator|::
name|clearApplicationFilePath
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_function
DECL|function|cleanupThreadData
name|void
name|QCoreApplicationPrivate
operator|::
name|cleanupThreadData
parameter_list|()
block|{
if|if
condition|(
name|threadData
operator|&&
operator|!
name|threadData_clean
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|void
modifier|*
name|data
init|=
operator|&
name|threadData
operator|->
name|tls
decl_stmt|;
name|QThreadStorageData
operator|::
name|finish
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// need to clear the state of the mainData, just in case a new QCoreApplication comes along.
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|threadData
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threadData
operator|->
name|postEventList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|pe
init|=
name|threadData
operator|->
name|postEventList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|pe
operator|.
name|event
condition|)
block|{
operator|--
name|pe
operator|.
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|pe
operator|.
name|event
operator|->
name|posted
operator|=
literal|false
expr_stmt|;
operator|delete
name|pe
operator|.
name|event
expr_stmt|;
block|}
block|}
name|threadData
operator|->
name|postEventList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|threadData
operator|->
name|postEventList
operator|.
name|recursion
operator|=
literal|0
expr_stmt|;
name|threadData
operator|->
name|quitNow
operator|=
literal|false
expr_stmt|;
name|threadData_clean
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|createEventDispatcher
name|void
name|QCoreApplicationPrivate
operator|::
name|createEventDispatcher
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QCoreApplication
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_OSX
argument_list|)
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|int
name|value
init|=
name|qEnvironmentVariableIntValue
argument_list|(
literal|"QT_EVENT_DISPATCHER_CORE_FOUNDATION"
argument_list|,
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
operator|&&
name|value
operator|>
literal|0
condition|)
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherCoreFoundation
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherUNIX
argument_list|(
name|q
argument_list|)
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|QT_NO_GLIB
argument_list|)
if|if
condition|(
name|qEnvironmentVariableIsEmpty
argument_list|(
literal|"QT_NO_GLIB"
argument_list|)
operator|&&
name|QEventDispatcherGlib
operator|::
name|versionSupported
argument_list|()
condition|)
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherGlib
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherUNIX
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|#
directive|else
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherUNIX
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherWinRT
argument_list|(
name|q
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|eventDispatcher
operator|=
operator|new
name|QEventDispatcherWin32
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"QEventDispatcher not yet ported to this platform"
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|eventDispatcherReady
name|void
name|QCoreApplicationPrivate
operator|::
name|eventDispatcherReady
parameter_list|()
block|{ }
end_function
begin_decl_stmt
DECL|member|theMainThread
name|QBasicAtomicPointer
argument_list|<
name|QThread
argument_list|>
name|QCoreApplicationPrivate
operator|::
name|theMainThread
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|mainThread
name|QThread
modifier|*
name|QCoreApplicationPrivate
operator|::
name|mainThread
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|theMainThread
operator|.
name|load
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|theMainThread
operator|.
name|load
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|threadRequiresCoreApplication
name|bool
name|QCoreApplicationPrivate
operator|::
name|threadRequiresCoreApplication
parameter_list|()
block|{
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
literal|true
return|;
comment|// default setting
return|return
name|data
operator|->
name|requiresCoreApplication
return|;
block|}
end_function
begin_function
DECL|function|checkReceiverThread
name|void
name|QCoreApplicationPrivate
operator|::
name|checkReceiverThread
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|)
block|{
name|QThread
modifier|*
name|currentThread
init|=
name|QThread
operator|::
name|currentThread
argument_list|()
decl_stmt|;
name|QThread
modifier|*
name|thr
init|=
name|receiver
operator|->
name|thread
argument_list|()
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|currentThread
operator|==
name|thr
operator|||
operator|!
name|thr
argument_list|,
literal|"QCoreApplication::sendEvent"
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Cannot send events to objects owned by a different thread. "
literal|"Current thread %1. Receiver '%2' (of type '%3') was created in thread %4"
argument_list|)
operator|.
name|arg
argument_list|(
name|QString
operator|::
name|number
argument_list|(
operator|(
name|quintptr
operator|)
name|currentThread
argument_list|,
literal|16
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|receiver
operator|->
name|objectName
argument_list|()
argument_list|)
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|QString
operator|::
name|number
argument_list|(
operator|(
name|quintptr
operator|)
name|thr
argument_list|,
literal|16
argument_list|)
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|currentThread
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|thr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QOBJECT
end_comment
begin_function
DECL|function|appendApplicationPathToLibraryPaths
name|void
name|QCoreApplicationPrivate
operator|::
name|appendApplicationPathToLibraryPaths
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
name|QStringList
modifier|*
name|app_libpaths
init|=
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|app_libpaths
condition|)
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|.
name|reset
argument_list|(
name|app_libpaths
operator|=
operator|new
name|QStringList
argument_list|)
expr_stmt|;
name|QString
name|app_location
init|=
name|QCoreApplication
operator|::
name|applicationFilePath
argument_list|()
decl_stmt|;
name|app_location
operator|.
name|truncate
argument_list|(
name|app_location
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WINRT
if|if
condition|(
name|app_location
operator|.
name|isEmpty
argument_list|()
condition|)
name|app_location
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|app_location
operator|=
name|QDir
argument_list|(
name|app_location
argument_list|)
operator|.
name|canonicalPath
argument_list|()
expr_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|app_location
argument_list|)
operator|&&
operator|!
name|app_libpaths
operator|->
name|contains
argument_list|(
name|app_location
argument_list|)
condition|)
name|app_libpaths
operator|->
name|append
argument_list|(
name|app_location
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|qAppName
name|QString
name|qAppName
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"qAppName"
argument_list|)
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|appName
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|initLocale
name|void
name|QCoreApplicationPrivate
operator|::
name|initLocale
parameter_list|()
block|{
if|if
condition|(
name|qt_locale_initialized
condition|)
return|return;
name|qt_locale_initialized
operator|=
literal|true
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \class QCoreApplication     \inmodule QtCore     \brief The QCoreApplication class provides an event loop for Qt     applications without UI.      This class is used by non-GUI applications to provide their event     loop. For non-GUI application that uses Qt, there should be exactly     one QCoreApplication object. For GUI applications, see     QGuiApplication. For applications that use the Qt Widgets module,     see QApplication.      QCoreApplication contains the main event loop, where all events     from the operating system (e.g., timer and network events) and     other sources are processed and dispatched. It also handles the     application's initialization and finalization, as well as     system-wide and application-wide settings.      \section1 The Event Loop and Event Handling      The event loop is started with a call to exec(). Long-running     operations can call processEvents() to keep the application     responsive.      In general, we recommend that you create a QCoreApplication,     QGuiApplication or a QApplication object in your \c main()     function as early as possible. exec() will not return until     the event loop exits; e.g., when quit() is called.      Several static convenience functions are also provided. The     QCoreApplication object is available from instance(). Events can     be sent or posted using sendEvent(), postEvent(), and     sendPostedEvents(). Pending events can be removed with     removePostedEvents() or flushed with flush().      The class provides a quit() slot and an aboutToQuit() signal.      \section1 Application and Library Paths      An application has an applicationDirPath() and an     applicationFilePath(). Library paths (see QLibrary) can be retrieved     with libraryPaths() and manipulated by setLibraryPaths(), addLibraryPath(),     and removeLibraryPath().      \section1 Internationalization and Translations      Translation files can be added or removed     using installTranslator() and removeTranslator(). Application     strings can be translated using translate(). The QObject::tr()     and QObject::trUtf8() functions are implemented in terms of     translate().      \section1 Accessing Command Line Arguments      The command line arguments which are passed to QCoreApplication's     constructor should be accessed using the arguments() function.      \note QCoreApplication removes option \c -qmljsdebugger="...". It parses the     argument of \c qmljsdebugger, and then removes this option plus its argument.      For more advanced command line option handling, create a QCommandLineParser.      \section1 Locale Settings      On Unix/Linux Qt is configured to use the system locale settings by     default. This can cause a conflict when using POSIX functions, for     instance, when converting between data types such as floats and     strings, since the notation may differ between locales. To get     around this problem, call the POSIX function \c{setlocale(LC_NUMERIC,"C")}     right after initializing QApplication, QGuiApplication or QCoreApplication     to reset the locale that is used for number formatting to "C"-locale.      \sa QGuiApplication, QAbstractEventDispatcher, QEventLoop,     {Semaphores Example}, {Wait Conditions Example} */
end_comment
begin_comment
comment|/*!     \fn static QCoreApplication *QCoreApplication::instance()      Returns a pointer to the application's QCoreApplication (or     QGuiApplication/QApplication) instance.      If no instance has been allocated, \c null is returned. */
end_comment
begin_comment
comment|/*!     \internal  */
end_comment
begin_constructor
DECL|function|QCoreApplication
name|QCoreApplication
operator|::
name|QCoreApplication
parameter_list|(
name|QCoreApplicationPrivate
modifier|&
name|p
parameter_list|)
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
member_init_list|:
name|d_ptr
argument_list|(
operator|&
name|p
argument_list|)
else|#
directive|else
member_init_list|:
name|QObject
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
endif|#
directive|endif
block|{
name|d_func
argument_list|()
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
comment|// note: it is the subclasses' job to call
comment|// QCoreApplicationPrivate::eventDispatcher->startingUp();
block|}
end_constructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_comment
comment|/*!     Flushes the platform-specific event queues.      If you are doing graphical changes inside a loop that does not     return to the event loop on asynchronous window systems like X11     or double buffered window systems like Quartz (OS X and iOS), and you want to     visualize these changes immediately (e.g. Splash Screens), call     this function.      \sa sendPostedEvents() */
end_comment
begin_function
DECL|function|flush
name|void
name|QCoreApplication
operator|::
name|flush
parameter_list|()
block|{
if|if
condition|(
name|self
operator|&&
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|eventDispatcher
condition|)
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|eventDispatcher
operator|->
name|flush
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Constructs a Qt core application. Core applications are applications without     a graphical user interface. Such applications are used at the console or as     server processes.      The \a argc and \a argv arguments are processed by the application,     and made available in a more convenient form by the arguments()     function.      \warning The data referred to by \a argc and \a argv must stay valid     for the entire lifetime of the QCoreApplication object. In addition,     \a argc must be greater than zero and \a argv must contain at least     one valid character string. */
end_comment
begin_constructor
DECL|function|QCoreApplication
name|QCoreApplication
operator|::
name|QCoreApplication
parameter_list|(
name|int
modifier|&
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
ifndef|#
directive|ifndef
name|Q_QDOC
parameter_list|,
name|int
name|_internal
endif|#
directive|endif
parameter_list|)
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QCoreApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|_internal
argument_list|)
argument_list|)
else|#
directive|else
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QCoreApplicationPrivate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|_internal
argument_list|)
argument_list|)
endif|#
directive|endif
block|{
name|d_func
argument_list|()
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|init
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|startingUp
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_function
DECL|function|init
name|void
name|QCoreApplicationPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QCoreApplication
argument_list|)
expr_stmt|;
name|initLocale
argument_list|()
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
operator|!
name|QCoreApplication
operator|::
name|self
argument_list|,
literal|"QCoreApplication"
argument_list|,
literal|"there should be only one application object"
argument_list|)
expr_stmt|;
name|QCoreApplication
operator|::
name|self
operator|=
name|q
expr_stmt|;
comment|// Store app name (so it's still available after QCoreApplication is destroyed)
if|if
condition|(
operator|!
name|coreappdata
argument_list|()
operator|->
name|applicationNameSet
condition|)
name|coreappdata
argument_list|()
operator|->
name|application
operator|=
name|appName
argument_list|()
expr_stmt|;
name|QLoggingRegistry
operator|::
name|instance
argument_list|()
operator|->
name|init
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
comment|// Reset the lib paths, so that they will be recomputed, taking the availability of argv[0]
comment|// into account. If necessary, recompute right away and replay the manual changes on top of the
comment|// new lib paths.
name|QStringList
modifier|*
name|appPaths
init|=
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|.
name|take
argument_list|()
decl_stmt|;
name|QStringList
modifier|*
name|manualPaths
init|=
name|coreappdata
argument_list|()
operator|->
name|manual_libpaths
operator|.
name|take
argument_list|()
decl_stmt|;
if|if
condition|(
name|appPaths
condition|)
block|{
if|if
condition|(
name|manualPaths
condition|)
block|{
comment|// Replay the delta. As paths can only be prepended to the front or removed from
comment|// anywhere in the list, we can just linearly scan the lists and find the items that
comment|// have been removed. Once the original list is exhausted we know all the remaining
comment|// items have been added.
name|QStringList
name|newPaths
argument_list|(
name|q
operator|->
name|libraryPaths
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|manualPaths
operator|->
name|length
argument_list|()
init|,
name|j
init|=
name|appPaths
operator|->
name|length
argument_list|()
init|;
name|i
operator|>
literal|0
operator|||
name|j
operator|>
literal|0
condition|;
name|qt_noop
argument_list|()
control|)
block|{
if|if
condition|(
operator|--
name|j
operator|<
literal|0
condition|)
block|{
name|newPaths
operator|.
name|prepend
argument_list|(
operator|(
operator|*
name|manualPaths
operator|)
index|[
operator|--
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
block|{
name|newPaths
operator|.
name|removeAll
argument_list|(
operator|(
operator|*
name|appPaths
operator|)
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|manualPaths
operator|)
index|[
name|i
index|]
operator|!=
operator|(
operator|*
name|appPaths
operator|)
index|[
name|j
index|]
condition|)
block|{
name|newPaths
operator|.
name|removeAll
argument_list|(
operator|(
operator|*
name|appPaths
operator|)
index|[
name|j
index|]
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
comment|// try again with next item.
block|}
block|}
operator|delete
name|manualPaths
expr_stmt|;
name|coreappdata
argument_list|()
operator|->
name|manual_libpaths
operator|.
name|reset
argument_list|(
operator|new
name|QStringList
argument_list|(
name|newPaths
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|delete
name|appPaths
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
comment|// use the event dispatcher created by the app programmer (if any)
if|if
condition|(
operator|!
name|eventDispatcher
condition|)
name|eventDispatcher
operator|=
name|threadData
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
expr_stmt|;
comment|// otherwise we create one
if|if
condition|(
operator|!
name|eventDispatcher
condition|)
name|createEventDispatcher
argument_list|()
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|eventDispatcher
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eventDispatcher
operator|->
name|parent
argument_list|()
condition|)
block|{
name|eventDispatcher
operator|->
name|moveToThread
argument_list|(
name|threadData
operator|->
name|thread
argument_list|)
expr_stmt|;
name|eventDispatcher
operator|->
name|setParent
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|threadData
operator|->
name|eventDispatcher
operator|=
name|eventDispatcher
expr_stmt|;
name|eventDispatcherReady
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_EVAL
specifier|extern
name|void
name|qt_core_eval_init
argument_list|(
name|QCoreApplicationPrivate
operator|::
name|Type
argument_list|)
decl_stmt|;
name|qt_core_eval_init
argument_list|(
name|application_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|processCommandLineArguments
argument_list|()
expr_stmt|;
name|qt_call_pre_routines
argument_list|()
expr_stmt|;
name|qt_startup_hook
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|qtHookData
index|[
name|QHooks
operator|::
name|Startup
index|]
argument_list|)
condition|)
cast|reinterpret_cast
argument_list|<
name|QHooks
operator|::
name|StartupCallback
argument_list|>
argument_list|(
name|qtHookData
index|[
name|QHooks
operator|::
name|Startup
index|]
argument_list|)
operator|(
operator|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|is_app_running
operator|=
literal|true
expr_stmt|;
comment|// No longer starting up.
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Destroys the QCoreApplication object. */
end_comment
begin_destructor
DECL|function|~QCoreApplication
name|QCoreApplication
operator|::
name|~
name|QCoreApplication
parameter_list|()
block|{
name|qt_call_post_routines
argument_list|()
expr_stmt|;
name|self
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
operator|=
literal|true
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|is_app_running
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
comment|// Synchronize and stop the global thread pool threads.
name|QThreadPool
modifier|*
name|globalThreadPool
init|=
literal|0
decl_stmt|;
name|QT_TRY
block|{
name|globalThreadPool
operator|=
name|QThreadPool
operator|::
name|globalInstance
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// swallow the exception, since destructors shouldn't throw
block|}
if|if
condition|(
name|globalThreadPool
condition|)
name|globalThreadPool
operator|->
name|waitForDone
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|d_func
argument_list|()
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
condition|)
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|->
name|closingDown
argument_list|()
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|eventDispatcher
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|.
name|reset
argument_list|()
expr_stmt|;
name|coreappdata
argument_list|()
operator|->
name|manual_libpaths
operator|.
name|reset
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_comment
comment|/*!     \since 5.3      Allows the application to run setuid on UNIX platforms if \a allow     is true.      If \a allow is false (the default) and Qt detects the application is     running with an effective user id different than the real user id,     the application will be aborted when a QCoreApplication instance is     created.      Qt is not an appropriate solution for setuid programs due to its     large attack surface. However some applications may be required     to run in this manner for historical reasons. This flag will     prevent Qt from aborting the application when this is detected,     and must be set before a QCoreApplication instance is created.      \note It is strongly recommended not to enable this option since     it introduces security risks. */
end_comment
begin_function
DECL|function|setSetuidAllowed
name|void
name|QCoreApplication
operator|::
name|setSetuidAllowed
parameter_list|(
name|bool
name|allow
parameter_list|)
block|{
name|QCoreApplicationPrivate
operator|::
name|setuidAllowed
operator|=
name|allow
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.3      Returns true if the application is allowed to run setuid on UNIX     platforms.      \sa QCoreApplication::setSetuidAllowed() */
end_comment
begin_function
DECL|function|isSetuidAllowed
name|bool
name|QCoreApplication
operator|::
name|isSetuidAllowed
parameter_list|()
block|{
return|return
name|QCoreApplicationPrivate
operator|::
name|setuidAllowed
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the attribute \a attribute if \a on is true;     otherwise clears the attribute.      \sa testAttribute() */
end_comment
begin_function
DECL|function|setAttribute
name|void
name|QCoreApplication
operator|::
name|setAttribute
parameter_list|(
name|Qt
operator|::
name|ApplicationAttribute
name|attribute
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
if|if
condition|(
name|on
condition|)
name|QCoreApplicationPrivate
operator|::
name|attribs
operator||=
literal|1
operator|<<
name|attribute
expr_stmt|;
else|else
name|QCoreApplicationPrivate
operator|::
name|attribs
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|attribute
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns \c true if attribute \a attribute is set;   otherwise returns \c false.    \sa setAttribute()  */
end_comment
begin_function
DECL|function|testAttribute
name|bool
name|QCoreApplication
operator|::
name|testAttribute
parameter_list|(
name|Qt
operator|::
name|ApplicationAttribute
name|attribute
parameter_list|)
block|{
return|return
name|QCoreApplicationPrivate
operator|::
name|testAttribute
argument_list|(
name|attribute
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_comment
comment|/*!     \property QCoreApplication::quitLockEnabled      \brief Whether the use of the QEventLoopLocker feature can cause the     application to quit.      The default is \c true.      \sa QEventLoopLocker */
end_comment
begin_function
DECL|function|isQuitLockEnabled
name|bool
name|QCoreApplication
operator|::
name|isQuitLockEnabled
parameter_list|()
block|{
return|return
name|quitLockRefEnabled
return|;
block|}
end_function
begin_function_decl
specifier|static
name|bool
name|doNotify
parameter_list|(
name|QObject
modifier|*
parameter_list|,
name|QEvent
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|setQuitLockEnabled
name|void
name|QCoreApplication
operator|::
name|setQuitLockEnabled
parameter_list|(
name|bool
name|enabled
parameter_list|)
block|{
name|quitLockRefEnabled
operator|=
name|enabled
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   \deprecated    This function is here to make it possible for Qt extensions to   hook into event notification without subclassing QApplication */
end_comment
begin_function
DECL|function|notifyInternal
name|bool
name|QCoreApplication
operator|::
name|notifyInternal
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
return|return
name|notifyInternal2
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal   \since 5.6    This function is here to make it possible for Qt extensions to   hook into event notification without subclassing QApplication. */
end_comment
begin_function
DECL|function|notifyInternal2
name|bool
name|QCoreApplication
operator|::
name|notifyInternal2
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
name|bool
name|selfRequired
init|=
name|QCoreApplicationPrivate
operator|::
name|threadRequiresCoreApplication
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|self
operator|&&
name|selfRequired
condition|)
return|return
literal|false
return|;
comment|// Make it possible for Qt Script to hook into events even
comment|// though QApplication is subclassed...
name|bool
name|result
init|=
literal|false
decl_stmt|;
name|void
modifier|*
name|cbdata
index|[]
init|=
block|{
name|receiver
block|,
name|event
block|,
operator|&
name|result
block|}
decl_stmt|;
if|if
condition|(
name|QInternal
operator|::
name|activateCallbacks
argument_list|(
name|QInternal
operator|::
name|EventNotifyCallback
argument_list|,
name|cbdata
argument_list|)
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Qt enforces the rule that events can only be sent to objects in
comment|// the current thread, so receiver->d_func()->threadData is
comment|// equivalent to QThreadData::current(), just without the function
comment|// call overhead.
name|QObjectPrivate
modifier|*
name|d
init|=
name|receiver
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|QThreadData
modifier|*
name|threadData
init|=
name|d
operator|->
name|threadData
decl_stmt|;
name|QScopedScopeLevelCounter
name|scopeLevelCounter
argument_list|(
name|threadData
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|selfRequired
condition|)
return|return
name|doNotify
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
return|;
return|return
name|self
operator|->
name|notify
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Sends \a event to \a receiver: \a {receiver}->event(\a event).   Returns the value that is returned from the receiver's event   handler. Note that this function is called for all events sent to   any object in any thread.    For certain types of events (e.g. mouse and key events),   the event will be propagated to the receiver's parent and so on up to   the top-level object if the receiver is not interested in the event   (i.e., it returns \c false).    There are five different ways that events can be processed;   reimplementing this virtual function is just one of them. All five   approaches are listed below:   \list 1   \li Reimplementing \l {QWidget::}{paintEvent()}, \l {QWidget::}{mousePressEvent()} and so   on. This is the commonest, easiest, and least powerful way.    \li Reimplementing this function. This is very powerful, providing   complete control; but only one subclass can be active at a time.    \li Installing an event filter on QCoreApplication::instance(). Such   an event filter is able to process all events for all widgets, so   it's just as powerful as reimplementing notify(); furthermore, it's   possible to have more than one application-global event filter.   Global event filters even see mouse events for   \l{QWidget::isEnabled()}{disabled widgets}. Note that application   event filters are only called for objects that live in the main   thread.    \li Reimplementing QObject::event() (as QWidget does). If you do   this you get Tab key presses, and you get to see the events before   any widget-specific event filters.    \li Installing an event filter on the object. Such an event filter gets all   the events, including Tab and Shift+Tab key press events, as long as they   do not change the focus widget.   \endlist    \b{Future direction:} This function will not be called for objects that live   outside the main thread in Qt 6. Applications that need that functionality   should find other solutions for their event inspection needs in the meantime.   The change may be extended to the main thread, causing this function to be   deprecated.    \warning If you override this function, you must ensure all threads that   process events stop doing so before your application object begins   destruction. This includes threads started by other libraries that you may be   using, but does not apply to Qt's own threads.    \sa QObject::event(), installNativeEventFilter() */
end_comment
begin_function
DECL|function|notify
name|bool
name|QCoreApplication
operator|::
name|notify
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
comment|// no events are delivered after ~QCoreApplication() has started
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
condition|)
return|return
literal|true
return|;
return|return
name|doNotify
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|doNotify
specifier|static
name|bool
name|doNotify
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|receiver
operator|==
literal|0
condition|)
block|{
comment|// serious error
name|qWarning
argument_list|(
literal|"QCoreApplication::notify: Unexpected null receiver"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|QCoreApplicationPrivate
operator|::
name|checkReceiverThread
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|receiver
operator|->
name|isWidgetType
argument_list|()
condition|?
literal|false
else|:
name|QCoreApplicationPrivate
operator|::
name|notify_helper
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sendThroughApplicationEventFilters
name|bool
name|QCoreApplicationPrivate
operator|::
name|sendThroughApplicationEventFilters
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
comment|// We can't access the application event filters outside of the main thread (race conditions)
name|Q_ASSERT
argument_list|(
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|->
name|thread
operator|==
name|mainThread
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|extraData
condition|)
block|{
comment|// application event filters are only called for objects in the GUI thread
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|extraData
operator|->
name|eventFilters
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QObject
modifier|*
name|obj
init|=
name|extraData
operator|->
name|eventFilters
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
if|if
condition|(
name|obj
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|!=
name|threadData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication: Application event filter cannot be in a different thread."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|obj
operator|->
name|eventFilter
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|sendThroughObjectEventFilters
name|bool
name|QCoreApplicationPrivate
operator|::
name|sendThroughObjectEventFilters
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|receiver
operator|!=
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|&&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|extraData
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|extraData
operator|->
name|eventFilters
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QObject
modifier|*
name|obj
init|=
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|extraData
operator|->
name|eventFilters
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
continue|continue;
if|if
condition|(
name|obj
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|!=
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication: Object event filter cannot be in a different thread."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|obj
operator|->
name|eventFilter
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Helper function called by QCoreApplicationPrivate::notify() and qapplication.cpp  */
end_comment
begin_function
DECL|function|notify_helper
name|bool
name|QCoreApplicationPrivate
operator|::
name|notify_helper
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
comment|// send to all application event filters (only does anything in the main thread)
if|if
condition|(
name|QCoreApplication
operator|::
name|self
operator|&&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|->
name|thread
operator|==
name|mainThread
argument_list|()
operator|&&
name|QCoreApplication
operator|::
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|sendThroughApplicationEventFilters
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// send to all receiver event filters
if|if
condition|(
name|sendThroughObjectEventFilters
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// deliver the event
return|return
name|receiver
operator|->
name|event
argument_list|(
name|event
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns \c true if an application object has not been created yet;   otherwise returns \c false.    \sa closingDown() */
end_comment
begin_function
DECL|function|startingUp
name|bool
name|QCoreApplication
operator|::
name|startingUp
parameter_list|()
block|{
return|return
operator|!
name|QCoreApplicationPrivate
operator|::
name|is_app_running
return|;
block|}
end_function
begin_comment
comment|/*!   Returns \c true if the application objects are being destroyed;   otherwise returns \c false.    \sa startingUp() */
end_comment
begin_function
DECL|function|closingDown
name|bool
name|QCoreApplication
operator|::
name|closingDown
parameter_list|()
block|{
return|return
name|QCoreApplicationPrivate
operator|::
name|is_app_closing
return|;
block|}
end_function
begin_comment
comment|/*!     Processes all pending events for the calling thread according to     the specified \a flags until there are no more events to process.      You can call this function occasionally when your program is busy     performing a long operation (e.g. copying a file).      In the event that you are running a local loop which calls this function     continuously, without an event loop, the     \l{QEvent::DeferredDelete}{DeferredDelete} events will     not be processed. This can affect the behaviour of widgets,     e.g. QToolTip, that rely on \l{QEvent::DeferredDelete}{DeferredDelete}     events to function properly. An alternative would be to call     \l{QCoreApplication::sendPostedEvents()}{sendPostedEvents()} from     within that local loop.      Calling this function processes events only for the calling thread.      \threadsafe      \sa exec(), QTimer, QEventLoop::processEvents(), flush(), sendPostedEvents() */
end_comment
begin_function
DECL|function|processEvents
name|void
name|QCoreApplication
operator|::
name|processEvents
parameter_list|(
name|QEventLoop
operator|::
name|ProcessEventsFlags
name|flags
parameter_list|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|hasEventDispatcher
argument_list|()
condition|)
return|return;
name|data
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
operator|->
name|processEvents
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload processEvents()      Processes pending events for the calling thread for \a maxtime     milliseconds or until there are no more events to process,     whichever is shorter.      You can call this function occasionally when your program is busy     doing a long operation (e.g. copying a file).      Calling this function processes events only for the calling thread.      \threadsafe      \sa exec(), QTimer, QEventLoop::processEvents() */
end_comment
begin_function
DECL|function|processEvents
name|void
name|QCoreApplication
operator|::
name|processEvents
parameter_list|(
name|QEventLoop
operator|::
name|ProcessEventsFlags
name|flags
parameter_list|,
name|int
name|maxtime
parameter_list|)
block|{
comment|// ### Qt 6: consider splitting this method into a public and a private
comment|//           one, so that a user-invoked processEvents can be detected
comment|//           and handled properly.
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|hasEventDispatcher
argument_list|()
condition|)
return|return;
name|QElapsedTimer
name|start
decl_stmt|;
name|start
operator|.
name|start
parameter_list|()
constructor_decl|;
while|while
condition|(
name|data
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
operator|->
name|processEvents
argument_list|(
name|flags
operator|&
operator|~
name|QEventLoop
operator|::
name|WaitForMoreEvents
argument_list|)
condition|)
block|{
if|if
condition|(
name|start
operator|.
name|elapsed
argument_list|()
operator|>
name|maxtime
condition|)
break|break;
block|}
block|}
end_function
begin_comment
comment|/*****************************************************************************   Main event loop wrappers  *****************************************************************************/
end_comment
begin_comment
comment|/*!     Enters the main event loop and waits until exit() is called.  Returns     the value that was passed to exit() (which is 0 if exit() is called via     quit()).      It is necessary to call this function to start event handling. The     main event loop receives events from the window system and     dispatches these to the application widgets.      To make your application perform idle processing (by executing a     special function whenever there are no pending events), use a     QTimer with 0 timeout. More advanced idle processing schemes can     be achieved using processEvents().      We recommend that you connect clean-up code to the     \l{QCoreApplication::}{aboutToQuit()} signal, instead of putting it in     your application's \c{main()} function because on some platforms the     exec() call may not return. For example, on Windows     when the user logs off, the system terminates the process after Qt     closes all top-level windows. Hence, there is no guarantee that the     application will have time to exit its event loop and execute code at     the end of the \c{main()} function after the exec()     call.      \sa quit(), exit(), processEvents(), QApplication::exec() */
end_comment
begin_function
DECL|function|exec
name|int
name|QCoreApplication
operator|::
name|exec
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"exec"
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|QThreadData
modifier|*
name|threadData
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
decl_stmt|;
if|if
condition|(
name|threadData
operator|!=
name|QThreadData
operator|::
name|current
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"%s::exec: Must be called from the main thread"
argument_list|,
name|self
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|threadData
operator|->
name|eventLoops
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::exec: The event loop is already running"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|threadData
operator|->
name|quitNow
operator|=
literal|false
expr_stmt|;
name|QEventLoop
name|eventLoop
decl_stmt|;
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|in_exec
operator|=
literal|true
expr_stmt|;
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|aboutToQuitEmitted
operator|=
literal|false
expr_stmt|;
name|int
name|returnCode
init|=
name|eventLoop
operator|.
name|exec
argument_list|()
decl_stmt|;
name|threadData
operator|->
name|quitNow
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|self
condition|)
block|{
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|in_exec
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|aboutToQuitEmitted
condition|)
emit|emit
name|self
operator|->
name|aboutToQuit
argument_list|(
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|aboutToQuitEmitted
operator|=
literal|true
expr_stmt|;
name|sendPostedEvents
argument_list|(
literal|0
argument_list|,
name|QEvent
operator|::
name|DeferredDelete
argument_list|)
expr_stmt|;
block|}
return|return
name|returnCode
return|;
block|}
end_function
begin_comment
comment|/*!   Tells the application to exit with a return code.      After this function has been called, the application leaves the     main event loop and returns from the call to exec(). The exec()     function returns \a returnCode. If the event loop is not running,     this function does nothing.    By convention, a \a returnCode of 0 means success, and any non-zero   value indicates an error.    Note that unlike the C library function of the same name, this   function \e does return to the caller -- it is event processing that   stops.    \sa quit(), exec() */
end_comment
begin_function
DECL|function|exit
name|void
name|QCoreApplication
operator|::
name|exit
parameter_list|(
name|int
name|returnCode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|self
condition|)
return|return;
name|QThreadData
modifier|*
name|data
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
decl_stmt|;
name|data
operator|->
name|quitNow
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|eventLoops
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QEventLoop
modifier|*
name|eventLoop
init|=
name|data
operator|->
name|eventLoops
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|eventLoop
operator|->
name|exit
argument_list|(
name|returnCode
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Q_OS_WINRT
name|qWarning
argument_list|(
literal|"QCoreApplication::exit: It is not recommended to explicitly exit an application on Windows Store Apps"
argument_list|)
expr_stmt|;
name|ComPtr
argument_list|<
name|ICoreApplication
argument_list|>
name|app
decl_stmt|;
name|HRESULT
name|hr
init|=
name|RoGetActivationFactory
argument_list|(
name|Wrappers
operator|::
name|HString
operator|::
name|MakeReference
argument_list|(
name|RuntimeClass_Windows_ApplicationModel_Core_CoreApplication
argument_list|)
operator|.
name|Get
argument_list|()
argument_list|,
name|IID_PPV_ARGS
argument_list|(
operator|&
name|app
argument_list|)
argument_list|)
decl_stmt|;
name|RETURN_VOID_IF_FAILED
argument_list|(
literal|"Could not acquire ICoreApplication object"
argument_list|)
expr_stmt|;
name|ComPtr
argument_list|<
name|ICoreApplicationExit
argument_list|>
name|appExit
decl_stmt|;
name|hr
operator|=
name|app
operator|.
name|As
argument_list|(
operator|&
name|appExit
argument_list|)
expr_stmt|;
name|RETURN_VOID_IF_FAILED
argument_list|(
literal|"Could not acquire ICoreApplicationExit object"
argument_list|)
expr_stmt|;
name|hr
operator|=
name|appExit
operator|->
name|Exit
argument_list|()
expr_stmt|;
name|RETURN_VOID_IF_FAILED
argument_list|(
literal|"Could not exit application"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Q_OS_WINRT
block|}
end_function
begin_comment
comment|/*****************************************************************************   QCoreApplication management of posted events  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \fn bool QCoreApplication::sendEvent(QObject *receiver, QEvent *event)      Sends event \a event directly to receiver \a receiver, using the     notify() function. Returns the value that was returned from the     event handler.      The event is \e not deleted when the event has been sent. The normal     approach is to create the event on the stack, for example:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 0      \sa postEvent(), notify() */
end_comment
begin_comment
comment|/*!     \since 4.3      Adds the event \a event, with the object \a receiver as the     receiver of the event, to an event queue and returns immediately.      The event must be allocated on the heap since the post event queue     will take ownership of the event and delete it once it has been     posted.  It is \e {not safe} to access the event after     it has been posted.      When control returns to the main event loop, all events that are     stored in the queue will be sent using the notify() function.      Events are sorted in descending \a priority order, i.e. events     with a high \a priority are queued before events with a lower \a     priority. The \a priority can be any integer value, i.e. between     INT_MAX and INT_MIN, inclusive; see Qt::EventPriority for more     details. Events with equal \a priority will be processed in the     order posted.      \threadsafe      \sa sendEvent(), notify(), sendPostedEvents(), Qt::EventPriority */
end_comment
begin_function
DECL|function|postEvent
name|void
name|QCoreApplication
operator|::
name|postEvent
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QEvent
modifier|*
name|event
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
if|if
condition|(
name|receiver
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::postEvent: Unexpected null receiver"
argument_list|)
expr_stmt|;
operator|delete
name|event
expr_stmt|;
return|return;
block|}
name|QThreadData
modifier|*
specifier|volatile
modifier|*
name|pdata
init|=
operator|&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
decl_stmt|;
name|QThreadData
modifier|*
name|data
init|=
operator|*
name|pdata
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
comment|// posting during destruction? just delete the event to prevent a leak
operator|delete
name|event
expr_stmt|;
return|return;
block|}
comment|// lock the post event mutex
name|data
operator|->
name|postEventList
operator|.
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// if object has moved to another thread, follow it
while|while
condition|(
name|data
operator|!=
operator|*
name|pdata
condition|)
block|{
name|data
operator|->
name|postEventList
operator|.
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|data
operator|=
operator|*
name|pdata
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
comment|// posting during destruction? just delete the event to prevent a leak
operator|delete
name|event
expr_stmt|;
return|return;
block|}
name|data
operator|->
name|postEventList
operator|.
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
name|QMutexUnlocker
name|locker
argument_list|(
operator|&
name|data
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
comment|// if this is one of the compressible events, do compression
if|if
condition|(
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|&&
name|self
operator|&&
name|self
operator|->
name|compressEvent
argument_list|(
name|event
argument_list|,
name|receiver
argument_list|,
operator|&
name|data
operator|->
name|postEventList
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DeferredDelete
operator|&&
name|data
operator|==
name|QThreadData
operator|::
name|current
argument_list|()
condition|)
block|{
comment|// remember the current running eventloop for DeferredDelete
comment|// events posted in the receiver's thread.
comment|// Events sent by non-Qt event handlers (such as glib) may not
comment|// have the scopeLevel set correctly. The scope level makes sure that
comment|// code like this:
comment|//     foo->deleteLater();
comment|//     qApp->processEvents(); // without passing QEvent::DeferredDelete
comment|// will not cause "foo" to be deleted before returning to the event loop.
comment|// If the scope level is 0 while loopLevel != 0, we are called from a
comment|// non-conformant code path, and our best guess is that the scope level
comment|// should be 1. (Loop level 0 is special: it means that no event loops
comment|// are running.)
name|int
name|loopLevel
init|=
name|data
operator|->
name|loopLevel
decl_stmt|;
name|int
name|scopeLevel
init|=
name|data
operator|->
name|scopeLevel
decl_stmt|;
if|if
condition|(
name|scopeLevel
operator|==
literal|0
operator|&&
name|loopLevel
operator|!=
literal|0
condition|)
name|scopeLevel
operator|=
literal|1
expr_stmt|;
cast|static_cast
argument_list|<
name|QDeferredDeleteEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|level
operator|=
name|loopLevel
operator|+
name|scopeLevel
expr_stmt|;
block|}
comment|// delete the event on exceptions to protect against memory leaks till the event is
comment|// properly owned in the postEventList
name|QScopedPointer
argument_list|<
name|QEvent
argument_list|>
name|eventDeleter
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|addEvent
argument_list|(
name|QPostEvent
argument_list|(
name|receiver
argument_list|,
name|event
argument_list|,
name|priority
argument_list|)
argument_list|)
expr_stmt|;
name|eventDeleter
operator|.
name|take
argument_list|()
expr_stmt|;
name|event
operator|->
name|posted
operator|=
literal|true
expr_stmt|;
operator|++
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|data
operator|->
name|canWait
operator|=
literal|false
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QAbstractEventDispatcher
modifier|*
name|dispatcher
init|=
name|data
operator|->
name|eventDispatcher
operator|.
name|loadAcquire
argument_list|()
decl_stmt|;
if|if
condition|(
name|dispatcher
condition|)
name|dispatcher
operator|->
name|wakeUp
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal   Returns \c true if \a event was compressed away (possibly deleted) and should not be added to the list. */
end_comment
begin_function
DECL|function|compressEvent
name|bool
name|QCoreApplication
operator|::
name|compressEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|,
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QPostEventList
modifier|*
name|postedEvents
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|Q_ASSERT
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|postedEvents
argument_list|)
expr_stmt|;
comment|// compress posted timers to this object.
if|if
condition|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Timer
operator|&&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|>
literal|0
condition|)
block|{
name|int
name|timerId
init|=
operator|(
operator|(
name|QTimerEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|timerId
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|postedEvents
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|e
init|=
name|postedEvents
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|receiver
operator|==
name|receiver
operator|&&
name|e
operator|.
name|event
operator|&&
name|e
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Timer
operator|&&
operator|(
operator|(
name|QTimerEvent
operator|*
operator|)
name|e
operator|.
name|event
operator|)
operator|->
name|timerId
argument_list|()
operator|==
name|timerId
condition|)
block|{
operator|delete
name|event
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|(
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DeferredDelete
operator|||
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Quit
operator|)
operator|&&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|postedEvents
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|cur
init|=
name|postedEvents
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur
operator|.
name|receiver
operator|!=
name|receiver
operator|||
name|cur
operator|.
name|event
operator|==
literal|0
operator|||
name|cur
operator|.
name|event
operator|->
name|type
argument_list|()
operator|!=
name|event
operator|->
name|type
argument_list|()
condition|)
continue|continue;
comment|// found an event for this receiver
operator|delete
name|event
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Immediately dispatches all events which have been previously queued   with QCoreApplication::postEvent() and which are for the object \a receiver   and have the event type \a event_type.    Events from the window system are \e not dispatched by this   function, but by processEvents().    If \a receiver is null, the events of \a event_type are sent for all   objects. If \a event_type is 0, all the events are sent for \a receiver.    \note This method must be called from the thread in which its QObject   parameter, \a receiver, lives.    \sa flush(), postEvent() */
end_comment
begin_function
DECL|function|sendPostedEvents
name|void
name|QCoreApplication
operator|::
name|sendPostedEvents
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|event_type
parameter_list|)
block|{
comment|// ### Qt 6: consider splitting this method into a public and a private
comment|//           one, so that a user-invoked sendPostedEvents can be detected
comment|//           and handled properly.
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
name|QCoreApplicationPrivate
operator|::
name|sendPostedEvents
argument_list|(
name|receiver
argument_list|,
name|event_type
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendPostedEvents
name|void
name|QCoreApplicationPrivate
operator|::
name|sendPostedEvents
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|event_type
parameter_list|,
name|QThreadData
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|event_type
operator|==
operator|-
literal|1
condition|)
block|{
comment|// we were called by an obsolete event dispatcher.
name|event_type
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|receiver
operator|&&
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|!=
name|data
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::sendPostedEvents: Cannot send "
literal|"posted events for objects in another thread"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|data
operator|->
name|postEventList
operator|.
name|recursion
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|data
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
comment|// by default, we assume that the event dispatcher can go to sleep after
comment|// processing all events. if any new events are posted while we send
comment|// events, canWait will be set to false.
name|data
operator|->
name|canWait
operator|=
operator|(
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
operator|(
name|receiver
operator|&&
operator|!
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|)
condition|)
block|{
operator|--
name|data
operator|->
name|postEventList
operator|.
name|recursion
expr_stmt|;
return|return;
block|}
name|data
operator|->
name|canWait
operator|=
literal|true
expr_stmt|;
comment|// okay. here is the tricky loop. be careful about optimizing
comment|// this, it looks the way it does for good reasons.
name|int
name|startOffset
init|=
name|data
operator|->
name|postEventList
operator|.
name|startOffset
decl_stmt|;
name|int
modifier|&
name|i
init|=
operator|(
operator|!
name|event_type
operator|&&
operator|!
name|receiver
operator|)
condition|?
name|data
operator|->
name|postEventList
operator|.
name|startOffset
else|:
name|startOffset
decl_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|insertionOffset
operator|=
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
expr_stmt|;
comment|// Exception-safe cleaning up without the need for a try/catch block
struct|struct
name|CleanUp
block|{
name|QObject
modifier|*
name|receiver
decl_stmt|;
name|int
name|event_type
decl_stmt|;
name|QThreadData
modifier|*
name|data
decl_stmt|;
name|bool
name|exceptionCaught
decl_stmt|;
specifier|inline
name|CleanUp
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|event_type
parameter_list|,
name|QThreadData
modifier|*
name|data
parameter_list|)
member_init_list|:
name|receiver
argument_list|(
name|receiver
argument_list|)
member_init_list|,
name|event_type
argument_list|(
name|event_type
argument_list|)
member_init_list|,
name|data
argument_list|(
name|data
argument_list|)
member_init_list|,
name|exceptionCaught
argument_list|(
literal|true
argument_list|)
block|{}
specifier|inline
name|~
name|CleanUp
parameter_list|()
block|{
if|if
condition|(
name|exceptionCaught
condition|)
block|{
comment|// since we were interrupted, we need another pass to make sure we clean everything up
name|data
operator|->
name|canWait
operator|=
literal|false
expr_stmt|;
block|}
operator|--
name|data
operator|->
name|postEventList
operator|.
name|recursion
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|postEventList
operator|.
name|recursion
operator|&&
operator|!
name|data
operator|->
name|canWait
operator|&&
name|data
operator|->
name|hasEventDispatcher
argument_list|()
condition|)
name|data
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
operator|->
name|wakeUp
argument_list|()
expr_stmt|;
comment|// clear the global list, i.e. remove everything that was
comment|// delivered.
if|if
condition|(
operator|!
name|event_type
operator|&&
operator|!
name|receiver
operator|&&
name|data
operator|->
name|postEventList
operator|.
name|startOffset
operator|>=
literal|0
condition|)
block|{
specifier|const
name|QPostEventList
operator|::
name|iterator
name|it
init|=
name|data
operator|->
name|postEventList
operator|.
name|begin
argument_list|()
decl_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|erase
argument_list|(
name|it
argument_list|,
name|it
operator|+
name|data
operator|->
name|postEventList
operator|.
name|startOffset
argument_list|)
expr_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|insertionOffset
operator|-=
name|data
operator|->
name|postEventList
operator|.
name|startOffset
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
operator|->
name|postEventList
operator|.
name|insertionOffset
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|data
operator|->
name|postEventList
operator|.
name|startOffset
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
struct|;
name|CleanUp
name|cleanup
argument_list|(
name|receiver
argument_list|,
name|event_type
argument_list|,
name|data
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// avoid live-lock
if|if
condition|(
name|i
operator|>=
name|data
operator|->
name|postEventList
operator|.
name|insertionOffset
condition|)
break|break;
specifier|const
name|QPostEvent
modifier|&
name|pe
init|=
name|data
operator|->
name|postEventList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|pe
operator|.
name|event
condition|)
continue|continue;
if|if
condition|(
operator|(
name|receiver
operator|&&
name|receiver
operator|!=
name|pe
operator|.
name|receiver
operator|)
operator|||
operator|(
name|event_type
operator|&&
name|event_type
operator|!=
name|pe
operator|.
name|event
operator|->
name|type
argument_list|()
operator|)
condition|)
block|{
name|data
operator|->
name|canWait
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pe
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|DeferredDelete
condition|)
block|{
comment|// DeferredDelete events are sent either
comment|// 1) when the event loop that posted the event has returned; or
comment|// 2) if explicitly requested (with QEvent::DeferredDelete) for
comment|//    events posted by the current event loop; or
comment|// 3) if the event was posted before the outermost event loop.
name|int
name|eventLevel
init|=
cast|static_cast
argument_list|<
name|QDeferredDeleteEvent
operator|*
argument_list|>
argument_list|(
name|pe
operator|.
name|event
argument_list|)
operator|->
name|loopLevel
argument_list|()
decl_stmt|;
name|int
name|loopLevel
init|=
name|data
operator|->
name|loopLevel
operator|+
name|data
operator|->
name|scopeLevel
decl_stmt|;
specifier|const
name|bool
name|allowDeferredDelete
init|=
operator|(
name|eventLevel
operator|>
name|loopLevel
operator|||
operator|(
operator|!
name|eventLevel
operator|&&
name|loopLevel
operator|>
literal|0
operator|)
operator|||
operator|(
name|event_type
operator|==
name|QEvent
operator|::
name|DeferredDelete
operator|&&
name|eventLevel
operator|==
name|loopLevel
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowDeferredDelete
condition|)
block|{
comment|// cannot send deferred delete
if|if
condition|(
operator|!
name|event_type
operator|&&
operator|!
name|receiver
condition|)
block|{
comment|// we must copy it first; we want to re-post the event
comment|// with the event pointer intact, but we can't delay
comment|// nulling the event ptr until after re-posting, as
comment|// addEvent may invalidate pe.
name|QPostEvent
name|pe_copy
init|=
name|pe
decl_stmt|;
comment|// null out the event so if sendPostedEvents recurses, it
comment|// will ignore this one, as it's been re-posted.
cast|const_cast
argument_list|<
name|QPostEvent
operator|&
argument_list|>
argument_list|(
name|pe
argument_list|)
operator|.
name|event
operator|=
literal|0
expr_stmt|;
comment|// re-post the copied event so it isn't lost
name|data
operator|->
name|postEventList
operator|.
name|addEvent
argument_list|(
name|pe_copy
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
comment|// first, we diddle the event so that we can deliver
comment|// it, and that no one will try to touch it later.
name|pe
operator|.
name|event
operator|->
name|posted
operator|=
literal|false
expr_stmt|;
name|QEvent
modifier|*
name|e
init|=
name|pe
operator|.
name|event
decl_stmt|;
name|QObject
modifier|*
name|r
init|=
name|pe
operator|.
name|receiver
decl_stmt|;
operator|--
name|r
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|r
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|// next, update the data structure so that we're ready
comment|// for the next event.
cast|const_cast
argument_list|<
name|QPostEvent
operator|&
argument_list|>
argument_list|(
name|pe
argument_list|)
operator|.
name|event
operator|=
literal|0
expr_stmt|;
struct|struct
name|MutexUnlocker
block|{
name|QMutexLocker
modifier|&
name|m
decl_stmt|;
name|MutexUnlocker
parameter_list|(
name|QMutexLocker
modifier|&
name|m
parameter_list|)
member_init_list|:
name|m
argument_list|(
name|m
argument_list|)
block|{
name|m
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|~
name|MutexUnlocker
parameter_list|()
block|{
name|m
operator|.
name|relock
argument_list|()
expr_stmt|;
block|}
block|}
struct|;
name|MutexUnlocker
name|unlocker
argument_list|(
name|locker
argument_list|)
decl_stmt|;
name|QScopedPointer
argument_list|<
name|QEvent
argument_list|>
name|event_deleter
argument_list|(
name|e
argument_list|)
decl_stmt|;
comment|// will delete the event (with the mutex unlocked)
comment|// after all that work, it's time to deliver the event.
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// careful when adding anything below this point - the
comment|// sendEvent() call might invalidate any invariants this
comment|// function depends on.
block|}
name|cleanup
operator|.
name|exceptionCaught
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.3      Removes all events of the given \a eventType that were posted     using postEvent() for \a receiver.      The events are \e not dispatched, instead they are removed from     the queue. You should never need to call this function. If you do     call it, be aware that killing events may cause \a receiver to     break one or more invariants.      If \a receiver is null, the events of \a eventType are removed for     all objects. If \a eventType is 0, all the events are removed for     \a receiver. You should never call this function with \a eventType     of 0. If you do call it in this way, be aware that killing events     may cause \a receiver to break one or more invariants.      \threadsafe */
end_comment
begin_function
DECL|function|removePostedEvents
name|void
name|QCoreApplication
operator|::
name|removePostedEvents
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|eventType
parameter_list|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|receiver
condition|?
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
else|:
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|data
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
comment|// the QObject destructor calls this function directly.  this can
comment|// happen while the event loop is in the middle of posting events,
comment|// and when we get here, we may not have any more posted events
comment|// for this object.
if|if
condition|(
name|receiver
operator|&&
operator|!
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
condition|)
return|return;
comment|//we will collect all the posted events for the QObject
comment|//and we'll delete after the mutex was unlocked
name|QVarLengthArray
argument_list|<
name|QEvent
modifier|*
argument_list|>
name|events
decl_stmt|;
name|int
name|n
init|=
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|pe
init|=
name|data
operator|->
name|postEventList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|receiver
operator|||
name|pe
operator|.
name|receiver
operator|==
name|receiver
operator|)
operator|&&
operator|(
name|pe
operator|.
name|event
operator|&&
operator|(
name|eventType
operator|==
literal|0
operator|||
name|pe
operator|.
name|event
operator|->
name|type
argument_list|()
operator|==
name|eventType
operator|)
operator|)
condition|)
block|{
operator|--
name|pe
operator|.
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|pe
operator|.
name|event
operator|->
name|posted
operator|=
literal|false
expr_stmt|;
name|events
operator|.
name|append
argument_list|(
name|pe
operator|.
name|event
argument_list|)
expr_stmt|;
cast|const_cast
argument_list|<
name|QPostEvent
operator|&
argument_list|>
argument_list|(
name|pe
argument_list|)
operator|.
name|event
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|data
operator|->
name|postEventList
operator|.
name|recursion
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|j
condition|)
name|qSwap
argument_list|(
name|data
operator|->
name|postEventList
index|[
name|i
index|]
argument_list|,
name|data
operator|->
name|postEventList
index|[
name|j
index|]
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|QT_DEBUG
if|if
condition|(
name|receiver
operator|&&
name|eventType
operator|==
literal|0
condition|)
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|data
operator|->
name|postEventList
operator|.
name|recursion
condition|)
block|{
comment|// truncate list
name|data
operator|->
name|postEventList
operator|.
name|erase
argument_list|(
name|data
operator|->
name|postEventList
operator|.
name|begin
argument_list|()
operator|+
name|j
argument_list|,
name|data
operator|->
name|postEventList
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|events
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
operator|delete
name|events
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!   Removes \a event from the queue of posted events, and emits a   warning message if appropriate.    \warning This function can be \e really slow. Avoid using it, if   possible.    \threadsafe */
end_comment
begin_function
DECL|function|removePostedEvent
name|void
name|QCoreApplicationPrivate
operator|::
name|removePostedEvent
parameter_list|(
name|QEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|event
operator|||
operator|!
name|event
operator|->
name|posted
condition|)
return|return;
name|QThreadData
modifier|*
name|data
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|data
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QCoreApplication::removePostedEvent: Internal error: %p %d is posted"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|event
argument_list|,
name|event
operator|->
name|type
argument_list|()
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|postEventList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|pe
init|=
name|data
operator|->
name|postEventList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|pe
operator|.
name|event
operator|==
name|event
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QCoreApplication::removePostedEvent: Event of type %d deleted while posted to %s %s"
argument_list|,
name|event
operator|->
name|type
argument_list|()
argument_list|,
name|pe
operator|.
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|pe
operator|.
name|receiver
operator|->
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|pe
operator|.
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|postedEvents
expr_stmt|;
name|pe
operator|.
name|event
operator|->
name|posted
operator|=
literal|false
expr_stmt|;
operator|delete
name|pe
operator|.
name|event
expr_stmt|;
cast|const_cast
argument_list|<
name|QPostEvent
operator|&
argument_list|>
argument_list|(
name|pe
argument_list|)
operator|.
name|event
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!\reimp  */
end_comment
begin_function
DECL|function|event
name|bool
name|QCoreApplication
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Quit
condition|)
block|{
name|quit
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|QObject
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \enum QCoreApplication::Encoding     \obsolete      This enum type used to define the 8-bit encoding of character string     arguments to translate(). This enum is now obsolete and UTF-8 will be     used in all cases.      \value UnicodeUTF8   UTF-8.     \omitvalue Latin1     \omitvalue DefaultCodec  UTF-8.     \omitvalue CodecForTr      \sa QObject::tr(), QString::fromUtf8() */
end_comment
begin_function
DECL|function|ref
name|void
name|QCoreApplicationPrivate
operator|::
name|ref
parameter_list|()
block|{
name|quitLockRef
operator|.
name|ref
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|deref
name|void
name|QCoreApplicationPrivate
operator|::
name|deref
parameter_list|()
block|{
if|if
condition|(
operator|!
name|quitLockRef
operator|.
name|deref
argument_list|()
condition|)
name|maybeQuit
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|maybeQuit
name|void
name|QCoreApplicationPrivate
operator|::
name|maybeQuit
parameter_list|()
block|{
if|if
condition|(
name|quitLockRef
operator|.
name|load
argument_list|()
operator|==
literal|0
operator|&&
name|in_exec
operator|&&
name|quitLockRefEnabled
operator|&&
name|shouldQuit
argument_list|()
condition|)
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|Quit
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Tells the application to exit with return code 0 (success).     Equivalent to calling QCoreApplication::exit(0).      It's common to connect the QGuiApplication::lastWindowClosed() signal     to quit(), and you also often connect e.g. QAbstractButton::clicked() or     signals in QAction, QMenu, or QMenuBar to it.      Example:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 1      \sa exit(), aboutToQuit(), QGuiApplication::lastWindowClosed() */
end_comment
begin_function
DECL|function|quit
name|void
name|QCoreApplication
operator|::
name|quit
parameter_list|()
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \fn void QCoreApplication::aboutToQuit()    This signal is emitted when the application is about to quit the   main event loop, e.g. when the event loop level drops to zero.   This may happen either after a call to quit() from inside the   application or when the user shuts down the entire desktop session.    The signal is particularly useful if your application has to do some   last-second cleanup. Note that no user interaction is possible in   this state.    \sa quit() */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QOBJECT
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TRANSLATION
end_ifndef
begin_comment
comment|/*!     Adds the translation file \a translationFile to the list of     translation files to be used for translations.      Multiple translation files can be installed. Translations are     searched for in the reverse order in which they were installed,     so the most recently installed translation file is searched first     and the first translation file installed is searched last.     The search stops as soon as a translation containing a matching     string is found.      Installing or removing a QTranslator, or changing an installed QTranslator     generates a \l{QEvent::LanguageChange}{LanguageChange} event for the     QCoreApplication instance. A QGuiApplication instance will propagate the event     to all toplevel windows, where a reimplementation of changeEvent can     re-translate the user interface by passing user-visible strings via the     tr() function to the respective property setters. User-interface classes     generated by Qt Designer provide a \c retranslateUi() function that can be     called.      The function returns \c true on success and false on failure.      \sa removeTranslator(), translate(), QTranslator::load(), {Dynamic Translation} */
end_comment
begin_function
DECL|function|installTranslator
name|bool
name|QCoreApplication
operator|::
name|installTranslator
parameter_list|(
name|QTranslator
modifier|*
name|translationFile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|translationFile
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"installTranslator"
argument_list|)
condition|)
return|return
literal|false
return|;
name|QCoreApplicationPrivate
modifier|*
name|d
init|=
name|self
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|d
operator|->
name|translators
operator|.
name|prepend
argument_list|(
name|translationFile
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TRANSLATION_BUILDER
if|if
condition|(
name|translationFile
operator|->
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|LanguageChange
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|self
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the translation file \a translationFile from the list of     translation files used by this application. (It does not delete the     translation file from the file system.)      The function returns \c true on success and false on failure.      \sa installTranslator(), translate(), QObject::tr() */
end_comment
begin_function
DECL|function|removeTranslator
name|bool
name|QCoreApplication
operator|::
name|removeTranslator
parameter_list|(
name|QTranslator
modifier|*
name|translationFile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|translationFile
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|QCoreApplicationPrivate
operator|::
name|checkInstance
argument_list|(
literal|"removeTranslator"
argument_list|)
condition|)
return|return
literal|false
return|;
name|QCoreApplicationPrivate
modifier|*
name|d
init|=
name|self
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|translators
operator|.
name|removeAll
argument_list|(
name|translationFile
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
if|if
condition|(
operator|!
name|self
operator|->
name|closingDown
argument_list|()
condition|)
block|{
name|QEvent
name|ev
argument_list|(
name|QEvent
operator|::
name|LanguageChange
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|self
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|replacePercentN
specifier|static
name|void
name|replacePercentN
parameter_list|(
name|QString
modifier|*
name|result
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|int
name|percentPos
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|percentPos
operator|=
name|result
operator|->
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
argument_list|,
name|percentPos
operator|+
name|len
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
name|QString
name|fmt
decl_stmt|;
if|if
condition|(
name|result
operator|->
name|at
argument_list|(
name|percentPos
operator|+
name|len
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'L'
argument_list|)
condition|)
block|{
operator|++
name|len
expr_stmt|;
name|fmt
operator|=
name|QLatin1String
argument_list|(
literal|"%L1"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fmt
operator|=
name|QLatin1String
argument_list|(
literal|"%1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|->
name|at
argument_list|(
name|percentPos
operator|+
name|len
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'n'
argument_list|)
condition|)
block|{
name|fmt
operator|=
name|fmt
operator|.
name|arg
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|++
name|len
expr_stmt|;
name|result
operator|->
name|replace
argument_list|(
name|percentPos
argument_list|,
name|len
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|len
operator|=
name|fmt
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     \reentrant      Returns the translation text for \a sourceText, by querying the     installed translation files. The translation files are searched     from the most recently installed file back to the first     installed file.      QObject::tr() provides this functionality more conveniently.      \a context is typically a class name (e.g., "MyDialog") and \a     sourceText is either English text or a short identifying text.      \a disambiguation is an identifying string, for when the same \a     sourceText is used in different roles within the same context. By     default, it is null.      See the \l QTranslator and \l QObject::tr() documentation for     more information about contexts, disambiguations and comments.      \a n is used in conjunction with \c %n to support plural forms.     See QObject::tr() for details.      If none of the translation files contain a translation for \a     sourceText in \a context, this function returns a QString     equivalent of \a sourceText.      This function is not virtual. You can use alternative translation     techniques by subclassing \l QTranslator.      \warning This method is reentrant only if all translators are     installed \e before calling this method. Installing or removing     translators while performing translations is not supported. Doing     so will most likely result in crashes or other undesirable     behavior.      \sa QObject::tr(), installTranslator() */
end_comment
begin_function
DECL|function|translate
name|QString
name|QCoreApplication
operator|::
name|translate
parameter_list|(
specifier|const
name|char
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|sourceText
parameter_list|,
specifier|const
name|char
modifier|*
name|disambiguation
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|sourceText
condition|)
return|return
name|result
return|;
if|if
condition|(
name|self
operator|&&
operator|!
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|translators
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|QTranslator
modifier|*
argument_list|>
operator|::
name|ConstIterator
name|it
decl_stmt|;
name|QTranslator
modifier|*
name|translationFile
decl_stmt|;
for|for
control|(
name|it
operator|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|translators
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|translators
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|translationFile
operator|=
operator|*
name|it
expr_stmt|;
name|result
operator|=
name|translationFile
operator|->
name|translate
argument_list|(
name|context
argument_list|,
name|sourceText
argument_list|,
name|disambiguation
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|isNull
argument_list|()
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|result
operator|.
name|isNull
argument_list|()
condition|)
name|result
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|sourceText
argument_list|)
expr_stmt|;
name|replacePercentN
argument_list|(
operator|&
name|result
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*! \fn static QString QCoreApplication::translate(const char *context, const char *key, const char *disambiguation, Encoding encoding, int n = -1)    \obsolete */
end_comment
begin_comment
comment|// Declared in qglobal.h
end_comment
begin_function
DECL|function|qtTrId
name|QString
name|qtTrId
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|0
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isTranslatorInstalled
name|bool
name|QCoreApplicationPrivate
operator|::
name|isTranslatorInstalled
parameter_list|(
name|QTranslator
modifier|*
name|translator
parameter_list|)
block|{
return|return
name|QCoreApplication
operator|::
name|self
operator|&&
name|QCoreApplication
operator|::
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|translators
operator|.
name|contains
argument_list|(
name|translator
argument_list|)
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|translate
name|QString
name|QCoreApplication
operator|::
name|translate
parameter_list|(
specifier|const
name|char
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|sourceText
parameter_list|,
specifier|const
name|char
modifier|*
name|disambiguation
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
argument|context
argument_list|)
name|Q_UNUSED
argument_list|(
argument|disambiguation
argument_list|)
name|QString
name|ret
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|sourceText
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|ret
operator|.
name|replace
argument_list|(
name|QLatin1String
argument_list|(
literal|"%n"
argument_list|)
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_TRANSLATE
end_comment
begin_comment
comment|// Makes it possible to point QCoreApplication to a custom location to ensure
end_comment
begin_comment
comment|// the directory is added to the patch, and qt.conf and deployed plugins are
end_comment
begin_comment
comment|// found from there. This is for use cases in which QGuiApplication is
end_comment
begin_comment
comment|// instantiated by a library and not by an application executable, for example,
end_comment
begin_comment
comment|// Active X servers.
end_comment
begin_function
DECL|function|setApplicationFilePath
name|void
name|QCoreApplicationPrivate
operator|::
name|setApplicationFilePath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|cachedApplicationFilePath
condition|)
operator|*
name|QCoreApplicationPrivate
operator|::
name|cachedApplicationFilePath
operator|=
name|path
expr_stmt|;
else|else
name|QCoreApplicationPrivate
operator|::
name|cachedApplicationFilePath
operator|=
operator|new
name|QString
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the directory that contains the application executable.      For example, if you have installed Qt in the \c{C:\Qt}     directory, and you run the \c{regexp} example, this function will     return "C:/Qt/examples/tools/regexp".      On OS X and iOS this will point to the directory actually containing     the executable, which may be inside an application bundle (if the     application is bundled).      \warning On Linux, this function will try to get the path from the     \c {/proc} file system. If that fails, it assumes that \c     {argv[0]} contains the absolute file name of the executable. The     function also assumes that the current directory has not been     changed by the application.      \sa applicationFilePath() */
end_comment
begin_function
DECL|function|applicationDirPath
name|QString
name|QCoreApplication
operator|::
name|applicationDirPath
parameter_list|()
block|{
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::applicationDirPath: Please instantiate the QApplication object first"
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QCoreApplicationPrivate
modifier|*
name|d
init|=
name|self
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|cachedApplicationDirPath
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|cachedApplicationDirPath
operator|=
name|QFileInfo
argument_list|(
name|applicationFilePath
argument_list|()
argument_list|)
operator|.
name|path
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cachedApplicationDirPath
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the file path of the application executable.      For example, if you have installed Qt in the \c{/usr/local/qt}     directory, and you run the \c{regexp} example, this function will     return "/usr/local/qt/examples/tools/regexp/regexp".      \warning On Linux, this function will try to get the path from the     \c {/proc} file system. If that fails, it assumes that \c     {argv[0]} contains the absolute file name of the executable. The     function also assumes that the current directory has not been     changed by the application.      \sa applicationDirPath() */
end_comment
begin_function
DECL|function|applicationFilePath
name|QString
name|QCoreApplication
operator|::
name|applicationFilePath
parameter_list|()
block|{
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::applicationFilePath: Please instantiate the QApplication object first"
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QCoreApplicationPrivate
modifier|*
name|d
init|=
name|self
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|argc
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|procName
init|=
name|d
operator|->
name|argv
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|qstrcmp
argument_list|(
name|procName
argument_list|,
name|d
operator|->
name|argv
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|// clear the cache if the procname changes, so we reprocess it.
name|QCoreApplicationPrivate
operator|::
name|clearApplicationFilePath
argument_list|()
expr_stmt|;
name|procName
operator|=
name|d
operator|->
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|cachedApplicationFilePath
condition|)
return|return
operator|*
name|QCoreApplicationPrivate
operator|::
name|cachedApplicationFilePath
return|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|QCoreApplicationPrivate
operator|::
name|setApplicationFilePath
argument_list|(
name|QFileInfo
argument_list|(
name|qAppFileName
argument_list|()
argument_list|)
operator|.
name|filePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|*
name|QCoreApplicationPrivate
operator|::
name|cachedApplicationFilePath
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
name|QString
name|qAppFileName_str
init|=
name|qAppFileName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|qAppFileName_str
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QFileInfo
name|fi
argument_list|(
name|qAppFileName_str
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|exists
argument_list|()
condition|)
block|{
name|QCoreApplicationPrivate
operator|::
name|setApplicationFilePath
argument_list|(
name|fi
operator|.
name|canonicalFilePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|*
name|QCoreApplicationPrivate
operator|::
name|cachedApplicationFilePath
return|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
comment|// Try looking for a /proc/<pid>/exe symlink first which points to
comment|// the absolute path of the executable
name|QFileInfo
name|pfi
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"/proc/%1/exe"
argument_list|)
operator|.
name|arg
argument_list|(
name|getpid
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pfi
operator|.
name|exists
argument_list|()
operator|&&
name|pfi
operator|.
name|isSymLink
argument_list|()
condition|)
block|{
name|QCoreApplicationPrivate
operator|::
name|setApplicationFilePath
argument_list|(
name|pfi
operator|.
name|canonicalFilePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|*
name|QCoreApplicationPrivate
operator|::
name|cachedApplicationFilePath
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|arguments
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|argv0
init|=
name|QFile
operator|::
name|decodeName
argument_list|(
name|arguments
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|absPath
decl_stmt|;
if|if
condition|(
operator|!
name|argv0
operator|.
name|isEmpty
argument_list|()
operator|&&
name|argv0
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
comment|/*               If argv0 starts with a slash, it is already an absolute               file path.             */
name|absPath
operator|=
name|argv0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv0
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
block|{
comment|/*               If argv0 contains one or more slashes, it is a file path               relative to the current directory.             */
name|absPath
operator|=
name|QDir
operator|::
name|current
argument_list|()
operator|.
name|absoluteFilePath
argument_list|(
name|argv0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*               Otherwise, the file path has to be determined using the               PATH environment variable.             */
name|absPath
operator|=
name|QStandardPaths
operator|::
name|findExecutable
argument_list|(
name|argv0
argument_list|)
expr_stmt|;
block|}
name|absPath
operator|=
name|QDir
operator|::
name|cleanPath
argument_list|(
name|absPath
argument_list|)
expr_stmt|;
name|QFileInfo
name|fi
argument_list|(
name|absPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|exists
argument_list|()
condition|)
block|{
name|QCoreApplicationPrivate
operator|::
name|setApplicationFilePath
argument_list|(
name|fi
operator|.
name|canonicalFilePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|*
name|QCoreApplicationPrivate
operator|::
name|cachedApplicationFilePath
return|;
block|}
block|}
endif|#
directive|endif
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the current process ID for the application. */
end_comment
begin_function
DECL|function|applicationPid
name|qint64
name|QCoreApplication
operator|::
name|applicationPid
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
return|return
name|GetCurrentProcessId
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
return|return
operator|(
name|pid_t
operator|)
name|taskIdCurrent
return|;
else|#
directive|else
return|return
name|getpid
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the list of command-line arguments.      Usually arguments().at(0) is the program name, arguments().at(1)     is the first argument, and arguments().last() is the last     argument. See the note below about Windows.      Calling this function is slow - you should store the result in a variable     when parsing the command line.      \warning On Unix, this list is built from the argc and argv parameters passed     to the constructor in the main() function. The string-data in argv is     interpreted using QString::fromLocal8Bit(); hence it is not possible to     pass, for example, Japanese command line arguments on a system that runs in a     Latin1 locale. Most modern Unix systems do not have this limitation, as they are     Unicode-based.      On Windows, the list is built from the argc and argv parameters only if     modified argv/argc parameters are passed to the constructor. In that case,     encoding problems might occur.      Otherwise, the arguments() are constructed from the return value of     \l{http://msdn2.microsoft.com/en-us/library/ms683156(VS.85).aspx}{GetCommandLine()}.     As a result of this, the string given by arguments().at(0) might not be     the program name on Windows, depending on how the application was started.      \sa applicationFilePath(), QCommandLineParser */
end_comment
begin_function
DECL|function|arguments
name|QStringList
name|QCoreApplication
operator|::
name|arguments
parameter_list|()
block|{
name|QStringList
name|list
decl_stmt|;
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|qWarning
argument_list|(
literal|"QCoreApplication::arguments: Please instantiate the QApplication object first"
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
specifier|const
name|int
name|ac
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
specifier|const
name|av
init|=
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|argv
decl_stmt|;
name|list
operator|.
name|reserve
argument_list|(
name|ac
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
comment|// On Windows, it is possible to pass Unicode arguments on
comment|// the command line. To restore those, we split the command line
comment|// and filter out arguments that were deleted by derived application
comment|// classes by index.
name|QString
name|cmdline
init|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|GetCommandLine
argument_list|()
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|wchar_t
name|tempFilename
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|GetModuleFileName
argument_list|(
literal|0
argument_list|,
name|tempFilename
argument_list|,
name|MAX_PATH
argument_list|)
condition|)
block|{
name|tempFilename
index|[
name|MAX_PATH
index|]
operator|=
literal|0
expr_stmt|;
name|cmdline
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
operator|+
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|tempFilename
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"\" "
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Q_OS_WINCE
specifier|const
name|QCoreApplicationPrivate
modifier|*
name|d
init|=
name|self
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|origArgv
condition|)
block|{
specifier|const
name|QStringList
name|allArguments
init|=
name|qWinCmdArgs
argument_list|(
name|cmdline
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|allArguments
operator|.
name|size
argument_list|()
operator|==
name|d
operator|->
name|origArgc
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|origArgc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
name|d
operator|->
name|origArgv
index|[
name|i
index|]
argument_list|)
condition|)
name|list
operator|.
name|append
argument_list|(
name|allArguments
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|// Fall back to rebuilding from argv/argc when a modified argv was passed.
endif|#
directive|endif
comment|// defined(Q_OS_WIN)&& !defined(Q_OS_WINRT)
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|ac
condition|;
operator|++
name|a
control|)
block|{
name|list
operator|<<
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|av
index|[
name|a
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCoreApplication::organizationName     \brief the name of the organization that wrote this application      The value is used by the QSettings class when it is constructed     using the empty constructor. This saves having to repeat this     information each time a QSettings object is created.      On Mac, QSettings uses \l {QCoreApplication::}{organizationDomain()} as the organization     if it's not an empty string; otherwise it uses     organizationName(). On all other platforms, QSettings uses     organizationName() as the organization.      \sa organizationDomain, applicationName */
end_comment
begin_comment
comment|/*!   \fn void QCoreApplication::organizationNameChanged()   \internal    While not useful from C++ due to how organizationName is normally set once on   startup, this is still needed for QML so that bindings are reevaluated after   that initial change. */
end_comment
begin_function
DECL|function|setOrganizationName
name|void
name|QCoreApplication
operator|::
name|setOrganizationName
parameter_list|(
specifier|const
name|QString
modifier|&
name|orgName
parameter_list|)
block|{
if|if
condition|(
name|coreappdata
argument_list|()
operator|->
name|orgName
operator|==
name|orgName
condition|)
return|return;
name|coreappdata
argument_list|()
operator|->
name|orgName
operator|=
name|orgName
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
if|if
condition|(
name|QCoreApplication
operator|::
name|self
condition|)
emit|emit
name|QCoreApplication
operator|::
name|self
operator|->
name|organizationNameChanged
argument_list|()
emit|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|organizationName
name|QString
name|QCoreApplication
operator|::
name|organizationName
parameter_list|()
block|{
return|return
name|coreappdata
argument_list|()
operator|->
name|orgName
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCoreApplication::organizationDomain     \brief the Internet domain of the organization that wrote this application      The value is used by the QSettings class when it is constructed     using the empty constructor. This saves having to repeat this     information each time a QSettings object is created.      On Mac, QSettings uses organizationDomain() as the organization     if it's not an empty string; otherwise it uses organizationName().     On all other platforms, QSettings uses organizationName() as the     organization.      \sa organizationName, applicationName, applicationVersion */
end_comment
begin_comment
comment|/*!   \fn void QCoreApplication::organizationDomainChanged()   \internal    Primarily for QML, see organizationNameChanged. */
end_comment
begin_function
DECL|function|setOrganizationDomain
name|void
name|QCoreApplication
operator|::
name|setOrganizationDomain
parameter_list|(
specifier|const
name|QString
modifier|&
name|orgDomain
parameter_list|)
block|{
if|if
condition|(
name|coreappdata
argument_list|()
operator|->
name|orgDomain
operator|==
name|orgDomain
condition|)
return|return;
name|coreappdata
argument_list|()
operator|->
name|orgDomain
operator|=
name|orgDomain
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
if|if
condition|(
name|QCoreApplication
operator|::
name|self
condition|)
emit|emit
name|QCoreApplication
operator|::
name|self
operator|->
name|organizationDomainChanged
argument_list|()
emit|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|organizationDomain
name|QString
name|QCoreApplication
operator|::
name|organizationDomain
parameter_list|()
block|{
return|return
name|coreappdata
argument_list|()
operator|->
name|orgDomain
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCoreApplication::applicationName     \brief the name of this application      The value is used by the QSettings class when it is constructed     using the empty constructor. This saves having to repeat this     information each time a QSettings object is created.      If not set, the application name defaults to the executable name (since 5.0).      \sa organizationName, organizationDomain, applicationVersion, applicationFilePath() */
end_comment
begin_comment
comment|/*!   \fn void QCoreApplication::applicationNameChanged()   \internal    Primarily for QML, see organizationNameChanged. */
end_comment
begin_function
DECL|function|setApplicationName
name|void
name|QCoreApplication
operator|::
name|setApplicationName
parameter_list|(
specifier|const
name|QString
modifier|&
name|application
parameter_list|)
block|{
name|coreappdata
argument_list|()
operator|->
name|applicationNameSet
operator|=
operator|!
name|application
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|QString
name|newAppName
init|=
name|application
decl_stmt|;
if|if
condition|(
name|newAppName
operator|.
name|isEmpty
argument_list|()
operator|&&
name|QCoreApplication
operator|::
name|self
condition|)
name|newAppName
operator|=
name|QCoreApplication
operator|::
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|appName
argument_list|()
expr_stmt|;
if|if
condition|(
name|coreappdata
argument_list|()
operator|->
name|application
operator|==
name|newAppName
condition|)
return|return;
name|coreappdata
argument_list|()
operator|->
name|application
operator|=
name|newAppName
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
if|if
condition|(
name|QCoreApplication
operator|::
name|self
condition|)
emit|emit
name|QCoreApplication
operator|::
name|self
operator|->
name|applicationNameChanged
argument_list|()
emit|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|applicationName
name|QString
name|QCoreApplication
operator|::
name|applicationName
parameter_list|()
block|{
return|return
name|coreappdata
argument_list|()
condition|?
name|coreappdata
argument_list|()
operator|->
name|application
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// Exported for QDesktopServices (Qt4 behavior compatibility)
end_comment
begin_function
DECL|function|qt_applicationName_noFallback
name|Q_CORE_EXPORT
name|QString
name|qt_applicationName_noFallback
parameter_list|()
block|{
return|return
name|coreappdata
argument_list|()
operator|->
name|applicationNameSet
condition|?
name|coreappdata
argument_list|()
operator|->
name|application
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \property QCoreApplication::applicationVersion     \since 4.4     \brief the version of this application      \sa applicationName, organizationName, organizationDomain */
end_comment
begin_comment
comment|/*!   \fn void QCoreApplication::applicationVersionChanged()   \internal    Primarily for QML, see organizationNameChanged. */
end_comment
begin_function
DECL|function|setApplicationVersion
name|void
name|QCoreApplication
operator|::
name|setApplicationVersion
parameter_list|(
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
block|{
if|if
condition|(
name|coreappdata
argument_list|()
operator|->
name|applicationVersion
operator|==
name|version
condition|)
return|return;
name|coreappdata
argument_list|()
operator|->
name|applicationVersion
operator|=
name|version
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
if|if
condition|(
name|QCoreApplication
operator|::
name|self
condition|)
emit|emit
name|QCoreApplication
operator|::
name|self
operator|->
name|applicationVersionChanged
argument_list|()
emit|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|applicationVersion
name|QString
name|QCoreApplication
operator|::
name|applicationVersion
parameter_list|()
block|{
return|return
name|coreappdata
argument_list|()
operator|->
name|applicationVersion
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
end_ifndef
begin_macro
name|Q_GLOBAL_STATIC_WITH_ARGS
argument_list|(
argument|QMutex
argument_list|,
argument|libraryPathMutex
argument_list|,
argument|(QMutex::Recursive)
argument_list|)
end_macro
begin_comment
comment|/*!     Returns a list of paths that the application will search when     dynamically loading libraries.      The return value of this function may change when a QCoreApplication     is created. It is not recommended to call it before creating a     QCoreApplication. The directory of the application executable (\b not     the working directory) is part of the list if it is known. In order     to make it known a QCoreApplication has to be constructed as it will     use \c {argv[0]} to find it.      Qt provides default library paths, but they can also be set using     a \l{Using qt.conf}{qt.conf} file. Paths specified in this file     will override default values. Note that if the qt.conf file is in     the directory of the application executable, it may not be found     until a QCoreApplication is created. If it is not found when calling     this function, the default library paths will be used.      The list will include the installation directory for plugins if     it exists (the default installation directory for plugins is \c     INSTALL/plugins, where \c INSTALL is the directory where Qt was     installed). The colon separated entries of the \c QT_PLUGIN_PATH     environment variable are always added. The plugin installation     directory (and its existence) may change when the directory of     the application executable becomes known.      If you want to iterate over the list, you can use the \l foreach     pseudo-keyword:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 2      \sa setLibraryPaths(), addLibraryPath(), removeLibraryPath(), QLibrary,         {How to Create Qt Plugins} */
end_comment
begin_function
DECL|function|libraryPaths
name|QStringList
name|QCoreApplication
operator|::
name|libraryPaths
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
name|libraryPathMutex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|coreappdata
argument_list|()
operator|->
name|manual_libpaths
condition|)
return|return
operator|*
operator|(
name|coreappdata
argument_list|()
operator|->
name|manual_libpaths
operator|)
return|;
if|if
condition|(
operator|!
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
condition|)
block|{
name|QStringList
modifier|*
name|app_libpaths
init|=
operator|new
name|QStringList
decl_stmt|;
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|.
name|reset
argument_list|(
name|app_libpaths
argument_list|)
expr_stmt|;
specifier|const
name|QByteArray
name|libPathEnv
init|=
name|qgetenv
argument_list|(
literal|"QT_PLUGIN_PATH"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|libPathEnv
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringList
name|paths
init|=
name|QFile
operator|::
name|decodeName
argument_list|(
name|libPathEnv
argument_list|)
operator|.
name|split
argument_list|(
name|QDir
operator|::
name|listSeparator
argument_list|()
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
for|for
control|(
name|QStringList
operator|::
name|const_iterator
name|it
init|=
name|paths
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|paths
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QString
name|canonicalPath
init|=
name|QDir
argument_list|(
operator|*
name|it
argument_list|)
operator|.
name|canonicalPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|canonicalPath
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|app_libpaths
operator|->
name|contains
argument_list|(
name|canonicalPath
argument_list|)
condition|)
block|{
name|app_libpaths
operator|->
name|append
argument_list|(
name|canonicalPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|QString
name|installPathPlugins
init|=
name|QLibraryInfo
operator|::
name|location
argument_list|(
name|QLibraryInfo
operator|::
name|PluginsPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|installPathPlugins
argument_list|)
condition|)
block|{
comment|// Make sure we convert from backslashes to slashes.
name|installPathPlugins
operator|=
name|QDir
argument_list|(
name|installPathPlugins
argument_list|)
operator|.
name|canonicalPath
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|app_libpaths
operator|->
name|contains
argument_list|(
name|installPathPlugins
argument_list|)
condition|)
name|app_libpaths
operator|->
name|append
argument_list|(
name|installPathPlugins
argument_list|)
expr_stmt|;
block|}
comment|// If QCoreApplication is not yet instantiated,
comment|// make sure we add the application path when we construct the QCoreApplication
if|if
condition|(
name|self
condition|)
name|self
operator|->
name|d_func
argument_list|()
operator|->
name|appendApplicationPathToLibraryPaths
argument_list|()
expr_stmt|;
block|}
return|return
operator|*
operator|(
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!      Sets the list of directories to search when loading libraries to     \a paths. All existing paths will be deleted and the path list     will consist of the paths given in \a paths.      The library paths are reset to the default when an instance of     QCoreApplication is destructed.      \sa libraryPaths(), addLibraryPath(), removeLibraryPath(), QLibrary  */
end_comment
begin_function
DECL|function|setLibraryPaths
name|void
name|QCoreApplication
operator|::
name|setLibraryPaths
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|paths
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
name|libraryPathMutex
argument_list|()
argument_list|)
decl_stmt|;
comment|// setLibraryPaths() is considered a "remove everything and then add some new ones" operation.
comment|// When the application is constructed it should still amend the paths. So we keep the originals
comment|// around, and even create them if they don't exist, yet.
if|if
condition|(
operator|!
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
condition|)
name|libraryPaths
argument_list|()
expr_stmt|;
if|if
condition|(
name|coreappdata
argument_list|()
operator|->
name|manual_libpaths
condition|)
operator|*
operator|(
name|coreappdata
argument_list|()
operator|->
name|manual_libpaths
operator|)
operator|=
name|paths
expr_stmt|;
else|else
name|coreappdata
argument_list|()
operator|->
name|manual_libpaths
operator|.
name|reset
argument_list|(
operator|new
name|QStringList
argument_list|(
name|paths
argument_list|)
argument_list|)
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QFactoryLoader
operator|::
name|refreshAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Prepends \a path to the beginning of the library path list, ensuring that   it is searched for libraries first. If \a path is empty or already in the   path list, the path list is not changed.    The default path list consists of a single entry, the installation   directory for plugins.  The default installation directory for plugins   is \c INSTALL/plugins, where \c INSTALL is the directory where Qt was   installed.    The library paths are reset to the default when an instance of   QCoreApplication is destructed.    \sa removeLibraryPath(), libraryPaths(), setLibraryPaths()  */
end_comment
begin_function
DECL|function|addLibraryPath
name|void
name|QCoreApplication
operator|::
name|addLibraryPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QString
name|canonicalPath
init|=
name|QDir
argument_list|(
name|path
argument_list|)
operator|.
name|canonicalPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|canonicalPath
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QMutexLocker
name|locker
argument_list|(
name|libraryPathMutex
argument_list|()
argument_list|)
decl_stmt|;
name|QStringList
modifier|*
name|libpaths
init|=
name|coreappdata
argument_list|()
operator|->
name|manual_libpaths
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|libpaths
condition|)
block|{
if|if
condition|(
name|libpaths
operator|->
name|contains
argument_list|(
name|canonicalPath
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
comment|// make sure that library paths are initialized
name|libraryPaths
argument_list|()
expr_stmt|;
name|QStringList
modifier|*
name|app_libpaths
init|=
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|app_libpaths
operator|->
name|contains
argument_list|(
name|canonicalPath
argument_list|)
condition|)
return|return;
name|coreappdata
argument_list|()
operator|->
name|manual_libpaths
operator|.
name|reset
argument_list|(
name|libpaths
operator|=
operator|new
name|QStringList
argument_list|(
operator|*
name|app_libpaths
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|libpaths
operator|->
name|prepend
argument_list|(
name|canonicalPath
argument_list|)
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QFactoryLoader
operator|::
name|refreshAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes \a path from the library path list. If \a path is empty or not     in the path list, the list is not changed.      The library paths are reset to the default when an instance of     QCoreApplication is destructed.      \sa addLibraryPath(), libraryPaths(), setLibraryPaths() */
end_comment
begin_function
DECL|function|removeLibraryPath
name|void
name|QCoreApplication
operator|::
name|removeLibraryPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QString
name|canonicalPath
init|=
name|QDir
argument_list|(
name|path
argument_list|)
operator|.
name|canonicalPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|canonicalPath
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QMutexLocker
name|locker
argument_list|(
name|libraryPathMutex
argument_list|()
argument_list|)
decl_stmt|;
name|QStringList
modifier|*
name|libpaths
init|=
name|coreappdata
argument_list|()
operator|->
name|manual_libpaths
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|libpaths
condition|)
block|{
if|if
condition|(
name|libpaths
operator|->
name|removeAll
argument_list|(
name|canonicalPath
argument_list|)
operator|==
literal|0
condition|)
return|return;
block|}
else|else
block|{
comment|// make sure that library paths is initialized
name|libraryPaths
argument_list|()
expr_stmt|;
name|QStringList
modifier|*
name|app_libpaths
init|=
name|coreappdata
argument_list|()
operator|->
name|app_libpaths
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|app_libpaths
operator|->
name|contains
argument_list|(
name|canonicalPath
argument_list|)
condition|)
return|return;
name|coreappdata
argument_list|()
operator|->
name|manual_libpaths
operator|.
name|reset
argument_list|(
name|libpaths
operator|=
operator|new
name|QStringList
argument_list|(
operator|*
name|app_libpaths
argument_list|)
argument_list|)
expr_stmt|;
name|libpaths
operator|->
name|removeAll
argument_list|(
name|canonicalPath
argument_list|)
expr_stmt|;
block|}
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QFactoryLoader
operator|::
name|refreshAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_LIBRARY
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_comment
comment|/*!     Installs an event filter \a filterObj for all native events     received by the application in the main thread.      The event filter \a filterObj receives events via its \l {QAbstractNativeEventFilter::}{nativeEventFilter()}     function, which is called for all native events received in the main thread.      The QAbstractNativeEventFilter::nativeEventFilter() function should     return true if the event should be filtered, i.e. stopped. It should     return false to allow normal Qt processing to continue: the native     event can then be translated into a QEvent and handled by the standard     Qt \l{QEvent} {event} filtering, e.g. QObject::installEventFilter().      If multiple event filters are installed, the filter that was     installed last is activated first.      \note The filter function set here receives native messages,     i.e. MSG or XCB event structs.      \note Native event filters will be disabled in the application when the     Qt::AA_PluginApplication attribute is set.      For maximum portability, you should always try to use QEvent     and QObject::installEventFilter() whenever possible.      \sa QObject::installEventFilter()      \since 5.0 */
end_comment
begin_function
DECL|function|installNativeEventFilter
name|void
name|QCoreApplication
operator|::
name|installNativeEventFilter
parameter_list|(
name|QAbstractNativeEventFilter
modifier|*
name|filterObj
parameter_list|)
block|{
if|if
condition|(
name|QCoreApplication
operator|::
name|testAttribute
argument_list|(
name|Qt
operator|::
name|AA_PluginApplication
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Native event filters are not applied when the Qt::AA_PluginApplication attribute is set"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
init|=
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|(
name|QCoreApplicationPrivate
operator|::
name|theMainThread
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|filterObj
operator|||
operator|!
name|eventDispatcher
condition|)
return|return;
name|eventDispatcher
operator|->
name|installNativeEventFilter
argument_list|(
name|filterObj
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes an event \a filterObject from this object. The     request is ignored if such an event filter has not been installed.      All event filters for this object are automatically removed when     this object is destroyed.      It is always safe to remove an event filter, even during event     filter activation (i.e. from the nativeEventFilter() function).      \sa installNativeEventFilter()     \since 5.0 */
end_comment
begin_function
DECL|function|removeNativeEventFilter
name|void
name|QCoreApplication
operator|::
name|removeNativeEventFilter
parameter_list|(
name|QAbstractNativeEventFilter
modifier|*
name|filterObject
parameter_list|)
block|{
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
init|=
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|filterObject
operator|||
operator|!
name|eventDispatcher
condition|)
return|return;
name|eventDispatcher
operator|->
name|removeNativeEventFilter
argument_list|(
name|filterObject
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \deprecated      This function returns \c true if there are pending events; otherwise     returns \c false. Pending events can be either from the window     system or posted events using postEvent().      \note this function is not thread-safe. It may only be called in the main     thread and only if there are no other threads running in the application     (including threads Qt starts for its own purposes).      \sa QAbstractEventDispatcher::hasPendingEvents() */
end_comment
begin_if
if|#
directive|if
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|3
argument_list|)
end_if
begin_function
DECL|function|hasPendingEvents
name|bool
name|QCoreApplication
operator|::
name|hasPendingEvents
parameter_list|()
block|{
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
init|=
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
name|eventDispatcher
condition|)
return|return
name|eventDispatcher
operator|->
name|hasPendingEvents
argument_list|()
return|;
return|return
literal|false
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Returns a pointer to the event dispatcher object for the main thread. If no     event dispatcher exists for the thread, this function returns 0. */
end_comment
begin_function
DECL|function|eventDispatcher
name|QAbstractEventDispatcher
modifier|*
name|QCoreApplication
operator|::
name|eventDispatcher
parameter_list|()
block|{
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|theMainThread
condition|)
return|return
name|QCoreApplicationPrivate
operator|::
name|theMainThread
operator|.
name|load
argument_list|()
operator|->
name|eventDispatcher
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the event dispatcher for the main thread to \a eventDispatcher. This     is only possible as long as there is no event dispatcher installed yet. That     is, before QCoreApplication has been instantiated. This method takes     ownership of the object. */
end_comment
begin_function
DECL|function|setEventDispatcher
name|void
name|QCoreApplication
operator|::
name|setEventDispatcher
parameter_list|(
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
parameter_list|)
block|{
name|QThread
modifier|*
name|mainThread
init|=
name|QCoreApplicationPrivate
operator|::
name|theMainThread
decl_stmt|;
if|if
condition|(
operator|!
name|mainThread
condition|)
name|mainThread
operator|=
name|QThread
operator|::
name|currentThread
argument_list|()
expr_stmt|;
comment|// will also setup theMainThread
name|mainThread
operator|->
name|setEventDispatcher
argument_list|(
name|eventDispatcher
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_QOBJECT
end_comment
begin_comment
comment|/*!     \macro Q_COREAPP_STARTUP_FUNCTION(QtStartUpFunction ptr)     \since 5.1     \relates QCoreApplication     \reentrant      Adds a global function that will be called from the QCoreApplication     constructor. This macro is normally used to initialize libraries     for program-wide functionality, without requiring the application to     call into the library for initialization.      The function specified by \a ptr should take no arguments and should     return nothing. For example:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 3      Note that the startup function will run at the end of the QCoreApplication constructor,     before any GUI initialization. If GUI code is required in the function,     use a timer (or a queued invocation) to perform the initialization later on,     from the event loop.      If QCoreApplication is deleted and another QCoreApplication is created,     the startup function will be invoked again. */
end_comment
begin_comment
comment|/*!     \fn void qAddPostRoutine(QtCleanUpFunction ptr)     \relates QCoreApplication      Adds a global routine that will be called from the QCoreApplication     destructor. This function is normally used to add cleanup routines     for program-wide functionality.      The cleanup routines are called in the reverse order of their addition.      The function specified by \a ptr should take no arguments and should     return nothing. For example:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 4      Note that for an application- or module-wide cleanup, qaddPostRoutine()     is often not suitable. For example, if the program is split into dynamically     loaded modules, the relevant module may be unloaded long before the     QCoreApplication destructor is called. In such cases, if using qaddPostRoutine()     is still desirable, qRemovePostRoutine() can be used to prevent a routine     from being called by the QCoreApplication destructor. For example, if that     routine was called before the module was unloaded.      For modules and libraries, using a reference-counted     initialization manager or Qt's parent-child deletion mechanism may     be better. Here is an example of a private class that uses the     parent-child mechanism to call a cleanup function at the right     time:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 5      By selecting the right parent object, this can often be made to     clean up the module's data at the right moment.      \sa qRemovePostRoutine() */
end_comment
begin_comment
comment|/*!     \fn void qRemovePostRoutine(QtCleanUpFunction ptr)     \relates QCoreApplication     \since 5.3      Removes the cleanup routine specified by \a ptr from the list of     routines called by the QCoreApplication destructor. The routine     must have been previously added to the list by a call to     qAddPostRoutine(), otherwise this function has no effect.      \sa qAddPostRoutine() */
end_comment
begin_comment
comment|/*!     \macro Q_DECLARE_TR_FUNCTIONS(context)     \relates QCoreApplication      The Q_DECLARE_TR_FUNCTIONS() macro declares and implements two     translation functions, \c tr() and \c trUtf8(), with these     signatures:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 6      This macro is useful if you want to use QObject::tr() or     QObject::trUtf8() in classes that don't inherit from QObject.      Q_DECLARE_TR_FUNCTIONS() must appear at the very top of the     class definition (before the first \c{public:} or \c{protected:}).     For example:      \snippet code/src_corelib_kernel_qcoreapplication.cpp 7      The \a context parameter is normally the class name, but it can     be any text.      \sa Q_OBJECT, QObject::tr(), QObject::trUtf8() */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
