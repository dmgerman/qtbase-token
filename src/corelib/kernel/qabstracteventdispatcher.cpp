begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qabstracteventdispatcher.h"
end_include
begin_include
include|#
directive|include
file|"qabstracteventdispatcher_p.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qcoreapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qfreelist_p.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|// we allow for 2^24 = 8^8 = 16777216 simultaneously running timers
end_comment
begin_struct
DECL|struct|QtTimerIdFreeListConstants
struct|struct
name|QtTimerIdFreeListConstants
super|:
specifier|public
name|QFreeListDefaultConstants
block|{
enum|enum
block|{
DECL|enumerator|InitialNextValue
name|InitialNextValue
init|=
literal|1
block|,
DECL|enumerator|BlockCount
name|BlockCount
init|=
literal|6
block|,     }
enum|;
DECL|member|Sizes
specifier|static
specifier|const
name|int
name|Sizes
index|[
name|BlockCount
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_enum
enum|enum
block|{
DECL|enumerator|Offset0
name|Offset0
init|=
literal|0x00000000
block|,
DECL|enumerator|Offset1
name|Offset1
init|=
literal|0x00000040
block|,
DECL|enumerator|Offset2
name|Offset2
init|=
literal|0x00000100
block|,
DECL|enumerator|Offset3
name|Offset3
init|=
literal|0x00001000
block|,
DECL|enumerator|Offset4
name|Offset4
init|=
literal|0x00010000
block|,
DECL|enumerator|Offset5
name|Offset5
init|=
literal|0x00100000
block|,
DECL|enumerator|Size0
name|Size0
init|=
name|Offset1
operator|-
name|Offset0
block|,
DECL|enumerator|Size1
name|Size1
init|=
name|Offset2
operator|-
name|Offset1
block|,
DECL|enumerator|Size2
name|Size2
init|=
name|Offset3
operator|-
name|Offset2
block|,
DECL|enumerator|Size3
name|Size3
init|=
name|Offset4
operator|-
name|Offset3
block|,
DECL|enumerator|Size4
name|Size4
init|=
name|Offset5
operator|-
name|Offset4
block|,
DECL|enumerator|Size5
name|Size5
init|=
name|QtTimerIdFreeListConstants
operator|::
name|MaxIndex
operator|-
name|Offset5
block|}
enum|;
end_enum
begin_decl_stmt
DECL|member|Sizes
specifier|const
name|int
name|QtTimerIdFreeListConstants
operator|::
name|Sizes
index|[
name|QtTimerIdFreeListConstants
operator|::
name|BlockCount
index|]
init|=
block|{
name|Size0
block|,
name|Size1
block|,
name|Size2
block|,
name|Size3
block|,
name|Size4
block|,
name|Size5
block|}
decl_stmt|;
end_decl_stmt
begin_typedef
DECL|typedef|QtTimerIdFreeList
typedef|typedef
name|QFreeList
argument_list|<
name|void
argument_list|,
name|QtTimerIdFreeListConstants
argument_list|>
name|QtTimerIdFreeList
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QtTimerIdFreeList
argument_list|,
argument|timerIdFreeList
argument_list|)
end_macro
begin_function
DECL|function|allocateTimerId
name|int
name|QAbstractEventDispatcherPrivate
operator|::
name|allocateTimerId
parameter_list|()
block|{
return|return
name|timerIdFreeList
argument_list|()
operator|->
name|next
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|releaseTimerId
name|void
name|QAbstractEventDispatcherPrivate
operator|::
name|releaseTimerId
parameter_list|(
name|int
name|timerId
parameter_list|)
block|{
comment|// this function may be called by a global destructor after
comment|// timerIdFreeList() has been destructed
if|if
condition|(
name|QtTimerIdFreeList
modifier|*
name|fl
init|=
name|timerIdFreeList
argument_list|()
condition|)
name|fl
operator|->
name|release
argument_list|(
name|timerId
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QAbstractEventDispatcher     \brief The QAbstractEventDispatcher class provides an interface to manage Qt's event queue.      \ingroup events      An event dispatcher receives events from the window system and other     sources. It then sends them to the QCoreApplication or QApplication     instance for processing and delivery. QAbstractEventDispatcher provides     fine-grained control over event delivery.      For simple control of event processing use     QCoreApplication::processEvents().      For finer control of the application's event loop, call     instance() and call functions on the QAbstractEventDispatcher     object that is returned. If you want to use your own instance of     QAbstractEventDispatcher or of a QAbstractEventDispatcher     subclass, you must install it with QCoreApplication::setEventDispatcher()     or QThread::setEventDispatcher() \e before a default event dispatcher has     been installed.      The main event loop is started by calling     QCoreApplication::exec(), and stopped by calling     QCoreApplication::exit(). Local event loops can be created using     QEventLoop.      Programs that perform long operations can call processEvents()     with a bitwise OR combination of various QEventLoop::ProcessEventsFlag     values to control which events should be delivered.      QAbstractEventDispatcher also allows the integration of an     external event loop with the Qt event loop. For example, the     \l{Qt Solutions}{Motif Extension Qt Solution} includes a     reimplementation of QAbstractEventDispatcher that merges Qt and     Motif events together.      \sa QEventLoop, QCoreApplication, QThread */
end_comment
begin_comment
comment|/*!     Constructs a new event dispatcher with the given \a parent. */
end_comment
begin_constructor
DECL|function|QAbstractEventDispatcher
name|QAbstractEventDispatcher
operator|::
name|QAbstractEventDispatcher
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QAbstractEventDispatcherPrivate
argument_list|,
name|parent
argument_list|)
block|{}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QAbstractEventDispatcher
name|QAbstractEventDispatcher
operator|::
name|QAbstractEventDispatcher
parameter_list|(
name|QAbstractEventDispatcherPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{}
end_constructor
begin_comment
comment|/*!     Destroys the event dispatcher. */
end_comment
begin_destructor
DECL|function|~QAbstractEventDispatcher
name|QAbstractEventDispatcher
operator|::
name|~
name|QAbstractEventDispatcher
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns a pointer to the event dispatcher object for the specified     \a thread. If \a thread is zero, the current thread is used. If no     event dispatcher exists for the specified thread, this function     returns 0.      \bold{Note:} If Qt is built without thread support, the \a thread     argument is ignored.  */
end_comment
begin_function
DECL|function|instance
name|QAbstractEventDispatcher
modifier|*
name|QAbstractEventDispatcher
operator|::
name|instance
parameter_list|(
name|QThread
modifier|*
name|thread
parameter_list|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|thread
condition|?
name|QThreadData
operator|::
name|get2
argument_list|(
name|thread
argument_list|)
else|:
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
return|return
name|data
operator|->
name|eventDispatcher
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QAbstractEventDispatcher::processEvents(QEventLoop::ProcessEventsFlags flags)      Processes pending events that match \a flags until there are no     more events to process. Returns true if an event was processed;     otherwise returns false.      This function is especially useful if you have a long running     operation and want to show its progress without allowing user     input; i.e. by using the QEventLoop::ExcludeUserInputEvents flag.      If the QEventLoop::WaitForMoreEvents flag is set in \a flags, the     behavior of this function is as follows:      \list      \i If events are available, this function returns after processing     them.      \i If no events are available, this function will wait until more     are available and return after processing newly available events.      \endlist      If the QEventLoop::WaitForMoreEvents flag is not set in \a flags,     and no events are available, this function will return     immediately.      \bold{Note:} This function does not process events continuously; it     returns after all available events are processed.      \sa hasPendingEvents() */
end_comment
begin_comment
comment|/*! \fn bool QAbstractEventDispatcher::hasPendingEvents()      Returns true if there is an event waiting; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     \fn void QAbstractEventDispatcher::registerSocketNotifier(QSocketNotifier *notifier)      Registers \a notifier with the event loop. Subclasses must     implement this method to tie a socket notifier into another     event loop. */
end_comment
begin_comment
comment|/*! \fn void QAbstractEventDispatcher::unregisterSocketNotifier(QSocketNotifier *notifier)      Unregisters \a notifier from the event dispatcher. Subclasses must     reimplement this method to tie a socket notifier into another     event loop. Reimplementations must call the base     implementation. */
end_comment
begin_comment
comment|/*!     \obsolete      \fn int QAbstractEventDispatcher::registerTimer(int interval, QObject *object)      Registers a timer with the specified \a interval for the given \a object     and returns the timer id. */
end_comment
begin_comment
comment|/*!     \obsolete      \fn void QAbstractEventDispatcher::registerTimer(int timerId, int interval, QObject *object)      Register a timer with the specified \a timerId and \a interval for the     given \a object. */
end_comment
begin_comment
comment|/*!     Registers a timer with the specified \a interval and \a timerType for the     given \a object and returns the timer id. */
end_comment
begin_function
DECL|function|registerTimer
name|int
name|QAbstractEventDispatcher
operator|::
name|registerTimer
parameter_list|(
name|int
name|interval
parameter_list|,
name|Qt
operator|::
name|TimerType
name|timerType
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|)
block|{
name|int
name|id
init|=
name|QAbstractEventDispatcherPrivate
operator|::
name|allocateTimerId
argument_list|()
decl_stmt|;
name|registerTimer
argument_list|(
name|id
argument_list|,
name|interval
argument_list|,
name|timerType
argument_list|,
name|object
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QAbstractEventDispatcher::registerTimer(int timerId, int interval, Qt::TimerType timerType, QObject *object)      Register a timer with the specified \a timerId, \a interval, and \a     timerType for the given \a object. */
end_comment
begin_comment
comment|/*!     \fn bool QAbstractEventDispatcher::unregisterTimer(int timerId)      Unregisters the timer with the given \a timerId.     Returns true if successful; otherwise returns false.      \sa registerTimer(), unregisterTimers() */
end_comment
begin_comment
comment|/*!     \fn bool QAbstractEventDispatcher::unregisterTimers(QObject *object)      Unregisters all the timers associated with the given \a object.     Returns true if all timers were successful removed; otherwise returns false.      \sa unregisterTimer(), registeredTimers() */
end_comment
begin_comment
comment|/*!     \fn QList<TimerInfo> QAbstractEventDispatcher::registeredTimers(QObject *object) const      Returns a list of registered timers for \a object. The TimerInfo struct has     \c timerId, \c interval, and \c timerType members.      \sa Qt::TimerType */
end_comment
begin_comment
comment|/*! \fn void QAbstractEventDispatcher::wakeUp()     \threadsafe      Wakes up the event loop.      \sa awake() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractEventDispatcher::interrupt()      Interrupts event dispatching; i.e. the event dispatcher will     return from processEvents() as soon as possible. */
end_comment
begin_comment
comment|/*! \fn void QAbstractEventDispatcher::flush()      Flushes the event queue. This normally returns almost     immediately. Does nothing on platforms other than X11. */
end_comment
begin_comment
comment|// ### DOC: Are these called when the _application_ starts/stops or just
end_comment
begin_comment
comment|// when the current _event loop_ starts/stops?
end_comment
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|startingUp
name|void
name|QAbstractEventDispatcher
operator|::
name|startingUp
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|closingDown
name|void
name|QAbstractEventDispatcher
operator|::
name|closingDown
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!     \typedef QAbstractEventDispatcher::TimerInfo      Typedef for QPair<int, int>. The first component of     the pair is the timer ID; the second component is     the interval.      \sa registeredTimers() */
end_comment
begin_comment
comment|/*!     \typedef QAbstractEventDispatcher::EventFilter      Typedef for a function with the signature      \snippet doc/src/snippets/code/src_corelib_kernel_qabstracteventdispatcher.cpp 0      Note that the type of the \a message is platform dependent. The     following table shows the \a {message}'s type on Windows, Mac, and     X11. You can do a static cast to these types.      \table         \header             \o Platform             \o type         \row             \o Windows             \o MSG         \row             \o X11             \o XEvent         \row             \o Mac             \o NSEvent     \endtable            \sa setEventFilter(), filterEvent() */
end_comment
begin_comment
comment|/*!     Replaces the event filter function for this     QAbstractEventDispatcher with \a filter and returns the replaced     event filter function. Only the current event filter function is     called. If you want to use both filter functions, save the     replaced EventFilter in a place where yours can call it.      The event filter function set here is called for all messages     taken from the system event loop before the event is dispatched to     the respective target, including the messages not meant for Qt     objects.      The event filter function should return true if the message should     be filtered, (i.e. stopped). It should return false to allow     processing the message to continue.      By default, no event filter function is set (i.e., this function     returns a null EventFilter the first time it is called). */
end_comment
begin_function
DECL|function|setEventFilter
name|QAbstractEventDispatcher
operator|::
name|EventFilter
name|QAbstractEventDispatcher
operator|::
name|setEventFilter
parameter_list|(
name|EventFilter
name|filter
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractEventDispatcher
argument_list|)
expr_stmt|;
name|EventFilter
name|oldFilter
init|=
name|d
operator|->
name|event_filter
decl_stmt|;
name|d
operator|->
name|event_filter
operator|=
name|filter
expr_stmt|;
return|return
name|oldFilter
return|;
block|}
end_function
begin_comment
comment|/*!     Sends \a message through the event filter that was set by     setEventFilter().  If no event filter has been set, this function     returns false; otherwise, this function returns the result of the     event filter function.      Subclasses of QAbstractEventDispatcher \e must call this function     for \e all messages received from the system to ensure     compatibility with any extensions that may be used in the     application.      Note that the type of \a message is platform dependent. See      QAbstractEventDispatcher::EventFilter for details.      \sa setEventFilter() */
end_comment
begin_function
DECL|function|filterEvent
name|bool
name|QAbstractEventDispatcher
operator|::
name|filterEvent
parameter_list|(
name|void
modifier|*
name|message
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractEventDispatcher
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|event_filter
condition|)
return|return
name|d
operator|->
name|event_filter
argument_list|(
name|message
argument_list|)
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*! \fn void QAbstractEventDispatcher::awake()      This signal is emitted after the event loop returns from a     function that could block.      \sa wakeUp() aboutToBlock() */
end_comment
begin_comment
comment|/*! \fn void QAbstractEventDispatcher::aboutToBlock()      This signal is emitted before the event loop calls a function that     could block.      \sa awake() */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
