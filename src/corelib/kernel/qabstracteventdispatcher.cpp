begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qabstracteventdispatcher.h"
end_include
begin_include
include|#
directive|include
file|"qabstracteventdispatcher_p.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qcoreapplication_p.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|// we allow for 2^24 = 8^8 = 16777216 simultaneously running timers
DECL|variable|TimerIdMask
specifier|static
specifier|const
name|int
name|TimerIdMask
init|=
literal|0x00ffffff
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TimerSerialMask
specifier|static
specifier|const
name|int
name|TimerSerialMask
init|=
operator|~
name|TimerIdMask
operator|&
operator|~
literal|0x80000000
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|TimerSerialCounter
specifier|static
specifier|const
name|int
name|TimerSerialCounter
init|=
name|TimerIdMask
operator|+
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|MaxTimerId
specifier|static
specifier|const
name|int
name|MaxTimerId
init|=
name|TimerIdMask
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|FirstBucket
specifier|static
name|int
name|FirstBucket
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|}
decl_stmt|;
end_decl_stmt
begin_enum
enum|enum
block|{
DECL|enumerator|FirstBucketOffset
name|FirstBucketOffset
init|=
literal|0
block|,
DECL|enumerator|SecondBucketOffset
name|SecondBucketOffset
init|=
sizeof|sizeof
argument_list|(
name|FirstBucket
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|FirstBucket
index|[
literal|0
index|]
argument_list|)
block|,
DECL|enumerator|ThirdBucketOffset
name|ThirdBucketOffset
init|=
literal|0x100
block|,
DECL|enumerator|FourthBucketOffset
name|FourthBucketOffset
init|=
literal|0x1000
block|,
DECL|enumerator|FifthBucketOffset
name|FifthBucketOffset
init|=
literal|0x10000
block|,
DECL|enumerator|SixthBucketOffset
name|SixthBucketOffset
init|=
literal|0x100000
block|}
enum|;
end_enum
begin_enum
enum|enum
block|{
DECL|enumerator|FirstBucketSize
name|FirstBucketSize
init|=
name|SecondBucketOffset
block|,
DECL|enumerator|SecondBucketSize
name|SecondBucketSize
init|=
name|ThirdBucketOffset
operator|-
name|SecondBucketOffset
block|,
DECL|enumerator|ThirdBucketSize
name|ThirdBucketSize
init|=
name|FourthBucketOffset
operator|-
name|ThirdBucketOffset
block|,
DECL|enumerator|FourthBucketSize
name|FourthBucketSize
init|=
name|FifthBucketOffset
operator|-
name|FourthBucketOffset
block|,
DECL|enumerator|FifthBucketSize
name|FifthBucketSize
init|=
name|SixthBucketOffset
operator|-
name|FifthBucketOffset
block|,
DECL|enumerator|SixthBucketSize
name|SixthBucketSize
init|=
name|MaxTimerId
operator|-
name|SixthBucketOffset
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|BucketSize
specifier|static
specifier|const
name|int
name|BucketSize
index|[]
init|=
block|{
name|FirstBucketSize
block|,
name|SecondBucketSize
block|,
name|ThirdBucketSize
block|,
name|FourthBucketSize
block|,
name|FifthBucketSize
block|,
name|SixthBucketSize
block|}
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enumerator|NumberOfBuckets
enum|enum
block|{
name|NumberOfBuckets
init|=
sizeof|sizeof
argument_list|(
name|BucketSize
argument_list|)
operator|/
expr|sizeof
operator|(
name|BucketSize
index|[
literal|0
index|]
operator|)
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|BucketOffset
specifier|static
specifier|const
name|int
name|BucketOffset
index|[]
init|=
block|{
name|FirstBucketOffset
block|,
name|SecondBucketOffset
block|,
name|ThirdBucketOffset
block|,
name|FourthBucketOffset
block|,
name|FifthBucketOffset
block|,
name|SixthBucketOffset
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|timerIds
specifier|static
name|QBasicAtomicPointer
argument_list|<
name|int
argument_list|>
name|timerIds
index|[]
init|=
block|{
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
name|FirstBucket
argument_list|)
block|,
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
block|,
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
block|,
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
block|,
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
block|,
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|timerIdsDestructorFunction
specifier|static
name|void
name|timerIdsDestructorFunction
parameter_list|()
block|{
comment|// start at one, the first bucket is pre-allocated
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|NumberOfBuckets
condition|;
operator|++
name|i
control|)
operator|delete
index|[]
cast|static_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|timerIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|Q_DESTRUCTOR_FUNCTION
argument_list|(
argument|timerIdsDestructorFunction
argument_list|)
end_macro
begin_decl_stmt
DECL|variable|nextFreeTimerId
specifier|static
name|QBasicAtomicInt
name|nextFreeTimerId
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|// avoid the ABA-problem by using 7 of the top 8 bits of the timerId as a serial number
end_comment
begin_function
DECL|function|prepareNewValueWithSerialNumber
specifier|static
specifier|inline
name|int
name|prepareNewValueWithSerialNumber
parameter_list|(
name|int
name|oldId
parameter_list|,
name|int
name|newId
parameter_list|)
block|{
return|return
operator|(
name|newId
operator|&
name|TimerIdMask
operator|)
operator||
operator|(
operator|(
name|oldId
operator|+
name|TimerSerialCounter
operator|)
operator|&
name|TimerSerialMask
operator|)
return|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
template|template
parameter_list|<
name|bool
parameter_list|>
struct_decl|struct
name|QStaticAssertType
struct_decl|;
DECL|struct|QStaticAssertType
DECL|enumerator|Value
template|template
parameter_list|<>
struct|struct
name|QStaticAssertType
argument_list|<
literal|true
argument_list|>
block|{
enum|enum
block|{
name|Value
init|=
literal|1
block|}
enum|;
block|}
struct|;
block|}
end_namespace
begin_define
DECL|macro|q_static_assert
define|#
directive|define
name|q_static_assert
parameter_list|(
name|expr
parameter_list|)
value|(void)QStaticAssertType<expr>::Value
end_define
begin_function
DECL|function|bucketOffset
specifier|static
specifier|inline
name|int
name|bucketOffset
parameter_list|(
name|int
name|timerId
parameter_list|)
block|{
name|q_static_assert
argument_list|(
sizeof|sizeof
name|BucketSize
operator|==
sizeof|sizeof
name|BucketOffset
argument_list|)
expr_stmt|;
name|q_static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|timerIds
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|timerIds
index|[
literal|0
index|]
argument_list|)
operator|==
name|NumberOfBuckets
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NumberOfBuckets
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|timerId
operator|<
name|BucketSize
index|[
name|i
index|]
condition|)
return|return
name|i
return|;
name|timerId
operator|-=
name|BucketSize
index|[
name|i
index|]
expr_stmt|;
block|}
name|qFatal
argument_list|(
literal|"QAbstractEventDispatcher: INTERNAL ERROR, timer ID %d is too large"
argument_list|,
name|timerId
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|bucketIndex
specifier|static
specifier|inline
name|int
name|bucketIndex
parameter_list|(
name|int
name|bucket
parameter_list|,
name|int
name|timerId
parameter_list|)
block|{
return|return
name|timerId
operator|-
name|BucketOffset
index|[
name|bucket
index|]
return|;
block|}
end_function
begin_function
DECL|function|allocateBucket
specifier|static
specifier|inline
name|int
modifier|*
name|allocateBucket
parameter_list|(
name|int
name|bucket
parameter_list|)
block|{
comment|// allocate a new bucket
specifier|const
name|int
name|size
init|=
name|BucketSize
index|[
name|bucket
index|]
decl_stmt|;
specifier|const
name|int
name|offset
init|=
name|BucketOffset
index|[
name|bucket
index|]
decl_stmt|;
name|int
modifier|*
name|b
init|=
operator|new
name|int
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|size
condition|;
operator|++
name|i
control|)
name|b
index|[
name|i
index|]
operator|=
name|offset
operator|+
name|i
operator|+
literal|1
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QAbstractEventDispatcherPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractEventDispatcher
argument_list|)
expr_stmt|;
if|if
condition|(
name|threadData
operator|->
name|eventDispatcher
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QAbstractEventDispatcher: An event dispatcher has already been created for this thread"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|threadData
operator|->
name|eventDispatcher
operator|=
name|q
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Timer IDs are implemented using a free-list;
end_comment
begin_comment
comment|// there's a vector initialized with:
end_comment
begin_comment
comment|//    X[i] = i + 1
end_comment
begin_comment
comment|// and nextFreeTimerId starts with 1.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Allocating a timer ID involves taking the ID from
end_comment
begin_comment
comment|//    X[nextFreeTimerId]
end_comment
begin_comment
comment|// updating nextFreeTimerId to this value and returning the old value
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// When the timer ID is allocated, its cell in the vector is unused (it's a
end_comment
begin_comment
comment|// free list). As an added protection, we use the cell to store an invalid
end_comment
begin_comment
comment|// (negative) value that we can later check for integrity.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// (continues below).
end_comment
begin_function
DECL|function|allocateTimerId
name|int
name|QAbstractEventDispatcherPrivate
operator|::
name|allocateTimerId
parameter_list|()
block|{
name|int
name|timerId
decl_stmt|,
name|newTimerId
decl_stmt|;
name|int
name|at
decl_stmt|,
modifier|*
name|b
decl_stmt|;
do|do
block|{
name|timerId
operator|=
name|nextFreeTimerId
expr_stmt|;
comment|//.loadAcquire(); // ### FIXME Proper memory ordering semantics
comment|// which bucket are we looking in?
name|int
name|which
init|=
name|timerId
operator|&
name|TimerIdMask
decl_stmt|;
name|int
name|bucket
init|=
name|bucketOffset
argument_list|(
name|which
argument_list|)
decl_stmt|;
name|at
operator|=
name|bucketIndex
argument_list|(
name|bucket
argument_list|,
name|which
argument_list|)
expr_stmt|;
name|b
operator|=
name|timerIds
index|[
name|bucket
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
comment|// allocate a new bucket
name|b
operator|=
name|allocateBucket
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|timerIds
index|[
name|bucket
index|]
operator|.
name|testAndSetRelease
argument_list|(
literal|0
argument_list|,
name|b
argument_list|)
condition|)
block|{
comment|// another thread won the race to allocate the bucket
operator|delete
index|[]
name|b
expr_stmt|;
name|b
operator|=
name|timerIds
index|[
name|bucket
index|]
expr_stmt|;
block|}
block|}
name|newTimerId
operator|=
name|prepareNewValueWithSerialNumber
argument_list|(
name|timerId
argument_list|,
name|b
index|[
name|at
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|nextFreeTimerId
operator|.
name|testAndSetRelaxed
argument_list|(
name|timerId
argument_list|,
name|newTimerId
argument_list|)
condition|)
do|;
name|b
index|[
name|at
index|]
operator|=
operator|-
name|timerId
expr_stmt|;
return|return
name|timerId
return|;
block|}
end_function
begin_comment
comment|// Releasing a timer ID requires putting the current ID back in the vector;
end_comment
begin_comment
comment|// we do it by setting:
end_comment
begin_comment
comment|//    X[timerId] = nextFreeTimerId;
end_comment
begin_comment
comment|// then we update nextFreeTimerId to the timer we've just released
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The extra code in allocateTimerId and releaseTimerId are ABA prevention
end_comment
begin_comment
comment|// and bucket memory. The buckets are simply to make sure we allocate only
end_comment
begin_comment
comment|// the necessary number of timers. See above.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// ABA prevention simply adds a value to 7 of the top 8 bits when resetting
end_comment
begin_comment
comment|// nextFreeTimerId.
end_comment
begin_function
DECL|function|releaseTimerId
name|void
name|QAbstractEventDispatcherPrivate
operator|::
name|releaseTimerId
parameter_list|(
name|int
name|timerId
parameter_list|)
block|{
name|int
name|which
init|=
name|timerId
operator|&
name|TimerIdMask
decl_stmt|;
name|int
name|bucket
init|=
name|bucketOffset
argument_list|(
name|which
argument_list|)
decl_stmt|;
name|int
name|at
init|=
name|bucketIndex
argument_list|(
name|bucket
argument_list|,
name|which
argument_list|)
decl_stmt|;
name|int
modifier|*
name|b
init|=
name|timerIds
index|[
name|bucket
index|]
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|timerId
operator|==
operator|-
name|b
index|[
name|at
index|]
argument_list|,
literal|"QAbstractEventDispatcher::releaseTimerId"
argument_list|,
literal|"Internal error: timer ID not found"
argument_list|)
expr_stmt|;
name|int
name|freeId
decl_stmt|,
name|newTimerId
decl_stmt|;
do|do
block|{
name|freeId
operator|=
name|nextFreeTimerId
expr_stmt|;
comment|//.loadAcquire(); // ### FIXME Proper memory ordering semantics
name|b
index|[
name|at
index|]
operator|=
name|freeId
operator|&
name|TimerIdMask
expr_stmt|;
name|newTimerId
operator|=
name|prepareNewValueWithSerialNumber
argument_list|(
name|freeId
argument_list|,
name|timerId
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|nextFreeTimerId
operator|.
name|testAndSetRelease
argument_list|(
name|freeId
argument_list|,
name|newTimerId
argument_list|)
condition|)
do|;
block|}
end_function
begin_comment
comment|/*!     \class QAbstractEventDispatcher     \brief The QAbstractEventDispatcher class provides an interface to manage Qt's event queue.      \ingroup events      An event dispatcher receives events from the window system and other     sources. It then sends them to the QCoreApplication or QApplication     instance for processing and delivery. QAbstractEventDispatcher provides     fine-grained control over event delivery.      For simple control of event processing use     QCoreApplication::processEvents().      For finer control of the application's event loop, call     instance() and call functions on the QAbstractEventDispatcher     object that is returned. If you want to use your own instance of     QAbstractEventDispatcher or of a QAbstractEventDispatcher     subclass, you must create your instance \e before you create the     QApplication object.      The main event loop is started by calling     QCoreApplication::exec(), and stopped by calling     QCoreApplication::exit(). Local event loops can be created using     QEventLoop.      Programs that perform long operations can call processEvents()     with a bitwise OR combination of various QEventLoop::ProcessEventsFlag     values to control which events should be delivered.      QAbstractEventDispatcher also allows the integration of an     external event loop with the Qt event loop. For example, the     \l{Qt Solutions}{Motif Extension Qt Solution} includes a     reimplementation of QAbstractEventDispatcher that merges Qt and     Motif events together.      \sa QEventLoop, QCoreApplication */
end_comment
begin_comment
comment|/*!     Constructs a new event dispatcher with the given \a parent. */
end_comment
begin_constructor
DECL|function|QAbstractEventDispatcher
name|QAbstractEventDispatcher
operator|::
name|QAbstractEventDispatcher
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QAbstractEventDispatcherPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractEventDispatcher
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QAbstractEventDispatcher
name|QAbstractEventDispatcher
operator|::
name|QAbstractEventDispatcher
parameter_list|(
name|QAbstractEventDispatcherPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractEventDispatcher
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the event dispatcher. */
end_comment
begin_destructor
DECL|function|~QAbstractEventDispatcher
name|QAbstractEventDispatcher
operator|::
name|~
name|QAbstractEventDispatcher
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns a pointer to the event dispatcher object for the specified     \a thread. If \a thread is zero, the current thread is used. If no     event dispatcher exists for the specified thread, this function     returns 0.      \bold{Note:} If Qt is built without thread support, the \a thread     argument is ignored.  */
end_comment
begin_function
DECL|function|instance
name|QAbstractEventDispatcher
modifier|*
name|QAbstractEventDispatcher
operator|::
name|instance
parameter_list|(
name|QThread
modifier|*
name|thread
parameter_list|)
block|{
name|QThreadData
modifier|*
name|data
init|=
name|thread
condition|?
name|QThreadData
operator|::
name|get2
argument_list|(
name|thread
argument_list|)
else|:
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
return|return
name|data
operator|->
name|eventDispatcher
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QAbstractEventDispatcher::processEvents(QEventLoop::ProcessEventsFlags flags)      Processes pending events that match \a flags until there are no     more events to process. Returns true if an event was processed;     otherwise returns false.      This function is especially useful if you have a long running     operation and want to show its progress without allowing user     input; i.e. by using the QEventLoop::ExcludeUserInputEvents flag.      If the QEventLoop::WaitForMoreEvents flag is set in \a flags, the     behavior of this function is as follows:      \list      \i If events are available, this function returns after processing     them.      \i If no events are available, this function will wait until more     are available and return after processing newly available events.      \endlist      If the QEventLoop::WaitForMoreEvents flag is not set in \a flags,     and no events are available, this function will return     immediately.      \bold{Note:} This function does not process events continuously; it     returns after all available events are processed.      \sa hasPendingEvents() */
end_comment
begin_comment
comment|/*! \fn bool QAbstractEventDispatcher::hasPendingEvents()      Returns true if there is an event waiting; otherwise returns     false. */
end_comment
begin_comment
comment|/*!     \fn void QAbstractEventDispatcher::registerSocketNotifier(QSocketNotifier *notifier)      Registers \a notifier with the event loop. Subclasses must     implement this method to tie a socket notifier into another     event loop. */
end_comment
begin_comment
comment|/*! \fn void QAbstractEventDispatcher::unregisterSocketNotifier(QSocketNotifier *notifier)      Unregisters \a notifier from the event dispatcher. Subclasses must     reimplement this method to tie a socket notifier into another     event loop. Reimplementations must call the base     implementation. */
end_comment
begin_comment
comment|/*!     \fn int QAbstractEventDispatcher::registerTimer(int interval, QObject *object)      Registers a timer with the specified \a interval for the given \a object. */
end_comment
begin_function
DECL|function|registerTimer
name|int
name|QAbstractEventDispatcher
operator|::
name|registerTimer
parameter_list|(
name|int
name|interval
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|)
block|{
name|int
name|id
init|=
name|QAbstractEventDispatcherPrivate
operator|::
name|allocateTimerId
argument_list|()
decl_stmt|;
name|registerTimer
argument_list|(
name|id
argument_list|,
name|interval
argument_list|,
name|object
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QAbstractEventDispatcher::registerTimer(int timerId, int interval, QObject *object)      Register a timer with the specified \a timerId and \a interval for     the given \a object. */
end_comment
begin_comment
comment|/*!     \fn bool QAbstractEventDispatcher::unregisterTimer(int timerId)      Unregisters the timer with the given \a timerId.     Returns true if successful; otherwise returns false.      \sa registerTimer(), unregisterTimers() */
end_comment
begin_comment
comment|/*!     \fn bool QAbstractEventDispatcher::unregisterTimers(QObject *object)      Unregisters all the timers associated with the given \a object.     Returns true if all timers were successful removed; otherwise returns false.      \sa unregisterTimer(), registeredTimers() */
end_comment
begin_comment
comment|/*!     \fn QList<TimerInfo> QAbstractEventDispatcher::registeredTimers(QObject *object) const      Returns a list of registered timers for \a object. The timer ID     is the first member in each pair; the interval is the second. */
end_comment
begin_comment
comment|/*! \fn void QAbstractEventDispatcher::wakeUp()     \threadsafe      Wakes up the event loop.      \sa awake() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractEventDispatcher::interrupt()      Interrupts event dispatching; i.e. the event dispatcher will     return from processEvents() as soon as possible. */
end_comment
begin_comment
comment|/*! \fn void QAbstractEventDispatcher::flush()      Flushes the event queue. This normally returns almost     immediately. Does nothing on platforms other than X11. */
end_comment
begin_comment
comment|// ### DOC: Are these called when the _application_ starts/stops or just
end_comment
begin_comment
comment|// when the current _event loop_ starts/stops?
end_comment
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|startingUp
name|void
name|QAbstractEventDispatcher
operator|::
name|startingUp
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|closingDown
name|void
name|QAbstractEventDispatcher
operator|::
name|closingDown
parameter_list|()
block|{ }
end_function
begin_comment
comment|/*!     \typedef QAbstractEventDispatcher::TimerInfo      Typedef for QPair<int, int>. The first component of     the pair is the timer ID; the second component is     the interval.      \sa registeredTimers() */
end_comment
begin_comment
comment|/*!     \typedef QAbstractEventDispatcher::EventFilter      Typedef for a function with the signature      \snippet doc/src/snippets/code/src_corelib_kernel_qabstracteventdispatcher.cpp 0      Note that the type of the \a message is platform dependent. The     following table shows the \a {message}'s type on Windows, Mac, and     X11. You can do a static cast to these types.      \table         \header             \o Platform             \o type         \row             \o Windows             \o MSG         \row             \o X11             \o XEvent         \row             \o Mac             \o NSEvent     \endtable            \sa setEventFilter(), filterEvent() */
end_comment
begin_comment
comment|/*!     Replaces the event filter function for this     QAbstractEventDispatcher with \a filter and returns the replaced     event filter function. Only the current event filter function is     called. If you want to use both filter functions, save the     replaced EventFilter in a place where yours can call it.      The event filter function set here is called for all messages     taken from the system event loop before the event is dispatched to     the respective target, including the messages not meant for Qt     objects.      The event filter function should return true if the message should     be filtered, (i.e. stopped). It should return false to allow     processing the message to continue.      By default, no event filter function is set (i.e., this function     returns a null EventFilter the first time it is called). */
end_comment
begin_function
DECL|function|setEventFilter
name|QAbstractEventDispatcher
operator|::
name|EventFilter
name|QAbstractEventDispatcher
operator|::
name|setEventFilter
parameter_list|(
name|EventFilter
name|filter
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractEventDispatcher
argument_list|)
expr_stmt|;
name|EventFilter
name|oldFilter
init|=
name|d
operator|->
name|event_filter
decl_stmt|;
name|d
operator|->
name|event_filter
operator|=
name|filter
expr_stmt|;
return|return
name|oldFilter
return|;
block|}
end_function
begin_comment
comment|/*!     Sends \a message through the event filter that was set by     setEventFilter().  If no event filter has been set, this function     returns false; otherwise, this function returns the result of the     event filter function.      Subclasses of QAbstractEventDispatcher \e must call this function     for \e all messages received from the system to ensure     compatibility with any extensions that may be used in the     application.      Note that the type of \a message is platform dependent. See      QAbstractEventDispatcher::EventFilter for details.      \sa setEventFilter() */
end_comment
begin_function
DECL|function|filterEvent
name|bool
name|QAbstractEventDispatcher
operator|::
name|filterEvent
parameter_list|(
name|void
modifier|*
name|message
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractEventDispatcher
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|event_filter
condition|)
return|return
name|d
operator|->
name|event_filter
argument_list|(
name|message
argument_list|)
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*! \fn void QAbstractEventDispatcher::awake()      This signal is emitted after the event loop returns from a     function that could block.      \sa wakeUp() aboutToBlock() */
end_comment
begin_comment
comment|/*! \fn void QAbstractEventDispatcher::aboutToBlock()      This signal is emitted before the event loop calls a function that     could block.      \sa awake() */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
