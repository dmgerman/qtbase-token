begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qobject.h"
end_include
begin_include
include|#
directive|include
file|"qobject_p.h"
end_include
begin_include
include|#
directive|include
file|"qmetaobject_p.h"
end_include
begin_include
include|#
directive|include
file|"qabstracteventdispatcher.h"
end_include
begin_include
include|#
directive|include
file|"qabstracteventdispatcher_p.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication_p.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qmetaobject.h"
end_include
begin_include
include|#
directive|include
file|<qregexp.h>
end_include
begin_include
include|#
directive|include
file|<qregularexpression.h>
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<qpair.h>
end_include
begin_include
include|#
directive|include
file|<qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<qset.h>
end_include
begin_include
include|#
directive|include
file|<qsemaphore.h>
end_include
begin_include
include|#
directive|include
file|<qsharedpointer.h>
end_include
begin_include
include|#
directive|include
file|<private/qorderedmutexlocker_p.h>
end_include
begin_include
include|#
directive|include
file|<new>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_struct
DECL|struct|ExtraData
struct|struct
name|QObjectPrivate
operator|::
name|ExtraData
block|{
DECL|function|ExtraData
name|ExtraData
parameter_list|()
block|{}
ifndef|#
directive|ifndef
name|QT_NO_USERDATA
DECL|member|userData
name|QVector
argument_list|<
name|QObjectUserData
modifier|*
argument_list|>
name|userData
decl_stmt|;
endif|#
directive|endif
DECL|member|propertyNames
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|propertyNames
decl_stmt|;
DECL|member|propertyValues
name|QList
argument_list|<
name|QVariant
argument_list|>
name|propertyValues
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|DIRECT_CONNECTION_ONLY
specifier|static
name|int
name|DIRECT_CONNECTION_ONLY
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|queuedConnectionTypes
specifier|static
name|int
modifier|*
name|queuedConnectionTypes
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|typeNames
parameter_list|)
block|{
name|int
modifier|*
name|types
init|=
operator|new
name|int
index|[
name|typeNames
operator|.
name|count
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|types
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|typeNames
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QByteArray
name|typeName
init|=
name|typeNames
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeName
operator|.
name|endsWith
argument_list|(
literal|'*'
argument_list|)
condition|)
name|types
index|[
name|i
index|]
operator|=
name|QMetaType
operator|::
name|VoidStar
expr_stmt|;
else|else
name|types
index|[
name|i
index|]
operator|=
name|QMetaType
operator|::
name|type
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|types
index|[
name|i
index|]
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::connect: Cannot queue arguments of type '%s'\n"
literal|"(Make sure '%s' is registered using qRegisterMetaType().)"
argument_list|,
name|typeName
operator|.
name|constData
argument_list|()
argument_list|,
name|typeName
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
operator|delete
index|[]
name|types
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|types
index|[
name|typeNames
operator|.
name|count
argument_list|()
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|types
return|;
block|}
end_function
begin_function
DECL|function|queuedConnectionTypes
specifier|static
name|int
modifier|*
name|queuedConnectionTypes
parameter_list|(
specifier|const
name|QArgumentType
modifier|*
name|argumentTypes
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|QScopedArrayPointer
argument_list|<
name|int
argument_list|>
name|types
argument_list|(
operator|new
name|int
index|[
name|argc
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QArgumentType
modifier|&
name|type
init|=
name|argumentTypes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|type
argument_list|()
condition|)
name|types
index|[
name|i
index|]
operator|=
name|type
operator|.
name|type
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|.
name|name
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|'*'
argument_list|)
condition|)
name|types
index|[
name|i
index|]
operator|=
name|QMetaType
operator|::
name|VoidStar
expr_stmt|;
else|else
name|types
index|[
name|i
index|]
operator|=
name|QMetaType
operator|::
name|type
argument_list|(
name|type
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|types
index|[
name|i
index|]
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::connect: Cannot queue arguments of type '%s'\n"
literal|"(Make sure '%s' is registered using qRegisterMetaType().)"
argument_list|,
name|type
operator|.
name|name
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|type
operator|.
name|name
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|types
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|types
operator|.
name|take
argument_list|()
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|_q_ObjectMutexPool
specifier|static
name|QBasicMutex
name|_q_ObjectMutexPool
index|[
literal|131
index|]
decl_stmt|;
end_decl_stmt
begin_comment
comment|/** \internal  * mutex to be locked when accessing the connectionlists or the senders list  */
end_comment
begin_function
DECL|function|signalSlotLock
specifier|static
specifier|inline
name|QMutex
modifier|*
name|signalSlotLock
parameter_list|(
specifier|const
name|QObject
modifier|*
name|o
parameter_list|)
block|{
return|return
cast|static_cast
argument_list|<
name|QMutex
operator|*
argument_list|>
argument_list|(
operator|&
name|_q_ObjectMutexPool
index|[
name|uint
argument_list|(
name|quintptr
argument_list|(
name|o
argument_list|)
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|_q_ObjectMutexPool
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|QBasicMutex
argument_list|)
index|]
argument_list|)
return|;
block|}
end_function
begin_extern
DECL|function|qt_addObject
extern|extern
literal|"C"
name|Q_CORE_EXPORT
name|void
name|qt_addObject
parameter_list|(
name|QObject
modifier|*
parameter_list|)
block|{}
end_extern
begin_extern
DECL|function|qt_removeObject
extern|extern
literal|"C"
name|Q_CORE_EXPORT
name|void
name|qt_removeObject
parameter_list|(
name|QObject
modifier|*
parameter_list|)
block|{}
end_extern
begin_struct
DECL|struct|QConnectionSenderSwitcher
struct|struct
name|QConnectionSenderSwitcher
block|{
DECL|member|receiver
name|QObject
modifier|*
name|receiver
decl_stmt|;
DECL|member|previousSender
name|QObjectPrivate
operator|::
name|Sender
modifier|*
name|previousSender
decl_stmt|;
DECL|member|currentSender
name|QObjectPrivate
operator|::
name|Sender
name|currentSender
decl_stmt|;
DECL|member|switched
name|bool
name|switched
decl_stmt|;
DECL|function|QConnectionSenderSwitcher
specifier|inline
name|QConnectionSenderSwitcher
parameter_list|()
member_init_list|:
name|switched
argument_list|(
literal|false
argument_list|)
block|{}
DECL|function|QConnectionSenderSwitcher
specifier|inline
name|QConnectionSenderSwitcher
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|signal_absolute_id
parameter_list|)
block|{
name|switchSender
argument_list|(
name|receiver
argument_list|,
name|sender
argument_list|,
name|signal_absolute_id
argument_list|)
expr_stmt|;
block|}
DECL|function|switchSender
specifier|inline
name|void
name|switchSender
parameter_list|(
name|QObject
modifier|*
name|receiver
parameter_list|,
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|signal_absolute_id
parameter_list|)
block|{
name|this
operator|->
name|receiver
operator|=
name|receiver
expr_stmt|;
name|currentSender
operator|.
name|sender
operator|=
name|sender
expr_stmt|;
name|currentSender
operator|.
name|signal
operator|=
name|signal_absolute_id
expr_stmt|;
name|currentSender
operator|.
name|ref
operator|=
literal|1
expr_stmt|;
name|previousSender
operator|=
name|QObjectPrivate
operator|::
name|setCurrentSender
argument_list|(
name|receiver
argument_list|,
operator|&
name|currentSender
argument_list|)
expr_stmt|;
name|switched
operator|=
literal|true
expr_stmt|;
block|}
DECL|function|~QConnectionSenderSwitcher
specifier|inline
name|~
name|QConnectionSenderSwitcher
parameter_list|()
block|{
if|if
condition|(
name|switched
condition|)
name|QObjectPrivate
operator|::
name|resetCurrentSender
argument_list|(
name|receiver
argument_list|,
operator|&
name|currentSender
argument_list|,
name|previousSender
argument_list|)
expr_stmt|;
block|}
private|private:
name|Q_DISABLE_COPY
argument_list|(
argument|QConnectionSenderSwitcher
argument_list|)
block|}
struct|;
end_struct
begin_function_decl
DECL|variable|destroyed
name|void
function_decl|(
modifier|*
name|QAbstractDeclarativeData
operator|::
name|destroyed
function_decl|)
parameter_list|(
name|QAbstractDeclarativeData
modifier|*
parameter_list|,
name|QObject
modifier|*
parameter_list|)
function_decl|=
literal|0
function_decl|;
end_function_decl
begin_function_decl
DECL|variable|parentChanged
name|void
function_decl|(
modifier|*
name|QAbstractDeclarativeData
operator|::
name|parentChanged
function_decl|)
parameter_list|(
name|QAbstractDeclarativeData
modifier|*
parameter_list|,
name|QObject
modifier|*
parameter_list|,
name|QObject
modifier|*
parameter_list|)
function_decl|=
literal|0
function_decl|;
end_function_decl
begin_function_decl
DECL|variable|signalEmitted
name|void
function_decl|(
modifier|*
name|QAbstractDeclarativeData
operator|::
name|signalEmitted
function_decl|)
parameter_list|(
name|QAbstractDeclarativeData
modifier|*
parameter_list|,
name|QObject
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|=
literal|0
function_decl|;
end_function_decl
begin_function_decl
DECL|variable|receivers
name|int
function_decl|(
modifier|*
name|QAbstractDeclarativeData
operator|::
name|receivers
function_decl|)
parameter_list|(
name|QAbstractDeclarativeData
modifier|*
parameter_list|,
specifier|const
name|QObject
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|=
literal|0
function_decl|;
end_function_decl
begin_destructor
DECL|function|~QObjectData
name|QObjectData
operator|::
name|~
name|QObjectData
parameter_list|()
block|{}
end_destructor
begin_constructor
DECL|function|QObjectPrivate
name|QObjectPrivate
operator|::
name|QObjectPrivate
parameter_list|(
name|int
name|version
parameter_list|)
member_init_list|:
name|threadData
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|connectionLists
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|senders
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|currentSender
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|currentChildBeingDeleted
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
name|version
operator|!=
name|QObjectPrivateVersion
condition|)
name|qFatal
argument_list|(
literal|"Cannot mix incompatible Qt library (version 0x%x) with this library (version 0x%x)"
argument_list|,
name|version
argument_list|,
name|QObjectPrivateVersion
argument_list|)
expr_stmt|;
comment|// QObjectData initialization
name|q_ptr
operator|=
literal|0
expr_stmt|;
name|parent
operator|=
literal|0
expr_stmt|;
comment|// no parent yet. It is set by setParent()
name|isWidget
operator|=
literal|false
expr_stmt|;
comment|// assume not a widget object
name|blockSig
operator|=
literal|false
expr_stmt|;
comment|// not blocking signals
name|wasDeleted
operator|=
literal|false
expr_stmt|;
comment|// double-delete catcher
name|isDeletingChildren
operator|=
literal|false
expr_stmt|;
comment|// set by deleteChildren()
name|sendChildEvents
operator|=
literal|true
expr_stmt|;
comment|// if we should send ChildInsert and ChildRemove events to parent
name|receiveChildEvents
operator|=
literal|true
expr_stmt|;
name|postedEvents
operator|=
literal|0
expr_stmt|;
name|extraData
operator|=
literal|0
expr_stmt|;
name|connectedSignals
index|[
literal|0
index|]
operator|=
name|connectedSignals
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|metaObject
operator|=
literal|0
expr_stmt|;
name|isWindow
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QObjectPrivate
name|QObjectPrivate
operator|::
name|~
name|QObjectPrivate
parameter_list|()
block|{
if|if
condition|(
operator|!
name|runningTimers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// unregister pending timers
if|if
condition|(
name|threadData
operator|->
name|eventDispatcher
condition|)
name|threadData
operator|->
name|eventDispatcher
operator|->
name|unregisterTimers
argument_list|(
name|q_ptr
argument_list|)
expr_stmt|;
comment|// release the timer ids back to the pool
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|runningTimers
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|QAbstractEventDispatcherPrivate
operator|::
name|releaseTimerId
argument_list|(
name|runningTimers
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|postedEvents
condition|)
name|QCoreApplication
operator|::
name|removePostedEvents
argument_list|(
name|q_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|threadData
operator|->
name|deref
argument_list|()
expr_stmt|;
operator|delete
cast|static_cast
argument_list|<
name|QAbstractDynamicMetaObject
operator|*
argument_list|>
argument_list|(
name|metaObject
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_USERDATA
if|if
condition|(
name|extraData
condition|)
name|qDeleteAll
argument_list|(
name|extraData
operator|->
name|userData
argument_list|)
expr_stmt|;
operator|delete
name|extraData
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_comment
comment|/*!\internal   For a given metaobject, compute the signal offset, and the method offset (including signals) */
end_comment
begin_function
DECL|function|computeOffsets
specifier|static
name|void
name|computeOffsets
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|metaobject
parameter_list|,
name|int
modifier|*
name|signalOffset
parameter_list|,
name|int
modifier|*
name|methodOffset
parameter_list|)
block|{
operator|*
name|signalOffset
operator|=
operator|*
name|methodOffset
operator|=
literal|0
expr_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|metaobject
operator|->
name|d
operator|.
name|superdata
decl_stmt|;
while|while
condition|(
name|m
condition|)
block|{
specifier|const
name|QMetaObjectPrivate
modifier|*
name|d
init|=
name|QMetaObjectPrivate
operator|::
name|get
argument_list|(
name|m
argument_list|)
decl_stmt|;
operator|*
name|methodOffset
operator|+=
name|d
operator|->
name|methodCount
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|revision
operator|>=
literal|4
argument_list|)
expr_stmt|;
operator|*
name|signalOffset
operator|+=
name|d
operator|->
name|signalCount
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*     This vector contains the all connections from an object.      Each object may have one vector containing the lists of     connections for a given signal. The index in the vector correspond     to the signal index. The signal index is the one returned by     QObjectPrivate::signalIndex (not QMetaObject::indexOfSignal).     Negative index means connections to all signals.      This vector is protected by the object mutex (signalSlotMutexes())      Each Connection is also part of a 'senders' linked list. The mutex     of the receiver must be locked when touching the pointers of this     linked list. */
end_comment
begin_class
DECL|class|QObjectConnectionListVector
class|class
name|QObjectConnectionListVector
super|:
specifier|public
name|QVector
argument_list|<
name|QObjectPrivate
operator|::
name|ConnectionList
argument_list|>
block|{
public|public:
DECL|member|orphaned
name|bool
name|orphaned
decl_stmt|;
comment|//the QObject owner of this vector has been destroyed while the vector was inUse
DECL|member|dirty
name|bool
name|dirty
decl_stmt|;
comment|//some Connection have been disconnected (their receiver is 0) but not removed from the list yet
DECL|member|inUse
name|int
name|inUse
decl_stmt|;
comment|//number of functions that are currently accessing this object or its connections
DECL|member|allsignals
name|QObjectPrivate
operator|::
name|ConnectionList
name|allsignals
decl_stmt|;
DECL|function|QObjectConnectionListVector
name|QObjectConnectionListVector
parameter_list|()
member_init_list|:
name|QVector
argument_list|<
name|QObjectPrivate
operator|::
name|ConnectionList
argument_list|>
argument_list|()
member_init_list|,
name|orphaned
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|dirty
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|inUse
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|operator []
name|QObjectPrivate
operator|::
name|ConnectionList
modifier|&
name|operator
name|[]
parameter_list|(
name|int
name|at
parameter_list|)
block|{
if|if
condition|(
name|at
operator|<
literal|0
condition|)
return|return
name|allsignals
return|;
return|return
name|QVector
argument_list|<
name|QObjectPrivate
operator|::
name|ConnectionList
argument_list|>
operator|::
name|operator
name|[]
argument_list|(
name|at
argument_list|)
return|;
block|}
block|}
class|;
end_class
begin_comment
comment|// Used by QAccessibleWidget
end_comment
begin_function
DECL|function|isSender
name|bool
name|QObjectPrivate
operator|::
name|isSender
parameter_list|(
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|signal
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QObject
argument_list|)
expr_stmt|;
name|int
name|signal_index
init|=
name|signalIndex
argument_list|(
name|signal
argument_list|)
decl_stmt|;
if|if
condition|(
name|signal_index
operator|<
literal|0
condition|)
return|return
literal|false
return|;
name|QMutexLocker
name|locker
argument_list|(
name|signalSlotLock
argument_list|(
name|q
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|connectionLists
condition|)
block|{
if|if
condition|(
name|signal_index
operator|<
name|connectionLists
operator|->
name|count
argument_list|()
condition|)
block|{
specifier|const
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
init|=
name|connectionLists
operator|->
name|at
argument_list|(
name|signal_index
argument_list|)
operator|.
name|first
decl_stmt|;
while|while
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|receiver
operator|==
name|receiver
condition|)
return|return
literal|true
return|;
name|c
operator|=
name|c
operator|->
name|nextConnectionList
expr_stmt|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|// Used by QAccessibleWidget
end_comment
begin_function
DECL|function|receiverList
name|QObjectList
name|QObjectPrivate
operator|::
name|receiverList
parameter_list|(
specifier|const
name|char
modifier|*
name|signal
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QObject
argument_list|)
expr_stmt|;
name|QObjectList
name|returnValue
decl_stmt|;
name|int
name|signal_index
init|=
name|signalIndex
argument_list|(
name|signal
argument_list|)
decl_stmt|;
if|if
condition|(
name|signal_index
operator|<
literal|0
condition|)
return|return
name|returnValue
return|;
name|QMutexLocker
name|locker
argument_list|(
name|signalSlotLock
argument_list|(
name|q
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|connectionLists
condition|)
block|{
if|if
condition|(
name|signal_index
operator|<
name|connectionLists
operator|->
name|count
argument_list|()
condition|)
block|{
specifier|const
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
init|=
name|connectionLists
operator|->
name|at
argument_list|(
name|signal_index
argument_list|)
operator|.
name|first
decl_stmt|;
while|while
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|receiver
condition|)
name|returnValue
operator|<<
name|c
operator|->
name|receiver
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|nextConnectionList
expr_stmt|;
block|}
block|}
block|}
return|return
name|returnValue
return|;
block|}
end_function
begin_comment
comment|// Used by QAccessibleWidget
end_comment
begin_function
DECL|function|senderList
name|QObjectList
name|QObjectPrivate
operator|::
name|senderList
parameter_list|()
specifier|const
block|{
name|QObjectList
name|returnValue
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
name|signalSlotLock
argument_list|(
name|q_func
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Connection
modifier|*
name|c
init|=
name|senders
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
name|returnValue
operator|<<
name|c
operator|->
name|sender
expr_stmt|;
return|return
name|returnValue
return|;
block|}
end_function
begin_comment
comment|/*! \internal   Add the connection \a c to to the list of connections of the sender's object   for the specified \a signal    The signalSlotLock() of the sender and receiver must be locked while calling   this function    Will also add the connection in the sender's list of the receiver.  */
end_comment
begin_function
DECL|function|addConnection
name|void
name|QObjectPrivate
operator|::
name|addConnection
parameter_list|(
name|int
name|signal
parameter_list|,
name|Connection
modifier|*
name|c
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|c
operator|->
name|sender
operator|==
name|q_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|connectionLists
condition|)
name|connectionLists
operator|=
operator|new
name|QObjectConnectionListVector
argument_list|()
expr_stmt|;
if|if
condition|(
name|signal
operator|>=
name|connectionLists
operator|->
name|count
argument_list|()
condition|)
name|connectionLists
operator|->
name|resize
argument_list|(
name|signal
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ConnectionList
modifier|&
name|connectionList
init|=
operator|(
operator|*
name|connectionLists
operator|)
index|[
name|signal
index|]
decl_stmt|;
if|if
condition|(
name|connectionList
operator|.
name|last
condition|)
block|{
name|connectionList
operator|.
name|last
operator|->
name|nextConnectionList
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|connectionList
operator|.
name|first
operator|=
name|c
expr_stmt|;
block|}
name|connectionList
operator|.
name|last
operator|=
name|c
expr_stmt|;
name|cleanConnectionLists
argument_list|()
expr_stmt|;
name|c
operator|->
name|prev
operator|=
operator|&
operator|(
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|c
operator|->
name|receiver
argument_list|)
operator|->
name|senders
operator|)
expr_stmt|;
name|c
operator|->
name|next
operator|=
operator|*
name|c
operator|->
name|prev
expr_stmt|;
operator|*
name|c
operator|->
name|prev
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|next
condition|)
name|c
operator|->
name|next
operator|->
name|prev
operator|=
operator|&
name|c
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|signal
operator|<
literal|0
condition|)
block|{
name|connectedSignals
index|[
literal|0
index|]
operator|=
name|connectedSignals
index|[
literal|1
index|]
operator|=
operator|~
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|signal
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|connectedSignals
argument_list|)
operator|*
literal|8
condition|)
block|{
name|connectedSignals
index|[
name|signal
operator|>>
literal|5
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|signal
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|cleanConnectionLists
name|void
name|QObjectPrivate
operator|::
name|cleanConnectionLists
parameter_list|()
block|{
if|if
condition|(
name|connectionLists
operator|->
name|dirty
operator|&&
operator|!
name|connectionLists
operator|->
name|inUse
condition|)
block|{
comment|// remove broken connections
for|for
control|(
name|int
name|signal
init|=
operator|-
literal|1
init|;
name|signal
operator|<
name|connectionLists
operator|->
name|count
argument_list|()
condition|;
operator|++
name|signal
control|)
block|{
name|QObjectPrivate
operator|::
name|ConnectionList
modifier|&
name|connectionList
init|=
operator|(
operator|*
name|connectionLists
operator|)
index|[
name|signal
index|]
decl_stmt|;
comment|// Set to the last entry in the connection list that was *not*
comment|// deleted.  This is needed to update the list's last pointer
comment|// at the end of the cleanup.
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|last
init|=
literal|0
decl_stmt|;
name|QObjectPrivate
operator|::
name|Connection
modifier|*
modifier|*
name|prev
init|=
operator|&
name|connectionList
operator|.
name|first
decl_stmt|;
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
init|=
operator|*
name|prev
decl_stmt|;
while|while
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|receiver
condition|)
block|{
name|last
operator|=
name|c
expr_stmt|;
name|prev
operator|=
operator|&
name|c
operator|->
name|nextConnectionList
expr_stmt|;
name|c
operator|=
operator|*
name|prev
expr_stmt|;
block|}
else|else
block|{
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|next
init|=
name|c
operator|->
name|nextConnectionList
decl_stmt|;
operator|*
name|prev
operator|=
name|next
expr_stmt|;
name|c
operator|->
name|deref
argument_list|()
expr_stmt|;
name|c
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|// Correct the connection list's last pointer.
comment|// As conectionList.last could equal last, this could be a noop
name|connectionList
operator|.
name|last
operator|=
name|last
expr_stmt|;
block|}
name|connectionLists
operator|->
name|dirty
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_constructor
DECL|function|QMetaCallEvent
name|QMetaCallEvent
operator|::
name|QMetaCallEvent
parameter_list|(
name|ushort
name|method_offset
parameter_list|,
name|ushort
name|method_relative
parameter_list|,
name|QObjectPrivate
operator|::
name|StaticMetaCallFunction
name|callFunction
parameter_list|,
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|signalId
parameter_list|,
name|int
name|nargs
parameter_list|,
name|int
modifier|*
name|types
parameter_list|,
name|void
modifier|*
modifier|*
name|args
parameter_list|,
name|QSemaphore
modifier|*
name|semaphore
parameter_list|)
member_init_list|:
name|QEvent
argument_list|(
name|MetaCall
argument_list|)
member_init_list|,
name|slotObj_
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|sender_
argument_list|(
name|sender
argument_list|)
member_init_list|,
name|signalId_
argument_list|(
name|signalId
argument_list|)
member_init_list|,
name|nargs_
argument_list|(
name|nargs
argument_list|)
member_init_list|,
name|types_
argument_list|(
name|types
argument_list|)
member_init_list|,
name|args_
argument_list|(
name|args
argument_list|)
member_init_list|,
name|semaphore_
argument_list|(
name|semaphore
argument_list|)
member_init_list|,
name|callFunction_
argument_list|(
name|callFunction
argument_list|)
member_init_list|,
name|method_offset_
argument_list|(
name|method_offset
argument_list|)
member_init_list|,
name|method_relative_
argument_list|(
name|method_relative
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*! \internal  */
end_comment
begin_constructor
DECL|function|QMetaCallEvent
name|QMetaCallEvent
operator|::
name|QMetaCallEvent
parameter_list|(
name|QObject
operator|::
name|QSlotObjectBase
modifier|*
name|slotO
parameter_list|,
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|signalId
parameter_list|,
name|int
name|nargs
parameter_list|,
name|int
modifier|*
name|types
parameter_list|,
name|void
modifier|*
modifier|*
name|args
parameter_list|,
name|QSemaphore
modifier|*
name|semaphore
parameter_list|)
member_init_list|:
name|QEvent
argument_list|(
name|MetaCall
argument_list|)
member_init_list|,
name|slotObj_
argument_list|(
name|slotO
argument_list|)
member_init_list|,
name|sender_
argument_list|(
name|sender
argument_list|)
member_init_list|,
name|signalId_
argument_list|(
name|signalId
argument_list|)
member_init_list|,
name|nargs_
argument_list|(
name|nargs
argument_list|)
member_init_list|,
name|types_
argument_list|(
name|types
argument_list|)
member_init_list|,
name|args_
argument_list|(
name|args
argument_list|)
member_init_list|,
name|semaphore_
argument_list|(
name|semaphore
argument_list|)
member_init_list|,
name|callFunction_
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|method_offset_
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|method_relative_
argument_list|(
operator|-
literal|1
argument_list|)
block|{
if|if
condition|(
name|slotObj_
condition|)
name|slotObj_
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*! \internal  */
end_comment
begin_destructor
DECL|function|~QMetaCallEvent
name|QMetaCallEvent
operator|::
name|~
name|QMetaCallEvent
parameter_list|()
block|{
if|if
condition|(
name|types_
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nargs_
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|types_
index|[
name|i
index|]
operator|&&
name|args_
index|[
name|i
index|]
condition|)
name|QMetaType
operator|::
name|destroy
argument_list|(
name|types_
index|[
name|i
index|]
argument_list|,
name|args_
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|types_
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args_
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_THREAD
if|if
condition|(
name|semaphore_
condition|)
name|semaphore_
operator|->
name|release
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|slotObj_
operator|&&
operator|!
name|slotObj_
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|slotObj_
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|placeMetaCall
name|void
name|QMetaCallEvent
operator|::
name|placeMetaCall
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
block|{
if|if
condition|(
name|slotObj_
condition|)
block|{
name|slotObj_
operator|->
name|call
argument_list|(
name|object
argument_list|,
name|args_
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|callFunction_
operator|&&
name|method_offset_
operator|<=
name|object
operator|->
name|metaObject
argument_list|()
operator|->
name|methodOffset
argument_list|()
condition|)
block|{
name|callFunction_
argument_list|(
name|object
argument_list|,
name|QMetaObject
operator|::
name|InvokeMetaMethod
argument_list|,
name|method_relative_
argument_list|,
name|args_
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QMetaObject
operator|::
name|metacall
argument_list|(
name|object
argument_list|,
name|QMetaObject
operator|::
name|InvokeMetaMethod
argument_list|,
name|method_offset_
operator|+
name|method_relative_
argument_list|,
name|args_
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QObject     \brief The QObject class is the base class of all Qt objects.      \ingroup objectmodel      \reentrant      QObject is the heart of the Qt \l{Object Model}. The central     feature in this model is a very powerful mechanism for seamless     object communication called \l{signals and slots}. You can     connect a signal to a slot with connect() and destroy the     connection with disconnect(). To avoid never ending notification     loops you can temporarily block signals with blockSignals(). The     protected functions connectNotify() and disconnectNotify() make     it possible to track connections.      QObjects organize themselves in \l {Object Trees& Ownership}     {object trees}. When you create a QObject with another object as     parent, the object will automatically add itself to the parent's     children() list. The parent takes ownership of the object; i.e.,     it will automatically delete its children in its destructor. You     can look for an object by name and optionally type using     findChild() or findChildren().      Every object has an objectName() and its class name can be found     via the corresponding metaObject() (see QMetaObject::className()).     You can determine whether the object's class inherits another     class in the QObject inheritance hierarchy by using the     inherits() function.      When an object is deleted, it emits a destroyed() signal. You can     catch this signal to avoid dangling references to QObjects.      QObjects can receive events through event() and filter the events     of other objects. See installEventFilter() and eventFilter() for     details. A convenience handler, childEvent(), can be reimplemented     to catch child events.      Events are delivered in the thread in which the object was     created; see \l{Thread Support in Qt} and thread() for details.     Note that event processing is not done at all for QObjects with no     thread affinity (thread() returns zero). Use the moveToThread()     function to change the thread affinity for an object and its     children (the object cannot be moved if it has a parent).      Last but not least, QObject provides the basic timer support in     Qt; see QTimer for high-level support for timers.      Notice that the Q_OBJECT macro is mandatory for any object that     implements signals, slots or properties. You also need to run the     \l{moc}{Meta Object Compiler} on the source file. We strongly     recommend the use of this macro in all subclasses of QObject     regardless of whether or not they actually use signals, slots and     properties, since failure to do so may lead certain functions to     exhibit strange behavior.      All Qt widgets inherit QObject. The convenience function     isWidgetType() returns whether an object is actually a widget. It     is much faster than     \l{qobject_cast()}{qobject_cast}<QWidget *>(\e{obj}) or     \e{obj}->\l{inherits()}{inherits}("QWidget").      Some QObject functions, e.g. children(), return a QObjectList.     QObjectList is a typedef for QList<QObject *>.      \target No copy constructor     \section1 No copy constructor or assignment operator      QObject has neither a copy constructor nor an assignment operator.     This is by design. Actually, they are declared, but in a     \c{private} section with the macro Q_DISABLE_COPY(). In fact, all     Qt classes derived from QObject (direct or indirect) use this     macro to declare their copy constructor and assignment operator to     be private. The reasoning is found in the discussion on     \l{Identity vs Value} {Identity vs Value} on the Qt \l{Object     Model} page.      The main consequence is that you should use pointers to QObject     (or to your QObject subclass) where you might otherwise be tempted     to use your QObject subclass as a value. For example, without a     copy constructor, you can't use a subclass of QObject as the value     to be stored in one of the container classes. You must store     pointers.      \section1 Auto-Connection      Qt's meta-object system provides a mechanism to automatically connect     signals and slots between QObject subclasses and their children. As long     as objects are defined with suitable object names, and slots follow a     simple naming convention, this connection can be performed at run-time     by the QMetaObject::connectSlotsByName() function.      \l uic generates code that invokes this function to enable     auto-connection to be performed between widgets on forms created     with \e{Qt Designer}. More information about using auto-connection with \e{Qt Designer} is     given in the \l{Using a Designer UI File in Your Application} section of     the \e{Qt Designer} manual.      \section1 Dynamic Properties      From Qt 4.2, dynamic properties can be added to and removed from QObject     instances at run-time. Dynamic properties do not need to be declared at     compile-time, yet they provide the same advantages as static properties     and are manipulated using the same API - using property() to read them     and setProperty() to write them.      From Qt 4.3, dynamic properties are supported by     \l{Qt Designer's Widget Editing Mode#The Property Editor}{Qt Designer},     and both standard Qt widgets and user-created forms can be given dynamic     properties.      \section1 Internationalization (i18n)      All QObject subclasses support Qt's translation features, making it possible     to translate an application's user interface into different languages.      To make user-visible text translatable, it must be wrapped in calls to     the tr() function. This is explained in detail in the     \l{Writing Source Code for Translation} document.      \sa QMetaObject, QPointer, QObjectCleanupHandler, Q_DISABLE_COPY()     \sa {Object Trees& Ownership} */
end_comment
begin_comment
comment|/*!     \relates QObject      Returns a pointer to the object named \a name that inherits \a     type and with a given \a parent.      Returns 0 if there is no such child.      \snippet code/src_corelib_kernel_qobject.cpp 0 */
end_comment
begin_function
DECL|function|qt_find_obj_child
name|void
modifier|*
name|qt_find_obj_child
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QObjectList
name|list
init|=
name|parent
operator|->
name|children
argument_list|()
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QObject
modifier|*
name|obj
init|=
name|list
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|obj
operator|->
name|objectName
argument_list|()
operator|&&
name|obj
operator|->
name|inherits
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|obj
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   QObject member functions  *****************************************************************************/
end_comment
begin_comment
comment|// check the constructor's parent thread argument
end_comment
begin_function
DECL|function|check_parent_thread
specifier|static
name|bool
name|check_parent_thread
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|,
name|QThreadData
modifier|*
name|parentThreadData
parameter_list|,
name|QThreadData
modifier|*
name|currentThreadData
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|&&
name|parentThreadData
operator|!=
name|currentThreadData
condition|)
block|{
name|QThread
modifier|*
name|parentThread
init|=
name|parentThreadData
operator|->
name|thread
decl_stmt|;
name|QThread
modifier|*
name|currentThread
init|=
name|currentThreadData
operator|->
name|thread
decl_stmt|;
name|qWarning
argument_list|(
literal|"QObject: Cannot create children for a parent that is in a different thread.\n"
literal|"(Parent is %s(%p), parent's thread is %s(%p), current thread is %s(%p)"
argument_list|,
name|parent
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|parent
argument_list|,
name|parentThread
condition|?
name|parentThread
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
else|:
literal|"QThread"
argument_list|,
name|parentThread
argument_list|,
name|currentThread
condition|?
name|currentThread
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
else|:
literal|"QThread"
argument_list|,
name|currentThread
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs an object with parent object \a parent.      The parent of an object may be viewed as the object's owner. For     instance, a \l{QDialog}{dialog box} is the parent of the \uicontrol{OK}     and \uicontrol{Cancel} buttons it contains.      The destructor of a parent object destroys all child objects.      Setting \a parent to 0 constructs an object with no parent. If the     object is a widget, it will become a top-level window.      \sa parent(), findChild(), findChildren() */
end_comment
begin_constructor
DECL|function|QObject
name|QObject
operator|::
name|QObject
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QObjectPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
name|d
operator|->
name|threadData
operator|=
operator|(
name|parent
operator|&&
operator|!
name|parent
operator|->
name|thread
argument_list|()
operator|)
condition|?
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
else|:
name|QThreadData
operator|::
name|current
argument_list|()
expr_stmt|;
name|d
operator|->
name|threadData
operator|->
name|ref
argument_list|()
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
name|QT_TRY
block|{
if|if
condition|(
operator|!
name|check_parent_thread
argument_list|(
name|parent
argument_list|,
name|parent
condition|?
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
else|:
literal|0
argument_list|,
name|d
operator|->
name|threadData
argument_list|)
condition|)
name|parent
operator|=
literal|0
expr_stmt|;
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
name|d
operator|->
name|threadData
operator|->
name|deref
argument_list|()
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
block|}
name|qt_addObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \internal  */
end_comment
begin_constructor
DECL|function|QObject
name|QObject
operator|::
name|QObject
parameter_list|(
name|QObjectPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|&
name|dd
argument_list|)
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
name|d_ptr
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
name|d
operator|->
name|threadData
operator|=
operator|(
name|parent
operator|&&
operator|!
name|parent
operator|->
name|thread
argument_list|()
operator|)
condition|?
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
else|:
name|QThreadData
operator|::
name|current
argument_list|()
expr_stmt|;
name|d
operator|->
name|threadData
operator|->
name|ref
argument_list|()
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
name|QT_TRY
block|{
if|if
condition|(
operator|!
name|check_parent_thread
argument_list|(
name|parent
argument_list|,
name|parent
condition|?
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
else|:
literal|0
argument_list|,
name|d
operator|->
name|threadData
argument_list|)
condition|)
name|parent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|isWidget
condition|)
block|{
if|if
condition|(
name|parent
condition|)
block|{
name|d
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|d
operator|->
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|append
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// no events sent here, this is done at the end of the QWidget constructor
block|}
else|else
block|{
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
name|d
operator|->
name|threadData
operator|->
name|deref
argument_list|()
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
block|}
name|qt_addObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the object, deleting all its child objects.      All signals to and from the object are automatically disconnected, and     any pending posted events for the object are removed from the event     queue. However, it is often safer to use deleteLater() rather than     deleting a QObject subclass directly.      \warning All child objects are deleted. If any of these objects     are on the stack or global, sooner or later your program will     crash. We do not recommend holding pointers to child objects from     outside the parent. If you still do, the destroyed() signal gives     you an opportunity to detect when an object is destroyed.      \warning Deleting a QObject while pending events are waiting to     be delivered can cause a crash. You must not delete the QObject     directly if it exists in a different thread than the one currently     executing. Use deleteLater() instead, which will cause the event     loop to delete the object after all pending events have been     delivered to it.      \sa deleteLater() */
end_comment
begin_destructor
DECL|function|~QObject
name|QObject
operator|::
name|~
name|QObject
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
name|d
operator|->
name|wasDeleted
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|blockSig
operator|=
literal|0
expr_stmt|;
comment|// unblock signals so we always emit destroyed()
name|QtSharedPointer
operator|::
name|ExternalRefCountData
modifier|*
name|sharedRefcount
init|=
name|d
operator|->
name|sharedRefcount
operator|.
name|load
argument_list|()
decl_stmt|;
if|if
condition|(
name|sharedRefcount
condition|)
block|{
if|if
condition|(
name|sharedRefcount
operator|->
name|strongref
operator|.
name|load
argument_list|()
operator|>
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject: shared QObject was deleted directly. The program is malformed and may crash."
argument_list|)
expr_stmt|;
comment|// but continue deleting, it's too late to stop anyway
block|}
comment|// indicate to all QWeakPointers that this QObject has now been deleted
name|sharedRefcount
operator|->
name|strongref
operator|.
name|store
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sharedRefcount
operator|->
name|weakref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|sharedRefcount
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|isSignalConnected
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|QT_TRY
block|{
emit|emit
name|destroyed
argument_list|(
name|this
argument_list|)
emit|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{
comment|// all the signal/slots connections are still in place - if we don't
comment|// quit now, we will crash pretty soon.
name|qWarning
argument_list|(
literal|"Detected an unexpected exception in ~QObject while emitting destroyed()."
argument_list|)
expr_stmt|;
name|QT_RETHROW
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|declarativeData
condition|)
name|QAbstractDeclarativeData
operator|::
name|destroyed
argument_list|(
name|d
operator|->
name|declarativeData
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// set ref to zero to indicate that this object has been deleted
if|if
condition|(
name|d
operator|->
name|currentSender
operator|!=
literal|0
condition|)
name|d
operator|->
name|currentSender
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|currentSender
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connectionLists
operator|||
name|d
operator|->
name|senders
condition|)
block|{
name|QMutex
modifier|*
name|signalSlotMutex
init|=
name|signalSlotLock
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QMutexLocker
name|locker
argument_list|(
name|signalSlotMutex
argument_list|)
decl_stmt|;
comment|// disconnect all receivers
if|if
condition|(
name|d
operator|->
name|connectionLists
condition|)
block|{
operator|++
name|d
operator|->
name|connectionLists
operator|->
name|inUse
expr_stmt|;
name|int
name|connectionListsCount
init|=
name|d
operator|->
name|connectionLists
operator|->
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|signal
init|=
operator|-
literal|1
init|;
name|signal
operator|<
name|connectionListsCount
condition|;
operator|++
name|signal
control|)
block|{
name|QObjectPrivate
operator|::
name|ConnectionList
modifier|&
name|connectionList
init|=
operator|(
operator|*
name|d
operator|->
name|connectionLists
operator|)
index|[
name|signal
index|]
decl_stmt|;
while|while
condition|(
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
init|=
name|connectionList
operator|.
name|first
condition|)
block|{
if|if
condition|(
operator|!
name|c
operator|->
name|receiver
condition|)
block|{
name|connectionList
operator|.
name|first
operator|=
name|c
operator|->
name|nextConnectionList
expr_stmt|;
name|c
operator|->
name|deref
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|QMutex
modifier|*
name|m
init|=
name|signalSlotLock
argument_list|(
name|c
operator|->
name|receiver
argument_list|)
decl_stmt|;
name|bool
name|needToUnlock
init|=
name|QOrderedMutexLocker
operator|::
name|relock
argument_list|(
name|signalSlotMutex
argument_list|,
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|receiver
condition|)
block|{
operator|*
name|c
operator|->
name|prev
operator|=
name|c
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|next
condition|)
name|c
operator|->
name|next
operator|->
name|prev
operator|=
name|c
operator|->
name|prev
expr_stmt|;
block|}
name|c
operator|->
name|receiver
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needToUnlock
condition|)
name|m
operator|->
name|unlock
argument_list|()
expr_stmt|;
name|connectionList
operator|.
name|first
operator|=
name|c
operator|->
name|nextConnectionList
expr_stmt|;
name|c
operator|->
name|deref
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|--
name|d
operator|->
name|connectionLists
operator|->
name|inUse
condition|)
block|{
operator|delete
name|d
operator|->
name|connectionLists
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|connectionLists
operator|->
name|orphaned
operator|=
literal|true
expr_stmt|;
block|}
name|d
operator|->
name|connectionLists
operator|=
literal|0
expr_stmt|;
block|}
comment|// disconnect all senders
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|node
init|=
name|d
operator|->
name|senders
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|QObject
modifier|*
name|sender
init|=
name|node
operator|->
name|sender
decl_stmt|;
name|QMutex
modifier|*
name|m
init|=
name|signalSlotLock
argument_list|(
name|sender
argument_list|)
decl_stmt|;
name|node
operator|->
name|prev
operator|=
operator|&
name|node
expr_stmt|;
name|bool
name|needToUnlock
init|=
name|QOrderedMutexLocker
operator|::
name|relock
argument_list|(
name|signalSlotMutex
argument_list|,
name|m
argument_list|)
decl_stmt|;
comment|//the node has maybe been removed while the mutex was unlocked in relock?
if|if
condition|(
operator|!
name|node
operator|||
name|node
operator|->
name|sender
operator|!=
name|sender
condition|)
block|{
name|m
operator|->
name|unlock
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|node
operator|->
name|receiver
operator|=
literal|0
expr_stmt|;
name|QObjectConnectionListVector
modifier|*
name|senderLists
init|=
name|sender
operator|->
name|d_func
argument_list|()
operator|->
name|connectionLists
decl_stmt|;
if|if
condition|(
name|senderLists
condition|)
name|senderLists
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|needToUnlock
condition|)
name|m
operator|->
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|deleteChildren
argument_list|()
expr_stmt|;
name|qt_removeObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|parent
condition|)
comment|// remove it from parent object
name|d
operator|->
name|setParent_helper
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_destructor
DECL|function|~Connection
name|QObjectPrivate
operator|::
name|Connection
operator|::
name|~
name|Connection
parameter_list|()
block|{
if|if
condition|(
name|ownArgumentTypes
condition|)
block|{
specifier|const
name|int
modifier|*
name|v
init|=
name|argumentTypes
operator|.
name|load
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|!=
operator|&
name|DIRECT_CONNECTION_ONLY
condition|)
operator|delete
index|[]
name|v
expr_stmt|;
block|}
if|if
condition|(
name|isSlotObject
operator|&&
operator|!
name|slotObj
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|slotObj
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn QMetaObject *QObject::metaObject() const      Returns a pointer to the meta-object of this object.      A meta-object contains information about a class that inherits     QObject, e.g. class name, superclass name, properties, signals and     slots. Every QObject subclass that contains the Q_OBJECT macro will have a     meta-object.      The meta-object information is required by the signal/slot     connection mechanism and the property system. The inherits()     function also makes use of the meta-object.      If you have no pointer to an actual object instance but still     want to access the meta-object of a class, you can use \l     staticMetaObject.      Example:      \snippet code/src_corelib_kernel_qobject.cpp 1      \sa staticMetaObject */
end_comment
begin_comment
comment|/*!     \variable QObject::staticMetaObject      This variable stores the meta-object for the class.      A meta-object contains information about a class that inherits     QObject, e.g. class name, superclass name, properties, signals and     slots. Every class that contains the Q_OBJECT macro will also have     a meta-object.      The meta-object information is required by the signal/slot     connection mechanism and the property system. The inherits()     function also makes use of the meta-object.      If you have a pointer to an object, you can use metaObject() to     retrieve the meta-object associated with that object.      Example:      \snippet code/src_corelib_kernel_qobject.cpp 2      \sa metaObject() */
end_comment
begin_comment
comment|/*! \fn T *qobject_cast<T *>(QObject *object)     \relates QObject      Returns the given \a object cast to type T if the object is of type     T (or of a subclass); otherwise returns 0.  If \a object is 0 then      it will also return 0.      The class T must inherit (directly or indirectly) QObject and be     declared with the \l Q_OBJECT macro.      A class is considered to inherit itself.      Example:      \snippet code/src_corelib_kernel_qobject.cpp 3      The qobject_cast() function behaves similarly to the standard C++     \c dynamic_cast(), with the advantages that it doesn't require     RTTI support and it works across dynamic library boundaries.      qobject_cast() can also be used in conjunction with interfaces;     see the \l{tools/plugandpaint}{Plug& Paint} example for details.      \warning If T isn't declared with the Q_OBJECT macro, this     function's return value is undefined.      \sa QObject::inherits() */
end_comment
begin_comment
comment|/*!     \fn bool QObject::inherits(const char *className) const      Returns true if this object is an instance of a class that     inherits \a className or a QObject subclass that inherits \a     className; otherwise returns false.      A class is considered to inherit itself.      Example:      \snippet code/src_corelib_kernel_qobject.cpp 4      If you need to determine whether an object is an instance of a particular     class for the purpose of casting it, consider using qobject_cast<Type *>(object)     instead.      \sa metaObject(), qobject_cast() */
end_comment
begin_comment
comment|/*!     \property QObject::objectName      \brief the name of this object      You can find an object by name (and type) using findChild().     You can find a set of objects with findChildren().      \snippet code/src_corelib_kernel_qobject.cpp 5      By default, this property contains an empty string.      \sa metaObject(), QMetaObject::className() */
end_comment
begin_function
DECL|function|objectName
name|QString
name|QObject
operator|::
name|objectName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QObject
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|objectName
return|;
block|}
end_function
begin_comment
comment|/*     Sets the object's name to \a name. */
end_comment
begin_function
DECL|function|setObjectName
name|void
name|QObject
operator|::
name|setObjectName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|objectName
operator|!=
name|name
condition|)
block|{
name|d
operator|->
name|objectName
operator|=
name|name
expr_stmt|;
emit|emit
name|objectNameChanged
argument_list|(
name|d
operator|->
name|objectName
argument_list|)
emit|;
block|}
block|}
end_function
begin_comment
comment|/*! \fn void QObject::objectNameChanged(const QString&objectName)      This signal is emitted after the object's name has been changed. The new object name is passed as \a objectName.      \sa QObject::objectName */
end_comment
begin_comment
comment|/*!     \fn bool QObject::isWidgetType() const      Returns true if the object is a widget; otherwise returns false.      Calling this function is equivalent to calling     inherits("QWidget"), except that it is much faster. */
end_comment
begin_comment
comment|/*!     This virtual function receives events to an object and should     return true if the event \a e was recognized and processed.      The event() function can be reimplemented to customize the     behavior of an object.      \sa installEventFilter(), timerEvent(), QApplication::sendEvent(),     QApplication::postEvent(), QWidget::event() */
end_comment
begin_function
DECL|function|event
name|bool
name|QObject
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QEvent
operator|::
name|Timer
case|:
name|timerEvent
argument_list|(
operator|(
name|QTimerEvent
operator|*
operator|)
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|ChildAdded
case|:
case|case
name|QEvent
operator|::
name|ChildPolished
case|:
case|case
name|QEvent
operator|::
name|ChildRemoved
case|:
name|childEvent
argument_list|(
operator|(
name|QChildEvent
operator|*
operator|)
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|DeferredDelete
case|:
name|qDeleteInEventHandler
argument_list|(
name|this
argument_list|)
expr_stmt|;
break|break;
case|case
name|QEvent
operator|::
name|MetaCall
case|:
block|{
name|QMetaCallEvent
modifier|*
name|mce
init|=
cast|static_cast
argument_list|<
name|QMetaCallEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QConnectionSenderSwitcher
name|sw
argument_list|(
name|this
argument_list|,
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|mce
operator|->
name|sender
argument_list|()
argument_list|)
argument_list|,
name|mce
operator|->
name|signalId
argument_list|()
argument_list|)
decl_stmt|;
name|mce
operator|->
name|placeMetaCall
argument_list|(
name|this
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QEvent
operator|::
name|ThreadChange
case|:
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
name|QThreadData
modifier|*
name|threadData
init|=
name|d
operator|->
name|threadData
decl_stmt|;
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
init|=
name|threadData
operator|->
name|eventDispatcher
decl_stmt|;
if|if
condition|(
name|eventDispatcher
condition|)
block|{
name|QList
argument_list|<
name|QAbstractEventDispatcher
operator|::
name|TimerInfo
argument_list|>
name|timers
init|=
name|eventDispatcher
operator|->
name|registeredTimers
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|timers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// do not to release our timer ids back to the pool (since the timer ids are moving to a new thread).
name|eventDispatcher
operator|->
name|unregisterTimers
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_reregisterTimers"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|,
name|Q_ARG
argument_list|(
name|void
operator|*
argument_list|,
operator|(
operator|new
name|QList
argument_list|<
name|QAbstractEventDispatcher
operator|::
name|TimerInfo
argument_list|>
argument_list|(
name|timers
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|>=
name|QEvent
operator|::
name|User
condition|)
block|{
name|customEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QObject::timerEvent(QTimerEvent *event)      This event handler can be reimplemented in a subclass to receive     timer events for the object.      QTimer provides a higher-level interface to the timer     functionality, and also more general information about timers. The     timer event is passed in the \a event parameter.      \sa startTimer(), killTimer(), event() */
end_comment
begin_function
DECL|function|timerEvent
name|void
name|QObject
operator|::
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     This event handler can be reimplemented in a subclass to receive     child events. The event is passed in the \a event parameter.      QEvent::ChildAdded and QEvent::ChildRemoved events are sent to     objects when children are added or removed. In both cases you can     only rely on the child being a QObject, or if isWidgetType()     returns true, a QWidget. (This is because, in the     \l{QEvent::ChildAdded}{ChildAdded} case, the child is not yet     fully constructed, and in the \l{QEvent::ChildRemoved}{ChildRemoved}     case it might have been destructed already).      QEvent::ChildPolished events are sent to widgets when children     are polished, or when polished children are added. If you receive     a child polished event, the child's construction is usually     completed. However, this is not guaranteed, and multiple polish     events may be delivered during the execution of a widget's     constructor.      For every child widget, you receive one     \l{QEvent::ChildAdded}{ChildAdded} event, zero or more     \l{QEvent::ChildPolished}{ChildPolished} events, and one     \l{QEvent::ChildRemoved}{ChildRemoved} event.      The \l{QEvent::ChildPolished}{ChildPolished} event is omitted if     a child is removed immediately after it is added. If a child is     polished several times during construction and destruction, you     may receive several child polished events for the same child,     each time with a different virtual table.      \sa event() */
end_comment
begin_function
DECL|function|childEvent
name|void
name|QObject
operator|::
name|childEvent
parameter_list|(
name|QChildEvent
modifier|*
comment|/* event */
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     This event handler can be reimplemented in a subclass to receive     custom events. Custom events are user-defined events with a type     value at least as large as the QEvent::User item of the     QEvent::Type enum, and is typically a QEvent subclass. The event     is passed in the \a event parameter.      \sa event(), QEvent */
end_comment
begin_function
DECL|function|customEvent
name|void
name|QObject
operator|::
name|customEvent
parameter_list|(
name|QEvent
modifier|*
comment|/* event */
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     Filters events if this object has been installed as an event     filter for the \a watched object.      In your reimplementation of this function, if you want to filter     the \a event out, i.e. stop it being handled further, return     true; otherwise return false.      Example:     \snippet code/src_corelib_kernel_qobject.cpp 6      Notice in the example above that unhandled events are passed to     the base class's eventFilter() function, since the base class     might have reimplemented eventFilter() for its own internal     purposes.      \warning If you delete the receiver object in this function, be     sure to return true. Otherwise, Qt will forward the event to the     deleted object and the program might crash.      \sa installEventFilter() */
end_comment
begin_function
DECL|function|eventFilter
name|bool
name|QObject
operator|::
name|eventFilter
parameter_list|(
name|QObject
modifier|*
comment|/* watched */
parameter_list|,
name|QEvent
modifier|*
comment|/* event */
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QObject::signalsBlocked() const      Returns true if signals are blocked; otherwise returns false.      Signals are not blocked by default.      \sa blockSignals() */
end_comment
begin_comment
comment|/*!     If \a block is true, signals emitted by this object are blocked     (i.e., emitting a signal will not invoke anything connected to it).     If \a block is false, no such blocking will occur.      The return value is the previous value of signalsBlocked().      Note that the destroyed() signal will be emitted even if the signals     for this object have been blocked.      \sa signalsBlocked() */
end_comment
begin_function
DECL|function|blockSignals
name|bool
name|QObject
operator|::
name|blockSignals
parameter_list|(
name|bool
name|block
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
name|bool
name|previous
init|=
name|d
operator|->
name|blockSig
decl_stmt|;
name|d
operator|->
name|blockSig
operator|=
name|block
expr_stmt|;
return|return
name|previous
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the thread in which the object lives.      \sa moveToThread() */
end_comment
begin_function
DECL|function|thread
name|QThread
modifier|*
name|QObject
operator|::
name|thread
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|threadData
operator|->
name|thread
return|;
block|}
end_function
begin_comment
comment|/*!     Changes the thread affinity for this object and its children. The     object cannot be moved if it has a parent. Event processing will     continue in the \a targetThread.      To move an object to the main thread, use QApplication::instance()     to retrieve a pointer to the current application, and then use     QApplication::thread() to retrieve the thread in which the     application lives. For example:      \snippet code/src_corelib_kernel_qobject.cpp 7      If \a targetThread is zero, all event processing for this object     and its children stops.      Note that all active timers for the object will be reset. The     timers are first stopped in the current thread and restarted (with     the same interval) in the \a targetThread. As a result, constantly     moving an object between threads can postpone timer events     indefinitely.      A QEvent::ThreadChange event is sent to this object just before     the thread affinity is changed. You can handle this event to     perform any special processing. Note that any new events that are     posted to this object will be handled in the \a targetThread.      \warning This function is \e not thread-safe; the current thread     must be same as the current thread affinity. In other words, this     function can only "push" an object from the current thread to     another thread, it cannot "pull" an object from any arbitrary     thread to the current thread.      \sa thread()  */
end_comment
begin_function
DECL|function|moveToThread
name|void
name|QObject
operator|::
name|moveToThread
parameter_list|(
name|QThread
modifier|*
name|targetThread
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|threadData
operator|->
name|thread
operator|==
name|targetThread
condition|)
block|{
comment|// object is already in this thread
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|parent
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::moveToThread: Cannot move objects with a parent"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|isWidget
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::moveToThread: Widgets cannot be moved to a new thread"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QThreadData
modifier|*
name|currentData
init|=
name|QThreadData
operator|::
name|current
argument_list|()
decl_stmt|;
name|QThreadData
modifier|*
name|targetData
init|=
name|targetThread
condition|?
name|QThreadData
operator|::
name|get2
argument_list|(
name|targetThread
argument_list|)
else|:
operator|new
name|QThreadData
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|threadData
operator|->
name|thread
operator|==
literal|0
operator|&&
name|currentData
operator|==
name|targetData
condition|)
block|{
comment|// one exception to the rule: we allow moving objects with no thread affinity to the current thread
name|currentData
operator|=
name|d
operator|->
name|threadData
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|threadData
operator|!=
name|currentData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::moveToThread: Current thread (%p) is not the object's thread (%p).\n"
literal|"Cannot move to target thread (%p)\n"
argument_list|,
name|currentData
operator|->
name|thread
argument_list|,
name|d
operator|->
name|threadData
operator|->
name|thread
argument_list|,
name|targetData
operator|->
name|thread
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_MAC
name|qWarning
argument_list|(
literal|"On Mac OS X, you might be loading two sets of Qt binaries into the same process. "
literal|"Check that all plugins are compiled against the right Qt binaries. Export "
literal|"DYLD_PRINT_LIBRARIES=1 and check that only one set of binaries are being loaded."
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|// prepare to move
name|d
operator|->
name|moveToThread_helper
argument_list|()
expr_stmt|;
name|QOrderedMutexLocker
name|locker
argument_list|(
operator|&
name|currentData
operator|->
name|postEventList
operator|.
name|mutex
argument_list|,
operator|&
name|targetData
operator|->
name|postEventList
operator|.
name|mutex
argument_list|)
decl_stmt|;
comment|// keep currentData alive (since we've got it locked)
name|currentData
operator|->
name|ref
argument_list|()
expr_stmt|;
comment|// move the object
name|d_func
argument_list|()
operator|->
name|setThreadData_helper
argument_list|(
name|currentData
argument_list|,
name|targetData
argument_list|)
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// now currentData can commit suicide if it wants to
name|currentData
operator|->
name|deref
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|moveToThread_helper
name|void
name|QObjectPrivate
operator|::
name|moveToThread_helper
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ThreadChange
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|q
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QObject
modifier|*
name|child
init|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|child
operator|->
name|d_func
argument_list|()
operator|->
name|moveToThread_helper
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setThreadData_helper
name|void
name|QObjectPrivate
operator|::
name|setThreadData_helper
parameter_list|(
name|QThreadData
modifier|*
name|currentData
parameter_list|,
name|QThreadData
modifier|*
name|targetData
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
comment|// move posted events
name|int
name|eventsMoved
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|currentData
operator|->
name|postEventList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPostEvent
modifier|&
name|pe
init|=
name|currentData
operator|->
name|postEventList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pe
operator|.
name|event
condition|)
continue|continue;
if|if
condition|(
name|pe
operator|.
name|receiver
operator|==
name|q
condition|)
block|{
comment|// move this post event to the targetList
name|targetData
operator|->
name|postEventList
operator|.
name|addEvent
argument_list|(
name|pe
argument_list|)
expr_stmt|;
cast|const_cast
argument_list|<
name|QPostEvent
operator|&
argument_list|>
argument_list|(
name|pe
argument_list|)
operator|.
name|event
operator|=
literal|0
expr_stmt|;
operator|++
name|eventsMoved
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eventsMoved
operator|>
literal|0
operator|&&
name|targetData
operator|->
name|eventDispatcher
condition|)
block|{
name|targetData
operator|->
name|canWait
operator|=
literal|false
expr_stmt|;
name|targetData
operator|->
name|eventDispatcher
operator|->
name|wakeUp
argument_list|()
expr_stmt|;
block|}
comment|// the current emitting thread shouldn't restore currentSender after calling moveToThread()
if|if
condition|(
name|currentSender
condition|)
name|currentSender
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
name|currentSender
operator|=
literal|0
expr_stmt|;
comment|// set new thread data
name|targetData
operator|->
name|ref
argument_list|()
expr_stmt|;
name|threadData
operator|->
name|deref
argument_list|()
expr_stmt|;
name|threadData
operator|=
name|targetData
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QObject
modifier|*
name|child
init|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|child
operator|->
name|d_func
argument_list|()
operator|->
name|setThreadData_helper
argument_list|(
name|currentData
argument_list|,
name|targetData
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_reregisterTimers
name|void
name|QObjectPrivate
operator|::
name|_q_reregisterTimers
parameter_list|(
name|void
modifier|*
name|pointer
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QAbstractEventDispatcher
operator|::
name|TimerInfo
argument_list|>
modifier|*
name|timerList
init|=
cast|reinterpret_cast
argument_list|<
name|QList
argument_list|<
name|QAbstractEventDispatcher
operator|::
name|TimerInfo
argument_list|>
operator|*
argument_list|>
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
name|QAbstractEventDispatcher
modifier|*
name|eventDispatcher
init|=
name|threadData
operator|->
name|eventDispatcher
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|timerList
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QAbstractEventDispatcher
operator|::
name|TimerInfo
modifier|&
name|ti
init|=
name|timerList
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|eventDispatcher
operator|->
name|registerTimer
argument_list|(
name|ti
operator|.
name|timerId
argument_list|,
name|ti
operator|.
name|interval
argument_list|,
name|ti
operator|.
name|timerType
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
operator|delete
name|timerList
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// The timer flag hasTimer is set when startTimer is called.
end_comment
begin_comment
comment|// It is not reset when killing the timer because more than
end_comment
begin_comment
comment|// one timer might be active.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|/*!     Starts a timer and returns a timer identifier, or returns zero if     it could not start a timer.      A timer event will occur every \a interval milliseconds until     killTimer() is called. If \a interval is 0, then the timer event     occurs once every time there are no more window system events to     process.      The virtual timerEvent() function is called with the QTimerEvent     event parameter class when a timer event occurs. Reimplement this     function to get timer events.      If multiple timers are running, the QTimerEvent::timerId() can be     used to find out which timer was activated.      Example:      \snippet code/src_corelib_kernel_qobject.cpp 8      Note that QTimer's accuracy depends on the underlying operating system and     hardware. The \a timerType argument allows you to customize the accuracy of     the timer. See Qt::TimerType for information on the different timer types.     Most platforms support an accuracy of 20 milliseconds; some provide more.     If Qt is unable to deliver the requested number of timer events, it will     silently discard some.      The QTimer class provides a high-level programming interface with     single-shot timers and timer signals instead of events. There is     also a QBasicTimer class that is more lightweight than QTimer and     less clumsy than using timer IDs directly.      \sa timerEvent(), killTimer(), QTimer::singleShot() */
end_comment
begin_function
DECL|function|startTimer
name|int
name|QObject
operator|::
name|startTimer
parameter_list|(
name|int
name|interval
parameter_list|,
name|Qt
operator|::
name|TimerType
name|timerType
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|interval
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::startTimer: QTimer cannot have a negative interval"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::startTimer: QTimer can only be used with threads started with QThread"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|timerId
init|=
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|->
name|registerTimer
argument_list|(
name|interval
argument_list|,
name|timerType
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|d
operator|->
name|runningTimers
operator|.
name|append
argument_list|(
name|timerId
argument_list|)
expr_stmt|;
return|return
name|timerId
return|;
block|}
end_function
begin_comment
comment|/*!     Kills the timer with timer identifier, \a id.      The timer identifier is returned by startTimer() when a timer     event is started.      \sa timerEvent(), startTimer() */
end_comment
begin_function
DECL|function|killTimer
name|void
name|QObject
operator|::
name|killTimer
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|int
name|at
init|=
name|d
operator|->
name|runningTimers
operator|.
name|indexOf
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|at
operator|==
operator|-
literal|1
condition|)
block|{
comment|// timer isn't owned by this object
name|qWarning
argument_list|(
literal|"QObject::killTimer(): Error: timer id %d is not valid for object %p (%s), timer has not been killed"
argument_list|,
name|id
argument_list|,
name|this
argument_list|,
name|qPrintable
argument_list|(
name|objectName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
condition|)
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|->
name|unregisterTimer
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|d
operator|->
name|runningTimers
operator|.
name|remove
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|QAbstractEventDispatcherPrivate
operator|::
name|releaseTimerId
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QObject *QObject::parent() const      Returns a pointer to the parent object.      \sa children() */
end_comment
begin_comment
comment|/*!     \fn const QObjectList&QObject::children() const      Returns a list of child objects.     The QObjectList class is defined in the \c{<QObject>} header     file as the following:      \quotefromfile kernel/qobject.h     \skipto /typedef .*QObjectList/     \printuntil QObjectList      The first child added is the \l{QList::first()}{first} object in     the list and the last child added is the \l{QList::last()}{last}     object in the list, i.e. new children are appended at the end.      Note that the list order changes when QWidget children are     \l{QWidget::raise()}{raised} or \l{QWidget::lower()}{lowered}. A     widget that is raised becomes the last object in the list, and a     widget that is lowered becomes the first object in the list.      \sa findChild(), findChildren(), parent(), setParent() */
end_comment
begin_comment
comment|/*!     \fn T *QObject::findChild(const QString&name, Qt::FindChildOptions options) const      Returns the child of this object that can be cast into type T and     that is called \a name, or 0 if there is no such object.     Omitting the \a name argument causes all object names to be matched.     The search is performed recursively, unless \a options specifies the     option FindDirectChildrenOnly.      If there is more than one child matching the search, the most     direct ancestor is returned. If there are several direct     ancestors, it is undefined which one will be returned. In that     case, findChildren() should be used.      This example returns a child \l{QPushButton} of \c{parentWidget}     named \c{"button1"}, even if the button isn't a direct child of     the parent:      \snippet code/src_corelib_kernel_qobject.cpp 10      This example returns a \l{QListWidget} child of \c{parentWidget}:      \snippet code/src_corelib_kernel_qobject.cpp 11      This example returns a child \l{QPushButton} of \c{parentWidget}     (its direct parent) named \c{"button1"}:      \snippet code/src_corelib_kernel_qobject.cpp 41      This example returns a \l{QListWidget} child of \c{parentWidget},     its direct parent:      \snippet code/src_corelib_kernel_qobject.cpp 42      \sa findChildren() */
end_comment
begin_comment
comment|/*!     \fn QList<T> QObject::findChildren(const QString&name, Qt::FindChildOptions options) const      Returns all children of this object with the given \a name that can be     cast to type T, or an empty list if there are no such objects.     Omitting the \a name argument causes all object names to be matched.     The search is performed recursively, unless \a options specifies the     option FindDirectChildrenOnly.      The following example shows how to find a list of child \l{QWidget}s of     the specified \c{parentWidget} named \c{widgetname}:      \snippet code/src_corelib_kernel_qobject.cpp 12      This example returns all \c{QPushButton}s that are children of \c{parentWidget}:      \snippet code/src_corelib_kernel_qobject.cpp 13      This example returns all \c{QPushButton}s that are immediate children of \c{parentWidget}:      \snippet code/src_corelib_kernel_qobject.cpp 43      \sa findChild() */
end_comment
begin_comment
comment|/*!     \fn QList<T> QObject::findChildren(const QRegExp&regExp, Qt::FindChildOptions options) const     \overload findChildren()      Returns the children of this object that can be cast to type T     and that have names matching the regular expression \a regExp,     or an empty list if there are no such objects.     The search is performed recursively, unless \a options specifies the     option FindDirectChildrenOnly. */
end_comment
begin_comment
comment|/*!     \fn QList<T> QObject::findChildren(const QRegularExpression&re, Qt::FindChildOptions options) const     \overload findChildren()      \since 5.0      Returns the children of this object that can be cast to type T     and that have names matching the regular expression \a re,     or an empty list if there are no such objects.     The search is performed recursively, unless \a options specifies the     option FindDirectChildrenOnly. */
end_comment
begin_comment
comment|/*!     \fn T qFindChild(const QObject *obj, const QString&name)     \relates QObject     \overload qFindChildren()     \obsolete      This function is equivalent to     \a{obj}->\l{QObject::findChild()}{findChild}<T>(\a name).      \note This function was provided as a workaround for MSVC 6     which did not support member template functions. It is advised     to use the other form in new code.      \sa QObject::findChild() */
end_comment
begin_comment
comment|/*!     \fn QList<T> qFindChildren(const QObject *obj, const QString&name)     \relates QObject     \overload qFindChildren()     \obsolete      This function is equivalent to     \a{obj}->\l{QObject::findChildren()}{findChildren}<T>(\a name).      \note This function was provided as a workaround for MSVC 6     which did not support member template functions. It is advised     to use the other form in new code.      \sa QObject::findChildren() */
end_comment
begin_comment
comment|/*!     \fn QList<T> qFindChildren(const QObject *obj, const QRegExp&regExp)     \relates QObject     \overload qFindChildren()      This function is equivalent to     \a{obj}->\l{QObject::findChildren()}{findChildren}<T>(\a regExp).      \note This function was provided as a workaround for MSVC 6     which did not support member template functions. It is advised     to use the other form in new code.      \sa QObject::findChildren() */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qt_qFindChildren_helper
name|void
name|qt_qFindChildren_helper
parameter_list|(
specifier|const
name|QObject
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QMetaObject
modifier|&
name|mo
parameter_list|,
name|QList
argument_list|<
name|void
modifier|*
argument_list|>
modifier|*
name|list
parameter_list|,
name|Qt
operator|::
name|FindChildOptions
name|options
parameter_list|)
block|{
if|if
condition|(
operator|!
name|parent
operator|||
operator|!
name|list
condition|)
return|return;
specifier|const
name|QObjectList
modifier|&
name|children
init|=
name|parent
operator|->
name|children
argument_list|()
decl_stmt|;
name|QObject
modifier|*
name|obj
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|obj
operator|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mo
operator|.
name|cast
argument_list|(
name|obj
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|isNull
argument_list|()
operator|||
name|obj
operator|->
name|objectName
argument_list|()
operator|==
name|name
condition|)
name|list
operator|->
name|append
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
name|Qt
operator|::
name|FindChildrenRecursively
condition|)
name|qt_qFindChildren_helper
argument_list|(
name|obj
argument_list|,
name|name
argument_list|,
name|mo
argument_list|,
name|list
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qt_qFindChildren_helper
name|void
name|qt_qFindChildren_helper
parameter_list|(
specifier|const
name|QObject
modifier|*
name|parent
parameter_list|,
specifier|const
name|QRegExp
modifier|&
name|re
parameter_list|,
specifier|const
name|QMetaObject
modifier|&
name|mo
parameter_list|,
name|QList
argument_list|<
name|void
modifier|*
argument_list|>
modifier|*
name|list
parameter_list|,
name|Qt
operator|::
name|FindChildOptions
name|options
parameter_list|)
block|{
if|if
condition|(
operator|!
name|parent
operator|||
operator|!
name|list
condition|)
return|return;
specifier|const
name|QObjectList
modifier|&
name|children
init|=
name|parent
operator|->
name|children
argument_list|()
decl_stmt|;
name|QRegExp
name|reCopy
init|=
name|re
decl_stmt|;
name|QObject
modifier|*
name|obj
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|obj
operator|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mo
operator|.
name|cast
argument_list|(
name|obj
argument_list|)
operator|&&
name|reCopy
operator|.
name|indexIn
argument_list|(
name|obj
operator|->
name|objectName
argument_list|()
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|list
operator|->
name|append
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|Qt
operator|::
name|FindChildrenRecursively
condition|)
name|qt_qFindChildren_helper
argument_list|(
name|obj
argument_list|,
name|re
argument_list|,
name|mo
argument_list|,
name|list
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGEXP
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qt_qFindChildren_helper
name|void
name|qt_qFindChildren_helper
parameter_list|(
specifier|const
name|QObject
modifier|*
name|parent
parameter_list|,
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|,
specifier|const
name|QMetaObject
modifier|&
name|mo
parameter_list|,
name|QList
argument_list|<
name|void
modifier|*
argument_list|>
modifier|*
name|list
parameter_list|,
name|Qt
operator|::
name|FindChildOptions
name|options
parameter_list|)
block|{
if|if
condition|(
operator|!
name|parent
operator|||
operator|!
name|list
condition|)
return|return;
specifier|const
name|QObjectList
modifier|&
name|children
init|=
name|parent
operator|->
name|children
argument_list|()
decl_stmt|;
name|QObject
modifier|*
name|obj
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|obj
operator|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mo
operator|.
name|cast
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|QRegularExpressionMatch
name|m
init|=
name|re
operator|.
name|match
argument_list|(
name|obj
operator|->
name|objectName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|hasMatch
argument_list|()
condition|)
name|list
operator|->
name|append
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
name|Qt
operator|::
name|FindChildrenRecursively
condition|)
name|qt_qFindChildren_helper
argument_list|(
name|obj
argument_list|,
name|re
argument_list|,
name|mo
argument_list|,
name|list
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGEXP
end_comment
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|qt_qFindChild_helper
name|QObject
modifier|*
name|qt_qFindChild_helper
parameter_list|(
specifier|const
name|QObject
modifier|*
name|parent
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QMetaObject
modifier|&
name|mo
parameter_list|,
name|Qt
operator|::
name|FindChildOptions
name|options
parameter_list|)
block|{
if|if
condition|(
operator|!
name|parent
condition|)
return|return
literal|0
return|;
specifier|const
name|QObjectList
modifier|&
name|children
init|=
name|parent
operator|->
name|children
argument_list|()
decl_stmt|;
name|QObject
modifier|*
name|obj
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|obj
operator|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mo
operator|.
name|cast
argument_list|(
name|obj
argument_list|)
operator|&&
operator|(
name|name
operator|.
name|isNull
argument_list|()
operator|||
name|obj
operator|->
name|objectName
argument_list|()
operator|==
name|name
operator|)
condition|)
return|return
name|obj
return|;
block|}
if|if
condition|(
name|options
operator|&
name|Qt
operator|::
name|FindChildrenRecursively
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|obj
operator|=
name|qt_qFindChild_helper
argument_list|(
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|name
argument_list|,
name|mo
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
condition|)
return|return
name|obj
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Makes the object a child of \a parent.      \sa QWidget::setParent() */
end_comment
begin_function
DECL|function|setParent
name|void
name|QObject
operator|::
name|setParent
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|d
operator|->
name|isWidget
argument_list|)
expr_stmt|;
name|d
operator|->
name|setParent_helper
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|deleteChildren
name|void
name|QObjectPrivate
operator|::
name|deleteChildren
parameter_list|()
block|{
name|Q_ASSERT_X
argument_list|(
operator|!
name|isDeletingChildren
argument_list|,
literal|"QObjectPrivate::deleteChildren()"
argument_list|,
literal|"isDeletingChildren already set, did this function recurse?"
argument_list|)
expr_stmt|;
name|isDeletingChildren
operator|=
literal|true
expr_stmt|;
comment|// delete children objects
comment|// don't use qDeleteAll as the destructor of the child might
comment|// delete siblings
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|currentChildBeingDeleted
operator|=
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|children
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
operator|delete
name|currentChildBeingDeleted
expr_stmt|;
block|}
name|children
operator|.
name|clear
argument_list|()
expr_stmt|;
name|currentChildBeingDeleted
operator|=
literal|0
expr_stmt|;
name|isDeletingChildren
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setParent_helper
name|void
name|QObjectPrivate
operator|::
name|setParent_helper
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|parent
condition|)
return|return;
if|if
condition|(
name|parent
condition|)
block|{
name|QObjectPrivate
modifier|*
name|parentD
init|=
name|parent
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentD
operator|->
name|isDeletingChildren
operator|&&
name|wasDeleted
operator|&&
name|parentD
operator|->
name|currentChildBeingDeleted
operator|==
name|q
condition|)
block|{
comment|// don't do anything since QObjectPrivate::deleteChildren() already
comment|// cleared our entry in parentD->children.
block|}
else|else
block|{
specifier|const
name|int
name|index
init|=
name|parentD
operator|->
name|children
operator|.
name|indexOf
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentD
operator|->
name|isDeletingChildren
condition|)
block|{
name|parentD
operator|->
name|children
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|parentD
operator|->
name|children
operator|.
name|removeAt
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendChildEvents
operator|&&
name|parentD
operator|->
name|receiveChildEvents
condition|)
block|{
name|QChildEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ChildRemoved
argument_list|,
name|q
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|parent
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|parent
operator|=
name|o
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
comment|// object hierarchies are constrained to a single thread
if|if
condition|(
name|threadData
operator|!=
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::setParent: Cannot set parent, new parent is in a different thread"
argument_list|)
expr_stmt|;
name|parent
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|children
operator|.
name|append
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendChildEvents
operator|&&
name|parent
operator|->
name|d_func
argument_list|()
operator|->
name|receiveChildEvents
condition|)
block|{
if|if
condition|(
operator|!
name|isWidget
condition|)
block|{
name|QChildEvent
name|e
argument_list|(
name|QEvent
operator|::
name|ChildAdded
argument_list|,
name|q
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|parent
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|isDeletingChildren
operator|&&
name|declarativeData
condition|)
name|QAbstractDeclarativeData
operator|::
name|parentChanged
argument_list|(
name|declarativeData
argument_list|,
name|q
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QObject::installEventFilter(QObject *filterObj)      Installs an event filter \a filterObj on this object. For example:     \snippet code/src_corelib_kernel_qobject.cpp 14      An event filter is an object that receives all events that are     sent to this object. The filter can either stop the event or     forward it to this object. The event filter \a filterObj receives     events via its eventFilter() function. The eventFilter() function     must return true if the event should be filtered, (i.e. stopped);     otherwise it must return false.      If multiple event filters are installed on a single object, the     filter that was installed last is activated first.      Here's a \c KeyPressEater class that eats the key presses of its     monitored objects:      \snippet code/src_corelib_kernel_qobject.cpp 15      And here's how to install it on two widgets:      \snippet code/src_corelib_kernel_qobject.cpp 16      The QShortcut class, for example, uses this technique to intercept     shortcut key presses.      \warning If you delete the receiver object in your eventFilter()     function, be sure to return true. If you return false, Qt sends     the event to the deleted object and the program will crash.      Note that the filtering object must be in the same thread as this     object. If \a filterObj is in a different thread, this function does     nothing. If either \a filterObj or this object are moved to a different     thread after calling this function, the event filter will not be     called until both objects have the same thread affinity again (it     is \e not removed).      \sa removeEventFilter(), eventFilter(), event() */
end_comment
begin_function
DECL|function|installEventFilter
name|void
name|QObject
operator|::
name|installEventFilter
parameter_list|(
name|QObject
modifier|*
name|obj
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|threadData
operator|!=
name|obj
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::installEventFilter(): Cannot filter events for objects in a different thread."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// clean up unused items in the list
name|d
operator|->
name|eventFilters
operator|.
name|removeAll
argument_list|(
operator|(
name|QObject
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|eventFilters
operator|.
name|removeAll
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|d
operator|->
name|eventFilters
operator|.
name|prepend
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes an event filter object \a obj from this object. The     request is ignored if such an event filter has not been installed.      All event filters for this object are automatically removed when     this object is destroyed.      It is always safe to remove an event filter, even during event     filter activation (i.e. from the eventFilter() function).      \sa installEventFilter(), eventFilter(), event() */
end_comment
begin_function
DECL|function|removeEventFilter
name|void
name|QObject
operator|::
name|removeEventFilter
parameter_list|(
name|QObject
modifier|*
name|obj
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|eventFilters
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|d
operator|->
name|eventFilters
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|obj
condition|)
name|d
operator|->
name|eventFilters
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \fn QObject::destroyed(QObject *obj)      This signal is emitted immediately before the object \a obj is     destroyed, and can not be blocked.      All the objects's children are destroyed immediately after this     signal is emitted.      \sa deleteLater(), QPointer */
end_comment
begin_comment
comment|/*!     Schedules this object for deletion.      The object will be deleted when control returns to the event     loop. If the event loop is not running when this function is     called (e.g. deleteLater() is called on an object before     QCoreApplication::exec()), the object will be deleted once the     event loop is started.      Note that entering and leaving a new event loop (e.g., by opening a modal     dialog) will \e not perform the deferred deletion; for the object to be     deleted, the control must return to the event loop from which     deleteLater() was called.      \b{Note:} It is safe to call this function more than once; when the     first deferred deletion event is delivered, any pending events for the     object are removed from the event queue.      \sa destroyed(), QPointer */
end_comment
begin_function
DECL|function|deleteLater
name|void
name|QObject
operator|::
name|deleteLater
parameter_list|()
block|{
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|this
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|DeferredDelete
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QObject::tr(const char *sourceText, const char *disambiguation, int n)     \reentrant      Returns a translated version of \a sourceText, optionally based on a     \a disambiguation string and value of \a n for strings containing plurals;     otherwise returns \a sourceText itself if no appropriate translated string     is available.      Example:     \snippet mainwindows/sdi/mainwindow.cpp implicit tr context     \dots      If the same \a sourceText is used in different roles within the     same context, an additional identifying string may be passed in     \a disambiguation (0 by default). In Qt 4.4 and earlier, this was     the preferred way to pass comments to translators.      Example:      \snippet code/src_corelib_kernel_qobject.cpp 17     \dots      See \l{Writing Source Code for Translation} for a detailed description of     Qt's translation mechanisms in general, and the     \l{Writing Source Code for Translation#Disambiguation}{Disambiguation}     section for information on disambiguation.      \warning This method is reentrant only if all translators are     installed \e before calling this method. Installing or removing     translators while performing translations is not supported. Doing     so will probably result in crashes or other undesirable behavior.      \sa trUtf8(), QApplication::translate(), {Internationalization with Qt} */
end_comment
begin_comment
comment|/*!     \fn QString QObject::trUtf8(const char *sourceText, const char *disambiguation, int n)     \reentrant      Returns a translated version of \a sourceText, or     QString::fromUtf8(\a sourceText) if there is no appropriate     version. It is otherwise identical to tr(\a sourceText, \a     disambiguation, \a n).      \warning This method is reentrant only if all translators are     installed \e before calling this method. Installing or removing     translators while performing translations is not supported. Doing     so will probably result in crashes or other undesirable behavior.      \warning For portability reasons, we recommend that you use     escape sequences for specifying non-ASCII characters in string     literals to trUtf8(). For example:      \snippet code/src_corelib_kernel_qobject.cpp 20      \sa tr(), QApplication::translate(), {Internationalization with Qt} */
end_comment
begin_comment
comment|/*****************************************************************************   Signals and slots  *****************************************************************************/
end_comment
begin_decl_stmt
DECL|variable|flagged_locations_count
specifier|const
name|int
name|flagged_locations_count
init|=
literal|2
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|flagged_locations
specifier|static
specifier|const
name|char
modifier|*
name|flagged_locations
index|[
name|flagged_locations_count
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qFlagLocation
specifier|const
name|char
modifier|*
name|qFlagLocation
parameter_list|(
specifier|const
name|char
modifier|*
name|method
parameter_list|)
block|{
specifier|static
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|flagged_locations
index|[
name|idx
index|]
operator|=
name|method
expr_stmt|;
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|%
name|flagged_locations_count
expr_stmt|;
return|return
name|method
return|;
block|}
end_function
begin_function
DECL|function|extract_code
specifier|static
name|int
name|extract_code
parameter_list|(
specifier|const
name|char
modifier|*
name|member
parameter_list|)
block|{
comment|// extract code, ensure QMETHOD_CODE<= code<= QSIGNAL_CODE
return|return
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|*
name|member
argument_list|)
operator|-
literal|'0'
operator|)
operator|&
literal|0x3
operator|)
return|;
block|}
end_function
begin_function
DECL|function|extract_location
specifier|static
specifier|const
name|char
modifier|*
name|extract_location
parameter_list|(
specifier|const
name|char
modifier|*
name|member
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|flagged_locations_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|member
operator|==
name|flagged_locations
index|[
name|i
index|]
condition|)
block|{
comment|// signature includes location information after the first null-terminator
specifier|const
name|char
modifier|*
name|location
init|=
name|member
operator|+
name|qstrlen
argument_list|(
name|member
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|location
operator|!=
literal|'\0'
condition|)
return|return
name|location
return|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|check_signal_macro
specifier|static
name|bool
name|check_signal_macro
parameter_list|(
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
specifier|const
name|char
modifier|*
name|signal
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|)
block|{
name|int
name|sigcode
init|=
name|extract_code
argument_list|(
name|signal
argument_list|)
decl_stmt|;
if|if
condition|(
name|sigcode
operator|!=
name|QSIGNAL_CODE
condition|)
block|{
if|if
condition|(
name|sigcode
operator|==
name|QSLOT_CODE
condition|)
name|qWarning
argument_list|(
literal|"QObject::%s: Attempt to %s non-signal %s::%s"
argument_list|,
name|func
argument_list|,
name|op
argument_list|,
name|sender
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|signal
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QObject::%s: Use the SIGNAL macro to %s %s::%s"
argument_list|,
name|func
argument_list|,
name|op
argument_list|,
name|sender
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|signal
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|check_method_code
specifier|static
name|bool
name|check_method_code
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|QObject
modifier|*
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
if|if
condition|(
name|code
operator|!=
name|QSLOT_CODE
operator|&&
name|code
operator|!=
name|QSIGNAL_CODE
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::%s: Use the SLOT or SIGNAL macro to "
literal|"%s %s::%s"
argument_list|,
name|func
argument_list|,
name|func
argument_list|,
name|object
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|method
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|err_method_notfound
specifier|static
name|void
name|err_method_notfound
parameter_list|(
specifier|const
name|QObject
modifier|*
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|type
init|=
literal|"method"
decl_stmt|;
switch|switch
condition|(
name|extract_code
argument_list|(
name|method
argument_list|)
condition|)
block|{
case|case
name|QSLOT_CODE
case|:
name|type
operator|=
literal|"slot"
expr_stmt|;
break|break;
case|case
name|QSIGNAL_CODE
case|:
name|type
operator|=
literal|"signal"
expr_stmt|;
break|break;
block|}
specifier|const
name|char
modifier|*
name|loc
init|=
name|extract_location
argument_list|(
name|method
argument_list|)
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|method
argument_list|,
literal|')'
argument_list|)
operator|==
literal|0
condition|)
comment|// common typing mistake
name|qWarning
argument_list|(
literal|"QObject::%s: Parentheses expected, %s %s::%s%s%s"
argument_list|,
name|func
argument_list|,
name|type
argument_list|,
name|object
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|method
operator|+
literal|1
argument_list|,
name|loc
condition|?
literal|" in "
else|:
literal|""
argument_list|,
name|loc
condition|?
name|loc
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QObject::%s: No such %s %s::%s%s%s"
argument_list|,
name|func
argument_list|,
name|type
argument_list|,
name|object
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|method
operator|+
literal|1
argument_list|,
name|loc
condition|?
literal|" in "
else|:
literal|""
argument_list|,
name|loc
condition|?
name|loc
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|err_info_about_objects
specifier|static
name|void
name|err_info_about_objects
parameter_list|(
specifier|const
name|char
modifier|*
name|func
parameter_list|,
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|)
block|{
name|QString
name|a
init|=
name|sender
condition|?
name|sender
operator|->
name|objectName
argument_list|()
else|:
name|QString
argument_list|()
decl_stmt|;
name|QString
name|b
init|=
name|receiver
condition|?
name|receiver
operator|->
name|objectName
argument_list|()
else|:
name|QString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|a
operator|.
name|isEmpty
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QObject::%s:  (sender name:   '%s')"
argument_list|,
name|func
argument_list|,
name|a
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|.
name|isEmpty
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QObject::%s:  (receiver name: '%s')"
argument_list|,
name|func
argument_list|,
name|b
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the object that sent the signal, if called in     a slot activated by a signal; otherwise it returns 0. The pointer     is valid only during the execution of the slot that calls this     function from this object's thread context.      The pointer returned by this function becomes invalid if the     sender is destroyed, or if the slot is disconnected from the     sender's signal.      \warning This function violates the object-oriented principle of     modularity. However, getting access to the sender might be useful     when many signals are connected to a single slot.      \warning As mentioned above, the return value of this function is     not valid when the slot is called via a Qt::DirectConnection from     a thread different from this object's thread. Do not use this     function in this type of scenario.      \sa senderSignalIndex(), QSignalMapper */
end_comment
begin_function
DECL|function|sender
name|QObject
modifier|*
name|QObject
operator|::
name|sender
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QObject
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
name|signalSlotLock
argument_list|(
name|this
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|currentSender
condition|)
return|return
literal|0
return|;
for|for
control|(
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
init|=
name|d
operator|->
name|senders
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c
operator|->
name|sender
operator|==
name|d
operator|->
name|currentSender
operator|->
name|sender
condition|)
return|return
name|d
operator|->
name|currentSender
operator|->
name|sender
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns the meta-method index of the signal that called the currently     executing slot, which is a member of the class returned by sender().     If called outside of a slot activated by a signal, -1 is returned.      For signals with default parameters, this function will always return     the index with all parameters, regardless of which was used with     connect(). For example, the signal \c {destroyed(QObject *obj = 0)}     will have two different indexes (with and without the parameter), but     this function will always return the index with a parameter. This does     not apply when overloading signals with different parameters.      \warning This function violates the object-oriented principle of     modularity. However, getting access to the signal index might be useful     when many signals are connected to a single slot.      \warning The return value of this function is not valid when the slot     is called via a Qt::DirectConnection from a thread different from this     object's thread. Do not use this function in this type of scenario.      \sa sender(), QMetaObject::indexOfSignal(), QMetaObject::method() */
end_comment
begin_function
DECL|function|senderSignalIndex
name|int
name|QObject
operator|::
name|senderSignalIndex
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QObject
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
name|signalSlotLock
argument_list|(
name|this
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|currentSender
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
init|=
name|d
operator|->
name|senders
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c
operator|->
name|sender
operator|==
name|d
operator|->
name|currentSender
operator|->
name|sender
condition|)
return|return
name|d
operator|->
name|currentSender
operator|->
name|signal
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of receivers connected to the \a signal.      Since both slots and signals can be used as receivers for signals,     and the same connections can be made many times, the number of     receivers is the same as the number of connections made from this     signal.      When calling this function, you can use the \c SIGNAL() macro to     pass a specific signal:      \snippet code/src_corelib_kernel_qobject.cpp 21      \warning This function violates the object-oriented principle of     modularity. However, it might be useful when you need to perform     expensive initialization only if something is connected to a     signal.      \sa isSignalConnected() */
end_comment
begin_function
DECL|function|receivers
name|int
name|QObject
operator|::
name|receivers
parameter_list|(
specifier|const
name|char
modifier|*
name|signal
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QObject
argument_list|)
expr_stmt|;
name|int
name|receivers
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|signal
condition|)
block|{
name|QByteArray
name|signal_name
init|=
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|signal
argument_list|)
decl_stmt|;
name|signal
operator|=
name|signal_name
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
operator|!
name|check_signal_macro
argument_list|(
name|this
argument_list|,
name|signal
argument_list|,
literal|"receivers"
argument_list|,
literal|"bind"
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|signal
operator|++
expr_stmt|;
comment|// skip code
name|int
name|signal_index
init|=
name|d
operator|->
name|signalIndex
argument_list|(
name|signal
argument_list|)
decl_stmt|;
if|if
condition|(
name|signal_index
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|err_method_notfound
argument_list|(
name|this
argument_list|,
name|signal
operator|-
literal|1
argument_list|,
literal|"receivers"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
if|if
condition|(
name|d
operator|->
name|declarativeData
operator|&&
name|QAbstractDeclarativeData
operator|::
name|receivers
condition|)
block|{
name|receivers
operator|+=
name|QAbstractDeclarativeData
operator|::
name|receivers
argument_list|(
name|d
operator|->
name|declarativeData
argument_list|,
name|this
argument_list|,
name|metaObject
argument_list|()
operator|->
name|indexOfMethod
argument_list|(
name|signal
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|isSignalConnected
argument_list|(
name|signal_index
argument_list|)
condition|)
return|return
name|receivers
return|;
name|QMutexLocker
name|locker
argument_list|(
name|signalSlotLock
argument_list|(
name|this
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|connectionLists
condition|)
block|{
if|if
condition|(
name|signal_index
operator|<
name|d
operator|->
name|connectionLists
operator|->
name|count
argument_list|()
condition|)
block|{
specifier|const
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
init|=
name|d
operator|->
name|connectionLists
operator|->
name|at
argument_list|(
name|signal_index
argument_list|)
operator|.
name|first
decl_stmt|;
while|while
condition|(
name|c
condition|)
block|{
name|receivers
operator|+=
name|c
operator|->
name|receiver
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|nextConnectionList
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|receivers
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Returns true if the \a signal is connected to at least one receiver,     otherwise returns false.      \a signal must be a signal member of this object, otherwise the behaviour     is undefined.      \snippet code/src_corelib_kernel_qobject.cpp 21      As the code snippet above illustrates, you can use this function     to avoid emitting a signal that nobody listens to.      \warning This function violates the object-oriented principle of     modularity. However, it might be useful when you need to perform     expensive initialization only if something is connected to a     signal. */
end_comment
begin_function
DECL|function|isSignalConnected
name|bool
name|QObject
operator|::
name|isSignalConnected
parameter_list|(
specifier|const
name|QMetaMethod
modifier|&
name|signal
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QObject
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|signal
operator|.
name|mobj
condition|)
return|return
literal|false
return|;
name|Q_ASSERT_X
argument_list|(
name|signal
operator|.
name|mobj
operator|->
name|cast
argument_list|(
name|this
argument_list|)
operator|&&
name|signal
operator|.
name|methodType
argument_list|()
operator|==
name|QMetaMethod
operator|::
name|Signal
argument_list|,
literal|"QObject::isSignalConnected"
argument_list|,
literal|"the parameter must be a signal member of the object"
argument_list|)
expr_stmt|;
name|uint
name|signalIndex
init|=
operator|(
name|signal
operator|.
name|handle
operator|-
name|QMetaObjectPrivate
operator|::
name|get
argument_list|(
name|signal
operator|.
name|mobj
argument_list|)
operator|->
name|methodData
operator|)
operator|/
literal|5
decl_stmt|;
if|if
condition|(
name|signal
operator|.
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|signal
operator|.
name|handle
operator|+
literal|4
index|]
operator|&
name|MethodCloned
condition|)
name|signalIndex
operator|=
name|QMetaObjectPrivate
operator|::
name|originalClone
argument_list|(
name|signal
operator|.
name|mobj
argument_list|,
name|signalIndex
argument_list|)
expr_stmt|;
name|int
name|signalOffset
decl_stmt|;
name|int
name|methodOffset
decl_stmt|;
name|computeOffsets
argument_list|(
name|signal
operator|.
name|mobj
argument_list|,
operator|&
name|signalOffset
argument_list|,
operator|&
name|methodOffset
argument_list|)
expr_stmt|;
name|signalIndex
operator|+=
name|signalOffset
expr_stmt|;
if|if
condition|(
name|signalIndex
operator|<
sizeof|sizeof
argument_list|(
name|d
operator|->
name|connectedSignals
argument_list|)
operator|*
literal|8
condition|)
return|return
name|d
operator|->
name|isSignalConnected
argument_list|(
name|signalIndex
argument_list|)
return|;
name|QMutexLocker
name|locker
argument_list|(
name|signalSlotLock
argument_list|(
name|this
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|connectionLists
condition|)
block|{
if|if
condition|(
name|signalIndex
operator|<
name|uint
argument_list|(
name|d
operator|->
name|connectionLists
operator|->
name|count
argument_list|()
argument_list|)
condition|)
block|{
specifier|const
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
init|=
name|d
operator|->
name|connectionLists
operator|->
name|at
argument_list|(
name|signalIndex
argument_list|)
operator|.
name|first
decl_stmt|;
while|while
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|receiver
condition|)
return|return
literal|true
return|;
name|c
operator|=
name|c
operator|->
name|nextConnectionList
expr_stmt|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      This helper function calculates signal and method index for the given     member in the specified class.      \list     \li If member.mobj is 0 then both signalIndex and methodIndex are set to -1.      \li If specified member is not a member of obj instance class (or one of     its parent classes) then both signalIndex and methodIndex are set to -1.     \endlist      This function is used by QObject::connect and QObject::disconnect which     are working with QMetaMethod.      \a signalIndex is set to the signal index of member. If the member     specified is not signal this variable is set to -1.      \a methodIndex is set to the method index of the member. If the     member is not a method of the object specified by the \a obj argument this     variable is set to -1. */
end_comment
begin_function
DECL|function|memberIndexes
name|void
name|QMetaObjectPrivate
operator|::
name|memberIndexes
parameter_list|(
specifier|const
name|QObject
modifier|*
name|obj
parameter_list|,
specifier|const
name|QMetaMethod
modifier|&
name|member
parameter_list|,
name|int
modifier|*
name|signalIndex
parameter_list|,
name|int
modifier|*
name|methodIndex
parameter_list|)
block|{
operator|*
name|signalIndex
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|methodIndex
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|obj
operator|||
operator|!
name|member
operator|.
name|mobj
condition|)
return|return;
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|obj
operator|->
name|metaObject
argument_list|()
decl_stmt|;
comment|// Check that member is member of obj class
while|while
condition|(
name|m
operator|!=
literal|0
operator|&&
name|m
operator|!=
name|member
operator|.
name|mobj
condition|)
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return;
operator|*
name|signalIndex
operator|=
operator|*
name|methodIndex
operator|=
operator|(
name|member
operator|.
name|handle
operator|-
name|get
argument_list|(
name|member
operator|.
name|mobj
argument_list|)
operator|->
name|methodData
operator|)
operator|/
literal|5
expr_stmt|;
name|int
name|signalOffset
decl_stmt|;
name|int
name|methodOffset
decl_stmt|;
name|computeOffsets
argument_list|(
name|m
argument_list|,
operator|&
name|signalOffset
argument_list|,
operator|&
name|methodOffset
argument_list|)
expr_stmt|;
operator|*
name|methodIndex
operator|+=
name|methodOffset
expr_stmt|;
if|if
condition|(
name|member
operator|.
name|methodType
argument_list|()
operator|==
name|QMetaMethod
operator|::
name|Signal
condition|)
block|{
operator|*
name|signalIndex
operator|=
name|originalClone
argument_list|(
name|m
argument_list|,
operator|*
name|signalIndex
argument_list|)
expr_stmt|;
operator|*
name|signalIndex
operator|+=
name|signalOffset
expr_stmt|;
block|}
else|else
block|{
operator|*
name|signalIndex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|check_and_warn_compat
specifier|static
specifier|inline
name|void
name|check_and_warn_compat
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|sender
parameter_list|,
specifier|const
name|QMetaMethod
modifier|&
name|signal
parameter_list|,
specifier|const
name|QMetaObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|QMetaMethod
modifier|&
name|method
parameter_list|)
block|{
if|if
condition|(
name|signal
operator|.
name|attributes
argument_list|()
operator|&
name|QMetaMethod
operator|::
name|Compatibility
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|method
operator|.
name|attributes
argument_list|()
operator|&
name|QMetaMethod
operator|::
name|Compatibility
operator|)
condition|)
name|qWarning
argument_list|(
literal|"QObject::connect: Connecting from COMPAT signal (%s::%s)"
argument_list|,
name|sender
operator|->
name|className
argument_list|()
argument_list|,
name|signal
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|method
operator|.
name|attributes
argument_list|()
operator|&
name|QMetaMethod
operator|::
name|Compatibility
operator|)
operator|&&
name|method
operator|.
name|methodType
argument_list|()
operator|==
name|QMetaMethod
operator|::
name|Signal
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::connect: Connecting from %s::%s to COMPAT slot (%s::%s)"
argument_list|,
name|sender
operator|->
name|className
argument_list|()
argument_list|,
name|signal
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|receiver
operator|->
name|className
argument_list|()
argument_list|,
name|method
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \threadsafe      Creates a connection of the given \a type from the \a signal in     the \a sender object to the \a method in the \a receiver object.     Returns a handle to the connection that can be used to disconnect     it later.      You must use the \c SIGNAL() and \c SLOT() macros when specifying     the \a signal and the \a method, for example:      \snippet code/src_corelib_kernel_qobject.cpp 22      This example ensures that the label always displays the current     scroll bar value. Note that the signal and slots parameters must not     contain any variable names, only the type. E.g. the following would     not work and return false:      \snippet code/src_corelib_kernel_qobject.cpp 23      A signal can also be connected to another signal:      \snippet code/src_corelib_kernel_qobject.cpp 24      In this example, the \c MyWidget constructor relays a signal from     a private member variable, and makes it available under a name     that relates to \c MyWidget.      A signal can be connected to many slots and signals. Many signals     can be connected to one slot.      If a signal is connected to several slots, the slots are activated     in the same order as the order the connection was made, when the     signal is emitted.      The function returns a handle to a connection if it successfully     connects the signal to the slot. The Connection handle will be invalid     if it cannot create the connection, for example, if QObject is unable     to verify the existence of either \a signal or \a method, or if their     signatures aren't compatible.     You can check if the QMetaObject::Connection is valid by casting it to a bool.      By default, a signal is emitted for every connection you make;     two signals are emitted for duplicate connections. You can break     all of these connections with a single disconnect() call.     If you pass the Qt::UniqueConnection \a type, the connection will only     be made if it is not a duplicate. If there is already a duplicate     (exact same signal to the exact same slot on the same objects),     the connection will fail and connect will return an invalid QMetaObject::Connection.      The optional \a type parameter describes the type of connection     to establish. In particular, it determines whether a particular     signal is delivered to a slot immediately or queued for delivery     at a later time. If the signal is queued, the parameters must be     of types that are known to Qt's meta-object system, because Qt     needs to copy the arguments to store them in an event behind the     scenes. If you try to use a queued connection and get the error     message      \snippet code/src_corelib_kernel_qobject.cpp 25      call qRegisterMetaType() to register the data type before you     establish the connection.      \sa disconnect(), sender(), qRegisterMetaType(), Q_DECLARE_METATYPE() */
end_comment
begin_function
DECL|function|connect
name|QMetaObject
operator|::
name|Connection
name|QObject
operator|::
name|connect
parameter_list|(
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
specifier|const
name|char
modifier|*
name|signal
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|,
name|Qt
operator|::
name|ConnectionType
name|type
parameter_list|)
block|{
if|if
condition|(
name|sender
operator|==
literal|0
operator|||
name|receiver
operator|==
literal|0
operator|||
name|signal
operator|==
literal|0
operator|||
name|method
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::connect: Cannot connect %s::%s to %s::%s"
argument_list|,
name|sender
condition|?
name|sender
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
else|:
literal|"(null)"
argument_list|,
operator|(
name|signal
operator|&&
operator|*
name|signal
operator|)
condition|?
name|signal
operator|+
literal|1
else|:
literal|"(null)"
argument_list|,
name|receiver
condition|?
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
else|:
literal|"(null)"
argument_list|,
operator|(
name|method
operator|&&
operator|*
name|method
operator|)
condition|?
name|method
operator|+
literal|1
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|QByteArray
name|tmp_signal_name
decl_stmt|;
if|if
condition|(
operator|!
name|check_signal_macro
argument_list|(
name|sender
argument_list|,
name|signal
argument_list|,
literal|"connect"
argument_list|,
literal|"bind"
argument_list|)
condition|)
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|(
literal|0
argument_list|)
return|;
specifier|const
name|QMetaObject
modifier|*
name|smeta
init|=
name|sender
operator|->
name|metaObject
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|signal_arg
init|=
name|signal
decl_stmt|;
operator|++
name|signal
expr_stmt|;
comment|//skip code
name|QArgumentTypeArray
name|signalTypes
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QMetaObjectPrivate
operator|::
name|get
argument_list|(
name|smeta
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|QByteArray
name|signalName
init|=
name|QMetaObjectPrivate
operator|::
name|decodeMethodSignature
argument_list|(
name|signal
argument_list|,
name|signalTypes
argument_list|)
decl_stmt|;
name|int
name|signal_index
init|=
name|QMetaObjectPrivate
operator|::
name|indexOfSignalRelative
argument_list|(
operator|&
name|smeta
argument_list|,
name|signalName
argument_list|,
name|signalTypes
operator|.
name|size
argument_list|()
argument_list|,
name|signalTypes
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|signal_index
operator|<
literal|0
condition|)
block|{
comment|// check for normalized signatures
name|tmp_signal_name
operator|=
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|signal
operator|-
literal|1
argument_list|)
expr_stmt|;
name|signal
operator|=
name|tmp_signal_name
operator|.
name|constData
argument_list|()
operator|+
literal|1
expr_stmt|;
name|signalTypes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|signalName
operator|=
name|QMetaObjectPrivate
operator|::
name|decodeMethodSignature
argument_list|(
name|signal
argument_list|,
name|signalTypes
argument_list|)
expr_stmt|;
name|smeta
operator|=
name|sender
operator|->
name|metaObject
argument_list|()
expr_stmt|;
name|signal_index
operator|=
name|QMetaObjectPrivate
operator|::
name|indexOfSignalRelative
argument_list|(
operator|&
name|smeta
argument_list|,
name|signalName
argument_list|,
name|signalTypes
operator|.
name|size
argument_list|()
argument_list|,
name|signalTypes
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal_index
operator|<
literal|0
condition|)
block|{
name|err_method_notfound
argument_list|(
name|sender
argument_list|,
name|signal_arg
argument_list|,
literal|"connect"
argument_list|)
expr_stmt|;
name|err_info_about_objects
argument_list|(
literal|"connect"
argument_list|,
name|sender
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|signal_index
operator|=
name|QMetaObjectPrivate
operator|::
name|originalClone
argument_list|(
name|smeta
argument_list|,
name|signal_index
argument_list|)
expr_stmt|;
name|int
name|signalOffset
decl_stmt|,
name|methodOffset
decl_stmt|;
name|computeOffsets
argument_list|(
name|smeta
argument_list|,
operator|&
name|signalOffset
argument_list|,
operator|&
name|methodOffset
argument_list|)
expr_stmt|;
name|signal_index
operator|+=
name|signalOffset
expr_stmt|;
name|QByteArray
name|tmp_method_name
decl_stmt|;
name|int
name|membcode
init|=
name|extract_code
argument_list|(
name|method
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|check_method_code
argument_list|(
name|membcode
argument_list|,
name|receiver
argument_list|,
name|method
argument_list|,
literal|"connect"
argument_list|)
condition|)
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|(
literal|0
argument_list|)
return|;
specifier|const
name|char
modifier|*
name|method_arg
init|=
name|method
decl_stmt|;
operator|++
name|method
expr_stmt|;
comment|// skip code
name|QByteArray
name|methodName
decl_stmt|;
name|QArgumentTypeArray
name|methodTypes
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|rmeta
init|=
name|receiver
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|int
name|method_index_relative
init|=
operator|-
literal|1
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QMetaObjectPrivate
operator|::
name|get
argument_list|(
name|rmeta
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|membcode
condition|)
block|{
case|case
name|QSLOT_CODE
case|:
name|method_index_relative
operator|=
name|QMetaObjectPrivate
operator|::
name|indexOfSlotRelative
argument_list|(
operator|&
name|rmeta
argument_list|,
name|methodName
argument_list|,
name|methodTypes
operator|.
name|size
argument_list|()
argument_list|,
name|methodTypes
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSIGNAL_CODE
case|:
name|method_index_relative
operator|=
name|QMetaObjectPrivate
operator|::
name|indexOfSignalRelative
argument_list|(
operator|&
name|rmeta
argument_list|,
name|methodName
argument_list|,
name|methodTypes
operator|.
name|size
argument_list|()
argument_list|,
name|methodTypes
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|method_index_relative
operator|<
literal|0
condition|)
block|{
comment|// check for normalized methods
name|tmp_method_name
operator|=
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|method
operator|=
name|tmp_method_name
operator|.
name|constData
argument_list|()
expr_stmt|;
name|methodTypes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|methodName
operator|=
name|QMetaObjectPrivate
operator|::
name|decodeMethodSignature
argument_list|(
name|method
argument_list|,
name|methodTypes
argument_list|)
expr_stmt|;
comment|// rmeta may have been modified above
name|rmeta
operator|=
name|receiver
operator|->
name|metaObject
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|membcode
condition|)
block|{
case|case
name|QSLOT_CODE
case|:
name|method_index_relative
operator|=
name|QMetaObjectPrivate
operator|::
name|indexOfSlotRelative
argument_list|(
operator|&
name|rmeta
argument_list|,
name|methodName
argument_list|,
name|methodTypes
operator|.
name|size
argument_list|()
argument_list|,
name|methodTypes
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSIGNAL_CODE
case|:
name|method_index_relative
operator|=
name|QMetaObjectPrivate
operator|::
name|indexOfSignalRelative
argument_list|(
operator|&
name|rmeta
argument_list|,
name|methodName
argument_list|,
name|methodTypes
operator|.
name|size
argument_list|()
argument_list|,
name|methodTypes
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|method_index_relative
operator|<
literal|0
condition|)
block|{
name|err_method_notfound
argument_list|(
name|receiver
argument_list|,
name|method_arg
argument_list|,
literal|"connect"
argument_list|)
expr_stmt|;
name|err_info_about_objects
argument_list|(
literal|"connect"
argument_list|,
name|sender
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|QMetaObjectPrivate
operator|::
name|checkConnectArgs
argument_list|(
name|signalTypes
operator|.
name|size
argument_list|()
argument_list|,
name|signalTypes
operator|.
name|constData
argument_list|()
argument_list|,
name|methodTypes
operator|.
name|size
argument_list|()
argument_list|,
name|methodTypes
operator|.
name|constData
argument_list|()
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::connect: Incompatible sender/receiver arguments"
literal|"\n        %s::%s --> %s::%s"
argument_list|,
name|sender
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|signal
argument_list|,
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|method
argument_list|)
expr_stmt|;
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|int
modifier|*
name|types
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|Qt
operator|::
name|QueuedConnection
operator|)
operator|&&
operator|!
operator|(
name|types
operator|=
name|queuedConnectionTypes
argument_list|(
name|signalTypes
operator|.
name|constData
argument_list|()
argument_list|,
name|signalTypes
operator|.
name|size
argument_list|()
argument_list|)
operator|)
condition|)
block|{
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|(
literal|0
argument_list|)
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|QMetaMethod
name|smethod
init|=
name|QMetaObjectPrivate
operator|::
name|signal
argument_list|(
name|smeta
argument_list|,
name|signal_index
argument_list|)
decl_stmt|;
name|QMetaMethod
name|rmethod
init|=
name|rmeta
operator|->
name|method
argument_list|(
name|method_index_relative
operator|+
name|rmeta
operator|->
name|methodOffset
argument_list|()
argument_list|)
decl_stmt|;
name|check_and_warn_compat
argument_list|(
name|smeta
argument_list|,
name|smethod
argument_list|,
name|rmeta
argument_list|,
name|rmethod
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QMetaObject
operator|::
name|Connection
name|handle
init|=
name|QMetaObject
operator|::
name|Connection
argument_list|(
name|QMetaObjectPrivate
operator|::
name|connect
argument_list|(
name|sender
argument_list|,
name|signal_index
argument_list|,
name|smeta
argument_list|,
name|receiver
argument_list|,
name|method_index_relative
argument_list|,
name|rmeta
argument_list|,
name|type
argument_list|,
name|types
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
condition|)
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|)
operator|->
name|connectNotify
argument_list|(
name|signal
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|handle
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Creates a connection of the given \a type from the \a signal in     the \a sender object to the \a method in the \a receiver object.     Returns a handle to the connection that can be used to disconnect     it later.      The Connection handle will be invalid  if it cannot create the     connection, for example, the parameters were invalid.     You can check if the QMetaObject::Connection is valid by casting it to a bool.      This function works in the same way as     connect(const QObject *sender, const char *signal,             const QObject *receiver, const char *method,             Qt::ConnectionType type)     but it uses QMetaMethod to specify signal and method.      \sa connect(const QObject *sender, const char *signal,                 const QObject *receiver, const char *method,                 Qt::ConnectionType type)  */
end_comment
begin_function
DECL|function|connect
name|QMetaObject
operator|::
name|Connection
name|QObject
operator|::
name|connect
parameter_list|(
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
specifier|const
name|QMetaMethod
modifier|&
name|signal
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|QMetaMethod
modifier|&
name|method
parameter_list|,
name|Qt
operator|::
name|ConnectionType
name|type
parameter_list|)
block|{
if|if
condition|(
name|sender
operator|==
literal|0
operator|||
name|receiver
operator|==
literal|0
operator|||
name|signal
operator|.
name|methodType
argument_list|()
operator|!=
name|QMetaMethod
operator|::
name|Signal
operator|||
name|method
operator|.
name|methodType
argument_list|()
operator|==
name|QMetaMethod
operator|::
name|Constructor
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::connect: Cannot connect %s::%s to %s::%s"
argument_list|,
name|sender
condition|?
name|sender
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
else|:
literal|"(null)"
argument_list|,
name|signal
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|receiver
condition|?
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
else|:
literal|"(null)"
argument_list|,
name|method
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|// Reconstructing SIGNAL() macro result for signal.methodSignature() string
name|QByteArray
name|signalSignature
decl_stmt|;
name|signalSignature
operator|.
name|reserve
argument_list|(
name|signal
operator|.
name|methodSignature
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|signalSignature
operator|.
name|append
argument_list|(
call|(
name|char
call|)
argument_list|(
name|QSIGNAL_CODE
operator|+
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
name|signalSignature
operator|.
name|append
argument_list|(
name|signal
operator|.
name|methodSignature
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|signal_index
decl_stmt|;
name|int
name|method_index
decl_stmt|;
block|{
name|int
name|dummy
decl_stmt|;
name|QMetaObjectPrivate
operator|::
name|memberIndexes
argument_list|(
name|sender
argument_list|,
name|signal
argument_list|,
operator|&
name|signal_index
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|QMetaObjectPrivate
operator|::
name|memberIndexes
argument_list|(
name|receiver
argument_list|,
name|method
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|method_index
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QMetaObject
modifier|*
name|smeta
init|=
name|sender
operator|->
name|metaObject
argument_list|()
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|rmeta
init|=
name|receiver
operator|->
name|metaObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|signal_index
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::connect: Can't find signal %s on instance of class %s"
argument_list|,
name|signal
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|smeta
operator|->
name|className
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|method_index
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::connect: Can't find method %s on instance of class %s"
argument_list|,
name|method
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|rmeta
operator|->
name|className
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|QMetaObject
operator|::
name|checkConnectArgs
argument_list|(
name|signal
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|method
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::connect: Incompatible sender/receiver arguments"
literal|"\n        %s::%s --> %s::%s"
argument_list|,
name|smeta
operator|->
name|className
argument_list|()
argument_list|,
name|signal
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|rmeta
operator|->
name|className
argument_list|()
argument_list|,
name|method
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|int
modifier|*
name|types
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|Qt
operator|::
name|QueuedConnection
operator|)
operator|&&
operator|!
operator|(
name|types
operator|=
name|queuedConnectionTypes
argument_list|(
name|signal
operator|.
name|parameterTypes
argument_list|()
argument_list|)
operator|)
condition|)
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|(
literal|0
argument_list|)
return|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|check_and_warn_compat
argument_list|(
name|smeta
argument_list|,
name|signal
argument_list|,
name|rmeta
argument_list|,
name|method
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QMetaObject
operator|::
name|Connection
name|handle
init|=
name|QMetaObject
operator|::
name|Connection
argument_list|(
name|QMetaObjectPrivate
operator|::
name|connect
argument_list|(
name|sender
argument_list|,
name|signal_index
argument_list|,
name|signal
operator|.
name|enclosingMetaObject
argument_list|()
argument_list|,
name|receiver
argument_list|,
name|method_index
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
name|types
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
condition|)
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|)
operator|->
name|connectNotify
argument_list|(
name|signalSignature
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|handle
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QObject::connect(const QObject *sender, const char *signal, const char *method, Qt::ConnectionType type) const     \overload connect()     \threadsafe      Connects \a signal from the \a sender object to this object's \a     method.      Equivalent to connect(\a sender, \a signal, \c this, \a method, \a type).      Every connection you make emits a signal, so duplicate connections emit     two signals. You can break a connection using disconnect().      \sa disconnect() */
end_comment
begin_comment
comment|/*!     \threadsafe      Disconnects \a signal in object \a sender from \a method in object     \a receiver. Returns true if the connection is successfully broken;     otherwise returns false.      A signal-slot connection is removed when either of the objects     involved are destroyed.      disconnect() is typically used in three ways, as the following     examples demonstrate.     \list 1     \li Disconnect everything connected to an object's signals:         \snippet code/src_corelib_kernel_qobject.cpp 26         equivalent to the non-static overloaded function         \snippet code/src_corelib_kernel_qobject.cpp 27      \li Disconnect everything connected to a specific signal:         \snippet code/src_corelib_kernel_qobject.cpp 28         equivalent to the non-static overloaded function         \snippet code/src_corelib_kernel_qobject.cpp 29      \li Disconnect a specific receiver:         \snippet code/src_corelib_kernel_qobject.cpp 30         equivalent to the non-static overloaded function         \snippet code/src_corelib_kernel_qobject.cpp 31      \endlist      0 may be used as a wildcard, meaning "any signal", "any receiving     object", or "any slot in the receiving object", respectively.      The \a sender may never be 0. (You cannot disconnect signals from     more than one object in a single call.)      If \a signal is 0, it disconnects \a receiver and \a method from     any signal. If not, only the specified signal is disconnected.      If \a receiver is 0, it disconnects anything connected to \a     signal. If not, slots in objects other than \a receiver are not     disconnected.      If \a method is 0, it disconnects anything that is connected to \a     receiver. If not, only slots named \a method will be disconnected,     and all other slots are left alone. The \a method must be 0 if \a     receiver is left out, so you cannot disconnect a     specifically-named slot on all objects.      \sa connect() */
end_comment
begin_function
DECL|function|disconnect
name|bool
name|QObject
operator|::
name|disconnect
parameter_list|(
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
specifier|const
name|char
modifier|*
name|signal
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|)
block|{
if|if
condition|(
name|sender
operator|==
literal|0
operator|||
operator|(
name|receiver
operator|==
literal|0
operator|&&
name|method
operator|!=
literal|0
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::disconnect: Unexpected null parameter"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|const
name|char
modifier|*
name|signal_arg
init|=
name|signal
decl_stmt|;
name|QByteArray
name|signal_name
decl_stmt|;
name|bool
name|signal_found
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|signal
condition|)
block|{
name|QT_TRY
block|{
name|signal_name
operator|=
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|signal
argument_list|)
expr_stmt|;
name|signal
operator|=
name|signal_name
operator|.
name|constData
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::bad_alloc&
argument_list|)
block|{
comment|// if the signal is already normalized, we can continue.
if|if
condition|(
name|sender
operator|->
name|metaObject
argument_list|()
operator|->
name|indexOfSignal
argument_list|(
name|signal
operator|+
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|QT_RETHROW
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|check_signal_macro
argument_list|(
name|sender
argument_list|,
name|signal
argument_list|,
literal|"disconnect"
argument_list|,
literal|"unbind"
argument_list|)
condition|)
return|return
literal|false
return|;
name|signal
operator|++
expr_stmt|;
comment|// skip code
block|}
name|QByteArray
name|method_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|method_arg
init|=
name|method
decl_stmt|;
name|int
name|membcode
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|method_found
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|method
condition|)
block|{
name|QT_TRY
block|{
name|method_name
operator|=
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|method
operator|=
name|method_name
operator|.
name|constData
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::bad_alloc&
argument_list|)
block|{
comment|// if the method is already normalized, we can continue.
if|if
condition|(
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|indexOfMethod
argument_list|(
name|method
operator|+
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|QT_RETHROW
expr_stmt|;
block|}
name|membcode
operator|=
name|extract_code
argument_list|(
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_method_code
argument_list|(
name|membcode
argument_list|,
name|receiver
argument_list|,
name|method
argument_list|,
literal|"disconnect"
argument_list|)
condition|)
return|return
literal|false
return|;
name|method
operator|++
expr_stmt|;
comment|// skip code
block|}
comment|/* We now iterate through all the sender's and receiver's meta      * objects in order to also disconnect possibly shadowed signals      * and slots with the same signature.     */
name|bool
name|res
init|=
literal|false
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|smeta
init|=
name|sender
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|QByteArray
name|signalName
decl_stmt|;
name|QArgumentTypeArray
name|signalTypes
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QMetaObjectPrivate
operator|::
name|get
argument_list|(
name|smeta
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
condition|)
name|signalName
operator|=
name|QMetaObjectPrivate
operator|::
name|decodeMethodSignature
argument_list|(
name|signal
argument_list|,
name|signalTypes
argument_list|)
expr_stmt|;
name|QByteArray
name|methodName
decl_stmt|;
name|QArgumentTypeArray
name|methodTypes
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|receiver
operator|||
name|QMetaObjectPrivate
operator|::
name|get
argument_list|(
name|receiver
operator|->
name|metaObject
argument_list|()
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
condition|)
name|methodName
operator|=
name|QMetaObjectPrivate
operator|::
name|decodeMethodSignature
argument_list|(
name|method
argument_list|,
name|methodTypes
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|signal_index
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|signal
condition|)
block|{
name|signal_index
operator|=
name|QMetaObjectPrivate
operator|::
name|indexOfSignalRelative
argument_list|(
operator|&
name|smeta
argument_list|,
name|signalName
argument_list|,
name|signalTypes
operator|.
name|size
argument_list|()
argument_list|,
name|signalTypes
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal_index
operator|<
literal|0
condition|)
break|break;
name|signal_index
operator|=
name|QMetaObjectPrivate
operator|::
name|originalClone
argument_list|(
name|smeta
argument_list|,
name|signal_index
argument_list|)
expr_stmt|;
name|int
name|signalOffset
decl_stmt|,
name|methodOffset
decl_stmt|;
name|computeOffsets
argument_list|(
name|smeta
argument_list|,
operator|&
name|signalOffset
argument_list|,
operator|&
name|methodOffset
argument_list|)
expr_stmt|;
name|signal_index
operator|+=
name|signalOffset
expr_stmt|;
name|signal_found
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|method
condition|)
block|{
name|res
operator||=
name|QMetaObjectPrivate
operator|::
name|disconnect
argument_list|(
name|sender
argument_list|,
name|signal_index
argument_list|,
name|smeta
argument_list|,
name|receiver
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QMetaObject
modifier|*
name|rmeta
init|=
name|receiver
operator|->
name|metaObject
argument_list|()
decl_stmt|;
do|do
block|{
name|int
name|method_index
init|=
name|QMetaObjectPrivate
operator|::
name|indexOfMethod
argument_list|(
name|rmeta
argument_list|,
name|methodName
argument_list|,
name|methodTypes
operator|.
name|size
argument_list|()
argument_list|,
name|methodTypes
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|method_index
operator|>=
literal|0
condition|)
while|while
condition|(
name|method_index
operator|<
name|rmeta
operator|->
name|methodOffset
argument_list|()
condition|)
name|rmeta
operator|=
name|rmeta
operator|->
name|superClass
argument_list|()
expr_stmt|;
if|if
condition|(
name|method_index
operator|<
literal|0
condition|)
break|break;
name|res
operator||=
name|QMetaObjectPrivate
operator|::
name|disconnect
argument_list|(
name|sender
argument_list|,
name|signal_index
argument_list|,
name|smeta
argument_list|,
name|receiver
argument_list|,
name|method_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|method_found
operator|=
literal|true
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|rmeta
operator|=
name|rmeta
operator|->
name|superClass
argument_list|()
operator|)
condition|)
do|;
block|}
block|}
do|while
condition|(
name|signal
operator|&&
operator|(
name|smeta
operator|=
name|smeta
operator|->
name|superClass
argument_list|()
operator|)
condition|)
do|;
if|if
condition|(
name|signal
operator|&&
operator|!
name|signal_found
condition|)
block|{
name|err_method_notfound
argument_list|(
name|sender
argument_list|,
name|signal_arg
argument_list|,
literal|"disconnect"
argument_list|)
expr_stmt|;
name|err_info_about_objects
argument_list|(
literal|"disconnect"
argument_list|,
name|sender
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|method
operator|&&
operator|!
name|method_found
condition|)
block|{
name|err_method_notfound
argument_list|(
name|receiver
argument_list|,
name|method_arg
argument_list|,
literal|"disconnect"
argument_list|)
expr_stmt|;
name|err_info_about_objects
argument_list|(
literal|"disconnect"
argument_list|,
name|sender
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
condition|)
block|{
if|if
condition|(
operator|!
name|signal
condition|)
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|)
operator|->
name|disconnectNotify
argument_list|(
name|QMetaMethod
argument_list|()
argument_list|)
expr_stmt|;
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|)
operator|->
name|disconnectNotify
argument_list|(
name|signal
condition|?
operator|(
name|signal
operator|-
literal|1
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Disconnects \a signal in object \a sender from \a method in object     \a receiver. Returns true if the connection is successfully broken;     otherwise returns false.      This function provides the same possibilities like     disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)     but uses QMetaMethod to represent the signal and the method to be disconnected.      Additionally this function returnsfalse and no signals and slots disconnected     if:     \list 1          \li \a signal is not a member of sender class or one of its parent classes.          \li \a method is not a member of receiver class or one of its parent classes.          \li \a signal instance represents not a signal.      \endlist      QMetaMethod() may be used as wildcard in the meaning "any signal" or "any slot in receiving object".     In the same way 0 can be used for \a receiver in the meaning "any receiving object". In this case     method should also be QMetaMethod(). \a sender parameter should be never 0.      \sa disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)  */
end_comment
begin_function
DECL|function|disconnect
name|bool
name|QObject
operator|::
name|disconnect
parameter_list|(
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
specifier|const
name|QMetaMethod
modifier|&
name|signal
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
specifier|const
name|QMetaMethod
modifier|&
name|method
parameter_list|)
block|{
if|if
condition|(
name|sender
operator|==
literal|0
operator|||
operator|(
name|receiver
operator|==
literal|0
operator|&&
name|method
operator|.
name|mobj
operator|!=
literal|0
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::disconnect: Unexpected null parameter"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|signal
operator|.
name|mobj
condition|)
block|{
if|if
condition|(
name|signal
operator|.
name|methodType
argument_list|()
operator|!=
name|QMetaMethod
operator|::
name|Signal
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::%s: Attempt to %s non-signal %s::%s"
argument_list|,
literal|"disconnect"
argument_list|,
literal|"unbind"
argument_list|,
name|sender
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|signal
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|method
operator|.
name|mobj
condition|)
block|{
if|if
condition|(
name|method
operator|.
name|methodType
argument_list|()
operator|==
name|QMetaMethod
operator|::
name|Constructor
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::disconect: cannot use constructor as argument %s::%s"
argument_list|,
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|method
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// Reconstructing SIGNAL() macro result for signal.methodSignature() string
name|QByteArray
name|signalSignature
decl_stmt|;
if|if
condition|(
name|signal
operator|.
name|mobj
condition|)
block|{
name|signalSignature
operator|.
name|reserve
argument_list|(
name|signal
operator|.
name|methodSignature
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|signalSignature
operator|.
name|append
argument_list|(
call|(
name|char
call|)
argument_list|(
name|QSIGNAL_CODE
operator|+
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
name|signalSignature
operator|.
name|append
argument_list|(
name|signal
operator|.
name|methodSignature
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|signal_index
decl_stmt|;
name|int
name|method_index
decl_stmt|;
block|{
name|int
name|dummy
decl_stmt|;
name|QMetaObjectPrivate
operator|::
name|memberIndexes
argument_list|(
name|sender
argument_list|,
name|signal
argument_list|,
operator|&
name|signal_index
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|QMetaObjectPrivate
operator|::
name|memberIndexes
argument_list|(
name|receiver
argument_list|,
name|method
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|method_index
argument_list|)
expr_stmt|;
block|}
comment|// If we are here sender is not null. If signal is not null while signal_index
comment|// is -1 then this signal is not a member of sender.
if|if
condition|(
name|signal
operator|.
name|mobj
operator|&&
name|signal_index
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::disconect: signal %s not found on class %s"
argument_list|,
name|signal
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|sender
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// If this condition is true then method is not a member of receeiver.
if|if
condition|(
name|receiver
operator|&&
name|method
operator|.
name|mobj
operator|&&
name|method_index
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::disconect: method %s not found on class %s"
argument_list|,
name|method
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|QMetaObjectPrivate
operator|::
name|disconnect
argument_list|(
name|sender
argument_list|,
name|signal_index
argument_list|,
name|signal
operator|.
name|mobj
argument_list|,
name|receiver
argument_list|,
name|method_index
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|signal
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// The signal is a wildcard, meaning all signals were disconnected.
comment|// QMetaObjectPrivate::disconnect() doesn't call disconnectNotify()
comment|// per connection in this case. Call it once now, with an invalid
comment|// QMetaMethod as argument, as documented.
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|)
operator|->
name|disconnectNotify
argument_list|(
name|signal
argument_list|)
expr_stmt|;
block|}
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|)
operator|->
name|disconnectNotify
argument_list|(
name|method
operator|.
name|mobj
condition|?
name|signalSignature
operator|.
name|constData
argument_list|()
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \threadsafe      \fn bool QObject::disconnect(const char *signal, const QObject *receiver, const char *method) const     \overload disconnect()      Disconnects \a signal from \a method of \a receiver.      A signal-slot connection is removed when either of the objects     involved are destroyed. */
end_comment
begin_comment
comment|/*!     \fn bool QObject::disconnect(const QObject *receiver, const char *method) const     \overload disconnect()      Disconnects all signals in this object from \a receiver's \a     method.      A signal-slot connection is removed when either of the objects     involved are destroyed. */
end_comment
begin_comment
comment|/*!     \fn void QObject::connectNotify(const char *signal)     \obsolete */
end_comment
begin_function
DECL|function|connectNotify
name|void
name|QObject
operator|::
name|connectNotify
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \fn void QObject::disconnectNotify(const char *signal)     \obsolete */
end_comment
begin_function
DECL|function|disconnectNotify
name|void
name|QObject
operator|::
name|disconnectNotify
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
block|{ }
end_function
begin_comment
comment|/*!     \since 5.0      This virtual function is called when something has been connected     to \a signal in this object.      If you want to compare \a signal with a specific signal, you can     use QMetaMethod::fromSignal() as follows:      \snippet code/src_corelib_kernel_qobject.cpp 32      \warning This function violates the object-oriented principle of     modularity. However, it might be useful when you need to perform     expensive initialization only if something is connected to a     signal.      \sa connect(), disconnectNotify() */
end_comment
begin_function
DECL|function|connectNotify
name|void
name|QObject
operator|::
name|connectNotify
parameter_list|(
specifier|const
name|QMetaMethod
modifier|&
name|signal
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|signal
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      This virtual function is called when something has been     disconnected from \a signal in this object.      See connectNotify() for an example of how to compare     \a signal with a specific signal.      If all signals were disconnected from this object (e.g., the     signal argument to disconnect() was 0), disconnectNotify()     is only called once, and the \a signal will be an invalid     QMetaMethod (QMetaMethod::isValid() returns false).      \warning This function violates the object-oriented principle of     modularity. However, it might be useful for optimizing access to     expensive resources.      \sa disconnect(), connectNotify() */
end_comment
begin_function
DECL|function|disconnectNotify
name|void
name|QObject
operator|::
name|disconnectNotify
parameter_list|(
specifier|const
name|QMetaMethod
modifier|&
name|signal
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|signal
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* \internal     convert a signal index from the method range to the signal range  */
end_comment
begin_function
DECL|function|methodIndexToSignalIndex
specifier|static
name|int
name|methodIndexToSignalIndex
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
modifier|*
name|base
parameter_list|,
name|int
name|signal_index
parameter_list|)
block|{
if|if
condition|(
name|signal_index
operator|<
literal|0
condition|)
return|return
name|signal_index
return|;
specifier|const
name|QMetaObject
modifier|*
name|metaObject
init|=
operator|*
name|base
decl_stmt|;
while|while
condition|(
name|metaObject
operator|&&
name|metaObject
operator|->
name|methodOffset
argument_list|()
operator|>
name|signal_index
condition|)
name|metaObject
operator|=
name|metaObject
operator|->
name|superClass
argument_list|()
expr_stmt|;
if|if
condition|(
name|metaObject
condition|)
block|{
name|int
name|signalOffset
decl_stmt|,
name|methodOffset
decl_stmt|;
name|computeOffsets
argument_list|(
name|metaObject
argument_list|,
operator|&
name|signalOffset
argument_list|,
operator|&
name|methodOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal_index
operator|<
name|metaObject
operator|->
name|methodCount
argument_list|()
condition|)
name|signal_index
operator|=
name|QMetaObjectPrivate
operator|::
name|originalClone
argument_list|(
name|metaObject
argument_list|,
name|signal_index
operator|-
name|methodOffset
argument_list|)
operator|+
name|signalOffset
expr_stmt|;
else|else
name|signal_index
operator|=
name|signal_index
operator|-
name|methodOffset
operator|+
name|signalOffset
expr_stmt|;
operator|*
name|base
operator|=
name|metaObject
expr_stmt|;
block|}
return|return
name|signal_index
return|;
block|}
end_function
begin_comment
comment|/*!\internal    \a types is a 0-terminated vector of meta types for queued    connections.     if \a signal_index is -1, then we effectively connect *all* signals    from the sender to the receiver's slot  */
end_comment
begin_function
DECL|function|connect
name|QMetaObject
operator|::
name|Connection
name|QMetaObject
operator|::
name|connect
parameter_list|(
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|signal_index
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|method_index
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|types
parameter_list|)
block|{
specifier|const
name|QMetaObject
modifier|*
name|smeta
init|=
name|sender
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|signal_index
operator|=
name|methodIndexToSignalIndex
argument_list|(
operator|&
name|smeta
argument_list|,
name|signal_index
argument_list|)
expr_stmt|;
return|return
name|Connection
argument_list|(
name|QMetaObjectPrivate
operator|::
name|connect
argument_list|(
name|sender
argument_list|,
name|signal_index
argument_list|,
name|smeta
argument_list|,
name|receiver
argument_list|,
name|method_index
argument_list|,
literal|0
argument_list|,
comment|//FIXME, we could speed this connection up by computing the relative index
name|type
argument_list|,
name|types
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal    Same as the QMetaObject::connect, but \a signal_index must be the result of QObjectPrivate::signalIndex      method_index is relative to the rmeta metaobject, if rmeta is null, then it is absolute index      the QObjectPrivate::Connection* has a refcount of 2, so it must be passed to a QMetaObject::Connection  */
end_comment
begin_function
DECL|function|connect
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|QMetaObjectPrivate
operator|::
name|connect
parameter_list|(
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|signal_index
parameter_list|,
specifier|const
name|QMetaObject
modifier|*
name|smeta
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|method_index
parameter_list|,
specifier|const
name|QMetaObject
modifier|*
name|rmeta
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|types
parameter_list|)
block|{
name|QObject
modifier|*
name|s
init|=
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|)
decl_stmt|;
name|QObject
modifier|*
name|r
init|=
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|int
name|method_offset
init|=
name|rmeta
condition|?
name|rmeta
operator|->
name|methodOffset
argument_list|()
else|:
literal|0
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|rmeta
operator|||
name|QMetaObjectPrivate
operator|::
name|get
argument_list|(
name|rmeta
argument_list|)
operator|->
name|revision
operator|>=
literal|6
argument_list|)
expr_stmt|;
name|QObjectPrivate
operator|::
name|StaticMetaCallFunction
name|callFunction
init|=
name|rmeta
condition|?
name|rmeta
operator|->
name|d
operator|.
name|static_metacall
else|:
literal|0
decl_stmt|;
name|QOrderedMutexLocker
name|locker
argument_list|(
name|signalSlotLock
argument_list|(
name|sender
argument_list|)
argument_list|,
name|signalSlotLock
argument_list|(
name|receiver
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|&
name|Qt
operator|::
name|UniqueConnection
condition|)
block|{
name|QObjectConnectionListVector
modifier|*
name|connectionLists
init|=
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|s
argument_list|)
operator|->
name|connectionLists
decl_stmt|;
if|if
condition|(
name|connectionLists
operator|&&
name|connectionLists
operator|->
name|count
argument_list|()
operator|>
name|signal_index
condition|)
block|{
specifier|const
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c2
init|=
operator|(
operator|*
name|connectionLists
operator|)
index|[
name|signal_index
index|]
operator|.
name|first
decl_stmt|;
name|int
name|method_index_absolute
init|=
name|method_index
operator|+
name|method_offset
decl_stmt|;
while|while
condition|(
name|c2
condition|)
block|{
if|if
condition|(
name|c2
operator|->
name|receiver
operator|==
name|receiver
operator|&&
name|c2
operator|->
name|method
argument_list|()
operator|==
name|method_index_absolute
condition|)
return|return
literal|0
return|;
name|c2
operator|=
name|c2
operator|->
name|nextConnectionList
expr_stmt|;
block|}
block|}
name|type
operator|&=
name|Qt
operator|::
name|UniqueConnection
operator|-
literal|1
expr_stmt|;
block|}
name|QScopedPointer
argument_list|<
name|QObjectPrivate
operator|::
name|Connection
argument_list|>
name|c
argument_list|(
operator|new
name|QObjectPrivate
operator|::
name|Connection
argument_list|)
decl_stmt|;
name|c
operator|->
name|sender
operator|=
name|s
expr_stmt|;
name|c
operator|->
name|receiver
operator|=
name|r
expr_stmt|;
name|c
operator|->
name|method_relative
operator|=
name|method_index
expr_stmt|;
name|c
operator|->
name|method_offset
operator|=
name|method_offset
expr_stmt|;
name|c
operator|->
name|connectionType
operator|=
name|type
expr_stmt|;
name|c
operator|->
name|isSlotObject
operator|=
literal|false
expr_stmt|;
name|c
operator|->
name|argumentTypes
operator|.
name|store
argument_list|(
name|types
argument_list|)
expr_stmt|;
name|c
operator|->
name|nextConnectionList
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|callFunction
operator|=
name|callFunction
expr_stmt|;
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|s
argument_list|)
operator|->
name|addConnection
argument_list|(
name|signal_index
argument_list|,
name|c
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QMetaMethod
name|smethod
init|=
name|QMetaObjectPrivate
operator|::
name|signal
argument_list|(
name|smeta
argument_list|,
name|signal_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|smethod
operator|.
name|isValid
argument_list|()
condition|)
name|s
operator|->
name|connectNotify
argument_list|(
name|smethod
argument_list|)
expr_stmt|;
return|return
name|c
operator|.
name|take
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!\internal  */
end_comment
begin_function
DECL|function|disconnect
name|bool
name|QMetaObject
operator|::
name|disconnect
parameter_list|(
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|signal_index
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|method_index
parameter_list|)
block|{
specifier|const
name|QMetaObject
modifier|*
name|smeta
init|=
name|sender
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|signal_index
operator|=
name|methodIndexToSignalIndex
argument_list|(
operator|&
name|smeta
argument_list|,
name|signal_index
argument_list|)
expr_stmt|;
return|return
name|QMetaObjectPrivate
operator|::
name|disconnect
argument_list|(
name|sender
argument_list|,
name|signal_index
argument_list|,
name|smeta
argument_list|,
name|receiver
argument_list|,
name|method_index
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!\internal  Disconnect a single signal connection.  If QMetaObject::connect() has been called  multiple times for the same sender, signal_index, receiver and method_index only  one of these connections will be removed.  */
end_comment
begin_function
DECL|function|disconnectOne
name|bool
name|QMetaObject
operator|::
name|disconnectOne
parameter_list|(
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|signal_index
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|method_index
parameter_list|)
block|{
specifier|const
name|QMetaObject
modifier|*
name|smeta
init|=
name|sender
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|signal_index
operator|=
name|methodIndexToSignalIndex
argument_list|(
operator|&
name|smeta
argument_list|,
name|signal_index
argument_list|)
expr_stmt|;
return|return
name|QMetaObjectPrivate
operator|::
name|disconnect
argument_list|(
name|sender
argument_list|,
name|signal_index
argument_list|,
name|smeta
argument_list|,
name|receiver
argument_list|,
name|method_index
argument_list|,
literal|0
argument_list|,
name|QMetaObjectPrivate
operator|::
name|DisconnectOne
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Helper function to remove the connection from the senders list and setting the receivers to 0  */
end_comment
begin_function
DECL|function|disconnectHelper
name|bool
name|QMetaObjectPrivate
operator|::
name|disconnectHelper
parameter_list|(
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|method_index
parameter_list|,
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|QMutex
modifier|*
name|senderMutex
parameter_list|,
name|DisconnectType
name|disconnectType
parameter_list|)
block|{
name|bool
name|success
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|receiver
operator|&&
operator|(
name|receiver
operator|==
literal|0
operator|||
operator|(
name|c
operator|->
name|receiver
operator|==
name|receiver
operator|&&
operator|(
name|method_index
operator|<
literal|0
operator|||
name|c
operator|->
name|method
argument_list|()
operator|==
name|method_index
operator|)
operator|&&
operator|(
name|slot
operator|==
literal|0
operator|||
operator|(
name|c
operator|->
name|isSlotObject
operator|&&
name|c
operator|->
name|slotObj
operator|->
name|compare
argument_list|(
name|slot
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|bool
name|needToUnlock
init|=
literal|false
decl_stmt|;
name|QMutex
modifier|*
name|receiverMutex
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|receiver
condition|)
block|{
name|receiverMutex
operator|=
name|signalSlotLock
argument_list|(
name|c
operator|->
name|receiver
argument_list|)
expr_stmt|;
comment|// need to relock this receiver and sender in the correct order
name|needToUnlock
operator|=
name|QOrderedMutexLocker
operator|::
name|relock
argument_list|(
name|senderMutex
argument_list|,
name|receiverMutex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|receiver
condition|)
block|{
operator|*
name|c
operator|->
name|prev
operator|=
name|c
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|next
condition|)
name|c
operator|->
name|next
operator|->
name|prev
operator|=
name|c
operator|->
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|needToUnlock
condition|)
name|receiverMutex
operator|->
name|unlock
argument_list|()
expr_stmt|;
name|c
operator|->
name|receiver
operator|=
literal|0
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|disconnectType
operator|==
name|DisconnectOne
condition|)
return|return
name|success
return|;
block|}
name|c
operator|=
name|c
operator|->
name|nextConnectionList
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Same as the QMetaObject::disconnect, but \a signal_index must be the result of QObjectPrivate::signalIndex  */
end_comment
begin_function
DECL|function|disconnect
name|bool
name|QMetaObjectPrivate
operator|::
name|disconnect
parameter_list|(
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|signal_index
parameter_list|,
specifier|const
name|QMetaObject
modifier|*
name|smeta
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
name|int
name|method_index
parameter_list|,
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|DisconnectType
name|disconnectType
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sender
condition|)
return|return
literal|false
return|;
name|QObject
modifier|*
name|s
init|=
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|)
decl_stmt|;
name|QMutex
modifier|*
name|senderMutex
init|=
name|signalSlotLock
argument_list|(
name|sender
argument_list|)
decl_stmt|;
name|QMutex
modifier|*
name|receiverMutex
init|=
name|receiver
condition|?
name|signalSlotLock
argument_list|(
name|receiver
argument_list|)
else|:
literal|0
decl_stmt|;
name|QOrderedMutexLocker
name|locker
argument_list|(
name|senderMutex
argument_list|,
name|receiverMutex
argument_list|)
decl_stmt|;
name|QObjectConnectionListVector
modifier|*
name|connectionLists
init|=
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|s
argument_list|)
operator|->
name|connectionLists
decl_stmt|;
if|if
condition|(
operator|!
name|connectionLists
condition|)
return|return
literal|false
return|;
comment|// prevent incoming connections changing the connectionLists while unlocked
operator|++
name|connectionLists
operator|->
name|inUse
expr_stmt|;
name|bool
name|success
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|signal_index
operator|<
literal|0
condition|)
block|{
comment|// remove from all connection lists
for|for
control|(
name|int
name|sig_index
init|=
operator|-
literal|1
init|;
name|sig_index
operator|<
name|connectionLists
operator|->
name|count
argument_list|()
condition|;
operator|++
name|sig_index
control|)
block|{
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
init|=
operator|(
operator|*
name|connectionLists
operator|)
index|[
name|sig_index
index|]
operator|.
name|first
decl_stmt|;
if|if
condition|(
name|disconnectHelper
argument_list|(
name|c
argument_list|,
name|receiver
argument_list|,
name|method_index
argument_list|,
name|slot
argument_list|,
name|senderMutex
argument_list|,
name|disconnectType
argument_list|)
condition|)
block|{
name|success
operator|=
literal|true
expr_stmt|;
name|connectionLists
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|signal_index
operator|<
name|connectionLists
operator|->
name|count
argument_list|()
condition|)
block|{
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
init|=
operator|(
operator|*
name|connectionLists
operator|)
index|[
name|signal_index
index|]
operator|.
name|first
decl_stmt|;
if|if
condition|(
name|disconnectHelper
argument_list|(
name|c
argument_list|,
name|receiver
argument_list|,
name|method_index
argument_list|,
name|slot
argument_list|,
name|senderMutex
argument_list|,
name|disconnectType
argument_list|)
condition|)
block|{
name|success
operator|=
literal|true
expr_stmt|;
name|connectionLists
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
block|}
block|}
operator|--
name|connectionLists
operator|->
name|inUse
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|connectionLists
operator|->
name|inUse
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|connectionLists
operator|->
name|orphaned
operator|&&
operator|!
name|connectionLists
operator|->
name|inUse
condition|)
operator|delete
name|connectionLists
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|QMetaMethod
name|smethod
init|=
name|QMetaObjectPrivate
operator|::
name|signal
argument_list|(
name|smeta
argument_list|,
name|signal_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|smethod
operator|.
name|isValid
argument_list|()
condition|)
name|s
operator|->
name|disconnectNotify
argument_list|(
name|smethod
argument_list|)
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QMetaObject::connectSlotsByName(QObject *object)      Searches recursively for all child objects of the given \a object, and connects     matching signals from them to slots of \a object that follow the following form:      \snippet code/src_corelib_kernel_qobject.cpp 33      Let's assume our object has a child object of type QPushButton with     the \l{QObject::objectName}{object name} \c{button1}. The slot to catch the     button's \c{clicked()} signal would be:      \snippet code/src_corelib_kernel_qobject.cpp 34      \sa QObject::setObjectName()  */
end_comment
begin_function
DECL|function|connectSlotsByName
name|void
name|QMetaObject
operator|::
name|connectSlotsByName
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
condition|)
return|return;
specifier|const
name|QMetaObject
modifier|*
name|mo
init|=
name|o
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|mo
argument_list|)
expr_stmt|;
specifier|const
name|QObjectList
name|list
init|=
name|o
operator|->
name|findChildren
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|QString
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mo
operator|->
name|methodCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QByteArray
name|slotSignature
init|=
name|mo
operator|->
name|method
argument_list|(
name|i
argument_list|)
operator|.
name|methodSignature
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|slot
init|=
name|slotSignature
operator|.
name|constData
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
index|[
literal|0
index|]
operator|!=
literal|'o'
operator|||
name|slot
index|[
literal|1
index|]
operator|!=
literal|'n'
operator|||
name|slot
index|[
literal|2
index|]
operator|!=
literal|'_'
condition|)
continue|continue;
name|bool
name|foundIt
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|list
operator|.
name|count
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|QObject
modifier|*
name|co
init|=
name|list
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|QByteArray
name|objName
init|=
name|co
operator|->
name|objectName
argument_list|()
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|objName
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
name|qstrncmp
argument_list|(
name|slot
operator|+
literal|3
argument_list|,
name|objName
operator|.
name|data
argument_list|()
argument_list|,
name|len
argument_list|)
operator|||
name|slot
index|[
name|len
operator|+
literal|3
index|]
operator|!=
literal|'_'
condition|)
continue|continue;
specifier|const
name|QMetaObject
modifier|*
name|smeta
decl_stmt|;
name|int
name|sigIndex
init|=
name|co
operator|->
name|d_func
argument_list|()
operator|->
name|signalIndex
argument_list|(
name|slot
operator|+
name|len
operator|+
literal|4
argument_list|,
operator|&
name|smeta
argument_list|)
decl_stmt|;
if|if
condition|(
name|sigIndex
operator|<
literal|0
condition|)
block|{
comment|// search for compatible signals
specifier|const
name|QMetaObject
modifier|*
name|smo
init|=
name|co
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|int
name|slotlen
init|=
name|qstrlen
argument_list|(
name|slot
operator|+
name|len
operator|+
literal|4
argument_list|)
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|co
operator|->
name|metaObject
argument_list|()
operator|->
name|methodCount
argument_list|()
condition|;
operator|++
name|k
control|)
block|{
name|QMetaMethod
name|method
init|=
name|smo
operator|->
name|method
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
operator|.
name|methodType
argument_list|()
operator|!=
name|QMetaMethod
operator|::
name|Signal
condition|)
continue|continue;
if|if
condition|(
operator|!
name|qstrncmp
argument_list|(
name|method
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|slot
operator|+
name|len
operator|+
literal|4
argument_list|,
name|slotlen
argument_list|)
condition|)
block|{
name|smeta
operator|=
name|method
operator|.
name|enclosingMetaObject
argument_list|()
expr_stmt|;
name|int
name|signalOffset
decl_stmt|,
name|methodOffset
decl_stmt|;
name|computeOffsets
argument_list|(
name|smeta
argument_list|,
operator|&
name|signalOffset
argument_list|,
operator|&
name|methodOffset
argument_list|)
expr_stmt|;
name|sigIndex
operator|=
name|k
operator|+
operator|-
name|methodOffset
operator|+
name|signalOffset
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|sigIndex
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|Connection
argument_list|(
name|QMetaObjectPrivate
operator|::
name|connect
argument_list|(
name|co
argument_list|,
name|sigIndex
argument_list|,
name|smeta
argument_list|,
name|o
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|foundIt
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|foundIt
condition|)
block|{
comment|// we found our slot, now skip all overloads
while|while
condition|(
name|mo
operator|->
name|method
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|.
name|attributes
argument_list|()
operator|&
name|QMetaMethod
operator|::
name|Cloned
condition|)
operator|++
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|mo
operator|->
name|method
argument_list|(
name|i
argument_list|)
operator|.
name|attributes
argument_list|()
operator|&
name|QMetaMethod
operator|::
name|Cloned
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMetaObject::connectSlotsByName: No matching signal for %s"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|queued_activate
specifier|static
name|void
name|queued_activate
parameter_list|(
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|signal
parameter_list|,
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
parameter_list|,
name|void
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|int
modifier|*
name|argumentTypes
init|=
name|c
operator|->
name|argumentTypes
operator|.
name|load
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|argumentTypes
operator|&&
name|argumentTypes
operator|!=
operator|&
name|DIRECT_CONNECTION_ONLY
condition|)
block|{
name|QMetaMethod
name|m
init|=
name|sender
operator|->
name|metaObject
argument_list|()
operator|->
name|method
argument_list|(
name|signal
argument_list|)
decl_stmt|;
name|argumentTypes
operator|=
name|queuedConnectionTypes
argument_list|(
name|m
operator|.
name|parameterTypes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argumentTypes
condition|)
comment|// cannot queue arguments
name|argumentTypes
operator|=
operator|&
name|DIRECT_CONNECTION_ONLY
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|argumentTypes
operator|.
name|testAndSetOrdered
argument_list|(
literal|0
argument_list|,
name|argumentTypes
argument_list|)
condition|)
block|{
if|if
condition|(
name|argumentTypes
operator|!=
operator|&
name|DIRECT_CONNECTION_ONLY
condition|)
operator|delete
index|[]
name|argumentTypes
expr_stmt|;
name|argumentTypes
operator|=
name|c
operator|->
name|argumentTypes
operator|.
name|load
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argumentTypes
operator|==
operator|&
name|DIRECT_CONNECTION_ONLY
condition|)
comment|// cannot activate
return|return;
name|int
name|nargs
init|=
literal|1
decl_stmt|;
comment|// include return type
while|while
condition|(
name|argumentTypes
index|[
name|nargs
operator|-
literal|1
index|]
condition|)
operator|++
name|nargs
expr_stmt|;
name|int
modifier|*
name|types
init|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|types
argument_list|)
expr_stmt|;
name|void
modifier|*
modifier|*
name|args
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|types
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|// return type
name|args
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|// return value
for|for
control|(
name|int
name|n
init|=
literal|1
init|;
name|n
operator|<
name|nargs
condition|;
operator|++
name|n
control|)
name|args
index|[
name|n
index|]
operator|=
name|QMetaType
operator|::
name|create
argument_list|(
operator|(
name|types
index|[
name|n
index|]
operator|=
name|argumentTypes
index|[
name|n
operator|-
literal|1
index|]
operator|)
argument_list|,
name|argv
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|QMetaCallEvent
modifier|*
name|ev
init|=
name|c
operator|->
name|isSlotObject
condition|?
operator|new
name|QMetaCallEvent
argument_list|(
name|c
operator|->
name|slotObj
argument_list|,
name|sender
argument_list|,
name|signal
argument_list|,
name|nargs
argument_list|,
name|types
argument_list|,
name|args
argument_list|)
else|:
operator|new
name|QMetaCallEvent
argument_list|(
name|c
operator|->
name|method_offset
argument_list|,
name|c
operator|->
name|method_relative
argument_list|,
name|c
operator|->
name|callFunction
argument_list|,
name|sender
argument_list|,
name|signal
argument_list|,
name|nargs
argument_list|,
name|types
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|c
operator|->
name|receiver
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\internal  */
end_comment
begin_function
DECL|function|activate
name|void
name|QMetaObject
operator|::
name|activate
parameter_list|(
name|QObject
modifier|*
name|sender
parameter_list|,
specifier|const
name|QMetaObject
modifier|*
name|m
parameter_list|,
name|int
name|local_signal_index
parameter_list|,
name|void
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|signalOffset
decl_stmt|;
name|int
name|methodOffset
decl_stmt|;
name|computeOffsets
argument_list|(
name|m
argument_list|,
operator|&
name|signalOffset
argument_list|,
operator|&
name|methodOffset
argument_list|)
expr_stmt|;
name|int
name|signal_index
init|=
name|signalOffset
operator|+
name|local_signal_index
decl_stmt|;
if|if
condition|(
name|sender
operator|->
name|d_func
argument_list|()
operator|->
name|declarativeData
operator|&&
name|QAbstractDeclarativeData
operator|::
name|signalEmitted
condition|)
name|QAbstractDeclarativeData
operator|::
name|signalEmitted
argument_list|(
name|sender
operator|->
name|d_func
argument_list|()
operator|->
name|declarativeData
argument_list|,
name|sender
argument_list|,
name|methodOffset
operator|+
name|local_signal_index
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sender
operator|->
name|d_func
argument_list|()
operator|->
name|isSignalConnected
argument_list|(
name|signal_index
argument_list|)
condition|)
return|return;
comment|// nothing connected to these signals, and no spy
if|if
condition|(
name|sender
operator|->
name|d_func
argument_list|()
operator|->
name|blockSig
condition|)
return|return;
name|int
name|signal_absolute_index
init|=
name|methodOffset
operator|+
name|local_signal_index
decl_stmt|;
name|void
modifier|*
name|empty_argv
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|qt_signal_spy_callback_set
operator|.
name|signal_begin_callback
operator|!=
literal|0
condition|)
block|{
name|qt_signal_spy_callback_set
operator|.
name|signal_begin_callback
argument_list|(
name|sender
argument_list|,
name|signal_absolute_index
argument_list|,
name|argv
condition|?
name|argv
else|:
name|empty_argv
argument_list|)
expr_stmt|;
block|}
name|Qt
operator|::
name|HANDLE
name|currentThreadId
init|=
name|QThread
operator|::
name|currentThreadId
argument_list|()
decl_stmt|;
block|{
name|QMutexLocker
name|locker
argument_list|(
name|signalSlotLock
argument_list|(
name|sender
argument_list|)
argument_list|)
decl_stmt|;
struct|struct
name|ConnectionListsRef
block|{
name|QObjectConnectionListVector
modifier|*
name|connectionLists
decl_stmt|;
name|ConnectionListsRef
parameter_list|(
name|QObjectConnectionListVector
modifier|*
name|connectionLists
parameter_list|)
member_init_list|:
name|connectionLists
argument_list|(
name|connectionLists
argument_list|)
block|{
if|if
condition|(
name|connectionLists
condition|)
operator|++
name|connectionLists
operator|->
name|inUse
expr_stmt|;
block|}
name|~
name|ConnectionListsRef
parameter_list|()
block|{
if|if
condition|(
operator|!
name|connectionLists
condition|)
return|return;
operator|--
name|connectionLists
operator|->
name|inUse
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|connectionLists
operator|->
name|inUse
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|connectionLists
operator|->
name|orphaned
condition|)
block|{
if|if
condition|(
operator|!
name|connectionLists
operator|->
name|inUse
condition|)
operator|delete
name|connectionLists
expr_stmt|;
block|}
block|}
name|QObjectConnectionListVector
modifier|*
name|operator
name|->
parameter_list|()
specifier|const
block|{
return|return
name|connectionLists
return|;
block|}
block|}
struct|;
name|ConnectionListsRef
name|connectionLists
init|=
name|sender
operator|->
name|d_func
argument_list|()
operator|->
name|connectionLists
decl_stmt|;
if|if
condition|(
operator|!
name|connectionLists
operator|.
name|connectionLists
condition|)
block|{
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|qt_signal_spy_callback_set
operator|.
name|signal_end_callback
operator|!=
literal|0
condition|)
name|qt_signal_spy_callback_set
operator|.
name|signal_end_callback
argument_list|(
name|sender
argument_list|,
name|signal_absolute_index
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|QObjectPrivate
operator|::
name|ConnectionList
modifier|*
name|list
decl_stmt|;
if|if
condition|(
name|signal_index
operator|<
name|connectionLists
operator|->
name|count
argument_list|()
condition|)
name|list
operator|=
operator|&
name|connectionLists
operator|->
name|at
argument_list|(
name|signal_index
argument_list|)
expr_stmt|;
else|else
name|list
operator|=
operator|&
name|connectionLists
operator|->
name|allsignals
expr_stmt|;
do|do
block|{
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
init|=
name|list
operator|->
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
continue|continue;
comment|// We need to check against last here to ensure that signals added
comment|// during the signal emission are not emitted in this emission.
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|last
init|=
name|list
operator|->
name|last
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|c
operator|->
name|receiver
condition|)
continue|continue;
name|QObject
modifier|*
specifier|const
name|receiver
init|=
name|c
operator|->
name|receiver
decl_stmt|;
specifier|const
name|bool
name|receiverInSameThread
init|=
name|currentThreadId
operator|==
name|receiver
operator|->
name|d_func
argument_list|()
operator|->
name|threadData
operator|->
name|threadId
decl_stmt|;
comment|// determine if this connection should be sent immediately or
comment|// put into the event queue
if|if
condition|(
operator|(
name|c
operator|->
name|connectionType
operator|==
name|Qt
operator|::
name|AutoConnection
operator|&&
operator|!
name|receiverInSameThread
operator|)
operator|||
operator|(
name|c
operator|->
name|connectionType
operator|==
name|Qt
operator|::
name|QueuedConnection
operator|)
condition|)
block|{
name|queued_activate
argument_list|(
name|sender
argument_list|,
name|signal_absolute_index
argument_list|,
name|c
argument_list|,
name|argv
condition|?
name|argv
else|:
name|empty_argv
argument_list|)
expr_stmt|;
continue|continue;
ifndef|#
directive|ifndef
name|QT_NO_THREAD
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|connectionType
operator|==
name|Qt
operator|::
name|BlockingQueuedConnection
condition|)
block|{
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|receiverInSameThread
condition|)
block|{
name|qWarning
argument_list|(
literal|"Qt: Dead lock detected while activating a BlockingQueuedConnection: "
literal|"Sender is %s(%p), receiver is %s(%p)"
argument_list|,
name|sender
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|sender
argument_list|,
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
block|}
name|QSemaphore
name|semaphore
decl_stmt|;
name|QMetaCallEvent
modifier|*
name|ev
init|=
name|c
operator|->
name|isSlotObject
condition|?
operator|new
name|QMetaCallEvent
argument_list|(
name|c
operator|->
name|slotObj
argument_list|,
name|sender
argument_list|,
name|signal_absolute_index
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|argv
condition|?
name|argv
else|:
name|empty_argv
argument_list|,
operator|&
name|semaphore
argument_list|)
else|:
operator|new
name|QMetaCallEvent
argument_list|(
name|c
operator|->
name|method_offset
argument_list|,
name|c
operator|->
name|method_relative
argument_list|,
name|c
operator|->
name|callFunction
argument_list|,
name|sender
argument_list|,
name|signal_absolute_index
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|argv
condition|?
name|argv
else|:
name|empty_argv
argument_list|,
operator|&
name|semaphore
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|receiver
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|semaphore
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
continue|continue;
endif|#
directive|endif
block|}
name|QConnectionSenderSwitcher
name|sw
decl_stmt|;
if|if
condition|(
name|receiverInSameThread
condition|)
block|{
name|sw
operator|.
name|switchSender
argument_list|(
name|receiver
argument_list|,
name|sender
argument_list|,
name|signal_absolute_index
argument_list|)
expr_stmt|;
block|}
specifier|const
name|QObjectPrivate
operator|::
name|StaticMetaCallFunction
name|callFunction
init|=
name|c
operator|->
name|callFunction
decl_stmt|;
specifier|const
name|int
name|method_relative
init|=
name|c
operator|->
name|method_relative
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|isSlotObject
condition|)
block|{
name|QExplicitlySharedDataPointer
argument_list|<
name|QObject
operator|::
name|QSlotObjectBase
argument_list|>
name|obj
argument_list|(
name|c
operator|->
name|slotObj
argument_list|)
decl_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|obj
operator|->
name|call
argument_list|(
name|receiver
argument_list|,
name|argv
condition|?
name|argv
else|:
name|empty_argv
argument_list|)
expr_stmt|;
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|callFunction
operator|&&
name|c
operator|->
name|method_offset
operator|<=
name|receiver
operator|->
name|metaObject
argument_list|()
operator|->
name|methodOffset
argument_list|()
condition|)
block|{
comment|//we compare the vtable to make sure we are not in the destructor of the object.
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|qt_signal_spy_callback_set
operator|.
name|slot_begin_callback
operator|!=
literal|0
condition|)
name|qt_signal_spy_callback_set
operator|.
name|slot_begin_callback
argument_list|(
name|receiver
argument_list|,
name|c
operator|->
name|method
argument_list|()
argument_list|,
name|argv
condition|?
name|argv
else|:
name|empty_argv
argument_list|)
expr_stmt|;
name|callFunction
argument_list|(
name|receiver
argument_list|,
name|QMetaObject
operator|::
name|InvokeMetaMethod
argument_list|,
name|method_relative
argument_list|,
name|argv
condition|?
name|argv
else|:
name|empty_argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|qt_signal_spy_callback_set
operator|.
name|slot_end_callback
operator|!=
literal|0
condition|)
name|qt_signal_spy_callback_set
operator|.
name|slot_end_callback
argument_list|(
name|receiver
argument_list|,
name|c
operator|->
name|method
argument_list|()
argument_list|)
expr_stmt|;
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|int
name|method
init|=
name|method_relative
operator|+
name|c
operator|->
name|method_offset
decl_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|qt_signal_spy_callback_set
operator|.
name|slot_begin_callback
operator|!=
literal|0
condition|)
block|{
name|qt_signal_spy_callback_set
operator|.
name|slot_begin_callback
argument_list|(
name|receiver
argument_list|,
name|method
argument_list|,
name|argv
condition|?
name|argv
else|:
name|empty_argv
argument_list|)
expr_stmt|;
block|}
name|metacall
argument_list|(
name|receiver
argument_list|,
name|QMetaObject
operator|::
name|InvokeMetaMethod
argument_list|,
name|method
argument_list|,
name|argv
condition|?
name|argv
else|:
name|empty_argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|qt_signal_spy_callback_set
operator|.
name|slot_end_callback
operator|!=
literal|0
condition|)
name|qt_signal_spy_callback_set
operator|.
name|slot_end_callback
argument_list|(
name|receiver
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|connectionLists
operator|->
name|orphaned
condition|)
break|break;
block|}
do|while
condition|(
name|c
operator|!=
name|last
operator|&&
operator|(
name|c
operator|=
name|c
operator|->
name|nextConnectionList
operator|)
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|connectionLists
operator|->
name|orphaned
condition|)
break|break;
block|}
do|while
condition|(
name|list
operator|!=
operator|&
name|connectionLists
operator|->
name|allsignals
operator|&&
comment|//start over for all signals;
operator|(
operator|(
name|list
operator|=
operator|&
name|connectionLists
operator|->
name|allsignals
operator|)
operator|,
literal|true
operator|)
condition|)
do|;
block|}
if|if
condition|(
name|qt_signal_spy_callback_set
operator|.
name|signal_end_callback
operator|!=
literal|0
condition|)
name|qt_signal_spy_callback_set
operator|.
name|signal_end_callback
argument_list|(
name|sender
argument_list|,
name|signal_absolute_index
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\internal    signal_index comes from indexOfMethod() */
end_comment
begin_function
DECL|function|activate
name|void
name|QMetaObject
operator|::
name|activate
parameter_list|(
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|signal_index
parameter_list|,
name|void
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|QMetaObject
modifier|*
name|mo
init|=
name|sender
operator|->
name|metaObject
argument_list|()
decl_stmt|;
while|while
condition|(
name|mo
operator|->
name|methodOffset
argument_list|()
operator|>
name|signal_index
condition|)
name|mo
operator|=
name|mo
operator|->
name|superClass
argument_list|()
expr_stmt|;
name|activate
argument_list|(
name|sender
argument_list|,
name|mo
argument_list|,
name|signal_index
operator|-
name|mo
operator|->
name|methodOffset
argument_list|()
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal     Returns the signal index used in the internal connectionLists vector.      It is different from QMetaObject::indexOfSignal():  indexOfSignal is the same as indexOfMethod     while QObjectPrivate::signalIndex is smaller because it doesn't give index to slots.      If \a meta is not 0, it is set to the meta-object where the signal was found. */
end_comment
begin_function
DECL|function|signalIndex
name|int
name|QObjectPrivate
operator|::
name|signalIndex
parameter_list|(
specifier|const
name|char
modifier|*
name|signalName
parameter_list|,
specifier|const
name|QMetaObject
modifier|*
modifier|*
name|meta
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QObject
argument_list|)
expr_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|base
init|=
name|q
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QMetaObjectPrivate
operator|::
name|get
argument_list|(
name|base
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|QArgumentTypeArray
name|types
decl_stmt|;
name|QByteArray
name|name
init|=
name|QMetaObjectPrivate
operator|::
name|decodeMethodSignature
argument_list|(
name|signalName
argument_list|,
name|types
argument_list|)
decl_stmt|;
name|int
name|relative_index
init|=
name|QMetaObjectPrivate
operator|::
name|indexOfSignalRelative
argument_list|(
operator|&
name|base
argument_list|,
name|name
argument_list|,
name|types
operator|.
name|size
argument_list|()
argument_list|,
name|types
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|relative_index
operator|<
literal|0
condition|)
return|return
name|relative_index
return|;
name|relative_index
operator|=
name|QMetaObjectPrivate
operator|::
name|originalClone
argument_list|(
name|base
argument_list|,
name|relative_index
argument_list|)
expr_stmt|;
name|int
name|signalOffset
decl_stmt|,
name|methodOffset
decl_stmt|;
name|computeOffsets
argument_list|(
name|base
argument_list|,
operator|&
name|signalOffset
argument_list|,
operator|&
name|methodOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|meta
condition|)
operator|*
name|meta
operator|=
name|base
expr_stmt|;
return|return
name|relative_index
operator|+
name|signalOffset
return|;
block|}
end_function
begin_comment
comment|/*****************************************************************************   Properties  *****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_PROPERTIES
end_ifndef
begin_comment
comment|/*!   Sets the value of the object's \a name property to \a value.    If the property is defined in the class using Q_PROPERTY then   true is returned on success and false otherwise. If the property   is not defined using Q_PROPERTY, and therefore not listed in the   meta-object, it is added as a dynamic property and false is returned.    Information about all available properties is provided through the   metaObject() and dynamicPropertyNames().    Dynamic properties can be queried again using property() and can be   removed by setting the property value to an invalid QVariant.   Changing the value of a dynamic property causes a QDynamicPropertyChangeEvent   to be sent to the object.    \b{Note:} Dynamic properties starting with "_q_" are reserved for internal   purposes.    \sa property(), metaObject(), dynamicPropertyNames() */
end_comment
begin_function
DECL|function|setProperty
name|bool
name|QObject
operator|::
name|setProperty
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|meta
init|=
name|metaObject
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
name|meta
condition|)
return|return
literal|false
return|;
name|int
name|id
init|=
name|meta
operator|->
name|indexOfProperty
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|extraData
condition|)
name|d
operator|->
name|extraData
operator|=
operator|new
name|QObjectPrivate
operator|::
name|ExtraData
expr_stmt|;
specifier|const
name|int
name|idx
init|=
name|d
operator|->
name|extraData
operator|->
name|propertyNames
operator|.
name|indexOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|extraData
operator|->
name|propertyNames
operator|.
name|removeAt
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|d
operator|->
name|extraData
operator|->
name|propertyValues
operator|.
name|removeAt
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|extraData
operator|->
name|propertyNames
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|d
operator|->
name|extraData
operator|->
name|propertyValues
operator|.
name|append
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|extraData
operator|->
name|propertyValues
index|[
name|idx
index|]
operator|=
name|value
expr_stmt|;
block|}
block|}
name|QDynamicPropertyChangeEvent
name|ev
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|this
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QMetaProperty
name|p
init|=
name|meta
operator|->
name|property
argument_list|(
name|id
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
operator|!
name|p
operator|.
name|isWritable
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"%s::setProperty: Property \"%s\" invalid,"
literal|" read-only or does not exist"
argument_list|,
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|p
operator|.
name|write
argument_list|(
name|this
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the value of the object's \a name property.    If no such property exists, the returned variant is invalid.    Information about all available properties is provided through the   metaObject() and dynamicPropertyNames().    \sa setProperty(), QVariant::isValid(), metaObject(), dynamicPropertyNames() */
end_comment
begin_function
DECL|function|property
name|QVariant
name|QObject
operator|::
name|property
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QObject
argument_list|)
expr_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|meta
init|=
name|metaObject
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
name|meta
condition|)
return|return
name|QVariant
argument_list|()
return|;
name|int
name|id
init|=
name|meta
operator|->
name|indexOfProperty
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|extraData
condition|)
return|return
name|QVariant
argument_list|()
return|;
specifier|const
name|int
name|i
init|=
name|d
operator|->
name|extraData
operator|->
name|propertyNames
operator|.
name|indexOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|extraData
operator|->
name|propertyValues
operator|.
name|value
argument_list|(
name|i
argument_list|)
return|;
block|}
name|QMetaProperty
name|p
init|=
name|meta
operator|->
name|property
argument_list|(
name|id
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
operator|!
name|p
operator|.
name|isReadable
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"%s::property: Property \"%s\" invalid or does not exist"
argument_list|,
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|p
operator|.
name|read
argument_list|(
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the names of all properties that were dynamically added to     the object using setProperty(). */
end_comment
begin_function
DECL|function|dynamicPropertyNames
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QObject
operator|::
name|dynamicPropertyNames
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QObject
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extraData
condition|)
return|return
name|d
operator|->
name|extraData
operator|->
name|propertyNames
return|;
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PROPERTIES
end_comment
begin_comment
comment|/*****************************************************************************   QObject debugging output routines.  *****************************************************************************/
end_comment
begin_function
DECL|function|dumpRecursive
specifier|static
name|void
name|dumpRecursive
parameter_list|(
name|int
name|level
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
if|if
condition|(
name|object
condition|)
block|{
name|QByteArray
name|buf
decl_stmt|;
name|buf
operator|.
name|fill
argument_list|(
literal|' '
argument_list|,
name|level
operator|/
literal|2
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|%
literal|2
condition|)
name|buf
operator|+=
literal|"    "
expr_stmt|;
name|QString
name|name
init|=
name|object
operator|->
name|objectName
argument_list|()
decl_stmt|;
name|QString
name|flags
init|=
name|QLatin1String
argument_list|(
literal|""
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|if (qApp->focusWidget() == object)             flags += 'F';         if (object->isWidgetType()) {             QWidget * w = (QWidget *)object;             if (w->isVisible()) {                 QString t("<%1,%2,%3,%4>");                 flags += t.arg(w->x()).arg(w->y()).arg(w->width()).arg(w->height());             } else {                 flags += 'I';             }         }
endif|#
directive|endif
name|qDebug
argument_list|(
literal|"%s%s::%s %s"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
argument_list|,
name|object
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|name
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|,
name|flags
operator|.
name|toLatin1
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|QObjectList
name|children
init|=
name|object
operator|->
name|children
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|dumpRecursive
argument_list|(
name|level
operator|+
literal|1
argument_list|,
name|children
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|level
argument_list|)
name|Q_UNUSED
argument_list|(
argument|object
argument_list|)
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Dumps a tree of children to the debug output.      This function is useful for debugging, but does nothing if the     library has been compiled in release mode (i.e. without debugging     information).      \sa dumpObjectInfo() */
end_comment
begin_function
DECL|function|dumpObjectTree
name|void
name|QObject
operator|::
name|dumpObjectTree
parameter_list|()
block|{
name|dumpRecursive
argument_list|(
literal|0
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Dumps information about signal connections, etc. for this object     to the debug output.      This function is useful for debugging, but does nothing if the     library has been compiled in release mode (i.e. without debugging     information).      \sa dumpObjectTree() */
end_comment
begin_function
DECL|function|dumpObjectInfo
name|void
name|QObject
operator|::
name|dumpObjectInfo
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"OBJECT %s::%s"
argument_list|,
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|objectName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"unnamed"
else|:
name|objectName
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
name|signalSlotLock
argument_list|(
name|this
argument_list|)
argument_list|)
decl_stmt|;
comment|// first, look for connections where this object is the sender
name|qDebug
argument_list|(
literal|"  SIGNALS OUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connectionLists
condition|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|offsetToNextMetaObject
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|signal_index
init|=
literal|0
init|;
name|signal_index
operator|<
name|d
operator|->
name|connectionLists
operator|->
name|count
argument_list|()
condition|;
operator|++
name|signal_index
control|)
block|{
if|if
condition|(
name|signal_index
operator|>=
name|offsetToNextMetaObject
condition|)
block|{
specifier|const
name|QMetaObject
modifier|*
name|mo
init|=
name|metaObject
argument_list|()
decl_stmt|;
name|int
name|signalOffset
decl_stmt|,
name|methodOffset
decl_stmt|;
name|computeOffsets
argument_list|(
name|mo
argument_list|,
operator|&
name|signalOffset
argument_list|,
operator|&
name|methodOffset
argument_list|)
expr_stmt|;
while|while
condition|(
name|signalOffset
operator|>
name|signal_index
condition|)
block|{
name|mo
operator|=
name|mo
operator|->
name|superClass
argument_list|()
expr_stmt|;
name|offsetToNextMetaObject
operator|=
name|signalOffset
expr_stmt|;
name|computeOffsets
argument_list|(
name|mo
argument_list|,
operator|&
name|signalOffset
argument_list|,
operator|&
name|methodOffset
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
name|methodOffset
operator|-
name|signalOffset
expr_stmt|;
block|}
specifier|const
name|QMetaMethod
name|signal
init|=
name|metaObject
argument_list|()
operator|->
name|method
argument_list|(
name|signal_index
operator|+
name|offset
argument_list|)
decl_stmt|;
name|qDebug
argument_list|(
literal|"        signal: %s"
argument_list|,
name|signal
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
comment|// receivers
specifier|const
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
init|=
name|d
operator|->
name|connectionLists
operator|->
name|at
argument_list|(
name|signal_index
argument_list|)
operator|.
name|first
decl_stmt|;
while|while
condition|(
name|c
condition|)
block|{
if|if
condition|(
operator|!
name|c
operator|->
name|receiver
condition|)
block|{
name|qDebug
argument_list|(
literal|"<Disconnected receiver>"
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|nextConnectionList
expr_stmt|;
continue|continue;
block|}
specifier|const
name|QMetaObject
modifier|*
name|receiverMetaObject
init|=
name|c
operator|->
name|receiver
operator|->
name|metaObject
argument_list|()
decl_stmt|;
specifier|const
name|QMetaMethod
name|method
init|=
name|receiverMetaObject
operator|->
name|method
argument_list|(
name|c
operator|->
name|method
argument_list|()
argument_list|)
decl_stmt|;
name|qDebug
argument_list|(
literal|"          --> %s::%s %s"
argument_list|,
name|receiverMetaObject
operator|->
name|className
argument_list|()
argument_list|,
name|c
operator|->
name|receiver
operator|->
name|objectName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"unnamed"
else|:
name|qPrintable
argument_list|(
name|c
operator|->
name|receiver
operator|->
name|objectName
argument_list|()
argument_list|)
argument_list|,
name|method
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|nextConnectionList
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|qDebug
argument_list|(
literal|"<None>"
argument_list|)
expr_stmt|;
block|}
comment|// now look for connections where this object is the receiver
name|qDebug
argument_list|(
literal|"  SIGNALS IN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|senders
condition|)
block|{
for|for
control|(
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|s
init|=
name|d
operator|->
name|senders
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|QMetaMethod
name|slot
init|=
name|metaObject
argument_list|()
operator|->
name|method
argument_list|(
name|s
operator|->
name|method
argument_list|()
argument_list|)
decl_stmt|;
name|qDebug
argument_list|(
literal|"<-- %s::%s  %s"
argument_list|,
name|s
operator|->
name|sender
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|,
name|s
operator|->
name|sender
operator|->
name|objectName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"unnamed"
else|:
name|qPrintable
argument_list|(
name|s
operator|->
name|sender
operator|->
name|objectName
argument_list|()
argument_list|)
argument_list|,
name|slot
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|qDebug
argument_list|(
literal|"<None>"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_USERDATA
end_ifndef
begin_comment
comment|/*!\internal  */
end_comment
begin_function
DECL|function|registerUserData
name|uint
name|QObject
operator|::
name|registerUserData
parameter_list|()
block|{
specifier|static
name|int
name|user_data_registration
init|=
literal|0
decl_stmt|;
return|return
name|user_data_registration
operator|++
return|;
block|}
end_function
begin_comment
comment|/*!\internal  */
end_comment
begin_destructor
DECL|function|~QObjectUserData
name|QObjectUserData
operator|::
name|~
name|QObjectUserData
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!\internal  */
end_comment
begin_function
DECL|function|setUserData
name|void
name|QObject
operator|::
name|setUserData
parameter_list|(
name|uint
name|id
parameter_list|,
name|QObjectUserData
modifier|*
name|data
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QObject
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|extraData
condition|)
name|d
operator|->
name|extraData
operator|=
operator|new
name|QObjectPrivate
operator|::
name|ExtraData
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|extraData
operator|->
name|userData
operator|.
name|size
argument_list|()
operator|<=
operator|(
name|int
operator|)
name|id
condition|)
name|d
operator|->
name|extraData
operator|->
name|userData
operator|.
name|resize
argument_list|(
operator|(
name|int
operator|)
name|id
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|extraData
operator|->
name|userData
index|[
name|id
index|]
operator|=
name|data
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\internal  */
end_comment
begin_function
DECL|function|userData
name|QObjectUserData
modifier|*
name|QObject
operator|::
name|userData
parameter_list|(
name|uint
name|id
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QObject
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|extraData
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|id
operator|<
name|d
operator|->
name|extraData
operator|->
name|userData
operator|.
name|size
argument_list|()
condition|)
return|return
name|d
operator|->
name|extraData
operator|->
name|userData
operator|.
name|at
argument_list|(
name|id
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_USERDATA
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QObject
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
condition|)
return|return
name|dbg
operator|<<
literal|"QObject(0x0) "
return|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
name|o
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
operator|<<
literal|'('
operator|<<
operator|(
name|void
operator|*
operator|)
name|o
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|objectName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|dbg
operator|<<
literal|", name = "
operator|<<
name|o
operator|->
name|objectName
argument_list|()
expr_stmt|;
name|dbg
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \macro Q_CLASSINFO(Name, Value)     \relates QObject      This macro associates extra information to the class, which is     available using QObject::metaObject(). Except for the ActiveQt     extension, Qt doesn't use this information.      The extra information takes the form of a \a Name string and a \a     Value literal string.      Example:      \snippet code/src_corelib_kernel_qobject.cpp 35      \sa QMetaObject::classInfo() */
end_comment
begin_comment
comment|/*!     \macro Q_INTERFACES(...)     \relates QObject      This macro tells Qt which interfaces the class implements. This     is used when implementing plugins.      Example:      \snippet tools/plugandpaintplugins/basictools/basictoolsplugin.h 1     \dots     \snippet tools/plugandpaintplugins/basictools/basictoolsplugin.h 3      See the \l{tools/plugandpaintplugins/basictools}{Plug& Paint     Basic Tools} example for details.      \sa Q_DECLARE_INTERFACE(), Q_EXPORT_PLUGIN2(), {How to Create Qt Plugins} */
end_comment
begin_comment
comment|/*!     \macro Q_PROPERTY(...)     \relates QObject      This macro is used for declaring properties in classes that     inherit QObject. Properties behave like class data members, but     they have additional features accessible through the \l     {Meta-Object System}.      \snippet code/src_corelib_kernel_qobject.cpp 36      The property name and type and the \c READ function are required.     The type can be any type supported by QVariant, or it can be a     user-defined type.  The other items are optional, but a \c WRITE     function is common.  The attributes default to true except \c USER,     which defaults to false.      For example:      \snippet code/src_corelib_kernel_qobject.cpp 37      For more details about how to use this macro, and a more detailed     example of its use, see the discussion on \l {Qt's Property System}.      \sa {Qt's Property System} */
end_comment
begin_comment
comment|/*!     \macro Q_ENUMS(...)     \relates QObject      This macro registers one or several enum types to the meta-object     system.      For example:      \snippet code/src_corelib_kernel_qobject.cpp 38      If you want to register an enum that is declared in another class,     the enum must be fully qualified with the name of the class     defining it. In addition, the class \e defining the enum has to     inherit QObject as well as declare the enum using Q_ENUMS().      \sa {Qt's Property System} */
end_comment
begin_comment
comment|/*!     \macro Q_FLAGS(...)     \relates QObject      This macro registers one or several \l{QFlags}{flags types} to the     meta-object system. It is typically used in a class definition to declare     that values of a given enum can be used as flags and combined using the     bitwise OR operator.      For example, in QLibrary, the \l{QLibrary::LoadHints}{LoadHints} flag is     declared in the following way:      \snippet code/src_corelib_kernel_qobject.cpp 39a      The declaration of the flags themselves is performed in the public section     of the QLibrary class itself, using the \l Q_DECLARE_FLAGS() macro:      \snippet code/src_corelib_kernel_qobject.cpp 39b      \note This macro takes care of registering individual flag values     with the meta-object system, so it is unnecessary to use Q_ENUMS()     in addition to this macro.      \sa {Qt's Property System} */
end_comment
begin_comment
comment|/*!     \macro Q_OBJECT     \relates QObject      The Q_OBJECT macro must appear in the private section of a class     definition that declares its own signals and slots or that uses     other services provided by Qt's meta-object system.      For example:      \snippet signalsandslots/signalsandslots.h 1     \codeline     \snippet signalsandslots/signalsandslots.h 2     \snippet signalsandslots/signalsandslots.h 3      \note This macro requires the class to be a subclass of QObject. Use     Q_GADGET instead of Q_OBJECT to enable the meta object system's support     for enums in a class that is not a QObject subclass. Q_GADGET makes a     class member, \c{staticMetaObject}, available.     \c{staticMetaObject} is of type QMetaObject and provides access to the     enums declared with Q_ENUMS.     Q_GADGET is provided only for C++.      \sa {Meta-Object System}, {Signals and Slots}, {Qt's Property System} */
end_comment
begin_comment
comment|/*!     \macro Q_SIGNALS     \relates QObject      Use this macro to replace the \c signals keyword in class     declarations, when you want to use Qt Signals and Slots with a     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.      The macro is normally used when \c no_keywords is specified with     the \c CONFIG variable in the \c .pro file, but it can be used     even when \c no_keywords is \e not specified. */
end_comment
begin_comment
comment|/*!     \macro Q_SIGNAL     \relates QObject      This is an additional macro that allows you to mark a single     function as a signal. It can be quite useful, especially when you     use a 3rd-party source code parser which doesn't understand a \c     signals or \c Q_SIGNALS groups.      Use this macro to replace the \c signals keyword in class     declarations, when you want to use Qt Signals and Slots with a     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.      The macro is normally used when \c no_keywords is specified with     the \c CONFIG variable in the \c .pro file, but it can be used     even when \c no_keywords is \e not specified. */
end_comment
begin_comment
comment|/*!     \macro Q_SLOTS     \relates QObject      Use this macro to replace the \c slots keyword in class     declarations, when you want to use Qt Signals and Slots with a     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.      The macro is normally used when \c no_keywords is specified with     the \c CONFIG variable in the \c .pro file, but it can be used     even when \c no_keywords is \e not specified. */
end_comment
begin_comment
comment|/*!     \macro Q_SLOT     \relates QObject      This is an additional macro that allows you to mark a single     function as a slot. It can be quite useful, especially when you     use a 3rd-party source code parser which doesn't understand a \c     slots or \c Q_SLOTS groups.      Use this macro to replace the \c slots keyword in class     declarations, when you want to use Qt Signals and Slots with a     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.      The macro is normally used when \c no_keywords is specified with     the \c CONFIG variable in the \c .pro file, but it can be used     even when \c no_keywords is \e not specified. */
end_comment
begin_comment
comment|/*!     \macro Q_EMIT     \relates QObject      Use this macro to replace the \c emit keyword for emitting     signals, when you want to use Qt Signals and Slots with a     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.      The macro is normally used when \c no_keywords is specified with     the \c CONFIG variable in the \c .pro file, but it can be used     even when \c no_keywords is \e not specified. */
end_comment
begin_comment
comment|/*!     \macro Q_INVOKABLE     \relates QObject      Apply this macro to definitions of member functions to allow them to     be invoked via the meta-object system. The macro is written before     the return type, as shown in the following example:      \snippet qmetaobject-invokable/window.h Window class with invokable method      The \c invokableMethod() function is marked up using Q_INVOKABLE, causing     it to be registered with the meta-object system and enabling it to be     invoked using QMetaObject::invokeMethod().     Since \c normalMethod() function is not registered in this way, it cannot     be invoked using QMetaObject::invokeMethod(). */
end_comment
begin_comment
comment|/*!     \typedef QObjectList     \relates QObject      Synonym for QList<QObject *>. */
end_comment
begin_function
DECL|function|qDeleteInEventHandler
name|void
name|qDeleteInEventHandler
parameter_list|(
name|QObject
modifier|*
name|o
parameter_list|)
block|{
operator|delete
name|o
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type)     \overload connect()     \threadsafe      Creates a connection of the given \a type from the \a signal in     the \a sender object to the \a method in the \a receiver object.     Returns a handle to the connection that can be used to disconnect     it later.      The signal must be a function declared as a signal in the header.     The slot function can be any member function that can be connected     to the signal.     A slot can be connected to a given signal if the signal has at     least as many arguments as the slot, and there is an implicit     conversion between the types of the corresponding arguments in the     signal and the slot.      Example:      \snippet code/src_corelib_kernel_qobject.cpp 44      This example ensures that the label always displays the current     line edit text.      A signal can be connected to many slots and signals. Many signals     can be connected to one slot.      If a signal is connected to several slots, the slots are activated     in the same order as the order the connection was made, when the     signal is emitted      The function returns an handle to a connection if it successfully     connects the signal to the slot. The Connection handle will be invalid     if it cannot create the connection, for example, if QObject is unable     to verify the existence of \a signal (if it was not declared as a signal)     You can check if the QMetaObject::Connection is valid by casting it to a bool.      By default, a signal is emitted for every connection you make;     two signals are emitted for duplicate connections. You can break     all of these connections with a single disconnect() call.     If you pass the Qt::UniqueConnection \a type, the connection will only     be made if it is not a duplicate. If there is already a duplicate     (exact same signal to the exact same slot on the same objects),     the connection will fail and connect will return an invalid QMetaObject::Connection.      The optional \a type parameter describes the type of connection     to establish. In particular, it determines whether a particular     signal is delivered to a slot immediately or queued for delivery     at a later time. If the signal is queued, the parameters must be     of types that are known to Qt's meta-object system, because Qt     needs to copy the arguments to store them in an event behind the     scenes. If you try to use a queued connection and get the error     message      \snippet code/src_corelib_kernel_qobject.cpp 25      make sure to declare the argument type with Q_DECLARE_METATYPE  */
end_comment
begin_comment
comment|/*!     \fn QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, Functor functor)      \threadsafe     \overload connect()      Creates a connection of the given \a type from the \a signal in     the \a sender object to the \a functor and returns a handle to the connection      The signal must be a function declared as a signal in the header.     The slot function can be any function or functor that can be connected     to the signal.     A function can be connected to a given signal if the signal as at     least as many argument as the slot. A functor can be connected to a signal     if they have exactly the same number of arguments. There must exist implicit     conversion between the types of the corresponding arguments in the     signal and the slot.      Example:      \snippet code/src_corelib_kernel_qobject.cpp 45      If your compiler support C++11 lambda expressions, you can use them:      \snippet code/src_corelib_kernel_qobject.cpp 46      The connection will automatically disconnect if the sender is destroyed.  */
end_comment
begin_comment
comment|/** \internal      Implementation of the template version of connect      \a sender is the sender object     \a signal is a pointer to a pointer to a member signal of the sender     \a receiver is the receiver object, may not be null, will be equal to sender when                 connecting to a static function or a functor     \a slot a pointer only used when using Qt::UniqueConnection     \a type the Qt::ConnctionType passed as argument to connect     \a types an array of integer with the metatype id of the parametter of the signal              to be used with queued connection              must stay valid at least for the whole time of the connection, this function              do not take ownership. typically static data.              If null, then the types will be computed when the signal is emit in a queued              connection from the types from the signature.     \a senderMetaObject is the metaobject used to lookup the signal, the signal must be in                         this metaobject  */
end_comment
begin_function
DECL|function|connectImpl
name|QMetaObject
operator|::
name|Connection
name|QObject
operator|::
name|connectImpl
parameter_list|(
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
name|void
modifier|*
modifier|*
name|signal
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|QObject
operator|::
name|QSlotObjectBase
modifier|*
name|slotObj
parameter_list|,
name|Qt
operator|::
name|ConnectionType
name|type
parameter_list|,
specifier|const
name|int
modifier|*
name|types
parameter_list|,
specifier|const
name|QMetaObject
modifier|*
name|senderMetaObject
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sender
operator|||
operator|!
name|signal
operator|||
operator|!
name|slotObj
operator|||
operator|!
name|senderMetaObject
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::connect: invalid null parametter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|slotObj
operator|&&
operator|!
name|slotObj
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|slotObj
expr_stmt|;
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|()
return|;
block|}
name|int
name|signal_index
init|=
operator|-
literal|1
decl_stmt|;
name|void
modifier|*
name|args
index|[]
init|=
block|{
operator|&
name|signal_index
block|,
name|signal
block|}
decl_stmt|;
name|senderMetaObject
operator|->
name|static_metacall
argument_list|(
name|QMetaObject
operator|::
name|IndexOfMethod
argument_list|,
literal|0
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal_index
operator|<
literal|0
operator|||
name|signal_index
operator|>=
name|QMetaObjectPrivate
operator|::
name|get
argument_list|(
name|senderMetaObject
argument_list|)
operator|->
name|signalCount
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::connect: signal not found in %s"
argument_list|,
name|senderMetaObject
operator|->
name|className
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slotObj
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|slotObj
expr_stmt|;
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|int
name|signalOffset
decl_stmt|,
name|methodOffset
decl_stmt|;
name|computeOffsets
argument_list|(
name|senderMetaObject
argument_list|,
operator|&
name|signalOffset
argument_list|,
operator|&
name|methodOffset
argument_list|)
expr_stmt|;
name|signal_index
operator|+=
name|signalOffset
expr_stmt|;
name|QObject
modifier|*
name|s
init|=
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|)
decl_stmt|;
name|QObject
modifier|*
name|r
init|=
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
name|QOrderedMutexLocker
name|locker
argument_list|(
name|signalSlotLock
argument_list|(
name|sender
argument_list|)
argument_list|,
name|signalSlotLock
argument_list|(
name|receiver
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|&
name|Qt
operator|::
name|UniqueConnection
condition|)
block|{
name|QObjectConnectionListVector
modifier|*
name|connectionLists
init|=
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|s
argument_list|)
operator|->
name|connectionLists
decl_stmt|;
if|if
condition|(
name|connectionLists
operator|&&
name|connectionLists
operator|->
name|count
argument_list|()
operator|>
name|signal_index
condition|)
block|{
specifier|const
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c2
init|=
operator|(
operator|*
name|connectionLists
operator|)
index|[
name|signal_index
index|]
operator|.
name|first
decl_stmt|;
while|while
condition|(
name|c2
condition|)
block|{
if|if
condition|(
name|c2
operator|->
name|receiver
operator|==
name|receiver
operator|&&
name|c2
operator|->
name|isSlotObject
operator|&&
name|c2
operator|->
name|slotObj
operator|->
name|compare
argument_list|(
name|slot
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|slotObj
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|slotObj
expr_stmt|;
return|return
name|QMetaObject
operator|::
name|Connection
argument_list|()
return|;
block|}
name|c2
operator|=
name|c2
operator|->
name|nextConnectionList
expr_stmt|;
block|}
block|}
name|type
operator|=
cast|static_cast
argument_list|<
name|Qt
operator|::
name|ConnectionType
argument_list|>
argument_list|(
name|type
operator|^
name|Qt
operator|::
name|UniqueConnection
argument_list|)
expr_stmt|;
block|}
name|QScopedPointer
argument_list|<
name|QObjectPrivate
operator|::
name|Connection
argument_list|>
name|c
argument_list|(
operator|new
name|QObjectPrivate
operator|::
name|Connection
argument_list|)
decl_stmt|;
name|c
operator|->
name|sender
operator|=
name|s
expr_stmt|;
name|c
operator|->
name|receiver
operator|=
name|r
expr_stmt|;
name|c
operator|->
name|slotObj
operator|=
name|slotObj
expr_stmt|;
name|c
operator|->
name|connectionType
operator|=
name|type
expr_stmt|;
name|c
operator|->
name|isSlotObject
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|types
condition|)
block|{
name|c
operator|->
name|argumentTypes
operator|.
name|store
argument_list|(
name|types
argument_list|)
expr_stmt|;
name|c
operator|->
name|ownArgumentTypes
operator|=
literal|false
expr_stmt|;
block|}
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|s
argument_list|)
operator|->
name|addConnection
argument_list|(
name|signal_index
argument_list|,
name|c
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|Connection
name|ret
argument_list|(
name|c
operator|.
name|take
argument_list|()
argument_list|)
decl_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QMetaMethod
name|method
init|=
name|QMetaObjectPrivate
operator|::
name|signal
argument_list|(
name|senderMetaObject
argument_list|,
name|signal_index
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|method
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|->
name|connectNotify
argument_list|(
name|method
argument_list|)
expr_stmt|;
comment|// reconstruct the signature to call connectNotify
specifier|const
name|char
modifier|*
name|sig
decl_stmt|;
name|QByteArray
name|tmp_sig
init|=
name|method
operator|.
name|methodSignature
argument_list|()
decl_stmt|;
name|sig
operator|=
name|tmp_sig
operator|.
name|constData
argument_list|()
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|char
argument_list|>
name|signalSignature
argument_list|(
name|qstrlen
argument_list|(
name|sig
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|signalSignature
operator|.
name|data
argument_list|()
index|[
literal|0
index|]
operator|=
name|char
argument_list|(
name|QSIGNAL_CODE
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|signalSignature
operator|.
name|data
argument_list|()
operator|+
literal|1
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|s
operator|->
name|connectNotify
argument_list|(
name|signalSignature
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Disconnect a connection.      If the \a connection is invalid or has already been disconnected, do nothing     and return false.     \sa connect()  */
end_comment
begin_function
DECL|function|disconnect
name|bool
name|QObject
operator|::
name|disconnect
parameter_list|(
specifier|const
name|QMetaObject
operator|::
name|Connection
modifier|&
name|connection
parameter_list|)
block|{
name|QObjectPrivate
operator|::
name|Connection
modifier|*
name|c
init|=
cast|static_cast
argument_list|<
name|QObjectPrivate
operator|::
name|Connection
operator|*
argument_list|>
argument_list|(
name|connection
operator|.
name|d_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
operator|!
name|c
operator|->
name|receiver
condition|)
return|return
literal|false
return|;
name|QMutex
modifier|*
name|senderMutex
init|=
name|signalSlotLock
argument_list|(
name|c
operator|->
name|sender
argument_list|)
decl_stmt|;
name|QMutex
modifier|*
name|receiverMutex
init|=
name|signalSlotLock
argument_list|(
name|c
operator|->
name|receiver
argument_list|)
decl_stmt|;
name|QOrderedMutexLocker
name|locker
argument_list|(
name|senderMutex
argument_list|,
name|receiverMutex
argument_list|)
decl_stmt|;
name|QObjectConnectionListVector
modifier|*
name|connectionLists
init|=
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|c
operator|->
name|sender
argument_list|)
operator|->
name|connectionLists
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|connectionLists
argument_list|)
expr_stmt|;
name|connectionLists
operator|->
name|dirty
operator|=
literal|true
expr_stmt|;
operator|*
name|c
operator|->
name|prev
operator|=
name|c
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|next
condition|)
name|c
operator|->
name|next
operator|->
name|prev
operator|=
name|c
operator|->
name|prev
expr_stmt|;
name|c
operator|->
name|receiver
operator|=
literal|0
expr_stmt|;
comment|// disconnectNotify() not called (the signal index is unknown).
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QObject::disconnect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method)     \overload diconnect()     \threadsafe      Disconnects \a signal in object \a sender from \a method in object     \a receiver. Returns true if the connection is successfully broken;     otherwise returns false.      A signal-slot connection is removed when either of the objects     involved are destroyed.      disconnect() is typically used in three ways, as the following     examples demonstrate.     \list 1     \li Disconnect everything connected to an object's signals:         \snippet code/src_corelib_kernel_qobject.cpp 26      \li Disconnect everything connected to a specific signal:         \snippet code/src_corelib_kernel_qobject.cpp 47      \li Disconnect a specific receiver:         \snippet code/src_corelib_kernel_qobject.cpp 30      \li Disconnect a connection from one specific signal to a specific slot:         \snippet code/src_corelib_kernel_qobject.cpp 48       \endlist      0 may be used as a wildcard, meaning "any signal", "any receiving     object", or "any slot in the receiving object", respectively.      The \a sender may never be 0. (You cannot disconnect signals from     more than one object in a single call.)      If \a signal is 0, it disconnects \a receiver and \a method from     any signal. If not, only the specified signal is disconnected.      If \a receiver is 0, it disconnects anything connected to \a     signal. If not, slots in objects other than \a receiver are not     disconnected.      If \a method is 0, it disconnects anything that is connected to \a     receiver. If not, only slots named \a method will be disconnected,     and all other slots are left alone. The \a method must be 0 if \a     receiver is left out, so you cannot disconnect a     specifically-named slot on all objects.      \note It is not possible to use this overload to diconnect signals     connected to functors or lambda expressions. That is because it is not     possible to compare them. Instead, use the olverload that take a     QMetaObject::Connection      \sa connect() */
end_comment
begin_function
DECL|function|disconnectImpl
name|bool
name|QObject
operator|::
name|disconnectImpl
parameter_list|(
specifier|const
name|QObject
modifier|*
name|sender
parameter_list|,
name|void
modifier|*
modifier|*
name|signal
parameter_list|,
specifier|const
name|QObject
modifier|*
name|receiver
parameter_list|,
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
specifier|const
name|QMetaObject
modifier|*
name|senderMetaObject
parameter_list|)
block|{
if|if
condition|(
name|sender
operator|==
literal|0
operator|||
operator|(
name|receiver
operator|==
literal|0
operator|&&
name|slot
operator|!=
literal|0
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::disconnect: Unexpected null parameter"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|signal_index
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|signal
condition|)
block|{
name|void
modifier|*
name|args
index|[]
init|=
block|{
operator|&
name|signal_index
block|,
name|signal
block|}
decl_stmt|;
name|senderMetaObject
operator|->
name|static_metacall
argument_list|(
name|QMetaObject
operator|::
name|IndexOfMethod
argument_list|,
literal|0
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal_index
operator|<
literal|0
operator|||
name|signal_index
operator|>=
name|QMetaObjectPrivate
operator|::
name|get
argument_list|(
name|senderMetaObject
argument_list|)
operator|->
name|signalCount
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::disconnect: signal not found in %s"
argument_list|,
name|senderMetaObject
operator|->
name|className
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|signalOffset
decl_stmt|,
name|methodOffset
decl_stmt|;
name|computeOffsets
argument_list|(
name|senderMetaObject
argument_list|,
operator|&
name|signalOffset
argument_list|,
operator|&
name|methodOffset
argument_list|)
expr_stmt|;
name|signal_index
operator|+=
name|signalOffset
expr_stmt|;
block|}
return|return
name|QMetaObjectPrivate
operator|::
name|disconnect
argument_list|(
name|sender
argument_list|,
name|signal_index
argument_list|,
name|senderMetaObject
argument_list|,
name|receiver
argument_list|,
operator|-
literal|1
argument_list|,
name|slot
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \class QMetaObject::Connection      Represents a handle to a signal-slot connection.      It can be used to disconnect that connection, or check if      the connection was successful       \sa QObject::disconnect  */
end_comment
begin_comment
comment|/*!     Create a copy of the handle to the connection  */
end_comment
begin_constructor
DECL|function|Connection
name|QMetaObject
operator|::
name|Connection
operator|::
name|Connection
parameter_list|(
specifier|const
name|QMetaObject
operator|::
name|Connection
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
name|other
operator|.
name|d_ptr
argument_list|)
block|{
if|if
condition|(
name|d_ptr
condition|)
cast|static_cast
argument_list|<
name|QObjectPrivate
operator|::
name|Connection
operator|*
argument_list|>
argument_list|(
name|d_ptr
argument_list|)
operator|->
name|ref
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|operator =
name|QMetaObject
operator|::
name|Connection
modifier|&
name|QMetaObject
operator|::
name|Connection
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QMetaObject
operator|::
name|Connection
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|.
name|d_ptr
operator|!=
name|d_ptr
condition|)
block|{
if|if
condition|(
name|d_ptr
condition|)
cast|static_cast
argument_list|<
name|QObjectPrivate
operator|::
name|Connection
operator|*
argument_list|>
argument_list|(
name|d_ptr
argument_list|)
operator|->
name|deref
argument_list|()
expr_stmt|;
name|d_ptr
operator|=
name|other
operator|.
name|d_ptr
expr_stmt|;
if|if
condition|(
name|other
operator|.
name|d_ptr
condition|)
cast|static_cast
argument_list|<
name|QObjectPrivate
operator|::
name|Connection
operator|*
argument_list|>
argument_list|(
name|other
operator|.
name|d_ptr
argument_list|)
operator|->
name|ref
argument_list|()
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_constructor
DECL|function|Connection
name|QMetaObject
operator|::
name|Connection
operator|::
name|Connection
parameter_list|()
member_init_list|:
name|d_ptr
argument_list|(
literal|0
argument_list|)
block|{}
end_constructor
begin_destructor
DECL|function|~Connection
name|QMetaObject
operator|::
name|Connection
operator|::
name|~
name|Connection
parameter_list|()
block|{
if|if
condition|(
name|d_ptr
condition|)
cast|static_cast
argument_list|<
name|QObjectPrivate
operator|::
name|Connection
operator|*
argument_list|>
argument_list|(
name|d_ptr
argument_list|)
operator|->
name|deref
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn QMetaObject::Connection::operator bool() const      Returns true if the connection is valid.      The connection is valid if the call to QObject::connect succeeded.     The connection is invalid if QObject::connect was not able to find     the signal or the slot, or if the arguments do not match.  */
end_comment
begin_destructor
DECL|function|~QSlotObjectBase
name|QObject
operator|::
name|QSlotObjectBase
operator|::
name|~
name|QSlotObjectBase
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|compare
name|bool
name|QObject
operator|::
name|QSlotObjectBase
operator|::
name|compare
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qobject.cpp"
end_include
end_unit
