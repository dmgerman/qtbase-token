begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qtranslator.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TRANSLATION
end_ifndef
begin_include
include|#
directive|include
file|"qfileinfo.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication_p.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qfile.h"
end_include
begin_include
include|#
directive|include
file|"qmap.h"
end_include
begin_include
include|#
directive|include
file|"qalgorithms.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|"qtranslator_p.h"
end_include
begin_include
include|#
directive|include
file|"qlocale.h"
end_include
begin_include
include|#
directive|include
file|"qendian.h"
end_include
begin_include
include|#
directive|include
file|"qresource.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_INTEGRITY
argument_list|)
end_if
begin_define
DECL|macro|QT_USE_MMAP
define|#
directive|define
name|QT_USE_MMAP
end_define
begin_include
include|#
directive|include
file|"private/qcore_unix_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// most of the headers below are already included in qplatformdefs.h
end_comment
begin_comment
comment|// also this lacks Large File support but that's probably irrelevant
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_MMAP
argument_list|)
end_if
begin_comment
comment|// for mmap
end_comment
begin_include
include|#
directive|include
file|<sys/mman.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|"qobject_p.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|enum|Tag
DECL|enumerator|Tag_End
DECL|enumerator|Tag_SourceText16
DECL|enumerator|Tag_Translation
DECL|enumerator|Tag_Context16
DECL|enumerator|Tag_Obsolete1
name|enum
name|Tag
argument_list|{
name|Tag_End
operator|=
literal|1
argument_list|,
name|Tag_SourceText16
argument_list|,
name|Tag_Translation
argument_list|,
name|Tag_Context16
argument_list|,
name|Tag_Obsolete1
argument_list|,
DECL|enumerator|Tag_SourceText
DECL|enumerator|Tag_Context
DECL|enumerator|Tag_Comment
DECL|enumerator|Tag_Obsolete2
name|Tag_SourceText
argument_list|,
name|Tag_Context
argument_list|,
name|Tag_Comment
argument_list|,
name|Tag_Obsolete2
argument_list|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* $ mcookie 3cb86418caef9c95cd211cbf60a1bddd $ */
end_comment
begin_comment
comment|// magic number for the file
end_comment
begin_decl_stmt
DECL|variable|MagicLength
specifier|static
specifier|const
name|int
name|MagicLength
init|=
literal|16
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|magic
specifier|static
specifier|const
name|uchar
name|magic
index|[
name|MagicLength
index|]
init|=
block|{
literal|0x3c
block|,
literal|0xb8
block|,
literal|0x64
block|,
literal|0x18
block|,
literal|0xca
block|,
literal|0xef
block|,
literal|0x9c
block|,
literal|0x95
block|,
literal|0xcd
block|,
literal|0x21
block|,
literal|0x1c
block|,
literal|0xbf
block|,
literal|0x60
block|,
literal|0xa1
block|,
literal|0xbd
block|,
literal|0xdd
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|match
specifier|static
name|bool
name|match
parameter_list|(
specifier|const
name|uchar
modifier|*
name|found
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
comment|// catch the case if \a found has a zero-terminating symbol and \a len includes it.
comment|// (normalize it to be without the zero-terminating symbol)
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|found
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
operator|--
name|len
expr_stmt|;
return|return
operator|(
name|memcmp
argument_list|(
name|found
argument_list|,
name|target
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|target
index|[
name|len
index|]
operator|==
literal|'\0'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|elfHash_continue
specifier|static
name|void
name|elfHash_continue
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint
modifier|&
name|h
parameter_list|)
block|{
specifier|const
name|uchar
modifier|*
name|k
decl_stmt|;
name|uint
name|g
decl_stmt|;
name|k
operator|=
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|k
condition|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
operator|*
name|k
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
operator|(
name|h
operator|&
literal|0xf0000000
operator|)
operator|)
operator|!=
literal|0
condition|)
name|h
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
name|h
operator|&=
operator|~
name|g
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|elfHash_finish
specifier|static
name|void
name|elfHash_finish
parameter_list|(
name|uint
modifier|&
name|h
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
condition|)
name|h
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|elfHash
specifier|static
name|uint
name|elfHash
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|uint
name|hash
init|=
literal|0
decl_stmt|;
name|elfHash_continue
argument_list|(
name|name
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|elfHash_finish
argument_list|(
name|hash
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function
begin_comment
comment|/*    \internal     Determines whether \a rules are valid "numerus rules". Test input with this    function before calling numerusHelper, below.  */
end_comment
begin_function
DECL|function|isValidNumerusRules
specifier|static
name|bool
name|isValidNumerusRules
parameter_list|(
specifier|const
name|uchar
modifier|*
name|rules
parameter_list|,
name|uint
name|rulesSize
parameter_list|)
block|{
comment|// Disabled computation of maximum numerus return value
comment|// quint32 numerus = 0;
if|if
condition|(
name|rulesSize
operator|==
literal|0
condition|)
return|return
literal|true
return|;
name|quint32
name|offset
init|=
literal|0
decl_stmt|;
do|do
block|{
name|uchar
name|opcode
init|=
name|rules
index|[
name|offset
index|]
decl_stmt|;
name|uchar
name|op
init|=
name|opcode
operator|&
name|Q_OP_MASK
decl_stmt|;
if|if
condition|(
name|opcode
operator|&
literal|0x80
condition|)
return|return
literal|false
return|;
comment|// Bad op
if|if
condition|(
operator|++
name|offset
operator|==
name|rulesSize
condition|)
return|return
literal|false
return|;
comment|// Missing operand
comment|// right operand
operator|++
name|offset
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|Q_EQ
case|:
case|case
name|Q_LT
case|:
case|case
name|Q_LEQ
case|:
break|break;
case|case
name|Q_BETWEEN
case|:
if|if
condition|(
name|offset
operator|!=
name|rulesSize
condition|)
block|{
comment|// third operand
operator|++
name|offset
expr_stmt|;
break|break;
block|}
return|return
literal|false
return|;
comment|// Missing operand
default|default:
return|return
literal|false
return|;
comment|// Bad op (0)
block|}
comment|// ++numerus;
if|if
condition|(
name|offset
operator|==
name|rulesSize
condition|)
return|return
literal|true
return|;
block|}
do|while
condition|(
operator|(
operator|(
name|rules
index|[
name|offset
index|]
operator|==
name|Q_AND
operator|)
operator|||
operator|(
name|rules
index|[
name|offset
index|]
operator|==
name|Q_OR
operator|)
operator|||
operator|(
name|rules
index|[
name|offset
index|]
operator|==
name|Q_NEWRULE
operator|)
operator|)
operator|&&
operator|++
name|offset
operator|!=
name|rulesSize
condition|)
do|;
comment|// Bad op
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*    \internal     This function does no validation of input and assumes it is well-behaved,    these assumptions can be checked with isValidNumerusRules, above.     Determines which translation to use based on the value of \a n. The return    value is an index identifying the translation to be used.     \a rules is a character array of size \a rulesSize containing bytecode that    operates on the value of \a n and ultimately determines the result.     This function has O(1) space and O(rulesSize) time complexity.  */
end_comment
begin_function
DECL|function|numerusHelper
specifier|static
name|uint
name|numerusHelper
parameter_list|(
name|int
name|n
parameter_list|,
specifier|const
name|uchar
modifier|*
name|rules
parameter_list|,
name|uint
name|rulesSize
parameter_list|)
block|{
name|uint
name|result
init|=
literal|0
decl_stmt|;
name|uint
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rulesSize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bool
name|orExprTruthValue
init|=
literal|false
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bool
name|andExprTruthValue
init|=
literal|true
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bool
name|truthValue
init|=
literal|true
decl_stmt|;
name|int
name|opcode
init|=
name|rules
index|[
name|i
operator|++
index|]
decl_stmt|;
name|int
name|leftOperand
init|=
name|n
decl_stmt|;
if|if
condition|(
name|opcode
operator|&
name|Q_MOD_10
condition|)
block|{
name|leftOperand
operator|%=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|&
name|Q_MOD_100
condition|)
block|{
name|leftOperand
operator|%=
literal|100
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|&
name|Q_LEAD_1000
condition|)
block|{
while|while
condition|(
name|leftOperand
operator|>=
literal|1000
condition|)
name|leftOperand
operator|/=
literal|1000
expr_stmt|;
block|}
name|int
name|op
init|=
name|opcode
operator|&
name|Q_OP_MASK
decl_stmt|;
name|int
name|rightOperand
init|=
name|rules
index|[
name|i
operator|++
index|]
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|Q_EQ
case|:
name|truthValue
operator|=
operator|(
name|leftOperand
operator|==
name|rightOperand
operator|)
expr_stmt|;
break|break;
case|case
name|Q_LT
case|:
name|truthValue
operator|=
operator|(
name|leftOperand
operator|<
name|rightOperand
operator|)
expr_stmt|;
break|break;
case|case
name|Q_LEQ
case|:
name|truthValue
operator|=
operator|(
name|leftOperand
operator|<=
name|rightOperand
operator|)
expr_stmt|;
break|break;
case|case
name|Q_BETWEEN
case|:
name|int
name|bottom
init|=
name|rightOperand
decl_stmt|;
name|int
name|top
init|=
name|rules
index|[
name|i
operator|++
index|]
decl_stmt|;
name|truthValue
operator|=
operator|(
name|leftOperand
operator|>=
name|bottom
operator|&&
name|leftOperand
operator|<=
name|top
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|&
name|Q_NOT
condition|)
name|truthValue
operator|=
operator|!
name|truthValue
expr_stmt|;
name|andExprTruthValue
operator|=
name|andExprTruthValue
operator|&&
name|truthValue
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|rulesSize
operator|||
name|rules
index|[
name|i
index|]
operator|!=
name|Q_AND
condition|)
break|break;
operator|++
name|i
expr_stmt|;
block|}
name|orExprTruthValue
operator|=
name|orExprTruthValue
operator|||
name|andExprTruthValue
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|rulesSize
operator|||
name|rules
index|[
name|i
index|]
operator|!=
name|Q_OR
condition|)
break|break;
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|orExprTruthValue
condition|)
return|return
name|result
return|;
operator|++
name|result
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|rulesSize
condition|)
return|return
name|result
return|;
name|i
operator|++
expr_stmt|;
comment|// Q_NEWRULE
block|}
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_class
DECL|class|QTranslatorPrivate
class|class
name|QTranslatorPrivate
super|:
specifier|public
name|QObjectPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QTranslator
parameter_list|)
specifier|public
private|:
DECL|enumerator|Contexts
DECL|enumerator|Hashes
DECL|enumerator|Messages
DECL|enumerator|NumerusRules
DECL|enumerator|Dependencies
enum|enum
block|{
name|Contexts
init|=
literal|0x2f
block|,
name|Hashes
init|=
literal|0x42
block|,
name|Messages
init|=
literal|0x69
block|,
name|NumerusRules
init|=
literal|0x88
block|,
name|Dependencies
init|=
literal|0x96
block|}
enum|;
DECL|function|QTranslatorPrivate
name|QTranslatorPrivate
parameter_list|()
member_init_list|:
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_MMAP
argument_list|)
name|used_mmap
argument_list|(
literal|0
argument_list|)
member_init_list|,
endif|#
directive|endif
name|unmapPointer
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|unmapLength
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|resource
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|messageArray
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|offsetArray
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|contextArray
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|numerusRulesArray
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|messageLength
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|offsetLength
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|contextLength
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|numerusRulesLength
argument_list|(
literal|0
argument_list|)
block|{}
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_MMAP
argument_list|)
name|bool
name|used_mmap
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
DECL|member|unmapPointer
name|char
modifier|*
name|unmapPointer
decl_stmt|;
comment|// used memory (mmap, new or resource file)
DECL|member|unmapLength
name|quint32
name|unmapLength
decl_stmt|;
comment|// The resource object in case we loaded the translations from a resource
DECL|member|resource
name|QResource
modifier|*
name|resource
decl_stmt|;
comment|// used if the translator has dependencies
DECL|member|subTranslators
name|QList
argument_list|<
name|QTranslator
modifier|*
argument_list|>
name|subTranslators
decl_stmt|;
comment|// Pointers and offsets into unmapPointer[unmapLength] array, or user
comment|// provided data array
DECL|member|messageArray
specifier|const
name|uchar
modifier|*
name|messageArray
decl_stmt|;
DECL|member|offsetArray
specifier|const
name|uchar
modifier|*
name|offsetArray
decl_stmt|;
DECL|member|contextArray
specifier|const
name|uchar
modifier|*
name|contextArray
decl_stmt|;
DECL|member|numerusRulesArray
specifier|const
name|uchar
modifier|*
name|numerusRulesArray
decl_stmt|;
DECL|member|messageLength
name|uint
name|messageLength
decl_stmt|;
DECL|member|offsetLength
name|uint
name|offsetLength
decl_stmt|;
DECL|member|contextLength
name|uint
name|contextLength
decl_stmt|;
DECL|member|numerusRulesLength
name|uint
name|numerusRulesLength
decl_stmt|;
name|bool
name|do_load
parameter_list|(
specifier|const
name|QString
modifier|&
name|filename
parameter_list|,
specifier|const
name|QString
modifier|&
name|directory
parameter_list|)
function_decl|;
name|bool
name|do_load
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|QString
modifier|&
name|directory
parameter_list|)
function_decl|;
name|QString
name|do_translate
parameter_list|(
specifier|const
name|char
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|sourceText
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|int
name|n
parameter_list|)
specifier|const
function_decl|;
name|void
name|clear
parameter_list|()
function_decl|;
block|}
class|;
end_class
begin_comment
comment|/*!     \class QTranslator     \inmodule QtCore      \brief The QTranslator class provides internationalization support for text     output.      \ingroup i18n      An object of this class contains a set of translations from a     source language to a target language. QTranslator provides     functions to look up translations in a translation file.     Translation files are created using \l{Qt Linguist}.      The most common use of QTranslator is to: load a translation     file, install it using QCoreApplication::installTranslator(), and use     it via QObject::tr(). Here's an example \c main() function using the     QTranslator:      \snippet hellotrmain.cpp 0      Note that the translator must be created \e before the     application's widgets.      Most applications will never need to do anything else with this     class. The other functions provided by this class are useful for     applications that work on translator files.      \section1 Looking up Translations      It is possible to look up a translation using translate() (as tr()     and QCoreApplication::translate() do). The translate() function takes     up to three parameters:      \list     \li The \e context - usually the class name for the tr() caller.     \li The \e {source text} - usually the argument to tr().     \li The \e disambiguation - an optional string that helps disambiguate        different uses of the same text in the same context.     \endlist      For example, the "Cancel" in a dialog might have "Anuluj" when the     program runs in Polish (in this case the source text would be     "Cancel"). The context would (normally) be the dialog's class     name; there would normally be no comment, and the translated text     would be "Anuluj".      But it's not always so simple. The Spanish version of a printer     dialog with settings for two-sided printing and binding would     probably require both "Activado" and "Activada" as translations     for "Enabled". In this case the source text would be "Enabled" in     both cases, and the context would be the dialog's class name, but     the two items would have disambiguations such as "two-sided printing"     for one and "binding" for the other. The disambiguation enables the     translator to choose the appropriate gender for the Spanish version,     and enables Qt to distinguish between translations.      \section1 Using Multiple Translations      Multiple translation files can be installed in an application.     Translations are searched for in the reverse order in which they were     installed, so the most recently installed translation file is searched     for translations first and the earliest translation file is searched     last. The search stops as soon as a translation containing a matching     string is found.      This mechanism makes it possible for a specific translation to be     "selected" or given priority over the others; simply uninstall the     translator from the application by passing it to the     QCoreApplication::removeTranslator() function and reinstall it with     QCoreApplication::installTranslator(). It will then be the first     translation to be searched for matching strings.      \sa QCoreApplication::installTranslator(), QCoreApplication::removeTranslator(),         QObject::tr(), QCoreApplication::translate(), {I18N Example},         {Hello tr() Example}, {Arrow Pad Example}, {Troll Print Example} */
end_comment
begin_comment
comment|/*!     Constructs an empty message file object with parent \a parent that     is not connected to any file. */
end_comment
begin_constructor
DECL|function|QTranslator
name|QTranslator
operator|::
name|QTranslator
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QTranslatorPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the object and frees any allocated resources. */
end_comment
begin_destructor
DECL|function|~QTranslator
name|QTranslator
operator|::
name|~
name|QTranslator
parameter_list|()
block|{
if|if
condition|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
condition|)
name|QCoreApplication
operator|::
name|removeTranslator
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QTranslator
argument_list|)
expr_stmt|;
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!      Loads \a filename + \a suffix (".qm" if the \a suffix is not     specified), which may be an absolute file name or relative to \a     directory. Returns \c true if the translation is successfully loaded;     otherwise returns \c false.      If \a directory is not specified, the directory of the     application's executable is used (i.e., as     \l{QCoreApplication::}{applicationDirPath()}).      The previous contents of this translator object are discarded.      If the file name does not exist, other file names are tried     in the following order:      \list 1     \li File name without \a suffix appended.     \li File name with text after a character in \a search_delimiters        stripped ("_." is the default for \a search_delimiters if it is        an empty string) and \a suffix.     \li File name stripped without \a suffix appended.     \li File name stripped further, etc.     \endlist      For example, an application running in the fr_CA locale     (French-speaking Canada) might call load("foo.fr_ca",     "/opt/foolib"). load() would then try to open the first existing     readable file from this list:      \list 1     \li \c /opt/foolib/foo.fr_ca.qm     \li \c /opt/foolib/foo.fr_ca     \li \c /opt/foolib/foo.fr.qm     \li \c /opt/foolib/foo.fr     \li \c /opt/foolib/foo.qm     \li \c /opt/foolib/foo     \endlist      Usually, it is better to use the QTranslator::load(const QLocale&,     const QString&, const QString&, const QString&, const QString&)     function instead, because it uses \l{QLocale::uiLanguages()} and not simply     the locale name, which refers to the formatting of dates and numbers and not     necessarily the UI language. */
end_comment
begin_function
DECL|function|load
name|bool
name|QTranslator
operator|::
name|load
parameter_list|(
specifier|const
name|QString
modifier|&
name|filename
parameter_list|,
specifier|const
name|QString
modifier|&
name|directory
parameter_list|,
specifier|const
name|QString
modifier|&
name|search_delimiters
parameter_list|,
specifier|const
name|QString
modifier|&
name|suffix
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTranslator
argument_list|)
expr_stmt|;
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
name|QString
name|prefix
decl_stmt|;
if|if
condition|(
name|QFileInfo
argument_list|(
name|filename
argument_list|)
operator|.
name|isRelative
argument_list|()
condition|)
block|{
name|prefix
operator|=
name|directory
expr_stmt|;
if|if
condition|(
name|prefix
operator|.
name|length
argument_list|()
operator|&&
operator|!
name|prefix
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|prefix
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|QString
name|fname
init|=
name|filename
decl_stmt|;
name|QString
name|realname
decl_stmt|;
name|QString
name|delims
decl_stmt|;
name|delims
operator|=
name|search_delimiters
operator|.
name|isNull
argument_list|()
condition|?
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"_."
argument_list|)
else|:
name|search_delimiters
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|QFileInfo
name|fi
decl_stmt|;
name|realname
operator|=
name|prefix
operator|+
name|fname
operator|+
operator|(
name|suffix
operator|.
name|isNull
argument_list|()
condition|?
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|".qm"
argument_list|)
else|:
name|suffix
operator|)
expr_stmt|;
name|fi
operator|.
name|setFile
argument_list|(
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|.
name|isReadable
argument_list|()
operator|&&
name|fi
operator|.
name|isFile
argument_list|()
condition|)
break|break;
name|realname
operator|=
name|prefix
operator|+
name|fname
expr_stmt|;
name|fi
operator|.
name|setFile
argument_list|(
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|.
name|isReadable
argument_list|()
operator|&&
name|fi
operator|.
name|isFile
argument_list|()
condition|)
break|break;
name|int
name|rightmost
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|delims
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|k
init|=
name|fname
operator|.
name|lastIndexOf
argument_list|(
name|delims
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|>
name|rightmost
condition|)
name|rightmost
operator|=
name|k
expr_stmt|;
block|}
comment|// no truncations? fail
if|if
condition|(
name|rightmost
operator|==
literal|0
condition|)
return|return
literal|false
return|;
name|fname
operator|.
name|truncate
argument_list|(
name|rightmost
argument_list|)
expr_stmt|;
block|}
comment|// realname is now the fully qualified name of a readable file.
return|return
name|d
operator|->
name|do_load
argument_list|(
name|realname
argument_list|,
name|directory
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|do_load
name|bool
name|QTranslatorPrivate
operator|::
name|do_load
parameter_list|(
specifier|const
name|QString
modifier|&
name|realname
parameter_list|,
specifier|const
name|QString
modifier|&
name|directory
parameter_list|)
block|{
name|QTranslatorPrivate
modifier|*
name|d
init|=
name|this
decl_stmt|;
name|bool
name|ok
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|realname
operator|.
name|startsWith
argument_list|(
literal|':'
argument_list|)
condition|)
block|{
comment|// If the translation is in a non-compressed resource file, the data is already in
comment|// memory, so no need to use QFile to copy it again.
name|Q_ASSERT
argument_list|(
operator|!
name|d
operator|->
name|resource
argument_list|)
expr_stmt|;
name|d
operator|->
name|resource
operator|=
operator|new
name|QResource
argument_list|(
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource
operator|->
name|isValid
argument_list|()
operator|&&
operator|!
name|resource
operator|->
name|isCompressed
argument_list|()
operator|&&
name|resource
operator|->
name|size
argument_list|()
operator|>
name|MagicLength
operator|&&
operator|!
name|memcmp
argument_list|(
name|resource
operator|->
name|data
argument_list|()
argument_list|,
name|magic
argument_list|,
name|MagicLength
argument_list|)
condition|)
block|{
name|d
operator|->
name|unmapLength
operator|=
name|resource
operator|->
name|size
argument_list|()
expr_stmt|;
name|d
operator|->
name|unmapPointer
operator|=
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|resource
operator|->
name|data
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_MMAP
argument_list|)
name|d
operator|->
name|used_mmap
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
name|ok
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
operator|delete
name|resource
expr_stmt|;
name|resource
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|QFile
name|file
argument_list|(
name|realname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
operator||
name|QIODevice
operator|::
name|Unbuffered
argument_list|)
condition|)
return|return
literal|false
return|;
name|qint64
name|fileSize
init|=
name|file
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|fileSize
operator|<=
name|MagicLength
operator|||
name|quint32
argument_list|(
operator|-
literal|1
argument_list|)
operator|<=
name|fileSize
condition|)
return|return
literal|false
return|;
block|{
name|char
name|magicBuffer
index|[
name|MagicLength
index|]
decl_stmt|;
if|if
condition|(
name|MagicLength
operator|!=
name|file
operator|.
name|read
argument_list|(
name|magicBuffer
argument_list|,
name|MagicLength
argument_list|)
operator|||
name|memcmp
argument_list|(
name|magicBuffer
argument_list|,
name|magic
argument_list|,
name|MagicLength
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
name|d
operator|->
name|unmapLength
operator|=
name|quint32
argument_list|(
name|fileSize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_USE_MMAP
ifndef|#
directive|ifndef
name|MAP_FILE
DECL|macro|MAP_FILE
define|#
directive|define
name|MAP_FILE
value|0
endif|#
directive|endif
ifndef|#
directive|ifndef
name|MAP_FAILED
DECL|macro|MAP_FAILED
define|#
directive|define
name|MAP_FAILED
value|-1
endif|#
directive|endif
name|int
name|fd
init|=
name|file
operator|.
name|handle
argument_list|()
decl_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|mmap
argument_list|(
literal|0
argument_list|,
name|d
operator|->
name|unmapLength
argument_list|,
comment|// any address, whole file
name|PROT_READ
argument_list|,
comment|// read-only memory
name|MAP_FILE
operator||
name|MAP_PRIVATE
argument_list|,
comment|// swap-backed map from file
name|fd
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// from offset 0 of fd
if|if
condition|(
name|ptr
operator|&&
name|ptr
operator|!=
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|MAP_FAILED
argument_list|)
condition|)
block|{
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|used_mmap
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|unmapPointer
operator|=
name|ptr
expr_stmt|;
name|ok
operator|=
literal|true
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// QT_USE_MMAP
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|d
operator|->
name|unmapPointer
operator|=
operator|new
name|char
index|[
name|d
operator|->
name|unmapLength
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|unmapPointer
condition|)
block|{
name|file
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|qint64
name|readResult
init|=
name|file
operator|.
name|read
argument_list|(
name|d
operator|->
name|unmapPointer
argument_list|,
name|d
operator|->
name|unmapLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|readResult
operator|==
name|qint64
argument_list|(
name|unmapLength
argument_list|)
condition|)
name|ok
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ok
operator|&&
name|d
operator|->
name|do_load
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|unmapPointer
argument_list|)
argument_list|,
name|d
operator|->
name|unmapLength
argument_list|,
name|directory
argument_list|)
condition|)
return|return
literal|true
return|;
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_MMAP
argument_list|)
if|if
condition|(
name|used_mmap
condition|)
block|{
name|used_mmap
operator|=
literal|false
expr_stmt|;
name|munmap
argument_list|(
name|unmapPointer
argument_list|,
name|unmapLength
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|resource
condition|)
operator|delete
index|[]
name|unmapPointer
expr_stmt|;
operator|delete
name|d
operator|->
name|resource
expr_stmt|;
name|d
operator|->
name|resource
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|unmapPointer
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|unmapLength
operator|=
literal|0
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|find_translation
specifier|static
name|QString
name|find_translation
parameter_list|(
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|,
specifier|const
name|QString
modifier|&
name|filename
parameter_list|,
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|,
specifier|const
name|QString
modifier|&
name|directory
parameter_list|,
specifier|const
name|QString
modifier|&
name|suffix
parameter_list|)
block|{
name|QString
name|path
decl_stmt|;
if|if
condition|(
name|QFileInfo
argument_list|(
name|filename
argument_list|)
operator|.
name|isRelative
argument_list|()
condition|)
block|{
name|path
operator|=
name|directory
expr_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|path
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|path
operator|+=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|QFileInfo
name|fi
decl_stmt|;
name|QString
name|realname
decl_stmt|;
name|QStringList
name|fuzzyLocales
decl_stmt|;
comment|// see http://www.unicode.org/reports/tr35/#LanguageMatching for inspiration
name|QStringList
name|languages
init|=
name|locale
operator|.
name|uiLanguages
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
for|for
control|(
name|int
name|i
init|=
name|languages
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QString
name|lang
init|=
name|languages
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QString
name|lowerLang
init|=
name|lang
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|lang
operator|!=
name|lowerLang
condition|)
name|languages
operator|.
name|insert
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|lowerLang
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// try explicit locales names first
foreach|foreach
control|(
name|QString
name|localeName
decl|,
name|languages
control|)
block|{
name|localeName
operator|.
name|replace
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|,
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
argument_list|)
expr_stmt|;
name|realname
operator|=
name|path
operator|+
name|filename
operator|+
name|prefix
operator|+
name|localeName
operator|+
operator|(
name|suffix
operator|.
name|isNull
argument_list|()
condition|?
name|QLatin1String
argument_list|(
literal|".qm"
argument_list|)
else|:
name|suffix
operator|)
expr_stmt|;
name|fi
operator|.
name|setFile
argument_list|(
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|.
name|isReadable
argument_list|()
operator|&&
name|fi
operator|.
name|isFile
argument_list|()
condition|)
return|return
name|realname
return|;
name|realname
operator|=
name|path
operator|+
name|filename
operator|+
name|prefix
operator|+
name|localeName
expr_stmt|;
name|fi
operator|.
name|setFile
argument_list|(
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|.
name|isReadable
argument_list|()
operator|&&
name|fi
operator|.
name|isFile
argument_list|()
condition|)
return|return
name|realname
return|;
name|fuzzyLocales
operator|.
name|append
argument_list|(
name|localeName
argument_list|)
expr_stmt|;
block|}
comment|// start guessing
foreach|foreach
control|(
name|QString
name|localeName
decl|,
name|fuzzyLocales
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|rightmost
init|=
name|localeName
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
argument_list|)
decl_stmt|;
comment|// no truncations? fail
if|if
condition|(
name|rightmost
operator|<=
literal|0
condition|)
break|break;
name|localeName
operator|.
name|truncate
argument_list|(
name|rightmost
argument_list|)
expr_stmt|;
name|realname
operator|=
name|path
operator|+
name|filename
operator|+
name|prefix
operator|+
name|localeName
operator|+
operator|(
name|suffix
operator|.
name|isNull
argument_list|()
condition|?
name|QLatin1String
argument_list|(
literal|".qm"
argument_list|)
else|:
name|suffix
operator|)
expr_stmt|;
name|fi
operator|.
name|setFile
argument_list|(
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|.
name|isReadable
argument_list|()
operator|&&
name|fi
operator|.
name|isFile
argument_list|()
condition|)
return|return
name|realname
return|;
name|realname
operator|=
name|path
operator|+
name|filename
operator|+
name|prefix
operator|+
name|localeName
expr_stmt|;
name|fi
operator|.
name|setFile
argument_list|(
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|.
name|isReadable
argument_list|()
operator|&&
name|fi
operator|.
name|isFile
argument_list|()
condition|)
return|return
name|realname
return|;
block|}
block|}
if|if
condition|(
operator|!
name|suffix
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|realname
operator|=
name|path
operator|+
name|filename
operator|+
name|suffix
expr_stmt|;
name|fi
operator|.
name|setFile
argument_list|(
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|.
name|isReadable
argument_list|()
operator|&&
name|fi
operator|.
name|isFile
argument_list|()
condition|)
return|return
name|realname
return|;
block|}
name|realname
operator|=
name|path
operator|+
name|filename
operator|+
name|prefix
expr_stmt|;
name|fi
operator|.
name|setFile
argument_list|(
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|.
name|isReadable
argument_list|()
operator|&&
name|fi
operator|.
name|isFile
argument_list|()
condition|)
return|return
name|realname
return|;
name|realname
operator|=
name|path
operator|+
name|filename
expr_stmt|;
name|fi
operator|.
name|setFile
argument_list|(
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|.
name|isReadable
argument_list|()
operator|&&
name|fi
operator|.
name|isFile
argument_list|()
condition|)
return|return
name|realname
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Loads \a filename + \a prefix + \l{QLocale::uiLanguages()}{ui language     name} + \a suffix (".qm" if the \a suffix is not specified), which may be     an absolute file name or relative to \a directory. Returns \c true if the     translation is successfully loaded; otherwise returns \c false.      The previous contents of this translator object are discarded.      If the file name does not exist, other file names are tried     in the following order:      \list 1     \li File name without \a suffix appended.     \li File name with ui language part after a "_" character stripped and \a suffix.     \li File name with ui language part stripped without \a suffix appended.     \li File name with ui language part stripped further, etc.     \endlist      For example, an application running in the \a locale with the following     \l{QLocale::uiLanguages()}{ui languages} - "es", "fr-CA", "de" might call     load(QLocale::system(), "foo", ".", "/opt/foolib", ".qm"). load() would     replace '-' (dash) with '_' (underscore) in the ui language and then try to     open the first existing readable file from this list:      \list 1     \li \c /opt/foolib/foo.es.qm     \li \c /opt/foolib/foo.es     \li \c /opt/foolib/foo.fr_CA.qm     \li \c /opt/foolib/foo.fr_CA     \li \c /opt/foolib/foo.de.qm     \li \c /opt/foolib/foo.de     \li \c /opt/foolib/foo.fr.qm     \li \c /opt/foolib/foo.fr     \li \c /opt/foolib/foo.qm     \li \c /opt/foolib/foo.     \li \c /opt/foolib/foo     \endlist      On operating systems where file system is case sensitive, QTranslator also     tries to load a lower-cased version of the locale name. */
end_comment
begin_function
DECL|function|load
name|bool
name|QTranslator
operator|::
name|load
parameter_list|(
specifier|const
name|QLocale
modifier|&
name|locale
parameter_list|,
specifier|const
name|QString
modifier|&
name|filename
parameter_list|,
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|,
specifier|const
name|QString
modifier|&
name|directory
parameter_list|,
specifier|const
name|QString
modifier|&
name|suffix
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTranslator
argument_list|)
expr_stmt|;
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
name|QString
name|fname
init|=
name|find_translation
argument_list|(
name|locale
argument_list|,
name|filename
argument_list|,
name|prefix
argument_list|,
name|directory
argument_list|,
name|suffix
argument_list|)
decl_stmt|;
return|return
operator|!
name|fname
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|do_load
argument_list|(
name|fname
argument_list|,
name|directory
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \overload load()    Loads the QM file data \a data of length \a len into the   translator.    The data is not copied. The caller must be able to guarantee that \a data   will not be deleted or modified.    \a directory is only used to specify the base directory when loading the dependencies   of a QM file. If the file does not have dependencies, this argument is ignored. */
end_comment
begin_function
DECL|function|load
name|bool
name|QTranslator
operator|::
name|load
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|QString
modifier|&
name|directory
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTranslator
argument_list|)
expr_stmt|;
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|||
name|len
operator|<
name|MagicLength
operator|||
name|memcmp
argument_list|(
name|data
argument_list|,
name|magic
argument_list|,
name|MagicLength
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|do_load
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|directory
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|read8
specifier|static
name|quint8
name|read8
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|)
block|{
return|return
name|qFromBigEndian
argument_list|<
name|quint8
argument_list|>
argument_list|(
name|data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|read16
specifier|static
name|quint16
name|read16
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|)
block|{
return|return
name|qFromBigEndian
argument_list|<
name|quint16
argument_list|>
argument_list|(
name|data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|read32
specifier|static
name|quint32
name|read32
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|)
block|{
return|return
name|qFromBigEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|do_load
name|bool
name|QTranslatorPrivate
operator|::
name|do_load
parameter_list|(
specifier|const
name|uchar
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|QString
modifier|&
name|directory
parameter_list|)
block|{
name|bool
name|ok
init|=
literal|true
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|end
init|=
name|data
operator|+
name|len
decl_stmt|;
name|data
operator|+=
name|MagicLength
expr_stmt|;
name|QStringList
name|dependencies
decl_stmt|;
while|while
condition|(
name|data
operator|<
name|end
operator|-
literal|4
condition|)
block|{
name|quint8
name|tag
init|=
name|read8
argument_list|(
name|data
operator|++
argument_list|)
decl_stmt|;
name|quint32
name|blockLen
init|=
name|read32
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|tag
operator|||
operator|!
name|blockLen
condition|)
break|break;
if|if
condition|(
name|quint32
argument_list|(
name|end
operator|-
name|data
argument_list|)
operator|<
name|blockLen
condition|)
block|{
name|ok
operator|=
literal|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tag
operator|==
name|QTranslatorPrivate
operator|::
name|Contexts
condition|)
block|{
name|contextArray
operator|=
name|data
expr_stmt|;
name|contextLength
operator|=
name|blockLen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
name|QTranslatorPrivate
operator|::
name|Hashes
condition|)
block|{
name|offsetArray
operator|=
name|data
expr_stmt|;
name|offsetLength
operator|=
name|blockLen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
name|QTranslatorPrivate
operator|::
name|Messages
condition|)
block|{
name|messageArray
operator|=
name|data
expr_stmt|;
name|messageLength
operator|=
name|blockLen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
name|QTranslatorPrivate
operator|::
name|NumerusRules
condition|)
block|{
name|numerusRulesArray
operator|=
name|data
expr_stmt|;
name|numerusRulesLength
operator|=
name|blockLen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
name|QTranslatorPrivate
operator|::
name|Dependencies
condition|)
block|{
name|QDataStream
name|stream
argument_list|(
name|QByteArray
operator|::
name|fromRawData
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
argument_list|,
name|blockLen
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|dep
decl_stmt|;
while|while
condition|(
operator|!
name|stream
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|stream
operator|>>
name|dep
expr_stmt|;
name|dependencies
operator|.
name|append
argument_list|(
name|dep
argument_list|)
expr_stmt|;
block|}
block|}
name|data
operator|+=
name|blockLen
expr_stmt|;
block|}
if|if
condition|(
name|dependencies
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|!
name|offsetArray
operator|||
operator|!
name|messageArray
operator|)
condition|)
name|ok
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|ok
operator|&&
operator|!
name|isValidNumerusRules
argument_list|(
name|numerusRulesArray
argument_list|,
name|numerusRulesLength
argument_list|)
condition|)
name|ok
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
specifier|const
name|int
name|dependenciesCount
init|=
name|dependencies
operator|.
name|count
argument_list|()
decl_stmt|;
name|subTranslators
operator|.
name|reserve
argument_list|(
name|dependenciesCount
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dependenciesCount
condition|;
operator|++
name|i
control|)
block|{
name|QTranslator
modifier|*
name|translator
init|=
operator|new
name|QTranslator
decl_stmt|;
name|subTranslators
operator|.
name|append
argument_list|(
name|translator
argument_list|)
expr_stmt|;
name|ok
operator|=
name|translator
operator|->
name|load
argument_list|(
name|dependencies
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|directory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
break|break;
block|}
comment|// In case some dependencies fail to load, unload all the other ones too.
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|qDeleteAll
argument_list|(
name|subTranslators
argument_list|)
expr_stmt|;
name|subTranslators
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|messageArray
operator|=
literal|0
expr_stmt|;
name|contextArray
operator|=
literal|0
expr_stmt|;
name|offsetArray
operator|=
literal|0
expr_stmt|;
name|numerusRulesArray
operator|=
literal|0
expr_stmt|;
name|messageLength
operator|=
literal|0
expr_stmt|;
name|contextLength
operator|=
literal|0
expr_stmt|;
name|offsetLength
operator|=
literal|0
expr_stmt|;
name|numerusRulesLength
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function
begin_function
DECL|function|getMessage
specifier|static
name|QString
name|getMessage
parameter_list|(
specifier|const
name|uchar
modifier|*
name|m
parameter_list|,
specifier|const
name|uchar
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|sourceText
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|uint
name|numerus
parameter_list|)
block|{
specifier|const
name|uchar
modifier|*
name|tn
init|=
literal|0
decl_stmt|;
name|uint
name|tn_length
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|uchar
name|tag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m
operator|<
name|end
condition|)
name|tag
operator|=
name|read8
argument_list|(
name|m
operator|++
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|Tag
operator|)
name|tag
condition|)
block|{
case|case
name|Tag_End
case|:
goto|goto
name|end
goto|;
case|case
name|Tag_Translation
case|:
block|{
name|int
name|len
init|=
name|read32
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|%
literal|1
condition|)
return|return
name|QString
argument_list|()
return|;
name|m
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|numerus
operator|--
condition|)
block|{
name|tn_length
operator|=
name|len
expr_stmt|;
name|tn
operator|=
name|m
expr_stmt|;
block|}
name|m
operator|+=
name|len
expr_stmt|;
break|break;
block|}
case|case
name|Tag_Obsolete1
case|:
name|m
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|Tag_SourceText
case|:
block|{
name|quint32
name|len
init|=
name|read32
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|m
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
name|m
argument_list|,
name|sourceText
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|QString
argument_list|()
return|;
name|m
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|Tag_Context
case|:
block|{
name|quint32
name|len
init|=
name|read32
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|m
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
name|m
argument_list|,
name|context
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|QString
argument_list|()
return|;
name|m
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|Tag_Comment
case|:
block|{
name|quint32
name|len
init|=
name|read32
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|m
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|*
name|m
operator|&&
operator|!
name|match
argument_list|(
name|m
argument_list|,
name|comment
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|QString
argument_list|()
return|;
name|m
operator|+=
name|len
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|QString
argument_list|()
return|;
block|}
block|}
name|end
label|:
if|if
condition|(
operator|!
name|tn
condition|)
return|return
name|QString
argument_list|()
return|;
name|QString
name|str
init|=
name|QString
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|tn
argument_list|,
name|tn_length
operator|/
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|LittleEndian
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
name|str
index|[
name|i
index|]
operator|=
name|QChar
argument_list|(
operator|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
operator|>>
literal|8
operator|)
operator|+
operator|(
operator|(
name|str
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
end_function
begin_function
DECL|function|do_translate
name|QString
name|QTranslatorPrivate
operator|::
name|do_translate
parameter_list|(
specifier|const
name|char
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|sourceText
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|int
name|n
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|context
operator|==
literal|0
condition|)
name|context
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|sourceText
operator|==
literal|0
condition|)
name|sourceText
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|comment
operator|==
literal|0
condition|)
name|comment
operator|=
literal|""
expr_stmt|;
name|uint
name|numerus
init|=
literal|0
decl_stmt|;
name|size_t
name|numItems
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|offsetLength
condition|)
goto|goto
name|searchDependencies
goto|;
comment|/*         Check if the context belongs to this QTranslator. If many         translators are installed, this step is necessary.     */
if|if
condition|(
name|contextLength
condition|)
block|{
name|quint16
name|hTableSize
init|=
name|read16
argument_list|(
name|contextArray
argument_list|)
decl_stmt|;
name|uint
name|g
init|=
name|elfHash
argument_list|(
name|context
argument_list|)
operator|%
name|hTableSize
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|c
init|=
name|contextArray
operator|+
literal|2
operator|+
operator|(
name|g
operator|<<
literal|1
operator|)
decl_stmt|;
name|quint16
name|off
init|=
name|read16
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|c
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
return|return
name|QString
argument_list|()
return|;
name|c
operator|=
name|contextArray
operator|+
operator|(
literal|2
operator|+
operator|(
name|hTableSize
operator|<<
literal|1
operator|)
operator|+
operator|(
name|off
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|quint8
name|len
init|=
name|read8
argument_list|(
name|c
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|QString
argument_list|()
return|;
if|if
condition|(
name|match
argument_list|(
name|c
argument_list|,
name|context
argument_list|,
name|len
argument_list|)
condition|)
break|break;
name|c
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|numItems
operator|=
name|offsetLength
operator|/
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|numItems
condition|)
goto|goto
name|searchDependencies
goto|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|numerus
operator|=
name|numerusHelper
argument_list|(
name|n
argument_list|,
name|numerusRulesArray
argument_list|,
name|numerusRulesLength
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|quint32
name|h
init|=
literal|0
decl_stmt|;
name|elfHash_continue
argument_list|(
name|sourceText
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|elfHash_continue
argument_list|(
name|comment
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|elfHash_finish
argument_list|(
name|h
argument_list|)
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|start
init|=
name|offsetArray
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|end
init|=
name|start
operator|+
operator|(
operator|(
name|numItems
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
decl_stmt|;
while|while
condition|(
name|start
operator|<=
name|end
condition|)
block|{
specifier|const
name|uchar
modifier|*
name|middle
init|=
name|start
operator|+
operator|(
operator|(
operator|(
name|end
operator|-
name|start
operator|)
operator|>>
literal|4
operator|)
operator|<<
literal|3
operator|)
decl_stmt|;
name|uint
name|hash
init|=
name|read32
argument_list|(
name|middle
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|hash
condition|)
block|{
name|start
operator|=
name|middle
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|hash
operator|<
name|h
condition|)
block|{
name|start
operator|=
name|middle
operator|+
literal|8
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
name|middle
operator|-
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start
operator|<=
name|end
condition|)
block|{
comment|// go back on equal key
while|while
condition|(
name|start
operator|!=
name|offsetArray
operator|&&
name|read32
argument_list|(
name|start
argument_list|)
operator|==
name|read32
argument_list|(
name|start
operator|-
literal|8
argument_list|)
condition|)
name|start
operator|-=
literal|8
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|offsetArray
operator|+
name|offsetLength
condition|)
block|{
name|quint32
name|rh
init|=
name|read32
argument_list|(
name|start
argument_list|)
decl_stmt|;
name|start
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|rh
operator|!=
name|h
condition|)
break|break;
name|quint32
name|ro
init|=
name|read32
argument_list|(
name|start
argument_list|)
decl_stmt|;
name|start
operator|+=
literal|4
expr_stmt|;
name|QString
name|tn
init|=
name|getMessage
argument_list|(
name|messageArray
operator|+
name|ro
argument_list|,
name|messageArray
operator|+
name|messageLength
argument_list|,
name|context
argument_list|,
name|sourceText
argument_list|,
name|comment
argument_list|,
name|numerus
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tn
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|tn
return|;
block|}
block|}
if|if
condition|(
operator|!
name|comment
index|[
literal|0
index|]
condition|)
break|break;
name|comment
operator|=
literal|""
expr_stmt|;
block|}
name|searchDependencies
label|:
foreach|foreach
control|(
name|QTranslator
modifier|*
name|translator
decl|,
name|subTranslators
control|)
block|{
name|QString
name|tn
init|=
name|translator
operator|->
name|translate
argument_list|(
name|context
argument_list|,
name|sourceText
argument_list|,
name|comment
argument_list|,
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tn
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|tn
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Empties this translator of all contents.      This function works with stripped translator files. */
end_comment
begin_function
DECL|function|clear
name|void
name|QTranslatorPrivate
operator|::
name|clear
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QTranslator
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmapPointer
operator|&&
name|unmapLength
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_MMAP
argument_list|)
if|if
condition|(
name|used_mmap
condition|)
block|{
name|used_mmap
operator|=
literal|false
expr_stmt|;
name|munmap
argument_list|(
name|unmapPointer
argument_list|,
name|unmapLength
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|!
name|resource
condition|)
operator|delete
index|[]
name|unmapPointer
expr_stmt|;
block|}
operator|delete
name|resource
expr_stmt|;
name|resource
operator|=
literal|0
expr_stmt|;
name|unmapPointer
operator|=
literal|0
expr_stmt|;
name|unmapLength
operator|=
literal|0
expr_stmt|;
name|messageArray
operator|=
literal|0
expr_stmt|;
name|contextArray
operator|=
literal|0
expr_stmt|;
name|offsetArray
operator|=
literal|0
expr_stmt|;
name|numerusRulesArray
operator|=
literal|0
expr_stmt|;
name|messageLength
operator|=
literal|0
expr_stmt|;
name|contextLength
operator|=
literal|0
expr_stmt|;
name|offsetLength
operator|=
literal|0
expr_stmt|;
name|numerusRulesLength
operator|=
literal|0
expr_stmt|;
name|qDeleteAll
argument_list|(
name|subTranslators
argument_list|)
expr_stmt|;
name|subTranslators
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|QCoreApplicationPrivate
operator|::
name|isTranslatorInstalled
argument_list|(
name|q
argument_list|)
condition|)
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
argument_list|,
operator|new
name|QEvent
argument_list|(
name|QEvent
operator|::
name|LanguageChange
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the translation for the key (\a context, \a sourceText,     \a disambiguation). If none is found, also tries (\a context, \a     sourceText, ""). If that still fails, returns a null string.      If \a n is not -1, it is used to choose an appropriate form for     the translation (e.g. "%n file found" vs. "%n files found").      If you need to programatically insert translations into a     QTranslator, this function can be reimplemented.      \sa load() */
end_comment
begin_function
DECL|function|translate
name|QString
name|QTranslator
operator|::
name|translate
parameter_list|(
specifier|const
name|char
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|sourceText
parameter_list|,
specifier|const
name|char
modifier|*
name|disambiguation
parameter_list|,
name|int
name|n
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTranslator
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|do_translate
argument_list|(
name|context
argument_list|,
name|sourceText
argument_list|,
name|disambiguation
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this translator is empty, otherwise returns \c false.     This function works with stripped and unstripped translation files. */
end_comment
begin_function
DECL|function|isEmpty
name|bool
name|QTranslator
operator|::
name|isEmpty
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTranslator
argument_list|)
expr_stmt|;
return|return
operator|!
name|d
operator|->
name|unmapPointer
operator|&&
operator|!
name|d
operator|->
name|unmapLength
operator|&&
operator|!
name|d
operator|->
name|messageArray
operator|&&
operator|!
name|d
operator|->
name|offsetArray
operator|&&
operator|!
name|d
operator|->
name|contextArray
operator|&&
name|d
operator|->
name|subTranslators
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TRANSLATION
end_comment
end_unit
