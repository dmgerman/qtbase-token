begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qeventdispatcher_symbian_p.h"
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<private/qcoreapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<qsemaphore.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
ifdef|#
directive|ifdef
name|SYMBIAN_GRAPHICS_WSERV_QT_EFFECTS
comment|// when the system UI is Qt based, priority drop is not needed as CPU starved processes will not be killed.
DECL|macro|QT_SYMBIAN_PRIORITY_DROP
undef|#
directive|undef
name|QT_SYMBIAN_PRIORITY_DROP
else|#
directive|else
define|#
directive|define
name|QT_SYMBIAN_PRIORITY_DROP
endif|#
directive|endif
DECL|macro|WAKE_UP_PRIORITY
define|#
directive|define
name|WAKE_UP_PRIORITY
value|CActive::EPriorityStandard
DECL|macro|TIMER_PRIORITY
define|#
directive|define
name|TIMER_PRIORITY
value|CActive::EPriorityHigh
DECL|macro|NULLTIMER_PRIORITY
define|#
directive|define
name|NULLTIMER_PRIORITY
value|CActive::EPriorityLow
DECL|macro|COMPLETE_DEFERRED_ACTIVE_OBJECTS_PRIORITY
define|#
directive|define
name|COMPLETE_DEFERRED_ACTIVE_OBJECTS_PRIORITY
value|CActive::EPriorityIdle
DECL|function|qt_pipe_write
specifier|static
specifier|inline
name|int
name|qt_pipe_write
parameter_list|(
name|int
name|socket
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
return|return
operator|::
name|write
argument_list|(
name|socket
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|write
argument_list|)
end_if
begin_undef
DECL|macro|write
undef|#
directive|undef
name|write
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qt_pipe_close
specifier|static
specifier|inline
name|int
name|qt_pipe_close
parameter_list|(
name|int
name|socket
parameter_list|)
block|{
return|return
operator|::
name|close
argument_list|(
name|socket
argument_list|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|close
argument_list|)
end_if
begin_undef
DECL|macro|close
undef|#
directive|undef
name|close
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qt_pipe_fcntl
specifier|static
specifier|inline
name|int
name|qt_pipe_fcntl
parameter_list|(
name|int
name|socket
parameter_list|,
name|int
name|command
parameter_list|)
block|{
return|return
operator|::
name|fcntl
argument_list|(
name|socket
argument_list|,
name|command
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qt_pipe2_fcntl
specifier|static
specifier|inline
name|int
name|qt_pipe2_fcntl
parameter_list|(
name|int
name|socket
parameter_list|,
name|int
name|command
parameter_list|,
name|int
name|option
parameter_list|)
block|{
return|return
operator|::
name|fcntl
argument_list|(
name|socket
argument_list|,
name|command
argument_list|,
name|option
argument_list|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|fcntl
argument_list|)
end_if
begin_undef
DECL|macro|fcntl
undef|#
directive|undef
name|fcntl
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qt_socket_select
specifier|static
specifier|inline
name|int
name|qt_socket_select
parameter_list|(
name|int
name|nfds
parameter_list|,
name|fd_set
modifier|*
name|readfds
parameter_list|,
name|fd_set
modifier|*
name|writefds
parameter_list|,
name|fd_set
modifier|*
name|exceptfds
parameter_list|,
name|struct
name|timeval
modifier|*
name|timeout
parameter_list|)
block|{
return|return
operator|::
name|select
argument_list|(
name|nfds
argument_list|,
name|readfds
argument_list|,
name|writefds
argument_list|,
name|exceptfds
argument_list|,
name|timeout
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// This simply interrupts the select and locks the mutex until destroyed.
end_comment
begin_class
DECL|class|QSelectMutexGrabber
class|class
name|QSelectMutexGrabber
block|{
public|public:
DECL|function|QSelectMutexGrabber
name|QSelectMutexGrabber
parameter_list|(
name|int
name|writeFd
parameter_list|,
name|int
name|readFd
parameter_list|,
name|QMutex
modifier|*
name|mutex
parameter_list|)
member_init_list|:
name|m_mutex
argument_list|(
name|mutex
argument_list|)
block|{
if|if
condition|(
name|m_mutex
operator|->
name|tryLock
argument_list|()
condition|)
return|return;
name|char
name|dummy
init|=
literal|0
decl_stmt|;
name|qt_pipe_write
argument_list|(
name|writeFd
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_mutex
operator|->
name|lock
argument_list|()
expr_stmt|;
name|char
name|buffer
decl_stmt|;
while|while
condition|(
operator|::
name|read
argument_list|(
name|readFd
argument_list|,
operator|&
name|buffer
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{}
block|}
DECL|function|~QSelectMutexGrabber
name|~
name|QSelectMutexGrabber
parameter_list|()
block|{
name|m_mutex
operator|->
name|unlock
argument_list|()
expr_stmt|;
block|}
private|private:
DECL|member|m_mutex
name|QMutex
modifier|*
name|m_mutex
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*  * This class is designed to aid in implementing event handling in a more round robin fashion. We  * cannot change active objects that we do not own, but the active objects that Qt owns will use  * this as a base class with convenience functions.  *  * Here is how it works: On every RunL, the deriving class should call maybeQueueForLater().  * This will return whether the active object has been queued, or whether it should run immediately.  * Queued objects will run again after other events have been processed.  *  * The QCompleteDeferredAOs class is a special object that runs after all others, which will  * reactivate the objects that were previously not run.  */
end_comment
begin_constructor
DECL|function|QActiveObject
name|QActiveObject
operator|::
name|QActiveObject
parameter_list|(
name|TInt
name|priority
parameter_list|,
name|QEventDispatcherSymbian
modifier|*
name|dispatcher
parameter_list|)
member_init_list|:
name|CActive
argument_list|(
name|priority
argument_list|)
member_init_list|,
name|m_dispatcher
argument_list|(
name|dispatcher
argument_list|)
member_init_list|,
name|m_hasAlreadyRun
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_hasRunAgain
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_iterationCount
argument_list|(
literal|1
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QActiveObject
name|QActiveObject
operator|::
name|~
name|QActiveObject
parameter_list|()
block|{
if|if
condition|(
name|m_hasRunAgain
condition|)
name|m_dispatcher
operator|->
name|removeDeferredActiveObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|maybeQueueForLater
name|bool
name|QActiveObject
operator|::
name|maybeQueueForLater
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|m_hasRunAgain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_hasAlreadyRun
operator|||
name|m_dispatcher
operator|->
name|iterationCount
argument_list|()
operator|!=
name|m_iterationCount
condition|)
block|{
comment|// First occurrence of this event in this iteration.
name|m_hasAlreadyRun
operator|=
literal|true
expr_stmt|;
name|m_iterationCount
operator|=
name|m_dispatcher
operator|->
name|iterationCount
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// The event has already occurred.
name|m_dispatcher
operator|->
name|addDeferredActiveObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|m_hasRunAgain
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
end_function
begin_function
DECL|function|maybeDeferSocketEvent
name|bool
name|QActiveObject
operator|::
name|maybeDeferSocketEvent
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|m_hasRunAgain
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|m_dispatcher
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_dispatcher
operator|->
name|areSocketEventsBlocked
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|m_hasRunAgain
operator|=
literal|true
expr_stmt|;
name|m_dispatcher
operator|->
name|addDeferredSocketActiveObject
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|reactivateAndComplete
name|void
name|QActiveObject
operator|::
name|reactivateAndComplete
parameter_list|()
block|{
name|TInt
name|error
init|=
name|iStatus
operator|.
name|Int
argument_list|()
decl_stmt|;
name|iStatus
operator|=
name|KRequestPending
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
name|TRequestStatus
modifier|*
name|status
init|=
operator|&
name|iStatus
decl_stmt|;
name|QEventDispatcherSymbian
operator|::
name|RequestComplete
argument_list|(
name|status
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_hasRunAgain
operator|=
literal|false
expr_stmt|;
name|m_hasAlreadyRun
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QWakeUpActiveObject
name|QWakeUpActiveObject
operator|::
name|QWakeUpActiveObject
parameter_list|(
name|QEventDispatcherSymbian
modifier|*
name|dispatcher
parameter_list|)
member_init_list|:
name|QActiveObject
argument_list|(
name|WAKE_UP_PRIORITY
argument_list|,
name|dispatcher
argument_list|)
block|{
name|m_hostThreadId
operator|=
name|RThread
argument_list|()
operator|.
name|Id
argument_list|()
expr_stmt|;
name|CActiveScheduler
operator|::
name|Add
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|iStatus
operator|=
name|KRequestPending
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QWakeUpActiveObject
name|QWakeUpActiveObject
operator|::
name|~
name|QWakeUpActiveObject
parameter_list|()
block|{
name|Cancel
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|DoCancel
name|void
name|QWakeUpActiveObject
operator|::
name|DoCancel
parameter_list|()
block|{
if|if
condition|(
name|iStatus
operator|.
name|Int
argument_list|()
operator|==
name|KRequestPending
condition|)
block|{
name|TRequestStatus
modifier|*
name|status
init|=
operator|&
name|iStatus
decl_stmt|;
name|QEventDispatcherSymbian
operator|::
name|RequestComplete
argument_list|(
name|status
argument_list|,
name|KErrNone
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IsActive
argument_list|()
operator|&&
name|m_hostThreadId
operator|!=
name|RThread
argument_list|()
operator|.
name|Id
argument_list|()
condition|)
block|{
comment|// This is being cancelled in the adopted monitor thread, which can happen if an adopted thread with
comment|// an event loop has exited. The event loop creates an event dispatcher with this active object, which may be complete but not run on exit.
comment|// We force a cancellation in this thread, because a) the object cannot be deleted while active and b) without a cancellation
comment|// the thread semaphore will be one count down.
comment|// It is possible for this problem to affect other active objects. They symptom would be that finished signals
comment|// from adopted threads are not sent, or they arrive much later than they should.
name|TRequestStatus
modifier|*
name|status
init|=
operator|&
name|iStatus
decl_stmt|;
name|User
operator|::
name|RequestComplete
argument_list|(
name|status
argument_list|,
name|KErrNone
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|RunL
name|void
name|QWakeUpActiveObject
operator|::
name|RunL
parameter_list|()
block|{
if|if
condition|(
name|maybeQueueForLater
argument_list|()
condition|)
return|return;
name|iStatus
operator|=
name|KRequestPending
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
name|QT_TRYCATCH_LEAVING
argument_list|(
name|m_dispatcher
operator|->
name|wakeUpWasCalled
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QTimerActiveObject
name|QTimerActiveObject
operator|::
name|QTimerActiveObject
parameter_list|(
name|QEventDispatcherSymbian
modifier|*
name|dispatcher
parameter_list|,
name|SymbianTimerInfo
modifier|*
name|timerInfo
parameter_list|)
member_init_list|:
name|QActiveObject
argument_list|(
operator|(
name|timerInfo
operator|->
name|interval
operator|)
condition|?
name|TIMER_PRIORITY
else|:
name|NULLTIMER_PRIORITY
argument_list|,
name|dispatcher
argument_list|)
member_init_list|,
name|m_timerInfo
argument_list|(
name|timerInfo
argument_list|)
member_init_list|,
name|m_expectedTimeSinceLastEvent
argument_list|(
literal|0
argument_list|)
block|{
comment|// start the timeout timer to ensure initialisation
name|m_timeoutTimer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QTimerActiveObject
name|QTimerActiveObject
operator|::
name|~
name|QTimerActiveObject
parameter_list|()
block|{
name|Cancel
argument_list|()
expr_stmt|;
name|m_rTimer
operator|.
name|Close
argument_list|()
expr_stmt|;
comment|//close of null handle is safe
block|}
end_destructor
begin_function
DECL|function|DoCancel
name|void
name|QTimerActiveObject
operator|::
name|DoCancel
parameter_list|()
block|{
if|if
condition|(
name|m_timerInfo
operator|->
name|interval
operator|>
literal|0
condition|)
block|{
name|m_rTimer
operator|.
name|Cancel
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|iStatus
operator|.
name|Int
argument_list|()
operator|==
name|KRequestPending
condition|)
block|{
name|TRequestStatus
modifier|*
name|status
init|=
operator|&
name|iStatus
decl_stmt|;
name|QEventDispatcherSymbian
operator|::
name|RequestComplete
argument_list|(
name|status
argument_list|,
name|KErrNone
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|RunL
name|void
name|QTimerActiveObject
operator|::
name|RunL
parameter_list|()
block|{
name|int
name|error
init|=
name|KErrNone
decl_stmt|;
if|if
condition|(
name|iStatus
operator|==
name|KErrNone
condition|)
block|{
name|QT_TRYCATCH_ERROR
argument_list|(
name|error
argument_list|,
name|Run
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|iStatus
operator|.
name|Int
argument_list|()
expr_stmt|;
block|}
comment|// All Symbian error codes are negative.
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
name|CActiveScheduler
operator|::
name|Current
argument_list|()
operator|->
name|Error
argument_list|(
name|error
argument_list|)
expr_stmt|;
comment|// stop and report here, as this timer will be deleted on scope exit
block|}
block|}
end_function
begin_define
DECL|macro|MAX_SYMBIAN_TIMEOUT_MS
define|#
directive|define
name|MAX_SYMBIAN_TIMEOUT_MS
value|2000000
end_define
begin_function
DECL|function|StartTimer
name|void
name|QTimerActiveObject
operator|::
name|StartTimer
parameter_list|()
block|{
if|if
condition|(
name|m_timerInfo
operator|->
name|msLeft
operator|>
name|MAX_SYMBIAN_TIMEOUT_MS
condition|)
block|{
comment|//There is loss of accuracy anyway due to needing to restart the timer every 33 minutes,
comment|//so the 1/64s res of After() is acceptable for these very long timers.
name|m_rTimer
operator|.
name|After
argument_list|(
name|iStatus
argument_list|,
name|MAX_SYMBIAN_TIMEOUT_MS
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|m_timerInfo
operator|->
name|msLeft
operator|-=
name|MAX_SYMBIAN_TIMEOUT_MS
expr_stmt|;
block|}
else|else
block|{
comment|// this algorithm implements drift correction for repeating timers
comment|// calculate how late we are for this event
name|int
name|timeSinceLastEvent
init|=
name|m_timeoutTimer
operator|.
name|restart
argument_list|()
decl_stmt|;
name|int
name|overshoot
init|=
name|timeSinceLastEvent
operator|-
name|m_expectedTimeSinceLastEvent
decl_stmt|;
if|if
condition|(
name|overshoot
operator|>
name|m_timerInfo
operator|->
name|msLeft
condition|)
block|{
comment|// we skipped a whole timeout, restart from here
name|overshoot
operator|=
literal|0
expr_stmt|;
block|}
comment|// calculate when the next event should happen
name|int
name|waitTime
init|=
name|m_timerInfo
operator|->
name|msLeft
operator|-
name|overshoot
decl_stmt|;
name|m_expectedTimeSinceLastEvent
operator|=
name|waitTime
expr_stmt|;
comment|// limit the actual ms wait time to avoid wild corrections
comment|// this will cause the real event time to slowly drift back to the expected event time
comment|// measurements show that Symbian timers always fire 1 or 2 ms late
specifier|const
name|int
name|limit
init|=
literal|4
decl_stmt|;
name|waitTime
operator|=
name|qMax
argument_list|(
name|m_timerInfo
operator|->
name|msLeft
operator|-
name|limit
argument_list|,
name|waitTime
argument_list|)
expr_stmt|;
name|m_rTimer
operator|.
name|HighRes
argument_list|(
name|iStatus
argument_list|,
name|waitTime
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|m_timerInfo
operator|->
name|msLeft
operator|=
literal|0
expr_stmt|;
block|}
name|SetActive
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Run
name|void
name|QTimerActiveObject
operator|::
name|Run
parameter_list|()
block|{
comment|//restart timer immediately, if the timeout has been split because it overflows max for platform.
if|if
condition|(
name|m_timerInfo
operator|->
name|msLeft
operator|>
literal|0
condition|)
block|{
name|StartTimer
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|maybeQueueForLater
argument_list|()
condition|)
return|return;
if|if
condition|(
name|m_timerInfo
operator|->
name|interval
operator|>
literal|0
condition|)
block|{
comment|// Start a new timer immediately so that we don't lose time.
name|m_timerInfo
operator|->
name|msLeft
operator|=
name|m_timerInfo
operator|->
name|interval
expr_stmt|;
name|StartTimer
argument_list|()
expr_stmt|;
name|m_timerInfo
operator|->
name|dispatcher
operator|->
name|timerFired
argument_list|(
name|m_timerInfo
operator|->
name|timerId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// However, we only complete zero timers after the event has finished,
comment|// in order to prevent busy looping when doing nested loops.
comment|// Keep the refpointer around in order to avoid deletion until the end of this function.
name|SymbianTimerInfoPtr
name|timerInfoPtr
argument_list|(
name|m_timerInfo
argument_list|)
decl_stmt|;
name|m_timerInfo
operator|->
name|dispatcher
operator|->
name|timerFired
argument_list|(
name|m_timerInfo
operator|->
name|timerId
argument_list|)
expr_stmt|;
name|iStatus
operator|=
name|KRequestPending
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
name|TRequestStatus
modifier|*
name|status
init|=
operator|&
name|iStatus
decl_stmt|;
name|QEventDispatcherSymbian
operator|::
name|RequestComplete
argument_list|(
name|status
argument_list|,
name|KErrNone
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|Start
name|void
name|QTimerActiveObject
operator|::
name|Start
parameter_list|()
block|{
name|CActiveScheduler
operator|::
name|Add
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|m_timerInfo
operator|->
name|msLeft
operator|=
name|m_timerInfo
operator|->
name|interval
expr_stmt|;
if|if
condition|(
name|m_timerInfo
operator|->
name|interval
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|m_rTimer
operator|.
name|Handle
argument_list|()
condition|)
block|{
name|qt_symbian_throwIfError
argument_list|(
name|m_rTimer
operator|.
name|CreateLocal
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|m_timeoutTimer
operator|.
name|start
argument_list|()
expr_stmt|;
name|m_expectedTimeSinceLastEvent
operator|=
literal|0
expr_stmt|;
name|StartTimer
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|iStatus
operator|=
name|KRequestPending
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
name|TRequestStatus
modifier|*
name|status
init|=
operator|&
name|iStatus
decl_stmt|;
name|QEventDispatcherSymbian
operator|::
name|RequestComplete
argument_list|(
name|status
argument_list|,
name|KErrNone
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_constructor
DECL|function|SymbianTimerInfo
name|SymbianTimerInfo
operator|::
name|SymbianTimerInfo
parameter_list|()
member_init_list|:
name|timerAO
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~SymbianTimerInfo
name|SymbianTimerInfo
operator|::
name|~
name|SymbianTimerInfo
parameter_list|()
block|{
operator|delete
name|timerAO
expr_stmt|;
block|}
end_destructor
begin_constructor
DECL|function|QCompleteDeferredAOs
name|QCompleteDeferredAOs
operator|::
name|QCompleteDeferredAOs
parameter_list|(
name|QEventDispatcherSymbian
modifier|*
name|dispatcher
parameter_list|)
member_init_list|:
name|CActive
argument_list|(
name|COMPLETE_DEFERRED_ACTIVE_OBJECTS_PRIORITY
argument_list|)
member_init_list|,
name|m_dispatcher
argument_list|(
name|dispatcher
argument_list|)
block|{
name|CActiveScheduler
operator|::
name|Add
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|iStatus
operator|=
name|KRequestPending
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QCompleteDeferredAOs
name|QCompleteDeferredAOs
operator|::
name|~
name|QCompleteDeferredAOs
parameter_list|()
block|{
name|Cancel
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|complete
name|void
name|QCompleteDeferredAOs
operator|::
name|complete
parameter_list|()
block|{
if|if
condition|(
name|iStatus
operator|.
name|Int
argument_list|()
operator|==
name|KRequestPending
condition|)
block|{
name|TRequestStatus
modifier|*
name|status
init|=
operator|&
name|iStatus
decl_stmt|;
name|QEventDispatcherSymbian
operator|::
name|RequestComplete
argument_list|(
name|status
argument_list|,
name|KErrNone
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|DoCancel
name|void
name|QCompleteDeferredAOs
operator|::
name|DoCancel
parameter_list|()
block|{
if|if
condition|(
name|iStatus
operator|.
name|Int
argument_list|()
operator|==
name|KRequestPending
condition|)
block|{
name|TRequestStatus
modifier|*
name|status
init|=
operator|&
name|iStatus
decl_stmt|;
name|QEventDispatcherSymbian
operator|::
name|RequestComplete
argument_list|(
name|status
argument_list|,
name|KErrNone
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|RunL
name|void
name|QCompleteDeferredAOs
operator|::
name|RunL
parameter_list|()
block|{
name|iStatus
operator|=
name|KRequestPending
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
name|QT_TRYCATCH_LEAVING
argument_list|(
name|m_dispatcher
operator|->
name|reactivateDeferredActiveObjects
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QSelectThread
name|QSelectThread
operator|::
name|QSelectThread
parameter_list|()
member_init_list|:
name|m_quit
argument_list|(
literal|false
argument_list|)
block|{
if|if
condition|(
operator|::
name|pipe
argument_list|(
name|m_pipeEnds
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"Select thread was unable to open a pipe, errno: %i"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|flags0
init|=
name|qt_pipe_fcntl
argument_list|(
name|m_pipeEnds
index|[
literal|0
index|]
argument_list|,
name|F_GETFL
argument_list|)
decl_stmt|;
name|int
name|flags1
init|=
name|qt_pipe_fcntl
argument_list|(
name|m_pipeEnds
index|[
literal|1
index|]
argument_list|,
name|F_GETFL
argument_list|)
decl_stmt|;
comment|// We should check the error code here, but Open C has a bug that returns
comment|// failure even though the operation was successful.
name|qt_pipe2_fcntl
argument_list|(
name|m_pipeEnds
index|[
literal|0
index|]
argument_list|,
name|F_SETFL
argument_list|,
name|flags0
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
name|qt_pipe2_fcntl
argument_list|(
name|m_pipeEnds
index|[
literal|1
index|]
argument_list|,
name|F_SETFL
argument_list|,
name|flags1
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~QSelectThread
name|QSelectThread
operator|::
name|~
name|QSelectThread
parameter_list|()
block|{
name|qt_pipe_close
argument_list|(
name|m_pipeEnds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|qt_pipe_close
argument_list|(
name|m_pipeEnds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|run
name|void
name|QSelectThread
operator|::
name|run
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QThread
argument_list|)
expr_stmt|;
name|m_mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|m_quit
condition|)
block|{
name|fd_set
name|readfds
decl_stmt|;
name|fd_set
name|writefds
decl_stmt|;
name|fd_set
name|exceptionfds
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|writefds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|exceptionfds
argument_list|)
expr_stmt|;
name|int
name|maxfd
init|=
literal|0
decl_stmt|;
name|maxfd
operator|=
name|qMax
argument_list|(
name|maxfd
argument_list|,
name|updateSocketSet
argument_list|(
name|QSocketNotifier
operator|::
name|Read
argument_list|,
operator|&
name|readfds
argument_list|)
argument_list|)
expr_stmt|;
name|maxfd
operator|=
name|qMax
argument_list|(
name|maxfd
argument_list|,
name|updateSocketSet
argument_list|(
name|QSocketNotifier
operator|::
name|Write
argument_list|,
operator|&
name|writefds
argument_list|)
argument_list|)
expr_stmt|;
name|maxfd
operator|=
name|qMax
argument_list|(
name|maxfd
argument_list|,
name|updateSocketSet
argument_list|(
name|QSocketNotifier
operator|::
name|Exception
argument_list|,
operator|&
name|exceptionfds
argument_list|)
argument_list|)
expr_stmt|;
name|maxfd
operator|=
name|qMax
argument_list|(
name|maxfd
argument_list|,
name|m_pipeEnds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|maxfd
operator|++
expr_stmt|;
name|FD_SET
argument_list|(
name|m_pipeEnds
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|savedSelectErrno
decl_stmt|;
name|ret
operator|=
name|qt_socket_select
argument_list|(
name|maxfd
argument_list|,
operator|&
name|readfds
argument_list|,
operator|&
name|writefds
argument_list|,
operator|&
name|exceptionfds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|savedSelectErrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|// do nothing
block|}
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|savedSelectErrno
condition|)
block|{
case|case
name|EBADF
case|:
case|case
name|EINVAL
case|:
case|case
name|ENOMEM
case|:
case|case
name|EFAULT
case|:
name|qWarning
argument_list|(
literal|"::select() returned an error: %i"
argument_list|,
name|savedSelectErrno
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECONNREFUSED
case|:
case|case
name|EPIPE
case|:
name|qWarning
argument_list|(
literal|"::select() returned an error: %i (go through sockets)"
argument_list|,
name|savedSelectErrno
argument_list|)
expr_stmt|;
comment|// prepare to go through all sockets
comment|// mark in fd sets both:
comment|//     good ones
comment|//     ones that return -1 in select
comment|// after loop update notifiers for all of them
comment|// as we don't have "exception" notifier type
comment|// we should force monitoring fd_set of this
comment|// type as well
comment|// clean @ start
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|writefds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|exceptionfds
argument_list|)
expr_stmt|;
for|for
control|(
name|QHash
argument_list|<
name|QSocketNotifier
operator|*
argument_list|,
name|TRequestStatus
operator|*
argument_list|>
operator|::
name|const_iterator
name|i
init|=
name|m_AOStatuses
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|m_AOStatuses
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|fd_set
name|onefds
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|onefds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|i
operator|.
name|key
argument_list|()
operator|->
name|socket
argument_list|()
argument_list|,
operator|&
name|onefds
argument_list|)
expr_stmt|;
name|fd_set
name|excfds
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|excfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|i
operator|.
name|key
argument_list|()
operator|->
name|socket
argument_list|()
argument_list|,
operator|&
name|excfds
argument_list|)
expr_stmt|;
name|maxfd
operator|=
name|i
operator|.
name|key
argument_list|()
operator|->
name|socket
argument_list|()
operator|+
literal|1
expr_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|key
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|QSocketNotifier
operator|::
name|Read
condition|)
block|{
name|ret
operator|=
operator|::
name|select
argument_list|(
name|maxfd
argument_list|,
operator|&
name|onefds
argument_list|,
literal|0
argument_list|,
operator|&
name|excfds
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|FD_SET
argument_list|(
name|i
operator|.
name|key
argument_list|()
operator|->
name|socket
argument_list|()
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|key
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|QSocketNotifier
operator|::
name|Write
condition|)
block|{
name|ret
operator|=
operator|::
name|select
argument_list|(
name|maxfd
argument_list|,
literal|0
argument_list|,
operator|&
name|onefds
argument_list|,
operator|&
name|excfds
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|FD_SET
argument_list|(
name|i
operator|.
name|key
argument_list|()
operator|->
name|socket
argument_list|()
argument_list|,
operator|&
name|writefds
argument_list|)
expr_stmt|;
block|}
block|}
comment|// end for
comment|// traversed all, so update
name|updateActivatedNotifiers
argument_list|(
name|QSocketNotifier
operator|::
name|Exception
argument_list|,
operator|&
name|exceptionfds
argument_list|)
expr_stmt|;
name|updateActivatedNotifiers
argument_list|(
name|QSocketNotifier
operator|::
name|Read
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|updateActivatedNotifiers
argument_list|(
name|QSocketNotifier
operator|::
name|Write
argument_list|,
operator|&
name|writefds
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINTR
case|:
comment|// Should never occur on Symbian, but this is future proof!
default|default:
name|qWarning
argument_list|(
literal|"::select() returned an unknown error: %i"
argument_list|,
name|savedSelectErrno
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|updateActivatedNotifiers
argument_list|(
name|QSocketNotifier
operator|::
name|Exception
argument_list|,
operator|&
name|exceptionfds
argument_list|)
expr_stmt|;
name|updateActivatedNotifiers
argument_list|(
name|QSocketNotifier
operator|::
name|Read
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|updateActivatedNotifiers
argument_list|(
name|QSocketNotifier
operator|::
name|Write
argument_list|,
operator|&
name|writefds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|m_pipeEnds
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
name|m_waitCond
operator|.
name|wait
argument_list|(
operator|&
name|m_mutex
argument_list|)
expr_stmt|;
block|}
name|m_mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|requestSocketEvents
name|void
name|QSelectThread
operator|::
name|requestSocketEvents
parameter_list|(
name|QSocketNotifier
modifier|*
name|notifier
parameter_list|,
name|TRequestStatus
modifier|*
name|status
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QThread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
block|{
name|start
argument_list|()
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|this
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
name|QSelectMutexGrabber
name|lock
argument_list|(
name|m_pipeEnds
index|[
literal|1
index|]
argument_list|,
name|m_pipeEnds
index|[
literal|0
index|]
argument_list|,
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|m_AOStatuses
operator|.
name|contains
argument_list|(
name|notifier
argument_list|)
argument_list|)
expr_stmt|;
name|m_AOStatuses
operator|.
name|insert
argument_list|(
name|notifier
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|m_waitCond
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cancelSocketEvents
name|void
name|QSelectThread
operator|::
name|cancelSocketEvents
parameter_list|(
name|QSocketNotifier
modifier|*
name|notifier
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|this
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
name|QSelectMutexGrabber
name|lock
argument_list|(
name|m_pipeEnds
index|[
literal|1
index|]
argument_list|,
name|m_pipeEnds
index|[
literal|0
index|]
argument_list|,
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|m_AOStatuses
operator|.
name|remove
argument_list|(
name|notifier
argument_list|)
expr_stmt|;
name|m_waitCond
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|restart
name|void
name|QSelectThread
operator|::
name|restart
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|==
name|this
operator|->
name|thread
argument_list|()
argument_list|)
expr_stmt|;
name|QSelectMutexGrabber
name|lock
argument_list|(
name|m_pipeEnds
index|[
literal|1
index|]
argument_list|,
name|m_pipeEnds
index|[
literal|0
index|]
argument_list|,
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
name|m_waitCond
operator|.
name|wakeAll
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateSocketSet
name|int
name|QSelectThread
operator|::
name|updateSocketSet
parameter_list|(
name|QSocketNotifier
operator|::
name|Type
name|type
parameter_list|,
name|fd_set
modifier|*
name|fds
parameter_list|)
block|{
name|int
name|maxfd
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m_AOStatuses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|/*          * Wonder if should return -1          * to signal that no descriptors          * added to fds         */
return|return
name|maxfd
return|;
block|}
for|for
control|(
name|QHash
argument_list|<
name|QSocketNotifier
operator|*
argument_list|,
name|TRequestStatus
operator|*
argument_list|>
operator|::
name|const_iterator
name|i
init|=
name|m_AOStatuses
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|m_AOStatuses
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|.
name|key
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|type
condition|)
block|{
name|FD_SET
argument_list|(
name|i
operator|.
name|key
argument_list|()
operator|->
name|socket
argument_list|()
argument_list|,
name|fds
argument_list|)
expr_stmt|;
name|maxfd
operator|=
name|qMax
argument_list|(
name|maxfd
argument_list|,
name|i
operator|.
name|key
argument_list|()
operator|->
name|socket
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QSocketNotifier
operator|::
name|Exception
condition|)
block|{
comment|/*              * We are registering existing sockets              * always to exception set              *              * Doing double FD_SET shouldn't              * matter              */
name|FD_SET
argument_list|(
name|i
operator|.
name|key
argument_list|()
operator|->
name|socket
argument_list|()
argument_list|,
name|fds
argument_list|)
expr_stmt|;
name|maxfd
operator|=
name|qMax
argument_list|(
name|maxfd
argument_list|,
name|i
operator|.
name|key
argument_list|()
operator|->
name|socket
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|maxfd
return|;
block|}
end_function
begin_function
DECL|function|updateActivatedNotifiers
name|void
name|QSelectThread
operator|::
name|updateActivatedNotifiers
parameter_list|(
name|QSocketNotifier
operator|::
name|Type
name|type
parameter_list|,
name|fd_set
modifier|*
name|fds
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QThread
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_AOStatuses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|QList
argument_list|<
name|QSocketNotifier
modifier|*
argument_list|>
name|toRemove
decl_stmt|;
for|for
control|(
name|QHash
argument_list|<
name|QSocketNotifier
operator|*
argument_list|,
name|TRequestStatus
operator|*
argument_list|>
operator|::
name|const_iterator
name|i
init|=
name|m_AOStatuses
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|m_AOStatuses
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|.
name|key
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|type
operator|&&
name|FD_ISSET
argument_list|(
name|i
operator|.
name|key
argument_list|()
operator|->
name|socket
argument_list|()
argument_list|,
name|fds
argument_list|)
condition|)
block|{
name|toRemove
operator|.
name|append
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
name|TRequestStatus
modifier|*
name|status
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
comment|// Thread data is still owned by the main thread.
name|QEventDispatcherSymbian
operator|::
name|RequestComplete
argument_list|(
name|d
operator|->
name|threadData
operator|->
name|symbian_thread_handle
argument_list|,
name|status
argument_list|,
name|KErrNone
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|QSocketNotifier
operator|::
name|Exception
operator|&&
name|FD_ISSET
argument_list|(
name|i
operator|.
name|key
argument_list|()
operator|->
name|socket
argument_list|()
argument_list|,
name|fds
argument_list|)
condition|)
block|{
comment|/*              * check if socket is in exception set              * then signal RequestComplete for it              */
name|qWarning
argument_list|(
literal|"exception on %d [will close the socket handle - hack]"
argument_list|,
name|i
operator|.
name|key
argument_list|()
operator|->
name|socket
argument_list|()
argument_list|)
expr_stmt|;
comment|// quick fix; there is a bug
comment|// when doing read on socket
comment|// errors not preoperly mapped
comment|// after offline-ing the device
comment|// on some devices we do get exception
operator|::
name|close
argument_list|(
name|i
operator|.
name|key
argument_list|()
operator|->
name|socket
argument_list|()
argument_list|)
expr_stmt|;
name|toRemove
operator|.
name|append
argument_list|(
name|i
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
name|TRequestStatus
modifier|*
name|status
init|=
name|i
operator|.
name|value
argument_list|()
decl_stmt|;
name|QEventDispatcherSymbian
operator|::
name|RequestComplete
argument_list|(
name|d
operator|->
name|threadData
operator|->
name|symbian_thread_handle
argument_list|,
name|status
argument_list|,
name|KErrNone
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|toRemove
operator|.
name|size
argument_list|()
condition|;
operator|++
name|c
control|)
block|{
name|m_AOStatuses
operator|.
name|remove
argument_list|(
name|toRemove
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|stop
name|void
name|QSelectThread
operator|::
name|stop
parameter_list|()
block|{
name|m_quit
operator|=
literal|true
expr_stmt|;
name|restart
argument_list|()
expr_stmt|;
name|wait
argument_list|()
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QSocketActiveObject
name|QSocketActiveObject
operator|::
name|QSocketActiveObject
parameter_list|(
name|QEventDispatcherSymbian
modifier|*
name|dispatcher
parameter_list|,
name|QSocketNotifier
modifier|*
name|notifier
parameter_list|)
member_init_list|:
name|QActiveObject
argument_list|(
name|CActive
operator|::
name|EPriorityStandard
argument_list|,
name|dispatcher
argument_list|)
member_init_list|,
name|m_notifier
argument_list|(
name|notifier
argument_list|)
member_init_list|,
name|m_inSocketEvent
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_deleteLater
argument_list|(
literal|false
argument_list|)
block|{
name|CActiveScheduler
operator|::
name|Add
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|iStatus
operator|=
name|KRequestPending
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QSocketActiveObject
name|QSocketActiveObject
operator|::
name|~
name|QSocketActiveObject
parameter_list|()
block|{
name|Cancel
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|DoCancel
name|void
name|QSocketActiveObject
operator|::
name|DoCancel
parameter_list|()
block|{
if|if
condition|(
name|iStatus
operator|.
name|Int
argument_list|()
operator|==
name|KRequestPending
condition|)
block|{
name|TRequestStatus
modifier|*
name|status
init|=
operator|&
name|iStatus
decl_stmt|;
name|QEventDispatcherSymbian
operator|::
name|RequestComplete
argument_list|(
name|status
argument_list|,
name|KErrNone
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|RunL
name|void
name|QSocketActiveObject
operator|::
name|RunL
parameter_list|()
block|{
if|if
condition|(
name|maybeDeferSocketEvent
argument_list|()
condition|)
return|return;
if|if
condition|(
name|maybeQueueForLater
argument_list|()
condition|)
return|return;
name|QT_TRYCATCH_LEAVING
argument_list|(
name|run
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|run
name|void
name|QSocketActiveObject
operator|::
name|run
parameter_list|()
block|{
name|QEvent
name|e
argument_list|(
name|QEvent
operator|::
name|SockAct
argument_list|)
decl_stmt|;
name|m_inSocketEvent
operator|=
literal|true
expr_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|m_notifier
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|m_inSocketEvent
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|m_deleteLater
condition|)
block|{
operator|delete
name|this
expr_stmt|;
block|}
else|else
block|{
name|iStatus
operator|=
name|KRequestPending
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
name|m_dispatcher
operator|->
name|reactivateSocketNotifier
argument_list|(
name|m_notifier
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|deleteLater
name|void
name|QSocketActiveObject
operator|::
name|deleteLater
parameter_list|()
block|{
if|if
condition|(
name|m_inSocketEvent
condition|)
block|{
name|m_deleteLater
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
operator|delete
name|this
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QT_SYMBIAN_PRIORITY_DROP
end_ifdef
begin_class
DECL|class|QIdleDetectorThread
class|class
name|QIdleDetectorThread
block|{
public|public:
DECL|function|QIdleDetectorThread
name|QIdleDetectorThread
parameter_list|()
member_init_list|:
name|m_state
argument_list|(
name|STATE_RUN
argument_list|)
member_init_list|,
name|m_stop
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_running
argument_list|(
literal|false
argument_list|)
block|{
name|start
argument_list|()
expr_stmt|;
block|}
DECL|function|~QIdleDetectorThread
name|~
name|QIdleDetectorThread
parameter_list|()
block|{
name|stop
argument_list|()
expr_stmt|;
block|}
DECL|function|start
name|void
name|start
parameter_list|()
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|m_running
condition|)
return|return;
name|m_stop
operator|=
literal|false
expr_stmt|;
name|m_state
operator|=
name|STATE_RUN
expr_stmt|;
name|TInt
name|err
init|=
name|m_idleDetectorThread
operator|.
name|Create
argument_list|(
name|KNullDesC
argument_list|()
argument_list|,
operator|&
name|idleDetectorThreadFunc
argument_list|,
literal|1024
argument_list|,
operator|&
name|User
operator|::
name|Allocator
argument_list|()
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|KErrNone
condition|)
return|return;
comment|// Fail silently on error. Next kick will try again. Exception might stop the event being processed
name|m_idleDetectorThread
operator|.
name|SetPriority
argument_list|(
name|EPriorityAbsoluteBackgroundNormal
argument_list|)
expr_stmt|;
name|m_idleDetectorThread
operator|.
name|Resume
argument_list|()
expr_stmt|;
name|m_running
operator|=
literal|true
expr_stmt|;
comment|// get a callback from QCoreApplication destruction to stop this thread
name|qAddPostRoutine
argument_list|(
name|StopIdleDetectorThread
argument_list|)
expr_stmt|;
block|}
DECL|function|stop
name|void
name|stop
parameter_list|()
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|m_mutex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m_running
condition|)
return|return;
comment|// close down the idle thread because if corelib is loaded temporarily, this would leak threads into the host process
name|m_stop
operator|=
literal|true
expr_stmt|;
name|m_kick
operator|.
name|release
argument_list|()
expr_stmt|;
name|m_idleDetectorThread
operator|.
name|SetPriority
argument_list|(
name|EPriorityNormal
argument_list|)
expr_stmt|;
name|TRequestStatus
name|s
decl_stmt|;
name|m_idleDetectorThread
operator|.
name|Logon
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|User
operator|::
name|WaitForRequest
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_idleDetectorThread
operator|.
name|Close
argument_list|()
expr_stmt|;
name|m_running
operator|=
literal|false
expr_stmt|;
block|}
DECL|function|kick
name|void
name|kick
parameter_list|()
block|{
name|start
argument_list|()
expr_stmt|;
name|m_state
operator|=
name|STATE_KICKED
expr_stmt|;
name|m_kick
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
DECL|function|hasRun
name|bool
name|hasRun
parameter_list|()
block|{
return|return
name|m_state
operator|==
name|STATE_RUN
return|;
block|}
private|private:
DECL|function|idleDetectorThreadFunc
specifier|static
name|TInt
name|idleDetectorThreadFunc
parameter_list|(
name|TAny
modifier|*
name|self
parameter_list|)
block|{
name|User
operator|::
name|RenameThread
argument_list|(
name|_L
argument_list|(
literal|"IdleDetectorThread"
argument_list|)
argument_list|)
expr_stmt|;
cast|static_cast
argument_list|<
name|QIdleDetectorThread
operator|*
argument_list|>
argument_list|(
name|self
argument_list|)
operator|->
name|IdleLoop
argument_list|()
expr_stmt|;
return|return
name|KErrNone
return|;
block|}
DECL|function|IdleLoop
name|void
name|IdleLoop
parameter_list|()
block|{
while|while
condition|(
operator|!
name|m_stop
condition|)
block|{
name|m_kick
operator|.
name|acquire
argument_list|()
expr_stmt|;
name|m_state
operator|=
name|STATE_RUN
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|StopIdleDetectorThread
parameter_list|()
function_decl|;
private|private:
DECL|enum|IdleStates
DECL|enumerator|STATE_KICKED
DECL|enumerator|STATE_RUN
DECL|member|m_state
enum|enum
name|IdleStates
block|{
name|STATE_KICKED
block|,
name|STATE_RUN
block|}
name|m_state
enum|;
DECL|member|m_stop
name|bool
name|m_stop
decl_stmt|;
DECL|member|m_running
name|bool
name|m_running
decl_stmt|;
DECL|member|m_idleDetectorThread
name|RThread
name|m_idleDetectorThread
decl_stmt|;
DECL|member|m_kick
name|QSemaphore
name|m_kick
decl_stmt|;
DECL|member|m_mutex
name|QMutex
name|m_mutex
decl_stmt|;
block|}
class|;
end_class
begin_expr_stmt
name|Q_GLOBAL_STATIC
argument_list|(
name|QIdleDetectorThread
argument_list|,
name|idleDetectorThread
argument_list|)
expr_stmt|;
end_expr_stmt
begin_function
DECL|function|StopIdleDetectorThread
name|void
name|QIdleDetectorThread
operator|::
name|StopIdleDetectorThread
parameter_list|()
block|{
name|idleDetectorThread
argument_list|()
operator|->
name|stop
argument_list|()
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|maxBusyTime
specifier|const
name|int
name|maxBusyTime
init|=
literal|2000
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|maxBusyTime
comment|// maximum time we allow idle detector to be blocked before worrying, in milliseconds
end_comment
begin_decl_stmt
DECL|variable|baseDelay
specifier|const
name|int
name|baseDelay
init|=
literal|1000
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|baseDelay
comment|// minimum delay time used when backing off to allow idling, in microseconds
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|QEventDispatcherSymbian
name|QEventDispatcherSymbian
operator|::
name|QEventDispatcherSymbian
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractEventDispatcher
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|m_selectThread
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_activeScheduler
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_wakeUpAO
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_completeDeferredAOs
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_interrupt
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_wakeUpDone
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_iterationCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_insideTimerEvent
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_noSocketEvents
argument_list|(
literal|false
argument_list|)
block|{
ifdef|#
directive|ifdef
name|QT_SYMBIAN_PRIORITY_DROP
name|m_delay
operator|=
name|baseDelay
expr_stmt|;
name|m_avgEventTime
operator|=
literal|0
expr_stmt|;
name|idleDetectorThread
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_destructor
DECL|function|~QEventDispatcherSymbian
name|QEventDispatcherSymbian
operator|::
name|~
name|QEventDispatcherSymbian
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|startingUp
name|void
name|QEventDispatcherSymbian
operator|::
name|startingUp
parameter_list|()
block|{
if|if
condition|(
operator|!
name|CActiveScheduler
operator|::
name|Current
argument_list|()
condition|)
block|{
name|m_activeScheduler
operator|=
name|q_check_ptr
argument_list|(
operator|new
name|CQtActiveScheduler
argument_list|()
argument_list|)
expr_stmt|;
comment|// CBase derived class needs to be checked on new
name|CActiveScheduler
operator|::
name|Install
argument_list|(
name|m_activeScheduler
argument_list|)
expr_stmt|;
block|}
name|m_wakeUpAO
operator|=
name|q_check_ptr
argument_list|(
operator|new
name|QWakeUpActiveObject
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|m_completeDeferredAOs
operator|=
name|q_check_ptr
argument_list|(
operator|new
name|QCompleteDeferredAOs
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|// We already might have posted events, wakeup once to process them
name|wakeUp
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|selectThread
name|QSelectThread
modifier|&
name|QEventDispatcherSymbian
operator|::
name|selectThread
parameter_list|()
block|{
if|if
condition|(
operator|!
name|m_selectThread
condition|)
name|m_selectThread
operator|=
operator|new
name|QSelectThread
expr_stmt|;
return|return
operator|*
name|m_selectThread
return|;
block|}
end_function
begin_function
DECL|function|closingDown
name|void
name|QEventDispatcherSymbian
operator|::
name|closingDown
parameter_list|()
block|{
if|if
condition|(
name|m_selectThread
operator|&&
name|m_selectThread
operator|->
name|isRunning
argument_list|()
condition|)
block|{
name|m_selectThread
operator|->
name|stop
argument_list|()
expr_stmt|;
block|}
operator|delete
name|m_selectThread
expr_stmt|;
name|m_selectThread
operator|=
literal|0
expr_stmt|;
operator|delete
name|m_completeDeferredAOs
expr_stmt|;
operator|delete
name|m_wakeUpAO
expr_stmt|;
if|if
condition|(
name|m_activeScheduler
condition|)
block|{
operator|delete
name|m_activeScheduler
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|processEvents
name|bool
name|QEventDispatcherSymbian
operator|::
name|processEvents
parameter_list|(
name|QEventLoop
operator|::
name|ProcessEventsFlags
name|flags
parameter_list|)
block|{
name|bool
name|handledAnyEvent
init|=
literal|false
decl_stmt|;
name|bool
name|oldNoSocketEventsValue
init|=
name|m_noSocketEvents
decl_stmt|;
name|bool
name|oldInsideTimerEventValue
init|=
name|m_insideTimerEvent
decl_stmt|;
name|m_insideTimerEvent
operator|=
literal|false
expr_stmt|;
name|QT_TRY
block|{
name|Q_D
argument_list|(
name|QAbstractEventDispatcher
argument_list|)
expr_stmt|;
comment|// It is safe if this counter overflows. The main importance is that each
comment|// iteration count is different from the last.
name|m_iterationCount
operator|++
expr_stmt|;
name|RThread
modifier|&
name|thread
init|=
name|d
operator|->
name|threadData
operator|->
name|symbian_thread_handle
decl_stmt|;
name|bool
name|block
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|QEventLoop
operator|::
name|WaitForMoreEvents
condition|)
block|{
name|block
operator|=
literal|true
expr_stmt|;
emit|emit
name|aboutToBlock
argument_list|()
emit|;
block|}
else|else
block|{
name|block
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|QEventLoop
operator|::
name|ExcludeSocketNotifiers
condition|)
block|{
name|m_noSocketEvents
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|m_noSocketEvents
operator|=
literal|false
expr_stmt|;
name|handledAnyEvent
operator|=
name|sendDeferredSocketEvents
argument_list|()
expr_stmt|;
block|}
name|bool
name|handledSymbianEvent
init|=
literal|false
decl_stmt|;
name|m_interrupt
operator|=
literal|false
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_SYMBIAN_PRIORITY_DROP
name|QElapsedTimer
name|eventTimer
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|block
condition|)
block|{
comment|// This is where Qt will spend most of its time.
name|CActiveScheduler
operator|::
name|Current
argument_list|()
operator|->
name|WaitForAnyRequest
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|thread
operator|.
name|RequestCount
argument_list|()
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|QT_SYMBIAN_PRIORITY_DROP
if|if
condition|(
name|idleDetectorThread
argument_list|()
operator|->
name|hasRun
argument_list|()
condition|)
block|{
name|m_lastIdleRequestTimer
operator|.
name|start
argument_list|()
expr_stmt|;
name|idleDetectorThread
argument_list|()
operator|->
name|kick
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_lastIdleRequestTimer
operator|.
name|elapsed
argument_list|()
operator|>
name|maxBusyTime
condition|)
block|{
name|User
operator|::
name|AfterHighRes
argument_list|(
name|m_delay
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
comment|// This one should return without delay.
name|CActiveScheduler
operator|::
name|Current
argument_list|()
operator|->
name|WaitForAnyRequest
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_SYMBIAN_PRIORITY_DROP
if|if
condition|(
name|idleDetectorThread
argument_list|()
operator|->
name|hasRun
argument_list|()
condition|)
block|{
if|if
condition|(
name|m_delay
operator|>
name|baseDelay
condition|)
name|m_delay
operator|-=
name|baseDelay
expr_stmt|;
name|m_lastIdleRequestTimer
operator|.
name|start
argument_list|()
expr_stmt|;
name|idleDetectorThread
argument_list|()
operator|->
name|kick
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_lastIdleRequestTimer
operator|.
name|elapsed
argument_list|()
operator|>
name|maxBusyTime
condition|)
block|{
name|User
operator|::
name|AfterHighRes
argument_list|(
name|m_delay
argument_list|)
expr_stmt|;
comment|// allow delay to be up to 1/4 of execution time
if|if
condition|(
operator|!
name|idleDetectorThread
argument_list|()
operator|->
name|hasRun
argument_list|()
operator|&&
name|m_delay
operator|*
literal|3
operator|<
name|m_avgEventTime
condition|)
name|m_delay
operator|+=
name|baseDelay
expr_stmt|;
block|}
name|eventTimer
operator|.
name|start
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|TInt
name|error
decl_stmt|;
name|handledSymbianEvent
operator|=
name|CActiveScheduler
operator|::
name|RunIfReady
argument_list|(
name|error
argument_list|,
name|KMinTInt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|qWarning
argument_list|(
literal|"CActiveScheduler::RunIfReady() returned error: %i\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|CActiveScheduler
operator|::
name|Current
argument_list|()
operator|->
name|Error
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_SYMBIAN_PRIORITY_DROP
name|int
name|eventDur
init|=
name|eventTimer
operator|.
name|elapsed
argument_list|()
operator|*
literal|1000
decl_stmt|;
comment|// average is calcualted as a 5% decaying exponential average
name|m_avgEventTime
operator|=
operator|(
name|m_avgEventTime
operator|*
literal|95
operator|+
name|eventDur
operator|*
literal|5
operator|)
operator|/
literal|100
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|handledSymbianEvent
condition|)
block|{
name|qFatal
argument_list|(
literal|"QEventDispatcherSymbian::processEvents(): Caught Symbian stray signal"
argument_list|)
expr_stmt|;
block|}
name|handledAnyEvent
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|m_interrupt
condition|)
block|{
break|break;
block|}
name|block
operator|=
literal|false
expr_stmt|;
block|}
empty_stmt|;
emit|emit
name|awake
argument_list|()
emit|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::exception& ex
argument_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_EXCEPTIONS
name|CActiveScheduler
operator|::
name|Current
argument_list|()
operator|->
name|Error
argument_list|(
name|qt_symbian_exception2Error
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|m_noSocketEvents
operator|=
name|oldNoSocketEventsValue
expr_stmt|;
name|m_insideTimerEvent
operator|=
name|oldInsideTimerEventValue
expr_stmt|;
return|return
name|handledAnyEvent
return|;
block|}
end_function
begin_function
DECL|function|timerFired
name|void
name|QEventDispatcherSymbian
operator|::
name|timerFired
parameter_list|(
name|int
name|timerId
parameter_list|)
block|{
name|QHash
argument_list|<
name|int
argument_list|,
name|SymbianTimerInfoPtr
argument_list|>
operator|::
name|iterator
name|i
init|=
name|m_timerList
operator|.
name|find
argument_list|(
name|timerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|m_timerList
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// The timer has been deleted. Ignore this event.
return|return;
block|}
name|SymbianTimerInfoPtr
name|timerInfo
init|=
operator|*
name|i
decl_stmt|;
comment|// Prevent infinite timer recursion.
if|if
condition|(
name|timerInfo
operator|->
name|inTimerEvent
condition|)
block|{
return|return;
block|}
name|timerInfo
operator|->
name|inTimerEvent
operator|=
literal|true
expr_stmt|;
name|bool
name|oldInsideTimerEventValue
init|=
name|m_insideTimerEvent
decl_stmt|;
name|m_insideTimerEvent
operator|=
literal|true
expr_stmt|;
name|QTimerEvent
name|event
argument_list|(
name|timerInfo
operator|->
name|timerId
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|timerInfo
operator|->
name|receiver
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|m_insideTimerEvent
operator|=
name|oldInsideTimerEventValue
expr_stmt|;
name|timerInfo
operator|->
name|inTimerEvent
operator|=
literal|false
expr_stmt|;
return|return;
block|}
end_function
begin_function
DECL|function|wakeUpWasCalled
name|void
name|QEventDispatcherSymbian
operator|::
name|wakeUpWasCalled
parameter_list|()
block|{
comment|// The reactivation should happen in RunL, right before the call to this function.
comment|// This is because m_wakeUpDone is the "signal" that the object can be completed
comment|// once more.
comment|// Also, by dispatching the posted events after resetting m_wakeUpDone, we guarantee
comment|// that no posted event notification will be lost. If we did it the other way
comment|// around, it would be possible for another thread to post an event right after
comment|// the sendPostedEvents was done, but before the object was ready to be completed
comment|// again. This could deadlock the application if there are no other posted events.
name|m_wakeUpDone
operator|.
name|fetchAndStoreOrdered
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sendPostedEvents
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|interrupt
name|void
name|QEventDispatcherSymbian
operator|::
name|interrupt
parameter_list|()
block|{
name|m_interrupt
operator|=
literal|true
expr_stmt|;
name|wakeUp
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|wakeUp
name|void
name|QEventDispatcherSymbian
operator|::
name|wakeUp
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractEventDispatcher
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_wakeUpAO
operator|&&
name|m_wakeUpDone
operator|.
name|testAndSetAcquire
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|TRequestStatus
modifier|*
name|status
init|=
operator|&
name|m_wakeUpAO
operator|->
name|iStatus
decl_stmt|;
name|QEventDispatcherSymbian
operator|::
name|RequestComplete
argument_list|(
name|d
operator|->
name|threadData
operator|->
name|symbian_thread_handle
argument_list|,
name|status
argument_list|,
name|KErrNone
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|sendPostedEvents
name|bool
name|QEventDispatcherSymbian
operator|::
name|sendPostedEvents
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractEventDispatcher
argument_list|)
expr_stmt|;
comment|// moveToThread calls this and canWait == true -> Events will never get processed
comment|// if we check for d->threadData->canWait
comment|//
comment|// QCoreApplication::postEvent sets canWait = false, but after the object and events
comment|// are moved to a new thread, the canWait in new thread is true i.e. not changed to reflect
comment|// the flag on old thread. That's why events in a new thread will not get processed.
comment|// This migth be actually bug in moveToThread functionality, but because other platforms
comment|// do not check canWait in wakeUp (where we essentially are now) - decided to remove it from
comment|// here as well.
comment|//if (!d->threadData->canWait) {
name|QCoreApplicationPrivate
operator|::
name|sendPostedEvents
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|threadData
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|//}
comment|//return false;
block|}
end_function
begin_function
DECL|function|addDeferredActiveObject
specifier|inline
name|void
name|QEventDispatcherSymbian
operator|::
name|addDeferredActiveObject
parameter_list|(
name|QActiveObject
modifier|*
name|object
parameter_list|)
block|{
name|queueDeferredActiveObjectsCompletion
argument_list|()
expr_stmt|;
name|m_deferredActiveObjects
operator|.
name|append
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|removeDeferredActiveObject
specifier|inline
name|void
name|QEventDispatcherSymbian
operator|::
name|removeDeferredActiveObject
parameter_list|(
name|QActiveObject
modifier|*
name|object
parameter_list|)
block|{
name|m_deferredActiveObjects
operator|.
name|removeAll
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|m_deferredSocketEvents
operator|.
name|removeAll
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addDeferredSocketActiveObject
specifier|inline
name|void
name|QEventDispatcherSymbian
operator|::
name|addDeferredSocketActiveObject
parameter_list|(
name|QActiveObject
modifier|*
name|object
parameter_list|)
block|{
name|m_deferredSocketEvents
operator|.
name|append
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|queueDeferredActiveObjectsCompletion
name|void
name|QEventDispatcherSymbian
operator|::
name|queueDeferredActiveObjectsCompletion
parameter_list|()
block|{
name|m_completeDeferredAOs
operator|->
name|complete
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reactivateDeferredActiveObjects
name|void
name|QEventDispatcherSymbian
operator|::
name|reactivateDeferredActiveObjects
parameter_list|()
block|{
while|while
condition|(
operator|!
name|m_deferredActiveObjects
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QActiveObject
modifier|*
name|object
init|=
name|m_deferredActiveObjects
operator|.
name|takeFirst
argument_list|()
decl_stmt|;
name|object
operator|->
name|reactivateAndComplete
argument_list|()
expr_stmt|;
block|}
comment|// We do this because we want to return from processEvents. This is because
comment|// each invocation of processEvents should only run each active object once.
comment|// The active scheduler should run them continously, however.
name|m_interrupt
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendDeferredSocketEvents
name|bool
name|QEventDispatcherSymbian
operator|::
name|sendDeferredSocketEvents
parameter_list|()
block|{
name|bool
name|sentAnyEvents
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|m_deferredSocketEvents
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sentAnyEvents
operator|=
literal|true
expr_stmt|;
name|QActiveObject
modifier|*
name|object
init|=
name|m_deferredSocketEvents
operator|.
name|takeFirst
argument_list|()
decl_stmt|;
name|object
operator|->
name|reactivateAndComplete
argument_list|()
expr_stmt|;
block|}
return|return
name|sentAnyEvents
return|;
block|}
end_function
begin_function
DECL|function|flush
name|void
name|QEventDispatcherSymbian
operator|::
name|flush
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|hasPendingEvents
name|bool
name|QEventDispatcherSymbian
operator|::
name|hasPendingEvents
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractEventDispatcher
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|threadData
operator|->
name|symbian_thread_handle
operator|.
name|RequestCount
argument_list|()
operator|!=
literal|0
operator|||
operator|!
name|d
operator|->
name|threadData
operator|->
name|canWait
operator|||
operator|!
name|m_deferredSocketEvents
operator|.
name|isEmpty
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|registerSocketNotifier
name|void
name|QEventDispatcherSymbian
operator|::
name|registerSocketNotifier
parameter_list|(
name|QSocketNotifier
modifier|*
name|notifier
parameter_list|)
block|{
comment|//note - this is only for "open C" file descriptors
comment|//for native sockets, an active object in the symbian socket engine handles this
name|QSocketActiveObject
modifier|*
name|socketAO
init|=
operator|new
name|QSocketActiveObject
argument_list|(
name|this
argument_list|,
name|notifier
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|socketAO
argument_list|)
expr_stmt|;
name|m_notifiers
operator|.
name|insert
argument_list|(
name|notifier
argument_list|,
name|socketAO
argument_list|)
expr_stmt|;
name|selectThread
argument_list|()
operator|.
name|requestSocketEvents
argument_list|(
name|notifier
argument_list|,
operator|&
name|socketAO
operator|->
name|iStatus
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unregisterSocketNotifier
name|void
name|QEventDispatcherSymbian
operator|::
name|unregisterSocketNotifier
parameter_list|(
name|QSocketNotifier
modifier|*
name|notifier
parameter_list|)
block|{
comment|//note - this is only for "open C" file descriptors
comment|//for native sockets, an active object in the symbian socket engine handles this
if|if
condition|(
name|m_selectThread
condition|)
name|m_selectThread
operator|->
name|cancelSocketEvents
argument_list|(
name|notifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notifiers
operator|.
name|contains
argument_list|(
name|notifier
argument_list|)
condition|)
block|{
name|QSocketActiveObject
modifier|*
name|sockObj
init|=
operator|*
name|m_notifiers
operator|.
name|find
argument_list|(
name|notifier
argument_list|)
decl_stmt|;
name|m_deferredSocketEvents
operator|.
name|removeAll
argument_list|(
name|sockObj
argument_list|)
expr_stmt|;
name|sockObj
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
name|m_notifiers
operator|.
name|remove
argument_list|(
name|notifier
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|reactivateSocketNotifier
name|void
name|QEventDispatcherSymbian
operator|::
name|reactivateSocketNotifier
parameter_list|(
name|QSocketNotifier
modifier|*
name|notifier
parameter_list|)
block|{
name|selectThread
argument_list|()
operator|.
name|requestSocketEvents
argument_list|(
name|notifier
argument_list|,
operator|&
name|m_notifiers
index|[
name|notifier
index|]
operator|->
name|iStatus
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|registerTimer
name|void
name|QEventDispatcherSymbian
operator|::
name|registerTimer
parameter_list|(
name|int
name|timerId
parameter_list|,
name|int
name|interval
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|)
block|{
if|if
condition|(
name|interval
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"Timer interval< 0"
argument_list|)
expr_stmt|;
name|interval
operator|=
literal|0
expr_stmt|;
block|}
name|SymbianTimerInfoPtr
name|timer
argument_list|(
operator|new
name|SymbianTimerInfo
argument_list|)
decl_stmt|;
name|timer
operator|->
name|timerId
operator|=
name|timerId
expr_stmt|;
name|timer
operator|->
name|interval
operator|=
name|interval
expr_stmt|;
name|timer
operator|->
name|inTimerEvent
operator|=
literal|false
expr_stmt|;
name|timer
operator|->
name|receiver
operator|=
name|object
expr_stmt|;
name|timer
operator|->
name|dispatcher
operator|=
name|this
expr_stmt|;
name|timer
operator|->
name|timerAO
operator|=
name|q_check_ptr
argument_list|(
operator|new
name|QTimerActiveObject
argument_list|(
name|this
argument_list|,
name|timer
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|m_timerList
operator|.
name|insert
argument_list|(
name|timerId
argument_list|,
name|timer
argument_list|)
expr_stmt|;
name|timer
operator|->
name|timerAO
operator|->
name|Start
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_insideTimerEvent
condition|)
comment|// If we are inside a timer event, we need to prevent event starvation
comment|// by preventing newly created timers from running in the same event processing
comment|// iteration. Do this by calling the maybeQueueForLater() function to "fake" that we have
comment|// already run once. This will cause the next run to be added to the deferred
comment|// queue instead.
name|timer
operator|->
name|timerAO
operator|->
name|maybeQueueForLater
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unregisterTimer
name|bool
name|QEventDispatcherSymbian
operator|::
name|unregisterTimer
parameter_list|(
name|int
name|timerId
parameter_list|)
block|{
if|if
condition|(
operator|!
name|m_timerList
operator|.
name|contains
argument_list|(
name|timerId
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SymbianTimerInfoPtr
name|timerInfo
init|=
name|m_timerList
operator|.
name|take
argument_list|(
name|timerId
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|QObjectPrivate
operator|::
name|get
argument_list|(
name|timerInfo
operator|->
name|receiver
argument_list|)
operator|->
name|inThreadChangeEvent
condition|)
name|QAbstractEventDispatcherPrivate
operator|::
name|releaseTimerId
argument_list|(
name|timerId
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|unregisterTimers
name|bool
name|QEventDispatcherSymbian
operator|::
name|unregisterTimers
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
block|{
if|if
condition|(
name|m_timerList
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|bool
name|unregistered
init|=
literal|false
decl_stmt|;
for|for
control|(
name|QHash
argument_list|<
name|int
argument_list|,
name|SymbianTimerInfoPtr
argument_list|>
operator|::
name|iterator
name|i
init|=
name|m_timerList
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|m_timerList
operator|.
name|end
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|->
name|receiver
operator|==
name|object
condition|)
block|{
name|i
operator|=
name|m_timerList
operator|.
name|erase
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|unregistered
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
return|return
name|unregistered
return|;
block|}
end_function
begin_function
DECL|function|registeredTimers
name|QList
argument_list|<
name|QEventDispatcherSymbian
operator|::
name|TimerInfo
argument_list|>
name|QEventDispatcherSymbian
operator|::
name|registeredTimers
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|TimerInfo
argument_list|>
name|list
decl_stmt|;
for|for
control|(
name|QHash
argument_list|<
name|int
argument_list|,
name|SymbianTimerInfoPtr
argument_list|>
operator|::
name|const_iterator
name|i
init|=
name|m_timerList
operator|.
name|begin
argument_list|()
init|;
name|i
operator|!=
name|m_timerList
operator|.
name|end
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|i
operator|)
operator|->
name|receiver
operator|==
name|object
condition|)
block|{
name|list
operator|.
name|push_back
argument_list|(
name|TimerInfo
argument_list|(
operator|(
operator|*
name|i
operator|)
operator|->
name|timerId
argument_list|,
operator|(
operator|*
name|i
operator|)
operator|->
name|interval
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*  * This active scheduler class implements a simple report and continue policy, for Symbian OS leaves  * or exceptions from Qt that fall back to the scheduler.  * It will be used in cases where there is no existing active scheduler installed.  * Apps which link to qts60main.lib will have the UI active scheduler installed in the main thread  * instead of this one. But this would be used in other threads in the UI.  * An app could replace this behaviour by installing an alternative active scheduler.  */
end_comment
begin_function
DECL|function|Error
name|void
name|CQtActiveScheduler
operator|::
name|Error
parameter_list|(
name|TInt
name|aError
parameter_list|)
specifier|const
block|{
name|QT_TRY
block|{
name|qWarning
argument_list|(
literal|"Error from active scheduler %d"
argument_list|,
name|aError
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::bad_alloc&
argument_list|)
block|{}
comment|// ignore alloc fails, nothing more can be done
block|}
end_function
begin_function
DECL|function|wait
name|bool
name|QActiveObject
operator|::
name|wait
parameter_list|(
name|CActive
modifier|*
name|ao
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ao
operator|->
name|IsActive
argument_list|()
condition|)
return|return
literal|true
return|;
comment|//request already complete
name|bool
name|timedout
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ms
operator|>
literal|0
condition|)
block|{
name|TRequestStatus
name|tstat
decl_stmt|;
name|RTimer
name|t
decl_stmt|;
if|if
condition|(
name|KErrNone
operator|!=
name|t
operator|.
name|CreateLocal
argument_list|()
condition|)
return|return
literal|false
return|;
name|t
operator|.
name|HighRes
argument_list|(
name|tstat
argument_list|,
name|ms
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|User
operator|::
name|WaitForRequest
argument_list|(
name|tstat
argument_list|,
name|ao
operator|->
name|iStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstat
operator|!=
name|KRequestPending
condition|)
block|{
name|timedout
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|t
operator|.
name|Cancel
argument_list|()
expr_stmt|;
comment|//balance thread semaphore
name|User
operator|::
name|WaitForRequest
argument_list|(
name|tstat
argument_list|)
expr_stmt|;
block|}
name|t
operator|.
name|Close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|User
operator|::
name|WaitForRequest
argument_list|(
name|ao
operator|->
name|iStatus
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timedout
condition|)
return|return
literal|false
return|;
comment|//evil cast to allow calling of protected virtual
operator|(
operator|(
name|QActiveObject
operator|*
operator|)
name|ao
operator|)
operator|->
name|RunL
argument_list|()
expr_stmt|;
comment|//clear active& pending flags
name|ao
operator|->
name|iStatus
operator|=
name|TRequestStatus
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|wait
name|bool
name|QActiveObject
operator|::
name|wait
parameter_list|(
name|QList
argument_list|<
name|CActive
modifier|*
argument_list|>
name|aos
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
name|QVector
argument_list|<
name|TRequestStatus
modifier|*
argument_list|>
name|stati
decl_stmt|;
name|stati
operator|.
name|reserve
argument_list|(
name|aos
operator|.
name|count
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
foreach|foreach
control|(
name|CActive
modifier|*
name|ao
decl|,
name|aos
control|)
block|{
if|if
condition|(
operator|!
name|ao
operator|->
name|IsActive
argument_list|()
condition|)
return|return
literal|true
return|;
comment|//request already complete
name|stati
operator|.
name|append
argument_list|(
operator|&
operator|(
name|ao
operator|->
name|iStatus
operator|)
argument_list|)
expr_stmt|;
block|}
name|bool
name|timedout
init|=
literal|false
decl_stmt|;
name|TRequestStatus
name|tstat
decl_stmt|;
name|RTimer
name|t
decl_stmt|;
if|if
condition|(
name|ms
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|KErrNone
operator|!=
name|t
operator|.
name|CreateLocal
argument_list|()
condition|)
return|return
literal|false
return|;
name|t
operator|.
name|HighRes
argument_list|(
name|tstat
argument_list|,
name|ms
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|stati
operator|.
name|append
argument_list|(
operator|&
name|tstat
argument_list|)
expr_stmt|;
block|}
name|User
operator|::
name|WaitForNRequest
argument_list|(
name|stati
operator|.
name|data
argument_list|()
argument_list|,
name|stati
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ms
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tstat
operator|!=
name|KRequestPending
condition|)
block|{
name|timedout
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|t
operator|.
name|Cancel
argument_list|()
expr_stmt|;
comment|//balance thread semaphore
name|User
operator|::
name|WaitForRequest
argument_list|(
name|tstat
argument_list|)
expr_stmt|;
block|}
name|t
operator|.
name|Close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|timedout
condition|)
return|return
literal|false
return|;
foreach|foreach
control|(
name|CActive
modifier|*
name|ao
decl|,
name|aos
control|)
block|{
if|if
condition|(
name|ao
operator|->
name|iStatus
operator|!=
name|KRequestPending
condition|)
block|{
comment|//evil cast to allow calling of protected virtual
operator|(
operator|(
name|QActiveObject
operator|*
operator|)
name|ao
operator|)
operator|->
name|RunL
argument_list|()
expr_stmt|;
comment|//clear active& pending flags
name|ao
operator|->
name|iStatus
operator|=
name|TRequestStatus
argument_list|()
expr_stmt|;
break|break;
comment|//only call one
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qeventdispatcher_symbian_p.cpp"
end_include
end_unit
