begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsignalmapper.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|"qobject_p.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QSignalMapperPrivate
class|class
name|QSignalMapperPrivate
super|:
specifier|public
name|QObjectPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QSignalMapper
parameter_list|)
specifier|public
private|:
DECL|function|_q_senderDestroyed
name|void
name|_q_senderDestroyed
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSignalMapper
argument_list|)
expr_stmt|;
name|q
operator|->
name|removeMappings
argument_list|(
name|q
operator|->
name|sender
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|member|intHash
name|QHash
argument_list|<
name|QObject
modifier|*
argument_list|,
name|int
argument_list|>
name|intHash
decl_stmt|;
DECL|member|stringHash
name|QHash
argument_list|<
name|QObject
modifier|*
argument_list|,
name|QString
argument_list|>
name|stringHash
decl_stmt|;
DECL|member|widgetHash
name|QHash
argument_list|<
name|QObject
modifier|*
argument_list|,
name|QWidget
modifier|*
argument_list|>
name|widgetHash
decl_stmt|;
DECL|member|objectHash
name|QHash
argument_list|<
name|QObject
modifier|*
argument_list|,
name|QObject
modifier|*
argument_list|>
name|objectHash
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     \class QSignalMapper     \inmodule QtCore     \brief The QSignalMapper class bundles signals from identifiable senders.      \ingroup objectmodel       This class collects a set of parameterless signals, and re-emits     them with integer, string or widget parameters corresponding to     the object that sent the signal.      The class supports the mapping of particular strings or integers     with particular objects using setMapping(). The objects' signals     can then be connected to the map() slot which will emit the     mapped() signal with the string or integer associated with the     original signalling object. Mappings can be removed later using     removeMappings().      Example: Suppose we want to create a custom widget that contains     a group of buttons (like a tool palette). One approach is to     connect each button's \c clicked() signal to its own custom slot;     but in this example we want to connect all the buttons to a     single slot and parameterize the slot by the button that was     clicked.      Here's the definition of a simple custom widget that has a single     signal, \c clicked(), which is emitted with the text of the button     that was clicked:      \snippet qsignalmapper/buttonwidget.h 0     \snippet qsignalmapper/buttonwidget.h 1      The only function that we need to implement is the constructor:      \snippet qsignalmapper/buttonwidget.cpp 0     \snippet qsignalmapper/buttonwidget.cpp 1     \snippet qsignalmapper/buttonwidget.cpp 2      A list of texts is passed to the constructor. A signal mapper is     constructed and for each text in the list a QPushButton is     created. We connect each button's \c clicked() signal to the     signal mapper's map() slot, and create a mapping in the signal     mapper from each button to the button's text. Finally we connect     the signal mapper's mapped() signal to the custom widget's \c     clicked() signal. When the user clicks a button, the custom     widget will emit a single \c clicked() signal whose argument is     the text of the button the user clicked.      \sa QObject, QButtonGroup, QActionGroup */
end_comment
begin_comment
comment|/*!     Constructs a QSignalMapper with parent \a parent. */
end_comment
begin_constructor
DECL|function|QSignalMapper
name|QSignalMapper
operator|::
name|QSignalMapper
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QSignalMapperPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QSignalMapper. */
end_comment
begin_destructor
DECL|function|~QSignalMapper
name|QSignalMapper
operator|::
name|~
name|QSignalMapper
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Adds a mapping so that when map() is signalled from the given \a     sender, the signal mapped(\a id) is emitted.      There may be at most one integer ID for each sender.      \sa mapping() */
end_comment
begin_function
DECL|function|setMapping
name|void
name|QSignalMapper
operator|::
name|setMapping
parameter_list|(
name|QObject
modifier|*
name|sender
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSignalMapper
argument_list|)
expr_stmt|;
name|d
operator|->
name|intHash
operator|.
name|insert
argument_list|(
name|sender
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|sender
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_senderDestroyed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds a mapping so that when map() is signalled from the \a sender,     the signal mapped(\a text ) is emitted.      There may be at most one text for each sender. */
end_comment
begin_function
DECL|function|setMapping
name|void
name|QSignalMapper
operator|::
name|setMapping
parameter_list|(
name|QObject
modifier|*
name|sender
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSignalMapper
argument_list|)
expr_stmt|;
name|d
operator|->
name|stringHash
operator|.
name|insert
argument_list|(
name|sender
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|sender
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_senderDestroyed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds a mapping so that when map() is signalled from the \a sender,     the signal mapped(\a widget ) is emitted.      There may be at most one widget for each sender. */
end_comment
begin_function
DECL|function|setMapping
name|void
name|QSignalMapper
operator|::
name|setMapping
parameter_list|(
name|QObject
modifier|*
name|sender
parameter_list|,
name|QWidget
modifier|*
name|widget
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSignalMapper
argument_list|)
expr_stmt|;
name|d
operator|->
name|widgetHash
operator|.
name|insert
argument_list|(
name|sender
argument_list|,
name|widget
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|sender
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_senderDestroyed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds a mapping so that when map() is signalled from the \a sender,     the signal mapped(\a object ) is emitted.      There may be at most one object for each sender. */
end_comment
begin_function
DECL|function|setMapping
name|void
name|QSignalMapper
operator|::
name|setMapping
parameter_list|(
name|QObject
modifier|*
name|sender
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSignalMapper
argument_list|)
expr_stmt|;
name|d
operator|->
name|objectHash
operator|.
name|insert
argument_list|(
name|sender
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|sender
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_senderDestroyed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the sender QObject that is associated with the \a id.      \sa setMapping() */
end_comment
begin_function
DECL|function|mapping
name|QObject
modifier|*
name|QSignalMapper
operator|::
name|mapping
parameter_list|(
name|int
name|id
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSignalMapper
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|intHash
operator|.
name|key
argument_list|(
name|id
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload mapping() */
end_comment
begin_function
DECL|function|mapping
name|QObject
modifier|*
name|QSignalMapper
operator|::
name|mapping
parameter_list|(
specifier|const
name|QString
modifier|&
name|id
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSignalMapper
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|stringHash
operator|.
name|key
argument_list|(
name|id
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload mapping()      Returns the sender QObject that is associated with the \a widget. */
end_comment
begin_function
DECL|function|mapping
name|QObject
modifier|*
name|QSignalMapper
operator|::
name|mapping
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSignalMapper
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|widgetHash
operator|.
name|key
argument_list|(
name|widget
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload mapping()      Returns the sender QObject that is associated with the \a object. */
end_comment
begin_function
DECL|function|mapping
name|QObject
modifier|*
name|QSignalMapper
operator|::
name|mapping
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSignalMapper
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|objectHash
operator|.
name|key
argument_list|(
name|object
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Removes all mappings for \a sender.      This is done automatically when mapped objects are destroyed. */
end_comment
begin_function
DECL|function|removeMappings
name|void
name|QSignalMapper
operator|::
name|removeMappings
parameter_list|(
name|QObject
modifier|*
name|sender
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSignalMapper
argument_list|)
expr_stmt|;
name|d
operator|->
name|intHash
operator|.
name|remove
argument_list|(
name|sender
argument_list|)
expr_stmt|;
name|d
operator|->
name|stringHash
operator|.
name|remove
argument_list|(
name|sender
argument_list|)
expr_stmt|;
name|d
operator|->
name|widgetHash
operator|.
name|remove
argument_list|(
name|sender
argument_list|)
expr_stmt|;
name|d
operator|->
name|objectHash
operator|.
name|remove
argument_list|(
name|sender
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This slot emits signals based on which object sends signals to it. */
end_comment
begin_function
DECL|function|map
name|void
name|QSignalMapper
operator|::
name|map
parameter_list|()
block|{
name|map
argument_list|(
name|sender
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This slot emits signals based on the \a sender object. */
end_comment
begin_function
DECL|function|map
name|void
name|QSignalMapper
operator|::
name|map
parameter_list|(
name|QObject
modifier|*
name|sender
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSignalMapper
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|intHash
operator|.
name|contains
argument_list|(
name|sender
argument_list|)
condition|)
emit|emit
name|mapped
argument_list|(
name|d
operator|->
name|intHash
operator|.
name|value
argument_list|(
name|sender
argument_list|)
argument_list|)
emit|;
if|if
condition|(
name|d
operator|->
name|stringHash
operator|.
name|contains
argument_list|(
name|sender
argument_list|)
condition|)
emit|emit
name|mapped
argument_list|(
name|d
operator|->
name|stringHash
operator|.
name|value
argument_list|(
name|sender
argument_list|)
argument_list|)
emit|;
if|if
condition|(
name|d
operator|->
name|widgetHash
operator|.
name|contains
argument_list|(
name|sender
argument_list|)
condition|)
emit|emit
name|mapped
argument_list|(
name|d
operator|->
name|widgetHash
operator|.
name|value
argument_list|(
name|sender
argument_list|)
argument_list|)
emit|;
if|if
condition|(
name|d
operator|->
name|objectHash
operator|.
name|contains
argument_list|(
name|sender
argument_list|)
condition|)
emit|emit
name|mapped
argument_list|(
name|d
operator|->
name|objectHash
operator|.
name|value
argument_list|(
name|sender
argument_list|)
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \fn void QSignalMapper::mapped(int i)      This signal is emitted when map() is signalled from an object that     has an integer mapping set. The object's mapped integer is passed     in \a i.      \sa setMapping() */
end_comment
begin_comment
comment|/*!     \fn void QSignalMapper::mapped(const QString&text)      This signal is emitted when map() is signalled from an object that     has a string mapping set. The object's mapped string is passed in     \a text.      \sa setMapping() */
end_comment
begin_comment
comment|/*!     \fn void QSignalMapper::mapped(QWidget *widget)      This signal is emitted when map() is signalled from an object that     has a widget mapping set. The object's mapped widget is passed in     \a widget.      \sa setMapping() */
end_comment
begin_comment
comment|/*!     \fn void QSignalMapper::mapped(QObject *object)      This signal is emitted when map() is signalled from an object that     has an object mapping set. The object provided by the map is passed in     \a object.      \sa setMapping() */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qsignalmapper.cpp"
end_include
end_unit
