begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qbitarray.h"
end_include
begin_include
include|#
directive|include
file|"qbytearray.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qmap.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qeasingcurve.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qregularexpression.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qurl.h"
end_include
begin_include
include|#
directive|include
file|"qlocale.h"
end_include
begin_include
include|#
directive|include
file|"quuid.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_include
include|#
directive|include
file|"qabstractitemmodel.h"
end_include
begin_include
include|#
directive|include
file|"qjsonvalue.h"
end_include
begin_include
include|#
directive|include
file|"qjsonobject.h"
end_include
begin_include
include|#
directive|include
file|"qjsonarray.h"
end_include
begin_include
include|#
directive|include
file|"qjsondocument.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"private/qvariant_p.h"
end_include
begin_include
include|#
directive|include
file|"qmetatype_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GEOM_VARIANT
end_ifndef
begin_include
include|#
directive|include
file|"qsize.h"
end_include
begin_include
include|#
directive|include
file|"qpoint.h"
end_include
begin_include
include|#
directive|include
file|"qrect.h"
end_include
begin_include
include|#
directive|include
file|"qline.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<float.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_ifndef
ifndef|#
directive|ifndef
name|DBL_DIG
end_ifndef
begin_define
DECL|macro|DBL_DIG
define|#
directive|define
name|DBL_DIG
value|10
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FLT_DIG
end_ifndef
begin_define
DECL|macro|FLT_DIG
define|#
directive|define
name|FLT_DIG
value|6
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_namespace
namespace|namespace
block|{
DECL|class|HandlersManager
class|class
name|HandlersManager
block|{
DECL|member|Handlers
specifier|static
specifier|const
name|QVariant
operator|::
name|Handler
modifier|*
name|Handlers
index|[
name|QModulesPrivate
operator|::
name|ModulesCount
index|]
decl_stmt|;
public|public:
DECL|function|operator []
specifier|const
name|QVariant
operator|::
name|Handler
modifier|*
name|operator
name|[]
parameter_list|(
specifier|const
name|uint
name|typeId
parameter_list|)
specifier|const
block|{
return|return
name|Handlers
index|[
name|QModulesPrivate
operator|::
name|moduleForType
argument_list|(
name|typeId
argument_list|)
index|]
return|;
block|}
DECL|function|registerHandler
name|void
name|registerHandler
parameter_list|(
specifier|const
name|QModulesPrivate
operator|::
name|Names
name|name
parameter_list|,
specifier|const
name|QVariant
operator|::
name|Handler
modifier|*
name|handler
parameter_list|)
block|{
name|Handlers
index|[
name|name
index|]
operator|=
name|handler
expr_stmt|;
block|}
block|}
class|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_namespace
namespace|namespace
block|{
DECL|struct|CoreTypesFilter
struct|struct
name|CoreTypesFilter
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|Acceptor
name|Acceptor
block|{
DECL|member|IsAccepted
specifier|static
specifier|const
name|bool
name|IsAccepted
init|=
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsCore
operator|&&
name|QtMetaTypePrivate
operator|::
name|TypeDefinition
argument_list|<
name|T
argument_list|>
operator|::
name|IsAvailable
decl_stmt|;
block|}
struct|;
block|}
struct|;
block|}
end_namespace
begin_comment
comment|// annonymous
end_comment
begin_namespace
namespace|namespace
block|{
comment|// annonymous used to hide QVariant handlers
DECL|function|construct
specifier|static
name|void
name|construct
parameter_list|(
name|QVariant
operator|::
name|Private
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|copy
parameter_list|)
block|{
name|QVariantConstructor
argument_list|<
name|CoreTypesFilter
argument_list|>
name|constructor
argument_list|(
name|x
argument_list|,
name|copy
argument_list|)
decl_stmt|;
name|QMetaTypeSwitcher
operator|::
name|switcher
argument_list|<
name|void
argument_list|>
argument_list|(
name|constructor
argument_list|,
name|x
operator|->
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|function|clear
specifier|static
name|void
name|clear
parameter_list|(
name|QVariant
operator|::
name|Private
modifier|*
name|d
parameter_list|)
block|{
name|QVariantDestructor
argument_list|<
name|CoreTypesFilter
argument_list|>
name|cleaner
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|QMetaTypeSwitcher
operator|::
name|switcher
argument_list|<
name|void
argument_list|>
argument_list|(
name|cleaner
argument_list|,
name|d
operator|->
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|function|isNull
specifier|static
name|bool
name|isNull
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
name|d
parameter_list|)
block|{
name|QVariantIsNull
argument_list|<
name|CoreTypesFilter
argument_list|>
name|isNull
argument_list|(
name|d
argument_list|)
decl_stmt|;
return|return
name|QMetaTypeSwitcher
operator|::
name|switcher
argument_list|<
name|bool
argument_list|>
argument_list|(
name|isNull
argument_list|,
name|d
operator|->
name|type
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/*!   \internal    Compares \a a to \a b. The caller guarantees that \a a and \a b   are of the same type.  */
DECL|function|compare
specifier|static
name|bool
name|compare
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
name|a
parameter_list|,
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
name|b
parameter_list|)
block|{
name|QVariantComparator
argument_list|<
name|CoreTypesFilter
argument_list|>
name|comparator
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
return|return
name|QMetaTypeSwitcher
operator|::
name|switcher
argument_list|<
name|bool
argument_list|>
argument_list|(
name|comparator
argument_list|,
name|a
operator|->
name|type
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/*!   \internal  */
DECL|function|qMetaTypeNumber
specifier|static
name|qlonglong
name|qMetaTypeNumber
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
name|d
parameter_list|)
block|{
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QMetaType
operator|::
name|Int
case|:
return|return
name|d
operator|->
name|data
operator|.
name|i
return|;
case|case
name|QMetaType
operator|::
name|LongLong
case|:
return|return
name|d
operator|->
name|data
operator|.
name|ll
return|;
case|case
name|QMetaType
operator|::
name|Char
case|:
return|return
name|qlonglong
argument_list|(
name|d
operator|->
name|data
operator|.
name|c
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|SChar
case|:
return|return
name|qlonglong
argument_list|(
name|d
operator|->
name|data
operator|.
name|sc
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|Short
case|:
return|return
name|qlonglong
argument_list|(
name|d
operator|->
name|data
operator|.
name|s
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|Long
case|:
return|return
name|qlonglong
argument_list|(
name|d
operator|->
name|data
operator|.
name|l
argument_list|)
return|;
case|case
name|QMetaType
operator|::
name|Float
case|:
return|return
name|qRound64
argument_list|(
name|d
operator|->
name|data
operator|.
name|f
argument_list|)
return|;
case|case
name|QVariant
operator|::
name|Double
case|:
return|return
name|qRound64
argument_list|(
name|d
operator|->
name|data
operator|.
name|d
argument_list|)
return|;
block|}
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
DECL|function|qMetaTypeUNumber
specifier|static
name|qulonglong
name|qMetaTypeUNumber
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
name|d
parameter_list|)
block|{
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|UInt
case|:
return|return
name|d
operator|->
name|data
operator|.
name|u
return|;
case|case
name|QVariant
operator|::
name|ULongLong
case|:
return|return
name|d
operator|->
name|data
operator|.
name|ull
return|;
case|case
name|QMetaType
operator|::
name|UChar
case|:
return|return
name|d
operator|->
name|data
operator|.
name|uc
return|;
case|case
name|QMetaType
operator|::
name|UShort
case|:
return|return
name|d
operator|->
name|data
operator|.
name|us
return|;
case|case
name|QMetaType
operator|::
name|ULong
case|:
return|return
name|d
operator|->
name|data
operator|.
name|ul
return|;
block|}
name|Q_ASSERT
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
DECL|function|qConvertToNumber
specifier|static
name|qlonglong
name|qConvertToNumber
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
name|d
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
switch|switch
condition|(
name|uint
argument_list|(
name|d
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
name|QVariant
operator|::
name|String
case|:
return|return
name|v_cast
argument_list|<
name|QString
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toLongLong
argument_list|(
name|ok
argument_list|)
return|;
case|case
name|QVariant
operator|::
name|Char
case|:
return|return
name|v_cast
argument_list|<
name|QChar
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|unicode
argument_list|()
return|;
case|case
name|QVariant
operator|::
name|ByteArray
case|:
return|return
name|v_cast
argument_list|<
name|QByteArray
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toLongLong
argument_list|(
name|ok
argument_list|)
return|;
case|case
name|QVariant
operator|::
name|Bool
case|:
return|return
name|qlonglong
argument_list|(
name|d
operator|->
name|data
operator|.
name|b
argument_list|)
return|;
case|case
name|QVariant
operator|::
name|Double
case|:
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QMetaType
operator|::
name|Char
case|:
case|case
name|QMetaType
operator|::
name|SChar
case|:
case|case
name|QMetaType
operator|::
name|Short
case|:
case|case
name|QMetaType
operator|::
name|Long
case|:
case|case
name|QMetaType
operator|::
name|Float
case|:
case|case
name|QMetaType
operator|::
name|LongLong
case|:
return|return
name|qMetaTypeNumber
argument_list|(
name|d
argument_list|)
return|;
case|case
name|QVariant
operator|::
name|ULongLong
case|:
case|case
name|QVariant
operator|::
name|UInt
case|:
case|case
name|QMetaType
operator|::
name|UChar
case|:
case|case
name|QMetaType
operator|::
name|UShort
case|:
case|case
name|QMetaType
operator|::
name|ULong
case|:
return|return
name|qlonglong
argument_list|(
name|qMetaTypeUNumber
argument_list|(
name|d
argument_list|)
argument_list|)
return|;
block|}
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|Q_INT64_C
argument_list|(
literal|0
argument_list|)
return|;
block|}
DECL|function|qConvertToUnsignedNumber
specifier|static
name|qulonglong
name|qConvertToUnsignedNumber
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
name|d
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
switch|switch
condition|(
name|uint
argument_list|(
name|d
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
name|QVariant
operator|::
name|String
case|:
return|return
name|v_cast
argument_list|<
name|QString
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toULongLong
argument_list|(
name|ok
argument_list|)
return|;
case|case
name|QVariant
operator|::
name|Char
case|:
return|return
name|v_cast
argument_list|<
name|QChar
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|unicode
argument_list|()
return|;
case|case
name|QVariant
operator|::
name|ByteArray
case|:
return|return
name|v_cast
argument_list|<
name|QByteArray
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toULongLong
argument_list|(
name|ok
argument_list|)
return|;
case|case
name|QVariant
operator|::
name|Bool
case|:
return|return
name|qulonglong
argument_list|(
name|d
operator|->
name|data
operator|.
name|b
argument_list|)
return|;
case|case
name|QVariant
operator|::
name|Double
case|:
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QMetaType
operator|::
name|Char
case|:
case|case
name|QMetaType
operator|::
name|SChar
case|:
case|case
name|QMetaType
operator|::
name|Short
case|:
case|case
name|QMetaType
operator|::
name|Long
case|:
case|case
name|QMetaType
operator|::
name|Float
case|:
case|case
name|QMetaType
operator|::
name|LongLong
case|:
return|return
name|qulonglong
argument_list|(
name|qMetaTypeNumber
argument_list|(
name|d
argument_list|)
argument_list|)
return|;
case|case
name|QVariant
operator|::
name|ULongLong
case|:
case|case
name|QVariant
operator|::
name|UInt
case|:
case|case
name|QMetaType
operator|::
name|UChar
case|:
case|case
name|QMetaType
operator|::
name|UShort
case|:
case|case
name|QMetaType
operator|::
name|ULong
case|:
return|return
name|qMetaTypeUNumber
argument_list|(
name|d
argument_list|)
return|;
block|}
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|Q_UINT64_C
argument_list|(
literal|0
argument_list|)
return|;
block|}
template|template
parameter_list|<
name|typename
name|TInput
parameter_list|,
name|typename
name|LiteralWrapper
parameter_list|>
DECL|function|qt_convertToBool
specifier|inline
name|bool
name|qt_convertToBool
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
specifier|const
name|d
parameter_list|)
block|{
name|TInput
name|str
init|=
name|v_cast
argument_list|<
name|TInput
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toLower
argument_list|()
decl_stmt|;
return|return
operator|!
operator|(
name|str
operator|==
name|LiteralWrapper
argument_list|(
literal|"0"
argument_list|)
operator|||
name|str
operator|==
name|LiteralWrapper
argument_list|(
literal|"false"
argument_list|)
operator|||
name|str
operator|.
name|isEmpty
argument_list|()
operator|)
return|;
block|}
comment|/*!  \internal   Converts \a d to type \a t, which is placed in \a result.  */
DECL|function|convert
specifier|static
name|bool
name|convert
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
name|d
parameter_list|,
name|int
name|t
parameter_list|,
name|void
modifier|*
name|result
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|type
operator|!=
name|uint
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|bool
name|dummy
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|ok
operator|=
operator|&
name|dummy
expr_stmt|;
switch|switch
condition|(
name|uint
argument_list|(
name|t
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
case|case
name|QVariant
operator|::
name|Url
case|:
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|String
case|:
operator|*
cast|static_cast
argument_list|<
name|QUrl
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
name|QUrl
argument_list|(
operator|*
name|v_cast
argument_list|<
name|QString
argument_list|>
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
break|break;
endif|#
directive|endif
case|case
name|QVariant
operator|::
name|String
case|:
block|{
name|QString
modifier|*
name|str
init|=
cast|static_cast
argument_list|<
name|QString
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|Char
case|:
operator|*
name|str
operator|=
name|QString
argument_list|(
operator|*
name|v_cast
argument_list|<
name|QChar
argument_list|>
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Char
case|:
case|case
name|QMetaType
operator|::
name|SChar
case|:
case|case
name|QMetaType
operator|::
name|UChar
case|:
operator|*
name|str
operator|=
name|QChar
operator|::
name|fromLatin1
argument_list|(
name|d
operator|->
name|data
operator|.
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Short
case|:
case|case
name|QMetaType
operator|::
name|Long
case|:
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QVariant
operator|::
name|LongLong
case|:
operator|*
name|str
operator|=
name|QString
operator|::
name|number
argument_list|(
name|qMetaTypeNumber
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|UInt
case|:
case|case
name|QVariant
operator|::
name|ULongLong
case|:
case|case
name|QMetaType
operator|::
name|UShort
case|:
case|case
name|QMetaType
operator|::
name|ULong
case|:
operator|*
name|str
operator|=
name|QString
operator|::
name|number
argument_list|(
name|qMetaTypeUNumber
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Float
case|:
operator|*
name|str
operator|=
name|QString
operator|::
name|number
argument_list|(
name|d
operator|->
name|data
operator|.
name|f
argument_list|,
literal|'g'
argument_list|,
name|FLT_DIG
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Double
case|:
operator|*
name|str
operator|=
name|QString
operator|::
name|number
argument_list|(
name|d
operator|->
name|data
operator|.
name|d
argument_list|,
literal|'g'
argument_list|,
name|DBL_DIG
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DATESTRING
argument_list|)
case|case
name|QVariant
operator|::
name|Date
case|:
operator|*
name|str
operator|=
name|v_cast
argument_list|<
name|QDate
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Time
case|:
operator|*
name|str
operator|=
name|v_cast
argument_list|<
name|QTime
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|DateTime
case|:
operator|*
name|str
operator|=
name|v_cast
argument_list|<
name|QDateTime
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QVariant
operator|::
name|Bool
case|:
operator|*
name|str
operator|=
name|QLatin1String
argument_list|(
name|d
operator|->
name|data
operator|.
name|b
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|ByteArray
case|:
operator|*
name|str
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|v_cast
argument_list|<
name|QByteArray
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|constData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|StringList
case|:
if|if
condition|(
name|v_cast
argument_list|<
name|QStringList
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|count
argument_list|()
operator|==
literal|1
condition|)
operator|*
name|str
operator|=
name|v_cast
argument_list|<
name|QStringList
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
case|case
name|QVariant
operator|::
name|Url
case|:
operator|*
name|str
operator|=
name|v_cast
argument_list|<
name|QUrl
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toString
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QVariant
operator|::
name|Uuid
case|:
operator|*
name|str
operator|=
name|v_cast
argument_list|<
name|QUuid
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toString
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
break|break;
block|}
case|case
name|QVariant
operator|::
name|Char
case|:
block|{
name|QChar
modifier|*
name|c
init|=
cast|static_cast
argument_list|<
name|QChar
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QVariant
operator|::
name|LongLong
case|:
case|case
name|QMetaType
operator|::
name|Char
case|:
case|case
name|QMetaType
operator|::
name|SChar
case|:
case|case
name|QMetaType
operator|::
name|Short
case|:
case|case
name|QMetaType
operator|::
name|Long
case|:
case|case
name|QMetaType
operator|::
name|Float
case|:
operator|*
name|c
operator|=
name|QChar
argument_list|(
name|ushort
argument_list|(
name|qMetaTypeNumber
argument_list|(
name|d
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|UInt
case|:
case|case
name|QVariant
operator|::
name|ULongLong
case|:
case|case
name|QMetaType
operator|::
name|UChar
case|:
case|case
name|QMetaType
operator|::
name|UShort
case|:
case|case
name|QMetaType
operator|::
name|ULong
case|:
operator|*
name|c
operator|=
name|QChar
argument_list|(
name|ushort
argument_list|(
name|qMetaTypeUNumber
argument_list|(
name|d
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
break|break;
block|}
ifndef|#
directive|ifndef
name|QT_NO_GEOM_VARIANT
case|case
name|QVariant
operator|::
name|Size
case|:
block|{
name|QSize
modifier|*
name|s
init|=
cast|static_cast
argument_list|<
name|QSize
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|SizeF
case|:
operator|*
name|s
operator|=
name|v_cast
argument_list|<
name|QSizeF
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toSize
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
break|break;
block|}
case|case
name|QVariant
operator|::
name|SizeF
case|:
block|{
name|QSizeF
modifier|*
name|s
init|=
cast|static_cast
argument_list|<
name|QSizeF
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|Size
case|:
operator|*
name|s
operator|=
name|QSizeF
argument_list|(
operator|*
operator|(
name|v_cast
argument_list|<
name|QSize
argument_list|>
argument_list|(
name|d
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
break|break;
block|}
case|case
name|QVariant
operator|::
name|Line
case|:
block|{
name|QLine
modifier|*
name|s
init|=
cast|static_cast
argument_list|<
name|QLine
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|LineF
case|:
operator|*
name|s
operator|=
name|v_cast
argument_list|<
name|QLineF
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toLine
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
break|break;
block|}
case|case
name|QVariant
operator|::
name|LineF
case|:
block|{
name|QLineF
modifier|*
name|s
init|=
cast|static_cast
argument_list|<
name|QLineF
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|Line
case|:
operator|*
name|s
operator|=
name|QLineF
argument_list|(
operator|*
operator|(
name|v_cast
argument_list|<
name|QLine
argument_list|>
argument_list|(
name|d
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
break|break;
block|}
endif|#
directive|endif
case|case
name|QVariant
operator|::
name|StringList
case|:
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QVariant
operator|::
name|List
condition|)
block|{
name|QStringList
modifier|*
name|slst
init|=
cast|static_cast
argument_list|<
name|QStringList
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
specifier|const
name|QVariantList
modifier|*
name|list
init|=
name|v_cast
argument_list|<
name|QVariantList
argument_list|>
argument_list|(
name|d
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|slst
operator|->
name|append
argument_list|(
name|list
operator|->
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QVariant
operator|::
name|String
condition|)
block|{
name|QStringList
modifier|*
name|slst
init|=
cast|static_cast
argument_list|<
name|QStringList
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
operator|*
name|slst
operator|=
name|QStringList
argument_list|(
operator|*
name|v_cast
argument_list|<
name|QString
argument_list|>
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
break|break;
case|case
name|QVariant
operator|::
name|Date
case|:
block|{
name|QDate
modifier|*
name|dt
init|=
cast|static_cast
argument_list|<
name|QDate
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QVariant
operator|::
name|DateTime
condition|)
operator|*
name|dt
operator|=
name|v_cast
argument_list|<
name|QDateTime
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|date
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
elseif|else
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QVariant
operator|::
name|String
condition|)
operator|*
name|dt
operator|=
name|QDate
operator|::
name|fromString
argument_list|(
operator|*
name|v_cast
argument_list|<
name|QString
argument_list|>
argument_list|(
name|d
argument_list|)
argument_list|,
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
return|return
literal|false
return|;
return|return
name|dt
operator|->
name|isValid
argument_list|()
return|;
block|}
case|case
name|QVariant
operator|::
name|Time
case|:
block|{
name|QTime
modifier|*
name|t
init|=
cast|static_cast
argument_list|<
name|QTime
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|DateTime
case|:
operator|*
name|t
operator|=
name|v_cast
argument_list|<
name|QDateTime
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|time
argument_list|()
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
case|case
name|QVariant
operator|::
name|String
case|:
operator|*
name|t
operator|=
name|QTime
operator|::
name|fromString
argument_list|(
operator|*
name|v_cast
argument_list|<
name|QString
argument_list|>
argument_list|(
name|d
argument_list|)
argument_list|,
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
literal|false
return|;
block|}
return|return
name|t
operator|->
name|isValid
argument_list|()
return|;
block|}
case|case
name|QVariant
operator|::
name|DateTime
case|:
block|{
name|QDateTime
modifier|*
name|dt
init|=
cast|static_cast
argument_list|<
name|QDateTime
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
case|case
name|QVariant
operator|::
name|String
case|:
operator|*
name|dt
operator|=
name|QDateTime
operator|::
name|fromString
argument_list|(
operator|*
name|v_cast
argument_list|<
name|QString
argument_list|>
argument_list|(
name|d
argument_list|)
argument_list|,
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QVariant
operator|::
name|Date
case|:
operator|*
name|dt
operator|=
name|QDateTime
argument_list|(
operator|*
name|v_cast
argument_list|<
name|QDate
argument_list|>
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
name|dt
operator|->
name|isValid
argument_list|()
return|;
block|}
case|case
name|QVariant
operator|::
name|ByteArray
case|:
block|{
name|QByteArray
modifier|*
name|ba
init|=
cast|static_cast
argument_list|<
name|QByteArray
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|String
case|:
operator|*
name|ba
operator|=
name|v_cast
argument_list|<
name|QString
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toUtf8
argument_list|()
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Double
case|:
operator|*
name|ba
operator|=
name|QByteArray
operator|::
name|number
argument_list|(
name|d
operator|->
name|data
operator|.
name|d
argument_list|,
literal|'g'
argument_list|,
name|DBL_DIG
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Float
case|:
operator|*
name|ba
operator|=
name|QByteArray
operator|::
name|number
argument_list|(
name|d
operator|->
name|data
operator|.
name|f
argument_list|,
literal|'g'
argument_list|,
name|FLT_DIG
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Char
case|:
case|case
name|QMetaType
operator|::
name|SChar
case|:
case|case
name|QMetaType
operator|::
name|UChar
case|:
operator|*
name|ba
operator|=
name|QByteArray
argument_list|(
literal|1
argument_list|,
name|d
operator|->
name|data
operator|.
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QVariant
operator|::
name|LongLong
case|:
case|case
name|QMetaType
operator|::
name|Short
case|:
case|case
name|QMetaType
operator|::
name|Long
case|:
operator|*
name|ba
operator|=
name|QByteArray
operator|::
name|number
argument_list|(
name|qMetaTypeNumber
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|UInt
case|:
case|case
name|QVariant
operator|::
name|ULongLong
case|:
case|case
name|QMetaType
operator|::
name|UShort
case|:
case|case
name|QMetaType
operator|::
name|ULong
case|:
operator|*
name|ba
operator|=
name|QByteArray
operator|::
name|number
argument_list|(
name|qMetaTypeUNumber
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Bool
case|:
operator|*
name|ba
operator|=
name|QByteArray
argument_list|(
name|d
operator|->
name|data
operator|.
name|b
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
block|}
break|break;
case|case
name|QMetaType
operator|::
name|Short
case|:
operator|*
cast|static_cast
argument_list|<
name|short
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
name|short
argument_list|(
name|qConvertToNumber
argument_list|(
name|d
argument_list|,
name|ok
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|ok
return|;
case|case
name|QMetaType
operator|::
name|Long
case|:
operator|*
cast|static_cast
argument_list|<
name|long
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
name|long
argument_list|(
name|qConvertToNumber
argument_list|(
name|d
argument_list|,
name|ok
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|ok
return|;
case|case
name|QMetaType
operator|::
name|UShort
case|:
operator|*
cast|static_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
name|ushort
argument_list|(
name|qConvertToUnsignedNumber
argument_list|(
name|d
argument_list|,
name|ok
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|ok
return|;
case|case
name|QMetaType
operator|::
name|ULong
case|:
operator|*
cast|static_cast
argument_list|<
name|ulong
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
name|ulong
argument_list|(
name|qConvertToUnsignedNumber
argument_list|(
name|d
argument_list|,
name|ok
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|ok
return|;
case|case
name|QVariant
operator|::
name|Int
case|:
operator|*
cast|static_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
name|int
argument_list|(
name|qConvertToNumber
argument_list|(
name|d
argument_list|,
name|ok
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|ok
return|;
case|case
name|QVariant
operator|::
name|UInt
case|:
operator|*
cast|static_cast
argument_list|<
name|uint
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
name|uint
argument_list|(
name|qConvertToUnsignedNumber
argument_list|(
name|d
argument_list|,
name|ok
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|ok
return|;
case|case
name|QVariant
operator|::
name|LongLong
case|:
operator|*
cast|static_cast
argument_list|<
name|qlonglong
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
name|qConvertToNumber
argument_list|(
name|d
argument_list|,
name|ok
argument_list|)
expr_stmt|;
return|return
operator|*
name|ok
return|;
case|case
name|QVariant
operator|::
name|ULongLong
case|:
block|{
operator|*
cast|static_cast
argument_list|<
name|qulonglong
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
name|qConvertToUnsignedNumber
argument_list|(
name|d
argument_list|,
name|ok
argument_list|)
expr_stmt|;
return|return
operator|*
name|ok
return|;
block|}
case|case
name|QMetaType
operator|::
name|SChar
case|:
block|{
name|signed
name|char
name|s
init|=
name|qConvertToNumber
argument_list|(
name|d
argument_list|,
name|ok
argument_list|)
decl_stmt|;
operator|*
cast|static_cast
argument_list|<
name|signed
name|char
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
name|s
expr_stmt|;
return|return
operator|*
name|ok
return|;
block|}
case|case
name|QMetaType
operator|::
name|UChar
case|:
block|{
operator|*
cast|static_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
name|qConvertToUnsignedNumber
argument_list|(
name|d
argument_list|,
name|ok
argument_list|)
expr_stmt|;
return|return
operator|*
name|ok
return|;
block|}
case|case
name|QVariant
operator|::
name|Bool
case|:
block|{
name|bool
modifier|*
name|b
init|=
cast|static_cast
argument_list|<
name|bool
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|ByteArray
case|:
operator|*
name|b
operator|=
name|qt_convertToBool
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|String
case|:
operator|*
name|b
operator|=
name|qt_convertToBool
argument_list|<
name|QString
argument_list|,
name|QLatin1String
argument_list|>
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Char
case|:
operator|*
name|b
operator|=
operator|!
name|v_cast
argument_list|<
name|QChar
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|isNull
argument_list|()
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Double
case|:
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QVariant
operator|::
name|LongLong
case|:
case|case
name|QMetaType
operator|::
name|Char
case|:
case|case
name|QMetaType
operator|::
name|SChar
case|:
case|case
name|QMetaType
operator|::
name|Short
case|:
case|case
name|QMetaType
operator|::
name|Long
case|:
case|case
name|QMetaType
operator|::
name|Float
case|:
operator|*
name|b
operator|=
name|qMetaTypeNumber
argument_list|(
name|d
argument_list|)
operator|!=
name|Q_INT64_C
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|UInt
case|:
case|case
name|QVariant
operator|::
name|ULongLong
case|:
case|case
name|QMetaType
operator|::
name|UChar
case|:
case|case
name|QMetaType
operator|::
name|UShort
case|:
case|case
name|QMetaType
operator|::
name|ULong
case|:
operator|*
name|b
operator|=
name|qMetaTypeUNumber
argument_list|(
name|d
argument_list|)
operator|!=
name|Q_UINT64_C
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|b
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
block|}
case|case
name|QVariant
operator|::
name|Double
case|:
block|{
name|double
modifier|*
name|f
init|=
cast|static_cast
argument_list|<
name|double
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|String
case|:
operator|*
name|f
operator|=
name|v_cast
argument_list|<
name|QString
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toDouble
argument_list|(
name|ok
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|ByteArray
case|:
operator|*
name|f
operator|=
name|v_cast
argument_list|<
name|QByteArray
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toDouble
argument_list|(
name|ok
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Bool
case|:
operator|*
name|f
operator|=
name|double
argument_list|(
name|d
operator|->
name|data
operator|.
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Float
case|:
operator|*
name|f
operator|=
name|double
argument_list|(
name|d
operator|->
name|data
operator|.
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|LongLong
case|:
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QMetaType
operator|::
name|Char
case|:
case|case
name|QMetaType
operator|::
name|SChar
case|:
case|case
name|QMetaType
operator|::
name|Short
case|:
case|case
name|QMetaType
operator|::
name|Long
case|:
operator|*
name|f
operator|=
name|double
argument_list|(
name|qMetaTypeNumber
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|UInt
case|:
case|case
name|QVariant
operator|::
name|ULongLong
case|:
case|case
name|QMetaType
operator|::
name|UChar
case|:
case|case
name|QMetaType
operator|::
name|UShort
case|:
case|case
name|QMetaType
operator|::
name|ULong
case|:
operator|*
name|f
operator|=
name|double
argument_list|(
name|qMetaTypeUNumber
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|f
operator|=
literal|0.0
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
block|}
case|case
name|QMetaType
operator|::
name|Float
case|:
block|{
name|float
modifier|*
name|f
init|=
cast|static_cast
argument_list|<
name|float
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|String
case|:
operator|*
name|f
operator|=
name|v_cast
argument_list|<
name|QString
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toFloat
argument_list|(
name|ok
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|ByteArray
case|:
operator|*
name|f
operator|=
name|v_cast
argument_list|<
name|QByteArray
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|toFloat
argument_list|(
name|ok
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Bool
case|:
operator|*
name|f
operator|=
name|float
argument_list|(
name|d
operator|->
name|data
operator|.
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|Double
case|:
operator|*
name|f
operator|=
name|float
argument_list|(
name|d
operator|->
name|data
operator|.
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|LongLong
case|:
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QMetaType
operator|::
name|Char
case|:
case|case
name|QMetaType
operator|::
name|SChar
case|:
case|case
name|QMetaType
operator|::
name|Short
case|:
case|case
name|QMetaType
operator|::
name|Long
case|:
operator|*
name|f
operator|=
name|float
argument_list|(
name|qMetaTypeNumber
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QVariant
operator|::
name|UInt
case|:
case|case
name|QVariant
operator|::
name|ULongLong
case|:
case|case
name|QMetaType
operator|::
name|UChar
case|:
case|case
name|QMetaType
operator|::
name|UShort
case|:
case|case
name|QMetaType
operator|::
name|ULong
case|:
operator|*
name|f
operator|=
name|float
argument_list|(
name|qMetaTypeUNumber
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|f
operator|=
literal|0.0f
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
block|}
case|case
name|QVariant
operator|::
name|List
case|:
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QVariant
operator|::
name|StringList
condition|)
block|{
name|QVariantList
modifier|*
name|lst
init|=
cast|static_cast
argument_list|<
name|QVariantList
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
decl_stmt|;
specifier|const
name|QStringList
modifier|*
name|slist
init|=
name|v_cast
argument_list|<
name|QStringList
argument_list|>
argument_list|(
name|d
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|slist
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|lst
operator|->
name|append
argument_list|(
name|QVariant
argument_list|(
name|slist
operator|->
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qstrcmp
argument_list|(
name|QMetaType
operator|::
name|typeName
argument_list|(
name|d
operator|->
name|type
argument_list|)
argument_list|,
literal|"QList<QVariant>"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
cast|static_cast
argument_list|<
name|QVariantList
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
operator|*
cast|static_cast
argument_list|<
name|QList
argument_list|<
name|QVariant
argument_list|>
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|data
operator|.
name|shared
operator|->
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
break|break;
case|case
name|QVariant
operator|::
name|Map
case|:
if|if
condition|(
name|qstrcmp
argument_list|(
name|QMetaType
operator|::
name|typeName
argument_list|(
name|d
operator|->
name|type
argument_list|)
argument_list|,
literal|"QMap<QString, QVariant>"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
cast|static_cast
argument_list|<
name|QVariantMap
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
operator|*
cast|static_cast
argument_list|<
name|QMap
argument_list|<
name|QString
argument_list|,
name|QVariant
argument_list|>
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|data
operator|.
name|shared
operator|->
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
break|break;
case|case
name|QVariant
operator|::
name|Hash
case|:
if|if
condition|(
name|qstrcmp
argument_list|(
name|QMetaType
operator|::
name|typeName
argument_list|(
name|d
operator|->
name|type
argument_list|)
argument_list|,
literal|"QHash<QString, QVariant>"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
cast|static_cast
argument_list|<
name|QVariantHash
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
operator|*
cast|static_cast
argument_list|<
name|QHash
argument_list|<
name|QString
argument_list|,
name|QVariant
argument_list|>
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|data
operator|.
name|shared
operator|->
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
break|break;
ifndef|#
directive|ifndef
name|QT_NO_GEOM_VARIANT
case|case
name|QVariant
operator|::
name|Rect
case|:
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QVariant
operator|::
name|RectF
condition|)
operator|*
cast|static_cast
argument_list|<
name|QRect
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
operator|(
name|v_cast
argument_list|<
name|QRectF
argument_list|>
argument_list|(
name|d
argument_list|)
operator|)
operator|->
name|toRect
argument_list|()
expr_stmt|;
else|else
return|return
literal|false
return|;
break|break;
case|case
name|QVariant
operator|::
name|RectF
case|:
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QVariant
operator|::
name|Rect
condition|)
operator|*
cast|static_cast
argument_list|<
name|QRectF
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
operator|*
name|v_cast
argument_list|<
name|QRect
argument_list|>
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
return|return
literal|false
return|;
break|break;
case|case
name|QVariant
operator|::
name|PointF
case|:
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QVariant
operator|::
name|Point
condition|)
operator|*
cast|static_cast
argument_list|<
name|QPointF
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
operator|*
name|v_cast
argument_list|<
name|QPoint
argument_list|>
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
return|return
literal|false
return|;
break|break;
case|case
name|QVariant
operator|::
name|Point
case|:
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QVariant
operator|::
name|PointF
condition|)
operator|*
cast|static_cast
argument_list|<
name|QPoint
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
operator|(
name|v_cast
argument_list|<
name|QPointF
argument_list|>
argument_list|(
name|d
argument_list|)
operator|)
operator|->
name|toPoint
argument_list|()
expr_stmt|;
else|else
return|return
literal|false
return|;
break|break;
case|case
name|QMetaType
operator|::
name|Char
case|:
block|{
operator|*
cast|static_cast
argument_list|<
name|qint8
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
name|qint8
argument_list|(
name|qConvertToNumber
argument_list|(
name|d
argument_list|,
name|ok
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|ok
return|;
block|}
endif|#
directive|endif
case|case
name|QVariant
operator|::
name|Uuid
case|:
switch|switch
condition|(
name|d
operator|->
name|type
condition|)
block|{
case|case
name|QVariant
operator|::
name|String
case|:
operator|*
cast|static_cast
argument_list|<
name|QUuid
operator|*
argument_list|>
argument_list|(
name|result
argument_list|)
operator|=
name|QUuid
argument_list|(
operator|*
name|v_cast
argument_list|<
name|QString
argument_list|>
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
DECL|function|streamDebug
specifier|static
name|void
name|streamDebug
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|v
parameter_list|)
block|{
name|QVariant
operator|::
name|Private
modifier|*
name|d
init|=
cast|const_cast
argument_list|<
name|QVariant
operator|::
name|Private
operator|*
argument_list|>
argument_list|(
operator|&
name|v
operator|.
name|data_ptr
argument_list|()
argument_list|)
decl_stmt|;
name|QVariantDebugStream
argument_list|<
name|CoreTypesFilter
argument_list|>
name|stream
argument_list|(
name|dbg
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|QMetaTypeSwitcher
operator|::
name|switcher
argument_list|<
name|void
argument_list|>
argument_list|(
name|stream
argument_list|,
name|d
operator|->
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
DECL|member|qt_kernel_variant_handler
specifier|const
name|QVariant
operator|::
name|Handler
name|qt_kernel_variant_handler
init|=
block|{
name|construct
block|,
name|clear
block|,
name|isNull
block|,
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
literal|0
block|,
literal|0
block|,
endif|#
directive|endif
name|compare
block|,
name|convert
block|,
literal|0
block|,
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
name|streamDebug
else|#
directive|else
literal|0
endif|#
directive|endif
block|}
decl_stmt|;
DECL|function|dummyConstruct
specifier|static
name|void
name|dummyConstruct
parameter_list|(
name|QVariant
operator|::
name|Private
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QVariant"
argument_list|,
literal|"Trying to construct an unknown type"
argument_list|)
expr_stmt|;
block|}
DECL|function|dummyClear
specifier|static
name|void
name|dummyClear
parameter_list|(
name|QVariant
operator|::
name|Private
modifier|*
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QVariant"
argument_list|,
literal|"Trying to clear an unknown type"
argument_list|)
expr_stmt|;
block|}
DECL|function|dummyIsNull
specifier|static
name|bool
name|dummyIsNull
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
name|d
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QVariant::isNull"
argument_list|,
literal|"Trying to call isNull on an unknown type"
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|is_null
return|;
block|}
DECL|function|dummyCompare
specifier|static
name|bool
name|dummyCompare
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
parameter_list|,
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QVariant"
argument_list|,
literal|"Trying to compare an unknown types"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|function|dummyConvert
specifier|static
name|bool
name|dummyConvert
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QVariant"
argument_list|,
literal|"Trying to convert an unknown type"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
DECL|function|dummyStreamDebug
specifier|static
name|void
name|dummyStreamDebug
parameter_list|(
name|QDebug
parameter_list|,
specifier|const
name|QVariant
modifier|&
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QVariant"
argument_list|,
literal|"Trying to convert an unknown type"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
DECL|member|qt_dummy_variant_handler
specifier|const
name|QVariant
operator|::
name|Handler
name|qt_dummy_variant_handler
init|=
block|{
name|dummyConstruct
block|,
name|dummyClear
block|,
name|dummyIsNull
block|,
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
literal|0
block|,
literal|0
block|,
endif|#
directive|endif
name|dummyCompare
block|,
name|dummyConvert
block|,
literal|0
block|,
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
name|dummyStreamDebug
else|#
directive|else
literal|0
endif|#
directive|endif
block|}
decl_stmt|;
DECL|function|customConstruct
specifier|static
name|void
name|customConstruct
parameter_list|(
name|QVariant
operator|::
name|Private
modifier|*
name|d
parameter_list|,
specifier|const
name|void
modifier|*
name|copy
parameter_list|)
block|{
specifier|const
name|QMetaType
name|type
argument_list|(
name|d
operator|->
name|type
argument_list|)
decl_stmt|;
specifier|const
name|uint
name|size
init|=
name|type
operator|.
name|sizeOf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|qWarning
argument_list|(
literal|"Trying to construct an instance of an invalid type, type id: %i"
argument_list|,
name|d
operator|->
name|type
argument_list|)
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|QVariant
operator|::
name|Invalid
expr_stmt|;
return|return;
block|}
comment|// this logic should match with QVariantIntegrator::CanUseInternalSpace
if|if
condition|(
name|size
operator|<=
sizeof|sizeof
argument_list|(
name|QVariant
operator|::
name|Private
operator|::
name|Data
argument_list|)
operator|&&
operator|(
name|type
operator|.
name|flags
argument_list|()
operator|&
name|QMetaType
operator|::
name|MovableType
operator|)
condition|)
block|{
name|type
operator|.
name|construct
argument_list|(
operator|&
name|d
operator|->
name|data
operator|.
name|ptr
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|d
operator|->
name|is_shared
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
name|ptr
init|=
name|type
operator|.
name|create
argument_list|(
name|copy
argument_list|)
decl_stmt|;
name|d
operator|->
name|is_shared
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|data
operator|.
name|shared
operator|=
operator|new
name|QVariant
operator|::
name|PrivateShared
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|customClear
specifier|static
name|void
name|customClear
parameter_list|(
name|QVariant
operator|::
name|Private
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|is_shared
condition|)
block|{
name|QMetaType
operator|::
name|destruct
argument_list|(
name|d
operator|->
name|type
argument_list|,
operator|&
name|d
operator|->
name|data
operator|.
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QMetaType
operator|::
name|destroy
argument_list|(
name|d
operator|->
name|type
argument_list|,
name|d
operator|->
name|data
operator|.
name|shared
operator|->
name|ptr
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|data
operator|.
name|shared
expr_stmt|;
block|}
block|}
DECL|function|customIsNull
specifier|static
name|bool
name|customIsNull
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
name|d
parameter_list|)
block|{
return|return
name|d
operator|->
name|is_null
return|;
block|}
DECL|function|customCompare
specifier|static
name|bool
name|customCompare
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
name|a
parameter_list|,
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|typeName
init|=
name|QMetaType
operator|::
name|typeName
argument_list|(
name|a
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
operator|!
name|typeName
argument_list|)
operator|&&
name|Q_LIKELY
argument_list|(
operator|!
name|QMetaType
operator|::
name|isRegistered
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|)
condition|)
name|qFatal
argument_list|(
literal|"QVariant::compare: type %d unknown to QVariant."
argument_list|,
name|a
operator|->
name|type
argument_list|)
expr_stmt|;
specifier|const
name|void
modifier|*
name|a_ptr
init|=
name|a
operator|->
name|is_shared
condition|?
name|a
operator|->
name|data
operator|.
name|shared
operator|->
name|ptr
else|:
operator|&
operator|(
name|a
operator|->
name|data
operator|.
name|ptr
operator|)
decl_stmt|;
specifier|const
name|void
modifier|*
name|b_ptr
init|=
name|b
operator|->
name|is_shared
condition|?
name|b
operator|->
name|data
operator|.
name|shared
operator|->
name|ptr
else|:
operator|&
operator|(
name|b
operator|->
name|data
operator|.
name|ptr
operator|)
decl_stmt|;
name|uint
name|typeNameLen
init|=
name|qstrlen
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeNameLen
operator|>
literal|0
operator|&&
name|typeName
index|[
name|typeNameLen
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
return|return
operator|*
cast|static_cast
argument_list|<
name|void
operator|*
specifier|const
operator|*
argument_list|>
argument_list|(
name|a_ptr
argument_list|)
operator|==
operator|*
cast|static_cast
argument_list|<
name|void
operator|*
specifier|const
operator|*
argument_list|>
argument_list|(
name|b_ptr
argument_list|)
return|;
if|if
condition|(
name|a
operator|->
name|is_null
operator|&&
name|b
operator|->
name|is_null
condition|)
return|return
literal|true
return|;
return|return
operator|!
name|memcmp
argument_list|(
name|a_ptr
argument_list|,
name|b_ptr
argument_list|,
name|QMetaType
operator|::
name|sizeOf
argument_list|(
name|a
operator|->
name|type
argument_list|)
argument_list|)
return|;
block|}
DECL|function|customConvert
specifier|static
name|bool
name|customConvert
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
block|{
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
DECL|function|customStreamDebug
specifier|static
name|void
name|customStreamDebug
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|QMetaType
operator|::
name|TypeFlags
name|flags
init|=
name|QMetaType
operator|::
name|typeFlags
argument_list|(
name|variant
operator|.
name|userType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|QMetaType
operator|::
name|PointerToQObject
condition|)
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
name|variant
operator|.
name|value
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|()
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|dbg
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|variant
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
DECL|member|qt_custom_variant_handler
specifier|const
name|QVariant
operator|::
name|Handler
name|qt_custom_variant_handler
init|=
block|{
name|customConstruct
block|,
name|customClear
block|,
name|customIsNull
block|,
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
literal|0
block|,
literal|0
block|,
endif|#
directive|endif
name|customCompare
block|,
name|customConvert
block|,
literal|0
block|,
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
name|customStreamDebug
else|#
directive|else
literal|0
endif|#
directive|endif
block|}
decl_stmt|;
block|}
end_namespace
begin_comment
comment|// annonymous used to hide QVariant handlers
end_comment
begin_decl_stmt
DECL|variable|handlerManager
specifier|static
name|HandlersManager
name|handlerManager
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT_X
argument_list|(
operator|!
name|QModulesPrivate
operator|::
name|Core
argument_list|,
literal|"Initialization assumes that ModulesNames::Core is 0"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
DECL|member|Handlers
specifier|const
name|QVariant
operator|::
name|Handler
modifier|*
name|HandlersManager
operator|::
name|Handlers
index|[
name|QModulesPrivate
operator|::
name|ModulesCount
index|]
init|=
block|{
operator|&
name|qt_kernel_variant_handler
block|,
operator|&
name|qt_dummy_variant_handler
block|,
operator|&
name|qt_dummy_variant_handler
block|,
operator|&
name|qt_custom_variant_handler
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qcoreVariantHandler
name|Q_CORE_EXPORT
specifier|const
name|QVariant
operator|::
name|Handler
modifier|*
name|qcoreVariantHandler
parameter_list|()
block|{
return|return
operator|&
name|qt_kernel_variant_handler
return|;
block|}
end_function
begin_function
DECL|function|registerHandler
name|Q_CORE_EXPORT
name|void
name|QVariantPrivate
operator|::
name|registerHandler
parameter_list|(
specifier|const
name|int
comment|/* Modules::Names */
name|name
parameter_list|,
specifier|const
name|QVariant
operator|::
name|Handler
modifier|*
name|handler
parameter_list|)
block|{
name|handlerManager
operator|.
name|registerHandler
argument_list|(
cast|static_cast
argument_list|<
name|QModulesPrivate
operator|::
name|Names
argument_list|>
argument_list|(
name|name
argument_list|)
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QVariant     \brief The QVariant class acts like a union for the most common Qt data types.      \ingroup objectmodel     \ingroup shared       Because C++ forbids unions from including types that have     non-default constructors or destructors, most interesting Qt     classes cannot be used in unions. Without QVariant, this would be     a problem for QObject::property() and for database work, etc.      A QVariant object holds a single value of a single type() at a     time. (Some type()s are multi-valued, for example a string list.)     You can find out what type, T, the variant holds, convert it to a     different type using convert(), get its value using one of the     toT() functions (e.g., toSize()) and check whether the type can     be converted to a particular type using canConvert().      The methods named toT() (e.g., toInt(), toString()) are const. If     you ask for the stored type, they return a copy of the stored     object. If you ask for a type that can be generated from the     stored type, toT() copies and converts and leaves the object     itself unchanged. If you ask for a type that cannot be generated     from the stored type, the result depends on the type; see the     function documentation for details.      Here is some example code to demonstrate the use of QVariant:      \snippet code/src_corelib_kernel_qvariant.cpp 0      You can even store QList<QVariant> and QMap<QString, QVariant>     values in a variant, so you can easily construct arbitrarily     complex data structures of arbitrary types. This is very powerful     and versatile, but may prove less memory and speed efficient than     storing specific types in standard data structures.      QVariant also supports the notion of null values, where you can     have a defined type with no value set. However, note that QVariant     types can only be cast when they have had a value set.      \snippet code/src_corelib_kernel_qvariant.cpp 1      QVariant can be extended to support other types than those     mentioned in the \l Type enum. See the \l QMetaType documentation     for details.      \section1 A Note on GUI Types      Because QVariant is part of the QtCore library, it cannot provide     conversion functions to data types defined in QtGui, such as     QColor, QImage, and QPixmap. In other words, there is no \c     toColor() function. Instead, you can use the QVariant::value() or     the qvariant_cast() template function. For example:      \snippet code/src_corelib_kernel_qvariant.cpp 2      The inverse conversion (e.g., from QColor to QVariant) is     automatic for all data types supported by QVariant, including     GUI-related types:      \snippet code/src_corelib_kernel_qvariant.cpp 3      \section1 Using canConvert() and convert() Consecutively      When using canConvert() and convert() consecutively, it is possible for     canConvert() to return true, but convert() to return false. This     is typically because canConvert() only reports the general ability of     QVariant to convert between types given suitable data; it is still     possible to supply data which cannot actually be converted.      For example, canConvert() would return true when called on a variant     containing a string because, in principle, QVariant is able to convert     strings of numbers to integers.     However, if the string contains non-numeric characters, it cannot be     converted to an integer, and any attempt to convert it will fail.     Hence, it is important to have both functions return true for a     successful conversion.      \sa QMetaType */
end_comment
begin_comment
comment|/*!     \obsolete Use QMetaType::Type instead     \enum QVariant::Type      This enum type defines the types of variable that a QVariant can     contain.      \value Invalid  no type     \value BitArray  a QBitArray     \value Bitmap  a QBitmap     \value Bool  a bool     \value Brush  a QBrush     \value ByteArray  a QByteArray     \value Char  a QChar     \value Color  a QColor     \value Cursor  a QCursor     \value Date  a QDate     \value DateTime  a QDateTime     \value Double  a double     \value EasingCurve a QEasingCurve     \value Uuid a QUuid     \value ModelIndex a QModelIndex     \value Font  a QFont     \value Hash a QVariantHash     \value Icon  a QIcon     \value Image  a QImage     \value Int  an int     \value KeySequence  a QKeySequence     \value Line  a QLine     \value LineF  a QLineF     \value List  a QVariantList     \value Locale  a QLocale     \value LongLong a \l qlonglong     \value Map  a QVariantMap     \value Matrix  a QMatrix     \value Transform  a QTransform     \value Matrix4x4  a QMatrix4x4     \value Palette  a QPalette     \value Pen  a QPen     \value Pixmap  a QPixmap     \value Point  a QPoint     \value PointF  a QPointF     \value Polygon a QPolygon     \value PolygonF a QPolygonF     \value Quaternion  a QQuaternion     \value Rect  a QRect     \value RectF  a QRectF     \value RegExp  a QRegExp     \value RegularExpression  a QRegularExpression     \value Region  a QRegion     \value Size  a QSize     \value SizeF  a QSizeF     \value SizePolicy  a QSizePolicy     \value String  a QString     \value StringList  a QStringList     \value TextFormat  a QTextFormat     \value TextLength  a QTextLength     \value Time  a QTime     \value UInt  a \l uint     \value ULongLong a \l qulonglong     \value Url  a QUrl     \value Vector2D  a QVector2D     \value Vector3D  a QVector3D     \value Vector4D  a QVector4D      \value UserType Base value for user-defined types.      \omitvalue CString     \omitvalue ColorGroup     \omitvalue IconSet     \omitvalue LastGuiType     \omitvalue LastCoreType     \omitvalue LastType */
end_comment
begin_comment
comment|/*!     \fn QVariant::QVariant()      Constructs an invalid variant. */
end_comment
begin_comment
comment|/*!     \fn QVariant::QVariant(int typeId, const void *copy)      Constructs variant of type \a typeId, and initializes with     \a copy if \a copy is not 0.      Note that you have to pass the address of the variable you want stored.      Usually, you never have to use this constructor, use QVariant::fromValue()     instead to construct variants from the pointer types represented by     \c QMetaType::VoidStar, \c QMetaType::QObjectStar and     \c QMetaType::QWidgetStar.      \sa QVariant::fromValue(), Type */
end_comment
begin_comment
comment|/*!     \fn QVariant::QVariant(Type type)      Constructs a null variant of type \a type. */
end_comment
begin_comment
comment|/*!     \fn QVariant::create(int type, const void *copy)      \internal      Constructs a variant private of type \a type, and initializes with \a copy if     \a copy is not 0. */
end_comment
begin_function
DECL|function|create
name|void
name|QVariant
operator|::
name|create
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|copy
parameter_list|)
block|{
name|d
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|handlerManager
index|[
name|type
index|]
operator|->
name|construct
argument_list|(
operator|&
name|d
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QVariant::~QVariant()      Destroys the QVariant and the contained object.      Note that subclasses that reimplement clear() should reimplement     the destructor to call clear(). This destructor calls clear(), but     because it is the destructor, QVariant::clear() is called rather     than a subclass's clear(). */
end_comment
begin_destructor
DECL|function|~QVariant
name|QVariant
operator|::
name|~
name|QVariant
parameter_list|()
block|{
if|if
condition|(
operator|(
name|d
operator|.
name|is_shared
operator|&&
operator|!
name|d
operator|.
name|data
operator|.
name|shared
operator|->
name|ref
operator|.
name|deref
argument_list|()
operator|)
operator|||
operator|(
operator|!
name|d
operator|.
name|is_shared
operator|&&
name|d
operator|.
name|type
operator|>
name|Char
operator|)
condition|)
name|handlerManager
index|[
name|d
operator|.
name|type
index|]
operator|->
name|clear
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!   \fn QVariant::QVariant(const QVariant&p)      Constructs a copy of the variant, \a p, passed as the argument to     this constructor. */
end_comment
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|p
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|p
operator|.
name|d
argument_list|)
block|{
if|if
condition|(
name|d
operator|.
name|is_shared
condition|)
block|{
name|d
operator|.
name|data
operator|.
name|shared
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
elseif|else
if|if
condition|(
name|p
operator|.
name|d
operator|.
name|type
operator|>
name|Char
condition|)
block|{
name|handlerManager
index|[
name|d
operator|.
name|type
index|]
operator|->
name|construct
argument_list|(
operator|&
name|d
argument_list|,
name|p
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|.
name|is_null
operator|=
name|p
operator|.
name|d
operator|.
name|is_null
expr_stmt|;
block|}
block|}
end_constructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     Reads the variant from the data stream, \a s. */
end_comment
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|true
expr_stmt|;
name|s
operator|>>
operator|*
name|this
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QString&val)      Constructs a new variant with a string value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(QLatin1String val)      Constructs a new variant with a string value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const char *val)      Constructs a new variant with a string value of \a val.     The variant creates a deep copy of \a val into a QString assuming     UTF-8 encoding on the input \a val.      Note that \a val is converted to a QString for storing in the     variant and QVariant::userType() will return QMetaType::QString for     the variant.      You can disable this operator by defining \c     QT_NO_CAST_FROM_ASCII when you compile your applications. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CAST_FROM_ASCII
end_ifndef
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|QString
name|s
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|create
argument_list|(
name|String
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \fn QVariant::QVariant(const QStringList&val)      Constructs a new variant with a string list value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QMap<QString, QVariant>&val)      Constructs a new variant with a map of QVariants, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QHash<QString, QVariant>&val)      Constructs a new variant with a hash of QVariants, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QDate&val)      Constructs a new variant with a date value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QTime&val)      Constructs a new variant with a time value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QDateTime&val)      Constructs a new variant with a date/time value, \a val. */
end_comment
begin_comment
comment|/*!     \since 4.7   \fn QVariant::QVariant(const QEasingCurve&val)      Constructs a new variant with an easing curve value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QByteArray&val)      Constructs a new variant with a bytearray value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QBitArray&val)      Constructs a new variant with a bitarray value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QPoint&val)    Constructs a new variant with a point value of \a val.  */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QPointF&val)    Constructs a new variant with a point value of \a val.  */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QRectF&val)    Constructs a new variant with a rect value of \a val.  */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QLineF&val)    Constructs a new variant with a line value of \a val.  */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QLine&val)    Constructs a new variant with a line value of \a val.  */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QRect&val)    Constructs a new variant with a rect value of \a val.  */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QSize&val)    Constructs a new variant with a size value of \a val.  */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QSizeF&val)    Constructs a new variant with a size value of \a val.  */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QUrl&val)    Constructs a new variant with a url value of \a val.  */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(int val)      Constructs a new variant with an integer value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(uint val)      Constructs a new variant with an unsigned integer value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(qlonglong val)      Constructs a new variant with a long long integer value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(qulonglong val)      Constructs a new variant with an unsigned long long integer value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(bool val)      Constructs a new variant with a boolean value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(double val)      Constructs a new variant with a floating point value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(float val)      Constructs a new variant with a floating point value, \a val.     \since 4.6 */
end_comment
begin_comment
comment|/*!     \fn QVariant::QVariant(const QList<QVariant>&val)      Constructs a new variant with a list value, \a val. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(QChar c)    Constructs a new variant with a char value, \a c. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QLocale&l)    Constructs a new variant with a locale value, \a l. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QRegExp&regExp)    Constructs a new variant with the regexp value \a regExp. */
end_comment
begin_comment
comment|/*!   \fn QVariant::QVariant(const QRegularExpression&re)    \since 5.0    Constructs a new variant with the regular expression value \a re. */
end_comment
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
name|create
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
name|int
name|typeId
parameter_list|,
specifier|const
name|void
modifier|*
name|copy
parameter_list|)
block|{
name|create
argument_list|(
name|typeId
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \internal     flags is true if it is a pointer type  */
end_comment
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
name|int
name|typeId
parameter_list|,
specifier|const
name|void
modifier|*
name|copy
parameter_list|,
name|uint
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
condition|)
block|{
comment|//type is a pointer type
name|d
operator|.
name|type
operator|=
name|typeId
expr_stmt|;
name|d
operator|.
name|data
operator|.
name|ptr
operator|=
operator|*
cast|reinterpret_cast
argument_list|<
name|void
operator|*
specifier|const
operator|*
argument_list|>
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|create
argument_list|(
name|typeId
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Int
expr_stmt|;
name|d
operator|.
name|data
operator|.
name|i
operator|=
name|val
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
name|uint
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|UInt
expr_stmt|;
name|d
operator|.
name|data
operator|.
name|u
operator|=
name|val
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
name|qlonglong
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|LongLong
expr_stmt|;
name|d
operator|.
name|data
operator|.
name|ll
operator|=
name|val
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
name|qulonglong
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|ULongLong
expr_stmt|;
name|d
operator|.
name|data
operator|.
name|ull
operator|=
name|val
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
name|bool
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Bool
expr_stmt|;
name|d
operator|.
name|data
operator|.
name|b
operator|=
name|val
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
name|double
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Double
expr_stmt|;
name|d
operator|.
name|data
operator|.
name|d
operator|=
name|val
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|ByteArray
expr_stmt|;
name|v_construct
argument_list|<
name|QByteArray
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QBitArray
modifier|&
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|BitArray
expr_stmt|;
name|v_construct
argument_list|<
name|QBitArray
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QString
modifier|&
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|String
expr_stmt|;
name|v_construct
argument_list|<
name|QString
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
name|QChar
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Char
expr_stmt|;
name|v_construct
argument_list|<
name|QChar
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
name|QLatin1String
name|val
parameter_list|)
block|{
name|QString
name|str
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|String
expr_stmt|;
name|v_construct
argument_list|<
name|QString
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|StringList
expr_stmt|;
name|v_construct
argument_list|<
name|QStringList
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QDate
modifier|&
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Date
expr_stmt|;
name|v_construct
argument_list|<
name|QDate
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QTime
modifier|&
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Time
expr_stmt|;
name|v_construct
argument_list|<
name|QTime
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|DateTime
expr_stmt|;
name|v_construct
argument_list|<
name|QDateTime
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QEasingCurve
modifier|&
name|val
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|EasingCurve
expr_stmt|;
name|v_construct
argument_list|<
name|QEasingCurve
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QVariant
argument_list|>
modifier|&
name|list
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|List
expr_stmt|;
name|v_construct
argument_list|<
name|QVariantList
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QMap
argument_list|<
name|QString
argument_list|,
name|QVariant
argument_list|>
modifier|&
name|map
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Map
expr_stmt|;
name|v_construct
argument_list|<
name|QVariantMap
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QHash
argument_list|<
name|QString
argument_list|,
name|QVariant
argument_list|>
modifier|&
name|hash
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Hash
expr_stmt|;
name|v_construct
argument_list|<
name|QVariantHash
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GEOM_VARIANT
end_ifndef
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|pt
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Point
expr_stmt|;
name|v_construct
argument_list|<
name|QPoint
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|pt
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pt
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|PointF
expr_stmt|;
name|v_construct
argument_list|<
name|QPointF
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|pt
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|RectF
expr_stmt|;
name|v_construct
argument_list|<
name|QRectF
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QLineF
modifier|&
name|l
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|LineF
expr_stmt|;
name|v_construct
argument_list|<
name|QLineF
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QLine
modifier|&
name|l
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Line
expr_stmt|;
name|v_construct
argument_list|<
name|QLine
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Rect
expr_stmt|;
name|v_construct
argument_list|<
name|QRect
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QSize
modifier|&
name|s
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Size
expr_stmt|;
name|v_construct
argument_list|<
name|QSize
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QSizeF
modifier|&
name|s
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|SizeF
expr_stmt|;
name|v_construct
argument_list|<
name|QSizeF
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|u
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Url
expr_stmt|;
name|v_construct
argument_list|<
name|QUrl
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QLocale
modifier|&
name|l
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Locale
expr_stmt|;
name|v_construct
argument_list|<
name|QLocale
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QRegExp
modifier|&
name|regExp
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|RegExp
expr_stmt|;
name|v_construct
argument_list|<
name|QRegExp
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|regExp
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_constructor
DECL|function|QVariant
name|QVariant
operator|::
name|QVariant
parameter_list|(
specifier|const
name|QRegularExpression
modifier|&
name|re
parameter_list|)
block|{
name|d
operator|.
name|is_null
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|QMetaType
operator|::
name|QRegularExpression
expr_stmt|;
name|v_construct
argument_list|<
name|QRegularExpression
argument_list|>
argument_list|(
operator|&
name|d
argument_list|,
name|re
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_BOOTSTRAPPED
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_REGEXP
end_comment
begin_comment
comment|/*!     Returns the storage type of the value stored in the variant.     Although this function is declared as returning QVariant::Type,     the return value should be interpreted as QMetaType::Type. In     particular, QVariant::UserType is returned here only if the value     is equal or greater than QMetaType::User.      Note that return values in the ranges QVariant::Char through     QVariant::RegExp and QVariant::Font through QVariant::Transform     correspond to the values in the ranges QMetaType::QChar through     QMetaType::QRegExp and QMetaType::QFont through QMetaType::QQuaternion.      Pay particular attention when working with char and QChar     variants.  Note that there is no QVariant constructor specifically     for type char, but there is one for QChar. For a variant of type     QChar, this function returns QVariant::Char, which is the same as     QMetaType::QChar, but for a variant of type \c char, this function     returns QMetaType::Char, which is \e not the same as     QVariant::Char.      Also note that the types \c void*, \c long, \c short, \c unsigned     \c long, \c unsigned \c short, \c unsigned \c char, \c float, \c     QObject*, and \c QWidget* are represented in QMetaType::Type but     not in QVariant::Type, and they can be returned by this function.     However, they are considered to be user defined types when tested     against QVariant::Type.      To test whether an instance of QVariant contains a data type that     is compatible with the data type you are interested in, use     canConvert(). */
end_comment
begin_function
DECL|function|type
name|QVariant
operator|::
name|Type
name|QVariant
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|.
name|type
operator|>=
name|QMetaType
operator|::
name|User
condition|?
name|UserType
else|:
cast|static_cast
argument_list|<
name|Type
argument_list|>
argument_list|(
name|d
operator|.
name|type
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the storage type of the value stored in the variant. For     non-user types, this is the same as type().      \sa type() */
end_comment
begin_function
DECL|function|userType
name|int
name|QVariant
operator|::
name|userType
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|.
name|type
return|;
block|}
end_function
begin_comment
comment|/*!     Assigns the value of the variant \a variant to this variant. */
end_comment
begin_function
DECL|function|operator =
name|QVariant
modifier|&
name|QVariant
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|variant
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
operator|&
name|variant
condition|)
return|return
operator|*
name|this
return|;
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|variant
operator|.
name|d
operator|.
name|is_shared
condition|)
block|{
name|variant
operator|.
name|d
operator|.
name|data
operator|.
name|shared
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
name|d
operator|=
name|variant
operator|.
name|d
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|variant
operator|.
name|d
operator|.
name|type
operator|>
name|Char
condition|)
block|{
name|d
operator|.
name|type
operator|=
name|variant
operator|.
name|d
operator|.
name|type
expr_stmt|;
name|handlerManager
index|[
name|d
operator|.
name|type
index|]
operator|->
name|construct
argument_list|(
operator|&
name|d
argument_list|,
name|variant
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|.
name|is_null
operator|=
name|variant
operator|.
name|d
operator|.
name|is_null
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|variant
operator|.
name|d
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QVariant::swap(QVariant&other)     \since 4.8      Swaps variant \a other with this variant. This operation is very     fast and never fails. */
end_comment
begin_comment
comment|/*!     \fn void QVariant::detach()      \internal */
end_comment
begin_function
DECL|function|detach
name|void
name|QVariant
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
operator|.
name|is_shared
operator|||
name|d
operator|.
name|data
operator|.
name|shared
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
condition|)
return|return;
name|Private
name|dd
decl_stmt|;
name|dd
operator|.
name|type
operator|=
name|d
operator|.
name|type
expr_stmt|;
name|handlerManager
index|[
name|d
operator|.
name|type
index|]
operator|->
name|construct
argument_list|(
operator|&
name|dd
argument_list|,
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|data
operator|.
name|shared
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|handlerManager
index|[
name|d
operator|.
name|type
index|]
operator|->
name|clear
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
name|d
operator|.
name|data
operator|.
name|shared
operator|=
name|dd
operator|.
name|data
operator|.
name|shared
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QVariant::isDetached() const      \internal */
end_comment
begin_comment
comment|/*!     Returns the name of the type stored in the variant. The returned     strings describe the C++ datatype used to store the data: for     example, "QFont", "QString", or "QVariantList". An Invalid     variant returns 0. */
end_comment
begin_function
DECL|function|typeName
specifier|const
name|char
modifier|*
name|QVariant
operator|::
name|typeName
parameter_list|()
specifier|const
block|{
return|return
name|QMetaType
operator|::
name|typeName
argument_list|(
name|d
operator|.
name|type
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Convert this variant to type Invalid and free up any resources     used. */
end_comment
begin_function
DECL|function|clear
name|void
name|QVariant
operator|::
name|clear
parameter_list|()
block|{
if|if
condition|(
operator|(
name|d
operator|.
name|is_shared
operator|&&
operator|!
name|d
operator|.
name|data
operator|.
name|shared
operator|->
name|ref
operator|.
name|deref
argument_list|()
operator|)
operator|||
operator|(
operator|!
name|d
operator|.
name|is_shared
operator|&&
name|d
operator|.
name|type
operator|>
name|Char
operator|)
condition|)
name|handlerManager
index|[
name|d
operator|.
name|type
index|]
operator|->
name|clear
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
name|d
operator|.
name|type
operator|=
name|Invalid
expr_stmt|;
name|d
operator|.
name|is_null
operator|=
literal|true
expr_stmt|;
name|d
operator|.
name|is_shared
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Converts the int representation of the storage type, \a typeId, to     its string representation.      Returns a null pointer if the type is QVariant::Invalid or doesn't exist. */
end_comment
begin_function
DECL|function|typeToName
specifier|const
name|char
modifier|*
name|QVariant
operator|::
name|typeToName
parameter_list|(
name|int
name|typeId
parameter_list|)
block|{
return|return
name|QMetaType
operator|::
name|typeName
argument_list|(
name|typeId
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Converts the string representation of the storage type given in \a     name, to its enum representation.      If the string representation cannot be converted to any enum     representation, the variant is set to \c Invalid. */
end_comment
begin_function
DECL|function|nameToType
name|QVariant
operator|::
name|Type
name|QVariant
operator|::
name|nameToType
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|metaType
init|=
name|QMetaType
operator|::
name|type
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|metaType
operator|<=
name|int
argument_list|(
name|UserType
argument_list|)
condition|?
name|QVariant
operator|::
name|Type
argument_list|(
name|metaType
argument_list|)
else|:
name|UserType
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_enum
DECL|enumerator|MapFromThreeCount
enum|enum
block|{
name|MapFromThreeCount
init|=
literal|36
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|mapIdFromQt3ToCurrent
specifier|static
specifier|const
name|ushort
name|mapIdFromQt3ToCurrent
index|[
name|MapFromThreeCount
index|]
init|=
block|{
name|QVariant
operator|::
name|Invalid
block|,
name|QVariant
operator|::
name|Map
block|,
name|QVariant
operator|::
name|List
block|,
name|QVariant
operator|::
name|String
block|,
name|QVariant
operator|::
name|StringList
block|,
name|QVariant
operator|::
name|Font
block|,
name|QVariant
operator|::
name|Pixmap
block|,
name|QVariant
operator|::
name|Brush
block|,
name|QVariant
operator|::
name|Rect
block|,
name|QVariant
operator|::
name|Size
block|,
name|QVariant
operator|::
name|Color
block|,
name|QVariant
operator|::
name|Palette
block|,
literal|0
block|,
comment|// ColorGroup
name|QVariant
operator|::
name|Icon
block|,
name|QVariant
operator|::
name|Point
block|,
name|QVariant
operator|::
name|Image
block|,
name|QVariant
operator|::
name|Int
block|,
name|QVariant
operator|::
name|UInt
block|,
name|QVariant
operator|::
name|Bool
block|,
name|QVariant
operator|::
name|Double
block|,
name|QVariant
operator|::
name|ByteArray
block|,
name|QVariant
operator|::
name|Polygon
block|,
name|QVariant
operator|::
name|Region
block|,
name|QVariant
operator|::
name|Bitmap
block|,
name|QVariant
operator|::
name|Cursor
block|,
name|QVariant
operator|::
name|SizePolicy
block|,
name|QVariant
operator|::
name|Date
block|,
name|QVariant
operator|::
name|Time
block|,
name|QVariant
operator|::
name|DateTime
block|,
name|QVariant
operator|::
name|ByteArray
block|,
name|QVariant
operator|::
name|BitArray
block|,
name|QVariant
operator|::
name|KeySequence
block|,
name|QVariant
operator|::
name|Pen
block|,
name|QVariant
operator|::
name|LongLong
block|,
name|QVariant
operator|::
name|ULongLong
block|,
name|QVariant
operator|::
name|EasingCurve
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     Internal function for loading a variant from stream \a s. Use the     stream operators instead.      \internal */
end_comment
begin_function
DECL|function|load
name|void
name|QVariant
operator|::
name|load
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|quint32
name|typeId
decl_stmt|;
name|s
operator|>>
name|typeId
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_4_0
condition|)
block|{
if|if
condition|(
name|typeId
operator|>=
name|MapFromThreeCount
condition|)
return|return;
name|typeId
operator|=
name|mapIdFromQt3ToCurrent
index|[
name|typeId
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_5_0
condition|)
block|{
if|if
condition|(
name|typeId
operator|==
literal|127
comment|/* QVariant::UserType */
condition|)
block|{
name|typeId
operator|=
name|QMetaType
operator|::
name|User
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typeId
operator|>=
literal|128
operator|&&
name|typeId
operator|!=
name|QVariant
operator|::
name|UserType
condition|)
block|{
comment|// In Qt4 id == 128 was FirstExtCoreType. In Qt5 ExtCoreTypes set was merged to CoreTypes
comment|// by moving all ids down by 97.
name|typeId
operator|-=
literal|97
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typeId
operator|==
literal|75
comment|/* QSizePolicy */
condition|)
block|{
name|typeId
operator|=
name|QMetaType
operator|::
name|QSizePolicy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typeId
operator|>
literal|75
operator|&&
name|typeId
operator|<=
literal|86
condition|)
block|{
comment|// and as a result these types received lower ids too
comment|// QKeySequence QPen QTextLength QTextFormat QMatrix QTransform QMatrix4x4 QVector2D QVector3D QVector4D QQuaternion
name|typeId
operator|-=
literal|1
expr_stmt|;
block|}
block|}
name|qint8
name|is_null
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_2
condition|)
name|s
operator|>>
name|is_null
expr_stmt|;
if|if
condition|(
name|typeId
operator|==
name|QVariant
operator|::
name|UserType
condition|)
block|{
name|QByteArray
name|name
decl_stmt|;
name|s
operator|>>
name|name
expr_stmt|;
name|typeId
operator|=
name|QMetaType
operator|::
name|type
argument_list|(
name|name
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|typeId
operator|==
name|QMetaType
operator|::
name|UnknownType
condition|)
block|{
name|s
operator|.
name|setStatus
argument_list|(
name|QDataStream
operator|::
name|ReadCorruptData
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|create
argument_list|(
name|typeId
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|.
name|is_null
operator|=
name|is_null
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_5_0
condition|)
block|{
comment|// Since we wrote something, we should read something
name|QString
name|x
decl_stmt|;
name|s
operator|>>
name|x
expr_stmt|;
block|}
name|d
operator|.
name|is_null
operator|=
literal|true
expr_stmt|;
return|return;
block|}
comment|// const cast is safe since we operate on a newly constructed variant
if|if
condition|(
operator|!
name|QMetaType
operator|::
name|load
argument_list|(
name|s
argument_list|,
name|d
operator|.
name|type
argument_list|,
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|s
operator|.
name|setStatus
argument_list|(
name|QDataStream
operator|::
name|ReadCorruptData
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"QVariant::load: unable to load type %d."
argument_list|,
name|d
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Internal function for saving a variant to the stream \a s. Use the     stream operators instead.      \internal */
end_comment
begin_function
DECL|function|save
name|void
name|QVariant
operator|::
name|save
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|)
specifier|const
block|{
name|quint32
name|typeId
init|=
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_4_0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|MapFromThreeCount
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|mapIdFromQt3ToCurrent
index|[
name|i
index|]
operator|==
name|typeId
condition|)
block|{
name|typeId
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|s
operator|<<
name|QVariant
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_5_0
condition|)
block|{
if|if
condition|(
name|typeId
operator|==
name|QMetaType
operator|::
name|User
condition|)
block|{
name|typeId
operator|=
literal|127
expr_stmt|;
comment|// QVariant::UserType had this value in Qt4
block|}
elseif|else
if|if
condition|(
name|typeId
operator|>=
literal|128
operator|-
literal|97
operator|&&
name|typeId
operator|<=
name|LastCoreType
condition|)
block|{
comment|// In Qt4 id == 128 was FirstExtCoreType. In Qt5 ExtCoreTypes set was merged to CoreTypes
comment|// by moving all ids down by 97.
name|typeId
operator|+=
literal|97
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typeId
operator|==
name|QMetaType
operator|::
name|QSizePolicy
condition|)
block|{
name|typeId
operator|=
literal|75
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typeId
operator|>=
name|QMetaType
operator|::
name|QKeySequence
operator|&&
name|typeId
operator|<=
name|QMetaType
operator|::
name|QQuaternion
condition|)
block|{
comment|// and as a result these types received lower ids too
name|typeId
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|s
operator|<<
name|typeId
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|>=
name|QDataStream
operator|::
name|Qt_4_2
condition|)
name|s
operator|<<
name|qint8
argument_list|(
name|d
operator|.
name|is_null
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|type
operator|>=
name|QVariant
operator|::
name|UserType
condition|)
block|{
name|s
operator|<<
name|QMetaType
operator|::
name|typeName
argument_list|(
name|userType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|version
argument_list|()
operator|<
name|QDataStream
operator|::
name|Qt_5_0
condition|)
name|s
operator|<<
name|QString
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|QMetaType
operator|::
name|save
argument_list|(
name|s
argument_list|,
name|d
operator|.
name|type
argument_list|,
name|constData
argument_list|()
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QVariant::save: unable to save type '%s' (type id: %d).\n"
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|d
operator|.
name|type
argument_list|)
argument_list|,
name|d
operator|.
name|type
argument_list|)
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
literal|false
argument_list|,
literal|"QVariant::save"
argument_list|,
literal|"Invalid type to save"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Reads a variant \a p from the stream \a s.      \sa \link datastreamformat.html Format of the QDataStream     operators \endlink */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QVariant
modifier|&
name|p
parameter_list|)
block|{
name|p
operator|.
name|load
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     Writes a variant \a p to the stream \a s.      \sa \link datastreamformat.html Format of the QDataStream     operators \endlink */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|p
parameter_list|)
block|{
name|p
operator|.
name|save
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     Reads a variant type \a p in enum representation from the stream \a s. */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QVariant
operator|::
name|Type
modifier|&
name|p
parameter_list|)
block|{
name|quint32
name|u
decl_stmt|;
name|s
operator|>>
name|u
expr_stmt|;
name|p
operator|=
operator|(
name|QVariant
operator|::
name|Type
operator|)
name|u
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     Writes a variant type \a p to the stream \a s. */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QVariant
operator|::
name|Type
name|p
parameter_list|)
block|{
name|s
operator|<<
cast|static_cast
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*!     \fn bool QVariant::isValid() const      Returns true if the storage type of this variant is not     QVariant::Invalid; otherwise returns false. */
end_comment
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|qVariantToHelper
specifier|inline
name|T
name|qVariantToHelper
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|&
name|d
parameter_list|,
specifier|const
name|HandlersManager
modifier|&
name|handlerManager
parameter_list|)
block|{
specifier|const
name|uint
name|targetType
init|=
name|qMetaTypeId
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|type
operator|==
name|targetType
condition|)
return|return
operator|*
name|v_cast
argument_list|<
name|T
argument_list|>
argument_list|(
operator|&
name|d
argument_list|)
return|;
name|T
name|ret
decl_stmt|;
name|handlerManager
index|[
name|d
operator|.
name|type
index|]
operator|->
name|convert
argument_list|(
operator|&
name|d
argument_list|,
name|targetType
argument_list|,
operator|&
name|ret
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QStringList QVariant::toStringList() const      Returns the variant as a QStringList if the variant has type()     StringList, \l String, or \l List of a type that can be converted     to QString; otherwise returns an empty list.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toStringList
name|QStringList
name|QVariant
operator|::
name|toStringList
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QStringList
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the variant as a QString if the variant has type() \l     String, \l Bool, \l ByteArray, \l Char, \l Date, \l DateTime, \l     Double, \l Int, \l LongLong, \l StringList, \l Time, \l UInt, or     \l ULongLong; otherwise returns an empty string.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QVariant
operator|::
name|toString
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QString
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the variant as a QMap<QString, QVariant> if the variant     has type() \l Map; otherwise returns an empty map.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toMap
name|QVariantMap
name|QVariant
operator|::
name|toMap
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QVariantMap
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the variant as a QHash<QString, QVariant> if the variant     has type() \l Hash; otherwise returns an empty map.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toHash
name|QVariantHash
name|QVariant
operator|::
name|toHash
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QVariantHash
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDate QVariant::toDate() const      Returns the variant as a QDate if the variant has type() \l Date,     \l DateTime, or \l String; otherwise returns an invalid date.      If the type() is \l String, an invalid date will be returned if the     string cannot be parsed as a Qt::ISODate format date.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toDate
name|QDate
name|QVariant
operator|::
name|toDate
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QDate
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QTime QVariant::toTime() const      Returns the variant as a QTime if the variant has type() \l Time,     \l DateTime, or \l String; otherwise returns an invalid time.      If the type() is \l String, an invalid time will be returned if     the string cannot be parsed as a Qt::ISODate format time.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toTime
name|QTime
name|QVariant
operator|::
name|toTime
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QTime
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QDateTime QVariant::toDateTime() const      Returns the variant as a QDateTime if the variant has type() \l     DateTime, \l Date, or \l String; otherwise returns an invalid     date/time.      If the type() is \l String, an invalid date/time will be returned     if the string cannot be parsed as a Qt::ISODate format date/time.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toDateTime
name|QDateTime
name|QVariant
operator|::
name|toDateTime
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QDateTime
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7     \fn QEasingCurve QVariant::toEasingCurve() const      Returns the variant as a QEasingCurve if the variant has type() \l     EasingCurve; otherwise returns a default easing curve.      \sa canConvert(), convert() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_function
DECL|function|toEasingCurve
name|QEasingCurve
name|QVariant
operator|::
name|toEasingCurve
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QEasingCurve
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn QByteArray QVariant::toByteArray() const      Returns the variant as a QByteArray if the variant has type() \l     ByteArray or \l String (converted using QString::fromUtf8());     otherwise returns an empty byte array.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toByteArray
name|QByteArray
name|QVariant
operator|::
name|toByteArray
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QByteArray
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GEOM_VARIANT
end_ifndef
begin_comment
comment|/*!     \fn QPoint QVariant::toPoint() const      Returns the variant as a QPoint if the variant has type()     \l Point or \l PointF; otherwise returns a null QPoint.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toPoint
name|QPoint
name|QVariant
operator|::
name|toPoint
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QPoint
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRect QVariant::toRect() const      Returns the variant as a QRect if the variant has type() \l Rect;     otherwise returns an invalid QRect.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toRect
name|QRect
name|QVariant
operator|::
name|toRect
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QRect
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QSize QVariant::toSize() const      Returns the variant as a QSize if the variant has type() \l Size;     otherwise returns an invalid QSize.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toSize
name|QSize
name|QVariant
operator|::
name|toSize
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QSize
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QSizeF QVariant::toSizeF() const      Returns the variant as a QSizeF if the variant has type() \l     SizeF; otherwise returns an invalid QSizeF.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toSizeF
name|QSizeF
name|QVariant
operator|::
name|toSizeF
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QSizeF
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRectF QVariant::toRectF() const      Returns the variant as a QRectF if the variant has type() \l Rect     or \l RectF; otherwise returns an invalid QRectF.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toRectF
name|QRectF
name|QVariant
operator|::
name|toRectF
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QRectF
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QLineF QVariant::toLineF() const      Returns the variant as a QLineF if the variant has type() \l     LineF; otherwise returns an invalid QLineF.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toLineF
name|QLineF
name|QVariant
operator|::
name|toLineF
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QLineF
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QLine QVariant::toLine() const      Returns the variant as a QLine if the variant has type() \l Line;     otherwise returns an invalid QLine.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toLine
name|QLine
name|QVariant
operator|::
name|toLine
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QLine
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QPointF QVariant::toPointF() const      Returns the variant as a QPointF if the variant has type() \l     Point or \l PointF; otherwise returns a null QPointF.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toPointF
name|QPointF
name|QVariant
operator|::
name|toPointF
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QPointF
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GEOM_VARIANT
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_comment
comment|/*!     \fn QUrl QVariant::toUrl() const      Returns the variant as a QUrl if the variant has type()     \l Url; otherwise returns an invalid QUrl.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toUrl
name|QUrl
name|QVariant
operator|::
name|toUrl
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QUrl
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn QLocale QVariant::toLocale() const      Returns the variant as a QLocale if the variant has type()     \l Locale; otherwise returns an invalid QLocale.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toLocale
name|QLocale
name|QVariant
operator|::
name|toLocale
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QLocale
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QRegExp QVariant::toRegExp() const     \since 4.1      Returns the variant as a QRegExp if the variant has type() \l     RegExp; otherwise returns an empty QRegExp.      \sa canConvert(), convert() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_function
DECL|function|toRegExp
name|QRegExp
name|QVariant
operator|::
name|toRegExp
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QRegExp
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn QRegularExpression QVariant::toRegularExpression() const     \since 5.0      Returns the variant as a QRegularExpression if the variant has type() \l     QRegularExpression; otherwise returns an empty QRegularExpression.      \sa canConvert(), convert() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
end_ifndef
begin_function
DECL|function|toRegularExpression
name|QRegularExpression
name|QVariant
operator|::
name|toRegularExpression
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QRegularExpression
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn QChar QVariant::toChar() const      Returns the variant as a QChar if the variant has type() \l Char,     \l Int, or \l UInt; otherwise returns an invalid QChar.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toChar
name|QChar
name|QVariant
operator|::
name|toChar
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QChar
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the variant as a QBitArray if the variant has type()     \l BitArray; otherwise returns an empty bit array.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toBitArray
name|QBitArray
name|QVariant
operator|::
name|toBitArray
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QBitArray
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_function
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|qNumVariantToHelper
specifier|inline
name|T
name|qNumVariantToHelper
parameter_list|(
specifier|const
name|QVariant
operator|::
name|Private
modifier|&
name|d
parameter_list|,
specifier|const
name|HandlersManager
modifier|&
name|handlerManager
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|,
specifier|const
name|T
modifier|&
name|val
parameter_list|)
block|{
name|uint
name|t
init|=
name|qMetaTypeId
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|ok
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|type
operator|==
name|t
condition|)
return|return
name|val
return|;
name|T
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|handlerManager
index|[
name|d
operator|.
name|type
index|]
operator|->
name|convert
argument_list|(
operator|&
name|d
argument_list|,
name|t
argument_list|,
operator|&
name|ret
argument_list|,
name|ok
argument_list|)
operator|&&
name|ok
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the variant as an int if the variant has type() \l Int,     \l Bool, \l ByteArray, \l Char, \l Double, \l LongLong, \l     String, \l UInt, or \l ULongLong; otherwise returns 0.      If \a ok is non-null: \c{*}\a{ok} is set to true if the value could be     converted to an int; otherwise \c{*}\a{ok} is set to false.      \b{Warning:} If the value is convertible to a \l LongLong but is too     large to be represented in an int, the resulting arithmetic overflow will     not be reflected in \a ok. A simple workaround is to use QString::toInt().      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toInt
name|int
name|QVariant
operator|::
name|toInt
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
return|return
name|qNumVariantToHelper
argument_list|<
name|int
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|,
name|ok
argument_list|,
name|d
operator|.
name|data
operator|.
name|i
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the variant as an unsigned int if the variant has type()     \l UInt,  \l Bool, \l ByteArray, \l Char, \l Double, \l Int, \l     LongLong, \l String, or \l ULongLong; otherwise returns 0.      If \a ok is non-null: \c{*}\a{ok} is set to true if the value could be     converted to an unsigned int; otherwise \c{*}\a{ok} is set to false.      \b{Warning:} If the value is convertible to a \l ULongLong but is too     large to be represented in an unsigned int, the resulting arithmetic overflow will     not be reflected in \a ok. A simple workaround is to use QString::toUInt().      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toUInt
name|uint
name|QVariant
operator|::
name|toUInt
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
return|return
name|qNumVariantToHelper
argument_list|<
name|uint
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|,
name|ok
argument_list|,
name|d
operator|.
name|data
operator|.
name|u
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the variant as a long long int if the variant has type()     \l LongLong, \l Bool, \l ByteArray, \l Char, \l Double, \l Int,     \l String, \l UInt, or \l ULongLong; otherwise returns 0.      If \a ok is non-null: \c{*}\c{ok} is set to true if the value could be     converted to an int; otherwise \c{*}\c{ok} is set to false.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toLongLong
name|qlonglong
name|QVariant
operator|::
name|toLongLong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
return|return
name|qNumVariantToHelper
argument_list|<
name|qlonglong
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|,
name|ok
argument_list|,
name|d
operator|.
name|data
operator|.
name|ll
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the variant as as an unsigned long long int if the     variant has type() \l ULongLong, \l Bool, \l ByteArray, \l Char,     \l Double, \l Int, \l LongLong, \l String, or \l UInt; otherwise     returns 0.      If \a ok is non-null: \c{*}\a{ok} is set to true if the value could be     converted to an int; otherwise \c{*}\a{ok} is set to false.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toULongLong
name|qulonglong
name|QVariant
operator|::
name|toULongLong
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
return|return
name|qNumVariantToHelper
argument_list|<
name|qulonglong
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|,
name|ok
argument_list|,
name|d
operator|.
name|data
operator|.
name|ull
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the variant as a bool if the variant has type() Bool.      Returns true if the variant has type() \l Bool, \l Char, \l Double,     \l Int, \l LongLong, \l UInt, or \l ULongLong and the value is     non-zero, or if the variant has type \l String or \l ByteArray and     its lower-case content is not empty, "0" or "false"; otherwise     returns false.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toBool
name|bool
name|QVariant
operator|::
name|toBool
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|.
name|type
operator|==
name|Bool
condition|)
return|return
name|d
operator|.
name|data
operator|.
name|b
return|;
name|bool
name|res
init|=
literal|false
decl_stmt|;
name|handlerManager
index|[
name|d
operator|.
name|type
index|]
operator|->
name|convert
argument_list|(
operator|&
name|d
argument_list|,
name|Bool
argument_list|,
operator|&
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the variant as a double if the variant has type() \l     Double, \l QMetaType::Float, \l Bool, \l ByteArray, \l Int, \l LongLong, \l String, \l     UInt, or \l ULongLong; otherwise returns 0.0.      If \a ok is non-null: \c{*}\a{ok} is set to true if the value could be     converted to a double; otherwise \c{*}\a{ok} is set to false.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toDouble
name|double
name|QVariant
operator|::
name|toDouble
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
return|return
name|qNumVariantToHelper
argument_list|<
name|double
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|,
name|ok
argument_list|,
name|d
operator|.
name|data
operator|.
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the variant as a float if the variant has type() \l     Double, \l QMetaType::Float, \l Bool, \l ByteArray, \l Int, \l LongLong, \l String, \l     UInt, or \l ULongLong; otherwise returns 0.0.      \since 4.6      If \a ok is non-null: \c{*}\a{ok} is set to true if the value could be     converted to a double; otherwise \c{*}\a{ok} is set to false.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toFloat
name|float
name|QVariant
operator|::
name|toFloat
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
return|return
name|qNumVariantToHelper
argument_list|<
name|float
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|,
name|ok
argument_list|,
name|d
operator|.
name|data
operator|.
name|f
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the variant as a qreal if the variant has type() \l     Double, \l QMetaType::Float, \l Bool, \l ByteArray, \l Int, \l LongLong, \l String, \l     UInt, or \l ULongLong; otherwise returns 0.0.      \since 4.6      If \a ok is non-null: \c{*}\a{ok} is set to true if the value could be     converted to a double; otherwise \c{*}\a{ok} is set to false.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toReal
name|qreal
name|QVariant
operator|::
name|toReal
parameter_list|(
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
return|return
name|qNumVariantToHelper
argument_list|<
name|qreal
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|,
name|ok
argument_list|,
name|d
operator|.
name|data
operator|.
name|real
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the variant as a QVariantList if the variant has type()     \l List or \l StringList; otherwise returns an empty list.      \sa canConvert(), convert() */
end_comment
begin_function
DECL|function|toList
name|QVariantList
name|QVariant
operator|::
name|toList
parameter_list|()
specifier|const
block|{
return|return
name|qVariantToHelper
argument_list|<
name|QVariantList
argument_list|>
argument_list|(
name|d
argument_list|,
name|handlerManager
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|qCanConvertMatrix
specifier|static
specifier|const
name|quint32
name|qCanConvertMatrix
index|[
name|QVariant
operator|::
name|LastCoreType
operator|+
literal|1
index|]
init|=
block|{
comment|/*Invalid*/
literal|0
block|,
comment|/*Bool*/
literal|1
operator|<<
name|QVariant
operator|::
name|Double
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Int
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|UInt
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|LongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ULongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ByteArray
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|String
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Char
block|,
comment|/*Int*/
literal|1
operator|<<
name|QVariant
operator|::
name|UInt
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|String
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Double
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Bool
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|LongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ULongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Char
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ByteArray
block|,
comment|/*UInt*/
literal|1
operator|<<
name|QVariant
operator|::
name|Int
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|String
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Double
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Bool
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|LongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ULongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Char
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ByteArray
block|,
comment|/*LLong*/
literal|1
operator|<<
name|QVariant
operator|::
name|Int
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|String
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Double
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Bool
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|UInt
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ULongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Char
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ByteArray
block|,
comment|/*ULlong*/
literal|1
operator|<<
name|QVariant
operator|::
name|Int
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|String
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Double
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Bool
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|UInt
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|LongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Char
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ByteArray
block|,
comment|/*double*/
literal|1
operator|<<
name|QVariant
operator|::
name|Int
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|String
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ULongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Bool
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|UInt
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|LongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ByteArray
block|,
comment|/*QChar*/
literal|1
operator|<<
name|QVariant
operator|::
name|Int
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|UInt
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|LongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ULongLong
block|,
comment|/*QMap*/
literal|0
block|,
comment|/*QList*/
literal|1
operator|<<
name|QVariant
operator|::
name|StringList
block|,
comment|/*QString*/
literal|1
operator|<<
name|QVariant
operator|::
name|StringList
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ByteArray
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Int
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|UInt
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Bool
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Double
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Date
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Time
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|DateTime
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|LongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ULongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Char
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Url
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Uuid
block|,
comment|/*QStringList*/
literal|1
operator|<<
name|QVariant
operator|::
name|List
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|String
block|,
comment|/*QByteArray*/
literal|1
operator|<<
name|QVariant
operator|::
name|String
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Int
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|UInt
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Bool
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Double
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|LongLong
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|ULongLong
block|,
comment|/*QBitArray*/
literal|0
block|,
comment|/*QDate*/
literal|1
operator|<<
name|QVariant
operator|::
name|String
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|DateTime
block|,
comment|/*QTime*/
literal|1
operator|<<
name|QVariant
operator|::
name|String
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|DateTime
block|,
comment|/*QDateTime*/
literal|1
operator|<<
name|QVariant
operator|::
name|String
operator||
literal|1
operator|<<
name|QVariant
operator|::
name|Date
block|,
comment|/*QUrl*/
literal|1
operator|<<
name|QVariant
operator|::
name|String
block|,
comment|/*QLocale*/
literal|0
block|,
comment|/*QRect*/
literal|1
operator|<<
name|QVariant
operator|::
name|RectF
block|,
comment|/*QRectF*/
literal|1
operator|<<
name|QVariant
operator|::
name|Rect
block|,
comment|/*QSize*/
literal|1
operator|<<
name|QVariant
operator|::
name|SizeF
block|,
comment|/*QSizeF*/
literal|1
operator|<<
name|QVariant
operator|::
name|Size
block|,
comment|/*QLine*/
literal|1
operator|<<
name|QVariant
operator|::
name|LineF
block|,
comment|/*QLineF*/
literal|1
operator|<<
name|QVariant
operator|::
name|Line
block|,
comment|/*QPoint*/
literal|1
operator|<<
name|QVariant
operator|::
name|PointF
block|,
comment|/*QPointF*/
literal|1
operator|<<
name|QVariant
operator|::
name|Point
block|,
comment|/*QRegExp*/
literal|0
block|,
comment|/*QHash*/
literal|0
block|,
comment|/*QEasingCurve*/
literal|0
block|,
comment|/*QUuid*/
literal|1
operator|<<
name|QVariant
operator|::
name|String
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     Returns true if the variant's type can be cast to the requested     type, \a targetTypeId. Such casting is done automatically when calling the     toInt(), toBool(), ... methods.      The following casts are done automatically:      \table     \header \li Type \li Automatically Cast To     \row \li \l Bool \li \l Char, \l Double, \l Int, \l LongLong, \l String, \l UInt, \l ULongLong     \row \li \l ByteArray \li \l Double, \l Int, \l LongLong, \l String, \l UInt, \l ULongLong     \row \li \l Char \li \l Bool, \l Int, \l UInt, \l LongLong, \l ULongLong     \row \li \l Color \li \l String     \row \li \l Date \li \l DateTime, \l String     \row \li \l DateTime \li \l Date, \l String, \l Time     \row \li \l Double \li \l Bool, \l Int, \l LongLong, \l String, \l UInt, \l ULongLong     \row \li \l Font \li \l String     \row \li \l Int \li \l Bool, \l Char, \l Double, \l LongLong, \l String, \l UInt, \l ULongLong     \row \li \l KeySequence \li \l Int, \l String     \row \li \l List \li \l StringList (if the list's items can be converted to strings)     \row \li \l LongLong \li \l Bool, \l ByteArray, \l Char, \l Double, \l Int, \l String, \l UInt, \l ULongLong     \row \li \l Point \li PointF     \row \li \l Rect \li RectF     \row \li \l String \li \l Bool, \l ByteArray, \l Char, \l Color, \l Date, \l DateTime, \l Double,                          \l Font, \l Int, \l KeySequence, \l LongLong, \l StringList, \l Time, \l UInt,                          \l ULongLong     \row \li \l StringList \li \l List, \l String (if the list contains exactly one item)     \row \li \l Time \li \l String     \row \li \l UInt \li \l Bool, \l Char, \l Double, \l Int, \l LongLong, \l String, \l ULongLong     \row \li \l ULongLong \li \l Bool, \l Char, \l Double, \l Int, \l LongLong, \l String, \l UInt     \endtable      \sa convert() */
end_comment
begin_function
DECL|function|canConvert
name|bool
name|QVariant
operator|::
name|canConvert
parameter_list|(
name|int
name|targetTypeId
parameter_list|)
specifier|const
block|{
comment|// TODO Reimplement this function, currently it works but it is a historical mess.
name|uint
name|currentType
init|=
operator|(
operator|(
name|d
operator|.
name|type
operator|==
name|QMetaType
operator|::
name|Float
operator|)
condition|?
name|QVariant
operator|::
name|Double
else|:
name|d
operator|.
name|type
operator|)
decl_stmt|;
if|if
condition|(
name|currentType
operator|==
name|QMetaType
operator|::
name|SChar
operator|||
name|currentType
operator|==
name|QMetaType
operator|::
name|Char
condition|)
name|currentType
operator|=
name|QMetaType
operator|::
name|UInt
expr_stmt|;
if|if
condition|(
name|targetTypeId
operator|==
name|QMetaType
operator|::
name|SChar
operator|||
name|currentType
operator|==
name|QMetaType
operator|::
name|Char
condition|)
name|targetTypeId
operator|=
name|QMetaType
operator|::
name|UInt
expr_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|targetTypeId
argument_list|)
operator|==
name|uint
argument_list|(
name|QMetaType
operator|::
name|Float
argument_list|)
condition|)
name|targetTypeId
operator|=
name|QVariant
operator|::
name|Double
expr_stmt|;
if|if
condition|(
name|currentType
operator|==
name|uint
argument_list|(
name|targetTypeId
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|targetTypeId
operator|<
literal|0
operator|||
name|targetTypeId
operator|>=
name|QMetaType
operator|::
name|User
condition|)
return|return
literal|false
return|;
comment|// FIXME It should be LastCoreType intead of Uuid
if|if
condition|(
name|currentType
operator|>
name|int
argument_list|(
name|QMetaType
operator|::
name|QUuid
argument_list|)
operator|||
name|targetTypeId
operator|>
name|int
argument_list|(
name|QMetaType
operator|::
name|QUuid
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|uint
argument_list|(
name|targetTypeId
argument_list|)
condition|)
block|{
case|case
name|QVariant
operator|::
name|Int
case|:
if|if
condition|(
name|currentType
operator|==
name|QVariant
operator|::
name|KeySequence
condition|)
return|return
literal|true
return|;
comment|// fall through
case|case
name|QVariant
operator|::
name|UInt
case|:
return|return
name|currentType
operator|==
name|QMetaType
operator|::
name|ULong
operator|||
name|currentType
operator|==
name|QMetaType
operator|::
name|Long
operator|||
name|currentType
operator|==
name|QMetaType
operator|::
name|UShort
operator|||
name|currentType
operator|==
name|QMetaType
operator|::
name|UChar
operator|||
name|currentType
operator|==
name|QMetaType
operator|::
name|Char
operator|||
name|currentType
operator|==
name|QMetaType
operator|::
name|SChar
operator|||
name|currentType
operator|==
name|QMetaType
operator|::
name|Short
return|;
case|case
name|QVariant
operator|::
name|Image
case|:
return|return
name|currentType
operator|==
name|QVariant
operator|::
name|Pixmap
operator|||
name|currentType
operator|==
name|QVariant
operator|::
name|Bitmap
return|;
case|case
name|QVariant
operator|::
name|Pixmap
case|:
return|return
name|currentType
operator|==
name|QVariant
operator|::
name|Image
operator|||
name|currentType
operator|==
name|QVariant
operator|::
name|Bitmap
operator|||
name|currentType
operator|==
name|QVariant
operator|::
name|Brush
return|;
case|case
name|QVariant
operator|::
name|Bitmap
case|:
return|return
name|currentType
operator|==
name|QVariant
operator|::
name|Pixmap
operator|||
name|currentType
operator|==
name|QVariant
operator|::
name|Image
return|;
case|case
name|QVariant
operator|::
name|ByteArray
case|:
return|return
name|currentType
operator|==
name|QVariant
operator|::
name|Color
return|;
case|case
name|QVariant
operator|::
name|String
case|:
return|return
name|currentType
operator|==
name|QVariant
operator|::
name|KeySequence
operator|||
name|currentType
operator|==
name|QVariant
operator|::
name|Font
operator|||
name|currentType
operator|==
name|QVariant
operator|::
name|Color
return|;
case|case
name|QVariant
operator|::
name|KeySequence
case|:
return|return
name|currentType
operator|==
name|QVariant
operator|::
name|String
operator|||
name|currentType
operator|==
name|QVariant
operator|::
name|Int
return|;
case|case
name|QVariant
operator|::
name|Font
case|:
return|return
name|currentType
operator|==
name|QVariant
operator|::
name|String
return|;
case|case
name|QVariant
operator|::
name|Color
case|:
return|return
name|currentType
operator|==
name|QVariant
operator|::
name|String
operator|||
name|currentType
operator|==
name|QVariant
operator|::
name|ByteArray
operator|||
name|currentType
operator|==
name|QVariant
operator|::
name|Brush
return|;
case|case
name|QVariant
operator|::
name|Brush
case|:
return|return
name|currentType
operator|==
name|QVariant
operator|::
name|Color
operator|||
name|currentType
operator|==
name|QVariant
operator|::
name|Pixmap
return|;
case|case
name|QMetaType
operator|::
name|Long
case|:
case|case
name|QMetaType
operator|::
name|Char
case|:
case|case
name|QMetaType
operator|::
name|SChar
case|:
case|case
name|QMetaType
operator|::
name|UChar
case|:
case|case
name|QMetaType
operator|::
name|ULong
case|:
case|case
name|QMetaType
operator|::
name|Short
case|:
case|case
name|QMetaType
operator|::
name|UShort
case|:
return|return
name|qCanConvertMatrix
index|[
name|QVariant
operator|::
name|Int
index|]
operator|&
operator|(
literal|1
operator|<<
name|currentType
operator|)
operator|||
name|currentType
operator|==
name|QVariant
operator|::
name|Int
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|targetTypeId
operator|==
name|String
operator|&&
name|currentType
operator|==
name|StringList
condition|)
return|return
name|v_cast
argument_list|<
name|QStringList
argument_list|>
argument_list|(
operator|&
name|d
argument_list|)
operator|->
name|count
argument_list|()
operator|==
literal|1
return|;
return|return
name|qCanConvertMatrix
index|[
name|targetTypeId
index|]
operator|&
operator|(
literal|1
operator|<<
name|currentType
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Casts the variant to the requested type, \a targetTypeId. If the cast cannot be     done, the variant is cleared. Returns true if the current type of     the variant was successfully cast; otherwise returns false.      \warning For historical reasons, converting a null QVariant results     in a null value of the desired type (e.g., an empty string for     QString) and a result of false.      \sa canConvert(), clear() */
end_comment
begin_function
DECL|function|convert
name|bool
name|QVariant
operator|::
name|convert
parameter_list|(
name|int
name|targetTypeId
parameter_list|)
block|{
if|if
condition|(
name|d
operator|.
name|type
operator|==
name|uint
argument_list|(
name|targetTypeId
argument_list|)
condition|)
return|return
literal|true
return|;
name|QVariant
name|oldValue
init|=
operator|*
name|this
decl_stmt|;
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|oldValue
operator|.
name|canConvert
argument_list|(
name|targetTypeId
argument_list|)
condition|)
return|return
literal|false
return|;
name|create
argument_list|(
name|targetTypeId
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldValue
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
name|bool
name|isOk
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|handlerManager
index|[
name|d
operator|.
name|type
index|]
operator|->
name|convert
argument_list|(
operator|&
name|oldValue
operator|.
name|d
argument_list|,
name|targetTypeId
argument_list|,
name|data
argument_list|()
argument_list|,
operator|&
name|isOk
argument_list|)
condition|)
name|isOk
operator|=
literal|false
expr_stmt|;
name|d
operator|.
name|is_null
operator|=
operator|!
name|isOk
expr_stmt|;
return|return
name|isOk
return|;
block|}
end_function
begin_comment
comment|/*!   \fn bool QVariant::convert(const int type, void *ptr) const   \internal   Created for qvariant_cast() usage */
end_comment
begin_function
DECL|function|convert
name|bool
name|QVariant
operator|::
name|convert
parameter_list|(
specifier|const
name|int
name|type
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|type
operator|<
name|int
argument_list|(
name|QMetaType
operator|::
name|User
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|handlerManager
index|[
name|type
index|]
operator|->
name|convert
argument_list|(
operator|&
name|d
argument_list|,
name|type
argument_list|,
name|ptr
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool operator==(const QVariant&v1, const QVariant&v2)      \relates QVariant      Returns true if \a v1 and \a v2 are equal; otherwise returns false.      \warning This function doesn't support custom types registered     with qRegisterMetaType(). */
end_comment
begin_comment
comment|/*!     \fn bool operator!=(const QVariant&v1, const QVariant&v2)      \relates QVariant      Returns false if \a v1 and \a v2 are equal; otherwise returns true.      \warning This function doesn't support custom types registered     with qRegisterMetaType(). */
end_comment
begin_comment
comment|/*! \fn bool QVariant::operator==(const QVariant&v) const      Compares this QVariant with \a v and returns true if they are     equal; otherwise returns false.      In the case of custom types, their equalness operators are not called.     Instead the values' addresses are compared. */
end_comment
begin_comment
comment|/*!     \fn bool QVariant::operator!=(const QVariant&v) const      Compares this QVariant with \a v and returns true if they are not     equal; otherwise returns false.      \warning This function doesn't support custom types registered     with qRegisterMetaType(). */
end_comment
begin_function
DECL|function|qIsNumericType
specifier|static
name|bool
name|qIsNumericType
parameter_list|(
name|uint
name|tp
parameter_list|)
block|{
return|return
operator|(
name|tp
operator|>=
name|QVariant
operator|::
name|Bool
operator|&&
name|tp
operator|<=
name|QVariant
operator|::
name|Double
operator|)
operator|||
operator|(
name|tp
operator|>=
name|QMetaType
operator|::
name|Long
operator|&&
name|tp
operator|<=
name|QMetaType
operator|::
name|Float
operator|)
return|;
block|}
end_function
begin_function
DECL|function|qIsFloatingPoint
specifier|static
name|bool
name|qIsFloatingPoint
parameter_list|(
name|uint
name|tp
parameter_list|)
block|{
return|return
name|tp
operator|==
name|QVariant
operator|::
name|Double
operator|||
name|tp
operator|==
name|QMetaType
operator|::
name|Float
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|cmp
name|bool
name|QVariant
operator|::
name|cmp
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|v
parameter_list|)
specifier|const
block|{
name|QVariant
name|v2
init|=
name|v
decl_stmt|;
if|if
condition|(
name|d
operator|.
name|type
operator|!=
name|v2
operator|.
name|d
operator|.
name|type
condition|)
block|{
if|if
condition|(
name|qIsNumericType
argument_list|(
name|d
operator|.
name|type
argument_list|)
operator|&&
name|qIsNumericType
argument_list|(
name|v
operator|.
name|d
operator|.
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|qIsFloatingPoint
argument_list|(
name|d
operator|.
name|type
argument_list|)
operator|||
name|qIsFloatingPoint
argument_list|(
name|v
operator|.
name|d
operator|.
name|type
argument_list|)
condition|)
return|return
name|qFuzzyCompare
argument_list|(
name|toReal
argument_list|()
argument_list|,
name|v
operator|.
name|toReal
argument_list|()
argument_list|)
return|;
else|else
return|return
name|toLongLong
argument_list|()
operator|==
name|v
operator|.
name|toLongLong
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|v2
operator|.
name|canConvert
argument_list|(
name|d
operator|.
name|type
argument_list|)
operator|||
operator|!
name|v2
operator|.
name|convert
argument_list|(
name|d
operator|.
name|type
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
name|handlerManager
index|[
name|d
operator|.
name|type
index|]
operator|->
name|compare
argument_list|(
operator|&
name|d
argument_list|,
operator|&
name|v2
operator|.
name|d
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal  */
end_comment
begin_function
DECL|function|constData
specifier|const
name|void
modifier|*
name|QVariant
operator|::
name|constData
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|.
name|is_shared
condition|?
name|d
operator|.
name|data
operator|.
name|shared
operator|->
name|ptr
else|:
cast|reinterpret_cast
argument_list|<
specifier|const
name|void
operator|*
argument_list|>
argument_list|(
operator|&
name|d
operator|.
name|data
operator|.
name|ptr
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn const void* QVariant::data() const      \internal */
end_comment
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|data
name|void
modifier|*
name|QVariant
operator|::
name|data
parameter_list|()
block|{
name|detach
argument_list|()
expr_stmt|;
return|return
cast|const_cast
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|constData
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns true if this is a NULL variant, false otherwise. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QVariant
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
name|handlerManager
index|[
name|d
operator|.
name|type
index|]
operator|->
name|isNull
argument_list|(
operator|&
name|d
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|v
parameter_list|)
block|{
specifier|const
name|uint
name|typeId
init|=
name|v
operator|.
name|d
operator|.
name|type
decl_stmt|;
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QVariant("
expr_stmt|;
if|if
condition|(
name|typeId
operator|!=
name|QMetaType
operator|::
name|UnknownType
condition|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
name|QMetaType
operator|::
name|typeName
argument_list|(
name|typeId
argument_list|)
operator|<<
literal|", "
expr_stmt|;
name|handlerManager
index|[
name|typeId
index|]
operator|->
name|debugStream
argument_list|(
name|dbg
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"Invalid"
expr_stmt|;
block|}
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QVariant
operator|::
name|Type
name|p
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QVariant::"
operator|<<
operator|(
name|int
argument_list|(
name|p
argument_list|)
operator|!=
name|int
argument_list|(
name|QMetaType
operator|::
name|UnknownType
argument_list|)
condition|?
name|QMetaType
operator|::
name|typeName
argument_list|(
name|p
argument_list|)
else|:
literal|"Invalid"
operator|)
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \fn void QVariant::setValue(const T&value)      Stores a copy of \a value. If \c{T} is a type that QVariant     doesn't support, QMetaType is used to store the value. A compile     error will occur if QMetaType doesn't handle the type.      Example:      \snippet code/src_corelib_kernel_qvariant.cpp 4      \sa value(), fromValue(), canConvert()  */
end_comment
begin_comment
comment|/*! \fn T QVariant::value() const      Returns the stored value converted to the template type \c{T}.     Call canConvert() to find out whether a type can be converted.     If the value cannot be converted, \l{default-constructed value}     will be returned.      If the type \c{T} is supported by QVariant, this function behaves     exactly as toString(), toInt() etc.      Example:      \snippet code/src_corelib_kernel_qvariant.cpp 5      \sa setValue(), fromValue(), canConvert() */
end_comment
begin_comment
comment|/*! \fn bool QVariant::canConvert() const      Returns true if the variant can be converted to the template type \c{T},     otherwise false.      Example:      \snippet code/src_corelib_kernel_qvariant.cpp 6      \sa convert() */
end_comment
begin_comment
comment|/*! \fn static QVariant QVariant::fromValue(const T&value)      Returns a QVariant containing a copy of \a value. Behaves     exactly like setValue() otherwise.      Example:      \snippet code/src_corelib_kernel_qvariant.cpp 7      \note If you are working with custom types, you should use     the Q_DECLARE_METATYPE() macro to register your custom type.      \sa setValue(), value() */
end_comment
begin_comment
comment|/*!     \fn QVariant qVariantFromValue(const T&value)     \relates QVariant     \obsolete      Returns a variant containing a copy of the given \a value     with template type \c{T}.      This function is equivalent to QVariant::fromValue(\a value).      \note This function was provided as a workaround for MSVC 6     which did not support member template functions. It is advised     to use the other form in new code.      For example, a QObject pointer can be stored in a variant with the     following code:      \snippet code/src_corelib_kernel_qvariant.cpp 8      \sa QVariant::fromValue() */
end_comment
begin_comment
comment|/*! \fn void qVariantSetValue(QVariant&variant, const T&value)     \relates QVariant     \obsolete      Sets the contents of the given \a variant to a copy of the     \a value with the specified template type \c{T}.      This function is equivalent to QVariant::setValue(\a value).      \note This function was provided as a workaround for MSVC 6     which did not support member template functions. It is advised     to use the other form in new code.      \sa QVariant::setValue() */
end_comment
begin_comment
comment|/*!     \fn T qvariant_cast(const QVariant&value)     \relates QVariant      Returns the given \a value converted to the template type \c{T}.      This function is equivalent to QVariant::value().      \sa QVariant::value() */
end_comment
begin_comment
comment|/*! \fn T qVariantValue(const QVariant&value)     \relates QVariant     \obsolete      Returns the given \a value converted to the template type \c{T}.      This function is equivalent to     \l{QVariant::value()}{QVariant::value}<T>(\a value).      \note This function was provided as a workaround for MSVC 6     which did not support member template functions. It is advised     to use the other form in new code.      \sa QVariant::value(), qvariant_cast() */
end_comment
begin_comment
comment|/*! \fn bool qVariantCanConvert(const QVariant&value)     \relates QVariant     \obsolete      Returns true if the given \a value can be converted to the     template type specified; otherwise returns false.      This function is equivalent to QVariant::canConvert(\a value).      \note This function was provided as a workaround for MSVC 6     which did not support member template functions. It is advised     to use the other form in new code.      \sa QVariant::canConvert() */
end_comment
begin_comment
comment|/*!     \typedef QVariantList     \relates QVariant      Synonym for QList<QVariant>. */
end_comment
begin_comment
comment|/*!     \typedef QVariantMap     \relates QVariant      Synonym for QMap<QString, QVariant>. */
end_comment
begin_comment
comment|/*!     \typedef QVariantHash     \relates QVariant     \since 4.5      Synonym for QHash<QString, QVariant>. */
end_comment
begin_comment
comment|/*!     \typedef QVariant::DataPtr     \internal */
end_comment
begin_comment
comment|/*!     \fn DataPtr&QVariant::data_ptr()     \internal */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
