begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Copyright (C) 2014 Olivier Goffart<ogoffart@woboq.com> ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia. For licensing terms and ** conditions see http://qt.digia.com/licensing. For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights. These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qmetaobject.h"
end_include
begin_include
include|#
directive|include
file|"qmetatype.h"
end_include
begin_include
include|#
directive|include
file|"qobject.h"
end_include
begin_include
include|#
directive|include
file|"qmetaobject_p.h"
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<qcoreevent.h>
end_include
begin_include
include|#
directive|include
file|<qdatastream.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qthread.h>
end_include
begin_include
include|#
directive|include
file|<qvariant.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qsemaphore.h>
end_include
begin_include
include|#
directive|include
file|"private/qobject_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qmetaobject_p.h"
end_include
begin_comment
comment|// for normalizeTypeInternal
end_comment
begin_include
include|#
directive|include
file|"private/qmetaobject_moc_p.h"
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QMetaObject     \inmodule QtCore      \brief The QMetaObject class contains meta-information about Qt     objects.      \ingroup objectmodel      The Qt \l{Meta-Object System} in Qt is responsible for the     signals and slots inter-object communication mechanism, runtime     type information, and the Qt property system. A single     QMetaObject instance is created for each QObject subclass that is     used in an application, and this instance stores all the     meta-information for the QObject subclass. This object is     available as QObject::metaObject().      This class is not normally required for application programming,     but it is useful if you write meta-applications, such as scripting     engines or GUI builders.      The functions you are most likely to find useful are these:     \list     \li className() returns the name of a class.     \li superClass() returns the superclass's meta-object.     \li method() and methodCount() provide information        about a class's meta-methods (signals, slots and other        \l{Q_INVOKABLE}{invokable} member functions).     \li enumerator() and enumeratorCount() and provide information about        a class's enumerators.     \li propertyCount() and property() provide information about a        class's properties.     \li constructor() and constructorCount() provide information        about a class's meta-constructors.     \endlist      The index functions indexOfConstructor(), indexOfMethod(),     indexOfEnumerator(), and indexOfProperty() map names of constructors,     member functions, enumerators, or properties to indexes in the     meta-object. For example, Qt uses indexOfMethod() internally when you     connect a signal to a slot.      Classes can also have a list of \e{name}--\e{value} pairs of     additional class information, stored in QMetaClassInfo objects.     The number of pairs is returned by classInfoCount(), single pairs     are returned by classInfo(), and you can search for pairs with     indexOfClassInfo().      \sa QMetaClassInfo, QMetaEnum, QMetaMethod, QMetaProperty, QMetaType,         {Meta-Object System} */
comment|/*!     \enum QMetaObject::Call      \internal      \value InvokeSlot     \value EmitSignal     \value ReadProperty     \value WriteProperty     \value ResetProperty     \value QueryPropertyDesignable     \value QueryPropertyScriptable     \value QueryPropertyStored     \value QueryPropertyEditable     \value QueryPropertyUser     \value CreateInstance */
comment|/*!     \enum QMetaMethod::Access      This enum describes the access level of a method, following the conventions used in C++.      \value Private     \value Protected     \value Public */
DECL|function|priv
specifier|static
specifier|inline
specifier|const
name|QMetaObjectPrivate
modifier|*
name|priv
parameter_list|(
specifier|const
name|uint
modifier|*
name|data
parameter_list|)
block|{
return|return
cast|reinterpret_cast
argument_list|<
specifier|const
name|QMetaObjectPrivate
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|stringData
specifier|static
specifier|inline
specifier|const
name|QByteArray
name|stringData
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|mo
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mo
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
specifier|const
name|QByteArrayDataPtr
name|data
init|=
block|{
expr|const_cast
operator|<
name|QByteArrayData
operator|*
operator|>
operator|(
operator|&
name|mo
operator|->
name|d
operator|.
name|stringdata
index|[
name|index
index|]
operator|)
block|}
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|data
operator|.
name|ptr
operator|->
name|ref
operator|.
name|isStatic
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
operator|.
name|ptr
operator|->
name|alloc
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
operator|.
name|ptr
operator|->
name|capacityReserved
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
operator|.
name|ptr
operator|->
name|size
operator|>=
literal|0
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_function
DECL|function|rawStringData
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|rawStringData
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|mo
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
name|stringData
argument_list|(
name|mo
argument_list|,
name|index
argument_list|)
operator|.
name|data
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|typeNameFromTypeInfo
specifier|static
specifier|inline
name|QByteArray
name|typeNameFromTypeInfo
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|mo
parameter_list|,
name|uint
name|typeInfo
parameter_list|)
block|{
if|if
condition|(
name|typeInfo
operator|&
name|IsUnresolvedType
condition|)
block|{
return|return
name|stringData
argument_list|(
name|mo
argument_list|,
name|typeInfo
operator|&
name|TypeNameIndexMask
argument_list|)
return|;
block|}
else|else
block|{
comment|// ### Use the QMetaType::typeName() that returns QByteArray
specifier|const
name|char
modifier|*
name|t
init|=
name|QMetaType
operator|::
name|typeName
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
return|return
name|QByteArray
operator|::
name|fromRawData
argument_list|(
name|t
argument_list|,
name|qstrlen
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|rawTypeNameFromTypeInfo
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|rawTypeNameFromTypeInfo
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|mo
parameter_list|,
name|uint
name|typeInfo
parameter_list|)
block|{
return|return
name|typeNameFromTypeInfo
argument_list|(
name|mo
argument_list|,
name|typeInfo
argument_list|)
operator|.
name|constData
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|typeFromTypeInfo
specifier|static
specifier|inline
name|int
name|typeFromTypeInfo
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|mo
parameter_list|,
name|uint
name|typeInfo
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|typeInfo
operator|&
name|IsUnresolvedType
operator|)
condition|)
return|return
name|typeInfo
return|;
return|return
name|QMetaType
operator|::
name|type
argument_list|(
name|stringData
argument_list|(
name|mo
argument_list|,
name|typeInfo
operator|&
name|TypeNameIndexMask
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_class
DECL|class|QMetaMethodPrivate
class|class
name|QMetaMethodPrivate
super|:
specifier|public
name|QMetaMethod
block|{
public|public:
DECL|function|get
specifier|static
specifier|const
name|QMetaMethodPrivate
modifier|*
name|get
parameter_list|(
specifier|const
name|QMetaMethod
modifier|*
name|q
parameter_list|)
block|{
return|return
cast|static_cast
argument_list|<
specifier|const
name|QMetaMethodPrivate
operator|*
argument_list|>
argument_list|(
name|q
argument_list|)
return|;
block|}
specifier|inline
name|QByteArray
name|signature
parameter_list|()
specifier|const
function_decl|;
specifier|inline
name|QByteArray
name|name
parameter_list|()
specifier|const
function_decl|;
specifier|inline
name|int
name|typesDataIndex
parameter_list|()
specifier|const
function_decl|;
specifier|inline
specifier|const
name|char
modifier|*
name|rawReturnTypeName
parameter_list|()
specifier|const
function_decl|;
specifier|inline
name|int
name|returnType
parameter_list|()
specifier|const
function_decl|;
specifier|inline
name|int
name|parameterCount
parameter_list|()
specifier|const
function_decl|;
specifier|inline
name|int
name|parametersDataIndex
parameter_list|()
specifier|const
function_decl|;
specifier|inline
name|uint
name|parameterTypeInfo
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
function_decl|;
specifier|inline
name|int
name|parameterType
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
function_decl|;
specifier|inline
name|void
name|getParameterTypes
parameter_list|(
name|int
modifier|*
name|types
parameter_list|)
specifier|const
function_decl|;
specifier|inline
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|parameterTypes
parameter_list|()
specifier|const
function_decl|;
specifier|inline
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|parameterNames
parameter_list|()
specifier|const
function_decl|;
specifier|inline
name|QByteArray
name|tag
parameter_list|()
specifier|const
function_decl|;
specifier|inline
name|int
name|ownMethodIndex
parameter_list|()
specifier|const
function_decl|;
private|private:
name|QMetaMethodPrivate
parameter_list|()
constructor_decl|;
block|}
class|;
end_class
begin_comment
comment|/*!     \since 4.5      Constructs a new instance of this class. You can pass up to ten arguments     (\a val0, \a val1, \a val2, \a val3, \a val4, \a val5, \a val6, \a val7,     \a val8, and \a val9) to the constructor. Returns the new object, or 0 if     no suitable constructor is available.      Note that only constructors that are declared with the Q_INVOKABLE     modifier are made available through the meta-object system.      \sa Q_ARG(), constructor() */
end_comment
begin_function
DECL|function|newInstance
name|QObject
modifier|*
name|QMetaObject
operator|::
name|newInstance
parameter_list|(
name|QGenericArgument
name|val0
parameter_list|,
name|QGenericArgument
name|val1
parameter_list|,
name|QGenericArgument
name|val2
parameter_list|,
name|QGenericArgument
name|val3
parameter_list|,
name|QGenericArgument
name|val4
parameter_list|,
name|QGenericArgument
name|val5
parameter_list|,
name|QGenericArgument
name|val6
parameter_list|,
name|QGenericArgument
name|val7
parameter_list|,
name|QGenericArgument
name|val8
parameter_list|,
name|QGenericArgument
name|val9
parameter_list|)
specifier|const
block|{
name|QByteArray
name|constructorName
init|=
name|className
argument_list|()
decl_stmt|;
block|{
name|int
name|idx
init|=
name|constructorName
operator|.
name|lastIndexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
name|constructorName
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// remove qualified part
block|}
name|QVarLengthArray
argument_list|<
name|char
argument_list|,
literal|512
argument_list|>
name|sig
decl_stmt|;
name|sig
operator|.
name|append
argument_list|(
name|constructorName
operator|.
name|constData
argument_list|()
argument_list|,
name|constructorName
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|sig
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
enum|enum
block|{
name|MaximumParamCount
init|=
literal|10
block|}
enum|;
specifier|const
name|char
modifier|*
name|typeNames
index|[]
init|=
block|{
name|val0
operator|.
name|name
argument_list|()
block|,
name|val1
operator|.
name|name
argument_list|()
block|,
name|val2
operator|.
name|name
argument_list|()
block|,
name|val3
operator|.
name|name
argument_list|()
block|,
name|val4
operator|.
name|name
argument_list|()
block|,
name|val5
operator|.
name|name
argument_list|()
block|,
name|val6
operator|.
name|name
argument_list|()
block|,
name|val7
operator|.
name|name
argument_list|()
block|,
name|val8
operator|.
name|name
argument_list|()
block|,
name|val9
operator|.
name|name
argument_list|()
block|}
decl_stmt|;
name|int
name|paramCount
decl_stmt|;
for|for
control|(
name|paramCount
operator|=
literal|0
init|;
name|paramCount
operator|<
name|MaximumParamCount
condition|;
operator|++
name|paramCount
control|)
block|{
name|int
name|len
init|=
name|qstrlen
argument_list|(
name|typeNames
index|[
name|paramCount
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
break|break;
name|sig
operator|.
name|append
argument_list|(
name|typeNames
index|[
name|paramCount
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sig
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|paramCount
operator|==
literal|0
condition|)
name|sig
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
comment|// no parameters
else|else
name|sig
index|[
name|sig
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
name|sig
operator|.
name|append
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|int
name|idx
init|=
name|indexOfConstructor
argument_list|(
name|sig
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|QByteArray
name|norm
init|=
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|sig
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|idx
operator|=
name|indexOfConstructor
argument_list|(
name|norm
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|QObject
modifier|*
name|returnValue
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|param
index|[]
init|=
block|{
operator|&
name|returnValue
block|,
name|val0
operator|.
name|data
argument_list|()
block|,
name|val1
operator|.
name|data
argument_list|()
block|,
name|val2
operator|.
name|data
argument_list|()
block|,
name|val3
operator|.
name|data
argument_list|()
block|,
name|val4
operator|.
name|data
argument_list|()
block|,
name|val5
operator|.
name|data
argument_list|()
block|,
name|val6
operator|.
name|data
argument_list|()
block|,
name|val7
operator|.
name|data
argument_list|()
block|,
name|val8
operator|.
name|data
argument_list|()
block|,
name|val9
operator|.
name|data
argument_list|()
block|}
decl_stmt|;
if|if
condition|(
name|static_metacall
argument_list|(
name|CreateInstance
argument_list|,
name|idx
argument_list|,
name|param
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|returnValue
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|static_metacall
name|int
name|QMetaObject
operator|::
name|static_metacall
parameter_list|(
name|Call
name|cl
parameter_list|,
name|int
name|idx
parameter_list|,
name|void
modifier|*
modifier|*
name|argv
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|.
name|static_metacall
condition|)
return|return
literal|0
return|;
name|d
operator|.
name|static_metacall
argument_list|(
literal|0
argument_list|,
name|cl
argument_list|,
name|idx
argument_list|,
name|argv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|metacall
name|int
name|QMetaObject
operator|::
name|metacall
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|,
name|Call
name|cl
parameter_list|,
name|int
name|idx
parameter_list|,
name|void
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|object
operator|->
name|d_ptr
operator|->
name|metaObject
condition|)
return|return
name|object
operator|->
name|d_ptr
operator|->
name|metaObject
operator|->
name|metaCall
argument_list|(
name|object
argument_list|,
name|cl
argument_list|,
name|idx
argument_list|,
name|argv
argument_list|)
return|;
else|else
return|return
name|object
operator|->
name|qt_metacall
argument_list|(
name|cl
argument_list|,
name|idx
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|objectClassName
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|objectClassName
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|m
parameter_list|)
block|{
return|return
name|rawStringData
argument_list|(
name|m
argument_list|,
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|className
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the class name.      \sa superClass() */
end_comment
begin_function
DECL|function|className
specifier|const
name|char
modifier|*
name|QMetaObject
operator|::
name|className
parameter_list|()
specifier|const
block|{
return|return
name|objectClassName
argument_list|(
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QMetaObject *QMetaObject::superClass() const      Returns the meta-object of the superclass, or 0 if there is no     such object.      \sa className() */
end_comment
begin_comment
comment|/*!     \internal      Returns \a obj if object \a obj inherits from this     meta-object; otherwise returns 0. */
end_comment
begin_function
DECL|function|cast
name|QObject
modifier|*
name|QMetaObject
operator|::
name|cast
parameter_list|(
name|QObject
modifier|*
name|obj
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|obj
condition|)
block|{
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|obj
operator|->
name|metaObject
argument_list|()
decl_stmt|;
do|do
block|{
if|if
condition|(
name|m
operator|==
name|this
condition|)
return|return
name|obj
return|;
block|}
do|while
condition|(
operator|(
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
operator|)
condition|)
do|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns \a obj if object \a obj inherits from this     meta-object; otherwise returns 0. */
end_comment
begin_function
DECL|function|cast
specifier|const
name|QObject
modifier|*
name|QMetaObject
operator|::
name|cast
parameter_list|(
specifier|const
name|QObject
modifier|*
name|obj
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|obj
condition|)
block|{
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|obj
operator|->
name|metaObject
argument_list|()
decl_stmt|;
do|do
block|{
if|if
condition|(
name|m
operator|==
name|this
condition|)
return|return
name|obj
return|;
block|}
do|while
condition|(
operator|(
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
operator|)
condition|)
do|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TRANSLATION
end_ifndef
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|tr
name|QString
name|QMetaObject
operator|::
name|tr
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|c
parameter_list|,
name|int
name|n
parameter_list|)
specifier|const
block|{
return|return
name|QCoreApplication
operator|::
name|translate
argument_list|(
name|objectClassName
argument_list|(
name|this
argument_list|)
argument_list|,
name|s
argument_list|,
name|c
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TRANSLATION
end_comment
begin_comment
comment|/*!     Returns the method offset for this class; i.e. the index position     of this class's first member function.      The offset is the sum of all the methods in the class's     superclasses (which is always positive since QObject has the     deleteLater() slot and a destroyed() signal).      \sa method(), methodCount(), indexOfMethod() */
end_comment
begin_function
DECL|function|methodOffset
name|int
name|QMetaObject
operator|::
name|methodOffset
parameter_list|()
specifier|const
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|d
operator|.
name|superdata
decl_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|offset
operator|+=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodCount
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the enumerator offset for this class; i.e. the index     position of this class's first enumerator.      If the class has no superclasses with enumerators, the offset is     0; otherwise the offset is the sum of all the enumerators in the     class's superclasses.      \sa enumerator(), enumeratorCount(), indexOfEnumerator() */
end_comment
begin_function
DECL|function|enumeratorOffset
name|int
name|QMetaObject
operator|::
name|enumeratorOffset
parameter_list|()
specifier|const
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|d
operator|.
name|superdata
decl_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|offset
operator|+=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|enumeratorCount
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the property offset for this class; i.e. the index     position of this class's first property.      The offset is the sum of all the properties in the class's     superclasses (which is always positive since QObject has the     name() property).      \sa property(), propertyCount(), indexOfProperty() */
end_comment
begin_function
DECL|function|propertyOffset
name|int
name|QMetaObject
operator|::
name|propertyOffset
parameter_list|()
specifier|const
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|d
operator|.
name|superdata
decl_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|offset
operator|+=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyCount
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the class information offset for this class; i.e. the     index position of this class's first class information item.      If the class has no superclasses with class information, the     offset is 0; otherwise the offset is the sum of all the class     information items in the class's superclasses.      \sa classInfo(), classInfoCount(), indexOfClassInfo() */
end_comment
begin_function
DECL|function|classInfoOffset
name|int
name|QMetaObject
operator|::
name|classInfoOffset
parameter_list|()
specifier|const
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|d
operator|.
name|superdata
decl_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|offset
operator|+=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|classInfoCount
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the number of constructors in this class.      \sa constructor(), indexOfConstructor() */
end_comment
begin_function
DECL|function|constructorCount
name|int
name|QMetaObject
operator|::
name|constructorCount
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|2
argument_list|)
expr_stmt|;
return|return
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|constructorCount
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of methods in this class, including the number of     methods provided by each base class. These include signals and slots     as well as normal member functions.      Use code like the following to obtain a QStringList containing the methods     specific to a given class:      \snippet code/src_corelib_kernel_qmetaobject.cpp methodCount      \sa method(), methodOffset(), indexOfMethod() */
end_comment
begin_function
DECL|function|methodCount
name|int
name|QMetaObject
operator|::
name|methodCount
parameter_list|()
specifier|const
block|{
name|int
name|n
init|=
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodCount
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|d
operator|.
name|superdata
decl_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|n
operator|+=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodCount
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of enumerators in this class.      \sa enumerator(), enumeratorOffset(), indexOfEnumerator() */
end_comment
begin_function
DECL|function|enumeratorCount
name|int
name|QMetaObject
operator|::
name|enumeratorCount
parameter_list|()
specifier|const
block|{
name|int
name|n
init|=
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|enumeratorCount
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|d
operator|.
name|superdata
decl_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|n
operator|+=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|enumeratorCount
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of properties in this class, including the number of     properties provided by each base class.      Use code like the following to obtain a QStringList containing the properties     specific to a given class:      \snippet code/src_corelib_kernel_qmetaobject.cpp propertyCount      \sa property(), propertyOffset(), indexOfProperty() */
end_comment
begin_function
DECL|function|propertyCount
name|int
name|QMetaObject
operator|::
name|propertyCount
parameter_list|()
specifier|const
block|{
name|int
name|n
init|=
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyCount
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|d
operator|.
name|superdata
decl_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|n
operator|+=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyCount
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of items of class information in this class.      \sa classInfo(), classInfoOffset(), indexOfClassInfo() */
end_comment
begin_function
DECL|function|classInfoCount
name|int
name|QMetaObject
operator|::
name|classInfoCount
parameter_list|()
specifier|const
block|{
name|int
name|n
init|=
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|classInfoCount
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|d
operator|.
name|superdata
decl_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|n
operator|+=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|classInfoCount
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|// Returns \c true if the method defined by the given meta-object&handle
end_comment
begin_comment
comment|// matches the given name, argument count and argument types, otherwise
end_comment
begin_comment
comment|// returns \c false.
end_comment
begin_function
DECL|function|methodMatch
specifier|static
name|bool
name|methodMatch
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|m
parameter_list|,
name|int
name|handle
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|QArgumentType
modifier|*
name|types
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|int
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|1
index|]
argument_list|)
operator|!=
name|argc
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|stringData
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|d
operator|.
name|data
index|[
name|handle
index|]
argument_list|)
operator|!=
name|name
condition|)
return|return
literal|false
return|;
name|int
name|paramsIndex
init|=
name|m
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|uint
name|typeInfo
init|=
name|m
operator|->
name|d
operator|.
name|data
index|[
name|paramsIndex
operator|+
name|i
index|]
decl_stmt|;
if|if
condition|(
name|types
index|[
name|i
index|]
operator|.
name|type
argument_list|()
condition|)
block|{
if|if
condition|(
name|types
index|[
name|i
index|]
operator|.
name|type
argument_list|()
operator|!=
name|typeFromTypeInfo
argument_list|(
name|m
argument_list|,
name|typeInfo
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|types
index|[
name|i
index|]
operator|.
name|name
argument_list|()
operator|!=
name|typeNameFromTypeInfo
argument_list|(
name|m
argument_list|,
name|typeInfo
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/** * \internal * helper function for indexOf{Method,Slot,Signal}, returns the relative index of the method within * the baseObject * \a MethodType might be MethodSignal or MethodSlot, or 0 to match everything. */
end_comment
begin_function
template|template
parameter_list|<
name|int
name|MethodType
parameter_list|>
DECL|function|indexOfMethodRelative
specifier|static
specifier|inline
name|int
name|indexOfMethodRelative
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
modifier|*
name|baseObject
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|QArgumentType
modifier|*
name|types
parameter_list|)
block|{
for|for
control|(
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
operator|*
name|baseObject
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
control|)
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|int
name|i
init|=
operator|(
name|MethodType
operator|==
name|MethodSignal
operator|)
condition|?
operator|(
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|signalCount
operator|-
literal|1
operator|)
else|:
operator|(
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodCount
operator|-
literal|1
operator|)
decl_stmt|;
specifier|const
name|int
name|end
init|=
operator|(
name|MethodType
operator|==
name|MethodSlot
operator|)
condition|?
operator|(
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|signalCount
operator|)
else|:
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|>=
name|end
condition|;
operator|--
name|i
control|)
block|{
name|int
name|handle
init|=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodData
operator|+
literal|5
operator|*
name|i
decl_stmt|;
if|if
condition|(
name|methodMatch
argument_list|(
name|m
argument_list|,
name|handle
argument_list|,
name|name
argument_list|,
name|argc
argument_list|,
name|types
argument_list|)
condition|)
block|{
operator|*
name|baseObject
operator|=
name|m
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Finds \a constructor and returns its index; otherwise returns -1.      Note that the \a constructor has to be in normalized form, as returned     by normalizedSignature().      \sa constructor(), constructorCount(), normalizedSignature() */
end_comment
begin_function
DECL|function|indexOfConstructor
name|int
name|QMetaObject
operator|::
name|indexOfConstructor
parameter_list|(
specifier|const
name|char
modifier|*
name|constructor
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|QArgumentTypeArray
name|types
decl_stmt|;
name|QByteArray
name|name
init|=
name|QMetaObjectPrivate
operator|::
name|decodeMethodSignature
argument_list|(
name|constructor
argument_list|,
name|types
argument_list|)
decl_stmt|;
return|return
name|QMetaObjectPrivate
operator|::
name|indexOfConstructor
argument_list|(
name|this
argument_list|,
name|name
argument_list|,
name|types
operator|.
name|size
argument_list|()
argument_list|,
name|types
operator|.
name|constData
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Finds \a method and returns its index; otherwise returns -1.      Note that the \a method has to be in normalized form, as returned     by normalizedSignature().      \sa method(), methodCount(), methodOffset(), normalizedSignature() */
end_comment
begin_function
DECL|function|indexOfMethod
name|int
name|QMetaObject
operator|::
name|indexOfMethod
parameter_list|(
specifier|const
name|char
modifier|*
name|method
parameter_list|)
specifier|const
block|{
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|this
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|QArgumentTypeArray
name|types
decl_stmt|;
name|QByteArray
name|name
init|=
name|QMetaObjectPrivate
operator|::
name|decodeMethodSignature
argument_list|(
name|method
argument_list|,
name|types
argument_list|)
decl_stmt|;
name|i
operator|=
name|indexOfMethodRelative
argument_list|<
literal|0
argument_list|>
argument_list|(
operator|&
name|m
argument_list|,
name|name
argument_list|,
name|types
operator|.
name|size
argument_list|()
argument_list|,
name|types
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|i
operator|+=
name|m
operator|->
name|methodOffset
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_comment
comment|// Parses a string of comma-separated types into QArgumentTypes.
end_comment
begin_comment
comment|// No normalization of the type names is performed.
end_comment
begin_function
DECL|function|argumentTypesFromString
specifier|static
name|void
name|argumentTypesFromString
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|QArgumentTypeArray
modifier|&
name|types
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|str
operator|<=
name|end
argument_list|)
expr_stmt|;
while|while
condition|(
name|str
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|!
name|types
operator|.
name|isEmpty
argument_list|()
condition|)
operator|++
name|str
expr_stmt|;
comment|// Skip comma
specifier|const
name|char
modifier|*
name|begin
init|=
name|str
decl_stmt|;
name|int
name|level
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|str
operator|!=
name|end
operator|&&
operator|(
name|level
operator|>
literal|0
operator|||
operator|*
name|str
operator|!=
literal|','
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'<'
condition|)
operator|++
name|level
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'>'
condition|)
operator|--
name|level
expr_stmt|;
operator|++
name|str
expr_stmt|;
block|}
name|types
operator|+=
name|QArgumentType
argument_list|(
name|QByteArray
argument_list|(
name|begin
argument_list|,
name|str
operator|-
name|begin
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Given a method \a signature (e.g. "foo(int,double)"), this function
end_comment
begin_comment
comment|// populates the argument \a types array and returns the method name.
end_comment
begin_function
DECL|function|decodeMethodSignature
name|QByteArray
name|QMetaObjectPrivate
operator|::
name|decodeMethodSignature
parameter_list|(
specifier|const
name|char
modifier|*
name|signature
parameter_list|,
name|QArgumentTypeArray
modifier|&
name|types
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|signature
operator|!=
literal|0
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|lparens
init|=
name|strchr
argument_list|(
name|signature
argument_list|,
literal|'('
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lparens
condition|)
return|return
name|QByteArray
argument_list|()
return|;
specifier|const
name|char
modifier|*
name|rparens
init|=
name|strrchr
argument_list|(
name|lparens
operator|+
literal|1
argument_list|,
literal|')'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rparens
operator|||
operator|*
operator|(
name|rparens
operator|+
literal|1
operator|)
condition|)
return|return
name|QByteArray
argument_list|()
return|;
name|int
name|nameLength
init|=
name|lparens
operator|-
name|signature
decl_stmt|;
name|argumentTypesFromString
argument_list|(
name|lparens
operator|+
literal|1
argument_list|,
name|rparens
argument_list|,
name|types
argument_list|)
expr_stmt|;
return|return
name|QByteArray
operator|::
name|fromRawData
argument_list|(
name|signature
argument_list|,
name|nameLength
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Finds \a signal and returns its index; otherwise returns -1.      This is the same as indexOfMethod(), except that it will return     -1 if the method exists but isn't a signal.      Note that the \a signal has to be in normalized form, as returned     by normalizedSignature().      \sa indexOfMethod(), normalizedSignature(), method(), methodCount(), methodOffset() */
end_comment
begin_function
DECL|function|indexOfSignal
name|int
name|QMetaObject
operator|::
name|indexOfSignal
parameter_list|(
specifier|const
name|char
modifier|*
name|signal
parameter_list|)
specifier|const
block|{
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|this
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|QArgumentTypeArray
name|types
decl_stmt|;
name|QByteArray
name|name
init|=
name|QMetaObjectPrivate
operator|::
name|decodeMethodSignature
argument_list|(
name|signal
argument_list|,
name|types
argument_list|)
decl_stmt|;
name|i
operator|=
name|QMetaObjectPrivate
operator|::
name|indexOfSignalRelative
argument_list|(
operator|&
name|m
argument_list|,
name|name
argument_list|,
name|types
operator|.
name|size
argument_list|()
argument_list|,
name|types
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|i
operator|+=
name|m
operator|->
name|methodOffset
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Same as QMetaObject::indexOfSignal, but the result is the local offset to the base object.      \a baseObject will be adjusted to the enclosing QMetaObject, or 0 if the signal is not found */
end_comment
begin_function
DECL|function|indexOfSignalRelative
name|int
name|QMetaObjectPrivate
operator|::
name|indexOfSignalRelative
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
modifier|*
name|baseObject
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|QArgumentType
modifier|*
name|types
parameter_list|)
block|{
name|int
name|i
init|=
name|indexOfMethodRelative
argument_list|<
name|MethodSignal
argument_list|>
argument_list|(
name|baseObject
argument_list|,
name|name
argument_list|,
name|argc
argument_list|,
name|types
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
operator|*
name|baseObject
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|m
operator|&&
name|m
operator|->
name|d
operator|.
name|superdata
condition|)
block|{
name|int
name|conflict
init|=
name|indexOfMethod
argument_list|(
name|m
operator|->
name|d
operator|.
name|superdata
argument_list|,
name|name
argument_list|,
name|argc
argument_list|,
name|types
argument_list|)
decl_stmt|;
if|if
condition|(
name|conflict
operator|>=
literal|0
condition|)
block|{
name|QMetaMethod
name|conflictMethod
init|=
name|m
operator|->
name|d
operator|.
name|superdata
operator|->
name|method
argument_list|(
name|conflict
argument_list|)
decl_stmt|;
name|qWarning
argument_list|(
literal|"QMetaObject::indexOfSignal: signal %s from %s redefined in %s"
argument_list|,
name|conflictMethod
operator|.
name|methodSignature
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|objectClassName
argument_list|(
name|m
operator|->
name|d
operator|.
name|superdata
argument_list|)
argument_list|,
name|objectClassName
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|i
return|;
block|}
end_function
begin_comment
comment|/*!     Finds \a slot and returns its index; otherwise returns -1.      This is the same as indexOfMethod(), except that it will return     -1 if the method exists but isn't a slot.      \sa indexOfMethod(), method(), methodCount(), methodOffset() */
end_comment
begin_function
DECL|function|indexOfSlot
name|int
name|QMetaObject
operator|::
name|indexOfSlot
parameter_list|(
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
specifier|const
block|{
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|this
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|QArgumentTypeArray
name|types
decl_stmt|;
name|QByteArray
name|name
init|=
name|QMetaObjectPrivate
operator|::
name|decodeMethodSignature
argument_list|(
name|slot
argument_list|,
name|types
argument_list|)
decl_stmt|;
name|i
operator|=
name|QMetaObjectPrivate
operator|::
name|indexOfSlotRelative
argument_list|(
operator|&
name|m
argument_list|,
name|name
argument_list|,
name|types
operator|.
name|size
argument_list|()
argument_list|,
name|types
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|i
operator|+=
name|m
operator|->
name|methodOffset
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_comment
comment|// same as indexOfSignalRelative but for slots.
end_comment
begin_function
DECL|function|indexOfSlotRelative
name|int
name|QMetaObjectPrivate
operator|::
name|indexOfSlotRelative
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
modifier|*
name|m
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|QArgumentType
modifier|*
name|types
parameter_list|)
block|{
return|return
name|indexOfMethodRelative
argument_list|<
name|MethodSlot
argument_list|>
argument_list|(
name|m
argument_list|,
name|name
argument_list|,
name|argc
argument_list|,
name|types
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|indexOfSignal
name|int
name|QMetaObjectPrivate
operator|::
name|indexOfSignal
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|m
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|QArgumentType
modifier|*
name|types
parameter_list|)
block|{
name|int
name|i
init|=
name|indexOfSignalRelative
argument_list|(
operator|&
name|m
argument_list|,
name|name
argument_list|,
name|argc
argument_list|,
name|types
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|i
operator|+=
name|m
operator|->
name|methodOffset
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_function
DECL|function|indexOfSlot
name|int
name|QMetaObjectPrivate
operator|::
name|indexOfSlot
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|m
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|QArgumentType
modifier|*
name|types
parameter_list|)
block|{
name|int
name|i
init|=
name|indexOfSlotRelative
argument_list|(
operator|&
name|m
argument_list|,
name|name
argument_list|,
name|argc
argument_list|,
name|types
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|i
operator|+=
name|m
operator|->
name|methodOffset
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_function
DECL|function|indexOfMethod
name|int
name|QMetaObjectPrivate
operator|::
name|indexOfMethod
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|m
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|QArgumentType
modifier|*
name|types
parameter_list|)
block|{
name|int
name|i
init|=
name|indexOfMethodRelative
argument_list|<
literal|0
argument_list|>
argument_list|(
operator|&
name|m
argument_list|,
name|name
argument_list|,
name|argc
argument_list|,
name|types
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|i
operator|+=
name|m
operator|->
name|methodOffset
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_function
DECL|function|indexOfConstructor
name|int
name|QMetaObjectPrivate
operator|::
name|indexOfConstructor
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|m
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|QArgumentType
modifier|*
name|types
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|constructorCount
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|handle
init|=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|constructorData
operator|+
literal|5
operator|*
name|i
decl_stmt|;
if|if
condition|(
name|methodMatch
argument_list|(
name|m
argument_list|,
name|handle
argument_list|,
name|name
argument_list|,
name|argc
argument_list|,
name|types
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 5.0      Returns the signal offset for the class \a m; i.e., the index position     of the class's first signal.      Similar to QMetaObject::methodOffset(), but non-signal methods are     excluded. */
end_comment
begin_function
DECL|function|signalOffset
name|int
name|QMetaObjectPrivate
operator|::
name|signalOffset
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|m
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|m
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
control|)
name|offset
operator|+=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|signalCount
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 5.0      Returns the number of signals for the class \a m, including the signals     for the base class.      Similar to QMetaObject::methodCount(), but non-signal methods are     excluded. */
end_comment
begin_function
DECL|function|absoluteSignalCount
name|int
name|QMetaObjectPrivate
operator|::
name|absoluteSignalCount
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|m
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|m
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|signalCount
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
control|)
name|n
operator|+=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|signalCount
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 5.0      Returns the index of the signal method \a m.      Similar to QMetaMethod::methodIndex(), but non-signal methods are     excluded. */
end_comment
begin_function
DECL|function|signalIndex
name|int
name|QMetaObjectPrivate
operator|::
name|signalIndex
parameter_list|(
specifier|const
name|QMetaMethod
modifier|&
name|m
parameter_list|)
block|{
if|if
condition|(
operator|!
name|m
operator|.
name|mobj
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
operator|&
name|m
argument_list|)
operator|->
name|ownMethodIndex
argument_list|()
operator|+
name|signalOffset
argument_list|(
name|m
operator|.
name|mobj
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 5.0      Returns the signal for the given meta-object \a m at \a signal_index.      It it different from QMetaObject::method(); the index should not include     non-signal methods. */
end_comment
begin_function
DECL|function|signal
name|QMetaMethod
name|QMetaObjectPrivate
operator|::
name|signal
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|m
parameter_list|,
name|int
name|signal_index
parameter_list|)
block|{
name|QMetaMethod
name|result
decl_stmt|;
if|if
condition|(
name|signal_index
operator|<
literal|0
condition|)
return|return
name|result
return|;
name|Q_ASSERT
argument_list|(
name|m
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|signal_index
decl_stmt|;
name|i
operator|-=
name|signalOffset
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|m
operator|->
name|d
operator|.
name|superdata
condition|)
return|return
name|signal
argument_list|(
name|m
operator|->
name|d
operator|.
name|superdata
argument_list|,
name|signal_index
argument_list|)
return|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|signalCount
condition|)
block|{
name|result
operator|.
name|mobj
operator|=
name|m
expr_stmt|;
name|result
operator|.
name|handle
operator|=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodData
operator|+
literal|5
operator|*
name|i
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns \c true if the \a signalTypes and \a methodTypes are     compatible; otherwise returns \c false. */
end_comment
begin_function
DECL|function|checkConnectArgs
name|bool
name|QMetaObjectPrivate
operator|::
name|checkConnectArgs
parameter_list|(
name|int
name|signalArgc
parameter_list|,
specifier|const
name|QArgumentType
modifier|*
name|signalTypes
parameter_list|,
name|int
name|methodArgc
parameter_list|,
specifier|const
name|QArgumentType
modifier|*
name|methodTypes
parameter_list|)
block|{
if|if
condition|(
name|signalArgc
operator|<
name|methodArgc
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|methodArgc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|signalTypes
index|[
name|i
index|]
operator|!=
name|methodTypes
index|[
name|i
index|]
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns \c true if the \a signal and \a method arguments are     compatible; otherwise returns \c false. */
end_comment
begin_function
DECL|function|checkConnectArgs
name|bool
name|QMetaObjectPrivate
operator|::
name|checkConnectArgs
parameter_list|(
specifier|const
name|QMetaMethodPrivate
modifier|*
name|signal
parameter_list|,
specifier|const
name|QMetaMethodPrivate
modifier|*
name|method
parameter_list|)
block|{
if|if
condition|(
name|signal
operator|->
name|methodType
argument_list|()
operator|!=
name|QMetaMethod
operator|::
name|Signal
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|signal
operator|->
name|parameterCount
argument_list|()
operator|<
name|method
operator|->
name|parameterCount
argument_list|()
condition|)
return|return
literal|false
return|;
specifier|const
name|QMetaObject
modifier|*
name|smeta
init|=
name|signal
operator|->
name|enclosingMetaObject
argument_list|()
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|rmeta
init|=
name|method
operator|->
name|enclosingMetaObject
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|method
operator|->
name|parameterCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|uint
name|sourceTypeInfo
init|=
name|signal
operator|->
name|parameterTypeInfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|uint
name|targetTypeInfo
init|=
name|method
operator|->
name|parameterTypeInfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sourceTypeInfo
operator|&
name|IsUnresolvedType
operator|)
operator|||
operator|(
name|targetTypeInfo
operator|&
name|IsUnresolvedType
operator|)
condition|)
block|{
name|QByteArray
name|sourceName
init|=
name|typeNameFromTypeInfo
argument_list|(
name|smeta
argument_list|,
name|sourceTypeInfo
argument_list|)
decl_stmt|;
name|QByteArray
name|targetName
init|=
name|typeNameFromTypeInfo
argument_list|(
name|rmeta
argument_list|,
name|targetTypeInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceName
operator|!=
name|targetName
condition|)
return|return
literal|false
return|;
block|}
else|else
block|{
name|int
name|sourceType
init|=
name|typeFromTypeInfo
argument_list|(
name|smeta
argument_list|,
name|sourceTypeInfo
argument_list|)
decl_stmt|;
name|int
name|targetType
init|=
name|typeFromTypeInfo
argument_list|(
name|rmeta
argument_list|,
name|targetTypeInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceType
operator|!=
name|targetType
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|QMetaObject_findMetaObject
specifier|static
specifier|const
name|QMetaObject
modifier|*
name|QMetaObject_findMetaObject
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|self
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
while|while
condition|(
name|self
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|objectClassName
argument_list|(
name|self
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|self
return|;
if|if
condition|(
name|self
operator|->
name|d
operator|.
name|relatedMetaObjects
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|self
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|2
argument_list|)
expr_stmt|;
specifier|const
name|QMetaObject
modifier|*
specifier|const
modifier|*
name|e
init|=
name|self
operator|->
name|d
operator|.
name|relatedMetaObjects
decl_stmt|;
if|if
condition|(
name|e
condition|)
block|{
while|while
condition|(
operator|*
name|e
condition|)
block|{
if|if
condition|(
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|QMetaObject_findMetaObject
argument_list|(
operator|(
operator|*
name|e
operator|)
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|m
return|;
operator|++
name|e
expr_stmt|;
block|}
block|}
block|}
name|self
operator|=
name|self
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
block|}
return|return
name|self
return|;
block|}
end_function
begin_comment
comment|/*!     Finds enumerator \a name and returns its index; otherwise returns     -1.      \sa enumerator(), enumeratorCount(), enumeratorOffset() */
end_comment
begin_function
DECL|function|indexOfEnumerator
name|int
name|QMetaObject
operator|::
name|indexOfEnumerator
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
specifier|const
block|{
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|this
decl_stmt|;
while|while
condition|(
name|m
condition|)
block|{
specifier|const
name|QMetaObjectPrivate
modifier|*
name|d
init|=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|d
operator|->
name|enumeratorCount
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|prop
init|=
name|rawStringData
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|d
operator|.
name|data
index|[
name|d
operator|->
name|enumeratorData
operator|+
literal|4
operator|*
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|prop
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|prop
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|+=
name|m
operator|->
name|enumeratorOffset
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Finds property \a name and returns its index; otherwise returns     -1.      \sa property(), propertyCount(), propertyOffset() */
end_comment
begin_function
DECL|function|indexOfProperty
name|int
name|QMetaObject
operator|::
name|indexOfProperty
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
specifier|const
block|{
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|this
decl_stmt|;
while|while
condition|(
name|m
condition|)
block|{
specifier|const
name|QMetaObjectPrivate
modifier|*
name|d
init|=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|d
operator|->
name|propertyCount
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|prop
init|=
name|rawStringData
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|d
operator|.
name|data
index|[
name|d
operator|->
name|propertyData
operator|+
literal|3
operator|*
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|prop
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|prop
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|+=
name|m
operator|->
name|propertyOffset
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|this
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
argument_list|(
name|this
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|flags
operator|&
name|DynamicMetaObject
condition|)
block|{
name|QAbstractDynamicMetaObject
modifier|*
name|me
init|=
cast|const_cast
argument_list|<
name|QAbstractDynamicMetaObject
operator|*
argument_list|>
argument_list|(
cast|static_cast
argument_list|<
specifier|const
name|QAbstractDynamicMetaObject
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|me
operator|->
name|createProperty
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Finds class information item \a name and returns its index;     otherwise returns -1.      \sa classInfo(), classInfoCount(), classInfoOffset() */
end_comment
begin_function
DECL|function|indexOfClassInfo
name|int
name|QMetaObject
operator|::
name|indexOfClassInfo
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
specifier|const
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|this
decl_stmt|;
while|while
condition|(
name|m
operator|&&
name|i
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|classInfoCount
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|rawStringData
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|d
operator|.
name|data
index|[
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|classInfoData
operator|+
literal|2
operator|*
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|+=
name|m
operator|->
name|classInfoOffset
argument_list|()
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the meta-data for the constructor with the given \a index.      \sa constructorCount(), newInstance() */
end_comment
begin_function
DECL|function|constructor
name|QMetaMethod
name|QMetaObject
operator|::
name|constructor
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|int
name|i
init|=
name|index
decl_stmt|;
name|QMetaMethod
name|result
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|constructorCount
condition|)
block|{
name|result
operator|.
name|mobj
operator|=
name|this
expr_stmt|;
name|result
operator|.
name|handle
operator|=
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|constructorData
operator|+
literal|5
operator|*
name|i
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the meta-data for the method with the given \a index.      \sa methodCount(), methodOffset(), indexOfMethod() */
end_comment
begin_function
DECL|function|method
name|QMetaMethod
name|QMetaObject
operator|::
name|method
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|int
name|i
init|=
name|index
decl_stmt|;
name|i
operator|-=
name|methodOffset
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|d
operator|.
name|superdata
condition|)
return|return
name|d
operator|.
name|superdata
operator|->
name|method
argument_list|(
name|index
argument_list|)
return|;
name|QMetaMethod
name|result
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodCount
condition|)
block|{
name|result
operator|.
name|mobj
operator|=
name|this
expr_stmt|;
name|result
operator|.
name|handle
operator|=
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodData
operator|+
literal|5
operator|*
name|i
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the meta-data for the enumerator with the given \a index.      \sa enumeratorCount(), enumeratorOffset(), indexOfEnumerator() */
end_comment
begin_function
DECL|function|enumerator
name|QMetaEnum
name|QMetaObject
operator|::
name|enumerator
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|int
name|i
init|=
name|index
decl_stmt|;
name|i
operator|-=
name|enumeratorOffset
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|d
operator|.
name|superdata
condition|)
return|return
name|d
operator|.
name|superdata
operator|->
name|enumerator
argument_list|(
name|index
argument_list|)
return|;
name|QMetaEnum
name|result
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|enumeratorCount
condition|)
block|{
name|result
operator|.
name|mobj
operator|=
name|this
expr_stmt|;
name|result
operator|.
name|handle
operator|=
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|enumeratorData
operator|+
literal|4
operator|*
name|i
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the meta-data for the property with the given \a index.     If no such property exists, a null QMetaProperty is returned.      \sa propertyCount(), propertyOffset(), indexOfProperty() */
end_comment
begin_function
DECL|function|property
name|QMetaProperty
name|QMetaObject
operator|::
name|property
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|int
name|i
init|=
name|index
decl_stmt|;
name|i
operator|-=
name|propertyOffset
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|d
operator|.
name|superdata
condition|)
return|return
name|d
operator|.
name|superdata
operator|->
name|property
argument_list|(
name|index
argument_list|)
return|;
name|QMetaProperty
name|result
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyCount
condition|)
block|{
name|int
name|handle
init|=
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyData
operator|+
literal|3
operator|*
name|i
decl_stmt|;
name|int
name|flags
init|=
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
name|result
operator|.
name|mobj
operator|=
name|this
expr_stmt|;
name|result
operator|.
name|handle
operator|=
name|handle
expr_stmt|;
name|result
operator|.
name|idx
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EnumOrFlag
condition|)
block|{
specifier|const
name|char
modifier|*
name|type
init|=
name|rawTypeNameFromTypeInfo
argument_list|(
name|this
argument_list|,
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|result
operator|.
name|menum
operator|=
name|enumerator
argument_list|(
name|indexOfEnumerator
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|menum
operator|.
name|isValid
argument_list|()
condition|)
block|{
specifier|const
name|char
modifier|*
name|enum_name
init|=
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|scope_name
init|=
name|objectClassName
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|char
modifier|*
name|scope_buffer
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|colon
init|=
name|strrchr
argument_list|(
name|enum_name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
comment|// ':' will always appear in pairs
name|Q_ASSERT
argument_list|(
name|colon
operator|<=
name|enum_name
operator|||
operator|*
operator|(
name|colon
operator|-
literal|1
operator|)
operator|==
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
operator|>
name|enum_name
condition|)
block|{
name|int
name|len
init|=
name|colon
operator|-
name|enum_name
operator|-
literal|1
decl_stmt|;
name|scope_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|scope_buffer
argument_list|,
name|enum_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|scope_buffer
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scope_name
operator|=
name|scope_buffer
expr_stmt|;
name|enum_name
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
block|}
specifier|const
name|QMetaObject
modifier|*
name|scope
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|qstrcmp
argument_list|(
name|scope_name
argument_list|,
literal|"Qt"
argument_list|)
operator|==
literal|0
condition|)
name|scope
operator|=
operator|&
name|QObject
operator|::
name|staticQtMetaObject
expr_stmt|;
else|else
name|scope
operator|=
name|QMetaObject_findMetaObject
argument_list|(
name|this
argument_list|,
name|scope_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
condition|)
name|result
operator|.
name|menum
operator|=
name|scope
operator|->
name|enumerator
argument_list|(
name|scope
operator|->
name|indexOfEnumerator
argument_list|(
name|enum_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope_buffer
condition|)
name|free
argument_list|(
name|scope_buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the property that has the \c USER flag set to true.      \sa QMetaProperty::isUser() */
end_comment
begin_function
DECL|function|userProperty
name|QMetaProperty
name|QMetaObject
operator|::
name|userProperty
parameter_list|()
specifier|const
block|{
specifier|const
name|int
name|propCount
init|=
name|propertyCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|propCount
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
specifier|const
name|QMetaProperty
name|prop
init|=
name|property
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|.
name|isUser
argument_list|()
condition|)
return|return
name|prop
return|;
block|}
return|return
name|QMetaProperty
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the meta-data for the item of class information with the     given \a index.      Example:      \snippet code/src_corelib_kernel_qmetaobject.cpp 0      \sa classInfoCount(), classInfoOffset(), indexOfClassInfo()  */
end_comment
begin_function
DECL|function|classInfo
name|QMetaClassInfo
name|QMetaObject
operator|::
name|classInfo
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|int
name|i
init|=
name|index
decl_stmt|;
name|i
operator|-=
name|classInfoOffset
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|d
operator|.
name|superdata
condition|)
return|return
name|d
operator|.
name|superdata
operator|->
name|classInfo
argument_list|(
name|index
argument_list|)
return|;
name|QMetaClassInfo
name|result
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|classInfoCount
condition|)
block|{
name|result
operator|.
name|mobj
operator|=
name|this
expr_stmt|;
name|result
operator|.
name|handle
operator|=
name|priv
argument_list|(
name|d
operator|.
name|data
argument_list|)
operator|->
name|classInfoData
operator|+
literal|2
operator|*
name|i
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the \a signal and \a method arguments are     compatible; otherwise returns \c false.      Both \a signal and \a method are expected to be normalized.      \sa normalizedSignature() */
end_comment
begin_function
DECL|function|checkConnectArgs
name|bool
name|QMetaObject
operator|::
name|checkConnectArgs
parameter_list|(
specifier|const
name|char
modifier|*
name|signal
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s1
init|=
name|signal
decl_stmt|;
specifier|const
name|char
modifier|*
name|s2
init|=
name|method
decl_stmt|;
while|while
condition|(
operator|*
name|s1
operator|++
operator|!=
literal|'('
condition|)
block|{ }
comment|// scan to first '('
while|while
condition|(
operator|*
name|s2
operator|++
operator|!=
literal|'('
condition|)
block|{ }
if|if
condition|(
operator|*
name|s2
operator|==
literal|')'
operator|||
name|qstrcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
operator|==
literal|0
condition|)
comment|// method has no args or
return|return
literal|true
return|;
comment|//   exact match
name|int
name|s1len
init|=
name|qstrlen
argument_list|(
name|s1
argument_list|)
decl_stmt|;
name|int
name|s2len
init|=
name|qstrlen
argument_list|(
name|s2
argument_list|)
decl_stmt|;
if|if
condition|(
name|s2len
operator|<
name|s1len
operator|&&
name|strncmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|s2len
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|s1
index|[
name|s2len
operator|-
literal|1
index|]
operator|==
literal|','
condition|)
return|return
literal|true
return|;
comment|// method has less args
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     \overload      Returns \c true if the \a signal and \a method arguments are     compatible; otherwise returns \c false. */
end_comment
begin_function
DECL|function|checkConnectArgs
name|bool
name|QMetaObject
operator|::
name|checkConnectArgs
parameter_list|(
specifier|const
name|QMetaMethod
modifier|&
name|signal
parameter_list|,
specifier|const
name|QMetaMethod
modifier|&
name|method
parameter_list|)
block|{
return|return
name|QMetaObjectPrivate
operator|::
name|checkConnectArgs
argument_list|(
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
operator|&
name|signal
argument_list|)
argument_list|,
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
operator|&
name|method
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qRemoveWhitespace
specifier|static
name|void
name|qRemoveWhitespace
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|d
parameter_list|)
block|{
name|char
name|last
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
name|is_space
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|is_space
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|last
operator|=
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
name|is_space
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&&
operator|(
operator|(
name|is_ident_char
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|is_ident_char
argument_list|(
name|last
argument_list|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|s
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|last
operator|==
literal|'<'
operator|)
operator|)
operator|)
condition|)
block|{
name|last
operator|=
operator|*
name|d
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qNormalizeType
specifier|static
name|char
modifier|*
name|qNormalizeType
parameter_list|(
name|char
modifier|*
name|d
parameter_list|,
name|int
modifier|&
name|templdepth
parameter_list|,
name|QByteArray
modifier|&
name|result
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
init|=
name|d
decl_stmt|;
while|while
condition|(
operator|*
name|d
operator|&&
operator|(
name|templdepth
operator|||
operator|(
operator|*
name|d
operator|!=
literal|','
operator|&&
operator|*
name|d
operator|!=
literal|')'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|'<'
condition|)
operator|++
name|templdepth
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'>'
condition|)
operator|--
name|templdepth
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
comment|// "void" should only be removed if this is part of a signature that has
comment|// an explicit void argument; e.g., "void foo(void)" --> "void foo()"
if|if
condition|(
name|strncmp
argument_list|(
literal|"void)"
argument_list|,
name|t
argument_list|,
name|d
operator|-
name|t
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|result
operator|+=
name|normalizeTypeInternal
argument_list|(
name|t
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Normalizes a \a type.      See QMetaObject::normalizedSignature() for a description on how     Qt normalizes.      Example:      \snippet code/src_corelib_kernel_qmetaobject.cpp 1      \sa normalizedSignature()  */
end_comment
begin_function
DECL|function|normalizedType
name|QByteArray
name|QMetaObject
operator|::
name|normalizedType
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|QByteArray
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
operator|!
operator|*
name|type
condition|)
return|return
name|result
return|;
name|QVarLengthArray
argument_list|<
name|char
argument_list|>
name|stackbuf
argument_list|(
name|qstrlen
argument_list|(
name|type
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|qRemoveWhitespace
argument_list|(
name|type
argument_list|,
name|stackbuf
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|templdepth
init|=
literal|0
decl_stmt|;
name|qNormalizeType
argument_list|(
name|stackbuf
operator|.
name|data
argument_list|()
argument_list|,
name|templdepth
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Normalizes the signature of the given \a method.      Qt uses normalized signatures to decide whether two given signals     and slots are compatible. Normalization reduces whitespace to a     minimum, moves 'const' to the front where appropriate, removes     'const' from value types and replaces const references with     values.      \sa checkConnectArgs(), normalizedType()  */
end_comment
begin_function
DECL|function|normalizedSignature
name|QByteArray
name|QMetaObject
operator|::
name|normalizedSignature
parameter_list|(
specifier|const
name|char
modifier|*
name|method
parameter_list|)
block|{
name|QByteArray
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|method
operator|||
operator|!
operator|*
name|method
condition|)
return|return
name|result
return|;
name|int
name|len
init|=
name|int
argument_list|(
name|strlen
argument_list|(
name|method
argument_list|)
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|char
argument_list|>
name|stackbuf
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|d
init|=
name|stackbuf
operator|.
name|data
argument_list|()
decl_stmt|;
name|qRemoveWhitespace
argument_list|(
name|method
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|int
name|argdepth
init|=
literal|0
decl_stmt|;
name|int
name|templdepth
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|d
condition|)
block|{
if|if
condition|(
name|argdepth
operator|==
literal|1
condition|)
block|{
name|d
operator|=
name|qNormalizeType
argument_list|(
name|d
argument_list|,
name|templdepth
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|d
condition|)
comment|//most likely an invalid signature.
break|break;
block|}
if|if
condition|(
operator|*
name|d
operator|==
literal|'('
condition|)
operator|++
name|argdepth
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|')'
condition|)
operator|--
name|argdepth
expr_stmt|;
name|result
operator|+=
operator|*
name|d
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_enum
DECL|enumerator|MaximumParamCount
enum|enum
block|{
name|MaximumParamCount
init|=
literal|11
block|}
enum|;
end_enum
begin_comment
DECL|enumerator|MaximumParamCount
comment|// up to 10 arguments + 1 return value
end_comment
begin_comment
comment|/*!     Returns the signatures of all methods whose name matches \a nonExistentMember,     or an empty QByteArray if there are no matches. */
end_comment
begin_function
DECL|function|findMethodCandidates
specifier|static
specifier|inline
name|QByteArray
name|findMethodCandidates
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|metaObject
parameter_list|,
specifier|const
name|char
modifier|*
name|nonExistentMember
parameter_list|)
block|{
name|QByteArray
name|candidateMessage
decl_stmt|;
comment|// Prevent full string comparison in every iteration.
specifier|const
name|QByteArray
name|memberByteArray
init|=
name|nonExistentMember
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|metaObject
operator|->
name|methodCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QMetaMethod
name|method
init|=
name|metaObject
operator|->
name|method
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
operator|.
name|name
argument_list|()
operator|==
name|memberByteArray
condition|)
name|candidateMessage
operator|.
name|append
argument_list|(
literal|"    "
operator|+
name|method
operator|.
name|methodSignature
argument_list|()
operator|+
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|candidateMessage
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|candidateMessage
operator|.
name|prepend
argument_list|(
literal|"\nCandidates are:\n"
argument_list|)
expr_stmt|;
name|candidateMessage
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|candidateMessage
return|;
block|}
end_function
begin_comment
comment|/*!     Invokes the \a member (a signal or a slot name) on the object \a     obj. Returns \c true if the member could be invoked. Returns \c false     if there is no such member or the parameters did not match.      The invocation can be either synchronous or asynchronous,     depending on \a type:      \list     \li If \a type is Qt::DirectConnection, the member will be invoked immediately.      \li If \a type is Qt::QueuedConnection,        a QEvent will be sent and the member is invoked as soon as the application        enters the main event loop.      \li If \a type is Qt::BlockingQueuedConnection, the method will be invoked in        the same way as for Qt::QueuedConnection, except that the current thread        will block until the event is delivered. Using this connection type to        communicate between objects in the same thread will lead to deadlocks.      \li If \a type is Qt::AutoConnection, the member is invoked        synchronously if \a obj lives in the same thread as the        caller; otherwise it will invoke the member asynchronously.     \endlist      The return value of the \a member function call is placed in \a     ret. If the invocation is asynchronous, the return value cannot     be evaluated. You can pass up to ten arguments (\a val0, \a val1,     \a val2, \a val3, \a val4, \a val5, \a val6, \a val7, \a val8,     and \a val9) to the \a member function.      QGenericArgument and QGenericReturnArgument are internal     helper classes. Because signals and slots can be dynamically     invoked, you must enclose the arguments using the Q_ARG() and     Q_RETURN_ARG() macros. Q_ARG() takes a type name and a     const reference of that type; Q_RETURN_ARG() takes a type name     and a non-const reference.      You only need to pass the name of the signal or slot to this function,     not the entire signature. For example, to asynchronously invoke     the \l{QThread::quit()}{quit()} slot on a     QThread, use the following code:      \snippet code/src_corelib_kernel_qmetaobject.cpp 2      With asynchronous method invocations, the parameters must be of     types that are known to Qt's meta-object system, because Qt needs     to copy the arguments to store them in an event behind the     scenes. If you try to use a queued connection and get the error     message      \snippet code/src_corelib_kernel_qmetaobject.cpp 3      call qRegisterMetaType() to register the data type before you     call invokeMethod().      To synchronously invoke the \c compute(QString, int, double) slot on     some arbitrary object \c obj retrieve its return value:      \snippet code/src_corelib_kernel_qmetaobject.cpp 4      If the "compute" slot does not take exactly one QString, one int     and one double in the specified order, the call will fail.      \sa Q_ARG(), Q_RETURN_ARG(), qRegisterMetaType(), QMetaMethod::invoke() */
end_comment
begin_function
DECL|function|invokeMethod
name|bool
name|QMetaObject
operator|::
name|invokeMethod
parameter_list|(
name|QObject
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|member
parameter_list|,
name|Qt
operator|::
name|ConnectionType
name|type
parameter_list|,
name|QGenericReturnArgument
name|ret
parameter_list|,
name|QGenericArgument
name|val0
parameter_list|,
name|QGenericArgument
name|val1
parameter_list|,
name|QGenericArgument
name|val2
parameter_list|,
name|QGenericArgument
name|val3
parameter_list|,
name|QGenericArgument
name|val4
parameter_list|,
name|QGenericArgument
name|val5
parameter_list|,
name|QGenericArgument
name|val6
parameter_list|,
name|QGenericArgument
name|val7
parameter_list|,
name|QGenericArgument
name|val8
parameter_list|,
name|QGenericArgument
name|val9
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obj
condition|)
return|return
literal|false
return|;
name|QVarLengthArray
argument_list|<
name|char
argument_list|,
literal|512
argument_list|>
name|sig
decl_stmt|;
name|int
name|len
init|=
name|qstrlen
argument_list|(
name|member
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
literal|false
return|;
name|sig
operator|.
name|append
argument_list|(
name|member
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sig
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|typeNames
index|[]
init|=
block|{
name|ret
operator|.
name|name
argument_list|()
block|,
name|val0
operator|.
name|name
argument_list|()
block|,
name|val1
operator|.
name|name
argument_list|()
block|,
name|val2
operator|.
name|name
argument_list|()
block|,
name|val3
operator|.
name|name
argument_list|()
block|,
name|val4
operator|.
name|name
argument_list|()
block|,
name|val5
operator|.
name|name
argument_list|()
block|,
name|val6
operator|.
name|name
argument_list|()
block|,
name|val7
operator|.
name|name
argument_list|()
block|,
name|val8
operator|.
name|name
argument_list|()
block|,
name|val9
operator|.
name|name
argument_list|()
block|}
decl_stmt|;
name|int
name|paramCount
decl_stmt|;
for|for
control|(
name|paramCount
operator|=
literal|1
init|;
name|paramCount
operator|<
name|MaximumParamCount
condition|;
operator|++
name|paramCount
control|)
block|{
name|len
operator|=
name|qstrlen
argument_list|(
name|typeNames
index|[
name|paramCount
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
break|break;
name|sig
operator|.
name|append
argument_list|(
name|typeNames
index|[
name|paramCount
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sig
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|paramCount
operator|==
literal|1
condition|)
name|sig
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
comment|// no parameters
else|else
name|sig
index|[
name|sig
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
name|sig
operator|.
name|append
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
specifier|const
name|QMetaObject
modifier|*
name|meta
init|=
name|obj
operator|->
name|metaObject
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
name|meta
operator|->
name|indexOfMethod
argument_list|(
name|sig
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|QByteArray
name|norm
init|=
name|QMetaObject
operator|::
name|normalizedSignature
argument_list|(
name|sig
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|idx
operator|=
name|meta
operator|->
name|indexOfMethod
argument_list|(
name|norm
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|meta
operator|->
name|methodCount
argument_list|()
condition|)
block|{
comment|// This method doesn't belong to us; print out a nice warning with candidates.
name|qWarning
argument_list|(
literal|"QMetaObject::invokeMethod: No such method %s::%s%s"
argument_list|,
name|meta
operator|->
name|className
argument_list|()
argument_list|,
name|sig
operator|.
name|constData
argument_list|()
argument_list|,
name|findMethodCandidates
argument_list|(
name|meta
argument_list|,
name|member
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QMetaMethod
name|method
init|=
name|meta
operator|->
name|method
argument_list|(
name|idx
argument_list|)
decl_stmt|;
return|return
name|method
operator|.
name|invoke
argument_list|(
name|obj
argument_list|,
name|type
argument_list|,
name|ret
argument_list|,
name|val0
argument_list|,
name|val1
argument_list|,
name|val2
argument_list|,
name|val3
argument_list|,
name|val4
argument_list|,
name|val5
argument_list|,
name|val6
argument_list|,
name|val7
argument_list|,
name|val8
argument_list|,
name|val9
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QMetaObject::invokeMethod(QObject *obj, const char *member,                                        QGenericReturnArgument ret,                                        QGenericArgument val0 = QGenericArgument(0),                                        QGenericArgument val1 = QGenericArgument(),                                        QGenericArgument val2 = QGenericArgument(),                                        QGenericArgument val3 = QGenericArgument(),                                        QGenericArgument val4 = QGenericArgument(),                                        QGenericArgument val5 = QGenericArgument(),                                        QGenericArgument val6 = QGenericArgument(),                                        QGenericArgument val7 = QGenericArgument(),                                        QGenericArgument val8 = QGenericArgument(),                                        QGenericArgument val9 = QGenericArgument());     \overload invokeMethod()      This overload always invokes the member using the connection type Qt::AutoConnection. */
end_comment
begin_comment
comment|/*! \fn bool QMetaObject::invokeMethod(QObject *obj, const char *member,                              Qt::ConnectionType type,                              QGenericArgument val0 = QGenericArgument(0),                              QGenericArgument val1 = QGenericArgument(),                              QGenericArgument val2 = QGenericArgument(),                              QGenericArgument val3 = QGenericArgument(),                              QGenericArgument val4 = QGenericArgument(),                              QGenericArgument val5 = QGenericArgument(),                              QGenericArgument val6 = QGenericArgument(),                              QGenericArgument val7 = QGenericArgument(),                              QGenericArgument val8 = QGenericArgument(),                              QGenericArgument val9 = QGenericArgument())      \overload invokeMethod()      This overload can be used if the return value of the member is of no interest. */
end_comment
begin_comment
comment|/*!     \fn bool QMetaObject::invokeMethod(QObject *obj, const char *member,                              QGenericArgument val0 = QGenericArgument(0),                              QGenericArgument val1 = QGenericArgument(),                              QGenericArgument val2 = QGenericArgument(),                              QGenericArgument val3 = QGenericArgument(),                              QGenericArgument val4 = QGenericArgument(),                              QGenericArgument val5 = QGenericArgument(),                              QGenericArgument val6 = QGenericArgument(),                              QGenericArgument val7 = QGenericArgument(),                              QGenericArgument val8 = QGenericArgument(),                              QGenericArgument val9 = QGenericArgument())      \overload invokeMethod()      This overload invokes the member using the connection type Qt::AutoConnection and     ignores return values. */
end_comment
begin_comment
comment|/*!     \class QMetaMethod     \inmodule QtCore      \brief The QMetaMethod class provides meta-data about a member     function.      \ingroup objectmodel      A QMetaMethod has a methodType(), a methodSignature(), a list of     parameterTypes() and parameterNames(), a return typeName(), a     tag(), and an access() specifier. You can use invoke() to invoke     the method on an arbitrary QObject.      \sa QMetaObject, QMetaEnum, QMetaProperty, {Qt's Property System} */
end_comment
begin_comment
comment|/*!     \enum QMetaMethod::Attributes      \internal      \value Compatibility     \value Cloned     \value Scriptable */
end_comment
begin_comment
comment|/*!     \fn bool QMetaMethod::isValid() const     \since 5.0      Returns \c true if this method is valid (can be introspected and     invoked), otherwise returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool operator==(const QMetaMethod&m1, const QMetaMethod&m2)     \since 5.0     \relates QMetaMethod     \overload      Returns \c true if method \a m1 is equal to method \a m2,     otherwise returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool operator!=(const QMetaMethod&m1, const QMetaMethod&m2)     \since 5.0     \relates QMetaMethod     \overload      Returns \c true if method \a m1 is not equal to method \a m2,     otherwise returns \c false. */
end_comment
begin_comment
comment|/*!     \fn const QMetaObject *QMetaMethod::enclosingMetaObject() const     \internal */
end_comment
begin_comment
comment|/*!     \enum QMetaMethod::MethodType      \value Method  The function is a plain member function.     \value Signal  The function is a signal.     \value Slot    The function is a slot.     \value Constructor The function is a constructor. */
end_comment
begin_comment
comment|/*!     \fn QMetaMethod::QMetaMethod()     \internal */
end_comment
begin_comment
comment|/*!     \macro Q_METAMETHOD_INVOKE_MAX_ARGS     \relates QMetaMethod      Equals maximum number of arguments available for     execution of the method via QMetaMethod::invoke()  */
end_comment
begin_function
DECL|function|signature
name|QByteArray
name|QMetaMethodPrivate
operator|::
name|signature
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|QByteArray
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|result
operator|+=
name|name
argument_list|()
expr_stmt|;
name|result
operator|+=
literal|'('
expr_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|argTypes
init|=
name|parameterTypes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argTypes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
name|result
operator|+=
literal|','
expr_stmt|;
name|result
operator|+=
name|argTypes
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|result
operator|+=
literal|')'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|name
name|QByteArray
name|QMetaMethodPrivate
operator|::
name|name
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
return|return
name|stringData
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
index|]
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|typesDataIndex
name|int
name|QMetaMethodPrivate
operator|::
name|typesDataIndex
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
return|return
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
return|;
block|}
end_function
begin_function
DECL|function|rawReturnTypeName
specifier|const
name|char
modifier|*
name|QMetaMethodPrivate
operator|::
name|rawReturnTypeName
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|uint
name|typeInfo
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|typesDataIndex
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|typeInfo
operator|&
name|IsUnresolvedType
condition|)
return|return
name|rawStringData
argument_list|(
name|mobj
argument_list|,
name|typeInfo
operator|&
name|TypeNameIndexMask
argument_list|)
return|;
else|else
return|return
name|QMetaType
operator|::
name|typeName
argument_list|(
name|typeInfo
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|returnType
name|int
name|QMetaMethodPrivate
operator|::
name|returnType
parameter_list|()
specifier|const
block|{
return|return
name|parameterType
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parameterCount
name|int
name|QMetaMethodPrivate
operator|::
name|parameterCount
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
return|return
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|1
index|]
return|;
block|}
end_function
begin_function
DECL|function|parametersDataIndex
name|int
name|QMetaMethodPrivate
operator|::
name|parametersDataIndex
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
return|return
name|typesDataIndex
argument_list|()
operator|+
literal|1
return|;
block|}
end_function
begin_function
DECL|function|parameterTypeInfo
name|uint
name|QMetaMethodPrivate
operator|::
name|parameterTypeInfo
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
return|return
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|parametersDataIndex
argument_list|()
operator|+
name|index
index|]
return|;
block|}
end_function
begin_function
DECL|function|parameterType
name|int
name|QMetaMethodPrivate
operator|::
name|parameterType
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
return|return
name|typeFromTypeInfo
argument_list|(
name|mobj
argument_list|,
name|parameterTypeInfo
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getParameterTypes
name|void
name|QMetaMethodPrivate
operator|::
name|getParameterTypes
parameter_list|(
name|int
modifier|*
name|types
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|int
name|dataIndex
init|=
name|parametersDataIndex
argument_list|()
decl_stmt|;
name|int
name|argc
init|=
name|parameterCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|int
name|id
init|=
name|typeFromTypeInfo
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|dataIndex
operator|++
index|]
argument_list|)
decl_stmt|;
operator|*
operator|(
name|types
operator|++
operator|)
operator|=
name|id
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|parameterTypes
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QMetaMethodPrivate
operator|::
name|parameterTypes
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|int
name|argc
init|=
name|parameterCount
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
name|list
operator|.
name|reserve
argument_list|(
name|argc
argument_list|)
expr_stmt|;
name|int
name|paramsIndex
init|=
name|parametersDataIndex
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|list
operator|+=
name|typeNameFromTypeInfo
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|paramsIndex
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|parameterNames
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QMetaMethodPrivate
operator|::
name|parameterNames
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|int
name|argc
init|=
name|parameterCount
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
name|list
operator|.
name|reserve
argument_list|(
name|argc
argument_list|)
expr_stmt|;
name|int
name|namesIndex
init|=
name|parametersDataIndex
argument_list|()
operator|+
name|argc
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|list
operator|+=
name|stringData
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|namesIndex
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|tag
name|QByteArray
name|QMetaMethodPrivate
operator|::
name|tag
parameter_list|()
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
return|return
name|stringData
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|3
index|]
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ownMethodIndex
name|int
name|QMetaMethodPrivate
operator|::
name|ownMethodIndex
parameter_list|()
specifier|const
block|{
comment|// recompute the methodIndex by reversing the arithmetic in QMetaObject::property()
return|return
operator|(
name|handle
operator|-
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodData
operator|)
operator|/
literal|5
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Returns the signature of this method (e.g.,     \c{setValue(double)}).      \sa parameterTypes(), parameterNames() */
end_comment
begin_function
DECL|function|methodSignature
name|QByteArray
name|QMetaMethod
operator|::
name|methodSignature
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
name|QByteArray
argument_list|()
return|;
return|return
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|signature
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Returns the name of this method.      \sa methodSignature(), parameterCount() */
end_comment
begin_function
DECL|function|name
name|QByteArray
name|QMetaMethod
operator|::
name|name
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
name|QByteArray
argument_list|()
return|;
return|return
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|name
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Returns the return type of this method.      The return value is one of the types that are registered     with QMetaType, or QMetaType::UnknownType if the type is not registered.      \sa parameterType(), QMetaType, typeName() */
end_comment
begin_function
DECL|function|returnType
name|int
name|QMetaMethod
operator|::
name|returnType
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
name|QMetaType
operator|::
name|UnknownType
return|;
return|return
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|returnType
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Returns the number of parameters of this method.      \sa parameterType(), parameterNames() */
end_comment
begin_function
DECL|function|parameterCount
name|int
name|QMetaMethod
operator|::
name|parameterCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
return|return
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|parameterCount
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Returns the type of the parameter at the given \a index.      The return value is one of the types that are registered     with QMetaType, or QMetaType::UnknownType if the type is not registered.      \sa parameterCount(), returnType(), QMetaType */
end_comment
begin_function
DECL|function|parameterType
name|int
name|QMetaMethod
operator|::
name|parameterType
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
operator|||
name|index
operator|<
literal|0
condition|)
return|return
name|QMetaType
operator|::
name|UnknownType
return|;
if|if
condition|(
name|index
operator|>=
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|parameterCount
argument_list|()
condition|)
return|return
name|QMetaType
operator|::
name|UnknownType
return|;
name|int
name|type
init|=
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|parameterType
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|QMetaType
operator|::
name|UnknownType
condition|)
return|return
name|type
return|;
name|void
modifier|*
name|argv
index|[]
init|=
block|{
operator|&
name|type
block|,
operator|&
name|index
block|}
decl_stmt|;
name|mobj
operator|->
name|static_metacall
argument_list|(
name|QMetaObject
operator|::
name|RegisterMethodArgumentMetaType
argument_list|,
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|ownMethodIndex
argument_list|()
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
operator|-
literal|1
condition|)
return|return
name|type
return|;
return|return
name|QMetaType
operator|::
name|UnknownType
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     \internal      Gets the parameter \a types of this method. The storage     for \a types must be able to hold parameterCount() items.      \sa parameterCount(), returnType(), parameterType() */
end_comment
begin_function
DECL|function|getParameterTypes
name|void
name|QMetaMethod
operator|::
name|getParameterTypes
parameter_list|(
name|int
modifier|*
name|types
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return;
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|getParameterTypes
argument_list|(
name|types
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of parameter types.      \sa parameterNames(), methodSignature() */
end_comment
begin_function
DECL|function|parameterTypes
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QMetaMethod
operator|::
name|parameterTypes
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
return|return
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|parameterTypes
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of parameter names.      \sa parameterTypes(), methodSignature() */
end_comment
begin_function
DECL|function|parameterNames
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QMetaMethod
operator|::
name|parameterNames
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
name|list
return|;
return|return
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|parameterNames
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the return type name of this method.      \sa returnType(), QMetaType::type() */
end_comment
begin_function
DECL|function|typeName
specifier|const
name|char
modifier|*
name|QMetaMethod
operator|::
name|typeName
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
return|return
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|rawReturnTypeName
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the tag associated with this method.      Tags are special macros recognized by \c moc that make it     possible to add extra information about a method.      Tag information can be added in the following     way in the function declaration:      \code         #ifndef Q_MOC_RUN         // define the tag text         #  define THISISTESTTAG         #endif         ...         private slots:             THISISTESTTAG void testFunc();     \endcode      and the information can be accessed by using:      \code         MainWindow win;         win.show();          int functionIndex = win.metaObject()->indexOfSlot("testFunc()");         QMetaMethod mm = metaObject()->method(functionIndex);         qDebug()<< mm.tag(); // prints THISISTESTTAG     \endcode      For the moment, \c moc will extract and record all tags, but it will not     handle any of them specially.      \note Since Qt 5.0, \c moc expands preprocessor macros, so it is necessary     to surround the definition with \c #ifndef \c Q_MOC_RUN, as shown in the     example above. This was not required in Qt 4. The code as shown above works     with Qt 4 too. */
end_comment
begin_function
DECL|function|tag
specifier|const
name|char
modifier|*
name|QMetaMethod
operator|::
name|tag
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
return|return
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|tag
argument_list|()
operator|.
name|constData
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal  */
end_comment
begin_function
DECL|function|attributes
name|int
name|QMetaMethod
operator|::
name|attributes
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
return|return
operator|(
operator|(
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|4
index|]
operator|)
operator|>>
literal|4
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.6    Returns this method's index. */
end_comment
begin_function
DECL|function|methodIndex
name|int
name|QMetaMethod
operator|::
name|methodIndex
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|ownMethodIndex
argument_list|()
operator|+
name|mobj
operator|->
name|methodOffset
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// This method has been around for a while, but the documentation was marked \internal until 5.1
end_comment
begin_comment
comment|/*!     \since 5.1     Returns the method revision if one was     specified by Q_REVISION, otherwise returns 0.  */
end_comment
begin_function
DECL|function|revision
name|int
name|QMetaMethod
operator|::
name|revision
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
if|if
condition|(
call|(
name|QMetaMethod
operator|::
name|Access
call|)
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|4
index|]
operator|&
name|MethodRevisioned
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodData
operator|+
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodCount
operator|*
literal|5
operator|+
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|ownMethodIndex
argument_list|()
decl_stmt|;
return|return
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|offset
index|]
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the access specification of this method (private,     protected, or public).      Signals are always protected, meaning that you can only emit them     from the class or from a subclass.      \sa methodType() */
end_comment
begin_function
DECL|function|access
name|QMetaMethod
operator|::
name|Access
name|QMetaMethod
operator|::
name|access
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
name|Private
return|;
return|return
call|(
name|QMetaMethod
operator|::
name|Access
call|)
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|4
index|]
operator|&
name|AccessMask
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the type of this method (signal, slot, or method).      \sa access() */
end_comment
begin_function
DECL|function|methodType
name|QMetaMethod
operator|::
name|MethodType
name|QMetaMethod
operator|::
name|methodType
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
name|QMetaMethod
operator|::
name|Method
return|;
return|return
call|(
name|QMetaMethod
operator|::
name|MethodType
call|)
argument_list|(
operator|(
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|4
index|]
operator|&
name|MethodTypeMask
operator|)
operator|>>
literal|2
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QMetaMethod QMetaMethod::fromSignal(PointerToMemberFunction signal)     \since 5.0      Returns the meta-method that corresponds to the given \a signal, or an     invalid QMetaMethod if \a signal is not a signal of the class.      Example:      \snippet code/src_corelib_kernel_qmetaobject.cpp 9 */
end_comment
begin_comment
comment|/*!     \internal      Implementation of the fromSignal() function.      \a metaObject is the class's meta-object     \a signal is a pointer to a pointer to a member signal of the class */
end_comment
begin_function
DECL|function|fromSignalImpl
name|QMetaMethod
name|QMetaMethod
operator|::
name|fromSignalImpl
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|metaObject
parameter_list|,
name|void
modifier|*
modifier|*
name|signal
parameter_list|)
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|void
modifier|*
name|args
index|[]
init|=
block|{
operator|&
name|i
block|,
name|signal
block|}
decl_stmt|;
name|QMetaMethod
name|result
decl_stmt|;
for|for
control|(
specifier|const
name|QMetaObject
modifier|*
name|m
init|=
name|metaObject
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|d
operator|.
name|superdata
control|)
block|{
name|m
operator|->
name|static_metacall
argument_list|(
name|QMetaObject
operator|::
name|IndexOfMethod
argument_list|,
literal|0
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|result
operator|.
name|mobj
operator|=
name|m
expr_stmt|;
name|result
operator|.
name|handle
operator|=
name|priv
argument_list|(
name|m
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|methodData
operator|+
literal|5
operator|*
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Invokes this method on the object \a object. Returns \c true if the member could be invoked.     Returns \c false if there is no such member or the parameters did not match.      The invocation can be either synchronous or asynchronous, depending on the     \a connectionType:      \list     \li If \a connectionType is Qt::DirectConnection, the member will be invoked immediately.      \li If \a connectionType is Qt::QueuedConnection,        a QEvent will be posted and the member is invoked as soon as the application        enters the main event loop.      \li If \a connectionType is Qt::AutoConnection, the member is invoked        synchronously if \a object lives in the same thread as the        caller; otherwise it will invoke the member asynchronously.     \endlist      The return value of this method call is placed in \a     returnValue. If the invocation is asynchronous, the return value cannot     be evaluated. You can pass up to ten arguments (\a val0, \a val1,     \a val2, \a val3, \a val4, \a val5, \a val6, \a val7, \a val8,     and \a val9) to this method call.      QGenericArgument and QGenericReturnArgument are internal     helper classes. Because signals and slots can be dynamically     invoked, you must enclose the arguments using the Q_ARG() and     Q_RETURN_ARG() macros. Q_ARG() takes a type name and a     const reference of that type; Q_RETURN_ARG() takes a type name     and a non-const reference.      To asynchronously invoke the     \l{QPushButton::animateClick()}{animateClick()} slot on a     QPushButton:      \snippet code/src_corelib_kernel_qmetaobject.cpp 6      With asynchronous method invocations, the parameters must be of     types that are known to Qt's meta-object system, because Qt needs     to copy the arguments to store them in an event behind the     scenes. If you try to use a queued connection and get the error     message      \snippet code/src_corelib_kernel_qmetaobject.cpp 7      call qRegisterMetaType() to register the data type before you     call QMetaMethod::invoke().      To synchronously invoke the \c compute(QString, int, double) slot on     some arbitrary object \c obj retrieve its return value:      \snippet code/src_corelib_kernel_qmetaobject.cpp 8      QMetaObject::normalizedSignature() is used here to ensure that the format     of the signature is what invoke() expects.  E.g. extra whitespace is     removed.      If the "compute" slot does not take exactly one QString, one int     and one double in the specified order, the call will fail.      \warning this method will not test the validity of the arguments: \a object     must be an instance of the class of the QMetaObject of which this QMetaMethod     has been constructed with.  The arguments must have the same type as the ones     expected by the method, else, the behaviour is undefined.      \sa Q_ARG(), Q_RETURN_ARG(), qRegisterMetaType(), QMetaObject::invokeMethod() */
end_comment
begin_function
DECL|function|invoke
name|bool
name|QMetaMethod
operator|::
name|invoke
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|,
name|Qt
operator|::
name|ConnectionType
name|connectionType
parameter_list|,
name|QGenericReturnArgument
name|returnValue
parameter_list|,
name|QGenericArgument
name|val0
parameter_list|,
name|QGenericArgument
name|val1
parameter_list|,
name|QGenericArgument
name|val2
parameter_list|,
name|QGenericArgument
name|val3
parameter_list|,
name|QGenericArgument
name|val4
parameter_list|,
name|QGenericArgument
name|val5
parameter_list|,
name|QGenericArgument
name|val6
parameter_list|,
name|QGenericArgument
name|val7
parameter_list|,
name|QGenericArgument
name|val8
parameter_list|,
name|QGenericArgument
name|val9
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|object
operator|||
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|Q_ASSERT
argument_list|(
name|mobj
operator|->
name|cast
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
comment|// check return type
if|if
condition|(
name|returnValue
operator|.
name|data
argument_list|()
condition|)
block|{
specifier|const
name|char
modifier|*
name|retType
init|=
name|typeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|qstrcmp
argument_list|(
name|returnValue
operator|.
name|name
argument_list|()
argument_list|,
name|retType
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|// normalize the return value as well
name|QByteArray
name|normalized
init|=
name|QMetaObject
operator|::
name|normalizedType
argument_list|(
name|returnValue
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qstrcmp
argument_list|(
name|normalized
operator|.
name|constData
argument_list|()
argument_list|,
name|retType
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|// String comparison failed, try compare the metatype.
name|int
name|t
init|=
name|returnType
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|QMetaType
operator|::
name|UnknownType
operator|||
name|t
operator|!=
name|QMetaType
operator|::
name|type
argument_list|(
name|normalized
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// check argument count (we don't allow invoking a method if given too few arguments)
specifier|const
name|char
modifier|*
name|typeNames
index|[]
init|=
block|{
name|returnValue
operator|.
name|name
argument_list|()
block|,
name|val0
operator|.
name|name
argument_list|()
block|,
name|val1
operator|.
name|name
argument_list|()
block|,
name|val2
operator|.
name|name
argument_list|()
block|,
name|val3
operator|.
name|name
argument_list|()
block|,
name|val4
operator|.
name|name
argument_list|()
block|,
name|val5
operator|.
name|name
argument_list|()
block|,
name|val6
operator|.
name|name
argument_list|()
block|,
name|val7
operator|.
name|name
argument_list|()
block|,
name|val8
operator|.
name|name
argument_list|()
block|,
name|val9
operator|.
name|name
argument_list|()
block|}
decl_stmt|;
name|int
name|paramCount
decl_stmt|;
for|for
control|(
name|paramCount
operator|=
literal|1
init|;
name|paramCount
operator|<
name|MaximumParamCount
condition|;
operator|++
name|paramCount
control|)
block|{
if|if
condition|(
name|qstrlen
argument_list|(
name|typeNames
index|[
name|paramCount
index|]
argument_list|)
operator|<=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|paramCount
operator|<=
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|parameterCount
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// check connection type
name|QThread
modifier|*
name|currentThread
init|=
name|QThread
operator|::
name|currentThread
argument_list|()
decl_stmt|;
name|QThread
modifier|*
name|objectThread
init|=
name|object
operator|->
name|thread
argument_list|()
decl_stmt|;
if|if
condition|(
name|connectionType
operator|==
name|Qt
operator|::
name|AutoConnection
condition|)
block|{
name|connectionType
operator|=
name|currentThread
operator|==
name|objectThread
condition|?
name|Qt
operator|::
name|DirectConnection
else|:
name|Qt
operator|::
name|QueuedConnection
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_NO_THREAD
if|if
condition|(
name|connectionType
operator|==
name|Qt
operator|::
name|BlockingQueuedConnection
condition|)
block|{
name|connectionType
operator|=
name|Qt
operator|::
name|DirectConnection
expr_stmt|;
block|}
endif|#
directive|endif
comment|// invoke!
name|void
modifier|*
name|param
index|[]
init|=
block|{
name|returnValue
operator|.
name|data
argument_list|()
block|,
name|val0
operator|.
name|data
argument_list|()
block|,
name|val1
operator|.
name|data
argument_list|()
block|,
name|val2
operator|.
name|data
argument_list|()
block|,
name|val3
operator|.
name|data
argument_list|()
block|,
name|val4
operator|.
name|data
argument_list|()
block|,
name|val5
operator|.
name|data
argument_list|()
block|,
name|val6
operator|.
name|data
argument_list|()
block|,
name|val7
operator|.
name|data
argument_list|()
block|,
name|val8
operator|.
name|data
argument_list|()
block|,
name|val9
operator|.
name|data
argument_list|()
block|}
decl_stmt|;
name|int
name|idx_relative
init|=
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|ownMethodIndex
argument_list|()
decl_stmt|;
name|int
name|idx_offset
init|=
name|mobj
operator|->
name|methodOffset
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QMetaObjectPrivate
operator|::
name|get
argument_list|(
name|mobj
argument_list|)
operator|->
name|revision
operator|>=
literal|6
argument_list|)
expr_stmt|;
name|QObjectPrivate
operator|::
name|StaticMetaCallFunction
name|callFunction
init|=
name|mobj
operator|->
name|d
operator|.
name|static_metacall
decl_stmt|;
if|if
condition|(
name|connectionType
operator|==
name|Qt
operator|::
name|DirectConnection
condition|)
block|{
if|if
condition|(
name|callFunction
condition|)
block|{
name|callFunction
argument_list|(
name|object
argument_list|,
name|QMetaObject
operator|::
name|InvokeMetaMethod
argument_list|,
name|idx_relative
argument_list|,
name|param
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
name|QMetaObject
operator|::
name|metacall
argument_list|(
name|object
argument_list|,
name|QMetaObject
operator|::
name|InvokeMetaMethod
argument_list|,
name|idx_relative
operator|+
name|idx_offset
argument_list|,
name|param
argument_list|)
operator|<
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|connectionType
operator|==
name|Qt
operator|::
name|QueuedConnection
condition|)
block|{
if|if
condition|(
name|returnValue
operator|.
name|data
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMetaMethod::invoke: Unable to invoke methods with return values in "
literal|"queued connections"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|nargs
init|=
literal|1
decl_stmt|;
comment|// include return type
name|void
modifier|*
modifier|*
name|args
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|paramCount
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|int
modifier|*
name|types
init|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|paramCount
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|types
argument_list|)
expr_stmt|;
name|types
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|// return type
name|args
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|paramCount
condition|;
operator|++
name|i
control|)
block|{
name|types
index|[
name|i
index|]
operator|=
name|QMetaType
operator|::
name|type
argument_list|(
name|typeNames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|types
index|[
name|i
index|]
operator|!=
name|QMetaType
operator|::
name|UnknownType
condition|)
block|{
name|args
index|[
name|i
index|]
operator|=
name|QMetaType
operator|::
name|create
argument_list|(
name|types
index|[
name|i
index|]
argument_list|,
name|param
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|++
name|nargs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|param
index|[
name|i
index|]
condition|)
block|{
comment|// Try to register the type and try again before reporting an error.
name|void
modifier|*
name|argv
index|[]
init|=
block|{
operator|&
name|types
index|[
name|i
index|]
block|,
operator|&
name|i
block|}
decl_stmt|;
name|QMetaObject
operator|::
name|metacall
argument_list|(
name|object
argument_list|,
name|QMetaObject
operator|::
name|RegisterMethodArgumentMetaType
argument_list|,
name|idx_relative
operator|+
name|idx_offset
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|types
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMetaMethod::invoke: Unable to handle unregistered datatype '%s'"
argument_list|,
name|typeNames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|1
init|;
name|x
operator|<
name|i
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|types
index|[
name|x
index|]
operator|&&
name|args
index|[
name|x
index|]
condition|)
name|QMetaType
operator|::
name|destroy
argument_list|(
name|types
index|[
name|x
index|]
argument_list|,
name|args
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|types
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|object
argument_list|,
operator|new
name|QMetaCallEvent
argument_list|(
name|idx_offset
argument_list|,
name|idx_relative
argument_list|,
name|callFunction
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|nargs
argument_list|,
name|types
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// blocking queued connection
ifndef|#
directive|ifndef
name|QT_NO_THREAD
if|if
condition|(
name|currentThread
operator|==
name|objectThread
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMetaMethod::invoke: Dead lock detected in "
literal|"BlockingQueuedConnection: Receiver is %s(%p)"
argument_list|,
name|mobj
operator|->
name|className
argument_list|()
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
name|QSemaphore
name|semaphore
decl_stmt|;
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|object
argument_list|,
operator|new
name|QMetaCallEvent
argument_list|(
name|idx_offset
argument_list|,
name|idx_relative
argument_list|,
name|callFunction
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|param
argument_list|,
operator|&
name|semaphore
argument_list|)
argument_list|)
expr_stmt|;
name|semaphore
operator|.
name|acquire
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_THREAD
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QMetaMethod::invoke(QObject *object,                                  QGenericReturnArgument returnValue,                                  QGenericArgument val0 = QGenericArgument(0),                                  QGenericArgument val1 = QGenericArgument(),                                  QGenericArgument val2 = QGenericArgument(),                                  QGenericArgument val3 = QGenericArgument(),                                  QGenericArgument val4 = QGenericArgument(),                                  QGenericArgument val5 = QGenericArgument(),                                  QGenericArgument val6 = QGenericArgument(),                                  QGenericArgument val7 = QGenericArgument(),                                  QGenericArgument val8 = QGenericArgument(),                                  QGenericArgument val9 = QGenericArgument()) const     \overload invoke()      This overload always invokes this method using the connection type Qt::AutoConnection. */
end_comment
begin_comment
comment|/*! \fn bool QMetaMethod::invoke(QObject *object,                                  Qt::ConnectionType connectionType,                                  QGenericArgument val0 = QGenericArgument(0),                                  QGenericArgument val1 = QGenericArgument(),                                  QGenericArgument val2 = QGenericArgument(),                                  QGenericArgument val3 = QGenericArgument(),                                  QGenericArgument val4 = QGenericArgument(),                                  QGenericArgument val5 = QGenericArgument(),                                  QGenericArgument val6 = QGenericArgument(),                                  QGenericArgument val7 = QGenericArgument(),                                  QGenericArgument val8 = QGenericArgument(),                                  QGenericArgument val9 = QGenericArgument()) const      \overload invoke()      This overload can be used if the return value of the member is of no interest. */
end_comment
begin_comment
comment|/*!     \fn bool QMetaMethod::invoke(QObject *object,                                  QGenericArgument val0 = QGenericArgument(0),                                  QGenericArgument val1 = QGenericArgument(),                                  QGenericArgument val2 = QGenericArgument(),                                  QGenericArgument val3 = QGenericArgument(),                                  QGenericArgument val4 = QGenericArgument(),                                  QGenericArgument val5 = QGenericArgument(),                                  QGenericArgument val6 = QGenericArgument(),                                  QGenericArgument val7 = QGenericArgument(),                                  QGenericArgument val8 = QGenericArgument(),                                  QGenericArgument val9 = QGenericArgument()) const      \overload invoke()      This overload invokes this method using the     connection type Qt::AutoConnection and ignores return values. */
end_comment
begin_comment
comment|/*!     \since 5.5      Invokes this method on a Q_GADGET. Returns \c true if the member could be invoked.     Returns \c false if there is no such member or the parameters did not match.      The pointer \a gadget must point to an instance of the gadget class.      The invocation is always synchronous.      The return value of this method call is placed in \a     returnValue. You can pass up to ten arguments (\a val0, \a val1,     \a val2, \a val3, \a val4, \a val5, \a val6, \a val7, \a val8,     and \a val9) to this method call.      \warning this method will not test the validity of the arguments: \a gadget     must be an instance of the class of the QMetaObject of which this QMetaMethod     has been constructed with.  The arguments must have the same type as the ones     expected by the method, else, the behavior is undefined.      \sa Q_ARG(), Q_RETURN_ARG(), qRegisterMetaType(), QMetaObject::invokeMethod() */
end_comment
begin_function
DECL|function|invokeOnGadget
name|bool
name|QMetaMethod
operator|::
name|invokeOnGadget
parameter_list|(
name|void
modifier|*
name|gadget
parameter_list|,
name|QGenericReturnArgument
name|returnValue
parameter_list|,
name|QGenericArgument
name|val0
parameter_list|,
name|QGenericArgument
name|val1
parameter_list|,
name|QGenericArgument
name|val2
parameter_list|,
name|QGenericArgument
name|val3
parameter_list|,
name|QGenericArgument
name|val4
parameter_list|,
name|QGenericArgument
name|val5
parameter_list|,
name|QGenericArgument
name|val6
parameter_list|,
name|QGenericArgument
name|val7
parameter_list|,
name|QGenericArgument
name|val8
parameter_list|,
name|QGenericArgument
name|val9
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|gadget
operator|||
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
comment|// check return type
if|if
condition|(
name|returnValue
operator|.
name|data
argument_list|()
condition|)
block|{
specifier|const
name|char
modifier|*
name|retType
init|=
name|typeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|qstrcmp
argument_list|(
name|returnValue
operator|.
name|name
argument_list|()
argument_list|,
name|retType
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|// normalize the return value as well
name|QByteArray
name|normalized
init|=
name|QMetaObject
operator|::
name|normalizedType
argument_list|(
name|returnValue
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qstrcmp
argument_list|(
name|normalized
operator|.
name|constData
argument_list|()
argument_list|,
name|retType
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|// String comparison failed, try compare the metatype.
name|int
name|t
init|=
name|returnType
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|QMetaType
operator|::
name|UnknownType
operator|||
name|t
operator|!=
name|QMetaType
operator|::
name|type
argument_list|(
name|normalized
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// check argument count (we don't allow invoking a method if given too few arguments)
specifier|const
name|char
modifier|*
name|typeNames
index|[]
init|=
block|{
name|returnValue
operator|.
name|name
argument_list|()
block|,
name|val0
operator|.
name|name
argument_list|()
block|,
name|val1
operator|.
name|name
argument_list|()
block|,
name|val2
operator|.
name|name
argument_list|()
block|,
name|val3
operator|.
name|name
argument_list|()
block|,
name|val4
operator|.
name|name
argument_list|()
block|,
name|val5
operator|.
name|name
argument_list|()
block|,
name|val6
operator|.
name|name
argument_list|()
block|,
name|val7
operator|.
name|name
argument_list|()
block|,
name|val8
operator|.
name|name
argument_list|()
block|,
name|val9
operator|.
name|name
argument_list|()
block|}
decl_stmt|;
name|int
name|paramCount
decl_stmt|;
for|for
control|(
name|paramCount
operator|=
literal|1
init|;
name|paramCount
operator|<
name|MaximumParamCount
condition|;
operator|++
name|paramCount
control|)
block|{
if|if
condition|(
name|qstrlen
argument_list|(
name|typeNames
index|[
name|paramCount
index|]
argument_list|)
operator|<=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|paramCount
operator|<=
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|parameterCount
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// invoke!
name|void
modifier|*
name|param
index|[]
init|=
block|{
name|returnValue
operator|.
name|data
argument_list|()
block|,
name|val0
operator|.
name|data
argument_list|()
block|,
name|val1
operator|.
name|data
argument_list|()
block|,
name|val2
operator|.
name|data
argument_list|()
block|,
name|val3
operator|.
name|data
argument_list|()
block|,
name|val4
operator|.
name|data
argument_list|()
block|,
name|val5
operator|.
name|data
argument_list|()
block|,
name|val6
operator|.
name|data
argument_list|()
block|,
name|val7
operator|.
name|data
argument_list|()
block|,
name|val8
operator|.
name|data
argument_list|()
block|,
name|val9
operator|.
name|data
argument_list|()
block|}
decl_stmt|;
name|int
name|idx_relative
init|=
name|QMetaMethodPrivate
operator|::
name|get
argument_list|(
name|this
argument_list|)
operator|->
name|ownMethodIndex
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QMetaObjectPrivate
operator|::
name|get
argument_list|(
name|mobj
argument_list|)
operator|->
name|revision
operator|>=
literal|6
argument_list|)
expr_stmt|;
name|QObjectPrivate
operator|::
name|StaticMetaCallFunction
name|callFunction
init|=
name|mobj
operator|->
name|d
operator|.
name|static_metacall
decl_stmt|;
if|if
condition|(
operator|!
name|callFunction
condition|)
return|return
literal|false
return|;
name|callFunction
argument_list|(
cast|reinterpret_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|gadget
argument_list|)
argument_list|,
name|QMetaObject
operator|::
name|InvokeMetaMethod
argument_list|,
name|idx_relative
argument_list|,
name|param
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QMetaMethod::invokeOnGadget(void *gadget,             QGenericArgument val0 = QGenericArgument(0),             QGenericArgument val1 = QGenericArgument(),             QGenericArgument val2 = QGenericArgument(),             QGenericArgument val3 = QGenericArgument(),             QGenericArgument val4 = QGenericArgument(),             QGenericArgument val5 = QGenericArgument(),             QGenericArgument val6 = QGenericArgument(),             QGenericArgument val7 = QGenericArgument(),             QGenericArgument val8 = QGenericArgument(),             QGenericArgument val9 = QGenericArgument()) const      \overload     \since 5.5      This overload invokes this method for a \a gadget and ignores return values. */
end_comment
begin_comment
comment|/*!     \class QMetaEnum     \inmodule QtCore     \brief The QMetaEnum class provides meta-data about an enumerator.      \ingroup objectmodel      Use name() for the enumerator's name. The enumerator's keys (names     of each enumerated item) are returned by key(); use keyCount() to find     the number of keys. isFlag() returns whether the enumerator is     meant to be used as a flag, meaning that its values can be combined     using the OR operator.      The conversion functions keyToValue(), valueToKey(), keysToValue(),     and valueToKeys() allow conversion between the integer     representation of an enumeration or set value and its literal     representation. The scope() function returns the class scope this     enumerator was declared in.      \sa QMetaObject, QMetaMethod, QMetaProperty */
end_comment
begin_comment
comment|/*!     \fn bool QMetaEnum::isValid() const      Returns \c true if this enum is valid (has a name); otherwise returns     false.      \sa name() */
end_comment
begin_comment
comment|/*!     \fn const QMetaObject *QMetaEnum::enclosingMetaObject() const     \internal */
end_comment
begin_comment
comment|/*!     \fn QMetaEnum::QMetaEnum()     \internal */
end_comment
begin_comment
comment|/*!     Returns the name of the enumerator (without the scope).      For example, the Qt::AlignmentFlag enumeration has \c     AlignmentFlag as the name and \l Qt as the scope.      \sa isValid(), scope() */
end_comment
begin_function
DECL|function|name
specifier|const
name|char
modifier|*
name|QMetaEnum
operator|::
name|name
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
return|return
name|rawStringData
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of keys.      \sa key() */
end_comment
begin_function
DECL|function|keyCount
name|int
name|QMetaEnum
operator|::
name|keyCount
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
return|return
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the key with the given \a index, or 0 if no such key exists.      \sa keyCount(), value(), valueToKey() */
end_comment
begin_function
DECL|function|key
specifier|const
name|char
modifier|*
name|QMetaEnum
operator|::
name|key
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
name|int
name|count
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|data
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|count
condition|)
return|return
name|rawStringData
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|data
operator|+
literal|2
operator|*
name|index
index|]
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the value with the given \a index; or returns -1 if there     is no such value.      \sa keyCount(), key(), keyToValue() */
end_comment
begin_function
DECL|function|value
name|int
name|QMetaEnum
operator|::
name|value
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
name|int
name|count
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|data
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|count
condition|)
return|return
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|data
operator|+
literal|2
operator|*
name|index
operator|+
literal|1
index|]
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this enumerator is used as a flag; otherwise returns     false.      When used as flags, enumerators can be combined using the OR     operator.      \sa keysToValue(), valueToKeys() */
end_comment
begin_function
DECL|function|isFlag
name|bool
name|QMetaEnum
operator|::
name|isFlag
parameter_list|()
specifier|const
block|{
return|return
name|mobj
operator|&&
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|1
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the scope this enumerator was declared in.      For example, the Qt::AlignmentFlag enumeration has \c Qt as     the scope and \c AlignmentFlag as the name.      \sa name() */
end_comment
begin_function
DECL|function|scope
specifier|const
name|char
modifier|*
name|QMetaEnum
operator|::
name|scope
parameter_list|()
specifier|const
block|{
return|return
name|mobj
condition|?
name|objectClassName
argument_list|(
name|mobj
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the integer value of the given enumeration \a key, or -1     if \a key is not defined.      If \a key is not defined, *\a{ok} is set to false; otherwise     *\a{ok} is set to true.      For flag types, use keysToValue().      \sa valueToKey(), isFlag(), keysToValue() */
end_comment
begin_function
DECL|function|keyToValue
name|int
name|QMetaEnum
operator|::
name|keyToValue
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|mobj
operator|||
operator|!
name|key
condition|)
return|return
operator|-
literal|1
return|;
name|uint
name|scope
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|qualified_key
init|=
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|key
operator|+
name|qstrlen
argument_list|(
name|key
argument_list|)
decl_stmt|;
while|while
condition|(
name|s
operator|>
name|key
operator|&&
operator|*
name|s
operator|!=
literal|':'
condition|)
operator|--
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|key
operator|&&
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|':'
condition|)
block|{
name|scope
operator|=
name|s
operator|-
name|key
operator|-
literal|1
expr_stmt|;
name|key
operator|+=
name|scope
operator|+
literal|2
expr_stmt|;
block|}
name|int
name|count
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|data
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|3
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QByteArray
name|className
init|=
name|stringData
argument_list|(
name|mobj
argument_list|,
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|className
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|scope
operator|||
operator|(
name|className
operator|.
name|size
argument_list|()
operator|==
name|int
argument_list|(
name|scope
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|qualified_key
argument_list|,
name|className
operator|.
name|constData
argument_list|()
argument_list|,
name|scope
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|key
argument_list|,
name|rawStringData
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|data
operator|+
literal|2
operator|*
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
return|return
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|data
operator|+
literal|2
operator|*
name|i
operator|+
literal|1
index|]
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the string that is used as the name of the given     enumeration \a value, or 0 if \a value is not defined.      For flag types, use valueToKeys().      \sa isFlag(), valueToKeys() */
end_comment
begin_function
DECL|function|valueToKey
specifier|const
name|char
modifier|*
name|QMetaEnum
operator|::
name|valueToKey
parameter_list|(
name|int
name|value
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
name|int
name|count
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|data
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|3
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|value
operator|==
operator|(
name|int
operator|)
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|data
operator|+
literal|2
operator|*
name|i
operator|+
literal|1
index|]
condition|)
return|return
name|rawStringData
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|data
operator|+
literal|2
operator|*
name|i
index|]
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the value derived from combining together the values of     the \a keys using the OR operator, or -1 if \a keys is not     defined. Note that the strings in \a keys must be '|'-separated.      If \a keys is not defined, *\a{ok} is set to false; otherwise     *\a{ok} is set to true.      \sa isFlag(), valueToKey(), valueToKeys() */
end_comment
begin_function
DECL|function|keysToValue
name|int
name|QMetaEnum
operator|::
name|keysToValue
parameter_list|(
specifier|const
name|char
modifier|*
name|keys
parameter_list|,
name|bool
modifier|*
name|ok
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|mobj
operator|||
operator|!
name|keys
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|true
expr_stmt|;
name|QStringList
name|l
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|keys
argument_list|)
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
comment|//#### TODO write proper code, do not use QStringList
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|data
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|3
index|]
decl_stmt|;
for|for
control|(
name|int
name|li
init|=
literal|0
init|;
name|li
operator|<
name|l
operator|.
name|size
argument_list|()
condition|;
operator|++
name|li
control|)
block|{
name|QString
name|trimmed
init|=
name|l
operator|.
name|at
argument_list|(
name|li
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|QByteArray
name|qualified_key
init|=
name|trimmed
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
init|=
name|qualified_key
operator|.
name|constData
argument_list|()
decl_stmt|;
name|uint
name|scope
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|key
operator|+
name|qstrlen
argument_list|(
name|key
argument_list|)
decl_stmt|;
while|while
condition|(
name|s
operator|>
name|key
operator|&&
operator|*
name|s
operator|!=
literal|':'
condition|)
operator|--
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|key
operator|&&
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|':'
condition|)
block|{
name|scope
operator|=
name|s
operator|-
name|key
operator|-
literal|1
expr_stmt|;
name|key
operator|+=
name|scope
operator|+
literal|2
expr_stmt|;
block|}
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
specifier|const
name|QByteArray
name|className
init|=
name|stringData
argument_list|(
name|mobj
argument_list|,
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|className
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|scope
operator|||
operator|(
name|className
operator|.
name|size
argument_list|()
operator|==
name|int
argument_list|(
name|scope
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|qualified_key
operator|.
name|constData
argument_list|()
argument_list|,
name|className
operator|.
name|constData
argument_list|()
argument_list|,
name|scope
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|key
argument_list|,
name|rawStringData
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|data
operator|+
literal|2
operator|*
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator||=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|data
operator|+
literal|2
operator|*
name|i
operator|+
literal|1
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
operator|*
name|ok
operator|=
literal|false
expr_stmt|;
name|value
operator||=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|value
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a byte array of '|'-separated keys that represents the     given \a value.      \sa isFlag(), valueToKey(), keysToValue() */
end_comment
begin_function
DECL|function|valueToKeys
name|QByteArray
name|QMetaEnum
operator|::
name|valueToKeys
parameter_list|(
name|int
name|value
parameter_list|)
specifier|const
block|{
name|QByteArray
name|keys
decl_stmt|;
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
name|keys
return|;
name|int
name|count
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|data
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|3
index|]
decl_stmt|;
name|int
name|v
init|=
name|value
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|k
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|data
operator|+
literal|2
operator|*
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|k
operator|!=
literal|0
operator|&&
operator|(
name|v
operator|&
name|k
operator|)
operator|==
name|k
operator|)
operator|||
operator|(
name|k
operator|==
name|value
operator|)
condition|)
block|{
name|v
operator|=
name|v
operator|&
operator|~
name|k
expr_stmt|;
if|if
condition|(
operator|!
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
name|keys
operator|+=
literal|'|'
expr_stmt|;
name|keys
operator|+=
name|stringData
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|data
operator|+
literal|2
operator|*
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|keys
return|;
block|}
end_function
begin_function
DECL|function|qualifiedName
specifier|static
name|QByteArray
name|qualifiedName
parameter_list|(
specifier|const
name|QMetaEnum
modifier|&
name|e
parameter_list|)
block|{
return|return
name|QByteArray
argument_list|(
name|e
operator|.
name|scope
argument_list|()
argument_list|)
operator|+
literal|"::"
operator|+
name|e
operator|.
name|name
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \class QMetaProperty     \inmodule QtCore     \brief The QMetaProperty class provides meta-data about a property.      \ingroup objectmodel      Property meta-data is obtained from an object's meta-object. See     QMetaObject::property() and QMetaObject::propertyCount() for     details.      \section1 Property Meta-Data      A property has a name() and a type(), as well as various     attributes that specify its behavior: isReadable(), isWritable(),     isDesignable(), isScriptable(), revision(), and isStored().      If the property is an enumeration, isEnumType() returns \c true; if the     property is an enumeration that is also a flag (i.e. its values     can be combined using the OR operator), isEnumType() and     isFlagType() both return true. The enumerator for these types is     available from enumerator().      The property's values are set and retrieved with read(), write(),     and reset(); they can also be changed through QObject's set and get     functions. See QObject::setProperty() and QObject::property() for     details.      \section1 Copying and Assignment      QMetaProperty objects can be copied by value. However, each copy will     refer to the same underlying property meta-data.      \sa QMetaObject, QMetaEnum, QMetaMethod, {Qt's Property System} */
end_comment
begin_comment
comment|/*!     \fn bool QMetaProperty::isValid() const      Returns \c true if this property is valid (readable); otherwise     returns \c false.      \sa isReadable() */
end_comment
begin_comment
comment|/*!     \fn const QMetaObject *QMetaProperty::enclosingMetaObject() const     \internal */
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QMetaProperty
name|QMetaProperty
operator|::
name|QMetaProperty
parameter_list|()
member_init_list|:
name|mobj
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|handle
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|idx
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Returns this property's name.      \sa type(), typeName() */
end_comment
begin_function
DECL|function|name
specifier|const
name|char
modifier|*
name|QMetaProperty
operator|::
name|name
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
name|int
name|handle
init|=
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyData
operator|+
literal|3
operator|*
name|idx
decl_stmt|;
return|return
name|rawStringData
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of this property's type.      \sa type(), name() */
end_comment
begin_function
DECL|function|typeName
specifier|const
name|char
modifier|*
name|QMetaProperty
operator|::
name|typeName
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
name|int
name|handle
init|=
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyData
operator|+
literal|3
operator|*
name|idx
decl_stmt|;
return|return
name|rawTypeNameFromTypeInfo
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|1
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns this property's type. The return value is one     of the values of the QVariant::Type enumeration.      \sa userType(), typeName(), name() */
end_comment
begin_function
DECL|function|type
name|QVariant
operator|::
name|Type
name|QMetaProperty
operator|::
name|type
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
name|QVariant
operator|::
name|Invalid
return|;
name|int
name|handle
init|=
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyData
operator|+
literal|3
operator|*
name|idx
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|uint
name|type
init|=
name|typeFromTypeInfo
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|QMetaType
operator|::
name|User
condition|)
return|return
name|QVariant
operator|::
name|UserType
return|;
if|if
condition|(
name|type
operator|!=
name|QMetaType
operator|::
name|UnknownType
condition|)
return|return
name|QVariant
operator|::
name|Type
argument_list|(
name|type
argument_list|)
return|;
if|if
condition|(
name|isEnumType
argument_list|()
condition|)
block|{
name|int
name|enumMetaTypeId
init|=
name|QMetaType
operator|::
name|type
argument_list|(
name|qualifiedName
argument_list|(
name|menum
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|enumMetaTypeId
operator|==
name|QMetaType
operator|::
name|UnknownType
condition|)
return|return
name|QVariant
operator|::
name|Int
return|;
block|}
ifdef|#
directive|ifdef
name|QT_COORD_TYPE
comment|// qreal metatype must be resolved at runtime.
if|if
condition|(
name|strcmp
argument_list|(
name|typeName
argument_list|()
argument_list|,
literal|"qreal"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QVariant
operator|::
name|Type
argument_list|(
name|qMetaTypeId
argument_list|<
name|qreal
argument_list|>
argument_list|()
argument_list|)
return|;
endif|#
directive|endif
return|return
name|QVariant
operator|::
name|UserType
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns this property's user type. The return value is one     of the values that are registered with QMetaType, or QMetaType::UnknownType if     the type is not registered.      \sa type(), QMetaType, typeName()  */
end_comment
begin_function
DECL|function|userType
name|int
name|QMetaProperty
operator|::
name|userType
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
name|QMetaType
operator|::
name|UnknownType
return|;
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|int
name|handle
init|=
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyData
operator|+
literal|3
operator|*
name|idx
decl_stmt|;
name|int
name|type
init|=
name|typeFromTypeInfo
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|QMetaType
operator|::
name|UnknownType
condition|)
return|return
name|type
return|;
if|if
condition|(
name|isEnumType
argument_list|()
condition|)
block|{
name|type
operator|=
name|QMetaType
operator|::
name|type
argument_list|(
name|qualifiedName
argument_list|(
name|menum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|QMetaType
operator|::
name|UnknownType
condition|)
block|{
name|type
operator|=
name|registerPropertyType
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|QMetaType
operator|::
name|UnknownType
condition|)
return|return
name|QVariant
operator|::
name|Int
return|;
comment|// Match behavior of QMetaType::type()
block|}
return|return
name|type
return|;
block|}
name|type
operator|=
name|QMetaType
operator|::
name|type
argument_list|(
name|typeName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|QMetaType
operator|::
name|UnknownType
condition|)
return|return
name|type
return|;
return|return
name|registerPropertyType
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.6    Returns this property's index. */
end_comment
begin_function
DECL|function|propertyIndex
name|int
name|QMetaProperty
operator|::
name|propertyIndex
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|idx
operator|+
name|mobj
operator|->
name|propertyOffset
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the property's type is an enumeration value that     is used as a flag; otherwise returns \c false.      Flags can be combined using the OR operator. A flag type is     implicitly also an enum type.      \sa isEnumType(), enumerator(), QMetaEnum::isFlag() */
end_comment
begin_function
DECL|function|isFlagType
name|bool
name|QMetaProperty
operator|::
name|isFlagType
parameter_list|()
specifier|const
block|{
return|return
name|isEnumType
argument_list|()
operator|&&
name|menum
operator|.
name|isFlag
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the property's type is an enumeration value;     otherwise returns \c false.      \sa enumerator(), isFlagType() */
end_comment
begin_function
DECL|function|isEnumType
name|bool
name|QMetaProperty
operator|::
name|isEnumType
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|int
name|handle
init|=
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyData
operator|+
literal|3
operator|*
name|idx
decl_stmt|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
return|return
operator|(
name|flags
operator|&
name|EnumOrFlag
operator|)
operator|&&
name|menum
operator|.
name|name
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns \c true if the property has a C++ setter function that     follows Qt's standard "name" / "setName" pattern. Designer and uic     query hasStdCppSet() in order to avoid expensive     QObject::setProperty() calls. All properties in Qt [should] follow     this pattern. */
end_comment
begin_function
DECL|function|hasStdCppSet
name|bool
name|QMetaProperty
operator|::
name|hasStdCppSet
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|int
name|handle
init|=
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyData
operator|+
literal|3
operator|*
name|idx
decl_stmt|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
return|return
operator|(
name|flags
operator|&
name|StdCppSet
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Executes metacall with QMetaObject::RegisterPropertyMetaType flag.     Returns id of registered type or QMetaType::UnknownType if a type     could not be registered for any reason. */
end_comment
begin_function
DECL|function|registerPropertyType
name|int
name|QMetaProperty
operator|::
name|registerPropertyType
parameter_list|()
specifier|const
block|{
name|int
name|registerResult
init|=
operator|-
literal|1
decl_stmt|;
name|void
modifier|*
name|argv
index|[]
init|=
block|{
operator|&
name|registerResult
block|}
decl_stmt|;
name|mobj
operator|->
name|static_metacall
argument_list|(
name|QMetaObject
operator|::
name|RegisterPropertyMetaType
argument_list|,
name|idx
argument_list|,
name|argv
argument_list|)
expr_stmt|;
return|return
name|registerResult
operator|==
operator|-
literal|1
condition|?
name|QMetaType
operator|::
name|UnknownType
else|:
name|registerResult
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the enumerator if this property's type is an enumerator     type; otherwise the returned value is undefined.      \sa isEnumType(), isFlagType() */
end_comment
begin_function
DECL|function|enumerator
name|QMetaEnum
name|QMetaProperty
operator|::
name|enumerator
parameter_list|()
specifier|const
block|{
return|return
name|menum
return|;
block|}
end_function
begin_comment
comment|/*!     Reads the property's value from the given \a object. Returns the value     if it was able to read it; otherwise returns an invalid variant.      \sa write(), reset(), isReadable() */
end_comment
begin_function
DECL|function|read
name|QVariant
name|QMetaProperty
operator|::
name|read
parameter_list|(
specifier|const
name|QObject
modifier|*
name|object
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|object
operator|||
operator|!
name|mobj
condition|)
return|return
name|QVariant
argument_list|()
return|;
name|uint
name|t
init|=
name|QVariant
operator|::
name|Int
decl_stmt|;
if|if
condition|(
name|isEnumType
argument_list|()
condition|)
block|{
comment|/*           try to create a QVariant that can be converted to this enum           type (only works if the enum has already been registered           with QMetaType)         */
name|int
name|enumMetaTypeId
init|=
name|QMetaType
operator|::
name|type
argument_list|(
name|qualifiedName
argument_list|(
name|menum
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|enumMetaTypeId
operator|!=
name|QMetaType
operator|::
name|UnknownType
condition|)
name|t
operator|=
name|enumMetaTypeId
expr_stmt|;
block|}
else|else
block|{
name|int
name|handle
init|=
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyData
operator|+
literal|3
operator|*
name|idx
decl_stmt|;
specifier|const
name|char
modifier|*
name|typeName
init|=
literal|0
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|uint
name|typeInfo
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|typeInfo
operator|&
name|IsUnresolvedType
operator|)
condition|)
name|t
operator|=
name|typeInfo
expr_stmt|;
else|else
block|{
name|typeName
operator|=
name|rawStringData
argument_list|(
name|mobj
argument_list|,
name|typeInfo
operator|&
name|TypeNameIndexMask
argument_list|)
expr_stmt|;
name|t
operator|=
name|QMetaType
operator|::
name|type
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|QMetaType
operator|::
name|UnknownType
condition|)
block|{
comment|// Try to register the type and try again before reporting an error.
name|t
operator|=
name|registerPropertyType
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|QMetaType
operator|::
name|UnknownType
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMetaProperty::read: Unable to handle unregistered datatype '%s' for property '%s::%s'"
argument_list|,
name|typeName
argument_list|,
name|mobj
operator|->
name|className
argument_list|()
argument_list|,
name|name
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
block|}
block|}
comment|// the status variable is changed by qt_metacall to indicate what it did
comment|// this feature is currently only used by Qt D-Bus and should not be depended
comment|// upon. Don't change it without looking into QDBusAbstractInterface first
comment|// -1 (unchanged): normal qt_metacall, result stored in argv[0]
comment|// changed: result stored directly in value
name|int
name|status
init|=
operator|-
literal|1
decl_stmt|;
name|QVariant
name|value
decl_stmt|;
name|void
modifier|*
name|argv
index|[]
init|=
block|{
literal|0
block|,
operator|&
name|value
block|,
operator|&
name|status
block|}
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|QMetaType
operator|::
name|QVariant
condition|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
operator|&
name|value
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|QVariant
argument_list|(
name|t
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|value
operator|.
name|data
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|flags
operator|&
name|PropertyAccessInStaticMetaCall
operator|&&
name|mobj
operator|->
name|d
operator|.
name|static_metacall
condition|)
block|{
name|mobj
operator|->
name|d
operator|.
name|static_metacall
argument_list|(
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
argument_list|,
name|QMetaObject
operator|::
name|ReadProperty
argument_list|,
name|idx
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QMetaObject
operator|::
name|metacall
argument_list|(
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
argument_list|,
name|QMetaObject
operator|::
name|ReadProperty
argument_list|,
name|idx
operator|+
name|mobj
operator|->
name|propertyOffset
argument_list|()
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
operator|-
literal|1
condition|)
return|return
name|value
return|;
if|if
condition|(
name|t
operator|!=
name|QMetaType
operator|::
name|QVariant
operator|&&
name|argv
index|[
literal|0
index|]
operator|!=
name|value
operator|.
name|data
argument_list|()
condition|)
comment|// pointer or reference
return|return
name|QVariant
argument_list|(
operator|(
name|QVariant
operator|::
name|Type
operator|)
name|t
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
return|;
return|return
name|value
return|;
block|}
end_function
begin_comment
comment|/*!     Writes \a value as the property's value to the given \a object. Returns     true if the write succeeded; otherwise returns \c false.      \sa read(), reset(), isWritable() */
end_comment
begin_function
DECL|function|write
name|bool
name|QMetaProperty
operator|::
name|write
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|object
operator|||
operator|!
name|isWritable
argument_list|()
condition|)
return|return
literal|false
return|;
name|QVariant
name|v
init|=
name|value
decl_stmt|;
name|uint
name|t
init|=
name|QVariant
operator|::
name|Invalid
decl_stmt|;
if|if
condition|(
name|isEnumType
argument_list|()
condition|)
block|{
if|if
condition|(
name|v
operator|.
name|type
argument_list|()
operator|==
name|QVariant
operator|::
name|String
condition|)
block|{
name|bool
name|ok
decl_stmt|;
if|if
condition|(
name|isFlagType
argument_list|()
condition|)
name|v
operator|=
name|QVariant
argument_list|(
name|menum
operator|.
name|keysToValue
argument_list|(
name|value
operator|.
name|toByteArray
argument_list|()
argument_list|,
operator|&
name|ok
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|QVariant
argument_list|(
name|menum
operator|.
name|keyToValue
argument_list|(
name|value
operator|.
name|toByteArray
argument_list|()
argument_list|,
operator|&
name|ok
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|v
operator|.
name|type
argument_list|()
operator|!=
name|QVariant
operator|::
name|Int
operator|&&
name|v
operator|.
name|type
argument_list|()
operator|!=
name|QVariant
operator|::
name|UInt
condition|)
block|{
name|int
name|enumMetaTypeId
init|=
name|QMetaType
operator|::
name|type
argument_list|(
name|qualifiedName
argument_list|(
name|menum
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|enumMetaTypeId
operator|==
name|QMetaType
operator|::
name|UnknownType
operator|)
operator|||
operator|(
name|v
operator|.
name|userType
argument_list|()
operator|!=
name|enumMetaTypeId
operator|)
operator|||
operator|!
name|v
operator|.
name|constData
argument_list|()
condition|)
return|return
literal|false
return|;
name|v
operator|=
name|QVariant
argument_list|(
operator|*
cast|reinterpret_cast
argument_list|<
specifier|const
name|int
operator|*
argument_list|>
argument_list|(
name|v
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|v
operator|.
name|convert
argument_list|(
name|QVariant
operator|::
name|Int
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|handle
init|=
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyData
operator|+
literal|3
operator|*
name|idx
decl_stmt|;
specifier|const
name|char
modifier|*
name|typeName
init|=
literal|0
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|revision
operator|>=
literal|7
argument_list|)
expr_stmt|;
name|uint
name|typeInfo
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|typeInfo
operator|&
name|IsUnresolvedType
operator|)
condition|)
name|t
operator|=
name|typeInfo
expr_stmt|;
else|else
block|{
name|typeName
operator|=
name|rawStringData
argument_list|(
name|mobj
argument_list|,
name|typeInfo
operator|&
name|TypeNameIndexMask
argument_list|)
expr_stmt|;
name|t
operator|=
name|QMetaType
operator|::
name|type
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|QMetaType
operator|::
name|UnknownType
condition|)
name|t
operator|=
name|registerPropertyType
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|QMetaType
operator|::
name|UnknownType
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|t
operator|!=
name|QMetaType
operator|::
name|QVariant
operator|&&
name|t
operator|!=
operator|(
name|uint
operator|)
name|value
operator|.
name|userType
argument_list|()
operator|&&
operator|(
name|t
operator|<
name|QMetaType
operator|::
name|User
operator|&&
operator|!
name|v
operator|.
name|convert
argument_list|(
operator|(
name|QVariant
operator|::
name|Type
operator|)
name|t
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
block|}
comment|// the status variable is changed by qt_metacall to indicate what it did
comment|// this feature is currently only used by Qt D-Bus and should not be depended
comment|// upon. Don't change it without looking into QDBusAbstractInterface first
comment|// -1 (unchanged): normal qt_metacall, result stored in argv[0]
comment|// changed: result stored directly in value, return the value of status
name|int
name|status
init|=
operator|-
literal|1
decl_stmt|;
comment|// the flags variable is used by the declarative module to implement
comment|// interception of property writes.
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|argv
index|[]
init|=
block|{
literal|0
block|,
operator|&
name|v
block|,
operator|&
name|status
block|,
operator|&
name|flags
block|}
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|QMetaType
operator|::
name|QVariant
condition|)
name|argv
index|[
literal|0
index|]
operator|=
operator|&
name|v
expr_stmt|;
else|else
name|argv
index|[
literal|0
index|]
operator|=
name|v
operator|.
name|data
argument_list|()
expr_stmt|;
if|if
condition|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|flags
operator|&
name|PropertyAccessInStaticMetaCall
operator|&&
name|mobj
operator|->
name|d
operator|.
name|static_metacall
condition|)
name|mobj
operator|->
name|d
operator|.
name|static_metacall
argument_list|(
name|object
argument_list|,
name|QMetaObject
operator|::
name|WriteProperty
argument_list|,
name|idx
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
name|QMetaObject
operator|::
name|metacall
argument_list|(
name|object
argument_list|,
name|QMetaObject
operator|::
name|WriteProperty
argument_list|,
name|idx
operator|+
name|mobj
operator|->
name|propertyOffset
argument_list|()
argument_list|,
name|argv
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function
begin_comment
comment|/*!     Resets the property for the given \a object with a reset method.     Returns \c true if the reset worked; otherwise returns \c false.      Reset methods are optional; only a few properties support them.      \sa read(), write() */
end_comment
begin_function
DECL|function|reset
name|bool
name|QMetaProperty
operator|::
name|reset
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|object
operator|||
operator|!
name|mobj
operator|||
operator|!
name|isResettable
argument_list|()
condition|)
return|return
literal|false
return|;
name|void
modifier|*
name|argv
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|flags
operator|&
name|PropertyAccessInStaticMetaCall
operator|&&
name|mobj
operator|->
name|d
operator|.
name|static_metacall
condition|)
name|mobj
operator|->
name|d
operator|.
name|static_metacall
argument_list|(
name|object
argument_list|,
name|QMetaObject
operator|::
name|ResetProperty
argument_list|,
name|idx
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
name|QMetaObject
operator|::
name|metacall
argument_list|(
name|object
argument_list|,
name|QMetaObject
operator|::
name|ResetProperty
argument_list|,
name|idx
operator|+
name|mobj
operator|->
name|propertyOffset
argument_list|()
argument_list|,
name|argv
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.5      Reads the property's value from the given \a gadget. Returns the value     if it was able to read it; otherwise returns an invalid variant.      This function should only be used if this is a property of a Q_GADGET */
end_comment
begin_function
DECL|function|readOnGadget
name|QVariant
name|QMetaProperty
operator|::
name|readOnGadget
parameter_list|(
specifier|const
name|void
modifier|*
name|gadget
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|flags
operator|&
name|PropertyAccessInStaticMetaCall
operator|&&
name|mobj
operator|->
name|d
operator|.
name|static_metacall
argument_list|)
expr_stmt|;
return|return
name|read
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|QObject
operator|*
argument_list|>
argument_list|(
name|gadget
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.5      Writes \a value as the property's value to the given \a gadget. Returns     true if the write succeeded; otherwise returns \c false.      This function should only be used if this is a property of a Q_GADGET */
end_comment
begin_function
DECL|function|writeOnGadget
name|bool
name|QMetaProperty
operator|::
name|writeOnGadget
parameter_list|(
name|void
modifier|*
name|gadget
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|flags
operator|&
name|PropertyAccessInStaticMetaCall
operator|&&
name|mobj
operator|->
name|d
operator|.
name|static_metacall
argument_list|)
expr_stmt|;
return|return
name|write
argument_list|(
cast|reinterpret_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|gadget
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.5      Resets the property for the given \a gadget with a reset method.     Returns \c true if the reset worked; otherwise returns \c false.      Reset methods are optional; only a few properties support them.      This function should only be used if this is a property of a Q_GADGET */
end_comment
begin_function
DECL|function|resetOnGadget
name|bool
name|QMetaProperty
operator|::
name|resetOnGadget
parameter_list|(
name|void
modifier|*
name|gadget
parameter_list|)
specifier|const
block|{
name|Q_ASSERT
argument_list|(
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|flags
operator|&
name|PropertyAccessInStaticMetaCall
operator|&&
name|mobj
operator|->
name|d
operator|.
name|static_metacall
argument_list|)
expr_stmt|;
return|return
name|reset
argument_list|(
cast|reinterpret_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|gadget
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this property can be reset to a default value; otherwise     returns \c false.      \sa reset() */
end_comment
begin_function
DECL|function|isResettable
name|bool
name|QMetaProperty
operator|::
name|isResettable
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
return|return
name|flags
operator|&
name|Resettable
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this property is readable; otherwise returns \c false.      \sa isWritable(), read(), isValid()  */
end_comment
begin_function
DECL|function|isReadable
name|bool
name|QMetaProperty
operator|::
name|isReadable
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
return|return
name|flags
operator|&
name|Readable
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this property has a corresponding change notify signal;     otherwise returns \c false.      \sa notifySignal()  */
end_comment
begin_function
DECL|function|hasNotifySignal
name|bool
name|QMetaProperty
operator|::
name|hasNotifySignal
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
return|return
name|flags
operator|&
name|Notify
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the QMetaMethod instance of the property change notifying signal if     one was specified, otherwise returns an invalid QMetaMethod.      \sa hasNotifySignal()  */
end_comment
begin_function
DECL|function|notifySignal
name|QMetaMethod
name|QMetaProperty
operator|::
name|notifySignal
parameter_list|()
specifier|const
block|{
name|int
name|id
init|=
name|notifySignalIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|id
operator|!=
operator|-
literal|1
condition|)
return|return
name|mobj
operator|->
name|method
argument_list|(
name|id
argument_list|)
return|;
else|else
return|return
name|QMetaMethod
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns the index of the property change notifying signal if one was     specified, otherwise returns -1.      \sa hasNotifySignal()  */
end_comment
begin_function
DECL|function|notifySignalIndex
name|int
name|QMetaProperty
operator|::
name|notifySignalIndex
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|hasNotifySignal
argument_list|()
condition|)
block|{
name|int
name|offset
init|=
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyData
operator|+
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyCount
operator|*
literal|3
operator|+
name|idx
decl_stmt|;
return|return
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|offset
index|]
operator|+
name|mobj
operator|->
name|methodOffset
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function
begin_comment
comment|// This method has been around for a while, but the documentation was marked \internal until 5.1
end_comment
begin_comment
comment|/*!     \since 5.1      Returns the property revision if one was     specified by REVISION, otherwise returns 0.  */
end_comment
begin_function
DECL|function|revision
name|int
name|QMetaProperty
operator|::
name|revision
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|Revisioned
condition|)
block|{
name|int
name|offset
init|=
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyData
operator|+
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyCount
operator|*
literal|3
operator|+
name|idx
decl_stmt|;
comment|// Revision data is placed after NOTIFY data, if present.
comment|// Iterate through properties to discover whether we have NOTIFY signals.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyCount
condition|;
operator|++
name|i
control|)
block|{
name|int
name|handle
init|=
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyData
operator|+
literal|3
operator|*
name|i
decl_stmt|;
if|if
condition|(
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
operator|&
name|Notify
condition|)
block|{
name|offset
operator|+=
name|priv
argument_list|(
name|mobj
operator|->
name|d
operator|.
name|data
argument_list|)
operator|->
name|propertyCount
expr_stmt|;
break|break;
block|}
block|}
return|return
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|offset
index|]
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this property is writable; otherwise returns     false.      \sa isReadable(), write()  */
end_comment
begin_function
DECL|function|isWritable
name|bool
name|QMetaProperty
operator|::
name|isWritable
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
return|return
name|flags
operator|&
name|Writable
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this property is designable for the given \a object;     otherwise returns \c false.      If no \a object is given, the function returns \c false if the     \c{Q_PROPERTY()}'s \c DESIGNABLE attribute is false; otherwise     returns \c true (if the attribute is true or is a function or expression).      \sa isScriptable(), isStored() */
end_comment
begin_function
DECL|function|isDesignable
name|bool
name|QMetaProperty
operator|::
name|isDesignable
parameter_list|(
specifier|const
name|QObject
modifier|*
name|object
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
name|bool
name|b
init|=
name|flags
operator|&
name|Designable
decl_stmt|;
if|if
condition|(
name|object
condition|)
block|{
name|void
modifier|*
name|argv
index|[]
init|=
block|{
operator|&
name|b
block|}
decl_stmt|;
name|QMetaObject
operator|::
name|metacall
argument_list|(
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
argument_list|,
name|QMetaObject
operator|::
name|QueryPropertyDesignable
argument_list|,
name|idx
operator|+
name|mobj
operator|->
name|propertyOffset
argument_list|()
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the property is scriptable for the given \a object;     otherwise returns \c false.      If no \a object is given, the function returns \c false if the     \c{Q_PROPERTY()}'s \c SCRIPTABLE attribute is false; otherwise returns     true (if the attribute is true or is a function or expression).      \sa isDesignable(), isStored() */
end_comment
begin_function
DECL|function|isScriptable
name|bool
name|QMetaProperty
operator|::
name|isScriptable
parameter_list|(
specifier|const
name|QObject
modifier|*
name|object
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
name|bool
name|b
init|=
name|flags
operator|&
name|Scriptable
decl_stmt|;
if|if
condition|(
name|object
condition|)
block|{
name|void
modifier|*
name|argv
index|[]
init|=
block|{
operator|&
name|b
block|}
decl_stmt|;
name|QMetaObject
operator|::
name|metacall
argument_list|(
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
argument_list|,
name|QMetaObject
operator|::
name|QueryPropertyScriptable
argument_list|,
name|idx
operator|+
name|mobj
operator|->
name|propertyOffset
argument_list|()
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the property is stored for \a object; otherwise returns     false.      If no \a object is given, the function returns \c false if the     \c{Q_PROPERTY()}'s \c STORED attribute is false; otherwise returns     true (if the attribute is true or is a function or expression).      \sa isDesignable(), isScriptable() */
end_comment
begin_function
DECL|function|isStored
name|bool
name|QMetaProperty
operator|::
name|isStored
parameter_list|(
specifier|const
name|QObject
modifier|*
name|object
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
name|bool
name|b
init|=
name|flags
operator|&
name|Stored
decl_stmt|;
if|if
condition|(
name|object
condition|)
block|{
name|void
modifier|*
name|argv
index|[]
init|=
block|{
operator|&
name|b
block|}
decl_stmt|;
name|QMetaObject
operator|::
name|metacall
argument_list|(
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
argument_list|,
name|QMetaObject
operator|::
name|QueryPropertyStored
argument_list|,
name|idx
operator|+
name|mobj
operator|->
name|propertyOffset
argument_list|()
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if this property is designated as the \c USER     property, i.e., the one that the user can edit for \a object or     that is significant in some other way.  Otherwise it returns     false. e.g., the \c text property is the \c USER editable property     of a QLineEdit.      If \a object is null, the function returns \c false if the \c     {Q_PROPERTY()}'s \c USER attribute is false. Otherwise it returns     true.      \sa QMetaObject::userProperty(), isDesignable(), isScriptable() */
end_comment
begin_function
DECL|function|isUser
name|bool
name|QMetaProperty
operator|::
name|isUser
parameter_list|(
specifier|const
name|QObject
modifier|*
name|object
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
name|bool
name|b
init|=
name|flags
operator|&
name|User
decl_stmt|;
if|if
condition|(
name|object
condition|)
block|{
name|void
modifier|*
name|argv
index|[]
init|=
block|{
operator|&
name|b
block|}
decl_stmt|;
name|QMetaObject
operator|::
name|metacall
argument_list|(
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
argument_list|,
name|QMetaObject
operator|::
name|QueryPropertyUser
argument_list|,
name|idx
operator|+
name|mobj
operator|->
name|propertyOffset
argument_list|()
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Returns \c true if the property is constant; otherwise returns \c false.      A property is constant if the \c{Q_PROPERTY()}'s \c CONSTANT attribute     is set. */
end_comment
begin_function
DECL|function|isConstant
name|bool
name|QMetaProperty
operator|::
name|isConstant
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
return|return
name|flags
operator|&
name|Constant
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Returns \c true if the property is final; otherwise returns \c false.      A property is final if the \c{Q_PROPERTY()}'s \c FINAL attribute     is set. */
end_comment
begin_function
DECL|function|isFinal
name|bool
name|QMetaProperty
operator|::
name|isFinal
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
return|return
name|flags
operator|&
name|Final
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Returns \c true if the property is editable for the given \a object;     otherwise returns \c false.      If no \a object is given, the function returns \c false if the     \c{Q_PROPERTY()}'s \c EDITABLE attribute is false; otherwise returns     true (if the attribute is true or is a function or expression).      \sa isDesignable(), isScriptable(), isStored() */
end_comment
begin_function
DECL|function|isEditable
name|bool
name|QMetaProperty
operator|::
name|isEditable
parameter_list|(
specifier|const
name|QObject
modifier|*
name|object
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|false
return|;
name|int
name|flags
init|=
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|2
index|]
decl_stmt|;
name|bool
name|b
init|=
name|flags
operator|&
name|Editable
decl_stmt|;
if|if
condition|(
name|object
condition|)
block|{
name|void
modifier|*
name|argv
index|[]
init|=
block|{
operator|&
name|b
block|}
decl_stmt|;
name|QMetaObject
operator|::
name|metacall
argument_list|(
cast|const_cast
argument_list|<
name|QObject
operator|*
argument_list|>
argument_list|(
name|object
argument_list|)
argument_list|,
name|QMetaObject
operator|::
name|QueryPropertyEditable
argument_list|,
name|idx
operator|+
name|mobj
operator|->
name|propertyOffset
argument_list|()
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function
begin_comment
comment|/*!     \class QMetaClassInfo     \inmodule QtCore      \brief The QMetaClassInfo class provides additional information     about a class.      \ingroup objectmodel      Class information items are simple \e{name}--\e{value} pairs that     are specified using Q_CLASSINFO() in the source code. The     information can be retrieved using name() and value(). For example:      \snippet code/src_corelib_kernel_qmetaobject.cpp 5      This mechanism is free for you to use in your Qt applications. Qt     doesn't use it for any of its classes.      \sa QMetaObject */
end_comment
begin_comment
comment|/*!     \fn QMetaClassInfo::QMetaClassInfo()     \internal */
end_comment
begin_comment
comment|/*!     \fn const QMetaObject *QMetaClassInfo::enclosingMetaObject() const     \internal */
end_comment
begin_comment
comment|/*!     Returns the name of this item.      \sa value() */
end_comment
begin_function
DECL|function|name
specifier|const
name|char
modifier|*
name|QMetaClassInfo
operator|::
name|name
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
return|return
name|rawStringData
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the value of this item.      \sa name() */
end_comment
begin_function
DECL|function|value
specifier|const
name|char
modifier|*
name|QMetaClassInfo
operator|::
name|value
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|mobj
condition|)
return|return
literal|0
return|;
return|return
name|rawStringData
argument_list|(
name|mobj
argument_list|,
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|1
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \macro QGenericArgument Q_ARG(Type, const Type&value)     \relates QMetaObject      This macro takes a \a Type and a \a value of that type and     returns a \l QGenericArgument object that can be passed to     QMetaObject::invokeMethod().      \sa Q_RETURN_ARG() */
end_comment
begin_comment
comment|/*!     \macro QGenericReturnArgument Q_RETURN_ARG(Type, Type&value)     \relates QMetaObject      This macro takes a \a Type and a non-const reference to a \a     value of that type and returns a QGenericReturnArgument object     that can be passed to QMetaObject::invokeMethod().      \sa Q_ARG() */
end_comment
begin_comment
comment|/*!     \class QGenericArgument     \inmodule QtCore      \brief The QGenericArgument class is an internal helper class for     marshalling arguments.      This class should never be used directly. Please use the \l Q_ARG()     macro instead.      \sa Q_ARG(), QMetaObject::invokeMethod(), QGenericReturnArgument */
end_comment
begin_comment
comment|/*!     \fn QGenericArgument::QGenericArgument(const char *name, const void *data)      Constructs a QGenericArgument object with the given \a name and \a data. */
end_comment
begin_comment
comment|/*!     \fn QGenericArgument::data () const      Returns the data set in the constructor. */
end_comment
begin_comment
comment|/*!     \fn QGenericArgument::name () const      Returns the name set in the constructor. */
end_comment
begin_comment
comment|/*!     \class QGenericReturnArgument     \inmodule QtCore      \brief The QGenericReturnArgument class is an internal helper class for     marshalling arguments.      This class should never be used directly. Please use the     Q_RETURN_ARG() macro instead.      \sa Q_RETURN_ARG(), QMetaObject::invokeMethod(), QGenericArgument */
end_comment
begin_comment
comment|/*!     \fn QGenericReturnArgument::QGenericReturnArgument(const char *name, void *data)      Constructs a QGenericReturnArgument object with the given \a name     and \a data. */
end_comment
begin_comment
comment|/*!     \internal     If the local_method_index is a cloned method, return the index of the original.      Example: if the index of "destroyed()" is passed, the index of "destroyed(QObject*)" is returned  */
end_comment
begin_function
DECL|function|originalClone
name|int
name|QMetaObjectPrivate
operator|::
name|originalClone
parameter_list|(
specifier|const
name|QMetaObject
modifier|*
name|mobj
parameter_list|,
name|int
name|local_method_index
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|local_method_index
operator|<
name|get
argument_list|(
name|mobj
argument_list|)
operator|->
name|methodCount
argument_list|)
expr_stmt|;
name|int
name|handle
init|=
name|get
argument_list|(
name|mobj
argument_list|)
operator|->
name|methodData
operator|+
literal|5
operator|*
name|local_method_index
decl_stmt|;
while|while
condition|(
name|mobj
operator|->
name|d
operator|.
name|data
index|[
name|handle
operator|+
literal|4
index|]
operator|&
name|MethodCloned
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|local_method_index
operator|>
literal|0
argument_list|)
expr_stmt|;
name|handle
operator|-=
literal|5
expr_stmt|;
name|local_method_index
operator|--
expr_stmt|;
block|}
return|return
name|local_method_index
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the parameter type names extracted from the given \a signature. */
end_comment
begin_function
DECL|function|parameterTypeNamesFromSignature
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QMetaObjectPrivate
operator|::
name|parameterTypeNamesFromSignature
parameter_list|(
specifier|const
name|char
modifier|*
name|signature
parameter_list|)
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
decl_stmt|;
while|while
condition|(
operator|*
name|signature
operator|&&
operator|*
name|signature
operator|!=
literal|'('
condition|)
operator|++
name|signature
expr_stmt|;
while|while
condition|(
operator|*
name|signature
operator|&&
operator|*
name|signature
operator|!=
literal|')'
operator|&&
operator|*
operator|++
name|signature
operator|!=
literal|')'
condition|)
block|{
specifier|const
name|char
modifier|*
name|begin
init|=
name|signature
decl_stmt|;
name|int
name|level
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|signature
operator|&&
operator|(
name|level
operator|>
literal|0
operator|||
operator|*
name|signature
operator|!=
literal|','
operator|)
operator|&&
operator|*
name|signature
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
operator|*
name|signature
operator|==
literal|'<'
condition|)
operator|++
name|level
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|signature
operator|==
literal|'>'
condition|)
operator|--
name|level
expr_stmt|;
operator|++
name|signature
expr_stmt|;
block|}
name|list
operator|+=
name|QByteArray
argument_list|(
name|begin
argument_list|,
name|signature
operator|-
name|begin
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
