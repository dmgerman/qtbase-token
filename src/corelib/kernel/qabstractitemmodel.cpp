begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qabstractitemmodel.h"
end_include
begin_include
include|#
directive|include
file|<private/qabstractitemmodel_p.h>
end_include
begin_include
include|#
directive|include
file|<qdatastream.h>
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qsize.h>
end_include
begin_include
include|#
directive|include
file|<qmimedata.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qvector.h>
end_include
begin_include
include|#
directive|include
file|<qstack.h>
end_include
begin_include
include|#
directive|include
file|<qbitarray.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|create
name|QPersistentModelIndexData
modifier|*
name|QPersistentModelIndexData
operator|::
name|create
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|index
operator|.
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
comment|// we will _never_ insert an invalid index in the list
name|QPersistentModelIndexData
modifier|*
name|d
init|=
literal|0
decl_stmt|;
name|QAbstractItemModel
modifier|*
name|model
init|=
cast|const_cast
argument_list|<
name|QAbstractItemModel
operator|*
argument_list|>
argument_list|(
name|index
operator|.
name|model
argument_list|()
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
modifier|*
argument_list|>
modifier|&
name|indexes
init|=
name|model
operator|->
name|d_func
argument_list|()
operator|->
name|persistent
operator|.
name|indexes
decl_stmt|;
specifier|const
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
modifier|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|indexes
operator|.
name|find
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|indexes
operator|.
name|end
argument_list|()
condition|)
block|{
name|d
operator|=
operator|(
operator|*
name|it
operator|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
operator|new
name|QPersistentModelIndexData
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|indexes
operator|.
name|insert
argument_list|(
name|index
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|destroy
name|void
name|QPersistentModelIndexData
operator|::
name|destroy
parameter_list|(
name|QPersistentModelIndexData
modifier|*
name|data
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|data
operator|->
name|ref
operator|==
literal|0
argument_list|)
expr_stmt|;
name|QAbstractItemModel
modifier|*
name|model
init|=
cast|const_cast
argument_list|<
name|QAbstractItemModel
operator|*
argument_list|>
argument_list|(
name|data
operator|->
name|model
argument_list|)
decl_stmt|;
comment|// a valid persistent model index with a null model pointer can only happen if the model was destroyed
if|if
condition|(
name|model
condition|)
block|{
name|QAbstractItemModelPrivate
modifier|*
name|p
init|=
name|model
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|removePersistentIndexData
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
operator|delete
name|data
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \class QPersistentModelIndex    \brief The QPersistentModelIndex class is used to locate data in a data model.    \ingroup model-view    A QPersistentModelIndex is a model index that can be stored by an   application, and later used to access information in a model.   Unlike the QModelIndex class, it is safe to store a   QPersistentModelIndex since the model will ensure that references   to items will continue to be valid as long as they can be accessed   by the model.    It is good practice to check that persistent model indexes are valid   before using them.    \sa {Model/View Programming}, QModelIndex, QAbstractItemModel */
end_comment
begin_comment
comment|/*!   \fn QPersistentModelIndex::QPersistentModelIndex()    \internal */
end_comment
begin_constructor
DECL|function|QPersistentModelIndex
name|QPersistentModelIndex
operator|::
name|QPersistentModelIndex
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   \fn QPersistentModelIndex::QPersistentModelIndex(const QPersistentModelIndex&other)    Creates a new QPersistentModelIndex that is a copy of the \a other persistent   model index. */
end_comment
begin_constructor
DECL|function|QPersistentModelIndex
name|QPersistentModelIndex
operator|::
name|QPersistentModelIndex
parameter_list|(
specifier|const
name|QPersistentModelIndex
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a new QPersistentModelIndex that is a copy of the model \a index. */
end_comment
begin_constructor
DECL|function|QPersistentModelIndex
name|QPersistentModelIndex
operator|::
name|QPersistentModelIndex
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
name|index
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|d
operator|=
name|QPersistentModelIndexData
operator|::
name|create
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
block|}
end_constructor
begin_comment
comment|/*!     \fn QPersistentModelIndex::~QPersistentModelIndex()      \internal */
end_comment
begin_destructor
DECL|function|~QPersistentModelIndex
name|QPersistentModelIndex
operator|::
name|~
name|QPersistentModelIndex
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
block|{
name|QPersistentModelIndexData
operator|::
name|destroy
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_destructor
begin_comment
comment|/*!   Returns true if this persistent model index is equal to the \a other   persistent model index; otherwise returns false.    All values in the persistent model index are used when comparing   with another persistent model index. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QPersistentModelIndex
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QPersistentModelIndex
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|&&
name|other
operator|.
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|==
name|other
operator|.
name|d
operator|->
name|index
return|;
return|return
name|d
operator|==
name|other
operator|.
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns true if this persistent model index is smaller than the \a other     persistent model index; otherwise returns false.      All values in the persistent model index are used when comparing     with another persistent model index. */
end_comment
begin_function
DECL|function|operator <
name|bool
name|QPersistentModelIndex
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QPersistentModelIndex
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|&&
name|other
operator|.
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|<
name|other
operator|.
name|d
operator|->
name|index
return|;
return|return
name|d
operator|<
name|other
operator|.
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPersistentModelIndex::operator!=(const QPersistentModelIndex&other) const     \since 4.2      Returns true if this persistent model index is not equal to the \a     other persistent model index; otherwise returns false. */
end_comment
begin_comment
comment|/*!     Sets the persistent model index to refer to the same item in a model     as the \a other persistent model index. */
end_comment
begin_function
DECL|function|operator =
name|QPersistentModelIndex
modifier|&
name|QPersistentModelIndex
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QPersistentModelIndex
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|d
operator|==
name|other
operator|.
name|d
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|QPersistentModelIndexData
operator|::
name|destroy
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the persistent model index to refer to the same item in a model     as the \a other model index. */
end_comment
begin_function
DECL|function|operator =
name|QPersistentModelIndex
modifier|&
name|QPersistentModelIndex
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
name|QPersistentModelIndexData
operator|::
name|destroy
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|other
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|d
operator|=
name|QPersistentModelIndexData
operator|::
name|create
argument_list|(
name|other
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
else|else
block|{
name|d
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   \fn QPersistentModelIndex::operator const QModelIndex&() const    Cast operator that returns a const QModelIndex&. */
end_comment
begin_function
DECL|function|operator const QModelIndex&
name|QPersistentModelIndex
operator|::
name|operator
name|const QModelIndex&
parameter_list|()
specifier|const
block|{
specifier|static
specifier|const
name|QModelIndex
name|invalid
decl_stmt|;
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|index
return|;
return|return
name|invalid
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPersistentModelIndex::operator==(const QModelIndex&other) const      Returns true if this persistent model index refers to the same location as     the \a other model index; otherwise returns false.      All values in the persistent model index are used when comparing with     another model index. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QPersistentModelIndex
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|==
name|other
return|;
return|return
operator|!
name|other
operator|.
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPersistentModelIndex::operator!=(const QModelIndex&other) const      Returns true if this persistent model index does not refer to the same     location as the \a other model index; otherwise returns false. */
end_comment
begin_function
DECL|function|operator !=
name|bool
name|QPersistentModelIndex
operator|::
name|operator
name|!=
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|!=
name|other
return|;
return|return
name|other
operator|.
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QPersistentModelIndex::row() const      Returns the row this persistent model index refers to. */
end_comment
begin_function
DECL|function|row
name|int
name|QPersistentModelIndex
operator|::
name|row
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|.
name|row
argument_list|()
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \fn int QPersistentModelIndex::column() const      Returns the column this persistent model index refers to. */
end_comment
begin_function
DECL|function|column
name|int
name|QPersistentModelIndex
operator|::
name|column
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|.
name|column
argument_list|()
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void *QPersistentModelIndex::internalPointer() const      \internal      Returns a \c{void} \c{*} pointer used by the model to associate the index with     the internal data structure. */
end_comment
begin_function
DECL|function|internalPointer
name|void
modifier|*
name|QPersistentModelIndex
operator|::
name|internalPointer
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|.
name|internalPointer
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void *QPersistentModelIndex::internalId() const      \internal      Returns a \c{qint64} used by the model to associate the index with     the internal data structure. */
end_comment
begin_function
DECL|function|internalId
name|qint64
name|QPersistentModelIndex
operator|::
name|internalId
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|.
name|internalId
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the parent QModelIndex for this persistent index, or an invalid     QModelIndex if it has no parent.      \sa child() sibling() model() */
end_comment
begin_function
DECL|function|parent
name|QModelIndex
name|QPersistentModelIndex
operator|::
name|parent
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|.
name|parent
argument_list|()
return|;
return|return
name|QModelIndex
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the sibling at \a row and \a column or an invalid QModelIndex if     there is no sibling at this position.      \sa parent() child() */
end_comment
begin_function
DECL|function|sibling
name|QModelIndex
name|QPersistentModelIndex
operator|::
name|sibling
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|.
name|sibling
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
return|;
return|return
name|QModelIndex
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the child of the model index that is stored in the given \a row     and \a column.      \sa parent() sibling() */
end_comment
begin_function
DECL|function|child
name|QModelIndex
name|QPersistentModelIndex
operator|::
name|child
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|.
name|child
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
return|;
return|return
name|QModelIndex
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the data for the given \a role for the item referred to by the     index.      \sa Qt::ItemDataRole, QAbstractItemModel::setData() */
end_comment
begin_function
DECL|function|data
name|QVariant
name|QPersistentModelIndex
operator|::
name|data
parameter_list|(
name|int
name|role
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|.
name|data
argument_list|(
name|role
argument_list|)
return|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the flags for the item referred to by the index. */
end_comment
begin_function
DECL|function|flags
name|Qt
operator|::
name|ItemFlags
name|QPersistentModelIndex
operator|::
name|flags
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|.
name|flags
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the model that the index belongs to. */
end_comment
begin_function
DECL|function|model
specifier|const
name|QAbstractItemModel
modifier|*
name|QPersistentModelIndex
operator|::
name|model
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|index
operator|.
name|model
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QPersistentModelIndex::isValid() const      Returns true if this persistent model index is valid; otherwise returns     false.      A valid index belongs to a model, and has non-negative row and column     numbers.      \sa model(), row(), column() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QPersistentModelIndex
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|&&
name|d
operator|->
name|index
operator|.
name|isValid
argument_list|()
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|idx
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|Q_BROKEN_DEBUG_STREAM
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QModelIndex("
operator|<<
name|idx
operator|.
name|row
argument_list|()
operator|<<
literal|','
operator|<<
name|idx
operator|.
name|column
argument_list|()
operator|<<
literal|','
operator|<<
name|idx
operator|.
name|internalPointer
argument_list|()
operator|<<
literal|','
operator|<<
name|idx
operator|.
name|model
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"This compiler doesn't support streaming QModelIndex to QDebug"
argument_list|)
expr_stmt|;
return|return
name|dbg
return|;
name|Q_UNUSED
argument_list|(
name|idx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QPersistentModelIndex
modifier|&
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|.
name|d
condition|)
name|dbg
operator|<<
name|idx
operator|.
name|d
operator|->
name|index
expr_stmt|;
else|else
name|dbg
operator|<<
name|QModelIndex
argument_list|()
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|QEmptyItemModel
class|class
name|QEmptyItemModel
super|:
specifier|public
name|QAbstractItemModel
block|{
public|public:
DECL|function|QEmptyItemModel
specifier|explicit
name|QEmptyItemModel
parameter_list|(
name|QObject
modifier|*
name|parent
init|=
literal|0
parameter_list|)
member_init_list|:
name|QAbstractItemModel
argument_list|(
name|parent
argument_list|)
block|{}
DECL|function|index
name|QModelIndex
name|index
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|QModelIndex
argument_list|()
return|;
block|}
DECL|function|parent
name|QModelIndex
name|parent
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|QModelIndex
argument_list|()
return|;
block|}
DECL|function|rowCount
name|int
name|rowCount
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
specifier|const
block|{
return|return
literal|0
return|;
block|}
DECL|function|columnCount
name|int
name|columnCount
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
specifier|const
block|{
return|return
literal|0
return|;
block|}
DECL|function|hasChildren
name|bool
name|hasChildren
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
specifier|const
block|{
return|return
literal|false
return|;
block|}
DECL|function|data
name|QVariant
name|data
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
parameter_list|,
name|int
parameter_list|)
specifier|const
block|{
return|return
name|QVariant
argument_list|()
return|;
block|}
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QEmptyItemModel
argument_list|,
argument|qEmptyModel
argument_list|)
end_macro
begin_function
DECL|function|staticEmptyModel
name|QAbstractItemModel
modifier|*
name|QAbstractItemModelPrivate
operator|::
name|staticEmptyModel
parameter_list|()
block|{
return|return
name|qEmptyModel
argument_list|()
return|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|struct|DefaultRoleNames
struct|struct
name|DefaultRoleNames
super|:
specifier|public
name|QHash
argument_list|<
name|int
argument_list|,
name|QByteArray
argument_list|>
block|{
DECL|function|DefaultRoleNames
name|DefaultRoleNames
parameter_list|()
block|{
operator|(
operator|*
name|this
operator|)
index|[
name|Qt
operator|::
name|DisplayRole
index|]
operator|=
literal|"display"
expr_stmt|;
operator|(
operator|*
name|this
operator|)
index|[
name|Qt
operator|::
name|DecorationRole
index|]
operator|=
literal|"decoration"
expr_stmt|;
operator|(
operator|*
name|this
operator|)
index|[
name|Qt
operator|::
name|EditRole
index|]
operator|=
literal|"edit"
expr_stmt|;
operator|(
operator|*
name|this
operator|)
index|[
name|Qt
operator|::
name|ToolTipRole
index|]
operator|=
literal|"toolTip"
expr_stmt|;
operator|(
operator|*
name|this
operator|)
index|[
name|Qt
operator|::
name|StatusTipRole
index|]
operator|=
literal|"statusTip"
expr_stmt|;
operator|(
operator|*
name|this
operator|)
index|[
name|Qt
operator|::
name|WhatsThisRole
index|]
operator|=
literal|"whatsThis"
expr_stmt|;
block|}
block|}
struct|;
block|}
end_namespace
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|DefaultRoleNames
argument_list|,
argument|qDefaultRoleNames
argument_list|)
end_macro
begin_function
DECL|function|defaultRoleNames
specifier|const
name|QHash
argument_list|<
name|int
argument_list|,
name|QByteArray
argument_list|>
modifier|&
name|QAbstractItemModelPrivate
operator|::
name|defaultRoleNames
parameter_list|()
block|{
return|return
operator|*
name|qDefaultRoleNames
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|typeOfVariant
specifier|static
name|uint
name|typeOfVariant
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
comment|//return 0 for integer, 1 for floating point and 2 for other
switch|switch
condition|(
name|value
operator|.
name|userType
argument_list|()
condition|)
block|{
case|case
name|QVariant
operator|::
name|Bool
case|:
case|case
name|QVariant
operator|::
name|Int
case|:
case|case
name|QVariant
operator|::
name|UInt
case|:
case|case
name|QVariant
operator|::
name|LongLong
case|:
case|case
name|QVariant
operator|::
name|ULongLong
case|:
case|case
name|QVariant
operator|::
name|Char
case|:
case|case
name|QMetaType
operator|::
name|Short
case|:
case|case
name|QMetaType
operator|::
name|UShort
case|:
case|case
name|QMetaType
operator|::
name|UChar
case|:
case|case
name|QMetaType
operator|::
name|ULong
case|:
case|case
name|QMetaType
operator|::
name|Long
case|:
return|return
literal|0
return|;
case|case
name|QVariant
operator|::
name|Double
case|:
case|case
name|QMetaType
operator|::
name|Float
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|2
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     return true if \a value contains a numerical type      This function is used by our Q{Tree,Widget,Table}WidgetModel classes to sort. */
end_comment
begin_function
DECL|function|variantLessThan
name|bool
name|QAbstractItemModelPrivate
operator|::
name|variantLessThan
parameter_list|(
specifier|const
name|QVariant
modifier|&
name|v1
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|v2
parameter_list|)
block|{
switch|switch
condition|(
name|qMax
argument_list|(
name|typeOfVariant
argument_list|(
name|v1
argument_list|)
argument_list|,
name|typeOfVariant
argument_list|(
name|v2
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|//integer type
return|return
name|v1
operator|.
name|toLongLong
argument_list|()
operator|<
name|v2
operator|.
name|toLongLong
argument_list|()
return|;
case|case
literal|1
case|:
comment|//floating point
return|return
name|v1
operator|.
name|toReal
argument_list|()
operator|<
name|v2
operator|.
name|toReal
argument_list|()
return|;
default|default:
return|return
name|v1
operator|.
name|toString
argument_list|()
operator|.
name|localeAwareCompare
argument_list|(
name|v2
operator|.
name|toString
argument_list|()
argument_list|)
operator|<
literal|0
return|;
block|}
block|}
end_function
begin_function
DECL|function|removePersistentIndexData
name|void
name|QAbstractItemModelPrivate
operator|::
name|removePersistentIndexData
parameter_list|(
name|QPersistentModelIndexData
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|->
name|index
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|int
name|removed
init|=
name|persistent
operator|.
name|indexes
operator|.
name|remove
argument_list|(
name|data
operator|->
name|index
argument_list|)
decl_stmt|;
name|Q_ASSERT_X
argument_list|(
name|removed
operator|==
literal|1
argument_list|,
literal|"QPersistentModelIndex::~QPersistentModelIndex"
argument_list|,
literal|"persistent model indexes corrupted"
argument_list|)
expr_stmt|;
comment|//maybe the index was somewhat invalid?
comment|// This assert may happen if the model use changePersistentIndex in a way that could result on two
comment|// QPersistentModelIndex pointing to the same index.
name|Q_UNUSED
argument_list|(
name|removed
argument_list|)
expr_stmt|;
block|}
comment|// make sure our optimization still works
for|for
control|(
name|int
name|i
init|=
name|persistent
operator|.
name|moved
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|idx
init|=
name|persistent
operator|.
name|moved
index|[
name|i
index|]
operator|.
name|indexOf
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
name|persistent
operator|.
name|moved
index|[
name|i
index|]
operator|.
name|remove
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
comment|// update the references to invalidated persistent indexes
for|for
control|(
name|int
name|i
init|=
name|persistent
operator|.
name|invalidated
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|idx
init|=
name|persistent
operator|.
name|invalidated
index|[
name|i
index|]
operator|.
name|indexOf
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
name|persistent
operator|.
name|invalidated
index|[
name|i
index|]
operator|.
name|remove
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|rowsAboutToBeInserted
name|void
name|QAbstractItemModelPrivate
operator|::
name|rowsAboutToBeInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_moved
decl_stmt|;
if|if
condition|(
name|first
operator|<
name|q
operator|->
name|rowCount
argument_list|(
name|parent
argument_list|)
condition|)
block|{
for|for
control|(
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|persistent
operator|.
name|indexes
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|persistent
operator|.
name|indexes
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
specifier|const
name|QModelIndex
modifier|&
name|index
init|=
name|data
operator|->
name|index
decl_stmt|;
if|if
condition|(
name|index
operator|.
name|row
argument_list|()
operator|>=
name|first
operator|&&
name|index
operator|.
name|isValid
argument_list|()
operator|&&
name|index
operator|.
name|parent
argument_list|()
operator|==
name|parent
condition|)
block|{
name|persistent_moved
operator|.
name|append
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|persistent
operator|.
name|moved
operator|.
name|push
argument_list|(
name|persistent_moved
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|rowsInserted
name|void
name|QAbstractItemModelPrivate
operator|::
name|rowsInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_moved
init|=
name|persistent
operator|.
name|moved
operator|.
name|pop
argument_list|()
decl_stmt|;
name|int
name|count
init|=
operator|(
name|last
operator|-
name|first
operator|)
operator|+
literal|1
decl_stmt|;
comment|// it is important to only use the delta, because the change could be nested
for|for
control|(
name|QVector
argument_list|<
name|QPersistentModelIndexData
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|persistent_moved
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|persistent_moved
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
name|QModelIndex
name|old
init|=
name|data
operator|->
name|index
decl_stmt|;
name|persistent
operator|.
name|indexes
operator|.
name|erase
argument_list|(
name|persistent
operator|.
name|indexes
operator|.
name|find
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|index
operator|=
name|q_func
argument_list|()
operator|->
name|index
argument_list|(
name|old
operator|.
name|row
argument_list|()
operator|+
name|count
argument_list|,
name|old
operator|.
name|column
argument_list|()
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|index
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|persistent
operator|.
name|insertMultiAtEnd
argument_list|(
name|data
operator|->
name|index
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QAbstractItemModel::endInsertRows:  Invalid index ("
operator|<<
name|old
operator|.
name|row
argument_list|()
operator|+
name|count
operator|<<
literal|','
operator|<<
name|old
operator|.
name|column
argument_list|()
operator|<<
literal|") in model"
operator|<<
name|q_func
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|itemsAboutToBeMoved
name|void
name|QAbstractItemModelPrivate
operator|::
name|itemsAboutToBeMoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|srcParent
parameter_list|,
name|int
name|srcFirst
parameter_list|,
name|int
name|srcLast
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|destinationParent
parameter_list|,
name|int
name|destinationChild
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_moved_explicitly
decl_stmt|;
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_moved_in_source
decl_stmt|;
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_moved_in_destination
decl_stmt|;
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|;
specifier|const
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
modifier|*
argument_list|>
operator|::
name|const_iterator
name|begin
init|=
name|persistent
operator|.
name|indexes
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
modifier|*
argument_list|>
operator|::
name|const_iterator
name|end
init|=
name|persistent
operator|.
name|indexes
operator|.
name|constEnd
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|sameParent
init|=
operator|(
name|srcParent
operator|==
name|destinationParent
operator|)
decl_stmt|;
specifier|const
name|bool
name|movingUp
init|=
operator|(
name|srcFirst
operator|>
name|destinationChild
operator|)
decl_stmt|;
for|for
control|(
name|it
operator|=
name|begin
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
specifier|const
name|QModelIndex
modifier|&
name|index
init|=
name|data
operator|->
name|index
decl_stmt|;
specifier|const
name|QModelIndex
modifier|&
name|parent
init|=
name|index
operator|.
name|parent
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|isSourceIndex
init|=
operator|(
name|parent
operator|==
name|srcParent
operator|)
decl_stmt|;
specifier|const
name|bool
name|isDestinationIndex
init|=
operator|(
name|parent
operator|==
name|destinationParent
operator|)
decl_stmt|;
name|int
name|childPosition
decl_stmt|;
if|if
condition|(
name|orientation
operator|==
name|Qt
operator|::
name|Vertical
condition|)
name|childPosition
operator|=
name|index
operator|.
name|row
argument_list|()
expr_stmt|;
else|else
name|childPosition
operator|=
name|index
operator|.
name|column
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|index
operator|.
name|isValid
argument_list|()
operator|||
operator|!
operator|(
name|isSourceIndex
operator|||
name|isDestinationIndex
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|sameParent
operator|&&
name|isDestinationIndex
condition|)
block|{
if|if
condition|(
name|childPosition
operator|>=
name|destinationChild
condition|)
name|persistent_moved_in_destination
operator|.
name|append
argument_list|(
name|data
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sameParent
operator|&&
name|movingUp
operator|&&
name|childPosition
operator|<
name|destinationChild
condition|)
continue|continue;
if|if
condition|(
name|sameParent
operator|&&
operator|!
name|movingUp
operator|&&
name|childPosition
operator|<
name|srcFirst
condition|)
continue|continue;
if|if
condition|(
operator|!
name|sameParent
operator|&&
name|childPosition
operator|<
name|srcFirst
condition|)
continue|continue;
if|if
condition|(
name|sameParent
operator|&&
operator|(
name|childPosition
operator|>
name|srcLast
operator|)
operator|&&
operator|(
name|childPosition
operator|>=
name|destinationChild
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|childPosition
operator|<=
name|srcLast
operator|)
operator|&&
operator|(
name|childPosition
operator|>=
name|srcFirst
operator|)
condition|)
block|{
name|persistent_moved_explicitly
operator|.
name|append
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|persistent_moved_in_source
operator|.
name|append
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
name|persistent
operator|.
name|moved
operator|.
name|push
argument_list|(
name|persistent_moved_explicitly
argument_list|)
expr_stmt|;
name|persistent
operator|.
name|moved
operator|.
name|push
argument_list|(
name|persistent_moved_in_source
argument_list|)
expr_stmt|;
name|persistent
operator|.
name|moved
operator|.
name|push
argument_list|(
name|persistent_moved_in_destination
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal    Moves persistent indexes \a indexes by amount \a change. The change will be either a change in row value or a change in   column value depending on the value of \a orientation. The indexes may also be moved to a different parent if \a parent   differs from the existing parent for the index. */
end_comment
begin_function
DECL|function|movePersistentIndexes
name|void
name|QAbstractItemModelPrivate
operator|::
name|movePersistentIndexes
parameter_list|(
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|indexes
parameter_list|,
name|int
name|change
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
operator|::
name|const_iterator
name|it
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
operator|::
name|const_iterator
name|begin
init|=
name|indexes
operator|.
name|constBegin
argument_list|()
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
operator|::
name|const_iterator
name|end
init|=
name|indexes
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
name|it
operator|=
name|begin
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
name|int
name|row
init|=
name|data
operator|->
name|index
operator|.
name|row
argument_list|()
decl_stmt|;
name|int
name|column
init|=
name|data
operator|->
name|index
operator|.
name|column
argument_list|()
decl_stmt|;
if|if
condition|(
name|Qt
operator|::
name|Vertical
operator|==
name|orientation
condition|)
name|row
operator|+=
name|change
expr_stmt|;
else|else
name|column
operator|+=
name|change
expr_stmt|;
name|persistent
operator|.
name|indexes
operator|.
name|erase
argument_list|(
name|persistent
operator|.
name|indexes
operator|.
name|find
argument_list|(
name|data
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|index
operator|=
name|q_func
argument_list|()
operator|->
name|index
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|index
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|persistent
operator|.
name|insertMultiAtEnd
argument_list|(
name|data
operator|->
name|index
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QAbstractItemModel::endMoveRows:  Invalid index ("
operator|<<
name|row
operator|<<
literal|","
operator|<<
name|column
operator|<<
literal|") in model"
operator|<<
name|q_func
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|itemsMoved
name|void
name|QAbstractItemModelPrivate
operator|::
name|itemsMoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|sourceParent
parameter_list|,
name|int
name|sourceFirst
parameter_list|,
name|int
name|sourceLast
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|destinationParent
parameter_list|,
name|int
name|destinationChild
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|moved_in_destination
init|=
name|persistent
operator|.
name|moved
operator|.
name|pop
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|moved_in_source
init|=
name|persistent
operator|.
name|moved
operator|.
name|pop
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|moved_explicitly
init|=
name|persistent
operator|.
name|moved
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|const
name|bool
name|sameParent
init|=
operator|(
name|sourceParent
operator|==
name|destinationParent
operator|)
decl_stmt|;
specifier|const
name|bool
name|movingUp
init|=
operator|(
name|sourceFirst
operator|>
name|destinationChild
operator|)
decl_stmt|;
specifier|const
name|int
name|explicit_change
init|=
operator|(
operator|!
name|sameParent
operator|||
name|movingUp
operator|)
condition|?
name|destinationChild
operator|-
name|sourceFirst
else|:
name|destinationChild
operator|-
name|sourceLast
operator|-
literal|1
decl_stmt|;
specifier|const
name|int
name|source_change
init|=
operator|(
operator|!
name|sameParent
operator|||
operator|!
name|movingUp
operator|)
condition|?
operator|-
literal|1
operator|*
operator|(
name|sourceLast
operator|-
name|sourceFirst
operator|+
literal|1
operator|)
else|:
name|sourceLast
operator|-
name|sourceFirst
operator|+
literal|1
decl_stmt|;
specifier|const
name|int
name|destination_change
init|=
name|sourceLast
operator|-
name|sourceFirst
operator|+
literal|1
decl_stmt|;
name|movePersistentIndexes
argument_list|(
name|moved_explicitly
argument_list|,
name|explicit_change
argument_list|,
name|destinationParent
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
name|movePersistentIndexes
argument_list|(
name|moved_in_source
argument_list|,
name|source_change
argument_list|,
name|sourceParent
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
name|movePersistentIndexes
argument_list|(
name|moved_in_destination
argument_list|,
name|destination_change
argument_list|,
name|destinationParent
argument_list|,
name|orientation
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|rowsAboutToBeRemoved
name|void
name|QAbstractItemModelPrivate
operator|::
name|rowsAboutToBeRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_moved
decl_stmt|;
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_invalidated
decl_stmt|;
comment|// find the persistent indexes that are affected by the change, either by being in the removed subtree
comment|// or by being on the same level and below the removed rows
for|for
control|(
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|persistent
operator|.
name|indexes
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|persistent
operator|.
name|indexes
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
name|bool
name|level_changed
init|=
literal|false
decl_stmt|;
name|QModelIndex
name|current
init|=
name|data
operator|->
name|index
decl_stmt|;
while|while
condition|(
name|current
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QModelIndex
name|current_parent
init|=
name|current
operator|.
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|current_parent
operator|==
name|parent
condition|)
block|{
comment|// on the same level as the change
if|if
condition|(
operator|!
name|level_changed
operator|&&
name|current
operator|.
name|row
argument_list|()
operator|>
name|last
condition|)
comment|// below the removed rows
name|persistent_moved
operator|.
name|append
argument_list|(
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current
operator|.
name|row
argument_list|()
operator|<=
name|last
operator|&&
name|current
operator|.
name|row
argument_list|()
operator|>=
name|first
condition|)
comment|// in the removed subtree
name|persistent_invalidated
operator|.
name|append
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
name|current
operator|=
name|current_parent
expr_stmt|;
name|level_changed
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|persistent
operator|.
name|moved
operator|.
name|push
argument_list|(
name|persistent_moved
argument_list|)
expr_stmt|;
name|persistent
operator|.
name|invalidated
operator|.
name|push
argument_list|(
name|persistent_invalidated
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|rowsRemoved
name|void
name|QAbstractItemModelPrivate
operator|::
name|rowsRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_moved
init|=
name|persistent
operator|.
name|moved
operator|.
name|pop
argument_list|()
decl_stmt|;
name|int
name|count
init|=
operator|(
name|last
operator|-
name|first
operator|)
operator|+
literal|1
decl_stmt|;
comment|// it is important to only use the delta, because the change could be nested
for|for
control|(
name|QVector
argument_list|<
name|QPersistentModelIndexData
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|persistent_moved
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|persistent_moved
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
name|QModelIndex
name|old
init|=
name|data
operator|->
name|index
decl_stmt|;
name|persistent
operator|.
name|indexes
operator|.
name|erase
argument_list|(
name|persistent
operator|.
name|indexes
operator|.
name|find
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|index
operator|=
name|q_func
argument_list|()
operator|->
name|index
argument_list|(
name|old
operator|.
name|row
argument_list|()
operator|-
name|count
argument_list|,
name|old
operator|.
name|column
argument_list|()
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|index
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|persistent
operator|.
name|insertMultiAtEnd
argument_list|(
name|data
operator|->
name|index
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QAbstractItemModel::endRemoveRows:  Invalid index ("
operator|<<
name|old
operator|.
name|row
argument_list|()
operator|-
name|count
operator|<<
literal|','
operator|<<
name|old
operator|.
name|column
argument_list|()
operator|<<
literal|") in model"
operator|<<
name|q_func
argument_list|()
expr_stmt|;
block|}
block|}
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_invalidated
init|=
name|persistent
operator|.
name|invalidated
operator|.
name|pop
argument_list|()
decl_stmt|;
for|for
control|(
name|QVector
argument_list|<
name|QPersistentModelIndexData
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|persistent_invalidated
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|persistent_invalidated
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
name|persistent
operator|.
name|indexes
operator|.
name|erase
argument_list|(
name|persistent
operator|.
name|indexes
operator|.
name|find
argument_list|(
name|data
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|index
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
name|data
operator|->
name|model
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|columnsAboutToBeInserted
name|void
name|QAbstractItemModelPrivate
operator|::
name|columnsAboutToBeInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_moved
decl_stmt|;
if|if
condition|(
name|first
operator|<
name|q
operator|->
name|columnCount
argument_list|(
name|parent
argument_list|)
condition|)
block|{
for|for
control|(
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|persistent
operator|.
name|indexes
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|persistent
operator|.
name|indexes
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
specifier|const
name|QModelIndex
modifier|&
name|index
init|=
name|data
operator|->
name|index
decl_stmt|;
if|if
condition|(
name|index
operator|.
name|column
argument_list|()
operator|>=
name|first
operator|&&
name|index
operator|.
name|isValid
argument_list|()
operator|&&
name|index
operator|.
name|parent
argument_list|()
operator|==
name|parent
condition|)
name|persistent_moved
operator|.
name|append
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
name|persistent
operator|.
name|moved
operator|.
name|push
argument_list|(
name|persistent_moved
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|columnsInserted
name|void
name|QAbstractItemModelPrivate
operator|::
name|columnsInserted
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_moved
init|=
name|persistent
operator|.
name|moved
operator|.
name|pop
argument_list|()
decl_stmt|;
name|int
name|count
init|=
operator|(
name|last
operator|-
name|first
operator|)
operator|+
literal|1
decl_stmt|;
comment|// it is important to only use the delta, because the change could be nested
for|for
control|(
name|QVector
argument_list|<
name|QPersistentModelIndexData
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|persistent_moved
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|persistent_moved
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
name|QModelIndex
name|old
init|=
name|data
operator|->
name|index
decl_stmt|;
name|persistent
operator|.
name|indexes
operator|.
name|erase
argument_list|(
name|persistent
operator|.
name|indexes
operator|.
name|find
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|index
operator|=
name|q_func
argument_list|()
operator|->
name|index
argument_list|(
name|old
operator|.
name|row
argument_list|()
argument_list|,
name|old
operator|.
name|column
argument_list|()
operator|+
name|count
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|index
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|persistent
operator|.
name|insertMultiAtEnd
argument_list|(
name|data
operator|->
name|index
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QAbstractItemModel::endInsertColumns:  Invalid index ("
operator|<<
name|old
operator|.
name|row
argument_list|()
operator|<<
literal|','
operator|<<
name|old
operator|.
name|column
argument_list|()
operator|+
name|count
operator|<<
literal|") in model"
operator|<<
name|q_func
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|columnsAboutToBeRemoved
name|void
name|QAbstractItemModelPrivate
operator|::
name|columnsAboutToBeRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_moved
decl_stmt|;
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_invalidated
decl_stmt|;
comment|// find the persistent indexes that are affected by the change, either by being in the removed subtree
comment|// or by being on the same level and to the right of the removed columns
for|for
control|(
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|persistent
operator|.
name|indexes
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|persistent
operator|.
name|indexes
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
name|bool
name|level_changed
init|=
literal|false
decl_stmt|;
name|QModelIndex
name|current
init|=
name|data
operator|->
name|index
decl_stmt|;
while|while
condition|(
name|current
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QModelIndex
name|current_parent
init|=
name|current
operator|.
name|parent
argument_list|()
decl_stmt|;
if|if
condition|(
name|current_parent
operator|==
name|parent
condition|)
block|{
comment|// on the same level as the change
if|if
condition|(
operator|!
name|level_changed
operator|&&
name|current
operator|.
name|column
argument_list|()
operator|>
name|last
condition|)
comment|// right of the removed columns
name|persistent_moved
operator|.
name|append
argument_list|(
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current
operator|.
name|column
argument_list|()
operator|<=
name|last
operator|&&
name|current
operator|.
name|column
argument_list|()
operator|>=
name|first
condition|)
comment|// in the removed subtree
name|persistent_invalidated
operator|.
name|append
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
name|current
operator|=
name|current_parent
expr_stmt|;
name|level_changed
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|persistent
operator|.
name|moved
operator|.
name|push
argument_list|(
name|persistent_moved
argument_list|)
expr_stmt|;
name|persistent
operator|.
name|invalidated
operator|.
name|push
argument_list|(
name|persistent_invalidated
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|columnsRemoved
name|void
name|QAbstractItemModelPrivate
operator|::
name|columnsRemoved
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_moved
init|=
name|persistent
operator|.
name|moved
operator|.
name|pop
argument_list|()
decl_stmt|;
name|int
name|count
init|=
operator|(
name|last
operator|-
name|first
operator|)
operator|+
literal|1
decl_stmt|;
comment|// it is important to only use the delta, because the change could be nested
for|for
control|(
name|QVector
argument_list|<
name|QPersistentModelIndexData
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|persistent_moved
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|persistent_moved
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
name|QModelIndex
name|old
init|=
name|data
operator|->
name|index
decl_stmt|;
name|persistent
operator|.
name|indexes
operator|.
name|erase
argument_list|(
name|persistent
operator|.
name|indexes
operator|.
name|find
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|index
operator|=
name|q_func
argument_list|()
operator|->
name|index
argument_list|(
name|old
operator|.
name|row
argument_list|()
argument_list|,
name|old
operator|.
name|column
argument_list|()
operator|-
name|count
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|index
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|persistent
operator|.
name|insertMultiAtEnd
argument_list|(
name|data
operator|->
name|index
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QAbstractItemModel::endRemoveColumns:  Invalid index ("
operator|<<
name|old
operator|.
name|row
argument_list|()
operator|<<
literal|','
operator|<<
name|old
operator|.
name|column
argument_list|()
operator|-
name|count
operator|<<
literal|") in model"
operator|<<
name|q_func
argument_list|()
expr_stmt|;
block|}
block|}
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|persistent_invalidated
init|=
name|persistent
operator|.
name|invalidated
operator|.
name|pop
argument_list|()
decl_stmt|;
for|for
control|(
name|QVector
argument_list|<
name|QPersistentModelIndexData
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|persistent_invalidated
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|persistent_invalidated
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
name|persistent
operator|.
name|indexes
operator|.
name|erase
argument_list|(
name|persistent
operator|.
name|indexes
operator|.
name|find
argument_list|(
name|data
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|index
operator|=
name|QModelIndex
argument_list|()
expr_stmt|;
name|data
operator|->
name|model
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QModelIndex      \brief The QModelIndex class is used to locate data in a data model.      \ingroup model-view       This class is used as an index into item models derived from     QAbstractItemModel. The index is used by item views, delegates, and     selection models to locate an item in the model.      New QModelIndex objects are created by the model using the     QAbstractItemModel::createIndex() function. An \e invalid model index can     be constructed with the QModelIndex constructor. Invalid indexes are often     used as parent indexes when referring to top-level items in a model.      Model indexes refer to items in models, and contain all the information     required to specify their locations in those models. Each index is located     in a given row and column, and may have a parent index; use row(),     column(), and parent() to obtain this information. Each top-level item in a     model is represented by a model index that does not have a parent index -     in this case, parent() will return an invalid model index, equivalent to an     index constructed with the zero argument form of the QModelIndex()     constructor.      To obtain a model index that refers to an existing item in a model, call     QAbstractItemModel::index() with the required row and column values, and     the model index of the parent. When referring to top-level items in a     model, supply QModelIndex() as the parent index.      The model() function returns the model that the index references as a     QAbstractItemModel. The child() function is used to examine items held     under the index in the model. The sibling() function allows you to traverse     items in the model on the same level as the index.      \note Model indexes should be used immediately and then discarded. You     should not rely on indexes to remain valid after calling model functions     that change the structure of the model or delete items. If you need to     keep a model index over time use a QPersistentModelIndex.      \sa {Model/View Programming}, QPersistentModelIndex, QAbstractItemModel */
end_comment
begin_comment
comment|/*!     \fn QModelIndex::QModelIndex()      Creates a new empty model index. This type of model index is used to     indicate that the position in the model is invalid.      \sa isValid() QAbstractItemModel */
end_comment
begin_comment
comment|/*!     \fn QModelIndex::QModelIndex(int row, int column, void *data, const QAbstractItemModel *model)      \internal      Creates a new model index at the given \a row and \a column,     pointing to some \a data. */
end_comment
begin_comment
comment|/*!     \fn QModelIndex::QModelIndex(const QModelIndex&other)      Creates a new model index that is a copy of the \a other model     index. */
end_comment
begin_comment
comment|/*!     \fn QModelIndex::~QModelIndex()      Destroys the model index. */
end_comment
begin_comment
comment|/*!     \fn int QModelIndex::row() const      Returns the row this model index refers to. */
end_comment
begin_comment
comment|/*!     \fn int QModelIndex::column() const      Returns the column this model index refers to. */
end_comment
begin_comment
comment|/*!     \fn void *QModelIndex::internalPointer() const      Returns a \c{void} \c{*} pointer used by the model to associate     the index with the internal data structure.      \sa QAbstractItemModel::createIndex() */
end_comment
begin_comment
comment|/*!     \fn void *QModelIndex::internalId() const      Returns a \c{qint64} used by the model to associate     the index with the internal data structure.      \sa QAbstractItemModel::createIndex() */
end_comment
begin_comment
comment|/*!     \fn bool QModelIndex::isValid() const      Returns true if this model index is valid; otherwise returns false.      A valid index belongs to a model, and has non-negative row and column     numbers.      \sa model(), row(), column() */
end_comment
begin_comment
comment|/*!     \fn const QAbstractItemModel *QModelIndex::model() const      Returns a pointer to the model containing the item that this index     refers to.      A const pointer to the model is returned because calls to non-const     functions of the model might invalidate the model index and possibly     crash your application. */
end_comment
begin_comment
comment|/*!     \fn QModelIndex QModelIndex::sibling(int row, int column) const      Returns the sibling at \a row and \a column. If there is no sibling at this     position, an invalid QModelIndex is returned.      \sa parent(), child() */
end_comment
begin_comment
comment|/*!     \fn QModelIndex QModelIndex::child(int row, int column) const      Returns the child of the model index that is stored in the given \a row and     \a column.      \note This function does not work for an invalid model index which is often     used as the root index.      \sa parent(), sibling() */
end_comment
begin_comment
comment|/*!     \fn QVariant QModelIndex::data(int role) const      Returns the data for the given \a role for the item referred to by the     index. */
end_comment
begin_comment
comment|/*!     \fn Qt::ItemFlags QModelIndex::flags() const     \since 4.2      Returns the flags for the item referred to by the index. */
end_comment
begin_comment
comment|/*!     \fn bool QModelIndex::operator==(const QModelIndex&other) const      Returns true if this model index refers to the same location as the     \a other model index; otherwise returns false.      All values in the model index are used when comparing with another model     index. */
end_comment
begin_comment
comment|/*!     \fn bool QModelIndex::operator!=(const QModelIndex&other) const      Returns true if this model index does not refer to the same location as     the \a other model index; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn QModelIndex QModelIndex::parent() const      Returns the parent of the model index, or QModelIndex() if it has no     parent.      \sa child(), sibling(), model() */
end_comment
begin_comment
comment|/*!     \class QAbstractItemModel      \brief The QAbstractItemModel class provides the abstract interface for     item model classes.      \ingroup model-view       The QAbstractItemModel class defines the standard interface that item     models must use to be able to interoperate with other components in the     model/view architecture. It is not supposed to be instantiated directly.     Instead, you should subclass it to create new models.      The QAbstractItemModel class is one of the \l{Model/View Classes}     and is part of Qt's \l{Model/View Programming}{model/view framework}.      If you need a model to use with a QListView or a QTableView, you should     consider subclassing QAbstractListModel or QAbstractTableModel instead of     this class.      The underlying data model is exposed to views and delegates as a hierarchy     of tables. If you do not make use of the hierarchy, then the model is a     simple table of rows and columns. Each item has a unique index specified by     a QModelIndex.      \image modelindex-no-parent.png      Every item of data that can be accessed via a model has an associated model     index. You can obtain this model index using the index() function. Each     index may have a sibling() index; child items have a parent() index.      Each item has a number of data elements associated with it and they can be     retrieved by specifying a role (see \l Qt::ItemDataRole) to the model's     data() function. Data for all available roles can be obtained at the same     time using the itemData() function.      Data for each role is set using a particular \l Qt::ItemDataRole. Data for     individual roles are set individually with setData(), or they can be set     for all roles with setItemData().      Items can be queried with flags() (see \l Qt::ItemFlag) to see if they can     be selected, dragged, or manipulated in other ways.      If an item has child objects, hasChildren() returns true for the     corresponding index.      The model has a rowCount() and a columnCount() for each level of the     hierarchy. Rows and columns can be inserted and removed with insertRows(),     insertColumns(), removeRows(), and removeColumns().      The model emits signals to indicate changes. For example, dataChanged() is     emitted whenever items of data made available by the model are changed.     Changes to the headers supplied by the model cause headerDataChanged() to     be emitted. If the structure of the underlying data changes, the model can     emit layoutChanged() to indicate to any attached views that they should     redisplay any items shown, taking the new structure into account.      The items available through the model can be searched for particular data     using the match() function.      To sort the model, you can use sort().       \section1 Subclassing      \note Some general guidelines for subclassing models are available in the     \l{Model Subclassing Reference}.      When subclassing QAbstractItemModel, at the very least you must implement     index(), parent(), rowCount(), columnCount(), and data(). These functions     are used in all read-only models, and form the basis of editable models.      You can also reimplement hasChildren() to provide special behavior for     models where the implementation of rowCount() is expensive. This makes it     possible for models to restrict the amount of data requested by views, and     can be used as a way to implement lazy population of model data.      To enable editing in your model, you must also implement setData(), and     reimplement flags() to ensure that \c ItemIsEditable is returned.  You can     also reimplement headerData() and setHeaderData() to control the way the     headers for your model are presented.      The dataChanged() and headerDataChanged() signals must be emitted     explicitly when reimplementing the setData() and setHeaderData() functions,     respectively.      Custom models need to create model indexes for other components to use. To     do this, call createIndex() with suitable row and column numbers for the     item, and an identifier for it, either as a pointer or as an integer value.     The combination of these values must be unique for each item. Custom models     typically use these unique identifiers in other reimplemented functions to     retrieve item data and access information about the item's parents and     children. See the \l{Simple Tree Model Example} for more information about     unique identifiers.      It is not necessary to support every role defined in Qt::ItemDataRole.     Depending on the type of data contained within a model, it may only be     useful to implement the data() function to return valid information for     some of the more common roles. Most models provide at least a textual     representation of item data for the Qt::DisplayRole, and well-behaved     models should also provide valid information for the Qt::ToolTipRole and     Qt::WhatsThisRole. Supporting these roles enables models to be used with     standard Qt views. However, for some models that handle highly-specialized     data, it may be appropriate to provide data only for user-defined roles.      Models that provide interfaces to resizable data structures can provide     implementations of insertRows(), removeRows(), insertColumns(),and     removeColumns(). When implementing these functions, it is important to     notify any connected views about changes to the model's dimensions both     \e before and \e after they occur:      \list         \o An insertRows() implementation must call beginInsertRows() \e before            inserting new rows into the data structure, and endInsertRows()            \e{immediately afterwards}.         \o An insertColumns() implementation must call beginInsertColumns()            \e before inserting new columns into the data structure, and            endInsertColumns() \e{immediately afterwards}.         \o A removeRows() implementation must call beginRemoveRows() \e before            the rows are removed from the data structure, and endRemoveRows()            \e{immediately afterwards}.         \o A removeColumns() implementation must call beginRemoveColumns()            \e before the columns are removed from the data structure, and            endRemoveColumns() \e{immediately afterwards}.     \endlist      The \e private signals that these functions emit give attached components     the chance to take action before any data becomes unavailable. The     encapsulation of the insert and remove operations with these begin and end     functions also enables the model to manage \l{QPersistentModelIndex}     {persistent model indexes} correctly. \bold{If you want selections to be     handled properly, you must ensure that you call these functions.} If you     insert or remove an item with children, you do not need to call these     functions for the child items. In other words, the parent item will take     care of its child items.      To create models that populate incrementally, you can reimplement     fetchMore() and canFetchMore(). If the reimplementation of fetchMore() adds     rows to the model, \l{QAbstractItemModel::}{beginInsertRows()} and     \l{QAbstractItemModel::}{endInsertRows()} must be called.      \sa {Model Classes}, {Model Subclassing Reference}, QModelIndex,         QAbstractItemView, {Using drag and drop with item views},         {Simple DOM Model Example}, {Simple Tree Model Example},         {Editable Tree Model Example}, {Fetch More Example} */
end_comment
begin_comment
comment|/*!     \fn QModelIndex QAbstractItemModel::index(int row, int column, const QModelIndex&parent) const = 0      Returns the index of the item in the model specified by the given \a row,     \a column and \a parent index.      When reimplementing this function in a subclass, call createIndex() to     generate model indexes that other components can use to refer to items in     your model.      \sa createIndex() */
end_comment
begin_comment
comment|/*!     \fn bool QAbstractItemModel::insertColumn(int column, const QModelIndex&parent)      Inserts a single column before the given \a column in the child items of     the \a parent specified.      Returns true if the column is inserted; otherwise returns false.      \sa insertColumns() insertRow() removeColumn() */
end_comment
begin_comment
comment|/*!     \fn bool QAbstractItemModel::insertRow(int row, const QModelIndex&parent)      \note The base class implementation of this function does nothing and     returns false.      Inserts a single row before the given \a row in the child items of the     \a parent specified.      Returns true if the row is inserted; otherwise returns false.      \sa insertRows() insertColumn() removeRow() */
end_comment
begin_comment
comment|/*!     \fn QObject *QAbstractItemModel::parent() const     \internal */
end_comment
begin_comment
comment|/*!     \fn QModelIndex QAbstractItemModel::parent(const QModelIndex&index) const = 0      Returns the parent of the model item with the given \a index. If the item     has no parent, an invalid QModelIndex is returned.      A common convention used in models that expose tree data structures is that     only items in the first column have children. For that case, when     reimplementing this function in a subclass the column of the returned     QModelIndex would be 0.      When reimplementing this function in a subclass, be careful to avoid     calling QModelIndex member functions, such as QModelIndex::parent(), since     indexes belonging to your model will simply call your implementation,     leading to infinite recursion.      \sa createIndex() */
end_comment
begin_comment
comment|/*!     \fn bool QAbstractItemModel::removeColumn(int column, const QModelIndex&parent)      Removes the given \a column from the child items of the \a parent     specified.      Returns true if the column is removed; otherwise returns false.      \sa removeColumns(), removeRow(), insertColumn() */
end_comment
begin_comment
comment|/*!     \fn bool QAbstractItemModel::removeRow(int row, const QModelIndex&parent)      Removes the given \a row from the child items of the \a parent specified.      Returns true if the row is removed; otherwise returns false.      This is a convenience function that calls removeRows(). The     QAbstractItemModel implementation of removeRows() does nothing.      \sa removeRows(), removeColumn(), insertRow() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::headerDataChanged(Qt::Orientation orientation, int first, int last)      This signal is emitted whenever a header is changed. The \a orientation     indicates whether the horizontal or vertical header has changed. The     sections in the header from the \a first to the \a last need to be updated.      When reimplementing the setHeaderData() function, this signal must be     emitted explicitly.      If you are changing the number of columns or rows you do not need to emit     this signal, but use the begin/end functions (refer to the section on     subclassing in the QAbstractItemModel class description for details).      \sa headerData(), setHeaderData(), dataChanged() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::layoutAboutToBeChanged()     \since 4.2      This signal is emitted just before the layout of a model is changed.     Components connected to this signal use it to adapt to changes in the     model's layout.      Subclasses should update any persistent model indexes after emitting     layoutAboutToBeChanged().      \sa layoutChanged(), changePersistentIndex() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::layoutChanged()      This signal is emitted whenever the layout of items exposed by the model     has changed; for example, when the model has been sorted. When this signal     is received by a view, it should update the layout of items to reflect this     change.      When subclassing QAbstractItemModel or QAbstractProxyModel, ensure that you     emit layoutAboutToBeChanged() before changing the order of items or     altering the structure of the data you expose to views, and emit     layoutChanged() after changing the layout.      Subclasses should update any persistent model indexes before emitting     layoutChanged(). In other words, when the structure changes:      \list         \o  emit layoutAboutToBeChanged         \o  Remember the QModelIndex that will change         \o  Update your internal data         \o  Call changePersistentIndex()         \o  emit layoutChanged     \endlist      \sa layoutAboutToBeChanged(), dataChanged(), headerDataChanged(), modelReset(),         changePersistentIndex() */
end_comment
begin_comment
comment|/*!     Constructs an abstract item model with the given \a parent. */
end_comment
begin_constructor
DECL|function|QAbstractItemModel
name|QAbstractItemModel
operator|::
name|QAbstractItemModel
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QAbstractItemModelPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   \internal */
end_comment
begin_constructor
DECL|function|QAbstractItemModel
name|QAbstractItemModel
operator|::
name|QAbstractItemModel
parameter_list|(
name|QAbstractItemModelPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the abstract item model. */
end_comment
begin_destructor
DECL|function|~QAbstractItemModel
name|QAbstractItemModel
operator|::
name|~
name|QAbstractItemModel
parameter_list|()
block|{
name|d_func
argument_list|()
operator|->
name|invalidatePersistentIndexes
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn QModelIndex QAbstractItemModel::sibling(int row, int column, const QModelIndex&index) const      Returns the sibling at \a row and \a column for the item at \a index, or an     invalid QModelIndex if there is no sibling at that location.      sibling() is just a convenience function that finds the item's parent, and     uses it to retrieve the index of the child item in the specified \a row and     \a column.      \sa index(), QModelIndex::row(), QModelIndex::column() */
end_comment
begin_comment
comment|/*!     \fn int QAbstractItemModel::rowCount(const QModelIndex&parent) const      Returns the number of rows under the given \a parent. When the parent is     valid it means that rowCount is returning the number of children of parent.      \note When implementing a table based model, rowCount() should return 0     when the parent is valid.      \sa columnCount() */
end_comment
begin_comment
comment|/*!     \fn int QAbstractItemModel::columnCount(const QModelIndex&parent) const      Returns the number of columns for the children of the given \a parent.      In most subclasses, the number of columns is independent of the \a parent.      For example:      \snippet examples/itemviews/simpledommodel/dommodel.cpp 2      \note When implementing a table based model, columnCount() should return 0     when the parent is valid.      \sa rowCount() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::dataChanged(const QModelIndex&topLeft, const QModelIndex&bottomRight)      This signal is emitted whenever the data in an existing item changes.      If the items are of the same parent, the affected ones are those between     \a topLeft and \a bottomRight inclusive. If the items do not have the same     parent, the behavior is undefined.      When reimplementing the setData() function, this signal must be emitted     explicitly.      \sa headerDataChanged(), setData(), layoutChanged() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::rowsInserted(const QModelIndex&parent, int start, int end)      This signal is emitted after rows have been inserted into the     model. The new items are those between \a start and \a end     inclusive, under the given \a parent item.      \note Components connected to this signal use it to adapt to changes in the     model's dimensions. It can only be emitted by the QAbstractItemModel     implementation, and cannot be explicitly emitted in subclass code.      \sa insertRows(), beginInsertRows() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::rowsAboutToBeInserted(const QModelIndex&parent, int start, int end)      This signal is emitted just before rows are inserted into the model. The     new items will be positioned between \a start and \a end inclusive, under     the given \a parent item.      \note Components connected to this signal use it to adapt to changes     in the model's dimensions. It can only be emitted by the QAbstractItemModel     implementation, and cannot be explicitly emitted in subclass code.      \sa insertRows(), beginInsertRows() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::rowsRemoved(const QModelIndex&parent, int start, int end)      This signal is emitted after rows have been removed from the model. The     removed items are those between \a start and \a end inclusive, under the     given \a parent item.      \note Components connected to this signal use it to adapt to changes     in the model's dimensions. It can only be emitted by the QAbstractItemModel     implementation, and cannot be explicitly emitted in subclass code.      \sa removeRows(), beginRemoveRows() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::rowsAboutToBeRemoved(const QModelIndex&parent, int start, int end)      This signal is emitted just before rows are removed from the model. The     items that will be removed are those between \a start and \a end inclusive,     under the given \a parent item.      \note Components connected to this signal use it to adapt to changes     in the model's dimensions. It can only be emitted by the QAbstractItemModel     implementation, and cannot be explicitly emitted in subclass code.      \sa removeRows(), beginRemoveRows() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::rowsMoved(const QModelIndex&sourceParent, int sourceStart, int sourceEnd, const QModelIndex&destinationParent, int destinationRow)     \since 4.6      This signal is emitted after rows have been moved within the     model. The items between \a sourceStart and \a sourceEnd     inclusive, under the given \a sourceParent item have been moved to \a destinationParent     starting at the row \a destinationRow.      \bold{Note:} Components connected to this signal use it to adapt to changes     in the model's dimensions. It can only be emitted by the QAbstractItemModel     implementation, and cannot be explicitly emitted in subclass code.      \sa beginMoveRows() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::rowsAboutToBeMoved(const QModelIndex&sourceParent, int sourceStart, int sourceEnd, const QModelIndex&destinationParent, int destinationRow)     \since 4.6      This signal is emitted just before rows are moved within the     model. The items that will be moved are those between \a sourceStart and \a sourceEnd     inclusive, under the given \a sourceParent item. They will be moved to \a destinationParent     starting at the row \a destinationRow.      \bold{Note:} Components connected to this signal use it to adapt to changes     in the model's dimensions. It can only be emitted by the QAbstractItemModel     implementation, and cannot be explicitly emitted in subclass code.      \sa beginMoveRows() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::columnsMoved(const QModelIndex&sourceParent, int sourceStart, int sourceEnd, const QModelIndex&destinationParent, int destinationColumn)     \since 4.6      This signal is emitted after columns have been moved within the     model. The items between \a sourceStart and \a sourceEnd     inclusive, under the given \a sourceParent item have been moved to \a destinationParent     starting at the column \a destinationColumn.      \bold{Note:} Components connected to this signal use it to adapt to changes     in the model's dimensions. It can only be emitted by the QAbstractItemModel     implementation, and cannot be explicitly emitted in subclass code.      \sa beginMoveRows() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::columnsAboutToBeMoved(const QModelIndex&sourceParent, int sourceStart, int sourceEnd, const QModelIndex&destinationParent, int destinationColumn)     \since 4.6      This signal is emitted just before columns are moved within the     model. The items that will be moved are those between \a sourceStart and \a sourceEnd     inclusive, under the given \a sourceParent item. They will be moved to \a destinationParent     starting at the column \a destinationColumn.      \bold{Note:} Components connected to this signal use it to adapt to changes     in the model's dimensions. It can only be emitted by the QAbstractItemModel     implementation, and cannot be explicitly emitted in subclass code.      \sa beginMoveRows() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::columnsInserted(const QModelIndex&parent, int start, int end)      This signal is emitted after columns have been inserted into the model. The     new items are those between \a start and \a end inclusive, under the given     \a parent item.      \note Components connected to this signal use it to adapt to changes in the     model's dimensions. It can only be emitted by the QAbstractItemModel     implementation, and cannot be explicitly emitted in subclass code.      \sa insertColumns(), beginInsertColumns() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::columnsAboutToBeInserted(const QModelIndex&parent, int start, int end)      This signal is emitted just before columns are inserted into the model. The     new items will be positioned between \a start and \a end inclusive, under     the given \a parent item.      \note Components connected to this signal use it to adapt to changes in the     model's dimensions. It can only be emitted by the QAbstractItemModel     implementation, and cannot be explicitly emitted in subclass code.      \sa insertColumns(), beginInsertColumns() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::columnsRemoved(const QModelIndex&parent, int start, int end)      This signal is emitted after columns have been removed from the model.     The removed items are those between \a start and \a end inclusive,     under the given \a parent item.      \note Components connected to this signal use it to adapt to changes in     the model's dimensions. It can only be emitted by the QAbstractItemModel     implementation, and cannot be explicitly emitted in subclass code.      \sa removeColumns(), beginRemoveColumns() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractItemModel::columnsAboutToBeRemoved(const QModelIndex&parent, int start, int end)      This signal is emitted just before columns are removed from the model. The     items to be removed are those between \a start and \a end inclusive, under     the given \a parent item.      \note Components connected to this signal use it to adapt to changes in the     model's dimensions. It can only be emitted by the QAbstractItemModel     implementation, and cannot be explicitly emitted in subclass code.      \sa removeColumns(), beginRemoveColumns() */
end_comment
begin_comment
comment|/*!     Returns true if the model returns a valid QModelIndex for \a row and     \a column with \a parent, otherwise returns false. */
end_comment
begin_function
DECL|function|hasIndex
name|bool
name|QAbstractItemModel
operator|::
name|hasIndex
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|row
operator|<
literal|0
operator|||
name|column
operator|<
literal|0
condition|)
return|return
literal|false
return|;
return|return
name|row
operator|<
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|&&
name|column
operator|<
name|columnCount
argument_list|(
name|parent
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if \a parent has any children; otherwise returns false.      Use rowCount() on the parent to find out the number of children.      \sa parent() index() */
end_comment
begin_function
DECL|function|hasChildren
name|bool
name|QAbstractItemModel
operator|::
name|hasChildren
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
return|return
operator|(
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|columnCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a map with values for all predefined roles in the model for the     item at the given \a index.      Reimplement this function if you want to extend the default behavior of     this function to include custom roles in the map.      \sa Qt::ItemDataRole, data() */
end_comment
begin_function
DECL|function|itemData
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
name|QAbstractItemModel
operator|::
name|itemData
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
name|roles
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Qt
operator|::
name|UserRole
condition|;
operator|++
name|i
control|)
block|{
name|QVariant
name|variantData
init|=
name|data
argument_list|(
name|index
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|variantData
operator|.
name|isValid
argument_list|()
condition|)
name|roles
operator|.
name|insert
argument_list|(
name|i
argument_list|,
name|variantData
argument_list|)
expr_stmt|;
block|}
return|return
name|roles
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the \a role data for the item at \a index to \a value.      Returns true if successful; otherwise returns false.      The dataChanged() signal should be emitted if the data was successfully     set.      The base class implementation returns false. This function and data() must     be reimplemented for editable models.      \sa Qt::ItemDataRole, data(), itemData() */
end_comment
begin_function
DECL|function|setData
name|bool
name|QAbstractItemModel
operator|::
name|setData
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|,
name|int
name|role
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|role
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QVariant QAbstractItemModel::data(const QModelIndex&index, int role) const = 0      Returns the data stored under the given \a role for the item referred to     by the \a index.      \note If you do not have a value to return, return an \bold invalid     QVariant instead of returning 0.      \sa Qt::ItemDataRole, setData(), headerData() */
end_comment
begin_comment
comment|/*!     Sets the role data for the item at \a index to the associated value in     \a roles, for every Qt::ItemDataRole.      Returns true if successful; otherwise returns false.      Roles that are not in \a roles will not be modified.      \sa setData() data() itemData() */
end_comment
begin_function
DECL|function|setItemData
name|bool
name|QAbstractItemModel
operator|::
name|setItemData
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|,
specifier|const
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
modifier|&
name|roles
parameter_list|)
block|{
name|bool
name|b
init|=
literal|true
decl_stmt|;
for|for
control|(
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|roles
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|roles
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
name|b
operator|=
name|b
operator|&&
name|setData
argument_list|(
name|index
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|,
name|it
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of MIME types that can be used to describe a list of model     indexes.      \sa mimeData() */
end_comment
begin_function
DECL|function|mimeTypes
name|QStringList
name|QAbstractItemModel
operator|::
name|mimeTypes
parameter_list|()
specifier|const
block|{
name|QStringList
name|types
decl_stmt|;
name|types
operator|<<
name|QLatin1String
argument_list|(
literal|"application/x-qabstractitemmodeldatalist"
argument_list|)
expr_stmt|;
return|return
name|types
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an object that contains serialized items of data corresponding to     the list of \a indexes specified. The formats used to describe the encoded     data is obtained from the mimeTypes() function.      If the list of indexes is empty, or there are no supported MIME types, 0 is     returned rather than a serialized empty list.      \sa mimeTypes(), dropMimeData() */
end_comment
begin_function
DECL|function|mimeData
name|QMimeData
modifier|*
name|QAbstractItemModel
operator|::
name|mimeData
parameter_list|(
specifier|const
name|QModelIndexList
modifier|&
name|indexes
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|indexes
operator|.
name|count
argument_list|()
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|QStringList
name|types
init|=
name|mimeTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|types
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|QMimeData
modifier|*
name|data
init|=
operator|new
name|QMimeData
argument_list|()
decl_stmt|;
name|QString
name|format
init|=
name|types
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QByteArray
name|encoded
decl_stmt|;
name|QDataStream
name|stream
argument_list|(
operator|&
name|encoded
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|encodeData
argument_list|(
name|indexes
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|data
operator|->
name|setData
argument_list|(
name|format
argument_list|,
name|encoded
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*!     Handles the \a data supplied by a drag and drop operation that ended with     the given \a action.      Returns true if the data and action can be handled by the model; otherwise     returns false.      Although the specified \a row, \a column and \a parent indicate the     location of an item in the model where the operation ended, it is the     responsibility of the view to provide a suitable location for where the     data should be inserted.      For instance, a drop action on an item in a QTreeView can result in new     items either being inserted as children of the item specified by \a row,     \a column, and \a parent, or as siblings of the item.      When row and column are -1 it means that it is up to the model to decide     where to place the data. This can occur in a tree when data is dropped on     a parent. Models will usually append the data to the parent in this case.      \sa supportedDropActions(), {Using drag and drop with item views} */
end_comment
begin_function
DECL|function|dropMimeData
name|bool
name|QAbstractItemModel
operator|::
name|dropMimeData
parameter_list|(
specifier|const
name|QMimeData
modifier|*
name|data
parameter_list|,
name|Qt
operator|::
name|DropAction
name|action
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
comment|// check if the action is supported
if|if
condition|(
operator|!
name|data
operator|||
operator|!
operator|(
name|action
operator|==
name|Qt
operator|::
name|CopyAction
operator|||
name|action
operator|==
name|Qt
operator|::
name|MoveAction
operator|)
condition|)
return|return
literal|false
return|;
comment|// check if the format is supported
name|QStringList
name|types
init|=
name|mimeTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|types
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QString
name|format
init|=
name|types
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|hasFormat
argument_list|(
name|format
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|row
operator|>
name|rowCount
argument_list|(
name|parent
argument_list|)
condition|)
name|row
operator|=
name|rowCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|==
operator|-
literal|1
condition|)
name|row
operator|=
name|rowCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|column
operator|==
operator|-
literal|1
condition|)
name|column
operator|=
literal|0
expr_stmt|;
comment|// decode and insert
name|QByteArray
name|encoded
init|=
name|data
operator|->
name|data
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|QDataStream
name|stream
argument_list|(
operator|&
name|encoded
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
decl_stmt|;
return|return
name|decodeData
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|parent
argument_list|,
name|stream
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the drop actions supported by this model.      The default implementation returns Qt::CopyAction. Reimplement this     function if you wish to support additional actions. You must also     reimplement the dropMimeData() function to handle the additional     operations.      \sa dropMimeData(), Qt::DropActions, {Using drag and drop with item     views} */
end_comment
begin_function
DECL|function|supportedDropActions
name|Qt
operator|::
name|DropActions
name|QAbstractItemModel
operator|::
name|supportedDropActions
parameter_list|()
specifier|const
block|{
return|return
name|Qt
operator|::
name|CopyAction
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the actions supported by the data in this model.      The default implementation returns supportedDropActions() unless specific     values have been set with setSupportedDragActions().      supportedDragActions() is used by QAbstractItemView::startDrag() as the     default values when a drag occurs.      \sa Qt::DropActions, {Using drag and drop with item views} */
end_comment
begin_function
DECL|function|supportedDragActions
name|Qt
operator|::
name|DropActions
name|QAbstractItemModel
operator|::
name|supportedDragActions
parameter_list|()
specifier|const
block|{
comment|// ### Qt 5: make this virtual or these properties
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|supportedDragActions
operator|!=
operator|-
literal|1
condition|)
return|return
name|d
operator|->
name|supportedDragActions
return|;
return|return
name|supportedDropActions
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Sets the supported drag \a actions for the items in the model.      \sa supportedDragActions(), {Using drag and drop with item views} */
end_comment
begin_function
DECL|function|setSupportedDragActions
name|void
name|QAbstractItemModel
operator|::
name|setSupportedDragActions
parameter_list|(
name|Qt
operator|::
name|DropActions
name|actions
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|supportedDragActions
operator|=
name|actions
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \note The base class implementation of this function does nothing and     returns false.      On models that support this, inserts \a count rows into the model before     the given \a row. Items in the new row will be children of the item     represented by the \a parent model index.      If \a row is 0, the rows are prepended to any existing rows in the parent.      If \a row is rowCount(), the rows are appended to any existing rows in the     parent.      If \a parent has no children, a single column with \a count rows is     inserted.      Returns true if the rows were successfully inserted; otherwise returns     false.      If you implement your own model, you can reimplement this function if you     want to support insertions. Alternatively, you can provide your own API for     altering the data. In either case, you will need to call     beginInsertRows() and endInsertRows() to notify other components that the     model has changed.      \sa insertColumns(), removeRows(), beginInsertRows(), endInsertRows() */
end_comment
begin_function
DECL|function|insertRows
name|bool
name|QAbstractItemModel
operator|::
name|insertRows
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     On models that support this, inserts \a count new columns into the model     before the given \a column. The items in each new column will be children     of the item represented by the \a parent model index.      If \a column is 0, the columns are prepended to any existing columns.      If \a column is columnCount(), the columns are appended to any existing     columns.      If \a parent has no children, a single row with \a count columns is     inserted.      Returns true if the columns were successfully inserted; otherwise returns     false.      The base class implementation does nothing and returns false.      If you implement your own model, you can reimplement this function if you     want to support insertions. Alternatively, you can provide your own API for     altering the data.      \sa insertRows(), removeColumns(), beginInsertColumns(), endInsertColumns() */
end_comment
begin_function
DECL|function|insertColumns
name|bool
name|QAbstractItemModel
operator|::
name|insertColumns
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     On models that support this, removes \a count rows starting with the given     \a row under parent \a parent from the model.      Returns true if the rows were successfully removed; otherwise returns     false.      The base class implementation does nothing and returns false.      If you implement your own model, you can reimplement this function if you     want to support removing. Alternatively, you can provide your own API for     altering the data.      \sa removeRow(), removeColumns(), insertColumns(), beginRemoveRows(),         endRemoveRows() */
end_comment
begin_function
DECL|function|removeRows
name|bool
name|QAbstractItemModel
operator|::
name|removeRows
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     On models that support this, removes \a count columns starting with the     given \a column under parent \a parent from the model.      Returns true if the columns were successfully removed; otherwise returns     false.      The base class implementation does nothing and returns false.      If you implement your own model, you can reimplement this function if you     want to support removing. Alternatively, you can provide your own API for     altering the data.      \sa removeColumn(), removeRows(), insertColumns(), beginRemoveColumns(),         endRemoveColumns() */
end_comment
begin_function
DECL|function|removeColumns
name|bool
name|QAbstractItemModel
operator|::
name|removeColumns
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Fetches any available data for the items with the parent specified by the     \a parent index.      Reimplement this if you are populating your model incrementally.      The default implementation does nothing.      \sa canFetchMore() */
end_comment
begin_function
DECL|function|fetchMore
name|void
name|QAbstractItemModel
operator|::
name|fetchMore
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
block|{
comment|// do nothing
block|}
end_function
begin_comment
comment|/*!     Returns true if there is more data available for \a parent; otherwise     returns false.      The default implementation always returns false.      If canFetchMore() returns true, QAbstractItemView will call fetchMore().     However, the fetchMore() function is only called when the model is being     populated incrementally.      \sa fetchMore() */
end_comment
begin_function
DECL|function|canFetchMore
name|bool
name|QAbstractItemModel
operator|::
name|canFetchMore
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
specifier|const
block|{
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the item flags for the given \a index.      The base class implementation returns a combination of flags that enables     the item (\c ItemIsEnabled) and allows it to be selected     (\c ItemIsSelectable).      \sa Qt::ItemFlags */
end_comment
begin_function
DECL|function|flags
name|Qt
operator|::
name|ItemFlags
name|QAbstractItemModel
operator|::
name|flags
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|indexValid
argument_list|(
name|index
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|Qt
operator|::
name|ItemIsSelectable
operator||
name|Qt
operator|::
name|ItemIsEnabled
return|;
block|}
end_function
begin_comment
comment|/*!     Sorts the model by \a column in the given \a order.      The base class implementation does nothing. */
end_comment
begin_function
DECL|function|sort
name|void
name|QAbstractItemModel
operator|::
name|sort
parameter_list|(
name|int
name|column
parameter_list|,
name|Qt
operator|::
name|SortOrder
name|order
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|column
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|order
argument_list|)
expr_stmt|;
comment|// do nothing
block|}
end_function
begin_comment
comment|/*!     Returns a model index for the buddy of the item represented by \a index.     When the user wants to edit an item, the view will call this function to     check whether another item in the model should be edited instead. Then, the     view will construct a delegate using the model index returned by the buddy     item.      The default implementation of this function has each item as its own buddy. */
end_comment
begin_function
DECL|function|buddy
name|QModelIndex
name|QAbstractItemModel
operator|::
name|buddy
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|index
parameter_list|)
specifier|const
block|{
return|return
name|index
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of indexes for the items in the column of the \a start index     where data stored under the given \a role matches the specified \a value.     The way the search is performed is defined by the \a flags given. The list     that is returned may be empty.      The search begins from the \a start index, and continues until the number     of matching data items equals \a hits, the search reaches the last row, or     the search reaches \a start again - depending on whether \c MatchWrap is     specified in \a flags. If you want to search for all matching items, use     \a hits = -1.      By default, this function will perform a wrapping, string-based comparison     on all items, searching for items that begin with the search term specified     by \a value.      \note The default implementation of this function only searches columns.     Reimplement this function to include a different search behavior. */
end_comment
begin_function
DECL|function|match
name|QModelIndexList
name|QAbstractItemModel
operator|::
name|match
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|start
parameter_list|,
name|int
name|role
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|,
name|int
name|hits
parameter_list|,
name|Qt
operator|::
name|MatchFlags
name|flags
parameter_list|)
specifier|const
block|{
name|QModelIndexList
name|result
decl_stmt|;
name|uint
name|matchType
init|=
name|flags
operator|&
literal|0x0F
decl_stmt|;
name|Qt
operator|::
name|CaseSensitivity
name|cs
init|=
name|flags
operator|&
name|Qt
operator|::
name|MatchCaseSensitive
condition|?
name|Qt
operator|::
name|CaseSensitive
else|:
name|Qt
operator|::
name|CaseInsensitive
decl_stmt|;
name|bool
name|recurse
init|=
name|flags
operator|&
name|Qt
operator|::
name|MatchRecursive
decl_stmt|;
name|bool
name|wrap
init|=
name|flags
operator|&
name|Qt
operator|::
name|MatchWrap
decl_stmt|;
name|bool
name|allHits
init|=
operator|(
name|hits
operator|==
operator|-
literal|1
operator|)
decl_stmt|;
name|QString
name|text
decl_stmt|;
comment|// only convert to a string if it is needed
name|QModelIndex
name|p
init|=
name|parent
argument_list|(
name|start
argument_list|)
decl_stmt|;
name|int
name|from
init|=
name|start
operator|.
name|row
argument_list|()
decl_stmt|;
name|int
name|to
init|=
name|rowCount
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|// iterates twice if wrapping
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
operator|(
name|wrap
operator|&&
name|i
operator|<
literal|2
operator|)
operator|||
operator|(
operator|!
name|wrap
operator|&&
name|i
operator|<
literal|1
operator|)
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|int
name|r
init|=
name|from
init|;
operator|(
name|r
operator|<
name|to
operator|)
operator|&&
operator|(
name|allHits
operator|||
name|result
operator|.
name|count
argument_list|()
operator|<
name|hits
operator|)
condition|;
operator|++
name|r
control|)
block|{
name|QModelIndex
name|idx
init|=
name|index
argument_list|(
name|r
argument_list|,
name|start
operator|.
name|column
argument_list|()
argument_list|,
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|idx
operator|.
name|isValid
argument_list|()
condition|)
continue|continue;
name|QVariant
name|v
init|=
name|data
argument_list|(
name|idx
argument_list|,
name|role
argument_list|)
decl_stmt|;
comment|// QVariant based matching
if|if
condition|(
name|matchType
operator|==
name|Qt
operator|::
name|MatchExactly
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|v
condition|)
name|result
operator|.
name|append
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// QString based matching
if|if
condition|(
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// lazy conversion
name|text
operator|=
name|value
operator|.
name|toString
argument_list|()
expr_stmt|;
name|QString
name|t
init|=
name|v
operator|.
name|toString
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|matchType
condition|)
block|{
case|case
name|Qt
operator|::
name|MatchRegExp
case|:
if|if
condition|(
name|QRegExp
argument_list|(
name|text
argument_list|,
name|cs
argument_list|)
operator|.
name|exactMatch
argument_list|(
name|t
argument_list|)
condition|)
name|result
operator|.
name|append
argument_list|(
name|idx
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|MatchWildcard
case|:
if|if
condition|(
name|QRegExp
argument_list|(
name|text
argument_list|,
name|cs
argument_list|,
name|QRegExp
operator|::
name|Wildcard
argument_list|)
operator|.
name|exactMatch
argument_list|(
name|t
argument_list|)
condition|)
name|result
operator|.
name|append
argument_list|(
name|idx
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|MatchStartsWith
case|:
if|if
condition|(
name|t
operator|.
name|startsWith
argument_list|(
name|text
argument_list|,
name|cs
argument_list|)
condition|)
name|result
operator|.
name|append
argument_list|(
name|idx
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|MatchEndsWith
case|:
if|if
condition|(
name|t
operator|.
name|endsWith
argument_list|(
name|text
argument_list|,
name|cs
argument_list|)
condition|)
name|result
operator|.
name|append
argument_list|(
name|idx
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|MatchFixedString
case|:
if|if
condition|(
name|t
operator|.
name|compare
argument_list|(
name|text
argument_list|,
name|cs
argument_list|)
operator|==
literal|0
condition|)
name|result
operator|.
name|append
argument_list|(
name|idx
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|MatchContains
case|:
default|default:
if|if
condition|(
name|t
operator|.
name|contains
argument_list|(
name|text
argument_list|,
name|cs
argument_list|)
condition|)
name|result
operator|.
name|append
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|recurse
operator|&&
name|hasChildren
argument_list|(
name|idx
argument_list|)
condition|)
block|{
comment|// search the hierarchy
name|result
operator|+=
name|match
argument_list|(
name|index
argument_list|(
literal|0
argument_list|,
name|idx
operator|.
name|column
argument_list|()
argument_list|,
name|idx
argument_list|)
argument_list|,
name|role
argument_list|,
operator|(
name|text
operator|.
name|isEmpty
argument_list|()
condition|?
name|value
else|:
name|text
operator|)
argument_list|,
operator|(
name|allHits
condition|?
operator|-
literal|1
else|:
name|hits
operator|-
name|result
operator|.
name|count
argument_list|()
operator|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
comment|// prepare for the next iteration
name|from
operator|=
literal|0
expr_stmt|;
name|to
operator|=
name|start
operator|.
name|row
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the row and column span of the item represented by \a index.      \note Currently, span is not used. */
end_comment
begin_function
DECL|function|span
name|QSize
name|QAbstractItemModel
operator|::
name|span
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|QSize
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sets the model's role names to \a roleNames.      This function allows mapping of role identifiers to role property names in     Declarative UI.  This function must be called before the model is used.     Modifying the role names after the model has been set may result in     undefined behaviour.      \sa roleNames() */
end_comment
begin_function
DECL|function|setRoleNames
name|void
name|QAbstractItemModel
operator|::
name|setRoleNames
parameter_list|(
specifier|const
name|QHash
argument_list|<
name|int
argument_list|,
name|QByteArray
argument_list|>
modifier|&
name|roleNames
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|roleNames
operator|=
name|roleNames
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns the model's role names.      \sa setRoleNames() */
end_comment
begin_function
DECL|function|roleNames
specifier|const
name|QHash
argument_list|<
name|int
argument_list|,
name|QByteArray
argument_list|>
modifier|&
name|QAbstractItemModel
operator|::
name|roleNames
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemModel
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|roleNames
return|;
block|}
end_function
begin_comment
comment|/*!     Lets the model know that it should submit cached information to permanent     storage. This function is typically used for row editing.      Returns true if there is no error; otherwise returns false.      \sa revert() */
end_comment
begin_function
DECL|function|submit
name|bool
name|QAbstractItemModel
operator|::
name|submit
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Lets the model know that it should discard cached information. This     function is typically used for row editing.      \sa submit() */
end_comment
begin_function
DECL|function|revert
name|void
name|QAbstractItemModel
operator|::
name|revert
parameter_list|()
block|{
comment|// do nothing
block|}
end_function
begin_comment
comment|/*!     Returns the data for the given \a role and \a section in the header with     the specified \a orientation.      For horizontal headers, the section number corresponds to the column     number. Similarly, for vertical headers, the section number corresponds to     the row number.      \sa Qt::ItemDataRole, setHeaderData(), QHeaderView */
end_comment
begin_function
DECL|function|headerData
name|QVariant
name|QAbstractItemModel
operator|::
name|headerData
parameter_list|(
name|int
name|section
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|,
name|int
name|role
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
if|if
condition|(
name|role
operator|==
name|Qt
operator|::
name|DisplayRole
condition|)
return|return
name|section
operator|+
literal|1
return|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the data for the given \a role and \a section in the header with the     specified \a orientation to the \a value supplied.      Returns true if the header's data was updated; otherwise returns false.      When reimplementing this function, the headerDataChanged() signal must be     emitted explicitly.      \sa Qt::ItemDataRole, headerData() */
end_comment
begin_function
DECL|function|setHeaderData
name|bool
name|QAbstractItemModel
operator|::
name|setHeaderData
parameter_list|(
name|int
name|section
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|,
name|int
name|role
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|section
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|orientation
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|role
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QModelIndex QAbstractItemModel::createIndex(int row, int column, void *ptr) const      Creates a model index for the given \a row and \a column with the internal     pointer \a ptr.      When using a QSortFilterProxyModel, its indexes have their own internal     pointer. It is not advisable to access this internal pointer outside of the     model. Use the data() function instead.      This function provides a consistent interface that model subclasses must     use to create model indexes. */
end_comment
begin_comment
comment|/*!     \fn QModelIndex QAbstractItemModel::createIndex(int row, int column, int id) const     \obsolete      Use QModelIndex     QAbstractItemModel::createIndex(int row, int column, quint32 id) instead. */
end_comment
begin_comment
comment|/*!     \fn QModelIndex QAbstractItemModel::createIndex(int row, int column, quint32 id) const      Creates a model index for the given \a row and \a column with the internal     identifier, \a id.      This function provides a consistent interface that model subclasses must     use to create model indexes.      \sa QModelIndex::internalId() */
end_comment
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|encodeData
name|void
name|QAbstractItemModel
operator|::
name|encodeData
parameter_list|(
specifier|const
name|QModelIndexList
modifier|&
name|indexes
parameter_list|,
name|QDataStream
modifier|&
name|stream
parameter_list|)
specifier|const
block|{
name|QModelIndexList
operator|::
name|ConstIterator
name|it
init|=
name|indexes
operator|.
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|indexes
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
name|stream
operator|<<
operator|(
operator|*
name|it
operator|)
operator|.
name|row
argument_list|()
operator|<<
operator|(
operator|*
name|it
operator|)
operator|.
name|column
argument_list|()
operator|<<
name|itemData
argument_list|(
operator|*
name|it
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal  */
end_comment
begin_function
DECL|function|decodeData
name|bool
name|QAbstractItemModel
operator|::
name|decodeData
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|QDataStream
modifier|&
name|stream
parameter_list|)
block|{
name|int
name|top
init|=
name|INT_MAX
decl_stmt|;
name|int
name|left
init|=
name|INT_MAX
decl_stmt|;
name|int
name|bottom
init|=
literal|0
decl_stmt|;
name|int
name|right
init|=
literal|0
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
name|rows
decl_stmt|,
name|columns
decl_stmt|;
name|QVector
argument_list|<
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
argument_list|>
name|data
decl_stmt|;
while|while
condition|(
operator|!
name|stream
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
name|v
decl_stmt|;
name|stream
operator|>>
name|r
operator|>>
name|c
operator|>>
name|v
expr_stmt|;
name|rows
operator|.
name|append
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|columns
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|data
operator|.
name|append
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|top
operator|=
name|qMin
argument_list|(
name|r
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|left
operator|=
name|qMin
argument_list|(
name|c
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|bottom
operator|=
name|qMax
argument_list|(
name|r
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|right
operator|=
name|qMax
argument_list|(
name|c
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
comment|// insert the dragged items into the table, use a bit array to avoid overwriting items,
comment|// since items from different tables can have the same row and column
name|int
name|dragRowCount
init|=
literal|0
decl_stmt|;
name|int
name|dragColumnCount
init|=
name|right
operator|-
name|left
operator|+
literal|1
decl_stmt|;
comment|// Compute the number of continuous rows upon insertion and modify the rows to match
name|QVector
argument_list|<
name|int
argument_list|>
name|rowsToInsert
argument_list|(
name|bottom
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rows
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|rowsToInsert
index|[
name|rows
operator|.
name|at
argument_list|(
name|i
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowsToInsert
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rowsToInsert
index|[
name|i
index|]
operator|==
literal|1
condition|)
block|{
name|rowsToInsert
index|[
name|i
index|]
operator|=
name|dragRowCount
expr_stmt|;
operator|++
name|dragRowCount
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rows
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|rows
index|[
name|i
index|]
operator|=
name|top
operator|+
name|rowsToInsert
index|[
name|rows
index|[
name|i
index|]
index|]
expr_stmt|;
name|QBitArray
name|isWrittenTo
argument_list|(
name|dragRowCount
operator|*
name|dragColumnCount
argument_list|)
decl_stmt|;
comment|// make space in the table for the dropped data
name|int
name|colCount
init|=
name|columnCount
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|colCount
operator|==
literal|0
condition|)
block|{
name|insertColumns
argument_list|(
name|colCount
argument_list|,
name|dragColumnCount
operator|-
name|colCount
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|colCount
operator|=
name|columnCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
name|insertRows
argument_list|(
name|row
argument_list|,
name|dragRowCount
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|row
operator|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|column
operator|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QPersistentModelIndex
argument_list|>
name|newIndexes
argument_list|(
name|data
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// set the data in the table
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|data
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|int
name|relativeRow
init|=
name|rows
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|-
name|top
decl_stmt|;
name|int
name|relativeColumn
init|=
name|columns
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|-
name|left
decl_stmt|;
name|int
name|destinationRow
init|=
name|relativeRow
operator|+
name|row
decl_stmt|;
name|int
name|destinationColumn
init|=
name|relativeColumn
operator|+
name|column
decl_stmt|;
name|int
name|flat
init|=
operator|(
name|relativeRow
operator|*
name|dragColumnCount
operator|)
operator|+
name|relativeColumn
decl_stmt|;
comment|// if the item was already written to, or we just can't fit it in the table, create a new row
if|if
condition|(
name|destinationColumn
operator|>=
name|colCount
operator|||
name|isWrittenTo
operator|.
name|testBit
argument_list|(
name|flat
argument_list|)
condition|)
block|{
name|destinationColumn
operator|=
name|qBound
argument_list|(
name|column
argument_list|,
name|destinationColumn
argument_list|,
name|colCount
operator|-
literal|1
argument_list|)
expr_stmt|;
name|destinationRow
operator|=
name|row
operator|+
name|dragRowCount
expr_stmt|;
name|insertRows
argument_list|(
name|row
operator|+
name|dragRowCount
argument_list|,
literal|1
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|flat
operator|=
operator|(
name|dragRowCount
operator|*
name|dragColumnCount
operator|)
operator|+
name|relativeColumn
expr_stmt|;
name|isWrittenTo
operator|.
name|resize
argument_list|(
operator|++
name|dragRowCount
operator|*
name|dragColumnCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isWrittenTo
operator|.
name|testBit
argument_list|(
name|flat
argument_list|)
condition|)
block|{
name|newIndexes
index|[
name|j
index|]
operator|=
name|index
argument_list|(
name|destinationRow
argument_list|,
name|destinationColumn
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|isWrittenTo
operator|.
name|setBit
argument_list|(
name|flat
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|newIndexes
operator|.
name|size
argument_list|()
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|newIndexes
operator|.
name|at
argument_list|(
name|k
argument_list|)
operator|.
name|isValid
argument_list|()
condition|)
name|setItemData
argument_list|(
name|newIndexes
operator|.
name|at
argument_list|(
name|k
argument_list|)
argument_list|,
name|data
operator|.
name|at
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Begins a row insertion operation.      When reimplementing insertRows() in a subclass, you must call this function     \e before inserting data into the model's underlying data store.      The \a parent index corresponds to the parent into which the new rows are     inserted; \a first and \a last are the row numbers that the new rows will     have after they have been inserted.      \table 80%     \row         \o  \inlineimage modelview-begin-insert-rows.png Inserting rows         \o  Specify the first and last row numbers for the span of rows you             want to insert into an item in a model.              For example, as shown in the diagram, we insert three rows before             row 2, so \a first is 2 and \a last is 4:              \snippet doc/src/snippets/code/src_corelib_kernel_qabstractitemmodel.cpp 0              This inserts the three new rows as rows 2, 3, and 4.     \row         \o  \inlineimage modelview-begin-append-rows.png Appending rows         \o  To append rows, insert them after the last row.              For example, as shown in the diagram, we append two rows to a             collection of 4 existing rows (ending in row 3), so \a first is 4             and \a last is 5:              \snippet doc/src/snippets/code/src_corelib_kernel_qabstractitemmodel.cpp 1              This appends the two new rows as rows 4 and 5.     \endtable      \note This function emits the rowsAboutToBeInserted() signal which     connected views (or proxies) must handle before the data is inserted.     Otherwise, the views may end up in an invalid state.     \sa endInsertRows() */
end_comment
begin_function
DECL|function|beginInsertRows
name|void
name|QAbstractItemModel
operator|::
name|beginInsertRows
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|first
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|last
operator|>=
name|first
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|changes
operator|.
name|push
argument_list|(
name|QAbstractItemModelPrivate
operator|::
name|Change
argument_list|(
name|parent
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|rowsAboutToBeInserted
argument_list|(
name|parent
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
emit|;
name|d
operator|->
name|rowsAboutToBeInserted
argument_list|(
name|parent
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Ends a row insertion operation.      When reimplementing insertRows() in a subclass, you must call this function     \e after inserting data into the model's underlying data store.      \sa beginInsertRows() */
end_comment
begin_function
DECL|function|endInsertRows
name|void
name|QAbstractItemModel
operator|::
name|endInsertRows
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|QAbstractItemModelPrivate
operator|::
name|Change
name|change
init|=
name|d
operator|->
name|changes
operator|.
name|pop
argument_list|()
decl_stmt|;
name|d
operator|->
name|rowsInserted
argument_list|(
name|change
operator|.
name|parent
argument_list|,
name|change
operator|.
name|first
argument_list|,
name|change
operator|.
name|last
argument_list|)
expr_stmt|;
emit|emit
name|rowsInserted
argument_list|(
name|change
operator|.
name|parent
argument_list|,
name|change
operator|.
name|first
argument_list|,
name|change
operator|.
name|last
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     Begins a row removal operation.      When reimplementing removeRows() in a subclass, you must call this     function \e before removing data from the model's underlying data store.      The \a parent index corresponds to the parent from which the new rows are     removed; \a first and \a last are the row numbers of the rows to be     removed.      \table 80%     \row         \o  \inlineimage modelview-begin-remove-rows.png Removing rows         \o  Specify the first and last row numbers for the span of rows you             want to remove from an item in a model.              For example, as shown in the diagram, we remove the two rows from             row 2 to row 3, so \a first is 2 and \a last is 3:              \snippet doc/src/snippets/code/src_corelib_kernel_qabstractitemmodel.cpp 2     \endtable      \note This function emits the rowsAboutToBeRemoved() signal which connected     views (or proxies) must handle before the data is removed. Otherwise, the     views may end up in an invalid state.      \sa endRemoveRows() */
end_comment
begin_function
DECL|function|beginRemoveRows
name|void
name|QAbstractItemModel
operator|::
name|beginRemoveRows
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|first
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|last
operator|>=
name|first
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|changes
operator|.
name|push
argument_list|(
name|QAbstractItemModelPrivate
operator|::
name|Change
argument_list|(
name|parent
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|rowsAboutToBeRemoved
argument_list|(
name|parent
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
emit|;
name|d
operator|->
name|rowsAboutToBeRemoved
argument_list|(
name|parent
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Ends a row removal operation.      When reimplementing removeRows() in a subclass, you must call this function     \e after removing data from the model's underlying data store.      \sa beginRemoveRows() */
end_comment
begin_function
DECL|function|endRemoveRows
name|void
name|QAbstractItemModel
operator|::
name|endRemoveRows
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|QAbstractItemModelPrivate
operator|::
name|Change
name|change
init|=
name|d
operator|->
name|changes
operator|.
name|pop
argument_list|()
decl_stmt|;
name|d
operator|->
name|rowsRemoved
argument_list|(
name|change
operator|.
name|parent
argument_list|,
name|change
operator|.
name|first
argument_list|,
name|change
operator|.
name|last
argument_list|)
expr_stmt|;
emit|emit
name|rowsRemoved
argument_list|(
name|change
operator|.
name|parent
argument_list|,
name|change
operator|.
name|first
argument_list|,
name|change
operator|.
name|last
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     Returns whether a move operation is valid.      A move operation is not allowed if it moves a continuous range of rows to a destination within     itself, or if it attempts to move a row to one of its own descendants.      \internal */
end_comment
begin_function
DECL|function|allowMove
name|bool
name|QAbstractItemModelPrivate
operator|::
name|allowMove
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|srcParent
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|destinationParent
parameter_list|,
name|int
name|destinationStart
parameter_list|,
name|Qt
operator|::
name|Orientation
name|orientation
parameter_list|)
block|{
comment|// Don't move the range within itself.
if|if
condition|(
name|destinationParent
operator|==
name|srcParent
condition|)
return|return
operator|!
operator|(
name|destinationStart
operator|>=
name|start
operator|&&
name|destinationStart
operator|<=
name|end
operator|+
literal|1
operator|)
return|;
name|QModelIndex
name|destinationAncestor
init|=
name|destinationParent
decl_stmt|;
name|int
name|pos
init|=
operator|(
name|Qt
operator|::
name|Vertical
operator|==
name|orientation
operator|)
condition|?
name|destinationAncestor
operator|.
name|row
argument_list|()
else|:
name|destinationAncestor
operator|.
name|column
argument_list|()
decl_stmt|;
forever|forever
block|{
if|if
condition|(
name|destinationAncestor
operator|==
name|srcParent
condition|)
block|{
if|if
condition|(
name|pos
operator|>=
name|start
operator|&&
name|pos
operator|<=
name|end
condition|)
return|return
literal|false
return|;
break|break;
block|}
if|if
condition|(
operator|!
name|destinationAncestor
operator|.
name|isValid
argument_list|()
condition|)
break|break;
name|pos
operator|=
operator|(
name|Qt
operator|::
name|Vertical
operator|==
name|orientation
operator|)
condition|?
name|destinationAncestor
operator|.
name|row
argument_list|()
else|:
name|destinationAncestor
operator|.
name|column
argument_list|()
expr_stmt|;
name|destinationAncestor
operator|=
name|destinationAncestor
operator|.
name|parent
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Begins a row move operation.      When reimplementing a subclass, this method simplifies moving     entities in your model. This method is responsible for moving     persistent indexes in the model, which you would otherwise be     required to do yourself. Using beginMoveRows and endMoveRows     is an alternative to emitting layoutAboutToBeChanged and     layoutChanged directly along with changePersistentIndexes.     layoutAboutToBeChanged is emitted by this method for compatibility     reasons.      The \a sourceParent index corresponds to the parent from which the     rows are moved; \a sourceFirst and \a sourceLast are the first and last     row numbers of the rows to be moved. The \a destinationParent index     corresponds to the parent into which those rows are moved. The \a     destinationChild is the row to which the rows will be moved.  That     is, the index at row \a sourceFirst in \a sourceParent will become     row \a destinationChild in \a destinationParent, followed by all other     rows up to \a sourceLast.      However, when moving rows down in the same parent (\a sourceParent     and \a destinationParent are equal), the rows will be placed before the     \a destinationChild index. That is, if you wish to move rows 0 and 1 so     they will become rows 1 and 2, \a destinationChild should be 3. In this     case, the new index for the source row \c i (which is between     \a sourceFirst and \a sourceLast) is equal to     \c {(destinationChild-sourceLast-1+i)}.      Note that if \a sourceParent and \a destinationParent are the same,     you must ensure that the \a destinationChild is not within the range     of \a sourceFirst and \a sourceLast + 1.  You must also ensure that you     do not attempt to move a row to one of its own children or ancestors.     This method returns false if either condition is true, in which case you     should abort your move operation.      \table 80%     \row         \o  \inlineimage modelview-move-rows-1.png Moving rows to another parent         \o  Specify the first and last row numbers for the span of rows in             the source parent you want to move in the model. Also specify             the row in the destination parent to move the span to.              For example, as shown in the diagram, we move three rows from             row 2 to 4 in the source, so \a sourceFirst is 2 and \a sourceLast is 4.             We move those items to above row 2 in the destination, so \a destinationChild is 2.              \snippet doc/src/snippets/code/src_corelib_kernel_qabstractitemmodel.cpp 6              This moves the three rows rows 2, 3, and 4 in the source to become 2, 3 and 4 in             the destination. Other affected siblings are displaced accordingly.     \row         \o  \inlineimage modelview-move-rows-2.png Moving rows to append to another parent         \o  To append rows to another parent, move them to after the last row.              For example, as shown in the diagram, we move three rows to a             collection of 6 existing rows (ending in row 5), so \a destinationChild is 6:              \snippet doc/src/snippets/code/src_corelib_kernel_qabstractitemmodel.cpp 7              This moves the target rows to the end of the target parent as 6, 7 and 8.     \row         \o  \inlineimage modelview-move-rows-3.png Moving rows in the same parent up         \o  To move rows within the same parent, specify the row to move them to.              For example, as shown in the diagram, we move one item from row 2 to row 0,             so \a sourceFirst and \a sourceLast are 2 and \a destinationChild is 0.              \snippet doc/src/snippets/code/src_corelib_kernel_qabstractitemmodel.cpp 8              Note that other rows may be displaced accordingly. Note also that when moving             items within the same parent you should not attempt invalid or no-op moves. In             the above example, item 2 is at row 2 before the move, so it can not be moved             to row 2 (where it is already) or row 3 (no-op as row 3 means above row 3, where             it is already)      \row         \o  \inlineimage modelview-move-rows-4.png Moving rows in the same parent down         \o  To move rows within the same parent, specify the row to move them to.              For example, as shown in the diagram, we move one item from row 2 to row 4,             so \a sourceFirst and \a sourceLast are 2 and \a destinationChild is 4.              \snippet doc/src/snippets/code/src_corelib_kernel_qabstractitemmodel.cpp 9              Note that other rows may be displaced accordingly.     \endtable      \sa endMoveRows() */
end_comment
begin_function
DECL|function|beginMoveRows
name|bool
name|QAbstractItemModel
operator|::
name|beginMoveRows
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|sourceParent
parameter_list|,
name|int
name|sourceFirst
parameter_list|,
name|int
name|sourceLast
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|destinationParent
parameter_list|,
name|int
name|destinationChild
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|sourceFirst
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|sourceLast
operator|>=
name|sourceFirst
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|destinationChild
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|allowMove
argument_list|(
name|sourceParent
argument_list|,
name|sourceFirst
argument_list|,
name|sourceLast
argument_list|,
name|destinationParent
argument_list|,
name|destinationChild
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|QAbstractItemModelPrivate
operator|::
name|Change
name|sourceChange
argument_list|(
name|sourceParent
argument_list|,
name|sourceFirst
argument_list|,
name|sourceLast
argument_list|)
decl_stmt|;
name|sourceChange
operator|.
name|needsAdjust
operator|=
name|sourceParent
operator|.
name|isValid
argument_list|()
operator|&&
name|sourceParent
operator|.
name|row
argument_list|()
operator|>=
name|destinationChild
operator|&&
name|sourceParent
operator|.
name|parent
argument_list|()
operator|==
name|destinationParent
expr_stmt|;
name|d
operator|->
name|changes
operator|.
name|push
argument_list|(
name|sourceChange
argument_list|)
expr_stmt|;
name|int
name|destinationLast
init|=
name|destinationChild
operator|+
operator|(
name|sourceLast
operator|-
name|sourceFirst
operator|)
decl_stmt|;
name|QAbstractItemModelPrivate
operator|::
name|Change
name|destinationChange
argument_list|(
name|destinationParent
argument_list|,
name|destinationChild
argument_list|,
name|destinationLast
argument_list|)
decl_stmt|;
name|destinationChange
operator|.
name|needsAdjust
operator|=
name|destinationParent
operator|.
name|isValid
argument_list|()
operator|&&
name|destinationParent
operator|.
name|row
argument_list|()
operator|>=
name|sourceLast
operator|&&
name|destinationParent
operator|.
name|parent
argument_list|()
operator|==
name|sourceParent
expr_stmt|;
name|d
operator|->
name|changes
operator|.
name|push
argument_list|(
name|destinationChange
argument_list|)
expr_stmt|;
emit|emit
name|rowsAboutToBeMoved
argument_list|(
name|sourceParent
argument_list|,
name|sourceFirst
argument_list|,
name|sourceLast
argument_list|,
name|destinationParent
argument_list|,
name|destinationChild
argument_list|)
emit|;
emit|emit
name|layoutAboutToBeChanged
argument_list|()
emit|;
name|d
operator|->
name|itemsAboutToBeMoved
argument_list|(
name|sourceParent
argument_list|,
name|sourceFirst
argument_list|,
name|sourceLast
argument_list|,
name|destinationParent
argument_list|,
name|destinationChild
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Ends a row move operation.      When implementing a subclass, you must call this     function \e after moving data within the model's underlying data     store.      layoutChanged is emitted by this method for compatibility reasons.      \sa beginMoveRows()      \since 4.6 */
end_comment
begin_function
DECL|function|endMoveRows
name|void
name|QAbstractItemModel
operator|::
name|endMoveRows
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|QAbstractItemModelPrivate
operator|::
name|Change
name|insertChange
init|=
name|d
operator|->
name|changes
operator|.
name|pop
argument_list|()
decl_stmt|;
name|QAbstractItemModelPrivate
operator|::
name|Change
name|removeChange
init|=
name|d
operator|->
name|changes
operator|.
name|pop
argument_list|()
decl_stmt|;
name|QModelIndex
name|adjustedSource
init|=
name|removeChange
operator|.
name|parent
decl_stmt|;
name|QModelIndex
name|adjustedDestination
init|=
name|insertChange
operator|.
name|parent
decl_stmt|;
specifier|const
name|int
name|numMoved
init|=
name|removeChange
operator|.
name|last
operator|-
name|removeChange
operator|.
name|first
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|insertChange
operator|.
name|needsAdjust
condition|)
name|adjustedDestination
operator|=
name|createIndex
argument_list|(
name|adjustedDestination
operator|.
name|row
argument_list|()
operator|-
name|numMoved
argument_list|,
name|adjustedDestination
operator|.
name|column
argument_list|()
argument_list|,
name|adjustedDestination
operator|.
name|internalPointer
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|removeChange
operator|.
name|needsAdjust
condition|)
name|adjustedSource
operator|=
name|createIndex
argument_list|(
name|adjustedSource
operator|.
name|row
argument_list|()
operator|+
name|numMoved
argument_list|,
name|adjustedSource
operator|.
name|column
argument_list|()
argument_list|,
name|adjustedSource
operator|.
name|internalPointer
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|itemsMoved
argument_list|(
name|adjustedSource
argument_list|,
name|removeChange
operator|.
name|first
argument_list|,
name|removeChange
operator|.
name|last
argument_list|,
name|adjustedDestination
argument_list|,
name|insertChange
operator|.
name|first
argument_list|,
name|Qt
operator|::
name|Vertical
argument_list|)
expr_stmt|;
emit|emit
name|rowsMoved
argument_list|(
name|adjustedSource
argument_list|,
name|removeChange
operator|.
name|first
argument_list|,
name|removeChange
operator|.
name|last
argument_list|,
name|adjustedDestination
argument_list|,
name|insertChange
operator|.
name|first
argument_list|)
emit|;
emit|emit
name|layoutChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     Begins a column insertion operation.      When reimplementing insertColumns() in a subclass, you must call this     function \e before inserting data into the model's underlying data store.      The \a parent index corresponds to the parent into which the new columns     are inserted; \a first and \a last are the column numbers of the new     columns will have after they have been inserted.      \table 80%     \row         \o  \inlineimage modelview-begin-insert-columns.png Inserting columns         \o  Specify the first and last column numbers for the span of columns             you want to insert into an item in a model.              For example, as shown in the diagram, we insert three columns             before column 4, so \a first is 4 and \a last is 6:              \snippet doc/src/snippets/code/src_corelib_kernel_qabstractitemmodel.cpp 3              This inserts the three new columns as columns 4, 5, and 6.     \row         \o  \inlineimage modelview-begin-append-columns.png Appending columns         \o  To append columns, insert them after the last column.              For example, as shown in the diagram, we append three columns to a             collection of six existing columns (ending in column 5), so             \a first is 6 and \a last is 8:              \snippet doc/src/snippets/code/src_corelib_kernel_qabstractitemmodel.cpp 4              This appends the two new columns as columns 6, 7, and 8.     \endtable      \note This function emits the columnsAboutToBeInserted() signal which     connected views (or proxies) must handle before the data is inserted.     Otherwise, the views may end up in an invalid state.      \sa endInsertColumns() */
end_comment
begin_function
DECL|function|beginInsertColumns
name|void
name|QAbstractItemModel
operator|::
name|beginInsertColumns
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|first
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|last
operator|>=
name|first
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|changes
operator|.
name|push
argument_list|(
name|QAbstractItemModelPrivate
operator|::
name|Change
argument_list|(
name|parent
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|columnsAboutToBeInserted
argument_list|(
name|parent
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
emit|;
name|d
operator|->
name|columnsAboutToBeInserted
argument_list|(
name|parent
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Ends a column insertion operation.      When reimplementing insertColumns() in a subclass, you must call this     function \e after inserting data into the model's underlying data     store.      \sa beginInsertColumns() */
end_comment
begin_function
DECL|function|endInsertColumns
name|void
name|QAbstractItemModel
operator|::
name|endInsertColumns
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|QAbstractItemModelPrivate
operator|::
name|Change
name|change
init|=
name|d
operator|->
name|changes
operator|.
name|pop
argument_list|()
decl_stmt|;
name|d
operator|->
name|columnsInserted
argument_list|(
name|change
operator|.
name|parent
argument_list|,
name|change
operator|.
name|first
argument_list|,
name|change
operator|.
name|last
argument_list|)
expr_stmt|;
emit|emit
name|columnsInserted
argument_list|(
name|change
operator|.
name|parent
argument_list|,
name|change
operator|.
name|first
argument_list|,
name|change
operator|.
name|last
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     Begins a column removal operation.      When reimplementing removeColumns() in a subclass, you must call this     function \e before removing data from the model's underlying data store.      The \a parent index corresponds to the parent from which the new columns     are removed; \a first and \a last are the column numbers of the first and     last columns to be removed.      \table 80%     \row         \o  \inlineimage modelview-begin-remove-columns.png Removing columns         \o  Specify the first and last column numbers for the span of columns             you want to remove from an item in a model.              For example, as shown in the diagram, we remove the three columns             from column 4 to column 6, so \a first is 4 and \a last is 6:              \snippet doc/src/snippets/code/src_corelib_kernel_qabstractitemmodel.cpp 5     \endtable      \note This function emits the columnsAboutToBeRemoved() signal which     connected views (or proxies) must handle before the data is removed.     Otherwise, the views may end up in an invalid state.      \sa endRemoveColumns() */
end_comment
begin_function
DECL|function|beginRemoveColumns
name|void
name|QAbstractItemModel
operator|::
name|beginRemoveColumns
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|first
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|last
operator|>=
name|first
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|changes
operator|.
name|push
argument_list|(
name|QAbstractItemModelPrivate
operator|::
name|Change
argument_list|(
name|parent
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|columnsAboutToBeRemoved
argument_list|(
name|parent
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
emit|;
name|d
operator|->
name|columnsAboutToBeRemoved
argument_list|(
name|parent
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Ends a column removal operation.      When reimplementing removeColumns() in a subclass, you must call this     function \e after removing data from the model's underlying data store.      \sa beginRemoveColumns() */
end_comment
begin_function
DECL|function|endRemoveColumns
name|void
name|QAbstractItemModel
operator|::
name|endRemoveColumns
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|QAbstractItemModelPrivate
operator|::
name|Change
name|change
init|=
name|d
operator|->
name|changes
operator|.
name|pop
argument_list|()
decl_stmt|;
name|d
operator|->
name|columnsRemoved
argument_list|(
name|change
operator|.
name|parent
argument_list|,
name|change
operator|.
name|first
argument_list|,
name|change
operator|.
name|last
argument_list|)
expr_stmt|;
emit|emit
name|columnsRemoved
argument_list|(
name|change
operator|.
name|parent
argument_list|,
name|change
operator|.
name|first
argument_list|,
name|change
operator|.
name|last
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     Begins a column move operation.      When reimplementing a subclass, this method simplifies moving     entities in your model. This method is responsible for moving     persistent indexes in the model, which you would otherwise be     required to do yourself. Using beginMoveRows and endMoveRows     is an alternative to emitting layoutAboutToBeChanged and     layoutChanged directly along with changePersistentIndexes.     layoutAboutToBeChanged is emitted by this method for compatibility     reasons.      The \a sourceParent index corresponds to the parent from which the     columns are moved; \a sourceFirst and \a sourceLast are the first and last     column numbers of the columns to be moved. The \a destinationParent index     corresponds to the parent into which those columns are moved. The \a     destinationChild is the column to which the columns will be moved.  That     is, the index at column \a sourceFirst in \a sourceParent will become     column \a destinationChild in \a destinationParent, followed by all other     columns up to \a sourceLast.      However, when moving columns down in the same parent (\a sourceParent     and \a destinationParent are equal), the columnss will be placed before the     \a destinationChild index. That is, if you wish to move columns 0 and 1 so     they will become columns 1 and 2, \a destinationChild should be 3. In this     case, the new index for the source column \c i (which is between     \a sourceFirst and \a sourceLast) is equal to     \c {(destinationChild-sourceLast-1+i)}.      Note that if \a sourceParent and \a destinationParent are the same,     you must ensure that the \a destinationChild is not within the range     of \a sourceFirst and \a sourceLast + 1.  You must also ensure that you     do not attempt to move a column to one of its own children or ancestors.     This method returns false if either condition is true, in which case you     should abort your move operation.      \sa endMoveColumns()      \since 4.6 */
end_comment
begin_function
DECL|function|beginMoveColumns
name|bool
name|QAbstractItemModel
operator|::
name|beginMoveColumns
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|sourceParent
parameter_list|,
name|int
name|sourceFirst
parameter_list|,
name|int
name|sourceLast
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|destinationParent
parameter_list|,
name|int
name|destinationChild
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|sourceFirst
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|sourceLast
operator|>=
name|sourceFirst
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|destinationChild
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|allowMove
argument_list|(
name|sourceParent
argument_list|,
name|sourceFirst
argument_list|,
name|sourceLast
argument_list|,
name|destinationParent
argument_list|,
name|destinationChild
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|QAbstractItemModelPrivate
operator|::
name|Change
name|sourceChange
argument_list|(
name|sourceParent
argument_list|,
name|sourceFirst
argument_list|,
name|sourceLast
argument_list|)
decl_stmt|;
name|sourceChange
operator|.
name|needsAdjust
operator|=
name|sourceParent
operator|.
name|isValid
argument_list|()
operator|&&
name|sourceParent
operator|.
name|row
argument_list|()
operator|>=
name|destinationChild
operator|&&
name|sourceParent
operator|.
name|parent
argument_list|()
operator|==
name|destinationParent
expr_stmt|;
name|d
operator|->
name|changes
operator|.
name|push
argument_list|(
name|sourceChange
argument_list|)
expr_stmt|;
name|int
name|destinationLast
init|=
name|destinationChild
operator|+
operator|(
name|sourceLast
operator|-
name|sourceFirst
operator|)
decl_stmt|;
name|QAbstractItemModelPrivate
operator|::
name|Change
name|destinationChange
argument_list|(
name|destinationParent
argument_list|,
name|destinationChild
argument_list|,
name|destinationLast
argument_list|)
decl_stmt|;
name|destinationChange
operator|.
name|needsAdjust
operator|=
name|destinationParent
operator|.
name|isValid
argument_list|()
operator|&&
name|destinationParent
operator|.
name|row
argument_list|()
operator|>=
name|sourceLast
operator|&&
name|destinationParent
operator|.
name|parent
argument_list|()
operator|==
name|sourceParent
expr_stmt|;
name|d
operator|->
name|changes
operator|.
name|push
argument_list|(
name|destinationChange
argument_list|)
expr_stmt|;
name|d
operator|->
name|itemsAboutToBeMoved
argument_list|(
name|sourceParent
argument_list|,
name|sourceFirst
argument_list|,
name|sourceLast
argument_list|,
name|destinationParent
argument_list|,
name|destinationChild
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|)
expr_stmt|;
emit|emit
name|columnsAboutToBeMoved
argument_list|(
name|sourceParent
argument_list|,
name|sourceFirst
argument_list|,
name|sourceLast
argument_list|,
name|destinationParent
argument_list|,
name|destinationChild
argument_list|)
emit|;
emit|emit
name|layoutAboutToBeChanged
argument_list|()
emit|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Ends a column move operation.      When implementing a subclass, you must call this     function \e after moving data within the model's underlying data     store.      layoutChanged is emitted by this method for compatibility reasons.      \sa beginMoveColumns()      \since 4.6 */
end_comment
begin_function
DECL|function|endMoveColumns
name|void
name|QAbstractItemModel
operator|::
name|endMoveColumns
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|QAbstractItemModelPrivate
operator|::
name|Change
name|insertChange
init|=
name|d
operator|->
name|changes
operator|.
name|pop
argument_list|()
decl_stmt|;
name|QAbstractItemModelPrivate
operator|::
name|Change
name|removeChange
init|=
name|d
operator|->
name|changes
operator|.
name|pop
argument_list|()
decl_stmt|;
name|QModelIndex
name|adjustedSource
init|=
name|removeChange
operator|.
name|parent
decl_stmt|;
name|QModelIndex
name|adjustedDestination
init|=
name|insertChange
operator|.
name|parent
decl_stmt|;
specifier|const
name|int
name|numMoved
init|=
name|removeChange
operator|.
name|last
operator|-
name|removeChange
operator|.
name|first
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|insertChange
operator|.
name|needsAdjust
condition|)
name|adjustedDestination
operator|=
name|createIndex
argument_list|(
name|adjustedDestination
operator|.
name|row
argument_list|()
argument_list|,
name|adjustedDestination
operator|.
name|column
argument_list|()
operator|-
name|numMoved
argument_list|,
name|adjustedDestination
operator|.
name|internalPointer
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|removeChange
operator|.
name|needsAdjust
condition|)
name|adjustedSource
operator|=
name|createIndex
argument_list|(
name|adjustedSource
operator|.
name|row
argument_list|()
argument_list|,
name|adjustedSource
operator|.
name|column
argument_list|()
operator|+
name|numMoved
argument_list|,
name|adjustedSource
operator|.
name|internalPointer
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|itemsMoved
argument_list|(
name|adjustedSource
argument_list|,
name|removeChange
operator|.
name|first
argument_list|,
name|removeChange
operator|.
name|last
argument_list|,
name|adjustedDestination
argument_list|,
name|insertChange
operator|.
name|first
argument_list|,
name|Qt
operator|::
name|Horizontal
argument_list|)
expr_stmt|;
emit|emit
name|columnsMoved
argument_list|(
name|adjustedSource
argument_list|,
name|removeChange
operator|.
name|first
argument_list|,
name|removeChange
operator|.
name|last
argument_list|,
name|adjustedDestination
argument_list|,
name|insertChange
operator|.
name|first
argument_list|)
emit|;
emit|emit
name|layoutChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     Resets the model to its original state in any attached views.      \note Use beginResetModel() and endResetModel() instead whenever possible.     Use this method only if there is no way to call beginResetModel() before invalidating the model.     Otherwise it could lead to unexpected behaviour, especially when used with proxy models. */
end_comment
begin_function
DECL|function|reset
name|void
name|QAbstractItemModel
operator|::
name|reset
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
emit|emit
name|modelAboutToBeReset
argument_list|()
emit|;
name|d
operator|->
name|invalidatePersistentIndexes
argument_list|()
expr_stmt|;
emit|emit
name|modelReset
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     Begins a model reset operation.      A reset operation resets the model to its current state in any attached views.      \note Any views attached to this model will be reset as well.      When a model is reset it means that any previous data reported from the     model is now invalid and has to be queried for again. This also means that     the current item and any selected items will become invalid.      When a model radically changes its data it can sometimes be easier to just     call this function rather than emit dataChanged() to inform other     components when the underlying data source, or its structure, has changed.      You must call this function before resetting any internal data structures in your model     or proxy model.      \sa modelAboutToBeReset(), modelReset(), endResetModel()     \since 4.6 */
end_comment
begin_function
DECL|function|beginResetModel
name|void
name|QAbstractItemModel
operator|::
name|beginResetModel
parameter_list|()
block|{
emit|emit
name|modelAboutToBeReset
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     Completes a model reset operation.      You must call this function after resetting any internal data structure in your model     or proxy model.      \sa beginResetModel()     \since 4.6 */
end_comment
begin_function
DECL|function|endResetModel
name|void
name|QAbstractItemModel
operator|::
name|endResetModel
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|d
operator|->
name|invalidatePersistentIndexes
argument_list|()
expr_stmt|;
emit|emit
name|modelReset
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     Changes the QPersistentModelIndex that is equal to the given \a from model     index to the given \a to model index.      If no persistent model index equal to the given \a from model index was     found, nothing is changed.      \sa persistentIndexList(), changePersistentIndexList() */
end_comment
begin_function
DECL|function|changePersistentIndex
name|void
name|QAbstractItemModel
operator|::
name|changePersistentIndex
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|from
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|to
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|persistent
operator|.
name|indexes
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// find the data and reinsert it sorted
specifier|const
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
modifier|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|d
operator|->
name|persistent
operator|.
name|indexes
operator|.
name|find
argument_list|(
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|d
operator|->
name|persistent
operator|.
name|indexes
operator|.
name|end
argument_list|()
condition|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
name|d
operator|->
name|persistent
operator|.
name|indexes
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|data
operator|->
name|index
operator|=
name|to
expr_stmt|;
if|if
condition|(
name|to
operator|.
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|persistent
operator|.
name|insertMultiAtEnd
argument_list|(
name|to
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|data
operator|->
name|model
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Changes the QPersistentModelIndexes that is equal to the indexes in the     given \a from model index list to the given \a to model index list.      If no persistent model indexes equal to the indexes in the given \a from     model index list was found, nothing is changed.      \sa persistentIndexList(), changePersistentIndex() */
end_comment
begin_function
DECL|function|changePersistentIndexList
name|void
name|QAbstractItemModel
operator|::
name|changePersistentIndexList
parameter_list|(
specifier|const
name|QModelIndexList
modifier|&
name|from
parameter_list|,
specifier|const
name|QModelIndexList
modifier|&
name|to
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractItemModel
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|persistent
operator|.
name|indexes
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QVector
argument_list|<
name|QPersistentModelIndexData
modifier|*
argument_list|>
name|toBeReinserted
decl_stmt|;
name|toBeReinserted
operator|.
name|reserve
argument_list|(
name|to
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|from
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|from
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|to
operator|.
name|at
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
specifier|const
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
modifier|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|d
operator|->
name|persistent
operator|.
name|indexes
operator|.
name|find
argument_list|(
name|from
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|d
operator|->
name|persistent
operator|.
name|indexes
operator|.
name|end
argument_list|()
condition|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
name|d
operator|->
name|persistent
operator|.
name|indexes
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|data
operator|->
name|index
operator|=
name|to
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|index
operator|.
name|isValid
argument_list|()
condition|)
name|toBeReinserted
operator|<<
name|data
expr_stmt|;
else|else
name|data
operator|->
name|model
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|QVector
argument_list|<
name|QPersistentModelIndexData
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|toBeReinserted
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|toBeReinserted
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
name|d
operator|->
name|persistent
operator|.
name|insertMultiAtEnd
argument_list|(
name|data
operator|->
name|index
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns the list of indexes stored as persistent indexes in the model. */
end_comment
begin_function
DECL|function|persistentIndexList
name|QModelIndexList
name|QAbstractItemModel
operator|::
name|persistentIndexList
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractItemModel
argument_list|)
expr_stmt|;
name|QModelIndexList
name|result
decl_stmt|;
for|for
control|(
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
operator|*
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|d
operator|->
name|persistent
operator|.
name|indexes
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|d
operator|->
name|persistent
operator|.
name|indexes
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QPersistentModelIndexData
modifier|*
name|data
init|=
operator|*
name|it
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
name|data
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \class QAbstractTableModel     \brief The QAbstractTableModel class provides an abstract model that can be     subclassed to create table models.      \ingroup model-view      QAbstractTableModel provides a standard interface for models that represent     their data as a two-dimensional array of items. It is not used directly,     but must be subclassed.      Since the model provides a more specialized interface than     QAbstractItemModel, it is not suitable for use with tree views, although it     can be used to provide data to a QListView. If you need to represent a     simple list of items, and only need a model to contain a single column of     data, subclassing the QAbstractListModel may be more appropriate.      The rowCount() and columnCount() functions return the dimensions of the     table. To retrieve a model index corresponding to an item in the model, use     index() and provide only the row and column numbers.      \section1 Subclassing      When subclassing QAbstractTableModel, you must implement rowCount(),     columnCount(), and data(). Default implementations of the index() and     parent() functions are provided by QAbstractTableModel.     Well behaved models will also implement headerData().      Editable models need to implement setData(), and implement flags() to     return a value containing     \l{Qt::ItemFlags}{Qt::ItemIsEditable}.      Models that provide interfaces to resizable data structures can     provide implementations of insertRows(), removeRows(), insertColumns(),     and removeColumns(). When implementing these functions, it is     important to call the appropriate functions so that all connected views     are aware of any changes:      \list     \o An insertRows() implementation must call beginInsertRows()        \e before inserting new rows into the data structure, and it must        call endInsertRows() \e{immediately afterwards}.     \o An insertColumns() implementation must call beginInsertColumns()        \e before inserting new columns into the data structure, and it must        call endInsertColumns() \e{immediately afterwards}.     \o A removeRows() implementation must call beginRemoveRows()        \e before the rows are removed from the data structure, and it must        call endRemoveRows() \e{immediately afterwards}.     \o A removeColumns() implementation must call beginRemoveColumns()        \e before the columns are removed from the data structure, and it must        call endRemoveColumns() \e{immediately afterwards}.     \endlist      \note Some general guidelines for subclassing models are available in the     \l{Model Subclassing Reference}.      \note      \sa {Model Classes}, QAbstractItemModel, QAbstractListModel,     {Pixelator Example} */
end_comment
begin_comment
comment|/*!     Constructs an abstract table model for the given \a parent. */
end_comment
begin_constructor
DECL|function|QAbstractTableModel
name|QAbstractTableModel
operator|::
name|QAbstractTableModel
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractItemModel
argument_list|(
name|parent
argument_list|)
block|{  }
end_constructor
begin_comment
comment|/*!     \internal      Constructs an abstract table model with \a dd and the given \a parent. */
end_comment
begin_constructor
DECL|function|QAbstractTableModel
name|QAbstractTableModel
operator|::
name|QAbstractTableModel
parameter_list|(
name|QAbstractItemModelPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractItemModel
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{  }
end_constructor
begin_comment
comment|/*!     Destroys the abstract table model. */
end_comment
begin_destructor
DECL|function|~QAbstractTableModel
name|QAbstractTableModel
operator|::
name|~
name|QAbstractTableModel
parameter_list|()
block|{  }
end_destructor
begin_comment
comment|/*!     \fn QModelIndex QAbstractTableModel::index(int row, int column, const QModelIndex&parent = QModelIndex()) const      Returns the index of the data in \a row and \a column with \a parent.      \sa parent() */
end_comment
begin_function
DECL|function|index
name|QModelIndex
name|QAbstractTableModel
operator|::
name|index
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
return|return
name|hasIndex
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|parent
argument_list|)
condition|?
name|createIndex
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
literal|0
argument_list|)
else|:
name|QModelIndex
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QModelIndex QAbstractTableModel::parent(const QModelIndex&index) const      Returns the parent of the model item with the given \a index.      \sa index() hasChildren() */
end_comment
begin_function
DECL|function|parent
name|QModelIndex
name|QAbstractTableModel
operator|::
name|parent
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|QModelIndex
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|hasChildren
name|bool
name|QAbstractTableModel
operator|::
name|hasChildren
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|parent
operator|.
name|model
argument_list|()
operator|==
name|this
operator|||
operator|!
name|parent
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|rowCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
operator|&&
name|columnCount
argument_list|(
name|parent
argument_list|)
operator|>
literal|0
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \class QAbstractListModel     \brief The QAbstractListModel class provides an abstract model that can be     subclassed to create one-dimensional list models.      \ingroup model-view      QAbstractListModel provides a standard interface for models that represent     their data as a simple non-hierarchical sequence of items. It is not used     directly, but must be subclassed.      Since the model provides a more specialized interface than     QAbstractItemModel, it is not suitable for use with tree views; you will     need to subclass QAbstractItemModel if you want to provide a model for     that purpose. If you need to use a number of list models to manage data,     it may be more appropriate to subclass QAbstractTableModel class instead.      Simple models can be created by subclassing this class and implementing     the minimum number of required functions. For example, we could implement     a simple read-only QStringList-based model that provides a list of strings     to a QListView widget. In such a case, we only need to implement the     rowCount() function to return the number of items in the list, and the     data() function to retrieve items from the list.      Since the model represents a one-dimensional structure, the rowCount()     function returns the total number of items in the model. The columnCount()     function is implemented for interoperability with all kinds of views, but     by default informs views that the model contains only one column.      \section1 Subclassing      When subclassing QAbstractListModel, you must provide implementations     of the rowCount() and data() functions. Well behaved models also provide     a headerData() implementation.      For editable list models, you must also provide an implementation of     setData(), implement the flags() function so that it returns a value     containing \l{Qt::ItemFlags}{Qt::ItemIsEditable}.      Note that QAbstractListModel provides a default implementation of     columnCount() that informs views that there is only a single column     of items in this model.      Models that provide interfaces to resizable list-like data structures     can provide implementations of insertRows() and removeRows(). When     implementing these functions, it is important to call the appropriate     functions so that all connected views are aware of any changes:      \list     \o An insertRows() implementation must call beginInsertRows()        \e before inserting new rows into the data structure, and it must        call endInsertRows() \e{immediately afterwards}.     \o A removeRows() implementation must call beginRemoveRows()        \e before the rows are removed from the data structure, and it must        call endRemoveRows() \e{immediately afterwards}.     \endlist      \note Some general guidelines for subclassing models are available in the     \l{Model Subclassing Reference}.      \sa {Model Classes}, {Model Subclassing Reference}, QAbstractItemView,         QAbstractTableModel, {Item Views Puzzle Example} */
end_comment
begin_comment
comment|/*!     Constructs an abstract list model with the given \a parent. */
end_comment
begin_constructor
DECL|function|QAbstractListModel
name|QAbstractListModel
operator|::
name|QAbstractListModel
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractItemModel
argument_list|(
name|parent
argument_list|)
block|{  }
end_constructor
begin_comment
comment|/*!     \internal      Constructs an abstract list model with \a dd and the given \a parent. */
end_comment
begin_constructor
DECL|function|QAbstractListModel
name|QAbstractListModel
operator|::
name|QAbstractListModel
parameter_list|(
name|QAbstractItemModelPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractItemModel
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{  }
end_constructor
begin_comment
comment|/*!     Destroys the abstract list model. */
end_comment
begin_destructor
DECL|function|~QAbstractListModel
name|QAbstractListModel
operator|::
name|~
name|QAbstractListModel
parameter_list|()
block|{  }
end_destructor
begin_comment
comment|/*!     \fn QModelIndex QAbstractListModel::index(int row, int column, const QModelIndex&parent = QModelIndex()) const      Returns the index of the data in \a row and \a column with \a parent.      \sa parent() */
end_comment
begin_function
DECL|function|index
name|QModelIndex
name|QAbstractListModel
operator|::
name|index
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
return|return
name|hasIndex
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|parent
argument_list|)
condition|?
name|createIndex
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
literal|0
argument_list|)
else|:
name|QModelIndex
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the parent of the model item with the given \a index.      \sa index() hasChildren() */
end_comment
begin_function
DECL|function|parent
name|QModelIndex
name|QAbstractListModel
operator|::
name|parent
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
comment|/* index */
parameter_list|)
specifier|const
block|{
return|return
name|QModelIndex
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the number of columns in the list with the given \a parent.      \sa rowCount() */
end_comment
begin_function
DECL|function|columnCount
name|int
name|QAbstractListModel
operator|::
name|columnCount
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
return|return
name|parent
operator|.
name|isValid
argument_list|()
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function
begin_function
DECL|function|hasChildren
name|bool
name|QAbstractListModel
operator|::
name|hasChildren
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
specifier|const
block|{
return|return
name|parent
operator|.
name|isValid
argument_list|()
condition|?
literal|false
else|:
operator|(
name|rowCount
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \typedef QModelIndexList     \relates QModelIndex      Synonym for QList<QModelIndex>. */
end_comment
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|dropMimeData
name|bool
name|QAbstractTableModel
operator|::
name|dropMimeData
parameter_list|(
specifier|const
name|QMimeData
modifier|*
name|data
parameter_list|,
name|Qt
operator|::
name|DropAction
name|action
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
operator|||
operator|!
operator|(
name|action
operator|==
name|Qt
operator|::
name|CopyAction
operator|||
name|action
operator|==
name|Qt
operator|::
name|MoveAction
operator|)
condition|)
return|return
literal|false
return|;
name|QStringList
name|types
init|=
name|mimeTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|types
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QString
name|format
init|=
name|types
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|hasFormat
argument_list|(
name|format
argument_list|)
condition|)
return|return
literal|false
return|;
name|QByteArray
name|encoded
init|=
name|data
operator|->
name|data
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|QDataStream
name|stream
argument_list|(
operator|&
name|encoded
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
decl_stmt|;
comment|// if the drop is on an item, replace the data in the items
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
operator|&&
name|row
operator|==
operator|-
literal|1
operator|&&
name|column
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|top
init|=
name|INT_MAX
decl_stmt|;
name|int
name|left
init|=
name|INT_MAX
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
name|rows
decl_stmt|,
name|columns
decl_stmt|;
name|QVector
argument_list|<
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
argument_list|>
name|data
decl_stmt|;
while|while
condition|(
operator|!
name|stream
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
name|v
decl_stmt|;
name|stream
operator|>>
name|r
operator|>>
name|c
operator|>>
name|v
expr_stmt|;
name|rows
operator|.
name|append
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|columns
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|data
operator|.
name|append
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|top
operator|=
name|qMin
argument_list|(
name|r
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|left
operator|=
name|qMin
argument_list|(
name|c
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|r
init|=
operator|(
name|rows
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|-
name|top
operator|)
operator|+
name|parent
operator|.
name|row
argument_list|()
decl_stmt|;
name|int
name|c
init|=
operator|(
name|columns
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|-
name|left
operator|)
operator|+
name|parent
operator|.
name|column
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasIndex
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
condition|)
name|setItemData
argument_list|(
name|index
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
argument_list|,
name|data
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|// otherwise insert new rows for the data
return|return
name|decodeData
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|parent
argument_list|,
name|stream
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \reimp */
end_comment
begin_function
DECL|function|dropMimeData
name|bool
name|QAbstractListModel
operator|::
name|dropMimeData
parameter_list|(
specifier|const
name|QMimeData
modifier|*
name|data
parameter_list|,
name|Qt
operator|::
name|DropAction
name|action
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|column
parameter_list|,
specifier|const
name|QModelIndex
modifier|&
name|parent
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
operator|||
operator|!
operator|(
name|action
operator|==
name|Qt
operator|::
name|CopyAction
operator|||
name|action
operator|==
name|Qt
operator|::
name|MoveAction
operator|)
condition|)
return|return
literal|false
return|;
name|QStringList
name|types
init|=
name|mimeTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|types
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QString
name|format
init|=
name|types
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|hasFormat
argument_list|(
name|format
argument_list|)
condition|)
return|return
literal|false
return|;
name|QByteArray
name|encoded
init|=
name|data
operator|->
name|data
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|QDataStream
name|stream
argument_list|(
operator|&
name|encoded
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
decl_stmt|;
comment|// if the drop is on an item, replace the data in the items
if|if
condition|(
name|parent
operator|.
name|isValid
argument_list|()
operator|&&
name|row
operator|==
operator|-
literal|1
operator|&&
name|column
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|top
init|=
name|INT_MAX
decl_stmt|;
name|int
name|left
init|=
name|INT_MAX
decl_stmt|;
name|QVector
argument_list|<
name|int
argument_list|>
name|rows
decl_stmt|,
name|columns
decl_stmt|;
name|QVector
argument_list|<
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
argument_list|>
name|data
decl_stmt|;
while|while
condition|(
operator|!
name|stream
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
name|QMap
argument_list|<
name|int
argument_list|,
name|QVariant
argument_list|>
name|v
decl_stmt|;
name|stream
operator|>>
name|r
operator|>>
name|c
operator|>>
name|v
expr_stmt|;
name|rows
operator|.
name|append
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|columns
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|data
operator|.
name|append
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|top
operator|=
name|qMin
argument_list|(
name|r
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|left
operator|=
name|qMin
argument_list|(
name|c
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|r
init|=
operator|(
name|rows
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|-
name|top
operator|)
operator|+
name|parent
operator|.
name|row
argument_list|()
decl_stmt|;
if|if
condition|(
name|columns
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
name|left
operator|&&
name|hasIndex
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
condition|)
name|setItemData
argument_list|(
name|index
argument_list|(
name|r
argument_list|)
argument_list|,
name|data
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|row
operator|==
operator|-
literal|1
condition|)
name|row
operator|=
name|rowCount
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|// otherwise insert new rows for the data
return|return
name|decodeData
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|parent
argument_list|,
name|stream
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QAbstractItemModel::modelAboutToBeReset()     \since 4.2      This signal is emitted when reset() is called, before the model's internal     state (e.g. persistent model indexes) has been invalidated.      \sa beginResetModel(), modelReset() */
end_comment
begin_comment
comment|/*!     \fn QAbstractItemModel::modelReset()     \since 4.1      This signal is emitted when reset() is called, after the model's internal     state (e.g. persistent model indexes) has been invalidated.      \sa endResetModel(), modelAboutToBeReset() */
end_comment
begin_comment
comment|/*!     \fn bool QModelIndex::operator<(const QModelIndex&other) const     \since 4.1      Returns true if this model index is smaller than the \a other     model index; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn uint qHash(const QPersistentModelIndex&index)     \since 4.5      Returns a hash of the QPersistentModelIndex  */
end_comment
begin_comment
comment|/*!     \internal     QHash::insertMulti insert the value before the old value. and find() return the new value.     We need insertMultiAtEnd because we don't want to overwrite the old one, which should be removed later      There should be only one instance QPersistentModelIndexData per index, but in some intermediate state there may be     severals of PersistantModelIndex pointing to the same index, but one is already updated, and the other one is not.     This make sure than when updating the first one we don't overwrite the second one in the hash, and the second one     will be updated right later.  */
end_comment
begin_function
DECL|function|insertMultiAtEnd
name|void
name|QAbstractItemModelPrivate
operator|::
name|Persistent
operator|::
name|insertMultiAtEnd
parameter_list|(
specifier|const
name|QModelIndex
modifier|&
name|key
parameter_list|,
name|QPersistentModelIndexData
modifier|*
name|data
parameter_list|)
block|{
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
modifier|*
argument_list|>
operator|::
name|iterator
name|newIt
init|=
name|indexes
operator|.
name|insertMulti
argument_list|(
name|key
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|QHash
argument_list|<
name|QModelIndex
argument_list|,
name|QPersistentModelIndexData
modifier|*
argument_list|>
operator|::
name|iterator
name|it
init|=
name|newIt
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|indexes
operator|.
name|end
argument_list|()
operator|&&
name|it
operator|.
name|key
argument_list|()
operator|==
name|key
condition|)
block|{
name|qSwap
argument_list|(
operator|*
name|newIt
argument_list|,
operator|*
name|it
argument_list|)
expr_stmt|;
name|newIt
operator|=
name|it
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
