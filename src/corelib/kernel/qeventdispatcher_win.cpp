begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qeventdispatcher_win_p.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|<private/qsystemlibrary_p.h>
end_include
begin_include
include|#
directive|include
file|"qpair.h"
end_include
begin_include
include|#
directive|include
file|"qset.h"
end_include
begin_include
include|#
directive|include
file|"qsocketnotifier.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qwineventnotifier.h"
end_include
begin_include
include|#
directive|include
file|"qelapsedtimer.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication_p.h"
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qmutexpool_p.h>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|HINSTANCE
name|qWinAppInst
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|uint
name|qGlobalPostedEventsCount
parameter_list|()
function_decl|;
end_function_decl
begin_ifndef
ifndef|#
directive|ifndef
name|TIME_KILL_SYNCHRONOUS
end_ifndef
begin_define
DECL|macro|TIME_KILL_SYNCHRONOUS
define|#
directive|define
name|TIME_KILL_SYNCHRONOUS
value|0x0100
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QS_RAWINPUT
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WINCE
end_ifdef
begin_define
DECL|macro|QS_RAWINPUT
define|#
directive|define
name|QS_RAWINPUT
value|0x0000
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QS_RAWINPUT
define|#
directive|define
name|QS_RAWINPUT
value|0x0400
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|WM_TOUCH
end_ifndef
begin_define
DECL|macro|WM_TOUCH
define|#
directive|define
name|WM_TOUCH
value|0x0240
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|WM_GESTURE
end_ifndef
begin_define
DECL|macro|WM_GESTURE
define|#
directive|define
name|WM_GESTURE
value|0x0119
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|WM_GESTURENOTIFY
end_ifndef
begin_define
DECL|macro|WM_GESTURENOTIFY
define|#
directive|define
name|WM_GESTURENOTIFY
value|0x011A
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_GESTURES
end_comment
begin_enum
enum|enum
block|{
DECL|enumerator|WM_QT_SOCKETNOTIFIER
name|WM_QT_SOCKETNOTIFIER
init|=
name|WM_USER
block|,
DECL|enumerator|WM_QT_SENDPOSTEDEVENTS
name|WM_QT_SENDPOSTEDEVENTS
init|=
name|WM_USER
operator|+
literal|1
block|,
DECL|enumerator|SendPostedEventsWindowsTimerId
name|SendPostedEventsWindowsTimerId
init|=
operator|~
literal|1u
block|}
enum|;
end_enum
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_decl_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<winsock.h>
name|QT_END_INCLUDE_NAMESPACE
comment|// Asynchronous Winsocks ------------------------------------------
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<qthread.h>
include|#
directive|include
file|<qmap.h>
include|#
directive|include
file|<qmutex.h>
name|QT_END_INCLUDE_NAMESPACE
comment|//#define QCE_ASYNC_DEBUG
namespace|namespace
block|{
class_decl|class
name|SocketAsyncHandler
class_decl|;
DECL|class|SocketAsyncHandler
class|class
name|SocketAsyncHandler
super|:
specifier|public
name|QThread
block|{
public|public:
name|SocketAsyncHandler
parameter_list|()
constructor_decl|;
name|~
name|SocketAsyncHandler
parameter_list|()
destructor_decl|;
name|void
name|run
parameter_list|()
function_decl|;
name|void
name|select
parameter_list|(
name|SOCKET
name|sock
parameter_list|,
name|HWND
name|handle
parameter_list|,
name|unsigned
name|int
name|msg
parameter_list|,
name|long
name|ev
parameter_list|)
function_decl|;
name|void
name|removeSelect
parameter_list|(
name|SOCKET
name|sock
parameter_list|)
function_decl|;
name|void
name|safeRemove
parameter_list|(
name|SOCKET
name|sock
parameter_list|)
function_decl|;
private|private:
DECL|struct|SockInfo
struct|struct
name|SockInfo
block|{
DECL|member|handle
name|HWND
name|handle
decl_stmt|;
DECL|member|msg
name|unsigned
name|int
name|msg
decl_stmt|;
DECL|member|ev
name|long
name|ev
decl_stmt|;
block|}
struct|;
DECL|member|sockets
name|QMap
argument_list|<
name|SOCKET
argument_list|,
name|SockInfo
argument_list|>
name|sockets
decl_stmt|;
DECL|member|mutex
name|QMutex
name|mutex
decl_stmt|;
DECL|member|cond
name|QWaitCondition
name|cond
decl_stmt|;
DECL|member|supposedToDie
name|bool
name|supposedToDie
decl_stmt|;
block|}
class|;
DECL|function|SocketAsyncHandler
name|SocketAsyncHandler
operator|::
name|SocketAsyncHandler
parameter_list|()
member_init_list|:
name|supposedToDie
argument_list|(
literal|false
argument_list|)
member_init_list|{
block|}
end_decl_stmt
begin_destructor
DECL|function|~SocketAsyncHandler
name|SocketAsyncHandler
operator|::
name|~
name|SocketAsyncHandler
parameter_list|()
block|{
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|supposedToDie
operator|=
literal|true
expr_stmt|;
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|cond
operator|.
name|wakeOne
argument_list|()
expr_stmt|;
name|wait
argument_list|()
expr_stmt|;
while|while
condition|(
name|sockets
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
name|removeSelect
argument_list|(
name|sockets
operator|.
name|begin
argument_list|()
operator|.
name|key
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|removeSelect
name|void
name|SocketAsyncHandler
operator|::
name|removeSelect
parameter_list|(
name|SOCKET
name|sock
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sockets
operator|.
name|contains
argument_list|(
name|sock
argument_list|)
condition|)
return|return;
name|sockets
operator|.
name|remove
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function
begin_function
DECL|function|safeRemove
name|void
name|SocketAsyncHandler
operator|::
name|safeRemove
parameter_list|(
name|SOCKET
name|sock
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
name|removeSelect
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|select
name|void
name|SocketAsyncHandler
operator|::
name|select
parameter_list|(
name|SOCKET
name|sock
parameter_list|,
name|HWND
name|handle
parameter_list|,
name|unsigned
name|int
name|msg
parameter_list|,
name|long
name|ev
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|sockets
operator|.
name|contains
argument_list|(
name|sock
argument_list|)
condition|)
name|sockets
operator|.
name|remove
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|SockInfo
name|info
decl_stmt|;
name|info
operator|.
name|handle
operator|=
name|handle
expr_stmt|;
name|info
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
name|info
operator|.
name|ev
operator|=
name|ev
expr_stmt|;
name|sockets
operator|.
name|insert
argument_list|(
name|sock
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|cond
operator|.
name|wakeOne
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|run
name|void
name|SocketAsyncHandler
operator|::
name|run
parameter_list|()
block|{
do|do
block|{
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|supposedToDie
operator|&&
name|sockets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cond
operator|.
name|wait
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|supposedToDie
condition|)
block|{
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// Copy current items to reduce lock time
comment|// and to be able to use SendMessage
name|QMap
argument_list|<
name|SOCKET
argument_list|,
name|SockInfo
argument_list|>
name|currentSockets
init|=
name|sockets
decl_stmt|;
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|fd_set
name|readS
decl_stmt|,
name|writeS
decl_stmt|,
name|exS
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readS
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|writeS
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|exS
argument_list|)
expr_stmt|;
name|int
name|maxFd
init|=
literal|0
decl_stmt|;
for|for
control|(
name|QMap
argument_list|<
name|SOCKET
argument_list|,
name|SockInfo
argument_list|>
operator|::
name|iterator
name|it
init|=
name|currentSockets
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|currentSockets
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
specifier|const
name|SockInfo
modifier|&
name|info
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|int
name|socket
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
name|maxFd
operator|=
name|qMax
argument_list|(
name|maxFd
argument_list|,
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|.
name|ev
operator|&
name|FD_READ
operator|)
operator|||
operator|(
name|info
operator|.
name|ev
operator|&
name|FD_CLOSE
operator|)
operator|||
operator|(
name|info
operator|.
name|ev
operator|&
name|FD_ACCEPT
operator|)
condition|)
name|FD_SET
argument_list|(
name|socket
argument_list|,
operator|&
name|readS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|.
name|ev
operator|&
name|FD_WRITE
operator|)
operator|||
operator|(
name|info
operator|.
name|ev
operator|&
name|FD_CONNECT
operator|)
condition|)
name|FD_SET
argument_list|(
name|socket
argument_list|,
operator|&
name|writeS
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|ev
operator|&
name|FD_OOB
condition|)
name|FD_SET
argument_list|(
name|socket
argument_list|,
operator|&
name|exS
argument_list|)
expr_stmt|;
block|}
name|timeval
name|timeout
decl_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|50000
expr_stmt|;
name|int
name|result
init|=
operator|::
name|select
argument_list|(
name|maxFd
operator|+
literal|1
argument_list|,
operator|&
name|readS
argument_list|,
operator|&
name|writeS
argument_list|,
operator|&
name|exS
argument_list|,
operator|&
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
name|HWND
name|handle
decl_stmt|;
name|unsigned
name|int
name|tmpMsg
decl_stmt|;
name|SOCKET
name|sock
decl_stmt|;
name|HRESULT
name|ret
decl_stmt|;
for|for
control|(
name|QMap
argument_list|<
name|SOCKET
argument_list|,
name|SockInfo
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|currentSockets
operator|.
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|currentSockets
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|handle
operator|=
operator|(
operator|*
name|it
operator|)
operator|.
name|handle
expr_stmt|;
name|tmpMsg
operator|=
operator|(
operator|*
name|it
operator|)
operator|.
name|msg
expr_stmt|;
name|sock
operator|=
name|it
operator|.
name|key
argument_list|()
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|sock
argument_list|,
operator|&
name|readS
argument_list|)
condition|)
name|ret
operator|=
name|SendMessage
argument_list|(
name|handle
argument_list|,
name|tmpMsg
argument_list|,
name|sock
argument_list|,
name|FD_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|sock
argument_list|,
operator|&
name|writeS
argument_list|)
condition|)
name|ret
operator|=
name|SendMessage
argument_list|(
name|handle
argument_list|,
name|tmpMsg
argument_list|,
name|sock
argument_list|,
name|FD_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|sock
argument_list|,
operator|&
name|exS
argument_list|)
condition|)
name|ret
operator|=
name|SendMessage
argument_list|(
name|handle
argument_list|,
name|tmpMsg
argument_list|,
name|sock
argument_list|,
name|FD_OOB
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|QCE_ASYNC_DEBUG
elseif|else
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|//timeout
name|qDebug
argument_list|(
literal|"    WSAAsync select timeout"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
comment|// SocketError
comment|// This might happen because of two reasons
comment|// 1. We already closed a socket in between the copy and the select
comment|//    and thus select() returns an error
comment|// 2. Something is really wrong, then
comment|//    ### Loop on all descriptors, try to select and remove the
comment|//    ### broken one.
name|qWarning
argument_list|(
literal|"WSAAsync select error %d"
argument_list|,
name|WSAGetLastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
do|while
condition|(
literal|true
condition|)
do|;
block|}
end_function
begin_comment
unit|}
comment|// namespace
end_comment
begin_expr_stmt
unit|Q_GLOBAL_STATIC
operator|(
name|SocketAsyncHandler
operator|,
name|qt_async_handler
operator|)
DECL|function|WSAAsyncSelect
name|int
name|WSAAsyncSelect
argument_list|(
argument|SOCKET sock
argument_list|,
argument|HWND handle
argument_list|,
argument|unsigned int msg
argument_list|,
argument|long ev
argument_list|)
block|{
if|if
condition|(
name|sock
operator|==
literal|0
operator|||
name|handle
operator|==
literal|0
operator|||
name|handle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|WSASetLastError
argument_list|(
name|WSAEINVAL
argument_list|)
expr_stmt|;
return|return
name|SOCKET_ERROR
return|;
block|}
end_expr_stmt
begin_if
if|if
condition|(
name|msg
operator|==
literal|0
operator|&&
name|ev
operator|==
literal|0
condition|)
name|qt_async_handler
argument_list|()
operator|->
name|safeRemove
argument_list|(
name|sock
argument_list|)
expr_stmt|;
else|else
name|qt_async_handler
argument_list|()
operator|->
name|select
argument_list|(
name|sock
argument_list|,
name|handle
argument_list|,
name|msg
argument_list|,
name|ev
argument_list|)
expr_stmt|;
end_if
begin_expr_stmt
name|qt_async_handler
argument_list|()
operator|->
name|start
argument_list|(
name|QThread
operator|::
name|LowPriority
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|WSASetLastError
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt
begin_return
return|return
literal|0
return|;
end_return
begin_else
unit|}
else|#
directive|else
end_else
begin_comment
comment|// QT_NO_THREAD
end_comment
begin_macro
unit|int
name|WSAAsyncSelect
argument_list|(
argument|SOCKET
argument_list|,
argument|HWND
argument_list|,
argument|unsigned int
argument_list|,
argument|long
argument_list|)
end_macro
begin_block
block|{
return|return
name|SOCKET_ERROR
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_OS_WINCE
end_comment
begin_class_decl
class_decl|class
name|QEventDispatcherWin32Private
class_decl|;
end_class_decl
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DWORD_PTR
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WIN64
argument_list|)
end_if
begin_define
DECL|macro|DWORD_PTR
define|#
directive|define
name|DWORD_PTR
value|DWORD
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|ptimeSetEvent
typedef|typedef
name|MMRESULT
function_decl|(
name|WINAPI
modifier|*
name|ptimeSetEvent
function_decl|)
parameter_list|(
name|UINT
parameter_list|,
name|UINT
parameter_list|,
name|LPTIMECALLBACK
parameter_list|,
name|DWORD_PTR
parameter_list|,
name|UINT
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|ptimeKillEvent
typedef|typedef
name|MMRESULT
function_decl|(
name|WINAPI
modifier|*
name|ptimeKillEvent
function_decl|)
parameter_list|(
name|UINT
parameter_list|)
function_decl|;
end_typedef
begin_decl_stmt
DECL|variable|qtimeSetEvent
specifier|static
name|ptimeSetEvent
name|qtimeSetEvent
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qtimeKillEvent
specifier|static
name|ptimeKillEvent
name|qtimeKillEvent
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function_decl
name|LRESULT
name|QT_WIN_CALLBACK
name|qt_internal_proc
parameter_list|(
name|HWND
name|hwnd
parameter_list|,
name|UINT
name|message
parameter_list|,
name|WPARAM
name|wp
parameter_list|,
name|LPARAM
name|lp
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|resolveTimerAPI
specifier|static
name|void
name|resolveTimerAPI
parameter_list|()
block|{
specifier|static
name|bool
name|triedResolve
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|triedResolve
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_THREAD
name|QMutexLocker
name|locker
argument_list|(
name|QMutexPool
operator|::
name|globalInstanceGet
argument_list|(
operator|&
name|triedResolve
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|triedResolve
condition|)
return|return;
endif|#
directive|endif
name|triedResolve
operator|=
literal|true
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|qtimeSetEvent
operator|=
operator|(
name|ptimeSetEvent
operator|)
name|QSystemLibrary
operator|::
name|resolve
argument_list|(
name|QLatin1String
argument_list|(
literal|"winmm"
argument_list|)
argument_list|,
literal|"timeSetEvent"
argument_list|)
expr_stmt|;
name|qtimeKillEvent
operator|=
operator|(
name|ptimeKillEvent
operator|)
name|QSystemLibrary
operator|::
name|resolve
argument_list|(
name|QLatin1String
argument_list|(
literal|"winmm"
argument_list|)
argument_list|,
literal|"timeKillEvent"
argument_list|)
expr_stmt|;
else|#
directive|else
name|qtimeSetEvent
operator|=
operator|(
name|ptimeSetEvent
operator|)
name|QSystemLibrary
operator|::
name|resolve
argument_list|(
name|QLatin1String
argument_list|(
literal|"Mmtimer"
argument_list|)
argument_list|,
literal|"timeSetEvent"
argument_list|)
expr_stmt|;
name|qtimeKillEvent
operator|=
operator|(
name|ptimeKillEvent
operator|)
name|QSystemLibrary
operator|::
name|resolve
argument_list|(
name|QLatin1String
argument_list|(
literal|"Mmtimer"
argument_list|)
argument_list|,
literal|"timeKillEvent"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_constructor
DECL|function|QEventDispatcherWin32Private
name|QEventDispatcherWin32Private
operator|::
name|QEventDispatcherWin32Private
parameter_list|()
member_init_list|:
name|threadId
argument_list|(
name|GetCurrentThreadId
argument_list|()
argument_list|)
member_init_list|,
name|interrupt
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|internalHwnd
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|getMessageHook
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|serialNumber
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|lastSerialNumber
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|sendPostedEventsWindowsTimerId
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|wakeUps
argument_list|(
literal|0
argument_list|)
block|{
name|resolveTimerAPI
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QEventDispatcherWin32Private
name|QEventDispatcherWin32Private
operator|::
name|~
name|QEventDispatcherWin32Private
parameter_list|()
block|{
if|if
condition|(
name|internalHwnd
condition|)
name|DestroyWindow
argument_list|(
name|internalHwnd
argument_list|)
expr_stmt|;
name|QString
name|className
init|=
name|QLatin1String
argument_list|(
literal|"QEventDispatcherWin32_Internal_Widget"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|quintptr
argument_list|(
name|qt_internal_proc
argument_list|)
argument_list|)
decl_stmt|;
name|UnregisterClass
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|className
operator|.
name|utf16
argument_list|()
argument_list|,
name|qWinAppInst
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|activateEventNotifier
name|void
name|QEventDispatcherWin32Private
operator|::
name|activateEventNotifier
parameter_list|(
name|QWinEventNotifier
modifier|*
name|wen
parameter_list|)
block|{
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|WinEventAct
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|wen
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// This function is called by a workerthread
end_comment
begin_function
DECL|function|qt_fast_timer_proc
name|void
name|WINAPI
name|QT_WIN_CALLBACK
name|qt_fast_timer_proc
parameter_list|(
name|uint
name|timerId
parameter_list|,
name|uint
comment|/*reserved*/
parameter_list|,
name|DWORD_PTR
name|user
parameter_list|,
name|DWORD_PTR
comment|/*reserved*/
parameter_list|,
name|DWORD_PTR
comment|/*reserved*/
parameter_list|)
block|{
if|if
condition|(
operator|!
name|timerId
condition|)
comment|// sanity check
return|return;
name|WinTimerInfo
modifier|*
name|t
init|=
operator|(
name|WinTimerInfo
operator|*
operator|)
name|user
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|t
operator|->
name|dispatcher
argument_list|,
operator|new
name|QTimerEvent
argument_list|(
name|t
operator|->
name|timerId
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_internal_proc
name|LRESULT
name|QT_WIN_CALLBACK
name|qt_internal_proc
parameter_list|(
name|HWND
name|hwnd
parameter_list|,
name|UINT
name|message
parameter_list|,
name|WPARAM
name|wp
parameter_list|,
name|LPARAM
name|lp
parameter_list|)
block|{
if|if
condition|(
name|message
operator|==
name|WM_NCCREATE
condition|)
return|return
literal|true
return|;
name|MSG
name|msg
decl_stmt|;
name|msg
operator|.
name|hwnd
operator|=
name|hwnd
expr_stmt|;
name|msg
operator|.
name|message
operator|=
name|message
expr_stmt|;
name|msg
operator|.
name|wParam
operator|=
name|wp
expr_stmt|;
name|msg
operator|.
name|lParam
operator|=
name|lp
expr_stmt|;
name|QAbstractEventDispatcher
modifier|*
name|dispatcher
init|=
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|()
decl_stmt|;
name|long
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|dispatcher
condition|)
block|{
if|if
condition|(
name|message
operator|==
name|WM_TIMER
condition|)
name|KillTimer
argument_list|(
name|hwnd
argument_list|,
name|wp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|dispatcher
operator|->
name|filterNativeEvent
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"windows_dispatcher_MSG"
argument_list|)
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|result
argument_list|)
condition|)
block|{
return|return
name|result
return|;
block|}
ifdef|#
directive|ifdef
name|GWLP_USERDATA
name|QEventDispatcherWin32
modifier|*
name|q
init|=
operator|(
name|QEventDispatcherWin32
operator|*
operator|)
name|GetWindowLongPtr
argument_list|(
name|hwnd
argument_list|,
name|GWLP_USERDATA
argument_list|)
decl_stmt|;
else|#
directive|else
name|QEventDispatcherWin32
modifier|*
name|q
init|=
operator|(
name|QEventDispatcherWin32
operator|*
operator|)
name|GetWindowLong
argument_list|(
name|hwnd
argument_list|,
name|GWL_USERDATA
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|QEventDispatcherWin32Private
modifier|*
name|d
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|0
condition|)
name|d
operator|=
name|q
operator|->
name|d_func
argument_list|()
expr_stmt|;
if|if
condition|(
name|message
operator|==
name|WM_QT_SOCKETNOTIFIER
condition|)
block|{
comment|// socket notifier message
name|int
name|type
init|=
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|WSAGETSELECTEVENT
argument_list|(
name|lp
argument_list|)
condition|)
block|{
case|case
name|FD_READ
case|:
case|case
name|FD_ACCEPT
case|:
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FD_WRITE
case|:
case|case
name|FD_CONNECT
case|:
name|type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|FD_OOB
case|:
name|type
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|FD_CLOSE
case|:
name|type
operator|=
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|>=
literal|0
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|d
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QSNDict
modifier|*
name|sn_vec
index|[
literal|4
index|]
init|=
block|{
operator|&
name|d
operator|->
name|sn_read
block|,
operator|&
name|d
operator|->
name|sn_write
block|,
operator|&
name|d
operator|->
name|sn_except
block|,
operator|&
name|d
operator|->
name|sn_read
block|}
decl_stmt|;
name|QSNDict
modifier|*
name|dict
init|=
name|sn_vec
index|[
name|type
index|]
decl_stmt|;
name|QSockNot
modifier|*
name|sn
init|=
name|dict
condition|?
name|dict
operator|->
name|value
argument_list|(
name|wp
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|sn
condition|)
block|{
if|if
condition|(
name|type
operator|<
literal|3
condition|)
block|{
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|SockAct
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|sn
operator|->
name|obj
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QEvent
name|event
argument_list|(
name|QEvent
operator|::
name|SockClose
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|sn
operator|->
name|obj
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|message
operator|==
name|WM_QT_SENDPOSTEDEVENTS
comment|// we also use a Windows timer to send posted events when the message queue is full
operator|||
operator|(
name|message
operator|==
name|WM_TIMER
operator|&&
name|d
operator|->
name|sendPostedEventsWindowsTimerId
operator|!=
literal|0
operator|&&
name|wp
operator|==
operator|(
name|uint
operator|)
name|d
operator|->
name|sendPostedEventsWindowsTimerId
operator|)
condition|)
block|{
specifier|const
name|int
name|localSerialNumber
init|=
name|d
operator|->
name|serialNumber
operator|.
name|load
argument_list|()
decl_stmt|;
if|if
condition|(
name|localSerialNumber
operator|!=
name|d
operator|->
name|lastSerialNumber
condition|)
block|{
name|d
operator|->
name|lastSerialNumber
operator|=
name|localSerialNumber
expr_stmt|;
name|q
operator|->
name|sendPostedEvents
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|message
operator|==
name|WM_TIMER
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|d
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendTimerEvent
argument_list|(
name|wp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|DefWindowProc
argument_list|(
name|hwnd
argument_list|,
name|message
argument_list|,
name|wp
argument_list|,
name|lp
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qt_GetMessageHook
name|LRESULT
name|QT_WIN_CALLBACK
name|qt_GetMessageHook
parameter_list|(
name|int
name|code
parameter_list|,
name|WPARAM
name|wp
parameter_list|,
name|LPARAM
name|lp
parameter_list|)
block|{
if|if
condition|(
name|wp
operator|==
name|PM_REMOVE
condition|)
block|{
name|QEventDispatcherWin32
modifier|*
name|q
init|=
name|qobject_cast
argument_list|<
name|QEventDispatcherWin32
operator|*
argument_list|>
argument_list|(
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|q
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
block|{
name|MSG
modifier|*
name|msg
init|=
operator|(
name|MSG
operator|*
operator|)
name|lp
decl_stmt|;
name|QEventDispatcherWin32Private
modifier|*
name|d
init|=
name|q
operator|->
name|d_func
argument_list|()
decl_stmt|;
specifier|const
name|int
name|localSerialNumber
init|=
name|d
operator|->
name|serialNumber
operator|.
name|load
argument_list|()
decl_stmt|;
if|if
condition|(
name|HIWORD
argument_list|(
name|GetQueueStatus
argument_list|(
name|QS_TIMER
operator||
name|QS_INPUT
operator||
name|QS_RAWINPUT
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// no more input or timer events in the message queue, we can allow posted events to be sent normally now
if|if
condition|(
name|d
operator|->
name|sendPostedEventsWindowsTimerId
operator|!=
literal|0
condition|)
block|{
comment|// stop the timer to send posted events, since we now allow the WM_QT_SENDPOSTEDEVENTS message
name|KillTimer
argument_list|(
name|d
operator|->
name|internalHwnd
argument_list|,
name|d
operator|->
name|sendPostedEventsWindowsTimerId
argument_list|)
expr_stmt|;
name|d
operator|->
name|sendPostedEventsWindowsTimerId
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|d
operator|->
name|wakeUps
operator|.
name|fetchAndStoreRelease
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|localSerialNumber
operator|!=
name|d
operator|->
name|lastSerialNumber
comment|// if this message IS the one that triggers sendPostedEvents(), no need to post it again
operator|&&
operator|(
name|msg
operator|->
name|hwnd
operator|!=
name|d
operator|->
name|internalHwnd
operator|||
name|msg
operator|->
name|message
operator|!=
name|WM_QT_SENDPOSTEDEVENTS
operator|)
condition|)
block|{
name|PostMessage
argument_list|(
name|d
operator|->
name|internalHwnd
argument_list|,
name|WM_QT_SENDPOSTEDEVENTS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|sendPostedEventsWindowsTimerId
operator|==
literal|0
operator|&&
name|localSerialNumber
operator|!=
name|d
operator|->
name|lastSerialNumber
condition|)
block|{
comment|// start a special timer to continue delivering posted events while
comment|// there are still input and timer messages in the message queue
name|d
operator|->
name|sendPostedEventsWindowsTimerId
operator|=
name|SetTimer
argument_list|(
name|d
operator|->
name|internalHwnd
argument_list|,
name|SendPostedEventsWindowsTimerId
argument_list|,
literal|0
argument_list|,
comment|// we specify zero, but Windows uses USER_TIMER_MINIMUM
name|NULL
argument_list|)
expr_stmt|;
comment|// we don't check the return value of SetTimer()... if creating the timer failed, there's little
comment|// we can do. we just have to accept that posted events will be starved
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|Q_OS_WINCE
return|return
literal|0
return|;
else|#
directive|else
return|return
name|CallNextHookEx
argument_list|(
literal|0
argument_list|,
name|code
argument_list|,
name|wp
argument_list|,
name|lp
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|qt_create_internal_window
specifier|static
name|HWND
name|qt_create_internal_window
parameter_list|(
specifier|const
name|QEventDispatcherWin32
modifier|*
name|eventDispatcher
parameter_list|)
block|{
comment|// make sure that multiple Qt's can coexist in the same process
name|QString
name|className
init|=
name|QLatin1String
argument_list|(
literal|"QEventDispatcherWin32_Internal_Widget"
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|quintptr
argument_list|(
name|qt_internal_proc
argument_list|)
argument_list|)
decl_stmt|;
name|WNDCLASS
name|wc
decl_stmt|;
name|wc
operator|.
name|style
operator|=
literal|0
expr_stmt|;
name|wc
operator|.
name|lpfnWndProc
operator|=
name|qt_internal_proc
expr_stmt|;
name|wc
operator|.
name|cbClsExtra
operator|=
literal|0
expr_stmt|;
name|wc
operator|.
name|cbWndExtra
operator|=
literal|0
expr_stmt|;
name|wc
operator|.
name|hInstance
operator|=
name|qWinAppInst
argument_list|()
expr_stmt|;
name|wc
operator|.
name|hIcon
operator|=
literal|0
expr_stmt|;
name|wc
operator|.
name|hCursor
operator|=
literal|0
expr_stmt|;
name|wc
operator|.
name|hbrBackground
operator|=
literal|0
expr_stmt|;
name|wc
operator|.
name|lpszMenuName
operator|=
name|NULL
expr_stmt|;
name|wc
operator|.
name|lpszClassName
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|className
operator|.
name|utf16
argument_list|()
argument_list|)
expr_stmt|;
name|RegisterClass
argument_list|(
operator|&
name|wc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WINCE
name|HWND
name|parent
init|=
literal|0
decl_stmt|;
else|#
directive|else
name|HWND
name|parent
init|=
name|HWND_MESSAGE
decl_stmt|;
endif|#
directive|endif
name|HWND
name|wnd
init|=
name|CreateWindow
argument_list|(
name|wc
operator|.
name|lpszClassName
argument_list|,
comment|// classname
name|wc
operator|.
name|lpszClassName
argument_list|,
comment|// window name
literal|0
argument_list|,
comment|// style
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|// geometry
name|parent
argument_list|,
comment|// parent
literal|0
argument_list|,
comment|// menu handle
name|qWinAppInst
argument_list|()
argument_list|,
comment|// application
literal|0
argument_list|)
decl_stmt|;
comment|// windows creation data.
if|if
condition|(
operator|!
name|wnd
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEventDispatcher: Failed to create QEventDispatcherWin32 internal window: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GWLP_USERDATA
name|SetWindowLongPtr
argument_list|(
name|wnd
argument_list|,
name|GWLP_USERDATA
argument_list|,
operator|(
name|LONG_PTR
operator|)
name|eventDispatcher
argument_list|)
expr_stmt|;
else|#
directive|else
name|SetWindowLong
argument_list|(
name|wnd
argument_list|,
name|GWL_USERDATA
argument_list|,
operator|(
name|LONG
operator|)
name|eventDispatcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|wnd
return|;
block|}
end_function
begin_function
DECL|function|registerTimer
name|void
name|QEventDispatcherWin32Private
operator|::
name|registerTimer
parameter_list|(
name|WinTimerInfo
modifier|*
name|t
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|internalHwnd
argument_list|)
expr_stmt|;
name|Q_Q
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
name|uint
name|interval
init|=
name|t
operator|->
name|interval
decl_stmt|;
if|if
condition|(
name|interval
operator|==
literal|0u
condition|)
block|{
comment|// optimization for single-shot-zero-timer
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|q
argument_list|,
operator|new
name|QZeroTimerEvent
argument_list|(
name|t
operator|->
name|timerId
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|interval
operator|<
literal|20u
operator|||
name|t
operator|->
name|timerType
operator|==
name|Qt
operator|::
name|PreciseTimer
operator|)
operator|&&
name|qtimeSetEvent
condition|)
block|{
name|ok
operator|=
name|t
operator|->
name|fastTimerId
operator|=
name|qtimeSetEvent
argument_list|(
name|interval
argument_list|,
literal|1
argument_list|,
name|qt_fast_timer_proc
argument_list|,
operator|(
name|DWORD_PTR
operator|)
name|t
argument_list|,
name|TIME_CALLBACK_FUNCTION
operator||
name|TIME_PERIODIC
operator||
name|TIME_KILL_SYNCHRONOUS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|interval
operator|>=
literal|20000u
operator|||
name|t
operator|->
name|timerType
operator|==
name|Qt
operator|::
name|VeryCoarseTimer
condition|)
block|{
comment|// round the interval, VeryCoarseTimers only have full second accuracy
name|interval
operator|=
operator|(
operator|(
name|interval
operator|+
literal|500
operator|)
operator|)
operator|/
literal|1000
operator|*
literal|1000
expr_stmt|;
block|}
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
block|{
comment|// user normal timers for (Very)CoarseTimers, or if no more multimedia timers available
name|ok
operator|=
name|SetTimer
argument_list|(
name|internalHwnd
argument_list|,
name|t
operator|->
name|timerId
argument_list|,
name|interval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|timeout
operator|=
name|qt_msectime
argument_list|()
operator|+
name|interval
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
name|qErrnoWarning
argument_list|(
literal|"QEventDispatcherWin32::registerTimer: Failed to create a timer"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unregisterTimer
name|void
name|QEventDispatcherWin32Private
operator|::
name|unregisterTimer
parameter_list|(
name|WinTimerInfo
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|interval
operator|==
literal|0
condition|)
block|{
name|QCoreApplicationPrivate
operator|::
name|removePostedTimerEvent
argument_list|(
name|t
operator|->
name|dispatcher
argument_list|,
name|t
operator|->
name|timerId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|fastTimerId
operator|!=
literal|0
condition|)
block|{
name|qtimeKillEvent
argument_list|(
name|t
operator|->
name|fastTimerId
argument_list|)
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|removePostedTimerEvent
argument_list|(
name|t
operator|->
name|dispatcher
argument_list|,
name|t
operator|->
name|timerId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|internalHwnd
condition|)
block|{
name|KillTimer
argument_list|(
name|internalHwnd
argument_list|,
name|t
operator|->
name|timerId
argument_list|)
expr_stmt|;
block|}
operator|delete
name|t
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendTimerEvent
name|void
name|QEventDispatcherWin32Private
operator|::
name|sendTimerEvent
parameter_list|(
name|int
name|timerId
parameter_list|)
block|{
name|WinTimerInfo
modifier|*
name|t
init|=
name|timerDict
operator|.
name|value
argument_list|(
name|timerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|&&
operator|!
name|t
operator|->
name|inTimerEvent
condition|)
block|{
comment|// send event, but don't allow it to recurse
name|t
operator|->
name|inTimerEvent
operator|=
literal|true
expr_stmt|;
name|QTimerEvent
name|e
argument_list|(
name|t
operator|->
name|timerId
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|t
operator|->
name|obj
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
comment|// timer could have been removed
name|t
operator|=
name|timerDict
operator|.
name|value
argument_list|(
name|timerId
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|t
operator|->
name|inTimerEvent
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|doWsaAsyncSelect
name|void
name|QEventDispatcherWin32Private
operator|::
name|doWsaAsyncSelect
parameter_list|(
name|int
name|socket
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|internalHwnd
argument_list|)
expr_stmt|;
name|int
name|sn_event
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sn_read
operator|.
name|contains
argument_list|(
name|socket
argument_list|)
condition|)
name|sn_event
operator||=
name|FD_READ
operator||
name|FD_CLOSE
operator||
name|FD_ACCEPT
expr_stmt|;
if|if
condition|(
name|sn_write
operator|.
name|contains
argument_list|(
name|socket
argument_list|)
condition|)
name|sn_event
operator||=
name|FD_WRITE
operator||
name|FD_CONNECT
expr_stmt|;
if|if
condition|(
name|sn_except
operator|.
name|contains
argument_list|(
name|socket
argument_list|)
condition|)
name|sn_event
operator||=
name|FD_OOB
expr_stmt|;
comment|// BoundsChecker may emit a warning for WSAAsyncSelect when sn_event == 0
comment|// This is a BoundsChecker bug and not a Qt bug
name|WSAAsyncSelect
argument_list|(
name|socket
argument_list|,
name|internalHwnd
argument_list|,
name|sn_event
condition|?
name|int
argument_list|(
name|WM_QT_SOCKETNOTIFIER
argument_list|)
else|:
literal|0
argument_list|,
name|sn_event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|createInternalHwnd
name|void
name|QEventDispatcherWin32
operator|::
name|createInternalHwnd
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|d
operator|->
name|internalHwnd
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|internalHwnd
condition|)
return|return;
name|d
operator|->
name|internalHwnd
operator|=
name|qt_create_internal_window
argument_list|(
name|this
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_WINCE
comment|// setup GetMessage hook needed to drive our posted events
name|d
operator|->
name|getMessageHook
operator|=
name|SetWindowsHookEx
argument_list|(
name|WH_GETMESSAGE
argument_list|,
operator|(
name|HOOKPROC
operator|)
name|qt_GetMessageHook
argument_list|,
name|NULL
argument_list|,
name|GetCurrentThreadId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|getMessageHook
condition|)
block|{
name|qFatal
argument_list|(
literal|"Qt: INTERNALL ERROR: failed to install GetMessage hook"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// register all socket notifiers
name|QList
argument_list|<
name|int
argument_list|>
name|sockets
init|=
operator|(
name|d
operator|->
name|sn_read
operator|.
name|keys
argument_list|()
operator|.
name|toSet
argument_list|()
operator|+
name|d
operator|->
name|sn_write
operator|.
name|keys
argument_list|()
operator|.
name|toSet
argument_list|()
operator|+
name|d
operator|->
name|sn_except
operator|.
name|keys
argument_list|()
operator|.
name|toSet
argument_list|()
operator|)
operator|.
name|toList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sockets
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|doWsaAsyncSelect
argument_list|(
name|sockets
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// start all normal timers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|timerVec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|registerTimer
argument_list|(
name|d
operator|->
name|timerVec
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// trigger a call to sendPostedEvents()
name|wakeUp
argument_list|()
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QEventDispatcherWin32
name|QEventDispatcherWin32
operator|::
name|QEventDispatcherWin32
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractEventDispatcher
argument_list|(
operator|*
operator|new
name|QEventDispatcherWin32Private
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QEventDispatcherWin32
name|QEventDispatcherWin32
operator|::
name|QEventDispatcherWin32
parameter_list|(
name|QEventDispatcherWin32Private
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractEventDispatcher
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QEventDispatcherWin32
name|QEventDispatcherWin32
operator|::
name|~
name|QEventDispatcherWin32
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|processEvents
name|bool
name|QEventDispatcherWin32
operator|::
name|processEvents
parameter_list|(
name|QEventLoop
operator|::
name|ProcessEventsFlags
name|flags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|internalHwnd
condition|)
name|createInternalHwnd
argument_list|()
expr_stmt|;
name|d
operator|->
name|interrupt
operator|=
literal|false
expr_stmt|;
emit|emit
name|awake
argument_list|()
emit|;
name|bool
name|canWait
decl_stmt|;
name|bool
name|retVal
init|=
literal|false
decl_stmt|;
name|bool
name|seenWM_QT_SENDPOSTEDEVENTS
init|=
literal|false
decl_stmt|;
name|bool
name|needWM_QT_SENDPOSTEDEVENTS
init|=
literal|false
decl_stmt|;
do|do
block|{
name|DWORD
name|waitRet
init|=
literal|0
decl_stmt|;
name|HANDLE
name|pHandles
index|[
name|MAXIMUM_WAIT_OBJECTS
operator|-
literal|1
index|]
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|MSG
argument_list|>
name|processedTimers
decl_stmt|;
while|while
condition|(
operator|!
name|d
operator|->
name|interrupt
condition|)
block|{
name|DWORD
name|nCount
init|=
name|d
operator|->
name|winEventNotifierList
operator|.
name|count
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|nCount
operator|<
name|MAXIMUM_WAIT_OBJECTS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|MSG
name|msg
decl_stmt|;
name|bool
name|haveMessage
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|QEventLoop
operator|::
name|ExcludeUserInputEvents
operator|)
operator|&&
operator|!
name|d
operator|->
name|queuedUserInputEvents
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// process queued user input events
name|haveMessage
operator|=
literal|true
expr_stmt|;
name|msg
operator|=
name|d
operator|->
name|queuedUserInputEvents
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|QEventLoop
operator|::
name|ExcludeSocketNotifiers
operator|)
operator|&&
operator|!
name|d
operator|->
name|queuedSocketEvents
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// process queued socket events
name|haveMessage
operator|=
literal|true
expr_stmt|;
name|msg
operator|=
name|d
operator|->
name|queuedSocketEvents
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|haveMessage
operator|=
name|PeekMessage
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PM_REMOVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|haveMessage
operator|&&
operator|(
name|flags
operator|&
name|QEventLoop
operator|::
name|ExcludeUserInputEvents
operator|)
operator|&&
operator|(
operator|(
name|msg
operator|.
name|message
operator|>=
name|WM_KEYFIRST
operator|&&
name|msg
operator|.
name|message
operator|<=
name|WM_KEYLAST
operator|)
operator|||
operator|(
name|msg
operator|.
name|message
operator|>=
name|WM_MOUSEFIRST
operator|&&
name|msg
operator|.
name|message
operator|<=
name|WM_MOUSELAST
operator|)
operator|||
name|msg
operator|.
name|message
operator|==
name|WM_MOUSEWHEEL
operator|||
name|msg
operator|.
name|message
operator|==
name|WM_MOUSEHWHEEL
operator|||
name|msg
operator|.
name|message
operator|==
name|WM_TOUCH
ifndef|#
directive|ifndef
name|QT_NO_GESTURES
operator|||
name|msg
operator|.
name|message
operator|==
name|WM_GESTURE
operator|||
name|msg
operator|.
name|message
operator|==
name|WM_GESTURENOTIFY
endif|#
directive|endif
operator|||
name|msg
operator|.
name|message
operator|==
name|WM_CLOSE
operator|)
condition|)
block|{
comment|// queue user input events for later processing
name|haveMessage
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|queuedUserInputEvents
operator|.
name|append
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|haveMessage
operator|&&
operator|(
name|flags
operator|&
name|QEventLoop
operator|::
name|ExcludeSocketNotifiers
operator|)
operator|&&
operator|(
name|msg
operator|.
name|message
operator|==
name|WM_QT_SOCKETNOTIFIER
operator|&&
name|msg
operator|.
name|hwnd
operator|==
name|d
operator|->
name|internalHwnd
operator|)
condition|)
block|{
comment|// queue socket events for later processing
name|haveMessage
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|queuedSocketEvents
operator|.
name|append
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|haveMessage
condition|)
block|{
comment|// no message - check for signalled objects
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|nCount
condition|;
name|i
operator|++
control|)
name|pHandles
index|[
name|i
index|]
operator|=
name|d
operator|->
name|winEventNotifierList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|handle
argument_list|()
expr_stmt|;
name|waitRet
operator|=
name|MsgWaitForMultipleObjectsEx
argument_list|(
name|nCount
argument_list|,
name|pHandles
argument_list|,
literal|0
argument_list|,
name|QS_ALLINPUT
argument_list|,
name|MWMO_ALERTABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|haveMessage
operator|=
operator|(
name|waitRet
operator|==
name|WAIT_OBJECT_0
operator|+
name|nCount
operator|)
operator|)
condition|)
block|{
comment|// a new message has arrived, process it
continue|continue;
block|}
block|}
if|if
condition|(
name|haveMessage
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_WINCE
comment|// WinCE doesn't support hooks at all, so we have to call this by hand :(
operator|(
name|void
operator|)
name|qt_GetMessageHook
argument_list|(
literal|0
argument_list|,
name|PM_REMOVE
argument_list|,
operator|(
name|LPARAM
operator|)
operator|&
name|msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|internalHwnd
operator|==
name|msg
operator|.
name|hwnd
operator|&&
name|msg
operator|.
name|message
operator|==
name|WM_QT_SENDPOSTEDEVENTS
condition|)
block|{
if|if
condition|(
name|seenWM_QT_SENDPOSTEDEVENTS
condition|)
block|{
comment|// when calling processEvents() "manually", we only want to send posted
comment|// events once
name|needWM_QT_SENDPOSTEDEVENTS
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|seenWM_QT_SENDPOSTEDEVENTS
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msg
operator|.
name|message
operator|==
name|WM_TIMER
condition|)
block|{
comment|// avoid live-lock by keeping track of the timers we've already sent
name|bool
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
operator|!
name|found
operator|&&
name|i
operator|<
name|processedTimers
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|MSG
name|processed
init|=
name|processedTimers
operator|.
name|constData
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|found
operator|=
operator|(
name|processed
operator|.
name|wParam
operator|==
name|msg
operator|.
name|wParam
operator|&&
name|processed
operator|.
name|hwnd
operator|==
name|msg
operator|.
name|hwnd
operator|&&
name|processed
operator|.
name|lParam
operator|==
name|msg
operator|.
name|lParam
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
continue|continue;
name|processedTimers
operator|.
name|append
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msg
operator|.
name|message
operator|==
name|WM_QUIT
condition|)
block|{
if|if
condition|(
name|QCoreApplication
operator|::
name|instance
argument_list|()
condition|)
name|QCoreApplication
operator|::
name|instance
argument_list|()
operator|->
name|quit
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|filterNativeEvent
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"windows_generic_MSG"
argument_list|)
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|TranslateMessage
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|DispatchMessage
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|waitRet
operator|-
name|WAIT_OBJECT_0
operator|<
name|nCount
condition|)
block|{
name|d
operator|->
name|activateEventNotifier
argument_list|(
name|d
operator|->
name|winEventNotifierList
operator|.
name|at
argument_list|(
name|waitRet
operator|-
name|WAIT_OBJECT_0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// nothing todo so break
break|break;
block|}
name|retVal
operator|=
literal|true
expr_stmt|;
block|}
comment|// still nothing - wait for message or signalled objects
name|canWait
operator|=
operator|(
operator|!
name|retVal
operator|&&
operator|!
name|d
operator|->
name|interrupt
operator|&&
operator|(
name|flags
operator|&
name|QEventLoop
operator|::
name|WaitForMoreEvents
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|canWait
condition|)
block|{
name|DWORD
name|nCount
init|=
name|d
operator|->
name|winEventNotifierList
operator|.
name|count
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|nCount
operator|<
name|MAXIMUM_WAIT_OBJECTS
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|nCount
condition|;
name|i
operator|++
control|)
name|pHandles
index|[
name|i
index|]
operator|=
name|d
operator|->
name|winEventNotifierList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|handle
argument_list|()
expr_stmt|;
emit|emit
name|aboutToBlock
argument_list|()
emit|;
name|waitRet
operator|=
name|MsgWaitForMultipleObjectsEx
argument_list|(
name|nCount
argument_list|,
name|pHandles
argument_list|,
name|INFINITE
argument_list|,
name|QS_ALLINPUT
argument_list|,
name|MWMO_ALERTABLE
operator||
name|MWMO_INPUTAVAILABLE
argument_list|)
expr_stmt|;
emit|emit
name|awake
argument_list|()
emit|;
if|if
condition|(
name|waitRet
operator|-
name|WAIT_OBJECT_0
operator|<
name|nCount
condition|)
block|{
name|d
operator|->
name|activateEventNotifier
argument_list|(
name|d
operator|->
name|winEventNotifierList
operator|.
name|at
argument_list|(
name|waitRet
operator|-
name|WAIT_OBJECT_0
argument_list|)
argument_list|)
expr_stmt|;
name|retVal
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|canWait
condition|)
do|;
if|if
condition|(
operator|!
name|seenWM_QT_SENDPOSTEDEVENTS
operator|&&
operator|(
name|flags
operator|&
name|QEventLoop
operator|::
name|EventLoopExec
operator|)
operator|==
literal|0
condition|)
block|{
comment|// when called "manually", always send posted events
name|sendPostedEvents
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|needWM_QT_SENDPOSTEDEVENTS
condition|)
name|PostMessage
argument_list|(
name|d
operator|->
name|internalHwnd
argument_list|,
name|WM_QT_SENDPOSTEDEVENTS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|retVal
return|;
block|}
end_function
begin_function
DECL|function|hasPendingEvents
name|bool
name|QEventDispatcherWin32
operator|::
name|hasPendingEvents
parameter_list|()
block|{
name|MSG
name|msg
decl_stmt|;
return|return
name|qGlobalPostedEventsCount
argument_list|()
operator|||
name|PeekMessage
argument_list|(
operator|&
name|msg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PM_NOREMOVE
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|registerSocketNotifier
name|void
name|QEventDispatcherWin32
operator|::
name|registerSocketNotifier
parameter_list|(
name|QSocketNotifier
modifier|*
name|notifier
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|notifier
argument_list|)
expr_stmt|;
name|int
name|sockfd
init|=
name|notifier
operator|->
name|socket
argument_list|()
decl_stmt|;
name|int
name|type
init|=
name|notifier
operator|->
name|type
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSocketNotifier: Internal error"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|notifier
operator|->
name|thread
argument_list|()
operator|!=
name|thread
argument_list|()
operator|||
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSocketNotifier: socket notifiers cannot be enabled from another thread"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
name|QSNDict
modifier|*
name|sn_vec
index|[
literal|3
index|]
init|=
block|{
operator|&
name|d
operator|->
name|sn_read
block|,
operator|&
name|d
operator|->
name|sn_write
block|,
operator|&
name|d
operator|->
name|sn_except
block|}
decl_stmt|;
name|QSNDict
modifier|*
name|dict
init|=
name|sn_vec
index|[
name|type
index|]
decl_stmt|;
if|if
condition|(
name|QCoreApplication
operator|::
name|closingDown
argument_list|()
condition|)
comment|// ### d->exitloop?
return|return;
comment|// after sn_cleanup, don't reinitialize.
if|if
condition|(
name|dict
operator|->
name|contains
argument_list|(
name|sockfd
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|t
index|[]
init|=
block|{
literal|"Read"
block|,
literal|"Write"
block|,
literal|"Exception"
block|}
decl_stmt|;
comment|/* Variable "socket" below is a function pointer. */
name|qWarning
argument_list|(
literal|"QSocketNotifier: Multiple socket notifiers for "
literal|"same socket %d and type %s"
argument_list|,
name|sockfd
argument_list|,
name|t
index|[
name|type
index|]
argument_list|)
expr_stmt|;
block|}
name|QSockNot
modifier|*
name|sn
init|=
operator|new
name|QSockNot
decl_stmt|;
name|sn
operator|->
name|obj
operator|=
name|notifier
expr_stmt|;
name|sn
operator|->
name|fd
operator|=
name|sockfd
expr_stmt|;
name|dict
operator|->
name|insert
argument_list|(
name|sn
operator|->
name|fd
argument_list|,
name|sn
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|internalHwnd
condition|)
name|d
operator|->
name|doWsaAsyncSelect
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unregisterSocketNotifier
name|void
name|QEventDispatcherWin32
operator|::
name|unregisterSocketNotifier
parameter_list|(
name|QSocketNotifier
modifier|*
name|notifier
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|notifier
argument_list|)
expr_stmt|;
name|int
name|sockfd
init|=
name|notifier
operator|->
name|socket
argument_list|()
decl_stmt|;
name|int
name|type
init|=
name|notifier
operator|->
name|type
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSocketNotifier: Internal error"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|notifier
operator|->
name|thread
argument_list|()
operator|!=
name|thread
argument_list|()
operator|||
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSocketNotifier: socket notifiers cannot be disabled from another thread"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
name|QSNDict
modifier|*
name|sn_vec
index|[
literal|3
index|]
init|=
block|{
operator|&
name|d
operator|->
name|sn_read
block|,
operator|&
name|d
operator|->
name|sn_write
block|,
operator|&
name|d
operator|->
name|sn_except
block|}
decl_stmt|;
name|QSNDict
modifier|*
name|dict
init|=
name|sn_vec
index|[
name|type
index|]
decl_stmt|;
name|QSockNot
modifier|*
name|sn
init|=
name|dict
operator|->
name|value
argument_list|(
name|sockfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sn
condition|)
return|return;
name|dict
operator|->
name|remove
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
operator|delete
name|sn
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|internalHwnd
condition|)
name|d
operator|->
name|doWsaAsyncSelect
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|registerTimer
name|void
name|QEventDispatcherWin32
operator|::
name|registerTimer
parameter_list|(
name|int
name|timerId
parameter_list|,
name|int
name|interval
parameter_list|,
name|Qt
operator|::
name|TimerType
name|timerType
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|)
block|{
if|if
condition|(
name|timerId
operator|<
literal|1
operator|||
name|interval
operator|<
literal|0
operator|||
operator|!
name|object
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEventDispatcherWin32::registerTimer: invalid arguments"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|object
operator|->
name|thread
argument_list|()
operator|!=
name|thread
argument_list|()
operator|||
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::startTimer: timers cannot be started from another thread"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
name|WinTimerInfo
modifier|*
name|t
init|=
operator|new
name|WinTimerInfo
decl_stmt|;
name|t
operator|->
name|dispatcher
operator|=
name|this
expr_stmt|;
name|t
operator|->
name|timerId
operator|=
name|timerId
expr_stmt|;
name|t
operator|->
name|interval
operator|=
name|interval
expr_stmt|;
name|t
operator|->
name|timerType
operator|=
name|timerType
expr_stmt|;
name|t
operator|->
name|obj
operator|=
name|object
expr_stmt|;
name|t
operator|->
name|inTimerEvent
operator|=
literal|false
expr_stmt|;
name|t
operator|->
name|fastTimerId
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|internalHwnd
condition|)
name|d
operator|->
name|registerTimer
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|d
operator|->
name|timerVec
operator|.
name|append
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|// store in timer vector
name|d
operator|->
name|timerDict
operator|.
name|insert
argument_list|(
name|t
operator|->
name|timerId
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// store timers in dict
block|}
end_function
begin_function
DECL|function|unregisterTimer
name|bool
name|QEventDispatcherWin32
operator|::
name|unregisterTimer
parameter_list|(
name|int
name|timerId
parameter_list|)
block|{
if|if
condition|(
name|timerId
operator|<
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEventDispatcherWin32::unregisterTimer: invalid argument"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QThread
modifier|*
name|currentThread
init|=
name|QThread
operator|::
name|currentThread
argument_list|()
decl_stmt|;
if|if
condition|(
name|thread
argument_list|()
operator|!=
name|currentThread
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::killTimer: timers cannot be stopped from another thread"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|timerVec
operator|.
name|isEmpty
argument_list|()
operator|||
name|timerId
operator|<=
literal|0
condition|)
return|return
literal|false
return|;
name|WinTimerInfo
modifier|*
name|t
init|=
name|d
operator|->
name|timerDict
operator|.
name|value
argument_list|(
name|timerId
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|timerDict
operator|.
name|remove
argument_list|(
name|t
operator|->
name|timerId
argument_list|)
expr_stmt|;
name|d
operator|->
name|timerVec
operator|.
name|removeAll
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|d
operator|->
name|unregisterTimer
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|unregisterTimers
name|bool
name|QEventDispatcherWin32
operator|::
name|unregisterTimers
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
block|{
if|if
condition|(
operator|!
name|object
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEventDispatcherWin32::unregisterTimers: invalid argument"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QThread
modifier|*
name|currentThread
init|=
name|QThread
operator|::
name|currentThread
argument_list|()
decl_stmt|;
if|if
condition|(
name|object
operator|->
name|thread
argument_list|()
operator|!=
name|thread
argument_list|()
operator|||
name|thread
argument_list|()
operator|!=
name|currentThread
condition|)
block|{
name|qWarning
argument_list|(
literal|"QObject::killTimers: timers cannot be stopped from another thread"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|timerVec
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
specifier|register
name|WinTimerInfo
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|timerVec
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|d
operator|->
name|timerVec
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|t
operator|->
name|obj
operator|==
name|object
condition|)
block|{
comment|// object found
name|d
operator|->
name|timerDict
operator|.
name|remove
argument_list|(
name|t
operator|->
name|timerId
argument_list|)
expr_stmt|;
name|d
operator|->
name|timerVec
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|d
operator|->
name|unregisterTimer
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
name|QList
argument_list|<
name|QEventDispatcherWin32
operator|::
name|TimerInfo
argument_list|>
DECL|function|registeredTimers
name|QEventDispatcherWin32
operator|::
name|registeredTimers
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|object
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEventDispatcherWin32:registeredTimers: invalid argument"
argument_list|)
expr_stmt|;
return|return
name|QList
argument_list|<
name|TimerInfo
argument_list|>
argument_list|()
return|;
block|}
name|Q_D
argument_list|(
specifier|const
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|TimerInfo
argument_list|>
name|list
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|timerVec
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|WinTimerInfo
modifier|*
name|t
init|=
name|d
operator|->
name|timerVec
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|&&
name|t
operator|->
name|obj
operator|==
name|object
condition|)
name|list
operator|<<
name|TimerInfo
argument_list|(
name|t
operator|->
name|timerId
argument_list|,
name|t
operator|->
name|interval
argument_list|,
name|t
operator|->
name|timerType
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|registerEventNotifier
name|bool
name|QEventDispatcherWin32
operator|::
name|registerEventNotifier
parameter_list|(
name|QWinEventNotifier
modifier|*
name|notifier
parameter_list|)
block|{
if|if
condition|(
operator|!
name|notifier
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWinEventNotifier: Internal error"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|notifier
operator|->
name|thread
argument_list|()
operator|!=
name|thread
argument_list|()
operator|||
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWinEventNotifier: event notifiers cannot be enabled from another thread"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|winEventNotifierList
operator|.
name|contains
argument_list|(
name|notifier
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|d
operator|->
name|winEventNotifierList
operator|.
name|count
argument_list|()
operator|>=
name|MAXIMUM_WAIT_OBJECTS
operator|-
literal|2
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWinEventNotifier: Cannot have more than %d enabled at one time"
argument_list|,
name|MAXIMUM_WAIT_OBJECTS
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|winEventNotifierList
operator|.
name|append
argument_list|(
name|notifier
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|unregisterEventNotifier
name|void
name|QEventDispatcherWin32
operator|::
name|unregisterEventNotifier
parameter_list|(
name|QWinEventNotifier
modifier|*
name|notifier
parameter_list|)
block|{
if|if
condition|(
operator|!
name|notifier
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWinEventNotifier: Internal error"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|notifier
operator|->
name|thread
argument_list|()
operator|!=
name|thread
argument_list|()
operator|||
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QWinEventNotifier: event notifiers cannot be disabled from another thread"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|d
operator|->
name|winEventNotifierList
operator|.
name|indexOf
argument_list|(
name|notifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
name|d
operator|->
name|winEventNotifierList
operator|.
name|takeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|activateEventNotifiers
name|void
name|QEventDispatcherWin32
operator|::
name|activateEventNotifiers
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
comment|//### this could break if events are removed/added in the activation
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|winEventNotifierList
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
name|WaitForSingleObjectEx
argument_list|(
name|d
operator|->
name|winEventNotifierList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|handle
argument_list|()
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
name|d
operator|->
name|activateEventNotifier
argument_list|(
name|d
operator|->
name|winEventNotifierList
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|WaitForSingleObject
argument_list|(
name|d
operator|->
name|winEventNotifierList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|handle
argument_list|()
argument_list|,
literal|0
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
name|d
operator|->
name|activateEventNotifier
argument_list|(
name|d
operator|->
name|winEventNotifierList
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_function
DECL|function|remainingTime
name|int
name|QEventDispatcherWin32
operator|::
name|remainingTime
parameter_list|(
name|int
name|timerId
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
if|if
condition|(
name|timerId
operator|<
literal|1
condition|)
block|{
name|qWarning
argument_list|(
literal|"QEventDispatcherWin32::remainingTime: invalid argument"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|timerVec
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|quint64
name|currentTime
init|=
name|qt_msectime
argument_list|()
decl_stmt|;
specifier|register
name|WinTimerInfo
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|timerVec
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|d
operator|->
name|timerVec
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|t
operator|->
name|timerId
operator|==
name|timerId
condition|)
block|{
comment|// timer found
if|if
condition|(
name|currentTime
operator|<
name|t
operator|->
name|timeout
condition|)
block|{
comment|// time to wait
return|return
name|t
operator|->
name|timeout
operator|-
name|currentTime
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QEventDispatcherWin32::remainingTime: timer id %d not found"
argument_list|,
name|timerId
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|wakeUp
name|void
name|QEventDispatcherWin32
operator|::
name|wakeUp
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
name|d
operator|->
name|serialNumber
operator|.
name|ref
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|internalHwnd
operator|&&
name|d
operator|->
name|wakeUps
operator|.
name|testAndSetAcquire
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|// post a WM_QT_SENDPOSTEDEVENTS to this thread if there isn't one already pending
name|PostMessage
argument_list|(
name|d
operator|->
name|internalHwnd
argument_list|,
name|WM_QT_SENDPOSTEDEVENTS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|interrupt
name|void
name|QEventDispatcherWin32
operator|::
name|interrupt
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
name|d
operator|->
name|interrupt
operator|=
literal|true
expr_stmt|;
name|wakeUp
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|flush
name|void
name|QEventDispatcherWin32
operator|::
name|flush
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|startingUp
name|void
name|QEventDispatcherWin32
operator|::
name|startingUp
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|closingDown
name|void
name|QEventDispatcherWin32
operator|::
name|closingDown
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
comment|// clean up any socketnotifiers
while|while
condition|(
operator|!
name|d
operator|->
name|sn_read
operator|.
name|isEmpty
argument_list|()
condition|)
name|unregisterSocketNotifier
argument_list|(
operator|(
operator|*
operator|(
name|d
operator|->
name|sn_read
operator|.
name|begin
argument_list|()
operator|)
operator|)
operator|->
name|obj
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|d
operator|->
name|sn_write
operator|.
name|isEmpty
argument_list|()
condition|)
name|unregisterSocketNotifier
argument_list|(
operator|(
operator|*
operator|(
name|d
operator|->
name|sn_write
operator|.
name|begin
argument_list|()
operator|)
operator|)
operator|->
name|obj
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|d
operator|->
name|sn_except
operator|.
name|isEmpty
argument_list|()
condition|)
name|unregisterSocketNotifier
argument_list|(
operator|(
operator|*
operator|(
name|d
operator|->
name|sn_except
operator|.
name|begin
argument_list|()
operator|)
operator|)
operator|->
name|obj
argument_list|)
expr_stmt|;
comment|// clean up any timers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|timerVec
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|unregisterTimer
argument_list|(
name|d
operator|->
name|timerVec
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|timerVec
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|timerDict
operator|.
name|clear
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_WINCE
if|if
condition|(
name|d
operator|->
name|getMessageHook
condition|)
name|UnhookWindowsHookEx
argument_list|(
name|d
operator|->
name|getMessageHook
argument_list|)
expr_stmt|;
name|d
operator|->
name|getMessageHook
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|event
name|bool
name|QEventDispatcherWin32
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ZeroTimerEvent
condition|)
block|{
name|QZeroTimerEvent
modifier|*
name|zte
init|=
cast|static_cast
argument_list|<
name|QZeroTimerEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|WinTimerInfo
modifier|*
name|t
init|=
name|d
operator|->
name|timerDict
operator|.
name|value
argument_list|(
name|zte
operator|->
name|timerId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|t
operator|->
name|inTimerEvent
operator|=
literal|true
expr_stmt|;
name|QTimerEvent
name|te
argument_list|(
name|zte
operator|->
name|timerId
argument_list|()
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|t
operator|->
name|obj
argument_list|,
operator|&
name|te
argument_list|)
expr_stmt|;
name|t
operator|=
name|d
operator|->
name|timerDict
operator|.
name|value
argument_list|(
name|zte
operator|->
name|timerId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|interval
operator|==
literal|0
operator|&&
name|t
operator|->
name|inTimerEvent
condition|)
block|{
comment|// post the next zero timer event as long as the timer was not restarted
name|QCoreApplication
operator|::
name|postEvent
argument_list|(
name|this
argument_list|,
operator|new
name|QZeroTimerEvent
argument_list|(
name|zte
operator|->
name|timerId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|inTimerEvent
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|Timer
condition|)
block|{
name|QTimerEvent
modifier|*
name|te
init|=
cast|static_cast
argument_list|<
name|QTimerEvent
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|d
operator|->
name|sendTimerEvent
argument_list|(
name|te
operator|->
name|timerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|QAbstractEventDispatcher
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sendPostedEvents
name|void
name|QEventDispatcherWin32
operator|::
name|sendPostedEvents
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QEventDispatcherWin32
argument_list|)
expr_stmt|;
name|QCoreApplicationPrivate
operator|::
name|sendPostedEvents
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|threadData
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
