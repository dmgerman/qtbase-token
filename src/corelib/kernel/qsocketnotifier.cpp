begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsocketnotifier.h"
end_include
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qabstracteventdispatcher.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qobject_p.h"
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QSocketNotifierPrivate
class|class
name|QSocketNotifierPrivate
super|:
specifier|public
name|QObjectPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QSocketNotifier
parameter_list|)
specifier|public
private|:
DECL|member|sockfd
name|qintptr
name|sockfd
decl_stmt|;
DECL|member|sntype
name|QSocketNotifier
operator|::
name|Type
name|sntype
decl_stmt|;
DECL|member|snenabled
name|bool
name|snenabled
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     \class QSocketNotifier     \inmodule QtCore     \brief The QSocketNotifier class provides support for monitoring     activity on a file descriptor.      \ingroup network     \ingroup io      The QSocketNotifier makes it possible to integrate Qt's event     loop with other event loops based on file descriptors. File     descriptor action is detected in Qt's main event     loop (QCoreApplication::exec()).      \target write notifiers      Once you have opened a device using a low-level (usually     platform-specific) API, you can create a socket notifier to     monitor the file descriptor. The socket notifier is enabled by     default, i.e. it emits the activated() signal whenever a socket     event corresponding to its type occurs. Connect the activated()     signal to the slot you want to be called when an event     corresponding to your socket notifier's type occurs.      There are three types of socket notifiers: read, write, and     exception. The type is described by the \l Type enum, and must be     specified when constructing the socket notifier. After     construction it can be determined using the type() function. Note     that if you need to monitor both reads and writes for the same     file descriptor, you must create two socket notifiers. Note also     that it is not possible to install two socket notifiers of the     same type (\l Read, \l Write, \l Exception) on the same socket.      The setEnabled() function allows you to disable as well as enable     the socket notifier. It is generally advisable to explicitly     enable or disable the socket notifier, especially for write     notifiers. A disabled notifier ignores socket events (the same     effect as not creating the socket notifier). Use the isEnabled()     function to determine the notifier's current status.      Finally, you can use the socket() function to retrieve the     socket identifier.  Although the class is called QSocketNotifier,     it is normally used for other types of devices than sockets.     QTcpSocket and QUdpSocket provide notification through signals, so     there is normally no need to use a QSocketNotifier on them.      \sa QFile, QProcess, QTcpSocket, QUdpSocket */
end_comment
begin_comment
comment|/*!     \enum QSocketNotifier::Type      This enum describes the various types of events that a socket     notifier can recognize. The type must be specified when     constructing the socket notifier.      Note that if you need to monitor both reads and writes for the     same file descriptor, you must create two socket notifiers. Note     also that it is not possible to install two socket notifiers of     the same type (Read, Write, Exception) on the same socket.      \value Read      There is data to be read.     \value Write      Data can be written.     \value Exception  An exception has occurred. We recommend against using this.      \sa QSocketNotifier(), type() */
end_comment
begin_comment
comment|/*!     Constructs a socket notifier with the given \a parent. It enables     the \a socket, and watches for events of the given \a type.      It is generally advisable to explicitly enable or disable the     socket notifier, especially for write notifiers.      \b{Note for Windows users:} The socket passed to QSocketNotifier     will become non-blocking, even if it was created as a blocking socket.      \sa setEnabled(), isEnabled() */
end_comment
begin_constructor
DECL|function|QSocketNotifier
name|QSocketNotifier
operator|::
name|QSocketNotifier
parameter_list|(
name|qintptr
name|socket
parameter_list|,
name|Type
name|type
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QSocketNotifierPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QSocketNotifier
argument_list|)
expr_stmt|;
name|d
operator|->
name|sockfd
operator|=
name|socket
expr_stmt|;
name|d
operator|->
name|sntype
operator|=
name|type
expr_stmt|;
name|d
operator|->
name|snenabled
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|socket
operator|<
literal|0
condition|)
name|qWarning
argument_list|(
literal|"QSocketNotifier: Invalid socket specified"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QSocketNotifier: Can only be used with threads started with QThread"
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
operator|->
name|registerSocketNotifier
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys this socket notifier. */
end_comment
begin_destructor
DECL|function|~QSocketNotifier
name|QSocketNotifier
operator|::
name|~
name|QSocketNotifier
parameter_list|()
block|{
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn void QSocketNotifier::activated(int socket)      This signal is emitted whenever the socket notifier is enabled and     a socket event corresponding to its \l {Type}{type} occurs.      The socket identifier is passed in the \a socket parameter.      \sa type(), socket() */
end_comment
begin_comment
comment|/*!     Returns the socket identifier specified to the constructor.      \sa type() */
end_comment
begin_function
DECL|function|socket
name|qintptr
name|QSocketNotifier
operator|::
name|socket
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSocketNotifier
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sockfd
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the socket event type specified to the constructor.      \sa socket() */
end_comment
begin_function
DECL|function|type
name|QSocketNotifier
operator|::
name|Type
name|QSocketNotifier
operator|::
name|type
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSocketNotifier
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sntype
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the notifier is enabled; otherwise returns \c false.      \sa setEnabled() */
end_comment
begin_function
DECL|function|isEnabled
name|bool
name|QSocketNotifier
operator|::
name|isEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSocketNotifier
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|snenabled
return|;
block|}
end_function
begin_comment
comment|/*!     If \a enable is true, the notifier is enabled; otherwise the notifier     is disabled.      The notifier is enabled by default, i.e. it emits the activated()     signal whenever a socket event corresponding to its     \l{type()}{type} occurs. If it is disabled, it ignores socket     events (the same effect as not creating the socket notifier).      Write notifiers should normally be disabled immediately after the     activated() signal has been emitted      \sa isEnabled(), activated() */
end_comment
begin_function
DECL|function|setEnabled
name|void
name|QSocketNotifier
operator|::
name|setEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSocketNotifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|sockfd
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|snenabled
operator|==
name|enable
condition|)
comment|// no change
return|return;
name|d
operator|->
name|snenabled
operator|=
name|enable
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
condition|)
comment|// perhaps application/thread is shutting down
return|return;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|thread
argument_list|()
operator|!=
name|QThread
operator|::
name|currentThread
argument_list|()
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSocketNotifier: Socket notifiers cannot be enabled or disabled from another thread"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|snenabled
condition|)
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
operator|->
name|registerSocketNotifier
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
operator|->
name|unregisterSocketNotifier
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QSocketNotifier
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSocketNotifier
argument_list|)
expr_stmt|;
comment|// Emits the activated() signal when a QEvent::SockAct or QEvent::SockClose is
comment|// received.
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ThreadChange
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|snenabled
condition|)
block|{
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"setEnabled"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|,
name|Q_ARG
argument_list|(
name|bool
argument_list|,
name|d
operator|->
name|snenabled
argument_list|)
argument_list|)
expr_stmt|;
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|QObject
operator|::
name|event
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// will activate filters
if|if
condition|(
operator|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|SockAct
operator|)
operator|||
operator|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|SockClose
operator|)
condition|)
block|{
emit|emit
name|activated
argument_list|(
name|d
operator|->
name|sockfd
argument_list|,
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
