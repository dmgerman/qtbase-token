begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qsocketnotifier.h"
end_include
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qabstracteventdispatcher.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qobject_p.h"
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class
DECL|class|QSocketNotifierPrivate
class|class
name|QSocketNotifierPrivate
super|:
specifier|public
name|QObjectPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QSocketNotifier
parameter_list|)
specifier|public
private|:
DECL|member|sockfd
name|qintptr
name|sockfd
decl_stmt|;
DECL|member|sntype
name|QSocketNotifier
operator|::
name|Type
name|sntype
decl_stmt|;
DECL|member|snenabled
name|bool
name|snenabled
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!     \class QSocketNotifier     \inmodule QtCore     \brief The QSocketNotifier class provides support for monitoring     activity on a file descriptor.      \ingroup network     \ingroup io      The QSocketNotifier makes it possible to integrate Qt's event     loop with other event loops based on file descriptors. File     descriptor action is detected in Qt's main event     loop (QCoreApplication::exec()).      \target write notifiers      Once you have opened a device using a low-level (usually     platform-specific) API, you can create a socket notifier to     monitor the file descriptor. The socket notifier is enabled by     default, i.e. it emits the activated() signal whenever a socket     event corresponding to its type occurs. Connect the activated()     signal to the slot you want to be called when an event     corresponding to your socket notifier's type occurs.      There are three types of socket notifiers: read, write, and     exception. The type is described by the \l Type enum, and must be     specified when constructing the socket notifier. After     construction it can be determined using the type() function. Note     that if you need to monitor both reads and writes for the same     file descriptor, you must create two socket notifiers. Note also     that it is not possible to install two socket notifiers of the     same type (\l Read, \l Write, \l Exception) on the same socket.      The setEnabled() function allows you to disable as well as enable     the socket notifier. It is generally advisable to explicitly     enable or disable the socket notifier, especially for write     notifiers. A disabled notifier ignores socket events (the same     effect as not creating the socket notifier). Use the isEnabled()     function to determine the notifier's current status.      Finally, you can use the socket() function to retrieve the     socket identifier.  Although the class is called QSocketNotifier,     it is normally used for other types of devices than sockets.     QTcpSocket and QUdpSocket provide notification through signals, so     there is normally no need to use a QSocketNotifier on them.      \section1 Notes for Windows Users      The socket passed to QSocketNotifier will become non-blocking, even if     it was created as a blocking socket.     The activated() signal is sometimes triggered by high general activity     on the host, even if there is nothing to read. A subsequent read from     the socket can then fail, the error indicating that there is no data     available (e.g., \c{WSAEWOULDBLOCK}). This is an operating system     limitation, and not a bug in QSocketNotifier.      To ensure that the socket notifier handles read notifications correctly,     follow these steps when you receive a notification:      \list 1     \li Disable the notifier.     \li Read data from the socket.     \li Re-enable the notifier if you are interested in more data (such as after        having written a new command to a remote server).     \endlist      To ensure that the socket notifier handles write notifications correctly,     follow these steps when you receive a notification:      \list 1     \li Disable the notifier.     \li Write as much data as you can (before \c EWOULDBLOCK is returned).     \li Re-enable notifier if you have more data to write.     \endlist      \b{Further information:}     On Windows, Qt always disables the notifier after getting a notification,     and only re-enables it if more data is expected. For example, if data is     read from the socket and it can be used to read more, or if reading or     writing is not possible because the socket would block, in which case     it is necessary to wait before attempting to read or write again.      \sa QFile, QProcess, QTcpSocket, QUdpSocket */
end_comment
begin_comment
comment|/*!     \enum QSocketNotifier::Type      This enum describes the various types of events that a socket     notifier can recognize. The type must be specified when     constructing the socket notifier.      Note that if you need to monitor both reads and writes for the     same file descriptor, you must create two socket notifiers. Note     also that it is not possible to install two socket notifiers of     the same type (Read, Write, Exception) on the same socket.      \value Read      There is data to be read.     \value Write      Data can be written.     \value Exception  An exception has occurred. We recommend against using this.      \sa QSocketNotifier(), type() */
end_comment
begin_comment
comment|/*!     Constructs a socket notifier with the given \a parent. It enables     the \a socket, and watches for events of the given \a type.      It is generally advisable to explicitly enable or disable the     socket notifier, especially for write notifiers.      \b{Note for Windows users:} The socket passed to QSocketNotifier     will become non-blocking, even if it was created as a blocking socket.      \sa setEnabled(), isEnabled() */
end_comment
begin_constructor
DECL|function|QSocketNotifier
name|QSocketNotifier
operator|::
name|QSocketNotifier
parameter_list|(
name|qintptr
name|socket
parameter_list|,
name|Type
name|type
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QSocketNotifierPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QSocketNotifier
argument_list|)
expr_stmt|;
name|d
operator|->
name|sockfd
operator|=
name|socket
expr_stmt|;
name|d
operator|->
name|sntype
operator|=
name|type
expr_stmt|;
name|d
operator|->
name|snenabled
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|socket
operator|<
literal|0
condition|)
name|qWarning
argument_list|(
literal|"QSocketNotifier: Invalid socket specified"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QSocketNotifier: Can only be used with threads started with QThread"
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
operator|->
name|registerSocketNotifier
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys this socket notifier. */
end_comment
begin_destructor
DECL|function|~QSocketNotifier
name|QSocketNotifier
operator|::
name|~
name|QSocketNotifier
parameter_list|()
block|{
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \fn void QSocketNotifier::activated(int socket)      This signal is emitted whenever the socket notifier is enabled and     a socket event corresponding to its \l {Type}{type} occurs.      The socket identifier is passed in the \a socket parameter.      \sa type(), socket() */
end_comment
begin_comment
comment|/*!     Returns the socket identifier specified to the constructor.      \sa type() */
end_comment
begin_function
DECL|function|socket
name|qintptr
name|QSocketNotifier
operator|::
name|socket
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSocketNotifier
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sockfd
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the socket event type specified to the constructor.      \sa socket() */
end_comment
begin_function
DECL|function|type
name|QSocketNotifier
operator|::
name|Type
name|QSocketNotifier
operator|::
name|type
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSocketNotifier
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sntype
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the notifier is enabled; otherwise returns \c false.      \sa setEnabled() */
end_comment
begin_function
DECL|function|isEnabled
name|bool
name|QSocketNotifier
operator|::
name|isEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSocketNotifier
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|snenabled
return|;
block|}
end_function
begin_comment
comment|/*!     If \a enable is true, the notifier is enabled; otherwise the notifier     is disabled.      The notifier is enabled by default, i.e. it emits the activated()     signal whenever a socket event corresponding to its     \l{type()}{type} occurs. If it is disabled, it ignores socket     events (the same effect as not creating the socket notifier).      Write notifiers should normally be disabled immediately after the     activated() signal has been emitted      \sa isEnabled(), activated() */
end_comment
begin_function
DECL|function|setEnabled
name|void
name|QSocketNotifier
operator|::
name|setEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSocketNotifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|sockfd
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|snenabled
operator|==
name|enable
condition|)
comment|// no change
return|return;
name|d
operator|->
name|snenabled
operator|=
name|enable
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
condition|)
comment|// perhaps application/thread is shutting down
return|return;
if|if
condition|(
name|d
operator|->
name|snenabled
condition|)
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
operator|->
name|registerSocketNotifier
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
operator|.
name|load
argument_list|()
operator|->
name|unregisterSocketNotifier
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\reimp */
end_comment
begin_function
DECL|function|event
name|bool
name|QSocketNotifier
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSocketNotifier
argument_list|)
expr_stmt|;
comment|// Emits the activated() signal when a QEvent::SockAct or QEvent::SockClose is
comment|// received.
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ThreadChange
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|snenabled
condition|)
block|{
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"setEnabled"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|,
name|Q_ARG
argument_list|(
name|bool
argument_list|,
name|d
operator|->
name|snenabled
argument_list|)
argument_list|)
expr_stmt|;
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|QObject
operator|::
name|event
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// will activate filters
if|if
condition|(
operator|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|SockAct
operator|)
operator|||
operator|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|SockClose
operator|)
condition|)
block|{
emit|emit
name|activated
argument_list|(
name|d
operator|->
name|sockfd
argument_list|,
name|QPrivateSignal
argument_list|()
argument_list|)
emit|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
