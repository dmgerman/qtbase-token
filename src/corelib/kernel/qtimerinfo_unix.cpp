begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qelapsedtimer.h>
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|"private/qcore_unix_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qtimerinfo_unix_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qobject_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qabstracteventdispatcher_p.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QTIMERINFO_DEBUG
end_ifdef
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_include
include|#
directive|include
file|<QThread>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<sys/times.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|variable|qt_disable_lowpriority_timers
name|Q_CORE_EXPORT
name|bool
name|qt_disable_lowpriority_timers
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Internal functions for manipulating timer data structures.  The  * timerBitVec array is used for keeping track of timer identifiers.  */
end_comment
begin_constructor
DECL|function|QTimerInfoList
name|QTimerInfoList
operator|::
name|QTimerInfoList
parameter_list|()
block|{
if|#
directive|if
operator|(
name|_POSIX_MONOTONIC_CLOCK
operator|-
literal|0
operator|<=
literal|0
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_NACL
argument_list|)
if|if
condition|(
operator|!
name|QElapsedTimer
operator|::
name|isMonotonic
argument_list|()
condition|)
block|{
comment|// not using monotonic timers, initialize the timeChanged() machinery
name|previousTime
operator|=
name|qt_gettime
argument_list|()
expr_stmt|;
name|tms
name|unused
decl_stmt|;
name|previousTicks
operator|=
name|times
argument_list|(
operator|&
name|unused
argument_list|)
expr_stmt|;
name|ticksPerSecond
operator|=
name|sysconf
argument_list|(
name|_SC_CLK_TCK
argument_list|)
expr_stmt|;
name|msPerTick
operator|=
literal|1000
operator|/
name|ticksPerSecond
expr_stmt|;
block|}
else|else
block|{
comment|// detected monotonic timers
name|previousTime
operator|.
name|tv_sec
operator|=
name|previousTime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|previousTicks
operator|=
literal|0
expr_stmt|;
name|ticksPerSecond
operator|=
literal|0
expr_stmt|;
name|msPerTick
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|firstTimerInfo
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|updateCurrentTime
name|timespec
name|QTimerInfoList
operator|::
name|updateCurrentTime
parameter_list|()
block|{
return|return
operator|(
name|currentTime
operator|=
name|qt_gettime
argument_list|()
operator|)
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|(
operator|(
name|_POSIX_MONOTONIC_CLOCK
operator|-
literal|0
operator|<=
literal|0
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_INTEGRITY
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
end_if
begin_function
DECL|function|qAbsTimespec
name|timespec
name|qAbsTimespec
parameter_list|(
specifier|const
name|timespec
modifier|&
name|t
parameter_list|)
block|{
name|timespec
name|tmp
init|=
name|t
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|tv_sec
operator|<
literal|0
condition|)
block|{
name|tmp
operator|.
name|tv_sec
operator|=
operator|-
name|tmp
operator|.
name|tv_sec
operator|-
literal|1
expr_stmt|;
name|tmp
operator|.
name|tv_nsec
operator|-=
literal|1000000000
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|tmp
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|tmp
operator|.
name|tv_nsec
operator|=
operator|-
name|tmp
operator|.
name|tv_nsec
expr_stmt|;
block|}
return|return
name|normalizedTimespec
argument_list|(
name|tmp
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*   Returns \c true if the real time clock has changed by more than 10%   relative to the processor time since the last time this function was   called. This presumably means that the system time has been changed.    If /a delta is nonzero, delta is set to our best guess at how much the system clock was changed. */
end_comment
begin_function
DECL|function|timeChanged
name|bool
name|QTimerInfoList
operator|::
name|timeChanged
parameter_list|(
name|timespec
modifier|*
name|delta
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_NACL
name|Q_UNUSED
argument_list|(
argument|delta
argument_list|)
return|return
literal|false
return|;
comment|// Calling "times" crashes.
endif|#
directive|endif
name|struct
name|tms
name|unused
decl_stmt|;
name|clock_t
name|currentTicks
init|=
name|times
argument_list|(
operator|&
name|unused
argument_list|)
decl_stmt|;
name|clock_t
name|elapsedTicks
init|=
name|currentTicks
operator|-
name|previousTicks
decl_stmt|;
name|timespec
name|elapsedTime
init|=
name|currentTime
operator|-
name|previousTime
decl_stmt|;
name|timespec
name|elapsedTimeTicks
decl_stmt|;
name|elapsedTimeTicks
operator|.
name|tv_sec
operator|=
name|elapsedTicks
operator|/
name|ticksPerSecond
expr_stmt|;
name|elapsedTimeTicks
operator|.
name|tv_nsec
operator|=
operator|(
operator|(
operator|(
name|elapsedTicks
operator|*
literal|1000
operator|)
operator|/
name|ticksPerSecond
operator|)
operator|%
literal|1000
operator|)
operator|*
literal|1000
operator|*
literal|1000
expr_stmt|;
name|timespec
name|dummy
decl_stmt|;
if|if
condition|(
operator|!
name|delta
condition|)
name|delta
operator|=
operator|&
name|dummy
expr_stmt|;
operator|*
name|delta
operator|=
name|elapsedTime
operator|-
name|elapsedTimeTicks
expr_stmt|;
name|previousTicks
operator|=
name|currentTicks
expr_stmt|;
name|previousTime
operator|=
name|currentTime
expr_stmt|;
comment|// If tick drift is more than 10% off compared to realtime, we assume that the clock has
comment|// been set. Of course, we have to allow for the tick granularity as well.
name|timespec
name|tickGranularity
decl_stmt|;
name|tickGranularity
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tickGranularity
operator|.
name|tv_nsec
operator|=
name|msPerTick
operator|*
literal|1000
operator|*
literal|1000
expr_stmt|;
return|return
name|elapsedTimeTicks
operator|<
operator|(
operator|(
name|qAbsTimespec
argument_list|(
operator|*
name|delta
argument_list|)
operator|-
name|tickGranularity
operator|)
operator|*
literal|10
operator|)
return|;
block|}
end_function
begin_comment
comment|/*   repair broken timer */
end_comment
begin_function
DECL|function|timerRepair
name|void
name|QTimerInfoList
operator|::
name|timerRepair
parameter_list|(
specifier|const
name|timespec
modifier|&
name|diff
parameter_list|)
block|{
comment|// repair all timers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTimerInfo
modifier|*
name|t
init|=
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|t
operator|->
name|timeout
operator|=
name|t
operator|->
name|timeout
operator|+
name|diff
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|repairTimersIfNeeded
name|void
name|QTimerInfoList
operator|::
name|repairTimersIfNeeded
parameter_list|()
block|{
if|if
condition|(
name|QElapsedTimer
operator|::
name|isMonotonic
argument_list|()
condition|)
return|return;
name|timespec
name|delta
decl_stmt|;
if|if
condition|(
name|timeChanged
argument_list|(
operator|&
name|delta
argument_list|)
condition|)
name|timerRepair
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|// !(_POSIX_MONOTONIC_CLOCK-0<= 0)&& !defined(QT_BOOTSTRAPPED)
end_comment
begin_function
DECL|function|repairTimersIfNeeded
name|void
name|QTimerInfoList
operator|::
name|repairTimersIfNeeded
parameter_list|()
block|{ }
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*   insert timer info into list */
end_comment
begin_function
DECL|function|timerInsert
name|void
name|QTimerInfoList
operator|::
name|timerInsert
parameter_list|(
name|QTimerInfo
modifier|*
name|ti
parameter_list|)
block|{
name|int
name|index
init|=
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|index
operator|--
condition|)
block|{
specifier|const
name|QTimerInfo
modifier|*
specifier|const
name|t
init|=
name|at
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ti
operator|->
name|timeout
operator|<
name|t
operator|->
name|timeout
operator|)
condition|)
break|break;
block|}
name|insert
argument_list|(
name|index
operator|+
literal|1
argument_list|,
name|ti
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|operator +=
specifier|inline
name|timespec
modifier|&
name|operator
name|+=
parameter_list|(
name|timespec
modifier|&
name|t1
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
name|t1
operator|.
name|tv_sec
operator|+=
name|ms
operator|/
literal|1000
expr_stmt|;
name|t1
operator|.
name|tv_nsec
operator|+=
name|ms
operator|%
literal|1000
operator|*
literal|1000
operator|*
literal|1000
expr_stmt|;
return|return
name|normalizedTimespec
argument_list|(
name|t1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|operator +
specifier|inline
name|timespec
name|operator
name|+
parameter_list|(
specifier|const
name|timespec
modifier|&
name|t1
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
name|timespec
name|t2
init|=
name|t1
decl_stmt|;
return|return
name|t2
operator|+=
name|ms
return|;
block|}
end_function
begin_function
DECL|function|roundToMillisecond
specifier|static
name|timespec
name|roundToMillisecond
parameter_list|(
name|timespec
name|val
parameter_list|)
block|{
comment|// always round up
comment|// worst case scenario is that the first trigger of a 1-ms timer is 0.999 ms late
name|int
name|ns
init|=
name|val
operator|.
name|tv_nsec
operator|%
operator|(
literal|1000
operator|*
literal|1000
operator|)
decl_stmt|;
name|val
operator|.
name|tv_nsec
operator|+=
literal|1000
operator|*
literal|1000
operator|-
name|ns
expr_stmt|;
return|return
name|normalizedTimespec
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|QTIMERINFO_DEBUG
end_ifdef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|s
parameter_list|,
name|timeval
name|tv
parameter_list|)
block|{
name|QDebugStateSaver
name|saver
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|s
operator|.
name|nospace
argument_list|()
operator|<<
name|tv
operator|.
name|tv_sec
operator|<<
literal|"."
operator|<<
name|qSetFieldWidth
argument_list|(
literal|6
argument_list|)
operator|<<
name|qSetPadChar
argument_list|(
name|QChar
argument_list|(
literal|48
argument_list|)
argument_list|)
operator|<<
name|tv
operator|.
name|tv_usec
operator|<<
name|reset
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|s
parameter_list|,
name|Qt
operator|::
name|TimerType
name|t
parameter_list|)
block|{
name|QDebugStateSaver
name|saver
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|s
operator|<<
operator|(
name|t
operator|==
name|Qt
operator|::
name|PreciseTimer
condition|?
literal|"P"
else|:
name|t
operator|==
name|Qt
operator|::
name|CoarseTimer
condition|?
literal|"C"
else|:
literal|"VC"
operator|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|calculateCoarseTimerTimeout
specifier|static
name|void
name|calculateCoarseTimerTimeout
parameter_list|(
name|QTimerInfo
modifier|*
name|t
parameter_list|,
name|timespec
name|currentTime
parameter_list|)
block|{
comment|// The coarse timer works like this:
comment|//  - interval under 40 ms: round to even
comment|//  - between 40 and 99 ms: round to multiple of 4
comment|//  - otherwise: try to wake up at a multiple of 25 ms, with a maximum error of 5%
comment|//
comment|// We try to wake up at the following second-fraction, in order of preference:
comment|//    0 ms
comment|//  500 ms
comment|//  250 ms or 750 ms
comment|//  200, 400, 600, 800 ms
comment|//  other multiples of 100
comment|//  other multiples of 50
comment|//  other multiples of 25
comment|//
comment|// The objective is to make most timers wake up at the same time, thereby reducing CPU wakeups.
name|uint
name|interval
init|=
name|uint
argument_list|(
name|t
operator|->
name|interval
argument_list|)
decl_stmt|;
name|uint
name|msec
init|=
name|uint
argument_list|(
name|t
operator|->
name|timeout
operator|.
name|tv_nsec
argument_list|)
operator|/
literal|1000
operator|/
literal|1000
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|interval
operator|>=
literal|20
argument_list|)
expr_stmt|;
comment|// Calculate how much we can round and still keep within 5% error
name|uint
name|absMaxRounding
init|=
name|interval
operator|/
literal|20
decl_stmt|;
if|if
condition|(
name|interval
operator|<
literal|100
operator|&&
name|interval
operator|!=
literal|25
operator|&&
name|interval
operator|!=
literal|50
operator|&&
name|interval
operator|!=
literal|75
condition|)
block|{
comment|// special mode for timers of less than 100 ms
if|if
condition|(
name|interval
operator|<
literal|50
condition|)
block|{
comment|// round to even
comment|// round towards multiples of 50 ms
name|bool
name|roundUp
init|=
operator|(
name|msec
operator|%
literal|50
operator|)
operator|>=
literal|25
decl_stmt|;
name|msec
operator|>>=
literal|1
expr_stmt|;
name|msec
operator||=
name|uint
argument_list|(
name|roundUp
argument_list|)
expr_stmt|;
name|msec
operator|<<=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// round to multiple of 4
comment|// round towards multiples of 100 ms
name|bool
name|roundUp
init|=
operator|(
name|msec
operator|%
literal|100
operator|)
operator|>=
literal|50
decl_stmt|;
name|msec
operator|>>=
literal|2
expr_stmt|;
name|msec
operator||=
name|uint
argument_list|(
name|roundUp
argument_list|)
expr_stmt|;
name|msec
operator|<<=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|uint
name|min
init|=
name|qMax
argument_list|<
name|int
argument_list|>
argument_list|(
literal|0
argument_list|,
name|msec
operator|-
name|absMaxRounding
argument_list|)
decl_stmt|;
name|uint
name|max
init|=
name|qMin
argument_list|(
literal|1000u
argument_list|,
name|msec
operator|+
name|absMaxRounding
argument_list|)
decl_stmt|;
comment|// find the boundary that we want, according to the rules above
comment|// extra rules:
comment|// 1) whatever the interval, we'll take any round-to-the-second timeout
if|if
condition|(
name|min
operator|==
literal|0
condition|)
block|{
name|msec
operator|=
literal|0
expr_stmt|;
goto|goto
name|recalculate
goto|;
block|}
elseif|else
if|if
condition|(
name|max
operator|==
literal|1000
condition|)
block|{
name|msec
operator|=
literal|1000
expr_stmt|;
goto|goto
name|recalculate
goto|;
block|}
name|uint
name|wantedBoundaryMultiple
decl_stmt|;
comment|// 2) if the interval is a multiple of 500 ms and> 5000 ms, we'll always round
comment|//    towards a round-to-the-second
comment|// 3) if the interval is a multiple of 500 ms, we'll round towards the nearest
comment|//    multiple of 500 ms
if|if
condition|(
operator|(
name|interval
operator|%
literal|500
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|interval
operator|>=
literal|5000
condition|)
block|{
name|msec
operator|=
name|msec
operator|>=
literal|500
condition|?
name|max
else|:
name|min
expr_stmt|;
goto|goto
name|recalculate
goto|;
block|}
else|else
block|{
name|wantedBoundaryMultiple
operator|=
literal|500
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|interval
operator|%
literal|50
operator|)
operator|==
literal|0
condition|)
block|{
comment|// 4) same for multiples of 250, 200, 100, 50
name|uint
name|mult50
init|=
name|interval
operator|/
literal|50
decl_stmt|;
if|if
condition|(
operator|(
name|mult50
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
comment|// multiple of 200
name|wantedBoundaryMultiple
operator|=
literal|200
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mult50
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
comment|// multiple of 100
name|wantedBoundaryMultiple
operator|=
literal|100
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mult50
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
comment|// multiple of 250
name|wantedBoundaryMultiple
operator|=
literal|250
expr_stmt|;
block|}
else|else
block|{
comment|// multiple of 50
name|wantedBoundaryMultiple
operator|=
literal|50
expr_stmt|;
block|}
block|}
else|else
block|{
name|wantedBoundaryMultiple
operator|=
literal|25
expr_stmt|;
block|}
name|uint
name|base
init|=
name|msec
operator|/
name|wantedBoundaryMultiple
operator|*
name|wantedBoundaryMultiple
decl_stmt|;
name|uint
name|middlepoint
init|=
name|base
operator|+
name|wantedBoundaryMultiple
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|msec
operator|<
name|middlepoint
condition|)
name|msec
operator|=
name|qMax
argument_list|(
name|base
argument_list|,
name|min
argument_list|)
expr_stmt|;
else|else
name|msec
operator|=
name|qMin
argument_list|(
name|base
operator|+
name|wantedBoundaryMultiple
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
name|recalculate
label|:
if|if
condition|(
name|msec
operator|==
literal|1000u
condition|)
block|{
operator|++
name|t
operator|->
name|timeout
operator|.
name|tv_sec
expr_stmt|;
name|t
operator|->
name|timeout
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|timeout
operator|.
name|tv_nsec
operator|=
name|msec
operator|*
literal|1000
operator|*
literal|1000
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|timeout
operator|<
name|currentTime
condition|)
name|t
operator|->
name|timeout
operator|+=
name|interval
expr_stmt|;
block|}
end_function
begin_function
DECL|function|calculateNextTimeout
specifier|static
name|void
name|calculateNextTimeout
parameter_list|(
name|QTimerInfo
modifier|*
name|t
parameter_list|,
name|timespec
name|currentTime
parameter_list|)
block|{
switch|switch
condition|(
name|t
operator|->
name|timerType
condition|)
block|{
case|case
name|Qt
operator|::
name|PreciseTimer
case|:
case|case
name|Qt
operator|::
name|CoarseTimer
case|:
name|t
operator|->
name|timeout
operator|+=
name|t
operator|->
name|interval
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|timeout
operator|<
name|currentTime
condition|)
block|{
name|t
operator|->
name|timeout
operator|=
name|currentTime
expr_stmt|;
name|t
operator|->
name|timeout
operator|+=
name|t
operator|->
name|interval
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QTIMERINFO_DEBUG
name|t
operator|->
name|expected
operator|+=
name|t
operator|->
name|interval
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|expected
operator|<
name|currentTime
condition|)
block|{
name|t
operator|->
name|expected
operator|=
name|currentTime
expr_stmt|;
name|t
operator|->
name|expected
operator|+=
name|t
operator|->
name|interval
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|t
operator|->
name|timerType
operator|==
name|Qt
operator|::
name|CoarseTimer
condition|)
name|calculateCoarseTimerTimeout
argument_list|(
name|t
argument_list|,
name|currentTime
argument_list|)
expr_stmt|;
return|return;
case|case
name|Qt
operator|::
name|VeryCoarseTimer
case|:
comment|// we don't need to take care of the microsecond component of t->interval
name|t
operator|->
name|timeout
operator|.
name|tv_sec
operator|+=
name|t
operator|->
name|interval
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|timeout
operator|.
name|tv_sec
operator|<=
name|currentTime
operator|.
name|tv_sec
condition|)
name|t
operator|->
name|timeout
operator|.
name|tv_sec
operator|=
name|currentTime
operator|.
name|tv_sec
operator|+
name|t
operator|->
name|interval
expr_stmt|;
ifdef|#
directive|ifdef
name|QTIMERINFO_DEBUG
name|t
operator|->
name|expected
operator|.
name|tv_sec
operator|+=
name|t
operator|->
name|interval
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|expected
operator|.
name|tv_sec
operator|<=
name|currentTime
operator|.
name|tv_sec
condition|)
name|t
operator|->
name|expected
operator|.
name|tv_sec
operator|=
name|currentTime
operator|.
name|tv_sec
operator|+
name|t
operator|->
name|interval
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
ifdef|#
directive|ifdef
name|QTIMERINFO_DEBUG
if|if
condition|(
name|t
operator|->
name|timerType
operator|!=
name|Qt
operator|::
name|PreciseTimer
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"timer"
operator|<<
name|t
operator|->
name|timerType
operator|<<
name|hex
operator|<<
name|t
operator|->
name|id
operator|<<
name|dec
operator|<<
literal|"interval"
operator|<<
name|t
operator|->
name|interval
operator|<<
literal|"originally expected at"
operator|<<
name|t
operator|->
name|expected
operator|<<
literal|"will fire at"
operator|<<
name|t
operator|->
name|timeout
operator|<<
literal|"or"
operator|<<
operator|(
name|t
operator|->
name|timeout
operator|-
name|t
operator|->
name|expected
operator|)
operator|<<
literal|"s late"
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*   Returns the time to wait for the next timer, or null if no timers   are waiting. */
end_comment
begin_function
DECL|function|timerWait
name|bool
name|QTimerInfoList
operator|::
name|timerWait
parameter_list|(
name|timespec
modifier|&
name|tm
parameter_list|)
block|{
name|timespec
name|currentTime
init|=
name|updateCurrentTime
argument_list|()
decl_stmt|;
name|repairTimersIfNeeded
argument_list|()
expr_stmt|;
comment|// Find first waiting timer not already active
name|QTimerInfo
modifier|*
name|t
init|=
literal|0
decl_stmt|;
for|for
control|(
name|QTimerInfoList
operator|::
name|const_iterator
name|it
init|=
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|it
operator|)
operator|->
name|activateRef
condition|)
block|{
name|t
operator|=
operator|*
name|it
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|t
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|currentTime
operator|<
name|t
operator|->
name|timeout
condition|)
block|{
comment|// time to wait
name|tm
operator|=
name|roundToMillisecond
argument_list|(
name|t
operator|->
name|timeout
operator|-
name|currentTime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// no time to wait
name|tm
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tm
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*   Returns the timer's remaining time in milliseconds with the given timerId, or   null if there is nothing left. If the timer id is not found in the list, the   returned value will be -1. If the timer is overdue, the returned value will be 0. */
end_comment
begin_function
DECL|function|timerRemainingTime
name|int
name|QTimerInfoList
operator|::
name|timerRemainingTime
parameter_list|(
name|int
name|timerId
parameter_list|)
block|{
name|timespec
name|currentTime
init|=
name|updateCurrentTime
argument_list|()
decl_stmt|;
name|repairTimersIfNeeded
argument_list|()
expr_stmt|;
name|timespec
name|tm
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTimerInfo
modifier|*
name|t
init|=
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|id
operator|==
name|timerId
condition|)
block|{
if|if
condition|(
name|currentTime
operator|<
name|t
operator|->
name|timeout
condition|)
block|{
comment|// time to wait
name|tm
operator|=
name|roundToMillisecond
argument_list|(
name|t
operator|->
name|timeout
operator|-
name|currentTime
argument_list|)
expr_stmt|;
return|return
name|tm
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|tm
operator|.
name|tv_nsec
operator|/
literal|1000
operator|/
literal|1000
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|qWarning
argument_list|(
literal|"QTimerInfoList::timerRemainingTime: timer id %i not found"
argument_list|,
name|timerId
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|registerTimer
name|void
name|QTimerInfoList
operator|::
name|registerTimer
parameter_list|(
name|int
name|timerId
parameter_list|,
name|int
name|interval
parameter_list|,
name|Qt
operator|::
name|TimerType
name|timerType
parameter_list|,
name|QObject
modifier|*
name|object
parameter_list|)
block|{
name|QTimerInfo
modifier|*
name|t
init|=
operator|new
name|QTimerInfo
decl_stmt|;
name|t
operator|->
name|id
operator|=
name|timerId
expr_stmt|;
name|t
operator|->
name|interval
operator|=
name|interval
expr_stmt|;
name|t
operator|->
name|timerType
operator|=
name|timerType
expr_stmt|;
name|t
operator|->
name|obj
operator|=
name|object
expr_stmt|;
name|t
operator|->
name|activateRef
operator|=
literal|0
expr_stmt|;
name|timespec
name|expected
init|=
name|updateCurrentTime
argument_list|()
operator|+
name|interval
decl_stmt|;
switch|switch
condition|(
name|timerType
condition|)
block|{
case|case
name|Qt
operator|::
name|PreciseTimer
case|:
comment|// high precision timer is based on millisecond precision
comment|// so no adjustment is necessary
name|t
operator|->
name|timeout
operator|=
name|expected
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|CoarseTimer
case|:
comment|// this timer has up to 5% coarseness
comment|// so our boundaries are 20 ms and 20 s
comment|// below 20 ms, 5% inaccuracy is below 1 ms, so we convert to high precision
comment|// above 20 s, 5% inaccuracy is above 1 s, so we convert to VeryCoarseTimer
if|if
condition|(
name|interval
operator|>=
literal|20000
condition|)
block|{
name|t
operator|->
name|timerType
operator|=
name|Qt
operator|::
name|VeryCoarseTimer
expr_stmt|;
comment|// fall through
block|}
else|else
block|{
name|t
operator|->
name|timeout
operator|=
name|expected
expr_stmt|;
if|if
condition|(
name|interval
operator|<=
literal|20
condition|)
block|{
name|t
operator|->
name|timerType
operator|=
name|Qt
operator|::
name|PreciseTimer
expr_stmt|;
comment|// no adjustment is necessary
block|}
elseif|else
if|if
condition|(
name|interval
operator|<=
literal|20000
condition|)
block|{
name|calculateCoarseTimerTimeout
argument_list|(
name|t
argument_list|,
name|currentTime
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|// fall through
case|case
name|Qt
operator|::
name|VeryCoarseTimer
case|:
comment|// the very coarse timer is based on full second precision,
comment|// so we keep the interval in seconds (round to closest second)
name|t
operator|->
name|interval
operator|/=
literal|500
expr_stmt|;
name|t
operator|->
name|interval
operator|+=
literal|1
expr_stmt|;
name|t
operator|->
name|interval
operator|>>=
literal|1
expr_stmt|;
name|t
operator|->
name|timeout
operator|.
name|tv_sec
operator|=
name|currentTime
operator|.
name|tv_sec
operator|+
name|t
operator|->
name|interval
expr_stmt|;
name|t
operator|->
name|timeout
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
comment|// if we're past the half-second mark, increase the timeout again
if|if
condition|(
name|currentTime
operator|.
name|tv_nsec
operator|>
literal|500
operator|*
literal|1000
operator|*
literal|1000
condition|)
operator|++
name|t
operator|->
name|timeout
operator|.
name|tv_sec
expr_stmt|;
block|}
name|timerInsert
argument_list|(
name|t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QTIMERINFO_DEBUG
name|t
operator|->
name|expected
operator|=
name|expected
expr_stmt|;
name|t
operator|->
name|cumulativeError
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|timerType
operator|!=
name|Qt
operator|::
name|PreciseTimer
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"timer"
operator|<<
name|t
operator|->
name|timerType
operator|<<
name|hex
operator|<<
name|t
operator|->
name|id
operator|<<
name|dec
operator|<<
literal|"interval"
operator|<<
name|t
operator|->
name|interval
operator|<<
literal|"expected at"
operator|<<
name|t
operator|->
name|expected
operator|<<
literal|"will fire first at"
operator|<<
name|t
operator|->
name|timeout
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|unregisterTimer
name|bool
name|QTimerInfoList
operator|::
name|unregisterTimer
parameter_list|(
name|int
name|timerId
parameter_list|)
block|{
comment|// set timer inactive
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTimerInfo
modifier|*
name|t
init|=
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|id
operator|==
name|timerId
condition|)
block|{
comment|// found it
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|firstTimerInfo
condition|)
name|firstTimerInfo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|activateRef
condition|)
operator|*
operator|(
name|t
operator|->
name|activateRef
operator|)
operator|=
literal|0
expr_stmt|;
operator|delete
name|t
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|// id not found
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|unregisterTimers
name|bool
name|QTimerInfoList
operator|::
name|unregisterTimers
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QTimerInfo
modifier|*
name|t
init|=
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|obj
operator|==
name|object
condition|)
block|{
comment|// object found
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|firstTimerInfo
condition|)
name|firstTimerInfo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|activateRef
condition|)
operator|*
operator|(
name|t
operator|->
name|activateRef
operator|)
operator|=
literal|0
expr_stmt|;
operator|delete
name|t
expr_stmt|;
comment|// move back one so that we don't skip the new current item
operator|--
name|i
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|registeredTimers
name|QList
argument_list|<
name|QAbstractEventDispatcher
operator|::
name|TimerInfo
argument_list|>
name|QTimerInfoList
operator|::
name|registeredTimers
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
specifier|const
block|{
name|QList
argument_list|<
name|QAbstractEventDispatcher
operator|::
name|TimerInfo
argument_list|>
name|list
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QTimerInfo
modifier|*
specifier|const
name|t
init|=
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|obj
operator|==
name|object
condition|)
block|{
name|list
operator|<<
name|QAbstractEventDispatcher
operator|::
name|TimerInfo
argument_list|(
name|t
operator|->
name|id
argument_list|,
operator|(
name|t
operator|->
name|timerType
operator|==
name|Qt
operator|::
name|VeryCoarseTimer
condition|?
name|t
operator|->
name|interval
operator|*
literal|1000
else|:
name|t
operator|->
name|interval
operator|)
argument_list|,
name|t
operator|->
name|timerType
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
end_function
begin_comment
comment|/*     Activate pending timers, returning how many where activated. */
end_comment
begin_function
DECL|function|activateTimers
name|int
name|QTimerInfoList
operator|::
name|activateTimers
parameter_list|()
block|{
if|if
condition|(
name|qt_disable_lowpriority_timers
operator|||
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// nothing to do
name|int
name|n_act
init|=
literal|0
decl_stmt|,
name|maxCount
init|=
literal|0
decl_stmt|;
name|firstTimerInfo
operator|=
literal|0
expr_stmt|;
name|timespec
name|currentTime
init|=
name|updateCurrentTime
argument_list|()
decl_stmt|;
comment|// qDebug()<< "Thread"<< QThread::currentThreadId()<< "woken up at"<< currentTime;
name|repairTimersIfNeeded
argument_list|()
expr_stmt|;
comment|// Find out how many timer have expired
for|for
control|(
name|QTimerInfoList
operator|::
name|const_iterator
name|it
init|=
name|constBegin
argument_list|()
init|;
name|it
operator|!=
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|currentTime
operator|<
operator|(
operator|*
name|it
operator|)
operator|->
name|timeout
condition|)
break|break;
name|maxCount
operator|++
expr_stmt|;
block|}
comment|//fire the timers.
while|while
condition|(
name|maxCount
operator|--
condition|)
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
break|break;
name|QTimerInfo
modifier|*
name|currentTimerInfo
init|=
name|first
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentTime
operator|<
name|currentTimerInfo
operator|->
name|timeout
condition|)
break|break;
comment|// no timer has expired
if|if
condition|(
operator|!
name|firstTimerInfo
condition|)
block|{
name|firstTimerInfo
operator|=
name|currentTimerInfo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|firstTimerInfo
operator|==
name|currentTimerInfo
condition|)
block|{
comment|// avoid sending the same timer multiple times
break|break;
block|}
elseif|else
if|if
condition|(
name|currentTimerInfo
operator|->
name|interval
operator|<
name|firstTimerInfo
operator|->
name|interval
operator|||
name|currentTimerInfo
operator|->
name|interval
operator|==
name|firstTimerInfo
operator|->
name|interval
condition|)
block|{
name|firstTimerInfo
operator|=
name|currentTimerInfo
expr_stmt|;
block|}
comment|// remove from list
name|removeFirst
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QTIMERINFO_DEBUG
name|float
name|diff
decl_stmt|;
if|if
condition|(
name|currentTime
operator|<
name|currentTimerInfo
operator|->
name|expected
condition|)
block|{
comment|// early
name|timeval
name|early
init|=
name|currentTimerInfo
operator|->
name|expected
operator|-
name|currentTime
decl_stmt|;
name|diff
operator|=
operator|-
operator|(
name|early
operator|.
name|tv_sec
operator|+
name|early
operator|.
name|tv_usec
operator|/
literal|1000000.0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|timeval
name|late
init|=
name|currentTime
operator|-
name|currentTimerInfo
operator|->
name|expected
decl_stmt|;
name|diff
operator|=
name|late
operator|.
name|tv_sec
operator|+
name|late
operator|.
name|tv_usec
operator|/
literal|1000000.0
expr_stmt|;
block|}
name|currentTimerInfo
operator|->
name|cumulativeError
operator|+=
name|diff
expr_stmt|;
operator|++
name|currentTimerInfo
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|currentTimerInfo
operator|->
name|timerType
operator|!=
name|Qt
operator|::
name|PreciseTimer
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"timer"
operator|<<
name|currentTimerInfo
operator|->
name|timerType
operator|<<
name|hex
operator|<<
name|currentTimerInfo
operator|->
name|id
operator|<<
name|dec
operator|<<
literal|"interval"
operator|<<
name|currentTimerInfo
operator|->
name|interval
operator|<<
literal|"firing at"
operator|<<
name|currentTime
operator|<<
literal|"(orig"
operator|<<
name|currentTimerInfo
operator|->
name|expected
operator|<<
literal|"scheduled at"
operator|<<
name|currentTimerInfo
operator|->
name|timeout
operator|<<
literal|") off by"
operator|<<
name|diff
operator|<<
literal|"activation"
operator|<<
name|currentTimerInfo
operator|->
name|count
operator|<<
literal|"avg error"
operator|<<
operator|(
name|currentTimerInfo
operator|->
name|cumulativeError
operator|/
name|currentTimerInfo
operator|->
name|count
operator|)
expr_stmt|;
endif|#
directive|endif
comment|// determine next timeout time
name|calculateNextTimeout
argument_list|(
name|currentTimerInfo
argument_list|,
name|currentTime
argument_list|)
expr_stmt|;
comment|// reinsert timer
name|timerInsert
argument_list|(
name|currentTimerInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentTimerInfo
operator|->
name|interval
operator|>
literal|0
condition|)
name|n_act
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|currentTimerInfo
operator|->
name|activateRef
condition|)
block|{
comment|// send event, but don't allow it to recurse
name|currentTimerInfo
operator|->
name|activateRef
operator|=
operator|&
name|currentTimerInfo
expr_stmt|;
name|QTimerEvent
name|e
argument_list|(
name|currentTimerInfo
operator|->
name|id
argument_list|)
decl_stmt|;
name|QCoreApplication
operator|::
name|sendEvent
argument_list|(
name|currentTimerInfo
operator|->
name|obj
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentTimerInfo
condition|)
name|currentTimerInfo
operator|->
name|activateRef
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|firstTimerInfo
operator|=
literal|0
expr_stmt|;
comment|// qDebug()<< "Thread"<< QThread::currentThreadId()<< "activated"<< n_act<< "timers";
return|return
name|n_act
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
