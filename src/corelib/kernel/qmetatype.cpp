begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia. For licensing terms and ** conditions see http://qt.digia.com/licensing. For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights. These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qmetatype.h"
end_include
begin_include
include|#
directive|include
file|"qmetatype_p.h"
end_include
begin_include
include|#
directive|include
file|"qobjectdefs.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qbytearray.h"
end_include
begin_include
include|#
directive|include
file|"qreadwritelock.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qvector.h"
end_include
begin_include
include|#
directive|include
file|"qlocale.h"
end_include
begin_include
include|#
directive|include
file|"qeasingcurve.h"
end_include
begin_include
include|#
directive|include
file|"quuid.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qmetatypeswitcher_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_include
include|#
directive|include
file|"qbitarray.h"
end_include
begin_include
include|#
directive|include
file|"qurl.h"
end_include
begin_include
include|#
directive|include
file|"qvariant.h"
end_include
begin_include
include|#
directive|include
file|"qabstractitemmodel.h"
end_include
begin_include
include|#
directive|include
file|"qregularexpression.h"
end_include
begin_include
include|#
directive|include
file|"qjsonvalue.h"
end_include
begin_include
include|#
directive|include
file|"qjsonobject.h"
end_include
begin_include
include|#
directive|include
file|"qjsonarray.h"
end_include
begin_include
include|#
directive|include
file|"qjsondocument.h"
end_include
begin_include
include|#
directive|include
file|"qbytearraylist.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_GEOM_VARIANT
end_ifndef
begin_include
include|#
directive|include
file|"qsize.h"
end_include
begin_include
include|#
directive|include
file|"qpoint.h"
end_include
begin_include
include|#
directive|include
file|"qrect.h"
end_include
begin_include
include|#
directive|include
file|"qline.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_define
DECL|macro|NS
define|#
directive|define
name|NS
parameter_list|(
name|x
parameter_list|)
value|QT_PREPEND_NAMESPACE(x)
end_define
begin_namespace
namespace|namespace
block|{
DECL|struct|DefinedTypesFilter
struct|struct
name|DefinedTypesFilter
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|Acceptor
name|Acceptor
block|{
DECL|member|IsAccepted
specifier|static
specifier|const
name|bool
name|IsAccepted
init|=
name|QtMetaTypePrivate
operator|::
name|TypeDefinition
argument_list|<
name|T
argument_list|>
operator|::
name|IsAvailable
operator|&&
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsCore
decl_stmt|;
block|}
struct|;
block|}
struct|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_comment
comment|/*!     \macro Q_DECLARE_OPAQUE_POINTER(PointerType)     \relates QMetaType     \since 5.0      This macro enables pointers to forward-declared types (\a PointerType)     to be registered with QMetaType using either Q_DECLARE_METATYPE()     or qRegisterMetaType().      \sa Q_DECLARE_METATYPE(), qRegisterMetaType() */
end_comment
begin_comment
comment|/*!     \macro Q_DECLARE_METATYPE(Type)     \relates QMetaType      This macro makes the type \a Type known to QMetaType as long as it     provides a public default constructor, a public copy constructor and     a public destructor.     It is needed to use the type \a Type as a custom type in QVariant.      This macro requires that \a Type is a fully defined type at the point where     it is used. For pointer types, it also requires that the pointed to type is     fully defined. Use in conjunction with Q_DECLARE_OPAQUE_POINTER() to     register pointers to forward declared types.      Ideally, this macro should be placed below the declaration of     the class or struct. If that is not possible, it can be put in     a private header file which has to be included every time that     type is used in a QVariant.      Adding a Q_DECLARE_METATYPE() makes the type known to all template     based functions, including QVariant. Note that if you intend to     use the type in \e queued signal and slot connections or in     QObject's property system, you also have to call     qRegisterMetaType() since the names are resolved at runtime.      This example shows a typical use case of Q_DECLARE_METATYPE():      \snippet code/src_corelib_kernel_qmetatype.cpp 0      If \c MyStruct is in a namespace, the Q_DECLARE_METATYPE() macro     has to be outside the namespace:      \snippet code/src_corelib_kernel_qmetatype.cpp 1      Since \c{MyStruct} is now known to QMetaType, it can be used in QVariant:      \snippet code/src_corelib_kernel_qmetatype.cpp 2      \sa qRegisterMetaType() */
end_comment
begin_comment
comment|/*!     \macro Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(Container)     \relates QMetaType      This macro makes the container \a Container known to QMetaType as a sequential     container. This makes it possible to put an instance of Container<T> into     a QVariant, if T itself is known to QMetaType.      Note that all of the Qt sequential containers already have built-in     support, and it is not necessary to use this macro with them. The     std::vector and std::list containers also have built-in support.      This example shows a typical use of Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE():      \snippet code/src_corelib_kernel_qmetatype.cpp 10 */
end_comment
begin_comment
comment|/*!     \macro Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(Container)     \relates QMetaType      This macro makes the container \a Container known to QMetaType as an associative     container. This makes it possible to put an instance of Container<T, U> into     a QVariant, if T and U are themselves known to QMetaType.      Note that all of the Qt associative containers already have built-in     support, and it is not necessary to use this macro with them. The     std::map container also has built-in support.      This example shows a typical use of Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE():      \snippet code/src_corelib_kernel_qmetatype.cpp 11 */
end_comment
begin_comment
comment|/*!     \macro Q_DECLARE_SMART_POINTER_METATYPE(SmartPointer)     \relates QMetaType      This macro makes the smart pointer \a SmartPointer known to QMetaType as a     smart pointer. This makes it possible to put an instance of SmartPointer<T> into     a QVariant, if T is a type which inherits QObject.      Note that the QWeakPointer, QSharedPointer and QPointer already have built-in     support, and it is not necessary to use this macro with them.      This example shows a typical use of Q_DECLARE_SMART_POINTER_METATYPE():      \snippet code/src_corelib_kernel_qmetatype.cpp 13 */
end_comment
begin_comment
comment|/*!     \enum QMetaType::Type      These are the built-in types supported by QMetaType:      \value Void \c void     \value Bool \c bool     \value Int \c int     \value UInt \c{unsigned int}     \value Double \c double     \value QChar QChar     \value QString QString     \value QByteArray QByteArray      \value VoidStar \c{void *}     \value Long \c{long}     \value LongLong LongLong     \value Short \c{short}     \value Char \c{char}     \value ULong \c{unsigned long}     \value ULongLong ULongLong     \value UShort \c{unsigned short}     \value SChar \c{signed char}     \value UChar \c{unsigned char}     \value Float \c float     \value QObjectStar QObject *     \value QVariant QVariant      \value QCursor QCursor     \value QDate QDate     \value QSize QSize     \value QTime QTime     \value QVariantList QVariantList     \value QPolygon QPolygon     \value QPolygonF QPolygonF     \value QColor QColor     \value QSizeF QSizeF     \value QRectF QRectF     \value QLine QLine     \value QTextLength QTextLength     \value QStringList QStringList     \value QVariantMap QVariantMap     \value QVariantHash QVariantHash     \value QIcon QIcon     \value QPen QPen     \value QLineF QLineF     \value QTextFormat QTextFormat     \value QRect QRect     \value QPoint QPoint     \value QUrl QUrl     \value QRegExp QRegExp     \value QRegularExpression QRegularExpression     \value QDateTime QDateTime     \value QPointF QPointF     \value QPalette QPalette     \value QFont QFont     \value QBrush QBrush     \value QRegion QRegion     \value QBitArray QBitArray     \value QImage QImage     \value QKeySequence QKeySequence     \value QSizePolicy QSizePolicy     \value QPixmap QPixmap     \value QLocale QLocale     \value QBitmap QBitmap     \value QMatrix QMatrix     \value QTransform QTransform     \value QMatrix4x4 QMatrix4x4     \value QVector2D QVector2D     \value QVector3D QVector3D     \value QVector4D QVector4D     \value QQuaternion QQuaternion     \value QEasingCurve QEasingCurve     \value QJsonValue QJsonValue     \value QJsonObject QJsonObject     \value QJsonArray QJsonArray     \value QJsonDocument QJsonDocument     \value QModelIndex QModelIndex     \value QUuid QUuid     \value QByteArrayList QByteArrayList      \value User  Base value for user types     \value UnknownType This is an invalid type id. It is returned from QMetaType for types that are not registered      Additional types can be registered using Q_DECLARE_METATYPE().      \sa type(), typeName() */
end_comment
begin_comment
comment|/*!     \enum QMetaType::TypeFlag      The enum describes attributes of a type supported by QMetaType.      \value NeedsConstruction This type has non-trivial constructors. If the flag is not set instances can be safely initialized with memset to 0.     \value NeedsDestruction This type has a non-trivial destructor. If the flag is not set calls to the destructor are not necessary before discarding objects.     \value MovableType An instance of a type having this attribute can be safely moved by memcpy.     \omitvalue SharedPointerToQObject     \omitvalue IsEnumeration     \omitvalue PointerToQObject     \omitvalue WeakPointerToQObject     \omitvalue TrackingPointerToQObject     \omitvalue WasDeclaredAsMetaType */
end_comment
begin_comment
comment|/*!     \class QMetaType     \inmodule QtCore     \brief The QMetaType class manages named types in the meta-object system.      \ingroup objectmodel     \threadsafe      The class is used as a helper to marshall types in QVariant and     in queued signals and slots connections. It associates a type     name to a type so that it can be created and destructed     dynamically at run-time. Declare new types with Q_DECLARE_METATYPE()     to make them available to QVariant and other template-based functions.     Call qRegisterMetaType() to make types available to non-template based     functions, such as the queued signal and slot connections.      Any class or struct that has a public default     constructor, a public copy constructor, and a public destructor     can be registered.      The following code allocates and destructs an instance of     \c{MyClass}:      \snippet code/src_corelib_kernel_qmetatype.cpp 3      If we want the stream operators \c operator<<() and \c     operator>>() to work on QVariant objects that store custom types,     the custom type must provide \c operator<<() and \c operator>>()     operators.      \sa Q_DECLARE_METATYPE(), QVariant::setValue(), QVariant::value(), QVariant::fromValue() */
end_comment
begin_comment
comment|/*!     \fn bool QMetaType::isValid() const     \since 5.0      Returns \c true if this QMetaType object contains valid     information about a type, false otherwise. */
end_comment
begin_comment
comment|/*!     \fn bool QMetaType::isRegistered() const     \since 5.0      Returns \c true if this QMetaType object contains valid     information about a type, false otherwise. */
end_comment
begin_comment
comment|/*!     \fn bool QMetaType::sizeOf() const     \since 5.0      Returns the size of the type in bytes (i.e. sizeof(T),     where T is the actual type for which this QMetaType instance     was constructed for).      This function is typically used together with construct()     to perform low-level management of the memory used by a type.      \sa QMetaType::construct(), QMetaType::sizeOf() */
end_comment
begin_comment
comment|/*!     \fn TypeFlags QMetaType::flags() const     \since 5.0      Returns flags of the type for which this QMetaType instance was constructed.      \sa QMetaType::TypeFlags, QMetaType::typeFlags() */
end_comment
begin_comment
comment|/*!     \fn const QMetaObject *QMetaType::metaObject() const     \since 5.0     \internal */
end_comment
begin_comment
comment|/*!     \fn void *QMetaType::create(const void *copy = 0) const     \since 5.0      Returns a copy of \a copy, assuming it is of the type that this     QMetaType instance was created for. If \a copy is null, creates     a default constructed instance.      \sa QMetaType::destroy() */
end_comment
begin_comment
comment|/*!     \fn void QMetaType::destroy(void *data) const     \since 5.0      Destroys the \a data, assuming it is of the type that this     QMetaType instance was created for.      \sa QMetaType::create() */
end_comment
begin_comment
comment|/*!     \fn void *QMetaType::construct(void *where, const void *copy = 0) const     \since 5.0      Constructs a value of the type that this QMetaType instance     was constructed for in the existing memory addressed by \a where,     that is a copy of \a copy, and returns \a where. If \a copy is     zero, the value is default constructed.      This is a low-level function for explicitly managing the memory     used to store the type. Consider calling create() if you don't     need this level of control (that is, use "new" rather than     "placement new").      You must ensure that \a where points to a location where the new     value can be stored and that \a where is suitably aligned.     The type's size can be queried by calling sizeOf().      The rule of thumb for alignment is that a type is aligned to its     natural boundary, which is the smallest power of 2 that is bigger     than the type, unless that alignment is larger than the maximum     useful alignment for the platform. For practical purposes,     alignment larger than 2 * sizeof(void*) is only necessary for     special hardware instructions (e.g., aligned SSE loads and stores     on x86). */
end_comment
begin_comment
comment|/*!     \fn void QMetaType::destruct(void *data) const     \since 5.0      Destructs the value, located at \a data, assuming that it is     of the type for which this QMetaType instance was constructed for.      Unlike destroy(), this function only invokes the type's     destructor, it doesn't invoke the delete operator.     \sa QMetaType::construct() */
end_comment
begin_comment
comment|/*!     \fn QMetaType::~QMetaType()      Destructs this object. */
end_comment
begin_define
DECL|macro|QT_ADD_STATIC_METATYPE
define|#
directive|define
name|QT_ADD_STATIC_METATYPE
parameter_list|(
name|MetaTypeName
parameter_list|,
name|MetaTypeId
parameter_list|,
name|RealName
parameter_list|)
define|\
value|{ #RealName, sizeof(#RealName) - 1, MetaTypeId },
end_define
begin_define
DECL|macro|QT_ADD_STATIC_METATYPE_ALIASES_ITER
define|#
directive|define
name|QT_ADD_STATIC_METATYPE_ALIASES_ITER
parameter_list|(
name|MetaTypeName
parameter_list|,
name|MetaTypeId
parameter_list|,
name|AliasingName
parameter_list|,
name|RealNameStr
parameter_list|)
define|\
value|{ RealNameStr, sizeof(RealNameStr) - 1, QMetaType::MetaTypeName },
end_define
begin_define
DECL|macro|QT_ADD_STATIC_METATYPE_HACKS_ITER
define|#
directive|define
name|QT_ADD_STATIC_METATYPE_HACKS_ITER
parameter_list|(
name|MetaTypeName
parameter_list|,
name|TypeId
parameter_list|,
name|Name
parameter_list|)
define|\
value|QT_ADD_STATIC_METATYPE(MetaTypeName, MetaTypeName, Name)
end_define
begin_struct
DECL|member|typeName
DECL|member|typeNameLength
DECL|member|type
DECL|variable|types
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|typeName
decl_stmt|;
name|int
name|typeNameLength
decl_stmt|;
name|int
name|type
decl_stmt|;
block|}
name|types
index|[]
init|=
block|{
name|QT_FOR_EACH_STATIC_TYPE
argument_list|(
argument|QT_ADD_STATIC_METATYPE
argument_list|)
name|QT_FOR_EACH_STATIC_ALIAS_TYPE
argument_list|(
argument|QT_ADD_STATIC_METATYPE_ALIASES_ITER
argument_list|)
name|QT_FOR_EACH_STATIC_HACKS_TYPE
argument_list|(
argument|QT_ADD_STATIC_METATYPE_HACKS_ITER
argument_list|)
block|{
literal|0
block|,
literal|0
block|,
name|QMetaType
operator|::
name|UnknownType
block|}
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|qMetaTypeGuiHelper
name|Q_CORE_EXPORT
specifier|const
name|QMetaTypeInterface
modifier|*
name|qMetaTypeGuiHelper
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qMetaTypeWidgetsHelper
name|Q_CORE_EXPORT
specifier|const
name|QMetaTypeInterface
modifier|*
name|qMetaTypeWidgetsHelper
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qMetaObjectWidgetsHelper
name|Q_CORE_EXPORT
specifier|const
name|QMetaObject
modifier|*
name|qMetaObjectWidgetsHelper
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_class
DECL|class|QCustomTypeInfo
class|class
name|QCustomTypeInfo
super|:
specifier|public
name|QMetaTypeInterface
block|{
public|public:
DECL|function|QCustomTypeInfo
name|QCustomTypeInfo
parameter_list|()
member_init_list|:
name|alias
argument_list|(
operator|-
literal|1
argument_list|)
block|{
name|QMetaTypeInterface
name|empty
init|=
name|QT_METATYPE_INTERFACE_INIT
argument_list|(
name|void
argument_list|)
decl_stmt|;
operator|*
cast|static_cast
argument_list|<
name|QMetaTypeInterface
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|=
name|empty
expr_stmt|;
block|}
DECL|member|typeName
name|QByteArray
name|typeName
decl_stmt|;
DECL|member|alias
name|int
name|alias
decl_stmt|;
block|}
class|;
end_class
begin_class
template|template
parameter_list|<
name|typename
name|T
parameter_list|,
name|typename
name|Key
parameter_list|>
class|class
DECL|class|QMetaTypeFunctionRegistry
name|QMetaTypeFunctionRegistry
block|{
public|public:
DECL|function|~QMetaTypeFunctionRegistry
name|~
name|QMetaTypeFunctionRegistry
parameter_list|()
block|{
specifier|const
name|QWriteLocker
name|locker
argument_list|(
operator|&
name|lock
argument_list|)
decl_stmt|;
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|function|contains
name|bool
name|contains
parameter_list|(
name|Key
name|k
parameter_list|)
specifier|const
block|{
specifier|const
name|QReadLocker
name|locker
argument_list|(
operator|&
name|lock
argument_list|)
decl_stmt|;
return|return
name|map
operator|.
name|contains
argument_list|(
name|k
argument_list|)
return|;
block|}
DECL|function|insertIfNotContains
name|bool
name|insertIfNotContains
parameter_list|(
name|Key
name|k
parameter_list|,
specifier|const
name|T
modifier|*
name|f
parameter_list|)
block|{
specifier|const
name|QWriteLocker
name|locker
argument_list|(
operator|&
name|lock
argument_list|)
decl_stmt|;
specifier|const
name|T
modifier|*
modifier|&
name|fun
init|=
name|map
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
name|fun
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
name|fun
operator|=
name|f
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|function|function
specifier|const
name|T
modifier|*
name|function
parameter_list|(
name|Key
name|k
parameter_list|)
specifier|const
block|{
specifier|const
name|QReadLocker
name|locker
argument_list|(
operator|&
name|lock
argument_list|)
decl_stmt|;
return|return
name|map
operator|.
name|value
argument_list|(
name|k
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|function|remove
name|void
name|remove
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
specifier|const
name|Key
name|k
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
decl_stmt|;
specifier|const
name|QWriteLocker
name|locker
argument_list|(
operator|&
name|lock
argument_list|)
decl_stmt|;
name|map
operator|.
name|remove
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
private|private:
DECL|member|lock
specifier|mutable
name|QReadWriteLock
name|lock
decl_stmt|;
DECL|member|map
name|QHash
argument_list|<
name|Key
argument_list|,
specifier|const
name|T
modifier|*
argument_list|>
name|map
decl_stmt|;
block|}
class|;
end_class
begin_typedef
typedef|typedef
name|QMetaTypeFunctionRegistry
argument_list|<
name|QtPrivate
operator|::
name|AbstractConverterFunction
argument_list|,
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|>
DECL|typedef|QMetaTypeConverterRegistry
name|QMetaTypeConverterRegistry
typedef|;
end_typedef
begin_typedef
typedef|typedef
name|QMetaTypeFunctionRegistry
argument_list|<
name|QtPrivate
operator|::
name|AbstractComparatorFunction
argument_list|,
name|int
argument_list|>
DECL|typedef|QMetaTypeComparatorRegistry
name|QMetaTypeComparatorRegistry
typedef|;
end_typedef
begin_typedef
typedef|typedef
name|QMetaTypeFunctionRegistry
argument_list|<
name|QtPrivate
operator|::
name|AbstractDebugStreamFunction
argument_list|,
name|int
argument_list|>
DECL|typedef|QMetaTypeDebugStreamRegistry
name|QMetaTypeDebugStreamRegistry
typedef|;
end_typedef
begin_namespace
namespace|namespace
block|{
DECL|union|CheckThatItIsPod
union|union
name|CheckThatItIsPod
block|{
comment|// This should break if QMetaTypeInterface is not a POD type
DECL|member|iface
name|QMetaTypeInterface
name|iface
decl_stmt|;
block|}
union|;
block|}
end_namespace
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|QCustomTypeInfo
argument_list|,
name|Q_MOVABLE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QVector<QCustomTypeInfo>
argument_list|,
argument|customTypes
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QReadWriteLock
argument_list|,
argument|customTypesLock
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QMetaTypeConverterRegistry
argument_list|,
argument|customTypesConversionRegistry
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QMetaTypeComparatorRegistry
argument_list|,
argument|customTypesComparatorRegistry
argument_list|)
end_macro
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QMetaTypeDebugStreamRegistry
argument_list|,
argument|customTypesDebugStreamRegistry
argument_list|)
end_macro
begin_comment
comment|/*!     \fn bool QMetaType::registerConverter()     \since 5.2     Registers the possibility of an implicit conversion from type From to type To in the meta     type system. Returns \c true if the registration succeeded, otherwise false. */
end_comment
begin_comment
comment|/*!     \fn bool QMetaType::registerConverter(MemberFunction function)     \since 5.2     \overload     Registers a method \a function like To From::function() const as converter from type From     to type To in the meta type system. Returns \c true if the registration succeeded, otherwise false. */
end_comment
begin_comment
comment|/*!     \fn bool QMetaType::registerConverter(MemberFunctionOk function)     \since 5.2     \overload     Registers a method \a function like To From::function(bool *ok) const as converter from type From     to type To in the meta type system. Returns \c true if the registration succeeded, otherwise false. */
end_comment
begin_comment
comment|/*!     \fn bool QMetaType::registerConverter(UnaryFunction function)     \since 5.2     \overload     Registers a unary function object \a function as converter from type From     to type To in the meta type system. Returns \c true if the registration succeeded, otherwise false. */
end_comment
begin_comment
comment|/*!     \fn bool QMetaType::registerComparators()     \since 5.2     Registers comparison operetarors for the user-registered type T. This requires T to have     both an operator== and an operator<.     Returns \c true if the registration succeeded, otherwise false. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_comment
comment|/*!     \fn bool QMetaType::registerDebugStreamOperator()     Registers the debug stream operator for the user-registered type T. This requires T to have     an operator<<(QDebug dbg, T).     Returns \c true if the registration succeeded, otherwise false. */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Registers function \a f as converter function from type id \a from to \a to.     If there's already a conversion registered, this does nothing but deleting \a f.     Returns \c true if the registration succeeded, otherwise false.     \since 5.2     \internal */
end_comment
begin_function
DECL|function|registerConverterFunction
name|bool
name|QMetaType
operator|::
name|registerConverterFunction
parameter_list|(
specifier|const
name|QtPrivate
operator|::
name|AbstractConverterFunction
modifier|*
name|f
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
if|if
condition|(
operator|!
name|customTypesConversionRegistry
argument_list|()
operator|->
name|insertIfNotContains
argument_list|(
name|qMakePair
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Type conversion already registered from type %s to type %s"
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|from
argument_list|)
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Invoked automatically when a converter function object is destroyed.  */
end_comment
begin_function
DECL|function|unregisterConverterFunction
name|void
name|QMetaType
operator|::
name|unregisterConverterFunction
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
if|if
condition|(
name|customTypesConversionRegistry
operator|.
name|isDestroyed
argument_list|()
condition|)
return|return;
name|customTypesConversionRegistry
argument_list|()
operator|->
name|remove
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|registerComparatorFunction
name|bool
name|QMetaType
operator|::
name|registerComparatorFunction
parameter_list|(
specifier|const
name|QtPrivate
operator|::
name|AbstractComparatorFunction
modifier|*
name|f
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|customTypesComparatorRegistry
argument_list|()
operator|->
name|insertIfNotContains
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Comparators already registered for type %s"
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QMetaType::hasRegisteredComparators()     Returns \c true, if the meta type system has registered comparators for type T.     \since 5.2  */
end_comment
begin_comment
comment|/*!     Returns \c true, if the meta type system has registered comparators for type id \a typeId.     \since 5.2  */
end_comment
begin_function
DECL|function|hasRegisteredComparators
name|bool
name|QMetaType
operator|::
name|hasRegisteredComparators
parameter_list|(
name|int
name|typeId
parameter_list|)
block|{
return|return
name|customTypesComparatorRegistry
argument_list|()
operator|->
name|contains
argument_list|(
name|typeId
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|registerDebugStreamOperatorFunction
name|bool
name|QMetaType
operator|::
name|registerDebugStreamOperatorFunction
parameter_list|(
specifier|const
name|QtPrivate
operator|::
name|AbstractDebugStreamFunction
modifier|*
name|f
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|customTypesDebugStreamRegistry
argument_list|()
operator|->
name|insertIfNotContains
argument_list|(
name|type
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Debug stream operator already registered for type %s"
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QMetaType::hasRegisteredDebugStreamOperator()     Returns \c true, if the meta type system has a registered debug stream operator for type T.     \since 5.2  */
end_comment
begin_comment
comment|/*!     Returns \c true, if the meta type system has a registered debug stream operator for type     id \a typeId.     \since 5.2 */
end_comment
begin_function
DECL|function|hasRegisteredDebugStreamOperator
name|bool
name|QMetaType
operator|::
name|hasRegisteredDebugStreamOperator
parameter_list|(
name|int
name|typeId
parameter_list|)
block|{
return|return
name|customTypesDebugStreamRegistry
argument_list|()
operator|->
name|contains
argument_list|(
name|typeId
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Converts the object at \a from from \a fromTypeId to the preallocated space at \a to     typed \a toTypeId. Returns \c true, if the conversion succeeded, otherwise false.     \since 5.2 */
end_comment
begin_function
DECL|function|convert
name|bool
name|QMetaType
operator|::
name|convert
parameter_list|(
specifier|const
name|void
modifier|*
name|from
parameter_list|,
name|int
name|fromTypeId
parameter_list|,
name|void
modifier|*
name|to
parameter_list|,
name|int
name|toTypeId
parameter_list|)
block|{
specifier|const
name|QtPrivate
operator|::
name|AbstractConverterFunction
modifier|*
specifier|const
name|f
init|=
name|customTypesConversionRegistry
argument_list|()
operator|->
name|function
argument_list|(
name|qMakePair
argument_list|(
name|fromTypeId
argument_list|,
name|toTypeId
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|f
operator|&&
name|f
operator|->
name|convert
argument_list|(
name|f
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Compares the objects at \a lhs and \a rhs. Both objects need to be of type \a typeId.     \a result is set to less than, equal to or greater than zero, if \a lhs is less than, equal to     or greater than \a rhs. Returns \c true, if the comparison succeeded, otherwiess false.     \since 5.2 */
end_comment
begin_function
DECL|function|compare
name|bool
name|QMetaType
operator|::
name|compare
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|,
name|int
name|typeId
parameter_list|,
name|int
modifier|*
name|result
parameter_list|)
block|{
specifier|const
name|QtPrivate
operator|::
name|AbstractComparatorFunction
modifier|*
specifier|const
name|f
init|=
name|customTypesComparatorRegistry
argument_list|()
operator|->
name|function
argument_list|(
name|typeId
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|f
operator|->
name|equals
argument_list|(
name|f
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
operator|*
name|result
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|result
operator|=
name|f
operator|->
name|lessThan
argument_list|(
name|f
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Streams the object at \a rhs of type \a typeId to the debug stream \a dbg. Returns \c true     on success, otherwise false.     \since 5.2 */
end_comment
begin_function
DECL|function|debugStream
name|bool
name|QMetaType
operator|::
name|debugStream
parameter_list|(
name|QDebug
modifier|&
name|dbg
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|,
name|int
name|typeId
parameter_list|)
block|{
specifier|const
name|QtPrivate
operator|::
name|AbstractDebugStreamFunction
modifier|*
specifier|const
name|f
init|=
name|customTypesDebugStreamRegistry
argument_list|()
operator|->
name|function
argument_list|(
name|typeId
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return
literal|false
return|;
name|f
operator|->
name|stream
argument_list|(
name|f
argument_list|,
name|dbg
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QMetaType::hasRegisteredConverterFunction()     Returns \c true, if the meta type system has a registered conversion from type From to type To.     \since 5.2     \overload     */
end_comment
begin_comment
comment|/*!     Returns \c true, if the meta type system has a registered conversion from meta type id \a fromTypeId     to \a toTypeId     \since 5.2 */
end_comment
begin_function
DECL|function|hasRegisteredConverterFunction
name|bool
name|QMetaType
operator|::
name|hasRegisteredConverterFunction
parameter_list|(
name|int
name|fromTypeId
parameter_list|,
name|int
name|toTypeId
parameter_list|)
block|{
return|return
name|customTypesConversionRegistry
argument_list|()
operator|->
name|contains
argument_list|(
name|qMakePair
argument_list|(
name|fromTypeId
argument_list|,
name|toTypeId
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|registerStreamOperators
name|void
name|QMetaType
operator|::
name|registerStreamOperators
parameter_list|(
specifier|const
name|char
modifier|*
name|typeName
parameter_list|,
name|SaveOperator
name|saveOp
parameter_list|,
name|LoadOperator
name|loadOp
parameter_list|)
block|{
name|registerStreamOperators
argument_list|(
name|type
argument_list|(
name|typeName
argument_list|)
argument_list|,
name|saveOp
argument_list|,
name|loadOp
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|registerStreamOperators
name|void
name|QMetaType
operator|::
name|registerStreamOperators
parameter_list|(
name|int
name|idx
parameter_list|,
name|SaveOperator
name|saveOp
parameter_list|,
name|LoadOperator
name|loadOp
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|<
name|User
condition|)
return|return;
comment|//builtin types should not be registered;
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ct
condition|)
return|return;
name|QWriteLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
name|QCustomTypeInfo
modifier|&
name|inf
init|=
operator|(
operator|*
name|ct
operator|)
index|[
name|idx
operator|-
name|User
index|]
decl_stmt|;
name|inf
operator|.
name|saveOp
operator|=
name|saveOp
expr_stmt|;
name|inf
operator|.
name|loadOp
operator|=
name|loadOp
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*!     Returns the type name associated with the given \a typeId, or 0 if no     matching type was found. The returned pointer must not be deleted.      \sa type(), isRegistered(), Type */
end_comment
begin_function
DECL|function|typeName
specifier|const
name|char
modifier|*
name|QMetaType
operator|::
name|typeName
parameter_list|(
name|int
name|typeId
parameter_list|)
block|{
specifier|const
name|uint
name|type
init|=
name|typeId
decl_stmt|;
comment|// In theory it can be filled during compilation time, but for some reason template code
comment|// that is able to do it causes GCC 4.6 to generate additional 3K of executable code. Probably
comment|// it is not worth of it.
specifier|static
specifier|const
name|char
modifier|*
name|namesCache
index|[
name|QMetaType
operator|::
name|HighestInternalId
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|type
operator|<=
name|QMetaType
operator|::
name|HighestInternalId
operator|&&
operator|(
operator|(
name|result
operator|=
name|namesCache
index|[
name|type
index|]
operator|)
operator|)
condition|)
return|return
name|result
return|;
DECL|macro|QT_METATYPE_TYPEID_TYPENAME_CONVERTER
define|#
directive|define
name|QT_METATYPE_TYPEID_TYPENAME_CONVERTER
parameter_list|(
name|MetaTypeName
parameter_list|,
name|TypeId
parameter_list|,
name|RealName
parameter_list|)
define|\
value|case QMetaType::MetaTypeName: result = #RealName; break;
switch|switch
condition|(
name|QMetaType
operator|::
name|Type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|QT_FOR_EACH_STATIC_TYPE
argument_list|(
argument|QT_METATYPE_TYPEID_TYPENAME_CONVERTER
argument_list|)
default|default:
block|{
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|type
operator|<
name|QMetaType
operator|::
name|User
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
comment|// It can happen when someone cast int to QVariant::Type, we should not crash...
block|}
else|else
block|{
specifier|const
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
specifier|const
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
name|QReadLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|ct
operator|&&
name|uint
argument_list|(
name|ct
operator|->
name|count
argument_list|()
argument_list|)
operator|>
name|type
operator|-
name|QMetaType
operator|::
name|User
operator|&&
operator|!
name|ct
operator|->
name|at
argument_list|(
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
operator|.
name|typeName
operator|.
name|isEmpty
argument_list|()
condition|?
name|ct
operator|->
name|at
argument_list|(
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
operator|.
name|typeName
operator|.
name|constData
argument_list|()
else|:
literal|0
return|;
block|}
block|}
block|}
DECL|macro|QT_METATYPE_TYPEID_TYPENAME_CONVERTER
undef|#
directive|undef
name|QT_METATYPE_TYPEID_TYPENAME_CONVERTER
name|Q_ASSERT
argument_list|(
name|type
operator|<=
name|QMetaType
operator|::
name|HighestInternalId
argument_list|)
expr_stmt|;
name|namesCache
index|[
name|type
index|]
operator|=
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Similar to QMetaType::type(), but only looks in the static set of types. */
end_comment
begin_function
DECL|function|qMetaTypeStaticType
specifier|static
specifier|inline
name|int
name|qMetaTypeStaticType
parameter_list|(
specifier|const
name|char
modifier|*
name|typeName
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|types
index|[
name|i
index|]
operator|.
name|typeName
operator|&&
operator|(
operator|(
name|length
operator|!=
name|types
index|[
name|i
index|]
operator|.
name|typeNameLength
operator|)
operator|||
name|memcmp
argument_list|(
name|typeName
argument_list|,
name|types
index|[
name|i
index|]
operator|.
name|typeName
argument_list|,
name|length
argument_list|)
operator|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
block|}
return|return
name|types
index|[
name|i
index|]
operator|.
name|type
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Similar to QMetaType::type(), but only looks in the custom set of     types, and doesn't lock the mutex. */
end_comment
begin_function
DECL|function|qMetaTypeCustomType_unlocked
specifier|static
name|int
name|qMetaTypeCustomType_unlocked
parameter_list|(
specifier|const
name|char
modifier|*
name|typeName
parameter_list|,
name|int
name|length
parameter_list|)
block|{
specifier|const
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
specifier|const
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ct
condition|)
return|return
name|QMetaType
operator|::
name|UnknownType
return|;
for|for
control|(
name|int
name|v
init|=
literal|0
init|;
name|v
operator|<
name|ct
operator|->
name|count
argument_list|()
condition|;
operator|++
name|v
control|)
block|{
specifier|const
name|QCustomTypeInfo
modifier|&
name|customInfo
init|=
name|ct
operator|->
name|at
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|length
operator|==
name|customInfo
operator|.
name|typeName
operator|.
name|size
argument_list|()
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|typeName
argument_list|,
name|customInfo
operator|.
name|typeName
operator|.
name|constData
argument_list|()
argument_list|,
name|length
argument_list|)
condition|)
block|{
if|if
condition|(
name|customInfo
operator|.
name|alias
operator|>=
literal|0
condition|)
return|return
name|customInfo
operator|.
name|alias
return|;
return|return
name|v
operator|+
name|QMetaType
operator|::
name|User
return|;
block|}
block|}
return|return
name|QMetaType
operator|::
name|UnknownType
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      This function is needed until existing code outside of qtbase     has been changed to call the new version of registerType().  */
end_comment
begin_function
DECL|function|registerType
name|int
name|QMetaType
operator|::
name|registerType
parameter_list|(
specifier|const
name|char
modifier|*
name|typeName
parameter_list|,
name|Deleter
name|deleter
parameter_list|,
name|Creator
name|creator
parameter_list|)
block|{
return|return
name|registerType
argument_list|(
name|typeName
argument_list|,
name|deleter
argument_list|,
name|creator
argument_list|,
name|QtMetaTypePrivate
operator|::
name|QMetaTypeFunctionHelper
argument_list|<
name|void
argument_list|>
operator|::
name|Destruct
argument_list|,
name|QtMetaTypePrivate
operator|::
name|QMetaTypeFunctionHelper
argument_list|<
name|void
argument_list|>
operator|::
name|Construct
argument_list|,
literal|0
argument_list|,
name|TypeFlags
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 5.0      Registers a user type for marshalling, with \a typeName, a \a     deleter, a \a creator, a \a destructor, a \a constructor, and     a \a size. Returns the type's handle, or -1 if the type could     not be registered.  */
end_comment
begin_function
DECL|function|registerType
name|int
name|QMetaType
operator|::
name|registerType
parameter_list|(
specifier|const
name|char
modifier|*
name|typeName
parameter_list|,
name|Deleter
name|deleter
parameter_list|,
name|Creator
name|creator
parameter_list|,
name|Destructor
name|destructor
parameter_list|,
name|Constructor
name|constructor
parameter_list|,
name|int
name|size
parameter_list|,
name|TypeFlags
name|flags
parameter_list|,
specifier|const
name|QMetaObject
modifier|*
name|metaObject
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
name|NS
argument_list|(
argument|QByteArray
argument_list|)
name|normalizedTypeName
operator|=
name|typeName
expr_stmt|;
else|#
directive|else
name|NS
argument_list|(
argument|QByteArray
argument_list|)
name|normalizedTypeName
operator|=
name|QMetaObject
operator|::
name|normalizedType
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|registerNormalizedType
argument_list|(
name|normalizedTypeName
argument_list|,
name|deleter
argument_list|,
name|creator
argument_list|,
name|destructor
argument_list|,
name|constructor
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
name|metaObject
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \since 5.0      Registers a user type for marshalling, with \a normalizedTypeName, a \a     deleter, a \a creator, a \a destructor, a \a constructor, and     a \a size. Returns the type's handle, or -1 if the type could     not be registered.  Note that normalizedTypeName is not checked for     conformance with Qt's normalized format, so it must already     conform.  */
end_comment
begin_decl_stmt
DECL|variable|deleter
name|int
name|QMetaType
operator|::
name|registerNormalizedType
argument_list|(
specifier|const
name|NS
argument_list|(
name|QByteArray
argument_list|)
operator|&
name|normalizedTypeName
argument_list|,
name|Deleter
name|deleter
argument_list|,
DECL|variable|creator
name|Creator
name|creator
argument_list|,
DECL|variable|destructor
name|Destructor
name|destructor
argument_list|,
DECL|variable|constructor
name|Constructor
name|constructor
argument_list|,
DECL|variable|size
DECL|variable|flags
name|int
name|size
argument_list|,
name|TypeFlags
name|flags
argument_list|,
specifier|const
name|QMetaObject
operator|*
name|metaObject
argument_list|)
argument_list|{
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
operator|*
name|ct
operator|=
name|customTypes
argument_list|()
argument_list|;     if
operator|(
operator|!
name|ct
operator|||
name|normalizedTypeName
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|deleter
operator|||
operator|!
name|creator
operator|||
operator|!
name|destructor
operator|||
operator|!
name|constructor
operator|)
return|return
operator|-
literal|1
return|;
end_decl_stmt
begin_decl_stmt
name|int
name|idx
init|=
name|qMetaTypeStaticType
argument_list|(
name|normalizedTypeName
operator|.
name|constData
argument_list|()
argument_list|,
name|normalizedTypeName
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|previousSize
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|int
name|previousFlags
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|idx
operator|==
name|UnknownType
condition|)
block|{
name|QWriteLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
name|idx
operator|=
name|qMetaTypeCustomType_unlocked
argument_list|(
name|normalizedTypeName
operator|.
name|constData
argument_list|()
argument_list|,
name|normalizedTypeName
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|UnknownType
condition|)
block|{
name|QCustomTypeInfo
name|inf
decl_stmt|;
name|inf
operator|.
name|typeName
operator|=
name|normalizedTypeName
expr_stmt|;
name|inf
operator|.
name|creator
operator|=
name|creator
expr_stmt|;
name|inf
operator|.
name|deleter
operator|=
name|deleter
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
name|inf
operator|.
name|loadOp
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|saveOp
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|inf
operator|.
name|alias
operator|=
operator|-
literal|1
expr_stmt|;
name|inf
operator|.
name|constructor
operator|=
name|constructor
expr_stmt|;
name|inf
operator|.
name|destructor
operator|=
name|destructor
expr_stmt|;
name|inf
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|inf
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|inf
operator|.
name|metaObject
operator|=
name|metaObject
expr_stmt|;
name|idx
operator|=
name|ct
operator|->
name|size
argument_list|()
operator|+
name|User
expr_stmt|;
name|ct
operator|->
name|append
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|idx
return|;
block|}
if|if
condition|(
name|idx
operator|>=
name|User
condition|)
block|{
name|previousSize
operator|=
name|ct
operator|->
name|at
argument_list|(
name|idx
operator|-
name|User
argument_list|)
operator|.
name|size
expr_stmt|;
name|previousFlags
operator|=
name|ct
operator|->
name|at
argument_list|(
name|idx
operator|-
name|User
argument_list|)
operator|.
name|flags
expr_stmt|;
block|}
block|}
end_if
begin_if
if|if
condition|(
name|idx
operator|<
name|User
condition|)
block|{
name|previousSize
operator|=
name|QMetaType
operator|::
name|sizeOf
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|previousFlags
operator|=
name|QMetaType
operator|::
name|typeFlags
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
end_if
begin_if
if|if
condition|(
name|previousSize
operator|!=
name|size
condition|)
block|{
name|qFatal
argument_list|(
literal|"QMetaType::registerType: Binary compatibility break "
literal|"-- Size mismatch for type '%s' [%i]. Previously registered "
literal|"size %i, now registering size %i."
argument_list|,
name|normalizedTypeName
operator|.
name|constData
argument_list|()
argument_list|,
name|idx
argument_list|,
name|previousSize
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_if
begin_comment
comment|// Ignore WasDeclaredAsMetaType inconsitency, to many users were hitting the problem
end_comment
begin_expr_stmt
name|previousFlags
operator||=
name|WasDeclaredAsMetaType
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|flags
operator||=
name|WasDeclaredAsMetaType
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|previousFlags
operator|!=
name|flags
condition|)
block|{
specifier|const
name|int
name|maskForTypeInfo
init|=
name|NeedsConstruction
operator||
name|NeedsDestruction
operator||
name|MovableType
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"QMetaType::registerType: Binary compatibility break. "
literal|"\nType flags for type '%s' [%i] don't match. Previously "
literal|"registered TypeFlags(0x%x), now registering TypeFlags(0x%x). "
literal|"This is an ODR break, which means that your application depends on a C++ undefined behavior."
literal|"\nHint: %s"
decl_stmt|;
name|QT_PREPEND_NAMESPACE
argument_list|(
argument|QByteArray
argument_list|)
name|hint
expr_stmt|;
if|if
condition|(
operator|(
name|previousFlags
operator|&
name|maskForTypeInfo
operator|)
operator|!=
operator|(
name|flags
operator|&
name|maskForTypeInfo
operator|)
condition|)
block|{
name|hint
operator|+=
literal|"\nIt seems that the type was registered at least twice in a different translation units, "
literal|"but Q_DECLARE_TYPEINFO is not visible from all the translations unit or different flags were used."
literal|"Remember that Q_DECLARE_TYPEINFO should be declared before QMetaType registration, "
literal|"preferably it should be placed just after the type declaration and before Q_DECLARE_METATYPE"
expr_stmt|;
block|}
name|qFatal
argument_list|(
name|msg
argument_list|,
name|normalizedTypeName
operator|.
name|constData
argument_list|()
argument_list|,
name|idx
argument_list|,
name|previousFlags
argument_list|,
name|int
argument_list|(
name|flags
argument_list|)
argument_list|,
name|hint
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if
begin_return
return|return
name|idx
return|;
end_return
begin_comment
unit|}
comment|/*!     \internal     \since 4.7      Registers a user type for marshalling, as an alias of another type (typedef) */
end_comment
begin_macro
unit|int
DECL|function|registerTypedef
name|QMetaType
end_macro
begin_expr_stmt
DECL|function|registerTypedef
operator|::
name|registerTypedef
operator|(
specifier|const
name|char
operator|*
name|typeName
operator|,
name|int
name|aliasId
operator|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_QOBJECT
name|NS
argument_list|(
argument|QByteArray
argument_list|)
name|normalizedTypeName
operator|=
name|typeName
block|;
else|#
directive|else
name|NS
argument_list|(
argument|QByteArray
argument_list|)
name|normalizedTypeName
operator|=
name|QMetaObject
operator|::
name|normalizedType
argument_list|(
name|typeName
argument_list|)
block|;
endif|#
directive|endif
return|return
name|registerNormalizedTypedef
argument_list|(
name|normalizedTypeName
argument_list|,
name|aliasId
argument_list|)
return|;
block|}
end_expr_stmt
begin_comment
comment|/*!     \internal     \since 5.0      Registers a user type for marshalling, as an alias of another type (typedef).     Note that normalizedTypeName is not checked for conformance with Qt's normalized format,     so it must already conform. */
end_comment
begin_decl_stmt
name|int
name|QMetaType
operator|::
name|registerNormalizedTypedef
argument_list|(
specifier|const
name|NS
argument_list|(
name|QByteArray
argument_list|)
operator|&
name|normalizedTypeName
argument_list|,
name|int
name|aliasId
argument_list|)
argument_list|{
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
operator|*
name|ct
operator|=
name|customTypes
argument_list|()
argument_list|;     if
operator|(
operator|!
name|ct
operator|||
name|normalizedTypeName
operator|.
name|isEmpty
argument_list|()
operator|)
return|return
operator|-
literal|1
return|;
end_decl_stmt
begin_decl_stmt
name|int
name|idx
init|=
name|qMetaTypeStaticType
argument_list|(
name|normalizedTypeName
operator|.
name|constData
argument_list|()
argument_list|,
name|normalizedTypeName
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|idx
operator|==
name|UnknownType
condition|)
block|{
name|QWriteLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
name|idx
operator|=
name|qMetaTypeCustomType_unlocked
argument_list|(
name|normalizedTypeName
operator|.
name|constData
argument_list|()
argument_list|,
name|normalizedTypeName
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|UnknownType
condition|)
block|{
name|QCustomTypeInfo
name|inf
decl_stmt|;
name|inf
operator|.
name|typeName
operator|=
name|normalizedTypeName
expr_stmt|;
name|inf
operator|.
name|alias
operator|=
name|aliasId
expr_stmt|;
name|inf
operator|.
name|creator
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|deleter
operator|=
literal|0
expr_stmt|;
name|ct
operator|->
name|append
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|aliasId
return|;
block|}
block|}
end_if
begin_if
if|if
condition|(
name|idx
operator|!=
name|aliasId
condition|)
block|{
name|qWarning
argument_list|(
literal|"QMetaType::registerTypedef: "
literal|"-- Type name '%s' previously registered as typedef of '%s' [%i], "
literal|"now registering as typedef of '%s' [%i]."
argument_list|,
name|normalizedTypeName
operator|.
name|constData
argument_list|()
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|idx
argument_list|)
argument_list|,
name|idx
argument_list|,
name|QMetaType
operator|::
name|typeName
argument_list|(
name|aliasId
argument_list|)
argument_list|,
name|aliasId
argument_list|)
expr_stmt|;
block|}
end_if
begin_return
return|return
name|idx
return|;
end_return
begin_comment
unit|}
comment|/*!     Returns \c true if the datatype with ID \a type is registered;     otherwise returns \c false.      \sa type(), typeName(), Type */
end_comment
begin_macro
unit|bool
DECL|function|isRegistered
name|QMetaType
end_macro
begin_expr_stmt
DECL|function|isRegistered
operator|::
name|isRegistered
operator|(
name|int
name|type
operator|)
block|{
comment|// predefined type
if|if
condition|(
operator|(
name|type
operator|>=
name|FirstCoreType
operator|&&
name|type
operator|<=
name|LastCoreType
operator|)
operator|||
operator|(
name|type
operator|>=
name|FirstGuiType
operator|&&
name|type
operator|<=
name|LastGuiType
operator|)
operator|||
operator|(
name|type
operator|>=
name|FirstWidgetsType
operator|&&
name|type
operator|<=
name|LastWidgetsType
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|QReadLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
specifier|const
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
specifier|const
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
end_decl_stmt
begin_return
return|return
operator|(
operator|(
name|type
operator|>=
name|User
operator|)
operator|&&
operator|(
name|ct
operator|&&
name|ct
operator|->
name|count
argument_list|()
operator|>
name|type
operator|-
name|User
operator|)
operator|&&
operator|!
name|ct
operator|->
name|at
argument_list|(
name|type
operator|-
name|User
argument_list|)
operator|.
name|typeName
operator|.
name|isEmpty
argument_list|()
operator|)
return|;
end_return
begin_comment
unit|}
comment|/*!     \fn int qMetaTypeTypeImpl(const char *typeName)     \internal      Implementation of QMetaType::type(). */
end_comment
begin_expr_stmt
unit|template
operator|<
name|bool
name|tryNormalizedType
operator|>
DECL|function|qMetaTypeTypeImpl
specifier|static
specifier|inline
name|int
name|qMetaTypeTypeImpl
argument_list|(
argument|const char *typeName
argument_list|,
argument|int length
argument_list|)
block|{
if|if
condition|(
operator|!
name|length
condition|)
return|return
name|QMetaType
operator|::
name|UnknownType
return|;
name|int
name|type
operator|=
name|qMetaTypeStaticType
argument_list|(
name|typeName
argument_list|,
name|length
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|type
operator|==
name|QMetaType
operator|::
name|UnknownType
condition|)
block|{
name|QReadLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
name|type
operator|=
name|qMetaTypeCustomType_unlocked
argument_list|(
name|typeName
argument_list|,
name|length
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
if|if
condition|(
operator|(
name|type
operator|==
name|QMetaType
operator|::
name|UnknownType
operator|)
operator|&&
name|tryNormalizedType
condition|)
block|{
specifier|const
name|NS
argument_list|(
argument|QByteArray
argument_list|)
name|normalizedTypeName
operator|=
name|QMetaObject
operator|::
name|normalizedType
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
name|type
operator|=
name|qMetaTypeStaticType
argument_list|(
name|normalizedTypeName
operator|.
name|constData
argument_list|()
argument_list|,
name|normalizedTypeName
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|QMetaType
operator|::
name|UnknownType
condition|)
block|{
name|type
operator|=
name|qMetaTypeCustomType_unlocked
argument_list|(
name|normalizedTypeName
operator|.
name|constData
argument_list|()
argument_list|,
name|normalizedTypeName
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_if
begin_return
return|return
name|type
return|;
end_return
begin_comment
unit|}
comment|/*!     Returns a handle to the type called \a typeName, or QMetaType::UnknownType if there is     no such type.      \sa isRegistered(), typeName(), Type */
end_comment
begin_macro
unit|int
DECL|function|type
name|QMetaType
end_macro
begin_expr_stmt
DECL|function|type
operator|::
name|type
operator|(
specifier|const
name|char
operator|*
name|typeName
operator|)
block|{
return|return
name|qMetaTypeTypeImpl
argument_list|<
comment|/*tryNormalizedType=*/
literal|true
argument_list|>
argument_list|(
name|typeName
argument_list|,
name|qstrlen
argument_list|(
name|typeName
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_comment
comment|/*!     \a internal      Similar to QMetaType::type(); the only difference is that this function     doesn't attempt to normalize the type name (i.e., the lookup will fail     for type names in non-normalized form). */
end_comment
begin_function
DECL|function|qMetaTypeTypeInternal
name|int
name|qMetaTypeTypeInternal
parameter_list|(
specifier|const
name|char
modifier|*
name|typeName
parameter_list|)
block|{
return|return
name|qMetaTypeTypeImpl
argument_list|<
comment|/*tryNormalizedType=*/
literal|false
argument_list|>
argument_list|(
name|typeName
argument_list|,
name|qstrlen
argument_list|(
name|typeName
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.5     \overload      Returns a handle to the type called \a typeName, or 0 if there is     no such type.      \sa isRegistered(), typeName() */
end_comment
begin_decl_stmt
name|int
name|QMetaType
operator|::
name|type
argument_list|(
specifier|const
name|QT_PREPEND_NAMESPACE
argument_list|(
name|QByteArray
argument_list|)
operator|&
name|typeName
argument_list|)
argument_list|{     return
name|qMetaTypeTypeImpl
argument_list|<
comment|/*tryNormalizedType=*/
literal|true
argument_list|>
argument_list|(
name|typeName
operator|.
name|constData
argument_list|()
argument_list|,
name|typeName
operator|.
name|size
argument_list|()
argument_list|)
argument_list|; }
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
comment|/*!     Writes the object pointed to by \a data with the ID \a type to     the given \a stream. Returns \c true if the object is saved     successfully; otherwise returns \c false.      The type must have been registered with qRegisterMetaType() and     qRegisterMetaTypeStreamOperators() beforehand.      Normally, you should not need to call this function directly.     Instead, use QVariant's \c operator<<(), which relies on save()     to stream custom types.      \sa load(), qRegisterMetaTypeStreamOperators() */
DECL|function|save
name|bool
name|QMetaType
operator|::
name|save
argument_list|(
name|QDataStream
operator|&
name|stream
argument_list|,
name|int
name|type
argument_list|,
specifier|const
name|void
operator|*
name|data
argument_list|)
argument_list|{     if
operator|(
operator|!
name|data
operator|||
operator|!
name|isRegistered
argument_list|(
name|type
argument_list|)
operator|)
return|return
literal|false
return|;
end_decl_stmt
begin_switch
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QMetaType
operator|::
name|UnknownType
case|:
case|case
name|QMetaType
operator|::
name|Void
case|:
case|case
name|QMetaType
operator|::
name|VoidStar
case|:
case|case
name|QMetaType
operator|::
name|QObjectStar
case|:
case|case
name|QMetaType
operator|::
name|QModelIndex
case|:
case|case
name|QMetaType
operator|::
name|QJsonValue
case|:
case|case
name|QMetaType
operator|::
name|QJsonObject
case|:
case|case
name|QMetaType
operator|::
name|QJsonArray
case|:
case|case
name|QMetaType
operator|::
name|QJsonDocument
case|:
return|return
literal|false
return|;
case|case
name|QMetaType
operator|::
name|Long
case|:
name|stream
operator|<<
name|qlonglong
argument_list|(
operator|*
cast|static_cast
argument_list|<
specifier|const
name|long
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Int
case|:
name|stream
operator|<<
operator|*
cast|static_cast
argument_list|<
specifier|const
name|int
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Short
case|:
name|stream
operator|<<
operator|*
cast|static_cast
argument_list|<
specifier|const
name|short
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Char
case|:
comment|// force a char to be signed
name|stream
operator|<<
operator|*
cast|static_cast
argument_list|<
specifier|const
name|signed
name|char
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|ULong
case|:
name|stream
operator|<<
name|qulonglong
argument_list|(
operator|*
cast|static_cast
argument_list|<
specifier|const
name|ulong
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|UInt
case|:
name|stream
operator|<<
operator|*
cast|static_cast
argument_list|<
specifier|const
name|uint
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|LongLong
case|:
name|stream
operator|<<
operator|*
cast|static_cast
argument_list|<
specifier|const
name|qlonglong
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|ULongLong
case|:
name|stream
operator|<<
operator|*
cast|static_cast
argument_list|<
specifier|const
name|qulonglong
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|UShort
case|:
name|stream
operator|<<
operator|*
cast|static_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|SChar
case|:
name|stream
operator|<<
operator|*
cast|static_cast
argument_list|<
specifier|const
name|signed
name|char
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|UChar
case|:
name|stream
operator|<<
operator|*
cast|static_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Bool
case|:
name|stream
operator|<<
name|qint8
argument_list|(
operator|*
cast|static_cast
argument_list|<
specifier|const
name|bool
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Float
case|:
name|stream
operator|<<
operator|*
cast|static_cast
argument_list|<
specifier|const
name|float
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Double
case|:
name|stream
operator|<<
operator|*
cast|static_cast
argument_list|<
specifier|const
name|double
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QChar
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QChar
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
case|case
name|QMetaType
operator|::
name|QVariantMap
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QVariantMap
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QVariantHash
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QVariantHash
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QVariantList
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QVariantList
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QVariant
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QVariant
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QByteArrayList
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QByteArrayList
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QMetaType
operator|::
name|QByteArray
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QByteArray
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QString
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QString
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QStringList
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QStringList
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
case|case
name|QMetaType
operator|::
name|QBitArray
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QBitArray
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QMetaType
operator|::
name|QDate
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QDate
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QTime
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QTime
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QDateTime
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QDateTime
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
case|case
name|QMetaType
operator|::
name|QUrl
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QUrl
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QMetaType
operator|::
name|QLocale
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QLocale
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_GEOM_VARIANT
case|case
name|QMetaType
operator|::
name|QRect
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QRect
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QRectF
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QRectF
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QSize
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QSize
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QSizeF
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QSizeF
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QLine
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QLine
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QLineF
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QLineF
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QPoint
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QPoint
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QPointF
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QPointF
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
case|case
name|QMetaType
operator|::
name|QRegExp
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QRegExp
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
ifndef|#
directive|ifndef
name|QT_NO_REGULAREXPRESSION
case|case
name|QMetaType
operator|::
name|QRegularExpression
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QRegularExpression
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|// QT_NO_REGULAREXPRESSION
case|case
name|QMetaType
operator|::
name|QEasingCurve
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QEasingCurve
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|// QT_BOOTSTRAPPED
case|case
name|QMetaType
operator|::
name|QFont
case|:
case|case
name|QMetaType
operator|::
name|QPixmap
case|:
case|case
name|QMetaType
operator|::
name|QBrush
case|:
case|case
name|QMetaType
operator|::
name|QColor
case|:
case|case
name|QMetaType
operator|::
name|QPalette
case|:
case|case
name|QMetaType
operator|::
name|QImage
case|:
case|case
name|QMetaType
operator|::
name|QPolygon
case|:
case|case
name|QMetaType
operator|::
name|QPolygonF
case|:
case|case
name|QMetaType
operator|::
name|QRegion
case|:
case|case
name|QMetaType
operator|::
name|QBitmap
case|:
case|case
name|QMetaType
operator|::
name|QCursor
case|:
case|case
name|QMetaType
operator|::
name|QKeySequence
case|:
case|case
name|QMetaType
operator|::
name|QPen
case|:
case|case
name|QMetaType
operator|::
name|QTextLength
case|:
case|case
name|QMetaType
operator|::
name|QTextFormat
case|:
case|case
name|QMetaType
operator|::
name|QMatrix
case|:
case|case
name|QMetaType
operator|::
name|QTransform
case|:
case|case
name|QMetaType
operator|::
name|QMatrix4x4
case|:
case|case
name|QMetaType
operator|::
name|QVector2D
case|:
case|case
name|QMetaType
operator|::
name|QVector3D
case|:
case|case
name|QMetaType
operator|::
name|QVector4D
case|:
case|case
name|QMetaType
operator|::
name|QQuaternion
case|:
case|case
name|QMetaType
operator|::
name|QIcon
case|:
if|if
condition|(
operator|!
name|qMetaTypeGuiHelper
condition|)
return|return
literal|false
return|;
name|qMetaTypeGuiHelper
index|[
name|type
operator|-
name|FirstGuiType
index|]
operator|.
name|saveOp
argument_list|(
name|stream
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QSizePolicy
case|:
if|if
condition|(
operator|!
name|qMetaTypeWidgetsHelper
condition|)
return|return
literal|false
return|;
name|qMetaTypeWidgetsHelper
index|[
name|type
operator|-
name|FirstWidgetsType
index|]
operator|.
name|saveOp
argument_list|(
name|stream
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QUuid
case|:
name|stream
operator|<<
operator|*
expr|static_cast
operator|<
specifier|const
name|NS
argument_list|(
name|QUuid
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
default|default:
block|{
specifier|const
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
specifier|const
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ct
condition|)
return|return
literal|false
return|;
name|SaveOperator
name|saveOp
init|=
literal|0
decl_stmt|;
block|{
name|QReadLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
name|saveOp
operator|=
name|ct
operator|->
name|at
argument_list|(
name|type
operator|-
name|User
argument_list|)
operator|.
name|saveOp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|saveOp
condition|)
return|return
literal|false
return|;
name|saveOp
argument_list|(
name|stream
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_switch
begin_return
return|return
literal|true
return|;
end_return
begin_comment
unit|}
comment|/*!     Reads the object of the specified \a type from the given \a     stream into \a data. Returns \c true if the object is loaded     successfully; otherwise returns \c false.      The type must have been registered with qRegisterMetaType() and     qRegisterMetaTypeStreamOperators() beforehand.      Normally, you should not need to call this function directly.     Instead, use QVariant's \c operator>>(), which relies on load()     to stream custom types.      \sa save(), qRegisterMetaTypeStreamOperators() */
end_comment
begin_macro
unit|bool
DECL|function|load
name|QMetaType
end_macro
begin_expr_stmt
DECL|function|load
operator|::
name|load
operator|(
name|QDataStream
operator|&
name|stream
operator|,
name|int
name|type
operator|,
name|void
operator|*
name|data
operator|)
block|{
if|if
condition|(
operator|!
name|data
operator|||
operator|!
name|isRegistered
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|false
return|;
end_expr_stmt
begin_switch
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QMetaType
operator|::
name|UnknownType
case|:
case|case
name|QMetaType
operator|::
name|Void
case|:
case|case
name|QMetaType
operator|::
name|VoidStar
case|:
case|case
name|QMetaType
operator|::
name|QObjectStar
case|:
case|case
name|QMetaType
operator|::
name|QModelIndex
case|:
case|case
name|QMetaType
operator|::
name|QJsonValue
case|:
case|case
name|QMetaType
operator|::
name|QJsonObject
case|:
case|case
name|QMetaType
operator|::
name|QJsonArray
case|:
case|case
name|QMetaType
operator|::
name|QJsonDocument
case|:
return|return
literal|false
return|;
case|case
name|QMetaType
operator|::
name|Long
case|:
block|{
name|qlonglong
name|l
decl_stmt|;
name|stream
operator|>>
name|l
expr_stmt|;
operator|*
cast|static_cast
argument_list|<
name|long
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
operator|=
name|long
argument_list|(
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QMetaType
operator|::
name|Int
case|:
name|stream
operator|>>
operator|*
cast|static_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Short
case|:
name|stream
operator|>>
operator|*
cast|static_cast
argument_list|<
name|short
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Char
case|:
comment|// force a char to be signed
name|stream
operator|>>
operator|*
cast|static_cast
argument_list|<
name|signed
name|char
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|ULong
case|:
block|{
name|qulonglong
name|ul
decl_stmt|;
name|stream
operator|>>
name|ul
expr_stmt|;
operator|*
cast|static_cast
argument_list|<
name|ulong
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
operator|=
name|ulong
argument_list|(
name|ul
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QMetaType
operator|::
name|UInt
case|:
name|stream
operator|>>
operator|*
cast|static_cast
argument_list|<
name|uint
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|LongLong
case|:
name|stream
operator|>>
operator|*
cast|static_cast
argument_list|<
name|qlonglong
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|ULongLong
case|:
name|stream
operator|>>
operator|*
cast|static_cast
argument_list|<
name|qulonglong
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|UShort
case|:
name|stream
operator|>>
operator|*
cast|static_cast
argument_list|<
name|ushort
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|SChar
case|:
name|stream
operator|>>
operator|*
cast|static_cast
argument_list|<
name|signed
name|char
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|UChar
case|:
name|stream
operator|>>
operator|*
cast|static_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Bool
case|:
block|{
name|qint8
name|b
decl_stmt|;
name|stream
operator|>>
name|b
expr_stmt|;
operator|*
cast|static_cast
argument_list|<
name|bool
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
operator|=
name|b
expr_stmt|;
break|break;
block|}
case|case
name|QMetaType
operator|::
name|Float
case|:
name|stream
operator|>>
operator|*
cast|static_cast
argument_list|<
name|float
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|Double
case|:
name|stream
operator|>>
operator|*
cast|static_cast
argument_list|<
name|double
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QChar
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QChar
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
case|case
name|QMetaType
operator|::
name|QVariantMap
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QVariantMap
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QVariantHash
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QVariantHash
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QVariantList
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QVariantList
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QVariant
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QVariant
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QByteArrayList
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QByteArrayList
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QMetaType
operator|::
name|QByteArray
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QByteArray
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QString
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QString
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QStringList
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QStringList
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
case|case
name|QMetaType
operator|::
name|QBitArray
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QBitArray
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QMetaType
operator|::
name|QDate
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QDate
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QTime
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QTime
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QDateTime
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QDateTime
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
case|case
name|QMetaType
operator|::
name|QUrl
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QUrl
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QMetaType
operator|::
name|QLocale
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QLocale
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_GEOM_VARIANT
case|case
name|QMetaType
operator|::
name|QRect
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QRect
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QRectF
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QRectF
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QSize
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QSize
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QSizeF
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QSizeF
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QLine
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QLine
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QLineF
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QLineF
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QPoint
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QPoint
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QPointF
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QPointF
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_REGEXP
case|case
name|QMetaType
operator|::
name|QRegExp
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QRegExp
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
ifndef|#
directive|ifndef
name|QT_NO_REGULAREXPRESSION
case|case
name|QMetaType
operator|::
name|QRegularExpression
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QRegularExpression
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|// QT_NO_REGULAREXPRESSION
case|case
name|QMetaType
operator|::
name|QEasingCurve
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QEasingCurve
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|// QT_BOOTSTRAPPED
case|case
name|QMetaType
operator|::
name|QFont
case|:
case|case
name|QMetaType
operator|::
name|QPixmap
case|:
case|case
name|QMetaType
operator|::
name|QBrush
case|:
case|case
name|QMetaType
operator|::
name|QColor
case|:
case|case
name|QMetaType
operator|::
name|QPalette
case|:
case|case
name|QMetaType
operator|::
name|QImage
case|:
case|case
name|QMetaType
operator|::
name|QPolygon
case|:
case|case
name|QMetaType
operator|::
name|QPolygonF
case|:
case|case
name|QMetaType
operator|::
name|QRegion
case|:
case|case
name|QMetaType
operator|::
name|QBitmap
case|:
case|case
name|QMetaType
operator|::
name|QCursor
case|:
case|case
name|QMetaType
operator|::
name|QKeySequence
case|:
case|case
name|QMetaType
operator|::
name|QPen
case|:
case|case
name|QMetaType
operator|::
name|QTextLength
case|:
case|case
name|QMetaType
operator|::
name|QTextFormat
case|:
case|case
name|QMetaType
operator|::
name|QMatrix
case|:
case|case
name|QMetaType
operator|::
name|QTransform
case|:
case|case
name|QMetaType
operator|::
name|QMatrix4x4
case|:
case|case
name|QMetaType
operator|::
name|QVector2D
case|:
case|case
name|QMetaType
operator|::
name|QVector3D
case|:
case|case
name|QMetaType
operator|::
name|QVector4D
case|:
case|case
name|QMetaType
operator|::
name|QQuaternion
case|:
case|case
name|QMetaType
operator|::
name|QIcon
case|:
if|if
condition|(
operator|!
name|qMetaTypeGuiHelper
condition|)
return|return
literal|false
return|;
name|qMetaTypeGuiHelper
index|[
name|type
operator|-
name|FirstGuiType
index|]
operator|.
name|loadOp
argument_list|(
name|stream
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QSizePolicy
case|:
if|if
condition|(
operator|!
name|qMetaTypeWidgetsHelper
condition|)
return|return
literal|false
return|;
name|qMetaTypeWidgetsHelper
index|[
name|type
operator|-
name|FirstWidgetsType
index|]
operator|.
name|loadOp
argument_list|(
name|stream
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|QMetaType
operator|::
name|QUuid
case|:
name|stream
operator|>>
operator|*
expr|static_cast
operator|<
name|NS
argument_list|(
name|QUuid
argument_list|)
operator|*
operator|>
operator|(
name|data
operator|)
expr_stmt|;
break|break;
default|default:
block|{
specifier|const
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
specifier|const
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ct
condition|)
return|return
literal|false
return|;
name|LoadOperator
name|loadOp
init|=
literal|0
decl_stmt|;
block|{
name|QReadLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
name|loadOp
operator|=
name|ct
operator|->
name|at
argument_list|(
name|type
operator|-
name|User
argument_list|)
operator|.
name|loadOp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|loadOp
condition|)
return|return
literal|false
return|;
name|loadOp
argument_list|(
name|stream
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_switch
begin_return
return|return
literal|true
return|;
end_return
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_block
unit|namespace
block|{
DECL|class|TypeCreator
class|class
name|TypeCreator
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|,
name|bool
name|IsAcceptedType
init|=
name|DefinedTypesFilter
operator|::
name|Acceptor
argument_list|<
name|T
argument_list|>
operator|::
name|IsAccepted
parameter_list|>
struct|struct
DECL|struct|CreatorImpl
name|CreatorImpl
block|{
DECL|function|Create
specifier|static
name|void
modifier|*
name|Create
parameter_list|(
specifier|const
name|int
comment|/* type */
parameter_list|,
specifier|const
name|void
modifier|*
name|copy
parameter_list|)
block|{
comment|// Using QMetaTypeFunctionHelper<T>::Create adds function call cost, even if it is a template (gcc).
comment|// This "copy" check is moved out from the switcher by compiler (at least by gcc)
return|return
name|copy
condition|?
operator|new
name|T
argument_list|(
operator|*
cast|static_cast
argument_list|<
specifier|const
name|T
operator|*
argument_list|>
argument_list|(
name|copy
argument_list|)
argument_list|)
else|:
operator|new
name|T
argument_list|()
return|;
block|}
block|}
struct|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|CreatorImpl
name|CreatorImpl
argument_list|<
name|T
argument_list|,
comment|/* IsAcceptedType = */
literal|false
argument_list|>
block|{
DECL|function|Create
specifier|static
name|void
modifier|*
name|Create
parameter_list|(
specifier|const
name|int
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|copy
parameter_list|)
block|{
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsGui
condition|)
block|{
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|qMetaTypeGuiHelper
argument_list|)
condition|)
return|return
name|qMetaTypeGuiHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstGuiType
index|]
operator|.
name|creator
argument_list|(
name|copy
argument_list|)
return|;
block|}
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsWidget
condition|)
block|{
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|qMetaTypeWidgetsHelper
argument_list|)
condition|)
return|return
name|qMetaTypeWidgetsHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstWidgetsType
index|]
operator|.
name|creator
argument_list|(
name|copy
argument_list|)
return|;
block|}
comment|// This point can be reached only for known types that definition is not available, for example
comment|// in bootstrap mode. We have no other choice then ignore it.
return|return
literal|0
return|;
block|}
block|}
struct|;
public|public:
DECL|function|TypeCreator
name|TypeCreator
parameter_list|(
specifier|const
name|int
name|type
parameter_list|)
member_init_list|:
name|m_type
argument_list|(
name|type
argument_list|)
block|{}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|delegate
name|void
modifier|*
name|delegate
parameter_list|(
specifier|const
name|T
modifier|*
name|copy
parameter_list|)
block|{
return|return
name|CreatorImpl
argument_list|<
name|T
argument_list|>
operator|::
name|Create
argument_list|(
name|m_type
argument_list|,
name|copy
argument_list|)
return|;
block|}
DECL|function|delegate
name|void
modifier|*
name|delegate
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
DECL|function|delegate
name|void
modifier|*
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|UnknownType
modifier|*
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
DECL|function|delegate
name|void
modifier|*
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|NotBuiltinType
modifier|*
name|copy
parameter_list|)
block|{
name|QMetaType
operator|::
name|Creator
name|creator
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
specifier|const
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
block|{
name|QReadLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|m_type
operator|<
name|QMetaType
operator|::
name|User
operator|||
operator|!
name|ct
operator|||
name|ct
operator|->
name|count
argument_list|()
operator|<=
name|m_type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
condition|)
return|return
literal|0
return|;
name|creator
operator|=
name|ct
operator|->
name|at
argument_list|(
name|m_type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
operator|.
name|creator
expr_stmt|;
block|}
name|Q_ASSERT_X
argument_list|(
name|creator
argument_list|,
literal|"void *QMetaType::create(int type, const void *copy)"
argument_list|,
literal|"The type was not properly registered"
argument_list|)
expr_stmt|;
return|return
name|creator
argument_list|(
name|copy
argument_list|)
return|;
block|}
private|private:
DECL|member|m_type
specifier|const
name|int
name|m_type
decl_stmt|;
block|}
class|;
block|}
end_block
begin_comment
comment|// namespace
end_comment
begin_comment
comment|/*!     Returns a copy of \a copy, assuming it is of type \a type. If \a     copy is zero, creates a default constructed instance.      \sa destroy(), isRegistered(), Type */
end_comment
begin_function
DECL|function|create
name|void
modifier|*
name|QMetaType
operator|::
name|create
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|copy
parameter_list|)
block|{
name|TypeCreator
name|typeCreator
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
name|QMetaTypeSwitcher
operator|::
name|switcher
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|typeCreator
argument_list|,
name|type
argument_list|,
name|copy
argument_list|)
return|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|class|TypeDestroyer
class|class
name|TypeDestroyer
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|,
name|bool
name|IsAcceptedType
init|=
name|DefinedTypesFilter
operator|::
name|Acceptor
argument_list|<
name|T
argument_list|>
operator|::
name|IsAccepted
parameter_list|>
struct|struct
DECL|struct|DestroyerImpl
name|DestroyerImpl
block|{
DECL|function|Destroy
specifier|static
name|void
name|Destroy
parameter_list|(
specifier|const
name|int
comment|/* type */
parameter_list|,
name|void
modifier|*
name|where
parameter_list|)
block|{
name|QtMetaTypePrivate
operator|::
name|QMetaTypeFunctionHelper
argument_list|<
name|T
argument_list|>
operator|::
name|Delete
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
block|}
struct|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|DestroyerImpl
name|DestroyerImpl
argument_list|<
name|T
argument_list|,
comment|/* IsAcceptedType = */
literal|false
argument_list|>
block|{
DECL|function|Destroy
specifier|static
name|void
name|Destroy
parameter_list|(
specifier|const
name|int
name|type
parameter_list|,
name|void
modifier|*
name|where
parameter_list|)
block|{
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsGui
condition|)
block|{
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|qMetaTypeGuiHelper
argument_list|)
condition|)
name|qMetaTypeGuiHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstGuiType
index|]
operator|.
name|deleter
argument_list|(
name|where
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsWidget
condition|)
block|{
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|qMetaTypeWidgetsHelper
argument_list|)
condition|)
name|qMetaTypeWidgetsHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstWidgetsType
index|]
operator|.
name|deleter
argument_list|(
name|where
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// This point can be reached only for known types that definition is not available, for example
comment|// in bootstrap mode. We have no other choice then ignore it.
block|}
block|}
struct|;
public|public:
DECL|function|TypeDestroyer
name|TypeDestroyer
parameter_list|(
specifier|const
name|int
name|type
parameter_list|)
member_init_list|:
name|m_type
argument_list|(
name|type
argument_list|)
block|{}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|delegate
name|void
name|delegate
parameter_list|(
specifier|const
name|T
modifier|*
name|where
parameter_list|)
block|{
name|DestroyerImpl
argument_list|<
name|T
argument_list|>
operator|::
name|Destroy
argument_list|(
name|m_type
argument_list|,
cast|const_cast
argument_list|<
name|T
operator|*
argument_list|>
argument_list|(
name|where
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|delegate
name|void
name|delegate
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
block|{}
DECL|function|delegate
name|void
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|UnknownType
modifier|*
parameter_list|)
block|{}
DECL|function|delegate
name|void
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|NotBuiltinType
modifier|*
name|where
parameter_list|)
block|{
name|customTypeDestroyer
argument_list|(
name|m_type
argument_list|,
operator|(
name|void
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
block|}
private|private:
DECL|function|customTypeDestroyer
specifier|static
name|void
name|customTypeDestroyer
parameter_list|(
specifier|const
name|int
name|type
parameter_list|,
name|void
modifier|*
name|where
parameter_list|)
block|{
name|QMetaType
operator|::
name|Destructor
name|deleter
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
specifier|const
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
block|{
name|QReadLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|type
operator|<
name|QMetaType
operator|::
name|User
operator|||
operator|!
name|ct
operator|||
name|ct
operator|->
name|count
argument_list|()
operator|<=
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
condition|)
return|return;
name|deleter
operator|=
name|ct
operator|->
name|at
argument_list|(
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
operator|.
name|deleter
expr_stmt|;
block|}
name|Q_ASSERT_X
argument_list|(
name|deleter
argument_list|,
literal|"void QMetaType::destroy(int type, void *data)"
argument_list|,
literal|"The type was not properly registered"
argument_list|)
expr_stmt|;
name|deleter
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
DECL|member|m_type
specifier|const
name|int
name|m_type
decl_stmt|;
block|}
class|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_comment
comment|/*!     Destroys the \a data, assuming it is of the \a type given.      \sa create(), isRegistered(), Type */
end_comment
begin_function
DECL|function|destroy
name|void
name|QMetaType
operator|::
name|destroy
parameter_list|(
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|TypeDestroyer
name|deleter
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|QMetaTypeSwitcher
operator|::
name|switcher
argument_list|<
name|void
argument_list|>
argument_list|(
name|deleter
argument_list|,
name|type
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|class|TypeConstructor
class|class
name|TypeConstructor
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|,
name|bool
name|IsAcceptedType
init|=
name|DefinedTypesFilter
operator|::
name|Acceptor
argument_list|<
name|T
argument_list|>
operator|::
name|IsAccepted
parameter_list|>
struct|struct
DECL|struct|ConstructorImpl
name|ConstructorImpl
block|{
DECL|function|Construct
specifier|static
name|void
modifier|*
name|Construct
parameter_list|(
specifier|const
name|int
comment|/*type*/
parameter_list|,
name|void
modifier|*
name|where
parameter_list|,
specifier|const
name|void
modifier|*
name|copy
parameter_list|)
block|{
return|return
name|QtMetaTypePrivate
operator|::
name|QMetaTypeFunctionHelper
argument_list|<
name|T
argument_list|>
operator|::
name|Construct
argument_list|(
name|where
argument_list|,
name|copy
argument_list|)
return|;
block|}
block|}
struct|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|ConstructorImpl
name|ConstructorImpl
argument_list|<
name|T
argument_list|,
comment|/* IsAcceptedType = */
literal|false
argument_list|>
block|{
DECL|function|Construct
specifier|static
name|void
modifier|*
name|Construct
parameter_list|(
specifier|const
name|int
name|type
parameter_list|,
name|void
modifier|*
name|where
parameter_list|,
specifier|const
name|void
modifier|*
name|copy
parameter_list|)
block|{
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsGui
condition|)
return|return
name|Q_LIKELY
argument_list|(
name|qMetaTypeGuiHelper
argument_list|)
condition|?
name|qMetaTypeGuiHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstGuiType
index|]
operator|.
name|constructor
argument_list|(
name|where
argument_list|,
name|copy
argument_list|)
else|:
literal|0
return|;
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsWidget
condition|)
return|return
name|Q_LIKELY
argument_list|(
name|qMetaTypeWidgetsHelper
argument_list|)
condition|?
name|qMetaTypeWidgetsHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstWidgetsType
index|]
operator|.
name|constructor
argument_list|(
name|where
argument_list|,
name|copy
argument_list|)
else|:
literal|0
return|;
comment|// This point can be reached only for known types that definition is not available, for example
comment|// in bootstrap mode. We have no other choice then ignore it.
return|return
literal|0
return|;
block|}
block|}
struct|;
public|public:
DECL|function|TypeConstructor
name|TypeConstructor
parameter_list|(
specifier|const
name|int
name|type
parameter_list|,
name|void
modifier|*
name|where
parameter_list|)
member_init_list|:
name|m_type
argument_list|(
name|type
argument_list|)
member_init_list|,
name|m_where
argument_list|(
name|where
argument_list|)
block|{}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|delegate
name|void
modifier|*
name|delegate
parameter_list|(
specifier|const
name|T
modifier|*
name|copy
parameter_list|)
block|{
return|return
name|ConstructorImpl
argument_list|<
name|T
argument_list|>
operator|::
name|Construct
argument_list|(
name|m_type
argument_list|,
name|m_where
argument_list|,
name|copy
argument_list|)
return|;
block|}
DECL|function|delegate
name|void
modifier|*
name|delegate
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
block|{
return|return
name|m_where
return|;
block|}
DECL|function|delegate
name|void
modifier|*
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|UnknownType
modifier|*
parameter_list|)
block|{
return|return
name|m_where
return|;
block|}
DECL|function|delegate
name|void
modifier|*
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|NotBuiltinType
modifier|*
name|copy
parameter_list|)
block|{
return|return
name|customTypeConstructor
argument_list|(
name|m_type
argument_list|,
name|m_where
argument_list|,
name|copy
argument_list|)
return|;
block|}
private|private:
DECL|function|customTypeConstructor
specifier|static
name|void
modifier|*
name|customTypeConstructor
parameter_list|(
specifier|const
name|int
name|type
parameter_list|,
name|void
modifier|*
name|where
parameter_list|,
specifier|const
name|void
modifier|*
name|copy
parameter_list|)
block|{
name|QMetaType
operator|::
name|Constructor
name|ctor
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
specifier|const
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
block|{
name|QReadLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|type
operator|<
name|QMetaType
operator|::
name|User
operator|||
operator|!
name|ct
operator|||
name|ct
operator|->
name|count
argument_list|()
operator|<=
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
condition|)
return|return
literal|0
return|;
name|ctor
operator|=
name|ct
operator|->
name|at
argument_list|(
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
operator|.
name|constructor
expr_stmt|;
block|}
name|Q_ASSERT_X
argument_list|(
name|ctor
argument_list|,
literal|"void *QMetaType::construct(int type, void *where, const void *copy)"
argument_list|,
literal|"The type was not properly registered"
argument_list|)
expr_stmt|;
return|return
name|ctor
argument_list|(
name|where
argument_list|,
name|copy
argument_list|)
return|;
block|}
DECL|member|m_type
specifier|const
name|int
name|m_type
decl_stmt|;
DECL|member|m_where
name|void
modifier|*
name|m_where
decl_stmt|;
block|}
class|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_comment
comment|/*!     \since 5.0      Constructs a value of the given \a type in the existing memory     addressed by \a where, that is a copy of \a copy, and returns     \a where. If \a copy is zero, the value is default constructed.      This is a low-level function for explicitly managing the memory     used to store the type. Consider calling create() if you don't     need this level of control (that is, use "new" rather than     "placement new").      You must ensure that \a where points to a location that can store     a value of type \a type, and that \a where is suitably aligned.     The type's size can be queried by calling sizeOf().      The rule of thumb for alignment is that a type is aligned to its     natural boundary, which is the smallest power of 2 that is bigger     than the type, unless that alignment is larger than the maximum     useful alignment for the platform. For practical purposes,     alignment larger than 2 * sizeof(void*) is only necessary for     special hardware instructions (e.g., aligned SSE loads and stores     on x86).      \sa destruct(), sizeOf() */
end_comment
begin_function
DECL|function|construct
name|void
modifier|*
name|QMetaType
operator|::
name|construct
parameter_list|(
name|int
name|type
parameter_list|,
name|void
modifier|*
name|where
parameter_list|,
specifier|const
name|void
modifier|*
name|copy
parameter_list|)
block|{
if|if
condition|(
operator|!
name|where
condition|)
return|return
literal|0
return|;
name|TypeConstructor
name|constructor
argument_list|(
name|type
argument_list|,
name|where
argument_list|)
decl_stmt|;
return|return
name|QMetaTypeSwitcher
operator|::
name|switcher
argument_list|<
name|void
operator|*
argument_list|>
argument_list|(
name|constructor
argument_list|,
name|type
argument_list|,
name|copy
argument_list|)
return|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|class|TypeDestructor
class|class
name|TypeDestructor
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|,
name|bool
name|IsAcceptedType
init|=
name|DefinedTypesFilter
operator|::
name|Acceptor
argument_list|<
name|T
argument_list|>
operator|::
name|IsAccepted
parameter_list|>
struct|struct
DECL|struct|DestructorImpl
name|DestructorImpl
block|{
DECL|function|Destruct
specifier|static
name|void
name|Destruct
parameter_list|(
specifier|const
name|int
comment|/* type */
parameter_list|,
name|void
modifier|*
name|where
parameter_list|)
block|{
name|QtMetaTypePrivate
operator|::
name|QMetaTypeFunctionHelper
argument_list|<
name|T
argument_list|>
operator|::
name|Destruct
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
block|}
struct|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|DestructorImpl
name|DestructorImpl
argument_list|<
name|T
argument_list|,
comment|/* IsAcceptedType = */
literal|false
argument_list|>
block|{
DECL|function|Destruct
specifier|static
name|void
name|Destruct
parameter_list|(
specifier|const
name|int
name|type
parameter_list|,
name|void
modifier|*
name|where
parameter_list|)
block|{
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsGui
condition|)
block|{
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|qMetaTypeGuiHelper
argument_list|)
condition|)
name|qMetaTypeGuiHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstGuiType
index|]
operator|.
name|destructor
argument_list|(
name|where
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsWidget
condition|)
block|{
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|qMetaTypeWidgetsHelper
argument_list|)
condition|)
name|qMetaTypeWidgetsHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstWidgetsType
index|]
operator|.
name|destructor
argument_list|(
name|where
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// This point can be reached only for known types that definition is not available, for example
comment|// in bootstrap mode. We have no other choice then ignore it.
block|}
block|}
struct|;
public|public:
DECL|function|TypeDestructor
name|TypeDestructor
parameter_list|(
specifier|const
name|int
name|type
parameter_list|)
member_init_list|:
name|m_type
argument_list|(
name|type
argument_list|)
block|{}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|delegate
name|void
name|delegate
parameter_list|(
specifier|const
name|T
modifier|*
name|where
parameter_list|)
block|{
name|DestructorImpl
argument_list|<
name|T
argument_list|>
operator|::
name|Destruct
argument_list|(
name|m_type
argument_list|,
cast|const_cast
argument_list|<
name|T
operator|*
argument_list|>
argument_list|(
name|where
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|delegate
name|void
name|delegate
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
block|{}
DECL|function|delegate
name|void
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|UnknownType
modifier|*
parameter_list|)
block|{}
DECL|function|delegate
name|void
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|NotBuiltinType
modifier|*
name|where
parameter_list|)
block|{
name|customTypeDestructor
argument_list|(
name|m_type
argument_list|,
operator|(
name|void
operator|*
operator|)
name|where
argument_list|)
expr_stmt|;
block|}
private|private:
DECL|function|customTypeDestructor
specifier|static
name|void
name|customTypeDestructor
parameter_list|(
specifier|const
name|int
name|type
parameter_list|,
name|void
modifier|*
name|where
parameter_list|)
block|{
name|QMetaType
operator|::
name|Destructor
name|dtor
decl_stmt|;
specifier|const
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
specifier|const
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
block|{
name|QReadLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|type
operator|<
name|QMetaType
operator|::
name|User
operator|||
operator|!
name|ct
operator|||
name|ct
operator|->
name|count
argument_list|()
operator|<=
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
condition|)
return|return;
name|dtor
operator|=
name|ct
operator|->
name|at
argument_list|(
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
operator|.
name|destructor
expr_stmt|;
block|}
name|Q_ASSERT_X
argument_list|(
name|dtor
argument_list|,
literal|"void QMetaType::destruct(int type, void *where)"
argument_list|,
literal|"The type was not properly registered"
argument_list|)
expr_stmt|;
name|dtor
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
DECL|member|m_type
specifier|const
name|int
name|m_type
decl_stmt|;
block|}
class|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_comment
comment|/*!     \since 5.0      Destructs the value of the given \a type, located at \a where.      Unlike destroy(), this function only invokes the type's     destructor, it doesn't invoke the delete operator.      \sa construct() */
end_comment
begin_function
DECL|function|destruct
name|void
name|QMetaType
operator|::
name|destruct
parameter_list|(
name|int
name|type
parameter_list|,
name|void
modifier|*
name|where
parameter_list|)
block|{
if|if
condition|(
operator|!
name|where
condition|)
return|return;
name|TypeDestructor
name|destructor
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|QMetaTypeSwitcher
operator|::
name|switcher
argument_list|<
name|void
argument_list|>
argument_list|(
name|destructor
argument_list|,
name|type
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|class|SizeOf
class|class
name|SizeOf
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|,
name|bool
name|IsAcceptedType
init|=
name|DefinedTypesFilter
operator|::
name|Acceptor
argument_list|<
name|T
argument_list|>
operator|::
name|IsAccepted
parameter_list|>
struct|struct
DECL|struct|SizeOfImpl
name|SizeOfImpl
block|{
DECL|function|Size
specifier|static
name|int
name|Size
parameter_list|(
specifier|const
name|int
parameter_list|)
block|{
return|return
name|QTypeInfo
argument_list|<
name|T
argument_list|>
operator|::
name|sizeOf
return|;
block|}
block|}
struct|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|SizeOfImpl
name|SizeOfImpl
argument_list|<
name|T
argument_list|,
comment|/* IsAcceptedType = */
literal|false
argument_list|>
block|{
DECL|function|Size
specifier|static
name|int
name|Size
parameter_list|(
specifier|const
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsGui
condition|)
return|return
name|Q_LIKELY
argument_list|(
name|qMetaTypeGuiHelper
argument_list|)
condition|?
name|qMetaTypeGuiHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstGuiType
index|]
operator|.
name|size
else|:
literal|0
return|;
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsWidget
condition|)
return|return
name|Q_LIKELY
argument_list|(
name|qMetaTypeWidgetsHelper
argument_list|)
condition|?
name|qMetaTypeWidgetsHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstWidgetsType
index|]
operator|.
name|size
else|:
literal|0
return|;
comment|// This point can be reached only for known types that definition is not available, for example
comment|// in bootstrap mode. We have no other choice then ignore it.
return|return
literal|0
return|;
block|}
block|}
struct|;
public|public:
DECL|function|SizeOf
name|SizeOf
parameter_list|(
name|int
name|type
parameter_list|)
member_init_list|:
name|m_type
argument_list|(
name|type
argument_list|)
block|{}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|delegate
name|int
name|delegate
parameter_list|(
specifier|const
name|T
modifier|*
parameter_list|)
block|{
return|return
name|SizeOfImpl
argument_list|<
name|T
argument_list|>
operator|::
name|Size
argument_list|(
name|m_type
argument_list|)
return|;
block|}
DECL|function|delegate
name|int
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|UnknownType
modifier|*
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
DECL|function|delegate
name|int
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|NotBuiltinType
modifier|*
parameter_list|)
block|{
return|return
name|customTypeSizeOf
argument_list|(
name|m_type
argument_list|)
return|;
block|}
private|private:
DECL|function|customTypeSizeOf
specifier|static
name|int
name|customTypeSizeOf
parameter_list|(
specifier|const
name|int
name|type
parameter_list|)
block|{
specifier|const
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
specifier|const
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
name|QReadLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|type
operator|<
name|QMetaType
operator|::
name|User
operator|||
operator|!
name|ct
operator|||
name|ct
operator|->
name|count
argument_list|()
operator|<=
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|ct
operator|->
name|at
argument_list|(
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
operator|.
name|size
return|;
block|}
DECL|member|m_type
specifier|const
name|int
name|m_type
decl_stmt|;
block|}
class|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_comment
comment|/*!     \since 5.0      Returns the size of the given \a type in bytes (i.e. sizeof(T),     where T is the actual type identified by the \a type argument).      This function is typically used together with construct()     to perform low-level management of the memory used by a type.      \sa construct() */
end_comment
begin_function
DECL|function|sizeOf
name|int
name|QMetaType
operator|::
name|sizeOf
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|SizeOf
name|sizeOf
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
name|QMetaTypeSwitcher
operator|::
name|switcher
argument_list|<
name|int
argument_list|>
argument_list|(
name|sizeOf
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|class|Flags
class|class
name|Flags
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|,
name|bool
name|IsAcceptedType
init|=
name|DefinedTypesFilter
operator|::
name|Acceptor
argument_list|<
name|T
argument_list|>
operator|::
name|IsAccepted
parameter_list|>
struct|struct
DECL|struct|FlagsImpl
name|FlagsImpl
block|{
DECL|function|Flags
specifier|static
name|quint32
name|Flags
parameter_list|(
specifier|const
name|int
comment|/* type */
parameter_list|)
block|{
return|return
name|QtPrivate
operator|::
name|QMetaTypeTypeFlags
argument_list|<
name|T
argument_list|>
operator|::
name|Flags
return|;
block|}
block|}
struct|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|FlagsImpl
name|FlagsImpl
argument_list|<
name|T
argument_list|,
comment|/* IsAcceptedType = */
literal|false
argument_list|>
block|{
DECL|function|Flags
specifier|static
name|quint32
name|Flags
parameter_list|(
specifier|const
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsGui
condition|)
return|return
name|Q_LIKELY
argument_list|(
name|qMetaTypeGuiHelper
argument_list|)
condition|?
name|qMetaTypeGuiHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstGuiType
index|]
operator|.
name|flags
else|:
literal|0
return|;
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsWidget
condition|)
return|return
name|Q_LIKELY
argument_list|(
name|qMetaTypeWidgetsHelper
argument_list|)
condition|?
name|qMetaTypeWidgetsHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstWidgetsType
index|]
operator|.
name|flags
else|:
literal|0
return|;
comment|// This point can be reached only for known types that definition is not available, for example
comment|// in bootstrap mode. We have no other choice then ignore it.
return|return
literal|0
return|;
block|}
block|}
struct|;
public|public:
DECL|function|Flags
name|Flags
parameter_list|(
specifier|const
name|int
name|type
parameter_list|)
member_init_list|:
name|m_type
argument_list|(
name|type
argument_list|)
block|{}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|delegate
name|quint32
name|delegate
parameter_list|(
specifier|const
name|T
modifier|*
parameter_list|)
block|{
return|return
name|FlagsImpl
argument_list|<
name|T
argument_list|>
operator|::
name|Flags
argument_list|(
name|m_type
argument_list|)
return|;
block|}
DECL|function|delegate
name|quint32
name|delegate
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
DECL|function|delegate
name|quint32
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|UnknownType
modifier|*
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
DECL|function|delegate
name|quint32
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|NotBuiltinType
modifier|*
parameter_list|)
block|{
return|return
name|customTypeFlags
argument_list|(
name|m_type
argument_list|)
return|;
block|}
private|private:
DECL|member|m_type
specifier|const
name|int
name|m_type
decl_stmt|;
DECL|function|customTypeFlags
specifier|static
name|quint32
name|customTypeFlags
parameter_list|(
specifier|const
name|int
name|type
parameter_list|)
block|{
specifier|const
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
specifier|const
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
operator|!
name|ct
operator|||
name|type
operator|<
name|QMetaType
operator|::
name|User
argument_list|)
condition|)
return|return
literal|0
return|;
name|QReadLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|ct
operator|->
name|count
argument_list|()
operator|<=
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|ct
operator|->
name|at
argument_list|(
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
operator|.
name|flags
return|;
block|}
block|}
class|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_comment
comment|/*!     \since 5.0      Returns flags of the given \a type.      \sa QMetaType::TypeFlags */
end_comment
begin_function
DECL|function|typeFlags
name|QMetaType
operator|::
name|TypeFlags
name|QMetaType
operator|::
name|typeFlags
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|Flags
name|flags
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
cast|static_cast
argument_list|<
name|QMetaType
operator|::
name|TypeFlags
argument_list|>
argument_list|(
name|QMetaTypeSwitcher
operator|::
name|switcher
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|flags
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_namespace
namespace|namespace
block|{
DECL|class|MetaObject
class|class
name|MetaObject
block|{
public|public:
DECL|function|MetaObject
name|MetaObject
parameter_list|(
specifier|const
name|int
name|type
parameter_list|)
member_init_list|:
name|m_type
argument_list|(
name|type
argument_list|)
block|{}
template|template
parameter_list|<
name|typename
name|T
parameter_list|,
name|bool
name|IsAcceptedType
init|=
name|DefinedTypesFilter
operator|::
name|Acceptor
argument_list|<
name|T
argument_list|>
operator|::
name|IsAccepted
parameter_list|>
struct|struct
DECL|struct|MetaObjectImpl
name|MetaObjectImpl
block|{
DECL|function|MetaObject
specifier|static
specifier|const
name|QMetaObject
modifier|*
name|MetaObject
parameter_list|(
name|int
comment|/*type*/
parameter_list|)
block|{
return|return
name|QtPrivate
operator|::
name|MetaObjectForType
argument_list|<
name|T
argument_list|>
operator|::
name|value
argument_list|()
return|;
block|}
block|}
struct|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|MetaObjectImpl
name|MetaObjectImpl
argument_list|<
name|T
argument_list|,
comment|/* IsAcceptedType = */
literal|false
argument_list|>
block|{
DECL|function|MetaObject
specifier|static
specifier|const
name|QMetaObject
modifier|*
name|MetaObject
parameter_list|(
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsGui
condition|)
return|return
name|Q_LIKELY
argument_list|(
name|qMetaTypeGuiHelper
argument_list|)
condition|?
name|qMetaTypeGuiHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstGuiType
index|]
operator|.
name|metaObject
else|:
literal|0
return|;
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsWidget
condition|)
return|return
name|Q_LIKELY
argument_list|(
name|qMetaTypeWidgetsHelper
argument_list|)
condition|?
name|qMetaTypeWidgetsHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstWidgetsType
index|]
operator|.
name|metaObject
else|:
literal|0
return|;
return|return
literal|0
return|;
block|}
block|}
struct|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|delegate
specifier|const
name|QMetaObject
modifier|*
name|delegate
parameter_list|(
specifier|const
name|T
modifier|*
parameter_list|)
block|{
return|return
name|MetaObjectImpl
argument_list|<
name|T
argument_list|>
operator|::
name|MetaObject
argument_list|(
name|m_type
argument_list|)
return|;
block|}
DECL|function|delegate
specifier|const
name|QMetaObject
modifier|*
name|delegate
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
DECL|function|delegate
specifier|const
name|QMetaObject
modifier|*
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|UnknownType
modifier|*
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
DECL|function|delegate
specifier|const
name|QMetaObject
modifier|*
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|NotBuiltinType
modifier|*
parameter_list|)
block|{
return|return
name|customMetaObject
argument_list|(
name|m_type
argument_list|)
return|;
block|}
private|private:
DECL|member|m_type
specifier|const
name|int
name|m_type
decl_stmt|;
DECL|function|customMetaObject
specifier|static
specifier|const
name|QMetaObject
modifier|*
name|customMetaObject
parameter_list|(
specifier|const
name|int
name|type
parameter_list|)
block|{
specifier|const
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
specifier|const
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
operator|!
name|ct
operator|||
name|type
operator|<
name|QMetaType
operator|::
name|User
argument_list|)
condition|)
return|return
literal|0
return|;
name|QReadLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|ct
operator|->
name|count
argument_list|()
operator|<=
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|ct
operator|->
name|at
argument_list|(
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
operator|.
name|metaObject
return|;
block|}
block|}
class|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 5.0      Returns QMetaObject of a given \a type, if the \a type is a pointer to type derived from QObject. */
end_comment
begin_function
DECL|function|metaObjectForType
specifier|const
name|QMetaObject
modifier|*
name|QMetaType
operator|::
name|metaObjectForType
parameter_list|(
name|int
name|type
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|MetaObject
name|mo
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
name|QMetaTypeSwitcher
operator|::
name|switcher
argument_list|<
specifier|const
name|QMetaObject
operator|*
argument_list|>
argument_list|(
name|mo
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \fn int qRegisterMetaType(const char *typeName)     \relates QMetaType     \threadsafe      Registers the type name \a typeName for the type \c{T}. Returns     the internal ID used by QMetaType. Any class or struct that has a     public default constructor, a public copy constructor and a public     destructor can be registered.      This function requires that \c{T} is a fully defined type at the point     where the function is called. For pointer types, it also requires that the     pointed to type is fully defined. Use Q_DECLARE_OPAQUE_POINTER() to be able     to register pointers to forward declared types.      After a type has been registered, you can create and destroy     objects of that type dynamically at run-time.      This example registers the class \c{MyClass}:      \snippet code/src_corelib_kernel_qmetatype.cpp 4      This function is useful to register typedefs so they can be used     by QMetaProperty, or in QueuedConnections      \snippet code/src_corelib_kernel_qmetatype.cpp 9      \warning This function is useful only for registering an alias (typedef)     for every other use case Q_DECLARE_METATYPE and qMetaTypeId() should be used instead.      \sa qRegisterMetaTypeStreamOperators(), QMetaType::isRegistered(),         Q_DECLARE_METATYPE() */
end_comment
begin_comment
comment|/*!     \fn void qRegisterMetaTypeStreamOperators(const char *typeName)     \relates QMetaType     \threadsafe      Registers the stream operators for the type \c{T} called \a     typeName.      Afterward, the type can be streamed using QMetaType::load() and     QMetaType::save(). These functions are used when streaming a     QVariant.      \snippet code/src_corelib_kernel_qmetatype.cpp 5      The stream operators should have the following signatures:      \snippet code/src_corelib_kernel_qmetatype.cpp 6      \sa qRegisterMetaType(), QMetaType::isRegistered(), Q_DECLARE_METATYPE() */
end_comment
begin_comment
comment|/*! \typedef QMetaType::Deleter     \internal */
end_comment
begin_comment
comment|/*! \typedef QMetaType::Creator     \internal */
end_comment
begin_comment
comment|/*! \typedef QMetaType::SaveOperator     \internal */
end_comment
begin_comment
comment|/*! \typedef QMetaType::LoadOperator     \internal */
end_comment
begin_comment
comment|/*! \typedef QMetaType::Destructor     \internal */
end_comment
begin_comment
comment|/*! \typedef QMetaType::Constructor     \internal */
end_comment
begin_comment
comment|/*!     \fn int qRegisterMetaType()     \relates QMetaType     \threadsafe     \since 4.2      Call this function to register the type \c T. \c T must be declared with     Q_DECLARE_METATYPE(). Returns the meta type Id.      Example:      \snippet code/src_corelib_kernel_qmetatype.cpp 7      This function requires that \c{T} is a fully defined type at the point     where the function is called. For pointer types, it also requires that the     pointed to type is fully defined. Use Q_DECLARE_OPAQUE_POINTER() to be able     to register pointers to forward declared types.      After a type has been registered, you can create and destroy     objects of that type dynamically at run-time.      To use the type \c T in QVariant, using Q_DECLARE_METATYPE() is     sufficient. To use the type \c T in queued signal and slot connections,     \c{qRegisterMetaType<T>()} must be called before the first connection     is established.      Also, to use type \c T with the QObject::property() API,     \c{qRegisterMetaType<T>()} must be called before it is used, typically     in the constructor of the class that uses \c T, or in the \c{main()}     function.      \sa Q_DECLARE_METATYPE()  */
end_comment
begin_comment
comment|/*!     \fn int qMetaTypeId()     \relates QMetaType     \threadsafe     \since 4.1      Returns the meta type id of type \c T at compile time. If the     type was not declared with Q_DECLARE_METATYPE(), compilation will     fail.      Typical usage:      \snippet code/src_corelib_kernel_qmetatype.cpp 8      QMetaType::type() returns the same ID as qMetaTypeId(), but does     a lookup at runtime based on the name of the type.     QMetaType::type() is a bit slower, but compilation succeeds if a     type is not registered.      \sa Q_DECLARE_METATYPE(), QMetaType::type() */
end_comment
begin_namespace
namespace|namespace
block|{
DECL|class|TypeInfo
class|class
name|TypeInfo
block|{
template|template
parameter_list|<
name|typename
name|T
parameter_list|,
name|bool
name|IsAcceptedType
init|=
name|DefinedTypesFilter
operator|::
name|Acceptor
argument_list|<
name|T
argument_list|>
operator|::
name|IsAccepted
parameter_list|>
struct|struct
DECL|struct|TypeInfoImpl
name|TypeInfoImpl
block|{
DECL|function|TypeInfoImpl
name|TypeInfoImpl
parameter_list|(
specifier|const
name|uint
comment|/* type */
parameter_list|,
name|QMetaTypeInterface
modifier|&
name|info
parameter_list|)
block|{
name|QMetaTypeInterface
name|tmp
init|=
name|QT_METATYPE_INTERFACE_INIT_NO_DATASTREAM
argument_list|(
name|T
argument_list|)
decl_stmt|;
name|info
operator|=
name|tmp
expr_stmt|;
block|}
block|}
struct|;
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
struct|struct
DECL|struct|TypeInfoImpl
name|TypeInfoImpl
argument_list|<
name|T
argument_list|,
comment|/* IsAcceptedType = */
literal|false
argument_list|>
block|{
DECL|function|TypeInfoImpl
name|TypeInfoImpl
parameter_list|(
specifier|const
name|uint
name|type
parameter_list|,
name|QMetaTypeInterface
modifier|&
name|info
parameter_list|)
block|{
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsGui
condition|)
block|{
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|qMetaTypeGuiHelper
argument_list|)
condition|)
name|info
operator|=
name|qMetaTypeGuiHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstGuiType
index|]
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|QModulesPrivate
operator|::
name|QTypeModuleInfo
argument_list|<
name|T
argument_list|>
operator|::
name|IsWidget
condition|)
block|{
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|qMetaTypeWidgetsHelper
argument_list|)
condition|)
name|info
operator|=
name|qMetaTypeWidgetsHelper
index|[
name|type
operator|-
name|QMetaType
operator|::
name|FirstWidgetsType
index|]
expr_stmt|;
return|return;
block|}
block|}
block|}
struct|;
public|public:
DECL|member|info
name|QMetaTypeInterface
name|info
decl_stmt|;
DECL|function|TypeInfo
name|TypeInfo
parameter_list|(
specifier|const
name|uint
name|type
parameter_list|)
member_init_list|:
name|m_type
argument_list|(
name|type
argument_list|)
block|{
name|QMetaTypeInterface
name|tmp
init|=
name|QT_METATYPE_INTERFACE_INIT_EMPTY
argument_list|()
decl_stmt|;
name|info
operator|=
name|tmp
expr_stmt|;
block|}
template|template
parameter_list|<
name|typename
name|T
parameter_list|>
DECL|function|delegate
name|void
name|delegate
parameter_list|(
specifier|const
name|T
modifier|*
parameter_list|)
block|{
name|TypeInfoImpl
argument_list|<
name|T
argument_list|>
argument_list|(
name|m_type
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
DECL|function|delegate
name|void
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|UnknownType
modifier|*
parameter_list|)
block|{}
DECL|function|delegate
name|void
name|delegate
parameter_list|(
specifier|const
name|QMetaTypeSwitcher
operator|::
name|NotBuiltinType
modifier|*
parameter_list|)
block|{
name|customTypeInfo
argument_list|(
name|m_type
argument_list|)
expr_stmt|;
block|}
private|private:
DECL|function|customTypeInfo
name|void
name|customTypeInfo
parameter_list|(
specifier|const
name|uint
name|type
parameter_list|)
block|{
specifier|const
name|QVector
argument_list|<
name|QCustomTypeInfo
argument_list|>
modifier|*
specifier|const
name|ct
init|=
name|customTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
operator|!
name|ct
argument_list|)
condition|)
return|return;
name|QReadLocker
name|locker
argument_list|(
name|customTypesLock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|uint
argument_list|(
name|ct
operator|->
name|count
argument_list|()
argument_list|)
operator|>
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
condition|)
name|info
operator|=
name|ct
operator|->
name|at
argument_list|(
name|type
operator|-
name|QMetaType
operator|::
name|User
argument_list|)
expr_stmt|;
block|}
DECL|member|m_type
specifier|const
name|uint
name|m_type
decl_stmt|;
block|}
class|;
block|}
end_namespace
begin_comment
comment|// namespace
end_comment
begin_comment
comment|/*!     \fn QMetaType QMetaType::typeInfo(const int type)     \internal */
end_comment
begin_function
DECL|function|typeInfo
name|QMetaType
name|QMetaType
operator|::
name|typeInfo
parameter_list|(
specifier|const
name|int
name|type
parameter_list|)
block|{
name|TypeInfo
name|typeInfo
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|QMetaTypeSwitcher
operator|::
name|switcher
argument_list|<
name|void
argument_list|>
argument_list|(
name|typeInfo
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|typeInfo
operator|.
name|info
operator|.
name|creator
condition|?
name|QMetaType
argument_list|(
name|QMetaType
operator|::
name|NoExtensionFlags
argument_list|,
cast|static_cast
argument_list|<
specifier|const
name|QMetaTypeInterface
operator|*
argument_list|>
argument_list|(
literal|0
argument_list|)
comment|// typeInfo::info is a temporary variable, we can't return address of it.
argument_list|,
name|typeInfo
operator|.
name|info
operator|.
name|creator
argument_list|,
name|typeInfo
operator|.
name|info
operator|.
name|deleter
argument_list|,
name|typeInfo
operator|.
name|info
operator|.
name|saveOp
argument_list|,
name|typeInfo
operator|.
name|info
operator|.
name|loadOp
argument_list|,
name|typeInfo
operator|.
name|info
operator|.
name|constructor
argument_list|,
name|typeInfo
operator|.
name|info
operator|.
name|destructor
argument_list|,
name|typeInfo
operator|.
name|info
operator|.
name|size
argument_list|,
name|typeInfo
operator|.
name|info
operator|.
name|flags
argument_list|,
name|type
argument_list|,
name|typeInfo
operator|.
name|info
operator|.
name|metaObject
argument_list|)
else|:
name|QMetaType
argument_list|(
name|UnknownType
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!      \fn QMetaType::QMetaType(const int typeId)      \since 5.0       Constructs a QMetaType object that contains all information about type \a typeId. */
end_comment
begin_constructor
DECL|function|QMetaType
name|QMetaType
operator|::
name|QMetaType
parameter_list|(
specifier|const
name|int
name|typeId
parameter_list|)
member_init_list|:
name|m_typeId
argument_list|(
name|typeId
argument_list|)
block|{
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|typeId
operator|==
name|UnknownType
argument_list|)
condition|)
block|{
comment|// Constructs invalid QMetaType instance.
name|m_extensionFlags
operator|=
literal|0xffffffff
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|isValid
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO it can be better.
operator|*
name|this
operator|=
name|QMetaType
operator|::
name|typeInfo
argument_list|(
name|typeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_typeId
operator|==
name|UnknownType
condition|)
name|m_extensionFlags
operator|=
literal|0xffffffff
expr_stmt|;
elseif|else
if|if
condition|(
name|m_typeId
operator|==
name|QMetaType
operator|::
name|Void
condition|)
name|m_extensionFlags
operator|=
name|CreateEx
operator||
name|DestroyEx
operator||
name|ConstructEx
operator||
name|DestructEx
expr_stmt|;
block|}
block|}
end_constructor
begin_comment
comment|/*!      \fn QMetaType::QMetaType(const QMetaType&other)      \since 5.0       Copy constructs a QMetaType object. */
end_comment
begin_constructor
DECL|function|QMetaType
name|QMetaType
operator|::
name|QMetaType
parameter_list|(
specifier|const
name|QMetaType
modifier|&
name|other
parameter_list|)
member_init_list|:
name|m_creator
argument_list|(
name|other
operator|.
name|m_creator
argument_list|)
member_init_list|,
name|m_deleter
argument_list|(
name|other
operator|.
name|m_deleter
argument_list|)
member_init_list|,
name|m_saveOp
argument_list|(
name|other
operator|.
name|m_saveOp
argument_list|)
member_init_list|,
name|m_loadOp
argument_list|(
name|other
operator|.
name|m_loadOp
argument_list|)
member_init_list|,
name|m_constructor
argument_list|(
name|other
operator|.
name|m_constructor
argument_list|)
member_init_list|,
name|m_destructor
argument_list|(
name|other
operator|.
name|m_destructor
argument_list|)
member_init_list|,
name|m_extension
argument_list|(
name|other
operator|.
name|m_extension
argument_list|)
comment|// space reserved for future use
member_init_list|,
name|m_size
argument_list|(
name|other
operator|.
name|m_size
argument_list|)
member_init_list|,
name|m_typeFlags
argument_list|(
name|other
operator|.
name|m_typeFlags
argument_list|)
member_init_list|,
name|m_extensionFlags
argument_list|(
name|other
operator|.
name|m_extensionFlags
argument_list|)
member_init_list|,
name|m_typeId
argument_list|(
name|other
operator|.
name|m_typeId
argument_list|)
member_init_list|,
name|m_metaObject
argument_list|(
name|other
operator|.
name|m_metaObject
argument_list|)
block|{}
end_constructor
begin_function
DECL|function|operator =
name|QMetaType
modifier|&
name|QMetaType
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QMetaType
modifier|&
name|other
parameter_list|)
block|{
name|m_creator
operator|=
name|other
operator|.
name|m_creator
expr_stmt|;
name|m_deleter
operator|=
name|other
operator|.
name|m_deleter
expr_stmt|;
name|m_saveOp
operator|=
name|other
operator|.
name|m_saveOp
expr_stmt|;
name|m_loadOp
operator|=
name|other
operator|.
name|m_loadOp
expr_stmt|;
name|m_constructor
operator|=
name|other
operator|.
name|m_constructor
expr_stmt|;
name|m_destructor
operator|=
name|other
operator|.
name|m_destructor
expr_stmt|;
name|m_size
operator|=
name|other
operator|.
name|m_size
expr_stmt|;
name|m_typeFlags
operator|=
name|other
operator|.
name|m_typeFlags
expr_stmt|;
name|m_extensionFlags
operator|=
name|other
operator|.
name|m_extensionFlags
expr_stmt|;
name|m_extension
operator|=
name|other
operator|.
name|m_extension
expr_stmt|;
comment|// space reserved for future use
name|m_typeId
operator|=
name|other
operator|.
name|m_typeId
expr_stmt|;
name|m_metaObject
operator|=
name|other
operator|.
name|m_metaObject
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QMetaType::ctor(const QMetaTypeInterface *info)     \internal      Method used for future binary compatible extensions.  The function may be     called from within QMetaType's constructor to force a library call from     inlined code. */
end_comment
begin_function
DECL|function|ctor
name|void
name|QMetaType
operator|::
name|ctor
parameter_list|(
specifier|const
name|QMetaTypeInterface
modifier|*
name|info
parameter_list|)
block|{
comment|// Special case for Void type, the type is valid but not constructible.
comment|// In future we may consider to remove this assert and extend this function to initialize
comment|// differently m_extensionFlags for different types. Currently it is not needed.
name|Q_ASSERT
argument_list|(
name|m_typeId
operator|==
name|QMetaType
operator|::
name|Void
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|m_extensionFlags
operator|=
name|CreateEx
operator||
name|DestroyEx
operator||
name|ConstructEx
operator||
name|DestructEx
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void QMetaType::dtor()     \internal      Method used for future binary compatible extensions.  The function may be     called from within QMetaType's destructor to force a library call from     inlined code. */
end_comment
begin_function
DECL|function|dtor
name|void
name|QMetaType
operator|::
name|dtor
parameter_list|()
block|{}
end_function
begin_comment
comment|/*!     \fn void *QMetaType::createExtended(const void *copy) const     \internal      Method used for future binary compatible extensions. The function may be called     during QMetaType::create to force library call from inlined code. */
end_comment
begin_function
DECL|function|createExtended
name|void
modifier|*
name|QMetaType
operator|::
name|createExtended
parameter_list|(
specifier|const
name|void
modifier|*
name|copy
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QMetaType::destroyExtended(void *data) const     \internal      Method used for future binary compatible extensions. The function may be called     during QMetaType::destroy to force library call from inlined code. */
end_comment
begin_function
DECL|function|destroyExtended
name|void
name|QMetaType
operator|::
name|destroyExtended
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn void *QMetaType::constructExtended(void *where, const void *copy) const     \internal      Method used for future binary compatible extensions. The function may be called     during QMetaType::construct to force library call from inlined code. */
end_comment
begin_function
DECL|function|constructExtended
name|void
modifier|*
name|QMetaType
operator|::
name|constructExtended
parameter_list|(
name|void
modifier|*
name|where
parameter_list|,
specifier|const
name|void
modifier|*
name|copy
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|where
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QMetaType::destructExtended(void *data) const     \internal      Method used for future binary compatible extensions. The function may be called     during QMetaType::destruct to force library call from inlined code. */
end_comment
begin_function
DECL|function|destructExtended
name|void
name|QMetaType
operator|::
name|destructExtended
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn uint QMetaType::sizeExtended() const     \internal      Method used for future binary compatible extensions. The function may be     called from within QMetaType::size to force a library call from     inlined code. */
end_comment
begin_function
DECL|function|sizeExtended
name|uint
name|QMetaType
operator|::
name|sizeExtended
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QMetaType::TypeFlags QMetaType::flagsExtended() const     \internal      Method used for future binary compatible extensions.  The function may be     called from within QMetaType::flags to force a library call from     inlined code. */
end_comment
begin_function
DECL|function|flagsExtended
name|QMetaType
operator|::
name|TypeFlags
name|QMetaType
operator|::
name|flagsExtended
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \brief QMetaType::metaObjectExtended     \internal      Method used for future binary compatible extensions. The function may be     called from within QMetaType::metaObject to force a library call from     inlined code. */
end_comment
begin_function
DECL|function|metaObjectExtended
specifier|const
name|QMetaObject
modifier|*
name|QMetaType
operator|::
name|metaObjectExtended
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_namespace
DECL|namespace|QtPrivate
namespace|namespace
name|QtPrivate
block|{
DECL|function|metaObjectForQWidget
specifier|const
name|QMetaObject
modifier|*
name|metaObjectForQWidget
parameter_list|()
block|{
if|if
condition|(
operator|!
name|qMetaTypeWidgetsHelper
condition|)
return|return
literal|0
return|;
return|return
name|qMetaObjectWidgetsHelper
return|;
block|}
block|}
end_namespace
begin_namespace
DECL|namespace|QtMetaTypePrivate
namespace|namespace
name|QtMetaTypePrivate
block|{
DECL|member|true_element
specifier|const
name|bool
name|VectorBoolElements
operator|::
name|true_element
init|=
literal|true
decl_stmt|;
DECL|member|false_element
specifier|const
name|bool
name|VectorBoolElements
operator|::
name|false_element
init|=
literal|false
decl_stmt|;
block|}
end_namespace
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
