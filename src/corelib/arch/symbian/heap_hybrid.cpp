begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qt_hybridheap_symbian_p.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QT_USE_NEW_SYMBIAN_ALLOCATOR
end_ifdef
begin_comment
comment|// if non zero this causes the iSlabs to be configured only when the chunk size exceeds this level
end_comment
begin_define
DECL|macro|DELAYED_SLAB_THRESHOLD
define|#
directive|define
name|DELAYED_SLAB_THRESHOLD
value|(64*1024)
end_define
begin_comment
DECL|macro|DELAYED_SLAB_THRESHOLD
comment|// 64KB seems about right based on trace data
end_comment
begin_define
DECL|macro|SLAB_CONFIG
define|#
directive|define
name|SLAB_CONFIG
value|0x3fff
end_define
begin_comment
DECL|macro|SLAB_CONFIG
comment|// Use all slab sizes 4,8..56 bytes. This is more efficient for large heaps as Qt tends to have
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|_DEBUG
end_ifdef
begin_define
DECL|macro|__SIMULATE_ALLOC_FAIL
define|#
directive|define
name|__SIMULATE_ALLOC_FAIL
parameter_list|(
name|s
parameter_list|)
value|if (CheckForSimulatedAllocFail()) {s}
end_define
begin_define
DECL|macro|__ALLOC_DEBUG_HEADER
define|#
directive|define
name|__ALLOC_DEBUG_HEADER
parameter_list|(
name|s
parameter_list|)
value|(s += EDebugHdrSize)
end_define
begin_define
DECL|macro|__SET_DEBUG_DATA
define|#
directive|define
name|__SET_DEBUG_DATA
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|,
name|c
parameter_list|)
value|(((SDebugCell*)(p))->nestingLevel = (n), ((SDebugCell*)(p))->allocCount = (c))
end_define
begin_define
DECL|macro|__GET_USER_DATA_BFR
define|#
directive|define
name|__GET_USER_DATA_BFR
parameter_list|(
name|p
parameter_list|)
value|((p!=0) ? (TUint8*)(p) + EDebugHdrSize : NULL)
end_define
begin_define
DECL|macro|__GET_DEBUG_DATA_BFR
define|#
directive|define
name|__GET_DEBUG_DATA_BFR
parameter_list|(
name|p
parameter_list|)
value|((p!=0) ? (TUint8*)(p) - EDebugHdrSize : NULL)
end_define
begin_define
DECL|macro|__ZAP_CELL
define|#
directive|define
name|__ZAP_CELL
parameter_list|(
name|p
parameter_list|)
value|memset( (TUint8*)p, 0xde, (AllocLen(__GET_USER_DATA_BFR(p))+EDebugHdrSize))
end_define
begin_define
DECL|macro|__DEBUG_SAVE
define|#
directive|define
name|__DEBUG_SAVE
parameter_list|(
name|p
parameter_list|)
value|TInt dbgNestLevel = ((SDebugCell*)p)->nestingLevel
end_define
begin_define
DECL|macro|__DEBUG_RESTORE
define|#
directive|define
name|__DEBUG_RESTORE
parameter_list|(
name|p
parameter_list|)
value|if (p) {((SDebugCell*)p)->nestingLevel = dbgNestLevel;}
end_define
begin_define
DECL|macro|__DEBUG_HDR_SIZE
define|#
directive|define
name|__DEBUG_HDR_SIZE
value|EDebugHdrSize
end_define
begin_define
DECL|macro|__REMOVE_DBG_HDR
define|#
directive|define
name|__REMOVE_DBG_HDR
parameter_list|(
name|n
parameter_list|)
value|(n*EDebugHdrSize)
end_define
begin_define
DECL|macro|__GET_AVAIL_BLOCK_SIZE
define|#
directive|define
name|__GET_AVAIL_BLOCK_SIZE
parameter_list|(
name|s
parameter_list|)
value|( (s<EDebugHdrSize) ? 0 : s-EDebugHdrSize )
end_define
begin_define
DECL|macro|__UPDATE_ALLOC_COUNT
define|#
directive|define
name|__UPDATE_ALLOC_COUNT
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|c
parameter_list|)
value|if (o!=n&& n) {((SDebugCell*)n)->allocCount = (c);}
end_define
begin_define
DECL|macro|__INIT_COUNTERS
define|#
directive|define
name|__INIT_COUNTERS
parameter_list|(
name|i
parameter_list|)
value|iCellCount=i,iTotalAllocSize=i
end_define
begin_define
DECL|macro|__INCREMENT_COUNTERS
define|#
directive|define
name|__INCREMENT_COUNTERS
parameter_list|(
name|p
parameter_list|)
value|iCellCount++, iTotalAllocSize += AllocLen(p)
end_define
begin_define
DECL|macro|__DECREMENT_COUNTERS
define|#
directive|define
name|__DECREMENT_COUNTERS
parameter_list|(
name|p
parameter_list|)
value|iCellCount--, iTotalAllocSize -= AllocLen(p)
end_define
begin_define
DECL|macro|__UPDATE_TOTAL_ALLOC
define|#
directive|define
name|__UPDATE_TOTAL_ALLOC
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|iTotalAllocSize += (AllocLen(__GET_USER_DATA_BFR(p)) - s)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|__SIMULATE_ALLOC_FAIL
define|#
directive|define
name|__SIMULATE_ALLOC_FAIL
parameter_list|(
name|s
parameter_list|)
end_define
begin_define
DECL|macro|__ALLOC_DEBUG_HEADER
define|#
directive|define
name|__ALLOC_DEBUG_HEADER
parameter_list|(
name|s
parameter_list|)
end_define
begin_define
DECL|macro|__SET_DEBUG_DATA
define|#
directive|define
name|__SET_DEBUG_DATA
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|,
name|c
parameter_list|)
end_define
begin_define
DECL|macro|__GET_USER_DATA_BFR
define|#
directive|define
name|__GET_USER_DATA_BFR
parameter_list|(
name|p
parameter_list|)
value|(p)
end_define
begin_define
DECL|macro|__GET_DEBUG_DATA_BFR
define|#
directive|define
name|__GET_DEBUG_DATA_BFR
parameter_list|(
name|p
parameter_list|)
value|(p)
end_define
begin_define
DECL|macro|__ZAP_CELL
define|#
directive|define
name|__ZAP_CELL
parameter_list|(
name|p
parameter_list|)
end_define
begin_define
DECL|macro|__DEBUG_SAVE
define|#
directive|define
name|__DEBUG_SAVE
parameter_list|(
name|p
parameter_list|)
end_define
begin_define
DECL|macro|__DEBUG_RESTORE
define|#
directive|define
name|__DEBUG_RESTORE
parameter_list|(
name|p
parameter_list|)
end_define
begin_define
DECL|macro|__DEBUG_HDR_SIZE
define|#
directive|define
name|__DEBUG_HDR_SIZE
value|0
end_define
begin_define
DECL|macro|__REMOVE_DBG_HDR
define|#
directive|define
name|__REMOVE_DBG_HDR
parameter_list|(
name|n
parameter_list|)
value|0
end_define
begin_define
DECL|macro|__GET_AVAIL_BLOCK_SIZE
define|#
directive|define
name|__GET_AVAIL_BLOCK_SIZE
parameter_list|(
name|s
parameter_list|)
value|(s)
end_define
begin_define
DECL|macro|__UPDATE_ALLOC_COUNT
define|#
directive|define
name|__UPDATE_ALLOC_COUNT
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|c
parameter_list|)
end_define
begin_define
DECL|macro|__INIT_COUNTERS
define|#
directive|define
name|__INIT_COUNTERS
parameter_list|(
name|i
parameter_list|)
value|iCellCount=i,iTotalAllocSize=i
end_define
begin_define
DECL|macro|__INCREMENT_COUNTERS
define|#
directive|define
name|__INCREMENT_COUNTERS
parameter_list|(
name|p
parameter_list|)
end_define
begin_define
DECL|macro|__DECREMENT_COUNTERS
define|#
directive|define
name|__DECREMENT_COUNTERS
parameter_list|(
name|p
parameter_list|)
end_define
begin_define
DECL|macro|__UPDATE_TOTAL_ALLOC
define|#
directive|define
name|__UPDATE_TOTAL_ALLOC
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|MEMORY_MONITORED
define|#
directive|define
name|MEMORY_MONITORED
value|(iFlags& EMonitorMemory)
end_define
begin_define
DECL|macro|GM
define|#
directive|define
name|GM
value|(&iGlobalMallocState)
end_define
begin_define
DECL|macro|IS_FIXED_HEAP
define|#
directive|define
name|IS_FIXED_HEAP
value|(iFlags& EFixedSize)
end_define
begin_define
DECL|macro|__INIT_COUNTERS
define|#
directive|define
name|__INIT_COUNTERS
parameter_list|(
name|i
parameter_list|)
value|iCellCount=i,iTotalAllocSize=i
end_define
begin_define
DECL|macro|__POWER_OF_2
define|#
directive|define
name|__POWER_OF_2
parameter_list|(
name|x
parameter_list|)
value|(!((x)&((x)-1)))
end_define
begin_define
DECL|macro|__DL_BFR_CHECK
define|#
directive|define
name|__DL_BFR_CHECK
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
define|\
value|if ( MEMORY_MONITORED ) \              if ( !IS_ALIGNED(P) || ((TUint8*)(P)<M->iSeg.iBase) || ((TUint8*)(P)>(M->iSeg.iBase+M->iSeg.iSize))) \                   BTraceContext12(BTrace::EHeap, BTrace::EHeapCorruption, (TUint32)this, (TUint32)P, (TUint32)0), HEAP_PANIC(ETHeapBadCellAddress); \ 			 else DoCheckInuseChunk(M, MEM2CHUNK(P))
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
end_ifndef
begin_define
DECL|macro|__SLAB_BFR_CHECK
define|#
directive|define
name|__SLAB_BFR_CHECK
parameter_list|(
name|S
parameter_list|,
name|P
parameter_list|,
name|B
parameter_list|)
define|\
value|if ( MEMORY_MONITORED ) \ 		  if ( ((TUint32)P& 0x3) || ((TUint8*)P<iMemBase) || ((TUint8*)(P)>(TUint8*)this))  \ 			   BTraceContext12(BTrace::EHeap, BTrace::EHeapCorruption, (TUint32)this, (TUint32)P, (TUint32)S), HEAP_PANIC(ETHeapBadCellAddress); \ 		  else DoCheckSlab(S, EPartialFullSlab, P), BuildPartialSlabBitmap(B,S,P)
end_define
begin_define
DECL|macro|__PAGE_BFR_CHECK
define|#
directive|define
name|__PAGE_BFR_CHECK
parameter_list|(
name|P
parameter_list|)
define|\
value|if ( MEMORY_MONITORED ) \ 			if ( ((TUint32)P&  ((1<< iPageSize)-1)) || ((TUint8*)P<iMemBase) || ((TUint8*)(P)>(TUint8*)this))  \ 				BTraceContext12(BTrace::EHeap, BTrace::EHeapCorruption, (TUint32)this, (TUint32)P, (TUint32)0), HEAP_PANIC(ETHeapBadCellAddress)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef
begin_comment
comment|// This is required while we are still using VC6 to compile, so as to avoid warnings that cannot be fixed
end_comment
begin_comment
comment|// without having to edit the original Doug Lea source.  The 4146 warnings are due to the original code having
end_comment
begin_comment
comment|// a liking for negating unsigned numbers and the 4127 warnings are due to the original code using the RTCHECK
end_comment
begin_comment
comment|// macro with values that are always defined as 1.  It is better to turn these warnings off than to introduce
end_comment
begin_comment
comment|// diffs between the original Doug Lea implementation and our adaptation of it
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4146
name|)
end_pragma
begin_comment
comment|/* unary minus operator applied to unsigned type, result still unsigned */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma
begin_comment
comment|/* conditional expression is constant */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// _MSC_VER
end_comment
begin_comment
comment|/** @SYMPatchable @publishedPartner @released  Defines the minimum cell size of  a heap.  The constant can be changed at ROM build time using patchdata OBY keyword.  @deprecated Patching this constant no longer has any effect. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__X86GCC__
end_ifdef
begin_comment
comment|// For X86GCC we don't use the proper data import attribute
end_comment
begin_undef
DECL|macro|IMPORT_D
undef|#
directive|undef
name|IMPORT_D
end_undef
begin_comment
DECL|macro|IMPORT_D
comment|// since the constants are not really imported. GCC doesn't
end_comment
begin_define
DECL|macro|IMPORT_D
define|#
directive|define
name|IMPORT_D
end_define
begin_comment
DECL|macro|IMPORT_D
comment|// allow imports from self.
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|IMPORT_D
specifier|extern
specifier|const
name|TInt
name|KHeapMinCellSize
decl_stmt|;
end_decl_stmt
begin_comment
comment|/** @SYMPatchable @publishedPartner @released  This constant defines the ratio that determines the amount of hysteresis between heap growing and heap shrinking. It is a 32-bit fixed point number where the radix point is defined to be between bits 7 and 8 (where the LSB is bit 0) i.e. using standard notation, a Q8 or a fx24.8 fixed point number.  For example, for a ratio of 2.0, set KHeapShrinkHysRatio=0x200.  The heap shrinking hysteresis value is calculated to be: @code KHeapShrinkHysRatio*(iGrowBy>>8) @endcode where iGrowBy is a page aligned value set by the argument, aGrowBy, to the RHeap constructor. The default hysteresis value is iGrowBy bytes i.e. KHeapShrinkHysRatio=2.0.  Memory usage may be improved by reducing the heap shrinking hysteresis by setting 1.0< KHeapShrinkHysRatio< 2.0.  Heap shrinking hysteresis is disabled/removed when KHeapShrinkHysRatio<= 1.0.  The constant can be changed at ROM build time using patchdata OBY keyword. */
end_comment
begin_decl_stmt
name|IMPORT_D
specifier|extern
specifier|const
name|TInt
name|KHeapShrinkHysRatio
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|AllocLen
name|UEXPORT_C
name|TInt
name|RHeap
operator|::
name|AllocLen
parameter_list|(
specifier|const
name|TAny
modifier|*
name|aCell
parameter_list|)
specifier|const
block|{
specifier|const
name|MAllocator
modifier|*
name|m
init|=
name|this
decl_stmt|;
return|return
name|m
operator|->
name|AllocLen
argument_list|(
name|aCell
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|Alloc
name|UEXPORT_C
name|TAny
modifier|*
name|RHeap
operator|::
name|Alloc
parameter_list|(
name|TInt
name|aSize
parameter_list|)
block|{
specifier|const
name|MAllocator
modifier|*
name|m
init|=
name|this
decl_stmt|;
return|return
operator|(
operator|(
name|MAllocator
operator|*
operator|)
name|m
operator|)
operator|->
name|Alloc
argument_list|(
name|aSize
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|Free
name|UEXPORT_C
name|void
name|RHeap
operator|::
name|Free
parameter_list|(
name|TAny
modifier|*
name|aCell
parameter_list|)
block|{
specifier|const
name|MAllocator
modifier|*
name|m
init|=
name|this
decl_stmt|;
operator|(
operator|(
name|MAllocator
operator|*
operator|)
name|m
operator|)
operator|->
name|Free
argument_list|(
name|aCell
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ReAlloc
name|UEXPORT_C
name|TAny
modifier|*
name|RHeap
operator|::
name|ReAlloc
parameter_list|(
name|TAny
modifier|*
name|aCell
parameter_list|,
name|TInt
name|aSize
parameter_list|,
name|TInt
name|aMode
parameter_list|)
block|{
specifier|const
name|MAllocator
modifier|*
name|m
init|=
name|this
decl_stmt|;
return|return
operator|(
operator|(
name|MAllocator
operator|*
operator|)
name|m
operator|)
operator|->
name|ReAlloc
argument_list|(
name|aCell
argument_list|,
name|aSize
argument_list|,
name|aMode
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|DebugFunction
name|UEXPORT_C
name|TInt
name|RHeap
operator|::
name|DebugFunction
parameter_list|(
name|TInt
name|aFunc
parameter_list|,
name|TAny
modifier|*
name|a1
parameter_list|,
name|TAny
modifier|*
name|a2
parameter_list|)
block|{
specifier|const
name|MAllocator
modifier|*
name|m
init|=
name|this
decl_stmt|;
return|return
operator|(
operator|(
name|MAllocator
operator|*
operator|)
name|m
operator|)
operator|->
name|DebugFunction
argument_list|(
name|aFunc
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|Extension_
name|UEXPORT_C
name|TInt
name|RHeap
operator|::
name|Extension_
parameter_list|(
name|TUint
name|aExtensionId
parameter_list|,
name|TAny
modifier|*
modifier|&
name|a0
parameter_list|,
name|TAny
modifier|*
name|a1
parameter_list|)
block|{
specifier|const
name|MAllocator
modifier|*
name|m
init|=
name|this
decl_stmt|;
return|return
operator|(
operator|(
name|MAllocator
operator|*
operator|)
name|m
operator|)
operator|->
name|Extension_
argument_list|(
name|aExtensionId
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
end_ifndef
begin_function
DECL|function|AllocSize
name|EXPORT_C
name|TInt
name|RHeap
operator|::
name|AllocSize
parameter_list|(
name|TInt
modifier|&
name|aTotalAllocSize
parameter_list|)
specifier|const
block|{
specifier|const
name|MAllocator
modifier|*
name|m
init|=
name|this
decl_stmt|;
return|return
name|m
operator|->
name|AllocSize
argument_list|(
name|aTotalAllocSize
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|Available
name|EXPORT_C
name|TInt
name|RHeap
operator|::
name|Available
parameter_list|(
name|TInt
modifier|&
name|aBiggestBlock
parameter_list|)
specifier|const
block|{
specifier|const
name|MAllocator
modifier|*
name|m
init|=
name|this
decl_stmt|;
return|return
name|m
operator|->
name|Available
argument_list|(
name|aBiggestBlock
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|Reset
name|EXPORT_C
name|void
name|RHeap
operator|::
name|Reset
parameter_list|()
block|{
specifier|const
name|MAllocator
modifier|*
name|m
init|=
name|this
decl_stmt|;
operator|(
operator|(
name|MAllocator
operator|*
operator|)
name|m
operator|)
operator|->
name|Reset
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Compress
name|EXPORT_C
name|TInt
name|RHeap
operator|::
name|Compress
parameter_list|()
block|{
specifier|const
name|MAllocator
modifier|*
name|m
init|=
name|this
decl_stmt|;
return|return
operator|(
operator|(
name|MAllocator
operator|*
operator|)
name|m
operator|)
operator|->
name|Compress
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|RHybridHeap
name|RHybridHeap
operator|::
name|RHybridHeap
parameter_list|()
block|{
comment|// This initialisation cannot be done in RHeap() for compatibility reasons
name|iMaxLength
operator|=
name|iChunkHandle
operator|=
name|iNestingLevel
operator|=
literal|0
expr_stmt|;
name|iTop
operator|=
name|NULL
expr_stmt|;
name|iFailType
operator|=
name|ENone
expr_stmt|;
name|iTestData
operator|=
name|NULL
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|operator delete
name|void
name|RHybridHeap
operator|::
name|operator
name|delete
parameter_list|(
name|TAny
modifier|*
parameter_list|,
name|TAny
modifier|*
parameter_list|)
comment|/** Called if constructor issued by operator new(TUint aSize, TAny* aBase) throws exception. This is dummy as corresponding new operator does not allocate memory. */
block|{}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
end_ifndef
begin_function
DECL|function|Lock
name|void
name|RHybridHeap
operator|::
name|Lock
parameter_list|()
specifier|const
comment|/**    @internalComponent */
block|{
operator|(
operator|(
name|RFastLock
operator|&
operator|)
name|iLock
operator|)
operator|.
name|Wait
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Unlock
name|void
name|RHybridHeap
operator|::
name|Unlock
parameter_list|()
specifier|const
comment|/**    @internalComponent */
block|{
operator|(
operator|(
name|RFastLock
operator|&
operator|)
name|iLock
operator|)
operator|.
name|Signal
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ChunkHandle
name|TInt
name|RHybridHeap
operator|::
name|ChunkHandle
parameter_list|()
specifier|const
comment|/**    @internalComponent */
block|{
return|return
name|iChunkHandle
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|//
end_comment
begin_comment
comment|//  This method is implemented in kheap.cpp
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//void RHybridHeap::Lock() const
end_comment
begin_comment
comment|/**    @internalComponent */
end_comment
begin_comment
comment|//   {;}
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//  This method is implemented in kheap.cpp
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//void RHybridHeap::Unlock() const
end_comment
begin_comment
comment|/**    @internalComponent */
end_comment
begin_comment
comment|//   {;}
end_comment
begin_function
DECL|function|ChunkHandle
name|TInt
name|RHybridHeap
operator|::
name|ChunkHandle
parameter_list|()
specifier|const
comment|/**    @internalComponent */
block|{
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|RHybridHeap
name|RHybridHeap
operator|::
name|RHybridHeap
parameter_list|(
name|TInt
name|aChunkHandle
parameter_list|,
name|TInt
name|aOffset
parameter_list|,
name|TInt
name|aMinLength
parameter_list|,
name|TInt
name|aMaxLength
parameter_list|,
name|TInt
name|aGrowBy
parameter_list|,
name|TInt
name|aAlign
parameter_list|,
name|TBool
name|aSingleThread
parameter_list|,
name|TBool
name|aDLOnly
parameter_list|,
name|TBool
name|aUseAdjust
parameter_list|)
comment|/** Constructor for a non fixed heap.  Unlike the fixed heap, this heap is quite flexible in terms of its minimum and maximum lengths and in that it can use the hybrid allocator if all of its requirements are met. */
member_init_list|:
name|iOffset
argument_list|(
name|aOffset
argument_list|)
member_init_list|,
name|iChunkSize
argument_list|(
name|aMinLength
argument_list|)
block|{
name|__ASSERT_ALWAYS
argument_list|(
name|iOffset
operator|>=
literal|0
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapNewBadOffset
argument_list|)
argument_list|)
expr_stmt|;
name|iChunkHandle
operator|=
name|aChunkHandle
expr_stmt|;
name|iMinLength
operator|=
name|aMinLength
expr_stmt|;
name|iMaxLength
operator|=
name|aMaxLength
expr_stmt|;
comment|// If the user has explicitly specified 0 as the aGrowBy value, set it to 1 so that it will be rounded up to the nearst page size
if|if
condition|(
name|aGrowBy
operator|==
literal|0
condition|)
name|aGrowBy
operator|=
literal|1
expr_stmt|;
name|GET_PAGE_SIZE
argument_list|(
name|iPageSize
argument_list|)
expr_stmt|;
name|iGrowBy
operator|=
name|_ALIGN_UP
argument_list|(
name|aGrowBy
argument_list|,
name|iPageSize
argument_list|)
expr_stmt|;
name|Construct
argument_list|(
name|aSingleThread
argument_list|,
name|aDLOnly
argument_list|,
name|aUseAdjust
argument_list|,
name|aAlign
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|RHybridHeap
name|RHybridHeap
operator|::
name|RHybridHeap
parameter_list|(
name|TInt
name|aMaxLength
parameter_list|,
name|TInt
name|aAlign
parameter_list|,
name|TBool
name|aSingleThread
parameter_list|)
comment|/** Constructor for a fixed heap.  We have restrictions in that we have fixed minimum and maximum lengths and cannot grow and we only use DL allocator. */
member_init_list|:
name|iOffset
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|iChunkSize
argument_list|(
name|aMaxLength
argument_list|)
block|{
name|iChunkHandle
operator|=
name|NULL
expr_stmt|;
name|iMinLength
operator|=
name|aMaxLength
expr_stmt|;
name|iMaxLength
operator|=
name|aMaxLength
expr_stmt|;
name|iGrowBy
operator|=
literal|0
expr_stmt|;
name|Construct
argument_list|(
name|aSingleThread
argument_list|,
name|ETrue
argument_list|,
name|ETrue
argument_list|,
name|aAlign
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
name|TAny
modifier|*
name|RHybridHeap
operator|::
name|operator
name|new
parameter_list|(
name|TUint
name|aSize
parameter_list|,
name|TAny
modifier|*
name|aBase
parameter_list|)
name|__NO_THROW
block|{
name|__ASSERT_ALWAYS
argument_list|(
name|aSize
operator|>=
sizeof|sizeof
argument_list|(
name|RHybridHeap
argument_list|)
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapNewBadSize
argument_list|)
argument_list|)
expr_stmt|;
name|RHybridHeap
modifier|*
name|h
init|=
operator|(
name|RHybridHeap
operator|*
operator|)
name|aBase
decl_stmt|;
name|h
operator|->
name|iBase
operator|=
operator|(
operator|(
name|TUint8
operator|*
operator|)
name|aBase
operator|)
operator|+
name|aSize
expr_stmt|;
return|return
name|aBase
return|;
block|}
end_function
begin_function
DECL|function|Construct
name|void
name|RHybridHeap
operator|::
name|Construct
parameter_list|(
name|TBool
name|aSingleThread
parameter_list|,
name|TBool
name|aDLOnly
parameter_list|,
name|TBool
name|aUseAdjust
parameter_list|,
name|TInt
name|aAlign
parameter_list|)
block|{
name|iAlign
operator|=
name|aAlign
condition|?
name|aAlign
else|:
name|RHybridHeap
operator|::
name|ECellAlignment
expr_stmt|;
name|__ASSERT_ALWAYS
argument_list|(
operator|(
name|TUint32
operator|)
name|iAlign
operator|>=
sizeof|sizeof
argument_list|(
name|TAny
operator|*
argument_list|)
operator|&&
name|__POWER_OF_2
argument_list|(
name|iAlign
argument_list|)
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapNewBadAlignment
argument_list|)
argument_list|)
expr_stmt|;
comment|// This initialisation cannot be done in RHeap() for compatibility reasons
name|iTop
operator|=
name|NULL
expr_stmt|;
name|iFailType
operator|=
name|ENone
expr_stmt|;
name|iNestingLevel
operator|=
literal|0
expr_stmt|;
name|iTestData
operator|=
name|NULL
expr_stmt|;
name|iHighWaterMark
operator|=
name|iMinLength
expr_stmt|;
name|iAllocCount
operator|=
literal|0
expr_stmt|;
name|iFlags
operator|=
name|aSingleThread
condition|?
name|ESingleThreaded
else|:
literal|0
expr_stmt|;
name|iGrowBy
operator|=
name|_ALIGN_UP
argument_list|(
name|iGrowBy
argument_list|,
name|iPageSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|iMinLength
operator|==
name|iMaxLength
condition|)
block|{
name|iFlags
operator||=
name|EFixedSize
expr_stmt|;
name|aDLOnly
operator|=
name|ETrue
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
ifdef|#
directive|ifdef
name|DELAYED_SLAB_THRESHOLD
name|iSlabInitThreshold
operator|=
name|DELAYED_SLAB_THRESHOLD
expr_stmt|;
else|#
directive|else
name|iSlabInitThreshold
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|// DELAYED_SLAB_THRESHOLD
name|iUseAdjust
operator|=
name|aUseAdjust
expr_stmt|;
name|iDLOnly
operator|=
name|aDLOnly
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|aUseAdjust
expr_stmt|;
endif|#
directive|endif
comment|// Initialise suballocators
comment|// if DL only is required then it cannot allocate slab or page memory
comment|// so these sub-allocators should be disabled. Otherwise initialise with default values
if|if
condition|(
name|aDLOnly
condition|)
block|{
name|Init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Init
argument_list|(
name|SLAB_CONFIG
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
name|TUint32
name|traceData
index|[
literal|4
index|]
decl_stmt|;
name|traceData
index|[
literal|0
index|]
operator|=
name|iMinLength
expr_stmt|;
name|traceData
index|[
literal|1
index|]
operator|=
name|iMaxLength
expr_stmt|;
name|traceData
index|[
literal|2
index|]
operator|=
name|iGrowBy
expr_stmt|;
name|traceData
index|[
literal|3
index|]
operator|=
name|iAlign
expr_stmt|;
name|BTraceContextN
argument_list|(
name|BTrace
operator|::
name|ETest1
argument_list|,
literal|90
argument_list|,
operator|(
name|TUint32
operator|)
name|this
argument_list|,
literal|11
argument_list|,
name|traceData
argument_list|,
sizeof|sizeof
argument_list|(
name|traceData
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
end_ifndef
begin_function
DECL|function|ConstructLock
name|TInt
name|RHybridHeap
operator|::
name|ConstructLock
parameter_list|(
name|TUint32
name|aMode
parameter_list|)
block|{
name|TBool
name|duplicateLock
init|=
name|EFalse
decl_stmt|;
name|TInt
name|r
init|=
name|KErrNone
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|iFlags
operator|&
name|ESingleThreaded
operator|)
condition|)
block|{
name|duplicateLock
operator|=
name|aMode
operator|&
name|UserHeap
operator|::
name|EChunkHeapSwitchTo
expr_stmt|;
name|r
operator|=
name|iLock
operator|.
name|CreateLocal
argument_list|(
name|duplicateLock
condition|?
name|EOwnerThread
else|:
name|EOwnerProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|KErrNone
condition|)
block|{
name|iChunkHandle
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
if|if
condition|(
name|aMode
operator|&
name|UserHeap
operator|::
name|EChunkHeapSwitchTo
condition|)
name|User
operator|::
name|SwitchHeap
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|iHandles
operator|=
operator|&
name|iChunkHandle
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iFlags
operator|&
name|ESingleThreaded
operator|)
condition|)
block|{
comment|// now change the thread-relative chunk/semaphore handles into process-relative handles
name|iHandleCount
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|duplicateLock
condition|)
block|{
name|RHandleBase
name|s
init|=
name|iLock
decl_stmt|;
name|r
operator|=
name|iLock
operator|.
name|Duplicate
argument_list|(
name|RThread
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|.
name|Close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|KErrNone
operator|&&
operator|(
name|aMode
operator|&
name|UserHeap
operator|::
name|EChunkHeapDuplicate
operator|)
condition|)
block|{
name|r
operator|=
operator|(
operator|(
name|RChunk
operator|*
operator|)
operator|&
name|iChunkHandle
operator|)
operator|->
name|Duplicate
argument_list|(
name|RThread
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|KErrNone
condition|)
name|iLock
operator|.
name|Close
argument_list|()
operator|,
name|iChunkHandle
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|iHandleCount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|aMode
operator|&
name|UserHeap
operator|::
name|EChunkHeapDuplicate
condition|)
name|r
operator|=
operator|(
operator|(
name|RChunk
operator|*
operator|)
operator|&
name|iChunkHandle
operator|)
operator|->
name|Duplicate
argument_list|(
name|RThread
argument_list|()
argument_list|,
name|EOwnerThread
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|Init
name|void
name|RHybridHeap
operator|::
name|Init
parameter_list|(
name|TInt
name|aBitmapSlab
parameter_list|,
name|TInt
name|aPagePower
parameter_list|)
block|{
comment|/*Moved code which does initialization */
name|iTop
operator|=
operator|(
name|TUint8
operator|*
operator|)
name|this
operator|+
name|iMinLength
expr_stmt|;
name|iBase
operator|=
name|Ceiling
argument_list|(
name|iBase
argument_list|,
name|ECellAlignment
argument_list|)
expr_stmt|;
comment|// Align iBase address
name|__INIT_COUNTERS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|//	memset(&mparams,0,sizeof(mparams));
name|InitDlMalloc
argument_list|(
name|iTop
operator|-
name|iBase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
name|SlabInit
argument_list|()
expr_stmt|;
name|iSlabConfigBits
operator|=
name|aBitmapSlab
expr_stmt|;
if|if
condition|(
name|iChunkSize
operator|>
name|iSlabInitThreshold
condition|)
block|{
name|iSlabInitThreshold
operator|=
name|KMaxTInt32
expr_stmt|;
name|SlabConfig
argument_list|(
name|aBitmapSlab
argument_list|)
expr_stmt|;
comment|// Delayed slab configuration done
block|}
if|if
condition|(
name|aPagePower
condition|)
block|{
name|RChunk
name|chunk
decl_stmt|;
name|chunk
operator|.
name|SetHandle
argument_list|(
name|iChunkHandle
argument_list|)
expr_stmt|;
name|iMemBase
operator|=
name|chunk
operator|.
name|Base
argument_list|()
expr_stmt|;
comment|// Store base address for paged allocator
block|}
comment|/*10-1K,11-2K,12-4k,13-8K,14-16K,15-32K,16-64K*/
name|PagedInit
argument_list|(
name|aPagePower
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
name|TUint32
name|traceData
index|[
literal|3
index|]
decl_stmt|;
name|traceData
index|[
literal|0
index|]
operator|=
name|aBitmapSlab
expr_stmt|;
name|traceData
index|[
literal|1
index|]
operator|=
name|aPagePower
expr_stmt|;
name|traceData
index|[
literal|2
index|]
operator|=
name|GM
operator|->
name|iTrimCheck
expr_stmt|;
name|BTraceContextN
argument_list|(
name|BTrace
operator|::
name|ETest1
argument_list|,
literal|90
argument_list|,
operator|(
name|TUint32
operator|)
name|this
argument_list|,
literal|0
argument_list|,
name|traceData
argument_list|,
sizeof|sizeof
argument_list|(
name|traceData
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
operator|(
name|void
operator|)
name|aBitmapSlab
expr_stmt|;
operator|(
name|void
operator|)
name|aPagePower
expr_stmt|;
endif|#
directive|endif
comment|// __KERNEL_MODE__
block|}
end_function
begin_function
DECL|function|AllocLen
name|TInt
name|RHybridHeap
operator|::
name|AllocLen
parameter_list|(
specifier|const
name|TAny
modifier|*
name|aCell
parameter_list|)
specifier|const
block|{
name|aCell
operator|=
name|__GET_DEBUG_DATA_BFR
argument_list|(
name|aCell
argument_list|)
expr_stmt|;
if|if
condition|(
name|PtrDiff
argument_list|(
name|aCell
argument_list|,
name|this
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|mchunkptr
name|m
init|=
name|MEM2CHUNK
argument_list|(
name|aCell
argument_list|)
decl_stmt|;
return|return
name|CHUNKSIZE
argument_list|(
name|m
argument_list|)
operator|-
name|OVERHEAD_FOR
argument_list|(
name|m
argument_list|)
operator|-
name|__DEBUG_HDR_SIZE
return|;
block|}
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
if|if
condition|(
name|aCell
condition|)
block|{
if|if
condition|(
name|LowBits
argument_list|(
name|aCell
argument_list|,
name|iPageSize
argument_list|)
condition|)
return|return
name|SlabHeaderSize
argument_list|(
name|slab
operator|::
name|SlabFor
argument_list|(
name|aCell
argument_list|)
operator|->
name|iHeader
argument_list|)
operator|-
name|__DEBUG_HDR_SIZE
return|;
return|return
name|PagedSize
argument_list|(
operator|(
name|void
operator|*
operator|)
name|aCell
argument_list|)
operator|-
name|__DEBUG_HDR_SIZE
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
comment|// NULL pointer situation, should PANIC !!
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__KERNEL_MODE__
end_ifdef
begin_function
DECL|function|Alloc
name|TAny
modifier|*
name|RHybridHeap
operator|::
name|Alloc
parameter_list|(
name|TInt
name|aSize
parameter_list|)
block|{
name|__CHECK_THREAD_STATE
expr_stmt|;
name|__ASSERT_ALWAYS
argument_list|(
operator|(
name|TUint
operator|)
name|aSize
operator|<
operator|(
name|KMaxTInt
operator|/
literal|2
operator|)
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapBadAllocatedCellSize
argument_list|)
argument_list|)
expr_stmt|;
name|__SIMULATE_ALLOC_FAIL
argument_list|(
argument|return NULL;
argument_list|)
name|Lock
argument_list|()
expr_stmt|;
name|__ALLOC_DEBUG_HEADER
argument_list|(
name|aSize
argument_list|)
expr_stmt|;
name|TAny
modifier|*
name|addr
init|=
name|DlMalloc
argument_list|(
name|aSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
comment|//		iCellCount++;
name|__SET_DEBUG_DATA
argument_list|(
name|addr
argument_list|,
name|iNestingLevel
argument_list|,
operator|++
name|iAllocCount
argument_list|)
expr_stmt|;
name|addr
operator|=
name|__GET_USER_DATA_BFR
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|__INCREMENT_COUNTERS
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|memclr
argument_list|(
name|addr
argument_list|,
name|AllocLen
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Unlock
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
if|if
condition|(
name|iFlags
operator|&
name|ETraceAllocs
condition|)
block|{
if|if
condition|(
name|addr
condition|)
block|{
name|TUint32
name|traceData
index|[
literal|3
index|]
decl_stmt|;
name|traceData
index|[
literal|0
index|]
operator|=
name|AllocLen
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|traceData
index|[
literal|1
index|]
operator|=
name|aSize
operator|-
name|__DEBUG_HDR_SIZE
expr_stmt|;
name|traceData
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|BTraceContextN
argument_list|(
name|BTrace
operator|::
name|EHeap
argument_list|,
name|BTrace
operator|::
name|EHeapAlloc
argument_list|,
operator|(
name|TUint32
operator|)
name|this
argument_list|,
operator|(
name|TUint32
operator|)
name|addr
argument_list|,
name|traceData
argument_list|,
sizeof|sizeof
argument_list|(
name|traceData
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|BTraceContext8
argument_list|(
name|BTrace
operator|::
name|EHeap
argument_list|,
name|BTrace
operator|::
name|EHeapAllocFail
argument_list|,
operator|(
name|TUint32
operator|)
name|this
argument_list|,
call|(
name|TUint32
call|)
argument_list|(
name|aSize
operator|-
name|__DEBUG_HDR_SIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|addr
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|Alloc
name|TAny
modifier|*
name|RHybridHeap
operator|::
name|Alloc
parameter_list|(
name|TInt
name|aSize
parameter_list|)
block|{
name|__ASSERT_ALWAYS
argument_list|(
operator|(
name|TUint
operator|)
name|aSize
operator|<
operator|(
name|KMaxTInt
operator|/
literal|2
operator|)
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapBadAllocatedCellSize
argument_list|)
argument_list|)
expr_stmt|;
name|__SIMULATE_ALLOC_FAIL
argument_list|(
argument|return NULL;
argument_list|)
name|TAny
modifier|*
name|addr
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
name|TInt
name|aSubAllocator
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|Lock
argument_list|()
expr_stmt|;
name|__ALLOC_DEBUG_HEADER
argument_list|(
name|aSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSize
operator|<
name|iSlabThreshold
condition|)
block|{
name|TInt
name|ix
init|=
name|iSizeMap
index|[
operator|(
name|aSize
operator|+
literal|3
operator|)
operator|>>
literal|2
index|]
decl_stmt|;
name|HEAP_ASSERT
argument_list|(
name|ix
operator|!=
literal|0xff
argument_list|)
expr_stmt|;
name|addr
operator|=
name|SlabAllocate
argument_list|(
name|iSlabAlloc
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr
condition|)
block|{
comment|// Slab allocation has failed, try to allocate from DL
name|addr
operator|=
name|DlMalloc
argument_list|(
name|aSize
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
else|else
name|aSubAllocator
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|aSize
operator|>>
name|iPageThreshold
operator|)
operator|==
literal|0
condition|)
block|{
name|addr
operator|=
name|DlMalloc
argument_list|(
name|aSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|PagedAllocate
argument_list|(
name|aSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr
condition|)
block|{
comment|// Page allocation has failed, try to allocate from DL
name|addr
operator|=
name|DlMalloc
argument_list|(
name|aSize
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
else|else
name|aSubAllocator
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|addr
condition|)
block|{
comment|//		iCellCount++;
name|__SET_DEBUG_DATA
argument_list|(
name|addr
argument_list|,
name|iNestingLevel
argument_list|,
operator|++
name|iAllocCount
argument_list|)
expr_stmt|;
name|addr
operator|=
name|__GET_USER_DATA_BFR
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|__INCREMENT_COUNTERS
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
name|Unlock
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
if|if
condition|(
name|iFlags
operator|&
name|ETraceAllocs
condition|)
block|{
if|if
condition|(
name|addr
condition|)
block|{
name|TUint32
name|traceData
index|[
literal|3
index|]
decl_stmt|;
name|traceData
index|[
literal|0
index|]
operator|=
name|AllocLen
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|traceData
index|[
literal|1
index|]
operator|=
name|aSize
operator|-
name|__DEBUG_HDR_SIZE
expr_stmt|;
name|traceData
index|[
literal|2
index|]
operator|=
name|aSubAllocator
expr_stmt|;
name|BTraceContextN
argument_list|(
name|BTrace
operator|::
name|EHeap
argument_list|,
name|BTrace
operator|::
name|EHeapAlloc
argument_list|,
operator|(
name|TUint32
operator|)
name|this
argument_list|,
operator|(
name|TUint32
operator|)
name|addr
argument_list|,
name|traceData
argument_list|,
sizeof|sizeof
argument_list|(
name|traceData
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|BTraceContext8
argument_list|(
name|BTrace
operator|::
name|EHeap
argument_list|,
name|BTrace
operator|::
name|EHeapAllocFail
argument_list|,
operator|(
name|TUint32
operator|)
name|this
argument_list|,
call|(
name|TUint32
call|)
argument_list|(
name|aSize
operator|-
name|__DEBUG_HDR_SIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|addr
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// __KERNEL_MODE__
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
end_ifndef
begin_function
DECL|function|Compress
name|TInt
name|RHybridHeap
operator|::
name|Compress
parameter_list|()
block|{
if|if
condition|(
name|IS_FIXED_HEAP
condition|)
return|return
literal|0
return|;
name|Lock
argument_list|()
expr_stmt|;
name|TInt
name|Reduced
init|=
name|SysTrim
argument_list|(
name|GM
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|iSparePage
condition|)
block|{
name|Unmap
argument_list|(
name|iSparePage
argument_list|,
name|iPageSize
argument_list|)
expr_stmt|;
name|iSparePage
operator|=
literal|0
expr_stmt|;
name|Reduced
operator|+=
name|iPageSize
expr_stmt|;
block|}
name|Unlock
argument_list|()
expr_stmt|;
return|return
name|Reduced
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|Free
name|void
name|RHybridHeap
operator|::
name|Free
parameter_list|(
name|TAny
modifier|*
name|aPtr
parameter_list|)
block|{
name|__CHECK_THREAD_STATE
expr_stmt|;
if|if
condition|(
operator|!
name|aPtr
condition|)
return|return;
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
name|TInt
name|aSubAllocator
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|Lock
argument_list|()
expr_stmt|;
name|aPtr
operator|=
name|__GET_DEBUG_DATA_BFR
argument_list|(
name|aPtr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
if|if
condition|(
name|PtrDiff
argument_list|(
name|aPtr
argument_list|,
name|this
argument_list|)
operator|>=
literal|0
condition|)
block|{
endif|#
directive|endif
name|__DL_BFR_CHECK
argument_list|(
name|GM
argument_list|,
name|aPtr
argument_list|)
expr_stmt|;
name|__DECREMENT_COUNTERS
argument_list|(
name|__GET_USER_DATA_BFR
argument_list|(
name|aPtr
argument_list|)
argument_list|)
expr_stmt|;
name|__ZAP_CELL
argument_list|(
name|aPtr
argument_list|)
expr_stmt|;
name|DlFree
argument_list|(
name|aPtr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
block|}
elseif|else
if|if
condition|(
name|LowBits
argument_list|(
name|aPtr
argument_list|,
name|iPageSize
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
name|aSubAllocator
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
name|__PAGE_BFR_CHECK
argument_list|(
name|aPtr
argument_list|)
expr_stmt|;
name|__DECREMENT_COUNTERS
argument_list|(
name|__GET_USER_DATA_BFR
argument_list|(
name|aPtr
argument_list|)
argument_list|)
expr_stmt|;
name|PagedFree
argument_list|(
name|aPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
name|aSubAllocator
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|TUint32
name|bm
index|[
literal|4
index|]
decl_stmt|;
name|__SLAB_BFR_CHECK
argument_list|(
name|slab
operator|::
name|SlabFor
argument_list|(
name|aPtr
argument_list|)
argument_list|,
name|aPtr
argument_list|,
name|bm
argument_list|)
expr_stmt|;
name|__DECREMENT_COUNTERS
argument_list|(
name|__GET_USER_DATA_BFR
argument_list|(
name|aPtr
argument_list|)
argument_list|)
expr_stmt|;
name|__ZAP_CELL
argument_list|(
name|aPtr
argument_list|)
expr_stmt|;
name|SlabFree
argument_list|(
name|aPtr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// __KERNEL_MODE__
comment|//	iCellCount--;
name|Unlock
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
if|if
condition|(
name|iFlags
operator|&
name|ETraceAllocs
condition|)
block|{
name|TUint32
name|traceData
decl_stmt|;
name|traceData
operator|=
name|aSubAllocator
expr_stmt|;
name|BTraceContextN
argument_list|(
name|BTrace
operator|::
name|EHeap
argument_list|,
name|BTrace
operator|::
name|EHeapFree
argument_list|,
operator|(
name|TUint32
operator|)
name|this
argument_list|,
operator|(
name|TUint32
operator|)
name|__GET_USER_DATA_BFR
argument_list|(
name|aPtr
argument_list|)
argument_list|,
operator|&
name|traceData
argument_list|,
sizeof|sizeof
argument_list|(
name|traceData
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
end_ifndef
begin_function
DECL|function|Reset
name|void
name|RHybridHeap
operator|::
name|Reset
parameter_list|()
comment|/** Frees all allocated cells on this heap. */
block|{
name|Lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|IS_FIXED_HEAP
condition|)
block|{
if|if
condition|(
name|GM
operator|->
name|iSeg
operator|.
name|iSize
operator|>
operator|(
name|iMinLength
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
operator|)
condition|)
name|Unmap
argument_list|(
name|GM
operator|->
name|iSeg
operator|.
name|iBase
operator|+
operator|(
name|iMinLength
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
operator|)
argument_list|,
operator|(
name|GM
operator|->
name|iSeg
operator|.
name|iSize
operator|-
operator|(
name|iMinLength
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ResetBitmap
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|iDLOnly
condition|)
name|Init
argument_list|(
name|iSlabConfigBits
argument_list|,
name|iPageThreshold
argument_list|)
expr_stmt|;
else|else
name|Init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|Init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|ReAllocImpl
name|TAny
modifier|*
name|RHybridHeap
operator|::
name|ReAllocImpl
parameter_list|(
name|TAny
modifier|*
name|aPtr
parameter_list|,
name|TInt
name|aSize
parameter_list|,
name|TInt
name|aMode
parameter_list|)
block|{
comment|// First handle special case of calling reallocate with NULL aPtr
if|if
condition|(
operator|!
name|aPtr
condition|)
block|{
if|if
condition|(
operator|(
name|aMode
operator|&
name|ENeverMove
operator|)
operator|==
literal|0
condition|)
block|{
name|aPtr
operator|=
name|Alloc
argument_list|(
name|aSize
operator|-
name|__DEBUG_HDR_SIZE
argument_list|)
expr_stmt|;
name|aPtr
operator|=
name|__GET_DEBUG_DATA_BFR
argument_list|(
name|aPtr
argument_list|)
expr_stmt|;
block|}
return|return
name|aPtr
return|;
block|}
name|TInt
name|oldsize
init|=
name|AllocLen
argument_list|(
name|__GET_USER_DATA_BFR
argument_list|(
name|aPtr
argument_list|)
argument_list|)
operator|+
name|__DEBUG_HDR_SIZE
decl_stmt|;
comment|// Insist on geometric growth when reallocating memory, this reduces copying and fragmentation
comment|// generated during arithmetic growth of buffer/array/vector memory
comment|// Experiments have shown that 25% is a good threshold for this policy
if|if
condition|(
name|aSize
operator|<=
name|oldsize
condition|)
block|{
if|if
condition|(
name|aSize
operator|>=
name|oldsize
operator|-
operator|(
name|oldsize
operator|>>
literal|2
operator|)
condition|)
return|return
name|aPtr
return|;
comment|// don't change if>75% original size
block|}
else|else
block|{
name|__SIMULATE_ALLOC_FAIL
argument_list|(
argument|return NULL;
argument_list|)
if|if
condition|(
name|aSize
operator|<
name|oldsize
operator|+
operator|(
name|oldsize
operator|>>
literal|2
operator|)
condition|)
block|{
name|aSize
operator|=
name|_ALIGN_UP
argument_list|(
name|oldsize
operator|+
operator|(
name|oldsize
operator|>>
literal|2
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|// grow to at least 125% original size
block|}
block|}
name|__DEBUG_SAVE
argument_list|(
name|aPtr
argument_list|)
expr_stmt|;
name|TAny
modifier|*
name|newp
decl_stmt|;
ifdef|#
directive|ifdef
name|__KERNEL_MODE__
name|Lock
argument_list|()
expr_stmt|;
name|__DL_BFR_CHECK
argument_list|(
name|GM
argument_list|,
name|aPtr
argument_list|)
expr_stmt|;
name|newp
operator|=
name|DlRealloc
argument_list|(
name|aPtr
argument_list|,
name|aSize
argument_list|,
name|aMode
argument_list|)
expr_stmt|;
name|Unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|newp
condition|)
block|{
if|if
condition|(
name|aSize
operator|>
name|oldsize
condition|)
name|memclr
argument_list|(
operator|(
operator|(
name|TUint8
operator|*
operator|)
name|newp
operator|)
operator|+
name|oldsize
argument_list|,
operator|(
name|aSize
operator|-
name|oldsize
operator|)
argument_list|)
expr_stmt|;
comment|// Buffer has grown in place, clear extra
name|__DEBUG_RESTORE
argument_list|(
name|newp
argument_list|)
expr_stmt|;
name|__UPDATE_ALLOC_COUNT
argument_list|(
name|aPtr
argument_list|,
name|newp
argument_list|,
operator|++
name|iAllocCount
argument_list|)
expr_stmt|;
name|__UPDATE_TOTAL_ALLOC
argument_list|(
name|newp
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|// Decide how to reallocate based on (a) the current cell location, (b) the mode requested and (c) the new size
if|if
condition|(
name|PtrDiff
argument_list|(
name|aPtr
argument_list|,
name|this
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|// current cell in Doug Lea iArena
if|if
condition|(
operator|(
name|aMode
operator|&
name|ENeverMove
operator|)
operator|||
operator|(
operator|!
operator|(
name|aMode
operator|&
name|EAllowMoveOnShrink
operator|)
operator|&&
operator|(
name|aSize
operator|<
name|oldsize
operator|)
operator|)
operator|||
operator|(
operator|(
name|aSize
operator|>=
name|iSlabThreshold
operator|)
operator|&&
operator|(
operator|(
name|aSize
operator|>>
name|iPageThreshold
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|Lock
argument_list|()
expr_stmt|;
name|__DL_BFR_CHECK
argument_list|(
name|GM
argument_list|,
name|aPtr
argument_list|)
expr_stmt|;
name|newp
operator|=
name|DlRealloc
argument_list|(
name|aPtr
argument_list|,
name|aSize
argument_list|,
name|aMode
argument_list|)
expr_stmt|;
comment|// old and new in DL allocator
name|Unlock
argument_list|()
expr_stmt|;
name|__DEBUG_RESTORE
argument_list|(
name|newp
argument_list|)
expr_stmt|;
name|__UPDATE_ALLOC_COUNT
argument_list|(
name|aPtr
argument_list|,
name|newp
argument_list|,
operator|++
name|iAllocCount
argument_list|)
expr_stmt|;
name|__UPDATE_TOTAL_ALLOC
argument_list|(
name|newp
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
return|return
name|newp
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|LowBits
argument_list|(
name|aPtr
argument_list|,
name|iPageSize
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// current cell in paged iArena
if|if
condition|(
operator|(
name|aMode
operator|&
name|ENeverMove
operator|)
operator|||
operator|(
operator|!
operator|(
name|aMode
operator|&
name|EAllowMoveOnShrink
operator|)
operator|&&
operator|(
name|aSize
operator|<
name|oldsize
operator|)
operator|)
operator|||
operator|(
operator|(
name|aSize
operator|>>
name|iPageThreshold
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|Lock
argument_list|()
expr_stmt|;
name|__PAGE_BFR_CHECK
argument_list|(
name|aPtr
argument_list|)
expr_stmt|;
name|newp
operator|=
name|PagedReallocate
argument_list|(
name|aPtr
argument_list|,
name|aSize
argument_list|,
name|aMode
argument_list|)
expr_stmt|;
comment|// old and new in paged allocator
name|Unlock
argument_list|()
expr_stmt|;
name|__DEBUG_RESTORE
argument_list|(
name|newp
argument_list|)
expr_stmt|;
name|__UPDATE_ALLOC_COUNT
argument_list|(
name|aPtr
argument_list|,
name|newp
argument_list|,
operator|++
name|iAllocCount
argument_list|)
expr_stmt|;
name|__UPDATE_TOTAL_ALLOC
argument_list|(
name|newp
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
return|return
name|newp
return|;
block|}
block|}
else|else
block|{
comment|// current cell in slab iArena
name|TUint32
name|bm
index|[
literal|4
index|]
decl_stmt|;
name|Lock
argument_list|()
expr_stmt|;
name|__SLAB_BFR_CHECK
argument_list|(
name|slab
operator|::
name|SlabFor
argument_list|(
name|aPtr
argument_list|)
argument_list|,
name|aPtr
argument_list|,
name|bm
argument_list|)
expr_stmt|;
name|Unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|aSize
operator|<=
name|oldsize
condition|)
return|return
name|aPtr
return|;
if|if
condition|(
name|aMode
operator|&
name|ENeverMove
condition|)
return|return
name|NULL
return|;
comment|// cannot grow in slab iArena
comment|// just use alloc/copy/free...
block|}
comment|// fallback to allocate and copy
comment|// shouldn't get here if we cannot move the cell
comment|//  	__ASSERT(mode == emobile || (mode==efixshrink&& size>oldsize));
name|newp
operator|=
name|Alloc
argument_list|(
name|aSize
operator|-
name|__DEBUG_HDR_SIZE
argument_list|)
expr_stmt|;
name|newp
operator|=
name|__GET_DEBUG_DATA_BFR
argument_list|(
name|newp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newp
condition|)
block|{
name|memcpy
argument_list|(
name|newp
argument_list|,
name|aPtr
argument_list|,
name|oldsize
operator|<
name|aSize
condition|?
name|oldsize
else|:
name|aSize
argument_list|)
expr_stmt|;
name|__DEBUG_RESTORE
argument_list|(
name|newp
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|__GET_USER_DATA_BFR
argument_list|(
name|aPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// __KERNEL_MODE__
return|return
name|newp
return|;
block|}
end_function
begin_function
DECL|function|ReAlloc
name|TAny
modifier|*
name|RHybridHeap
operator|::
name|ReAlloc
parameter_list|(
name|TAny
modifier|*
name|aPtr
parameter_list|,
name|TInt
name|aSize
parameter_list|,
name|TInt
name|aMode
parameter_list|)
block|{
name|aPtr
operator|=
name|__GET_DEBUG_DATA_BFR
argument_list|(
name|aPtr
argument_list|)
expr_stmt|;
name|__ALLOC_DEBUG_HEADER
argument_list|(
name|aSize
argument_list|)
expr_stmt|;
name|TAny
modifier|*
name|retval
init|=
name|ReAllocImpl
argument_list|(
name|aPtr
argument_list|,
name|aSize
argument_list|,
name|aMode
argument_list|)
decl_stmt|;
name|retval
operator|=
name|__GET_USER_DATA_BFR
argument_list|(
name|retval
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
if|if
condition|(
name|iFlags
operator|&
name|ETraceAllocs
condition|)
block|{
if|if
condition|(
name|retval
condition|)
block|{
name|TUint32
name|traceData
index|[
literal|3
index|]
decl_stmt|;
name|traceData
index|[
literal|0
index|]
operator|=
name|AllocLen
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|traceData
index|[
literal|1
index|]
operator|=
name|aSize
operator|-
name|__DEBUG_HDR_SIZE
expr_stmt|;
name|traceData
index|[
literal|2
index|]
operator|=
operator|(
name|TUint32
operator|)
name|aPtr
expr_stmt|;
name|BTraceContextN
argument_list|(
name|BTrace
operator|::
name|EHeap
argument_list|,
name|BTrace
operator|::
name|EHeapReAlloc
argument_list|,
operator|(
name|TUint32
operator|)
name|this
argument_list|,
operator|(
name|TUint32
operator|)
name|retval
argument_list|,
name|traceData
argument_list|,
sizeof|sizeof
argument_list|(
name|traceData
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|BTraceContext12
argument_list|(
name|BTrace
operator|::
name|EHeap
argument_list|,
name|BTrace
operator|::
name|EHeapReAllocFail
argument_list|,
operator|(
name|TUint32
operator|)
name|this
argument_list|,
operator|(
name|TUint32
operator|)
name|aPtr
argument_list|,
call|(
name|TUint32
call|)
argument_list|(
name|aSize
operator|-
name|__DEBUG_HDR_SIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|retval
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
end_ifndef
begin_function
DECL|function|Available
name|TInt
name|RHybridHeap
operator|::
name|Available
parameter_list|(
name|TInt
modifier|&
name|aBiggestBlock
parameter_list|)
specifier|const
comment|/** Gets the total free space currently available on the heap and the space available in the largest free block.  Note that this function exists mainly for compatibility reasons.  In a modern heap implementation such as that present in Symbian it is not appropriate to concern oneself with details such as the amount of free memory available on a heap and its largeset free block, because the way that a modern heap implementation works is not simple.  The amount of available virtual memory != physical memory and there are multiple allocation strategies used internally, which makes all memory usage figures "fuzzy" at best.  In short, if you want to see if there is enough memory available to allocate a block of memory, call Alloc() and if it succeeds then there is enough memory! Messing around with functions like this is somewhat pointless with modern heap allocators.  @param aBiggestBlock On return, contains the space available in the largest                      free block on the heap.  Due to the internals of modern                      heap implementations, you can probably still allocate a                      block larger than this!  @return The total free space currently available on the heap.  Again, you can         probably still allocate more than this! */
block|{
name|struct
name|HeapInfo
name|info
decl_stmt|;
name|Lock
argument_list|()
expr_stmt|;
name|TInt
name|Biggest
init|=
name|GetInfo
argument_list|(
operator|&
name|info
argument_list|)
decl_stmt|;
name|aBiggestBlock
operator|=
name|__GET_AVAIL_BLOCK_SIZE
argument_list|(
name|Biggest
argument_list|)
expr_stmt|;
name|Unlock
argument_list|()
expr_stmt|;
return|return
name|__GET_AVAIL_BLOCK_SIZE
argument_list|(
name|info
operator|.
name|iFreeBytes
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|AllocSize
name|TInt
name|RHybridHeap
operator|::
name|AllocSize
parameter_list|(
name|TInt
modifier|&
name|aTotalAllocSize
parameter_list|)
specifier|const
comment|/**    Gets the number of cells allocated on this heap, and the total space     allocated to them.        @param aTotalAllocSize On return, contains the total space allocated    to the cells.        @return The number of cells allocated on this heap. */
block|{
name|struct
name|HeapInfo
name|info
decl_stmt|;
name|Lock
argument_list|()
expr_stmt|;
name|GetInfo
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|aTotalAllocSize
operator|=
name|info
operator|.
name|iAllocBytes
operator|-
name|__REMOVE_DBG_HDR
argument_list|(
name|info
operator|.
name|iAllocN
argument_list|)
expr_stmt|;
name|Unlock
argument_list|()
expr_stmt|;
return|return
name|info
operator|.
name|iAllocN
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|Extension_
name|TInt
name|RHybridHeap
operator|::
name|Extension_
parameter_list|(
name|TUint
comment|/* aExtensionId */
parameter_list|,
name|TAny
modifier|*
modifier|&
comment|/* a0 */
parameter_list|,
name|TAny
modifier|*
comment|/* a1 */
parameter_list|)
block|{
return|return
name|KErrNotSupported
return|;
block|}
end_function
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|// imported from dla.cpp
end_comment
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//#include<unistd.h>
end_comment
begin_comment
comment|//#define DEBUG_REALLOC
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_REALLOC
end_ifdef
begin_include
include|#
directive|include
file|<e32debug.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|InitBins
specifier|inline
name|void
name|RHybridHeap
operator|::
name|InitBins
parameter_list|(
name|mstate
name|m
parameter_list|)
block|{
comment|/* Establish circular links for iSmallBins */
name|bindex_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSMALLBINS
condition|;
operator|++
name|i
control|)
block|{
name|sbinptr
name|bin
init|=
name|SMALLBIN_AT
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|bin
operator|->
name|iFd
operator|=
name|bin
operator|->
name|iBk
operator|=
name|bin
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ---------------------------- malloc support --------------------------- */
end_comment
begin_comment
comment|/* allocate a large request from the best fitting chunk in a treebin */
end_comment
begin_function
DECL|function|TmallocLarge
name|void
modifier|*
name|RHybridHeap
operator|::
name|TmallocLarge
parameter_list|(
name|mstate
name|m
parameter_list|,
name|size_t
name|nb
parameter_list|)
block|{
name|tchunkptr
name|v
init|=
literal|0
decl_stmt|;
name|size_t
name|rsize
init|=
operator|-
name|nb
decl_stmt|;
comment|/* Unsigned negation */
name|tchunkptr
name|t
decl_stmt|;
name|bindex_t
name|idx
decl_stmt|;
name|ComputeTreeIndex
argument_list|(
name|nb
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|*
name|TREEBIN_AT
argument_list|(
name|m
argument_list|,
name|idx
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Traverse tree for this bin looking for node with size == nb */
name|size_t
name|sizebits
init|=
name|nb
operator|<<
name|LEFTSHIFT_FOR_TREE_INDEX
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|tchunkptr
name|rst
init|=
literal|0
decl_stmt|;
comment|/* The deepest untaken right subtree */
for|for
control|(
init|;
condition|;
control|)
block|{
name|tchunkptr
name|rt
decl_stmt|;
name|size_t
name|trem
init|=
name|CHUNKSIZE
argument_list|(
name|t
argument_list|)
operator|-
name|nb
decl_stmt|;
if|if
condition|(
name|trem
operator|<
name|rsize
condition|)
block|{
name|v
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|rsize
operator|=
name|trem
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
name|rt
operator|=
name|t
operator|->
name|iChild
index|[
literal|1
index|]
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|iChild
index|[
operator|(
name|sizebits
operator|>>
operator|(
name|SIZE_T_BITSIZE
operator|-
name|SIZE_T_ONE
operator|)
operator|)
operator|&
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
name|rt
operator|!=
name|t
condition|)
name|rst
operator|=
name|rt
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|rst
expr_stmt|;
comment|/* set t to least subtree holding sizes> nb */
break|break;
block|}
name|sizebits
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|==
literal|0
operator|&&
name|v
operator|==
literal|0
condition|)
block|{
comment|/* set t to root of next non-empty treebin */
name|binmap_t
name|leftbits
init|=
name|LEFT_BITS
argument_list|(
name|IDX2BIT
argument_list|(
name|idx
argument_list|)
argument_list|)
operator|&
name|m
operator|->
name|iTreeMap
decl_stmt|;
if|if
condition|(
name|leftbits
operator|!=
literal|0
condition|)
block|{
name|bindex_t
name|i
decl_stmt|;
name|binmap_t
name|leastbit
init|=
name|LEAST_BIT
argument_list|(
name|leftbits
argument_list|)
decl_stmt|;
name|ComputeBit2idx
argument_list|(
name|leastbit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|t
operator|=
operator|*
name|TREEBIN_AT
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|t
operator|!=
literal|0
condition|)
block|{
comment|/* Find smallest of tree or subtree */
name|size_t
name|trem
init|=
name|CHUNKSIZE
argument_list|(
name|t
argument_list|)
operator|-
name|nb
decl_stmt|;
if|if
condition|(
name|trem
operator|<
name|rsize
condition|)
block|{
name|rsize
operator|=
name|trem
expr_stmt|;
name|v
operator|=
name|t
expr_stmt|;
block|}
name|t
operator|=
name|LEFTMOST_CHILD
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/*  If iDv is a better fit, return 0 so malloc will use it */
if|if
condition|(
name|v
operator|!=
literal|0
operator|&&
name|rsize
operator|<
call|(
name|size_t
call|)
argument_list|(
name|m
operator|->
name|iDvSize
operator|-
name|nb
argument_list|)
condition|)
block|{
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
argument_list|)
condition|)
block|{
comment|/* split */
name|mchunkptr
name|r
init|=
name|CHUNK_PLUS_OFFSET
argument_list|(
name|v
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|HEAP_ASSERT
argument_list|(
name|CHUNKSIZE
argument_list|(
name|v
argument_list|)
operator|==
name|rsize
operator|+
name|nb
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_NEXT
argument_list|(
name|v
argument_list|,
name|r
argument_list|)
argument_list|)
condition|)
block|{
name|UnlinkLargeChunk
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|<
name|MIN_CHUNK_SIZE
condition|)
name|SET_INUSE_AND_PINUSE
argument_list|(
name|m
argument_list|,
name|v
argument_list|,
operator|(
name|rsize
operator|+
name|nb
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|SET_SIZE_AND_PINUSE_OF_INUSE_CHUNK
argument_list|(
name|m
argument_list|,
name|v
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|SET_SIZE_AND_PINUSE_OF_FREE_CHUNK
argument_list|(
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|InsertChunk
argument_list|(
name|m
argument_list|,
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
block|}
return|return
name|CHUNK2MEM
argument_list|(
name|v
argument_list|)
return|;
block|}
block|}
comment|//    CORRUPTION_ERROR_ACTION(m);
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* allocate a small request from the best fitting chunk in a treebin */
end_comment
begin_function
DECL|function|TmallocSmall
name|void
modifier|*
name|RHybridHeap
operator|::
name|TmallocSmall
parameter_list|(
name|mstate
name|m
parameter_list|,
name|size_t
name|nb
parameter_list|)
block|{
name|tchunkptr
name|t
decl_stmt|,
name|v
decl_stmt|;
name|size_t
name|rsize
decl_stmt|;
name|bindex_t
name|i
decl_stmt|;
name|binmap_t
name|leastbit
init|=
name|LEAST_BIT
argument_list|(
name|m
operator|->
name|iTreeMap
argument_list|)
decl_stmt|;
name|ComputeBit2idx
argument_list|(
name|leastbit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|v
operator|=
name|t
operator|=
operator|*
name|TREEBIN_AT
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|CHUNKSIZE
argument_list|(
name|t
argument_list|)
operator|-
name|nb
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|LEFTMOST_CHILD
argument_list|(
name|t
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|size_t
name|trem
init|=
name|CHUNKSIZE
argument_list|(
name|t
argument_list|)
operator|-
name|nb
decl_stmt|;
if|if
condition|(
name|trem
operator|<
name|rsize
condition|)
block|{
name|rsize
operator|=
name|trem
expr_stmt|;
name|v
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
argument_list|)
condition|)
block|{
name|mchunkptr
name|r
init|=
name|CHUNK_PLUS_OFFSET
argument_list|(
name|v
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|HEAP_ASSERT
argument_list|(
name|CHUNKSIZE
argument_list|(
name|v
argument_list|)
operator|==
name|rsize
operator|+
name|nb
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_NEXT
argument_list|(
name|v
argument_list|,
name|r
argument_list|)
argument_list|)
condition|)
block|{
name|UnlinkLargeChunk
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|<
name|MIN_CHUNK_SIZE
condition|)
name|SET_INUSE_AND_PINUSE
argument_list|(
name|m
argument_list|,
name|v
argument_list|,
operator|(
name|rsize
operator|+
name|nb
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|SET_SIZE_AND_PINUSE_OF_INUSE_CHUNK
argument_list|(
name|m
argument_list|,
name|v
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|SET_SIZE_AND_PINUSE_OF_FREE_CHUNK
argument_list|(
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|ReplaceDv
argument_list|(
name|m
argument_list|,
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
block|}
return|return
name|CHUNK2MEM
argument_list|(
name|v
argument_list|)
return|;
block|}
block|}
comment|//  CORRUPTION_ERROR_ACTION(m);
comment|//  return 0;
block|}
end_function
begin_function
DECL|function|InitTop
specifier|inline
name|void
name|RHybridHeap
operator|::
name|InitTop
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|,
name|size_t
name|psize
parameter_list|)
block|{
comment|/* Ensure alignment */
name|size_t
name|offset
init|=
name|ALIGN_OFFSET
argument_list|(
name|CHUNK2MEM
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|=
call|(
name|mchunkptr
call|)
argument_list|(
operator|(
name|TUint8
operator|*
operator|)
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|psize
operator|-=
name|offset
expr_stmt|;
name|m
operator|->
name|iTop
operator|=
name|p
expr_stmt|;
name|m
operator|->
name|iTopSize
operator|=
name|psize
expr_stmt|;
name|p
operator|->
name|iHead
operator|=
name|psize
operator||
name|PINUSE_BIT
expr_stmt|;
comment|/* set size of fake trailing chunk holding overhead space only once */
name|mchunkptr
name|chunkPlusOff
init|=
name|CHUNK_PLUS_OFFSET
argument_list|(
name|p
argument_list|,
name|psize
argument_list|)
decl_stmt|;
name|chunkPlusOff
operator|->
name|iHead
operator|=
name|TOP_FOOT_SIZE
expr_stmt|;
name|m
operator|->
name|iTrimCheck
operator|=
name|KHeapShrinkHysRatio
operator|*
operator|(
name|iGrowBy
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Unlink the first chunk from a smallbin */
end_comment
begin_function
DECL|function|UnlinkFirstSmallChunk
specifier|inline
name|void
name|RHybridHeap
operator|::
name|UnlinkFirstSmallChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|mchunkptr
name|B
parameter_list|,
name|mchunkptr
name|P
parameter_list|,
name|bindex_t
modifier|&
name|I
parameter_list|)
block|{
name|mchunkptr
name|F
init|=
name|P
operator|->
name|iFd
decl_stmt|;
name|HEAP_ASSERT
argument_list|(
name|P
operator|!=
name|B
argument_list|)
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|P
operator|!=
name|F
argument_list|)
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|CHUNKSIZE
argument_list|(
name|P
argument_list|)
operator|==
name|SMALL_INDEX2SIZE
argument_list|(
name|I
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|B
operator|==
name|F
condition|)
name|CLEAR_SMALLMAP
argument_list|(
name|M
argument_list|,
name|I
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|M
argument_list|,
name|F
argument_list|)
argument_list|)
condition|)
block|{
name|B
operator|->
name|iFd
operator|=
name|F
expr_stmt|;
name|F
operator|->
name|iBk
operator|=
name|B
expr_stmt|;
block|}
else|else
block|{
name|CORRUPTION_ERROR_ACTION
argument_list|(
name|M
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Link a free chunk into a smallbin  */
end_comment
begin_function
DECL|function|InsertSmallChunk
specifier|inline
name|void
name|RHybridHeap
operator|::
name|InsertSmallChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|mchunkptr
name|P
parameter_list|,
name|size_t
name|S
parameter_list|)
block|{
name|bindex_t
name|I
init|=
name|SMALL_INDEX
argument_list|(
name|S
argument_list|)
decl_stmt|;
name|mchunkptr
name|B
init|=
name|SMALLBIN_AT
argument_list|(
name|M
argument_list|,
name|I
argument_list|)
decl_stmt|;
name|mchunkptr
name|F
init|=
name|B
decl_stmt|;
name|HEAP_ASSERT
argument_list|(
name|S
operator|>=
name|MIN_CHUNK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SMALLMAP_IS_MARKED
argument_list|(
name|M
argument_list|,
name|I
argument_list|)
condition|)
name|MARK_SMALLMAP
argument_list|(
name|M
argument_list|,
name|I
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|M
argument_list|,
name|B
operator|->
name|iFd
argument_list|)
argument_list|)
condition|)
name|F
operator|=
name|B
operator|->
name|iFd
expr_stmt|;
else|else
block|{
name|CORRUPTION_ERROR_ACTION
argument_list|(
name|M
argument_list|)
expr_stmt|;
block|}
name|B
operator|->
name|iFd
operator|=
name|P
expr_stmt|;
name|F
operator|->
name|iBk
operator|=
name|P
expr_stmt|;
name|P
operator|->
name|iFd
operator|=
name|F
expr_stmt|;
name|P
operator|->
name|iBk
operator|=
name|B
expr_stmt|;
block|}
end_function
begin_function
DECL|function|InsertChunk
specifier|inline
name|void
name|RHybridHeap
operator|::
name|InsertChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|mchunkptr
name|P
parameter_list|,
name|size_t
name|S
parameter_list|)
block|{
if|if
condition|(
name|IS_SMALL
argument_list|(
name|S
argument_list|)
condition|)
name|InsertSmallChunk
argument_list|(
name|M
argument_list|,
name|P
argument_list|,
name|S
argument_list|)
expr_stmt|;
else|else
block|{
name|tchunkptr
name|TP
init|=
call|(
name|tchunkptr
call|)
argument_list|(
name|P
argument_list|)
decl_stmt|;
name|InsertLargeChunk
argument_list|(
name|M
argument_list|,
name|TP
argument_list|,
name|S
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|UnlinkLargeChunk
specifier|inline
name|void
name|RHybridHeap
operator|::
name|UnlinkLargeChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|tchunkptr
name|X
parameter_list|)
block|{
name|tchunkptr
name|XP
init|=
name|X
operator|->
name|iParent
decl_stmt|;
name|tchunkptr
name|R
decl_stmt|;
if|if
condition|(
name|X
operator|->
name|iBk
operator|!=
name|X
condition|)
block|{
name|tchunkptr
name|F
init|=
name|X
operator|->
name|iFd
decl_stmt|;
name|R
operator|=
name|X
operator|->
name|iBk
expr_stmt|;
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|M
argument_list|,
name|F
argument_list|)
argument_list|)
condition|)
block|{
name|F
operator|->
name|iBk
operator|=
name|R
expr_stmt|;
name|R
operator|->
name|iFd
operator|=
name|F
expr_stmt|;
block|}
else|else
block|{
name|CORRUPTION_ERROR_ACTION
argument_list|(
name|M
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tchunkptr
modifier|*
name|RP
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|R
operator|=
operator|*
operator|(
name|RP
operator|=
operator|&
operator|(
name|X
operator|->
name|iChild
index|[
literal|1
index|]
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|R
operator|=
operator|*
operator|(
name|RP
operator|=
operator|&
operator|(
name|X
operator|->
name|iChild
index|[
literal|0
index|]
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|tchunkptr
modifier|*
name|CP
decl_stmt|;
while|while
condition|(
operator|(
operator|*
operator|(
name|CP
operator|=
operator|&
operator|(
name|R
operator|->
name|iChild
index|[
literal|1
index|]
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|*
operator|(
name|CP
operator|=
operator|&
operator|(
name|R
operator|->
name|iChild
index|[
literal|0
index|]
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|R
operator|=
operator|*
operator|(
name|RP
operator|=
name|CP
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|M
argument_list|,
name|RP
argument_list|)
argument_list|)
condition|)
operator|*
name|RP
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|CORRUPTION_ERROR_ACTION
argument_list|(
name|M
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|XP
operator|!=
literal|0
condition|)
block|{
name|tbinptr
modifier|*
name|H
init|=
name|TREEBIN_AT
argument_list|(
name|M
argument_list|,
name|X
operator|->
name|iIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|X
operator|==
operator|*
name|H
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|H
operator|=
name|R
operator|)
operator|==
literal|0
condition|)
name|CLEAR_TREEMAP
argument_list|(
name|M
argument_list|,
name|X
operator|->
name|iIndex
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|M
argument_list|,
name|XP
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|XP
operator|->
name|iChild
index|[
literal|0
index|]
operator|==
name|X
condition|)
name|XP
operator|->
name|iChild
index|[
literal|0
index|]
operator|=
name|R
expr_stmt|;
else|else
name|XP
operator|->
name|iChild
index|[
literal|1
index|]
operator|=
name|R
expr_stmt|;
block|}
else|else
name|CORRUPTION_ERROR_ACTION
argument_list|(
name|M
argument_list|)
expr_stmt|;
if|if
condition|(
name|R
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|M
argument_list|,
name|R
argument_list|)
argument_list|)
condition|)
block|{
name|tchunkptr
name|C0
decl_stmt|,
name|C1
decl_stmt|;
name|R
operator|->
name|iParent
operator|=
name|XP
expr_stmt|;
if|if
condition|(
operator|(
name|C0
operator|=
name|X
operator|->
name|iChild
index|[
literal|0
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|M
argument_list|,
name|C0
argument_list|)
argument_list|)
condition|)
block|{
name|R
operator|->
name|iChild
index|[
literal|0
index|]
operator|=
name|C0
expr_stmt|;
name|C0
operator|->
name|iParent
operator|=
name|R
expr_stmt|;
block|}
else|else
name|CORRUPTION_ERROR_ACTION
argument_list|(
name|M
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|C1
operator|=
name|X
operator|->
name|iChild
index|[
literal|1
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|M
argument_list|,
name|C1
argument_list|)
argument_list|)
condition|)
block|{
name|R
operator|->
name|iChild
index|[
literal|1
index|]
operator|=
name|C1
expr_stmt|;
name|C1
operator|->
name|iParent
operator|=
name|R
expr_stmt|;
block|}
else|else
name|CORRUPTION_ERROR_ACTION
argument_list|(
name|M
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|CORRUPTION_ERROR_ACTION
argument_list|(
name|M
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Unlink a chunk from a smallbin  */
end_comment
begin_function
DECL|function|UnlinkSmallChunk
specifier|inline
name|void
name|RHybridHeap
operator|::
name|UnlinkSmallChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|mchunkptr
name|P
parameter_list|,
name|size_t
name|S
parameter_list|)
block|{
name|mchunkptr
name|F
init|=
name|P
operator|->
name|iFd
decl_stmt|;
name|mchunkptr
name|B
init|=
name|P
operator|->
name|iBk
decl_stmt|;
name|bindex_t
name|I
init|=
name|SMALL_INDEX
argument_list|(
name|S
argument_list|)
decl_stmt|;
name|HEAP_ASSERT
argument_list|(
name|P
operator|!=
name|B
argument_list|)
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|P
operator|!=
name|F
argument_list|)
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|CHUNKSIZE
argument_list|(
name|P
argument_list|)
operator|==
name|SMALL_INDEX2SIZE
argument_list|(
name|I
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
operator|==
name|B
condition|)
name|CLEAR_SMALLMAP
argument_list|(
name|M
argument_list|,
name|I
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RTCHECK
argument_list|(
operator|(
name|F
operator|==
name|SMALLBIN_AT
argument_list|(
name|M
argument_list|,
name|I
argument_list|)
operator|||
name|OK_ADDRESS
argument_list|(
name|M
argument_list|,
name|F
argument_list|)
operator|)
operator|&&
operator|(
name|B
operator|==
name|SMALLBIN_AT
argument_list|(
name|M
argument_list|,
name|I
argument_list|)
operator|||
name|OK_ADDRESS
argument_list|(
name|M
argument_list|,
name|B
argument_list|)
operator|)
argument_list|)
condition|)
block|{
name|F
operator|->
name|iBk
operator|=
name|B
expr_stmt|;
name|B
operator|->
name|iFd
operator|=
name|F
expr_stmt|;
block|}
else|else
block|{
name|CORRUPTION_ERROR_ACTION
argument_list|(
name|M
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|UnlinkChunk
specifier|inline
name|void
name|RHybridHeap
operator|::
name|UnlinkChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|mchunkptr
name|P
parameter_list|,
name|size_t
name|S
parameter_list|)
block|{
if|if
condition|(
name|IS_SMALL
argument_list|(
name|S
argument_list|)
condition|)
name|UnlinkSmallChunk
argument_list|(
name|M
argument_list|,
name|P
argument_list|,
name|S
argument_list|)
expr_stmt|;
else|else
block|{
name|tchunkptr
name|TP
init|=
call|(
name|tchunkptr
call|)
argument_list|(
name|P
argument_list|)
decl_stmt|;
name|UnlinkLargeChunk
argument_list|(
name|M
argument_list|,
name|TP
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// For DL debug functions
end_comment
begin_function
DECL|function|DoComputeTreeIndex
name|void
name|RHybridHeap
operator|::
name|DoComputeTreeIndex
parameter_list|(
name|size_t
name|S
parameter_list|,
name|bindex_t
modifier|&
name|I
parameter_list|)
block|{
name|ComputeTreeIndex
argument_list|(
name|S
argument_list|,
name|I
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ComputeTreeIndex
specifier|inline
name|void
name|RHybridHeap
operator|::
name|ComputeTreeIndex
parameter_list|(
name|size_t
name|S
parameter_list|,
name|bindex_t
modifier|&
name|I
parameter_list|)
block|{
name|size_t
name|X
init|=
name|S
operator|>>
name|TREEBIN_SHIFT
decl_stmt|;
if|if
condition|(
name|X
operator|==
literal|0
condition|)
name|I
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|X
operator|>
literal|0xFFFF
condition|)
name|I
operator|=
name|NTREEBINS
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|Y
init|=
operator|(
name|unsigned
name|int
operator|)
name|X
decl_stmt|;
name|unsigned
name|int
name|N
init|=
operator|(
operator|(
name|Y
operator|-
literal|0x100
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|8
decl_stmt|;
name|unsigned
name|int
name|K
init|=
operator|(
operator|(
operator|(
name|Y
operator|<<=
name|N
operator|)
operator|-
literal|0x1000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|4
decl_stmt|;
name|N
operator|+=
name|K
expr_stmt|;
name|N
operator|+=
name|K
operator|=
operator|(
operator|(
operator|(
name|Y
operator|<<=
name|K
operator|)
operator|-
literal|0x4000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|2
expr_stmt|;
name|K
operator|=
literal|14
operator|-
name|N
operator|+
operator|(
operator|(
name|Y
operator|<<=
name|K
operator|)
operator|>>
literal|15
operator|)
expr_stmt|;
name|I
operator|=
operator|(
name|K
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|S
operator|>>
operator|(
name|K
operator|+
operator|(
name|TREEBIN_SHIFT
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ------------------------- Operations on trees ------------------------- */
end_comment
begin_comment
comment|/* Insert chunk into tree */
end_comment
begin_function
DECL|function|InsertLargeChunk
specifier|inline
name|void
name|RHybridHeap
operator|::
name|InsertLargeChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|tchunkptr
name|X
parameter_list|,
name|size_t
name|S
parameter_list|)
block|{
name|tbinptr
modifier|*
name|H
decl_stmt|;
name|bindex_t
name|I
decl_stmt|;
name|ComputeTreeIndex
argument_list|(
name|S
argument_list|,
name|I
argument_list|)
expr_stmt|;
name|H
operator|=
name|TREEBIN_AT
argument_list|(
name|M
argument_list|,
name|I
argument_list|)
expr_stmt|;
name|X
operator|->
name|iIndex
operator|=
name|I
expr_stmt|;
name|X
operator|->
name|iChild
index|[
literal|0
index|]
operator|=
name|X
operator|->
name|iChild
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TREEMAP_IS_MARKED
argument_list|(
name|M
argument_list|,
name|I
argument_list|)
condition|)
block|{
name|MARK_TREEMAP
argument_list|(
name|M
argument_list|,
name|I
argument_list|)
expr_stmt|;
operator|*
name|H
operator|=
name|X
expr_stmt|;
name|X
operator|->
name|iParent
operator|=
operator|(
name|tchunkptr
operator|)
name|H
expr_stmt|;
name|X
operator|->
name|iFd
operator|=
name|X
operator|->
name|iBk
operator|=
name|X
expr_stmt|;
block|}
else|else
block|{
name|tchunkptr
name|T
init|=
operator|*
name|H
decl_stmt|;
name|size_t
name|K
init|=
name|S
operator|<<
name|LEFTSHIFT_FOR_TREE_INDEX
argument_list|(
name|I
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|CHUNKSIZE
argument_list|(
name|T
argument_list|)
operator|!=
name|S
condition|)
block|{
name|tchunkptr
modifier|*
name|C
init|=
operator|&
operator|(
name|T
operator|->
name|iChild
index|[
operator|(
name|K
operator|>>
operator|(
name|SIZE_T_BITSIZE
operator|-
name|SIZE_T_ONE
operator|)
operator|)
operator|&
literal|1
index|]
operator|)
decl_stmt|;
name|K
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|C
operator|!=
literal|0
condition|)
name|T
operator|=
operator|*
name|C
expr_stmt|;
elseif|else
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|M
argument_list|,
name|C
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|C
operator|=
name|X
expr_stmt|;
name|X
operator|->
name|iParent
operator|=
name|T
expr_stmt|;
name|X
operator|->
name|iFd
operator|=
name|X
operator|->
name|iBk
operator|=
name|X
expr_stmt|;
break|break;
block|}
else|else
block|{
name|CORRUPTION_ERROR_ACTION
argument_list|(
name|M
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|tchunkptr
name|F
init|=
name|T
operator|->
name|iFd
decl_stmt|;
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|M
argument_list|,
name|T
argument_list|)
operator|&&
name|OK_ADDRESS
argument_list|(
name|M
argument_list|,
name|F
argument_list|)
argument_list|)
condition|)
block|{
name|T
operator|->
name|iFd
operator|=
name|F
operator|->
name|iBk
operator|=
name|X
expr_stmt|;
name|X
operator|->
name|iFd
operator|=
name|F
expr_stmt|;
name|X
operator|->
name|iBk
operator|=
name|T
expr_stmt|;
name|X
operator|->
name|iParent
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
name|CORRUPTION_ERROR_ACTION
argument_list|(
name|M
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* Unlink steps:  1. If x is a chained node, unlink it from its same-sized iFd/iBk links and choose its iBk node as its replacement. 2. If x was the last node of its size, but not a leaf node, it must be replaced with a leaf node (not merely one with an open left or right), to make sure that lefts and rights of descendents correspond properly to bit masks.  We use the rightmost descendent of x.  We could use any other leaf, but this is easy to locate and tends to counteract removal of leftmosts elsewhere, and so keeps paths shorter than minimally guaranteed.  This doesn't loop much because on average a node in a tree is near the bottom. 3. If x is the base of a chain (i.e., has iParent links) relink x's iParent and children to x's replacement (or null if none). */
end_comment
begin_comment
comment|/* Replace iDv node, binning the old one */
end_comment
begin_comment
comment|/* Used only when iDvSize known to be small */
end_comment
begin_function
DECL|function|ReplaceDv
specifier|inline
name|void
name|RHybridHeap
operator|::
name|ReplaceDv
parameter_list|(
name|mstate
name|M
parameter_list|,
name|mchunkptr
name|P
parameter_list|,
name|size_t
name|S
parameter_list|)
block|{
name|size_t
name|DVS
init|=
name|M
operator|->
name|iDvSize
decl_stmt|;
if|if
condition|(
name|DVS
operator|!=
literal|0
condition|)
block|{
name|mchunkptr
name|DV
init|=
name|M
operator|->
name|iDv
decl_stmt|;
name|HEAP_ASSERT
argument_list|(
name|IS_SMALL
argument_list|(
name|DVS
argument_list|)
argument_list|)
expr_stmt|;
name|InsertSmallChunk
argument_list|(
name|M
argument_list|,
name|DV
argument_list|,
name|DVS
argument_list|)
expr_stmt|;
block|}
name|M
operator|->
name|iDvSize
operator|=
name|S
expr_stmt|;
name|M
operator|->
name|iDv
operator|=
name|P
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ComputeBit2idx
specifier|inline
name|void
name|RHybridHeap
operator|::
name|ComputeBit2idx
parameter_list|(
name|binmap_t
name|X
parameter_list|,
name|bindex_t
modifier|&
name|I
parameter_list|)
block|{
name|unsigned
name|int
name|Y
init|=
name|X
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|K
init|=
name|Y
operator|>>
operator|(
literal|16
operator|-
literal|4
operator|)
operator|&
literal|16
decl_stmt|;
name|unsigned
name|int
name|N
init|=
name|K
decl_stmt|;
name|Y
operator|>>=
name|K
expr_stmt|;
name|N
operator|+=
name|K
operator|=
name|Y
operator|>>
operator|(
literal|8
operator|-
literal|3
operator|)
operator|&
literal|8
expr_stmt|;
name|Y
operator|>>=
name|K
expr_stmt|;
name|N
operator|+=
name|K
operator|=
name|Y
operator|>>
operator|(
literal|4
operator|-
literal|2
operator|)
operator|&
literal|4
expr_stmt|;
name|Y
operator|>>=
name|K
expr_stmt|;
name|N
operator|+=
name|K
operator|=
name|Y
operator|>>
operator|(
literal|2
operator|-
literal|1
operator|)
operator|&
literal|2
expr_stmt|;
name|Y
operator|>>=
name|K
expr_stmt|;
name|N
operator|+=
name|K
operator|=
name|Y
operator|>>
operator|(
literal|1
operator|-
literal|0
operator|)
operator|&
literal|1
expr_stmt|;
name|Y
operator|>>=
name|K
expr_stmt|;
name|I
operator|=
call|(
name|bindex_t
call|)
argument_list|(
name|N
operator|+
name|Y
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|SysTrim
name|int
name|RHybridHeap
operator|::
name|SysTrim
parameter_list|(
name|mstate
name|m
parameter_list|,
name|size_t
name|pad
parameter_list|)
block|{
name|size_t
name|extra
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IS_INITIALIZED
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|pad
operator|+=
name|TOP_FOOT_SIZE
expr_stmt|;
comment|/* ensure enough room for segment overhead */
if|if
condition|(
name|m
operator|->
name|iTopSize
operator|>
name|pad
condition|)
block|{
name|extra
operator|=
name|Floor
argument_list|(
name|m
operator|->
name|iTopSize
operator|-
name|pad
argument_list|,
name|iPageSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|iSeg
operator|.
name|iSize
operator|-
name|extra
operator|)
operator|<
operator|(
name|iMinLength
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|iSeg
operator|.
name|iSize
operator|>
operator|(
name|iMinLength
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
operator|)
condition|)
name|extra
operator|=
name|Floor
argument_list|(
name|m
operator|->
name|iSeg
operator|.
name|iSize
operator|-
operator|(
name|iMinLength
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
operator|)
argument_list|,
name|iPageSize
argument_list|)
expr_stmt|;
comment|/* do not shrink heap below min length */
else|else
name|extra
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|extra
condition|)
block|{
name|Unmap
argument_list|(
name|m
operator|->
name|iSeg
operator|.
name|iBase
operator|+
name|m
operator|->
name|iSeg
operator|.
name|iSize
operator|-
name|extra
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|m
operator|->
name|iSeg
operator|.
name|iSize
operator|-=
name|extra
expr_stmt|;
name|InitTop
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|iTop
argument_list|,
name|m
operator|->
name|iTopSize
operator|-
name|extra
argument_list|)
expr_stmt|;
name|CHECK_TOP_CHUNK
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|iTop
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|extra
return|;
block|}
end_function
begin_comment
comment|/* Get memory from system using MORECORE */
end_comment
begin_function
DECL|function|SysAlloc
name|void
modifier|*
name|RHybridHeap
operator|::
name|SysAlloc
parameter_list|(
name|mstate
name|m
parameter_list|,
name|size_t
name|nb
parameter_list|)
block|{
name|HEAP_ASSERT
argument_list|(
name|m
operator|->
name|iTop
argument_list|)
expr_stmt|;
comment|/* Subtract out existing available iTop space from MORECORE request. */
comment|//	size_t asize = _ALIGN_UP(nb - m->iTopSize + TOP_FOOT_SIZE + SIZE_T_ONE, iGrowBy);
name|TInt
name|asize
init|=
name|_ALIGN_UP
argument_list|(
name|nb
operator|-
name|m
operator|->
name|iTopSize
operator|+
name|SYS_ALLOC_PADDING
argument_list|,
name|iGrowBy
argument_list|)
decl_stmt|;
comment|// From DLA version 2.8.4
name|char
modifier|*
name|br
init|=
operator|(
name|char
operator|*
operator|)
name|Map
argument_list|(
name|m
operator|->
name|iSeg
operator|.
name|iBase
operator|+
name|m
operator|->
name|iSeg
operator|.
name|iSize
argument_list|,
name|asize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|br
condition|)
return|return
literal|0
return|;
name|HEAP_ASSERT
argument_list|(
name|br
operator|==
operator|(
name|char
operator|*
operator|)
name|m
operator|->
name|iSeg
operator|.
name|iBase
operator|+
name|m
operator|->
name|iSeg
operator|.
name|iSize
argument_list|)
expr_stmt|;
comment|/* Merge with an existing segment */
name|m
operator|->
name|iSeg
operator|.
name|iSize
operator|+=
name|asize
expr_stmt|;
name|InitTop
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|iTop
argument_list|,
name|m
operator|->
name|iTopSize
operator|+
name|asize
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
operator|<
name|m
operator|->
name|iTopSize
condition|)
block|{
comment|/* Allocate from new or extended iTop space */
name|size_t
name|rsize
init|=
name|m
operator|->
name|iTopSize
operator|-=
name|nb
decl_stmt|;
name|mchunkptr
name|p
init|=
name|m
operator|->
name|iTop
decl_stmt|;
name|mchunkptr
name|r
init|=
name|m
operator|->
name|iTop
operator|=
name|CHUNK_PLUS_OFFSET
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|r
operator|->
name|iHead
operator|=
name|rsize
operator||
name|PINUSE_BIT
expr_stmt|;
name|SET_SIZE_AND_PINUSE_OF_INUSE_CHUNK
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|CHECK_TOP_CHUNK
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|iTop
argument_list|)
expr_stmt|;
name|CHECK_MALLOCED_CHUNK
argument_list|(
name|m
argument_list|,
name|CHUNK2MEM
argument_list|(
name|p
argument_list|)
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|CHUNK2MEM
argument_list|(
name|p
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|InitDlMalloc
name|void
name|RHybridHeap
operator|::
name|InitDlMalloc
parameter_list|(
name|size_t
name|capacity
parameter_list|,
name|int
comment|/*locked*/
parameter_list|)
block|{
name|memset
argument_list|(
name|GM
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|malloc_state
argument_list|)
argument_list|)
expr_stmt|;
comment|// The maximum amount that can be allocated can be calculated as:-
comment|// 2^sizeof(size_t) - sizeof(malloc_state) - TOP_FOOT_SIZE - page Size(all accordingly padded)
comment|// If the capacity exceeds this, no allocation will be done.
name|GM
operator|->
name|iSeg
operator|.
name|iBase
operator|=
name|iBase
expr_stmt|;
name|GM
operator|->
name|iSeg
operator|.
name|iSize
operator|=
name|capacity
expr_stmt|;
name|InitBins
argument_list|(
name|GM
argument_list|)
expr_stmt|;
name|InitTop
argument_list|(
name|GM
argument_list|,
operator|(
name|mchunkptr
operator|)
name|iBase
argument_list|,
name|capacity
operator|-
name|TOP_FOOT_SIZE
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|DlMalloc
name|void
modifier|*
name|RHybridHeap
operator|::
name|DlMalloc
parameter_list|(
name|size_t
name|bytes
parameter_list|)
block|{
comment|/* 	Basic algorithm: 	If a small request (< 256 bytes minus per-chunk overhead): 	1. If one exists, use a remainderless chunk in associated smallbin. 	(Remainderless means that there are too few excess bytes to 	represent as a chunk.) 	2. If it is big enough, use the iDv chunk, which is normally the 	chunk adjacent to the one used for the most recent small request. 	3. If one exists, split the smallest available chunk in a bin, 	saving remainder in iDv. 	4. If it is big enough, use the iTop chunk. 	5. If available, get memory from system and use it 	Otherwise, for a large request: 	1. Find the smallest available binned chunk that fits, and use it 	if it is better fitting than iDv chunk, splitting if necessary. 	2. If better fitting than any binned chunk, use the iDv chunk. 	3. If it is big enough, use the iTop chunk. 	4. If request size>= mmap threshold, try to directly mmap this chunk. 	5. If available, get memory from system and use it */
name|void
modifier|*
name|mem
decl_stmt|;
name|size_t
name|nb
decl_stmt|;
if|if
condition|(
name|bytes
operator|<=
name|MAX_SMALL_REQUEST
condition|)
block|{
name|bindex_t
name|idx
decl_stmt|;
name|binmap_t
name|smallbits
decl_stmt|;
name|nb
operator|=
operator|(
name|bytes
operator|<
name|MIN_REQUEST
operator|)
condition|?
name|MIN_CHUNK_SIZE
else|:
name|PAD_REQUEST
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|idx
operator|=
name|SMALL_INDEX
argument_list|(
name|nb
argument_list|)
expr_stmt|;
name|smallbits
operator|=
name|GM
operator|->
name|iSmallMap
operator|>>
name|idx
expr_stmt|;
if|if
condition|(
operator|(
name|smallbits
operator|&
literal|0x3U
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Remainderless fit to a smallbin. */
name|mchunkptr
name|b
decl_stmt|,
name|p
decl_stmt|;
name|idx
operator|+=
operator|~
name|smallbits
operator|&
literal|1
expr_stmt|;
comment|/* Uses next bin if idx empty */
name|b
operator|=
name|SMALLBIN_AT
argument_list|(
name|GM
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|p
operator|=
name|b
operator|->
name|iFd
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|CHUNKSIZE
argument_list|(
name|p
argument_list|)
operator|==
name|SMALL_INDEX2SIZE
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|UnlinkFirstSmallChunk
argument_list|(
name|GM
argument_list|,
name|b
argument_list|,
name|p
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|SET_INUSE_AND_PINUSE
argument_list|(
name|GM
argument_list|,
name|p
argument_list|,
name|SMALL_INDEX2SIZE
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|CHUNK2MEM
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|CHECK_MALLOCED_CHUNK
argument_list|(
name|GM
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
elseif|else
if|if
condition|(
name|nb
operator|>
name|GM
operator|->
name|iDvSize
condition|)
block|{
if|if
condition|(
name|smallbits
operator|!=
literal|0
condition|)
block|{
comment|/* Use chunk in next nonempty smallbin */
name|mchunkptr
name|b
decl_stmt|,
name|p
decl_stmt|,
name|r
decl_stmt|;
name|size_t
name|rsize
decl_stmt|;
name|bindex_t
name|i
decl_stmt|;
name|binmap_t
name|leftbits
init|=
operator|(
name|smallbits
operator|<<
name|idx
operator|)
operator|&
name|LEFT_BITS
argument_list|(
name|IDX2BIT
argument_list|(
name|idx
argument_list|)
argument_list|)
decl_stmt|;
name|binmap_t
name|leastbit
init|=
name|LEAST_BIT
argument_list|(
name|leftbits
argument_list|)
decl_stmt|;
name|ComputeBit2idx
argument_list|(
name|leastbit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|b
operator|=
name|SMALLBIN_AT
argument_list|(
name|GM
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
name|b
operator|->
name|iFd
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|CHUNKSIZE
argument_list|(
name|p
argument_list|)
operator|==
name|SMALL_INDEX2SIZE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|UnlinkFirstSmallChunk
argument_list|(
name|GM
argument_list|,
name|b
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|SMALL_INDEX2SIZE
argument_list|(
name|i
argument_list|)
operator|-
name|nb
expr_stmt|;
comment|/* Fit here cannot be remainderless if 4byte sizes */
if|if
condition|(
name|SIZE_T_SIZE
operator|!=
literal|4
operator|&&
name|rsize
operator|<
name|MIN_CHUNK_SIZE
condition|)
name|SET_INUSE_AND_PINUSE
argument_list|(
name|GM
argument_list|,
name|p
argument_list|,
name|SMALL_INDEX2SIZE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|SET_SIZE_AND_PINUSE_OF_INUSE_CHUNK
argument_list|(
name|GM
argument_list|,
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|r
operator|=
name|CHUNK_PLUS_OFFSET
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|SET_SIZE_AND_PINUSE_OF_FREE_CHUNK
argument_list|(
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|ReplaceDv
argument_list|(
name|GM
argument_list|,
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|CHUNK2MEM
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|CHECK_MALLOCED_CHUNK
argument_list|(
name|GM
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
elseif|else
if|if
condition|(
name|GM
operator|->
name|iTreeMap
operator|!=
literal|0
operator|&&
operator|(
name|mem
operator|=
name|TmallocSmall
argument_list|(
name|GM
argument_list|,
name|nb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|CHECK_MALLOCED_CHUNK
argument_list|(
name|GM
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>=
name|MAX_REQUEST
condition|)
name|nb
operator|=
name|MAX_SIZE_T
expr_stmt|;
comment|/* Too big to allocate. Force failure (in sys alloc) */
else|else
block|{
name|nb
operator|=
name|PAD_REQUEST
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|GM
operator|->
name|iTreeMap
operator|!=
literal|0
operator|&&
operator|(
name|mem
operator|=
name|TmallocLarge
argument_list|(
name|GM
argument_list|,
name|nb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|CHECK_MALLOCED_CHUNK
argument_list|(
name|GM
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
block|}
if|if
condition|(
name|nb
operator|<=
name|GM
operator|->
name|iDvSize
condition|)
block|{
name|size_t
name|rsize
init|=
name|GM
operator|->
name|iDvSize
operator|-
name|nb
decl_stmt|;
name|mchunkptr
name|p
init|=
name|GM
operator|->
name|iDv
decl_stmt|;
if|if
condition|(
name|rsize
operator|>=
name|MIN_CHUNK_SIZE
condition|)
block|{
comment|/* split iDv */
name|mchunkptr
name|r
init|=
name|GM
operator|->
name|iDv
operator|=
name|CHUNK_PLUS_OFFSET
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|GM
operator|->
name|iDvSize
operator|=
name|rsize
expr_stmt|;
name|SET_SIZE_AND_PINUSE_OF_FREE_CHUNK
argument_list|(
name|r
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|SET_SIZE_AND_PINUSE_OF_INUSE_CHUNK
argument_list|(
name|GM
argument_list|,
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* exhaust iDv */
name|size_t
name|dvs
init|=
name|GM
operator|->
name|iDvSize
decl_stmt|;
name|GM
operator|->
name|iDvSize
operator|=
literal|0
expr_stmt|;
name|GM
operator|->
name|iDv
operator|=
literal|0
expr_stmt|;
name|SET_INUSE_AND_PINUSE
argument_list|(
name|GM
argument_list|,
name|p
argument_list|,
name|dvs
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|CHUNK2MEM
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|CHECK_MALLOCED_CHUNK
argument_list|(
name|GM
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
elseif|else
if|if
condition|(
name|nb
operator|<
name|GM
operator|->
name|iTopSize
condition|)
block|{
comment|/* Split iTop */
name|size_t
name|rsize
init|=
name|GM
operator|->
name|iTopSize
operator|-=
name|nb
decl_stmt|;
name|mchunkptr
name|p
init|=
name|GM
operator|->
name|iTop
decl_stmt|;
name|mchunkptr
name|r
init|=
name|GM
operator|->
name|iTop
operator|=
name|CHUNK_PLUS_OFFSET
argument_list|(
name|p
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|r
operator|->
name|iHead
operator|=
name|rsize
operator||
name|PINUSE_BIT
expr_stmt|;
name|SET_SIZE_AND_PINUSE_OF_INUSE_CHUNK
argument_list|(
name|GM
argument_list|,
name|p
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|mem
operator|=
name|CHUNK2MEM
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|CHECK_TOP_CHUNK
argument_list|(
name|GM
argument_list|,
name|GM
operator|->
name|iTop
argument_list|)
expr_stmt|;
name|CHECK_MALLOCED_CHUNK
argument_list|(
name|GM
argument_list|,
name|mem
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
return|return
name|SysAlloc
argument_list|(
name|GM
argument_list|,
name|nb
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|DlFree
name|void
name|RHybridHeap
operator|::
name|DlFree
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
comment|/* 	Consolidate freed chunks with preceding or succeeding bordering 	free chunks, if they exist, and then place in a bin.	Intermixed 	with special cases for iTop, iDv, mmapped chunks, and usage errors. */
name|mchunkptr
name|p
init|=
name|MEM2CHUNK
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|CHECK_INUSE_CHUNK
argument_list|(
name|GM
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|GM
argument_list|,
name|p
argument_list|)
operator|&&
name|OK_CINUSE
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|size_t
name|psize
init|=
name|CHUNKSIZE
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|mchunkptr
name|next
init|=
name|CHUNK_PLUS_OFFSET
argument_list|(
name|p
argument_list|,
name|psize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|PINUSE
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|size_t
name|prevsize
init|=
name|p
operator|->
name|iPrevFoot
decl_stmt|;
name|mchunkptr
name|prev
init|=
name|CHUNK_MINUS_OFFSET
argument_list|(
name|p
argument_list|,
name|prevsize
argument_list|)
decl_stmt|;
name|psize
operator|+=
name|prevsize
expr_stmt|;
name|p
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|GM
argument_list|,
name|prev
argument_list|)
argument_list|)
condition|)
block|{
comment|/* consolidate backward */
if|if
condition|(
name|p
operator|!=
name|GM
operator|->
name|iDv
condition|)
block|{
name|UnlinkChunk
argument_list|(
name|GM
argument_list|,
name|p
argument_list|,
name|prevsize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|next
operator|->
name|iHead
operator|&
name|INUSE_BITS
operator|)
operator|==
name|INUSE_BITS
condition|)
block|{
name|GM
operator|->
name|iDvSize
operator|=
name|psize
expr_stmt|;
name|SET_FREE_WITH_PINUSE
argument_list|(
name|p
argument_list|,
name|psize
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|GM
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_NEXT
argument_list|(
name|p
argument_list|,
name|next
argument_list|)
operator|&&
name|OK_PINUSE
argument_list|(
name|next
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|CINUSE
argument_list|(
name|next
argument_list|)
condition|)
block|{
comment|/* consolidate forward */
if|if
condition|(
name|next
operator|==
name|GM
operator|->
name|iTop
condition|)
block|{
name|size_t
name|tsize
init|=
name|GM
operator|->
name|iTopSize
operator|+=
name|psize
decl_stmt|;
name|GM
operator|->
name|iTop
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|iHead
operator|=
name|tsize
operator||
name|PINUSE_BIT
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|GM
operator|->
name|iDv
condition|)
block|{
name|GM
operator|->
name|iDv
operator|=
literal|0
expr_stmt|;
name|GM
operator|->
name|iDvSize
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_FIXED_HEAP
operator|&&
name|SHOULD_TRIM
argument_list|(
name|GM
argument_list|,
name|tsize
argument_list|)
condition|)
name|SysTrim
argument_list|(
name|GM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|next
operator|==
name|GM
operator|->
name|iDv
condition|)
block|{
name|size_t
name|dsize
init|=
name|GM
operator|->
name|iDvSize
operator|+=
name|psize
decl_stmt|;
name|GM
operator|->
name|iDv
operator|=
name|p
expr_stmt|;
name|SET_SIZE_AND_PINUSE_OF_FREE_CHUNK
argument_list|(
name|p
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|size_t
name|nsize
init|=
name|CHUNKSIZE
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|psize
operator|+=
name|nsize
expr_stmt|;
name|UnlinkChunk
argument_list|(
name|GM
argument_list|,
name|next
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
name|SET_SIZE_AND_PINUSE_OF_FREE_CHUNK
argument_list|(
name|p
argument_list|,
name|psize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|GM
operator|->
name|iDv
condition|)
block|{
name|GM
operator|->
name|iDvSize
operator|=
name|psize
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
name|SET_FREE_WITH_PINUSE
argument_list|(
name|p
argument_list|,
name|psize
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|InsertChunk
argument_list|(
name|GM
argument_list|,
name|p
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|CHECK_FREE_CHUNK
argument_list|(
name|GM
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_function
DECL|function|DlRealloc
name|void
modifier|*
name|RHybridHeap
operator|::
name|DlRealloc
parameter_list|(
name|void
modifier|*
name|oldmem
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|TInt
name|mode
parameter_list|)
block|{
name|mchunkptr
name|oldp
init|=
name|MEM2CHUNK
argument_list|(
name|oldmem
argument_list|)
decl_stmt|;
name|size_t
name|oldsize
init|=
name|CHUNKSIZE
argument_list|(
name|oldp
argument_list|)
decl_stmt|;
name|mchunkptr
name|next
init|=
name|CHUNK_PLUS_OFFSET
argument_list|(
name|oldp
argument_list|,
name|oldsize
argument_list|)
decl_stmt|;
name|mchunkptr
name|newp
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|extra
init|=
literal|0
decl_stmt|;
comment|/* Try to either shrink or extend into iTop. Else malloc-copy-free */
if|if
condition|(
name|RTCHECK
argument_list|(
name|OK_ADDRESS
argument_list|(
name|GM
argument_list|,
name|oldp
argument_list|)
operator|&&
name|OK_CINUSE
argument_list|(
name|oldp
argument_list|)
operator|&&
name|OK_NEXT
argument_list|(
name|oldp
argument_list|,
name|next
argument_list|)
operator|&&
name|OK_PINUSE
argument_list|(
name|next
argument_list|)
argument_list|)
condition|)
block|{
name|size_t
name|nb
init|=
name|REQUEST2SIZE
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldsize
operator|>=
name|nb
condition|)
block|{
comment|/* already big enough */
name|size_t
name|rsize
init|=
name|oldsize
operator|-
name|nb
decl_stmt|;
name|newp
operator|=
name|oldp
expr_stmt|;
if|if
condition|(
name|rsize
operator|>=
name|MIN_CHUNK_SIZE
condition|)
block|{
name|mchunkptr
name|remainder
init|=
name|CHUNK_PLUS_OFFSET
argument_list|(
name|newp
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|SET_INUSE
argument_list|(
name|GM
argument_list|,
name|newp
argument_list|,
name|nb
argument_list|)
expr_stmt|;
comment|//				SET_INUSE(GM, remainder, rsize);
name|SET_INUSE_AND_PINUSE
argument_list|(
name|GM
argument_list|,
name|remainder
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|// corrected in original DLA version V2.8.4
name|extra
operator|=
name|CHUNK2MEM
argument_list|(
name|remainder
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|next
operator|==
name|GM
operator|->
name|iTop
operator|&&
name|oldsize
operator|+
name|GM
operator|->
name|iTopSize
operator|>
name|nb
condition|)
block|{
comment|/* Expand into iTop */
name|size_t
name|newsize
init|=
name|oldsize
operator|+
name|GM
operator|->
name|iTopSize
decl_stmt|;
name|size_t
name|newtopsize
init|=
name|newsize
operator|-
name|nb
decl_stmt|;
name|mchunkptr
name|newtop
init|=
name|CHUNK_PLUS_OFFSET
argument_list|(
name|oldp
argument_list|,
name|nb
argument_list|)
decl_stmt|;
name|SET_INUSE
argument_list|(
name|GM
argument_list|,
name|oldp
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|newtop
operator|->
name|iHead
operator|=
name|newtopsize
operator||
name|PINUSE_BIT
expr_stmt|;
name|GM
operator|->
name|iTop
operator|=
name|newtop
expr_stmt|;
name|GM
operator|->
name|iTopSize
operator|=
name|newtopsize
expr_stmt|;
name|newp
operator|=
name|oldp
expr_stmt|;
block|}
block|}
else|else
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|GM
argument_list|,
name|oldmem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
block|{
name|DlFree
argument_list|(
name|extra
argument_list|)
expr_stmt|;
block|}
name|CHECK_INUSE_CHUNK
argument_list|(
name|GM
argument_list|,
name|newp
argument_list|)
expr_stmt|;
return|return
name|CHUNK2MEM
argument_list|(
name|newp
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|&
name|ENeverMove
condition|)
return|return
literal|0
return|;
comment|// cannot move
name|void
modifier|*
name|newmem
init|=
name|DlMalloc
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|newmem
operator|!=
literal|0
condition|)
block|{
name|size_t
name|oc
init|=
name|oldsize
operator|-
name|OVERHEAD_FOR
argument_list|(
name|oldp
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newmem
argument_list|,
name|oldmem
argument_list|,
operator|(
name|oc
operator|<
name|bytes
operator|)
condition|?
name|oc
else|:
name|bytes
argument_list|)
expr_stmt|;
name|DlFree
argument_list|(
name|oldmem
argument_list|)
expr_stmt|;
block|}
return|return
name|newmem
return|;
block|}
comment|//	return 0;
block|}
end_function
begin_function
DECL|function|DlInfo
name|size_t
name|RHybridHeap
operator|::
name|DlInfo
parameter_list|(
name|struct
name|HeapInfo
modifier|*
name|i
parameter_list|,
name|SWalkInfo
modifier|*
name|wi
parameter_list|)
specifier|const
block|{
name|TInt
name|max
init|=
operator|(
operator|(
name|GM
operator|->
name|iTopSize
operator|-
literal|1
operator|)
operator|&
operator|~
name|CHUNK_ALIGN_MASK
operator|)
operator|-
name|CHUNK_OVERHEAD
decl_stmt|;
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
else|else
operator|++
name|i
operator|->
name|iFreeN
expr_stmt|;
comment|// iTop always free
name|i
operator|->
name|iFreeBytes
operator|+=
name|max
expr_stmt|;
name|Walk
argument_list|(
name|wi
argument_list|,
name|GM
operator|->
name|iTop
argument_list|,
name|max
argument_list|,
name|EGoodFreeCell
argument_list|,
name|EDougLeaAllocator
argument_list|)
expr_stmt|;
comment|// Introduce DL iTop buffer to the walk function
for|for
control|(
name|mchunkptr
name|q
init|=
name|ALIGN_AS_CHUNK
argument_list|(
name|GM
operator|->
name|iSeg
operator|.
name|iBase
argument_list|)
init|;
name|q
operator|!=
name|GM
operator|->
name|iTop
condition|;
name|q
operator|=
name|NEXT_CHUNK
argument_list|(
name|q
argument_list|)
control|)
block|{
name|TInt
name|sz
init|=
name|CHUNKSIZE
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CINUSE
argument_list|(
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|sz
operator|>
name|max
condition|)
name|max
operator|=
name|sz
expr_stmt|;
name|i
operator|->
name|iFreeBytes
operator|+=
name|sz
expr_stmt|;
operator|++
name|i
operator|->
name|iFreeN
expr_stmt|;
name|Walk
argument_list|(
name|wi
argument_list|,
name|CHUNK2MEM
argument_list|(
name|q
argument_list|)
argument_list|,
name|sz
argument_list|,
name|EGoodFreeCell
argument_list|,
name|EDougLeaAllocator
argument_list|)
expr_stmt|;
comment|// Introduce DL free buffer to the walk function
block|}
else|else
block|{
name|i
operator|->
name|iAllocBytes
operator|+=
name|sz
operator|-
name|CHUNK_OVERHEAD
expr_stmt|;
operator|++
name|i
operator|->
name|iAllocN
expr_stmt|;
name|Walk
argument_list|(
name|wi
argument_list|,
name|CHUNK2MEM
argument_list|(
name|q
argument_list|)
argument_list|,
operator|(
name|sz
operator|-
name|CHUNK_OVERHEAD
operator|)
argument_list|,
name|EGoodAllocatedCell
argument_list|,
name|EDougLeaAllocator
argument_list|)
expr_stmt|;
comment|// Introduce DL allocated buffer to the walk function
block|}
block|}
return|return
name|max
return|;
comment|// return largest available chunk size
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// get statistics about the state of the allocator
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|GetInfo
name|TInt
name|RHybridHeap
operator|::
name|GetInfo
parameter_list|(
name|struct
name|HeapInfo
modifier|*
name|i
parameter_list|,
name|SWalkInfo
modifier|*
name|wi
parameter_list|)
specifier|const
block|{
name|memset
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|HeapInfo
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|->
name|iFootprint
operator|=
name|iChunkSize
expr_stmt|;
name|i
operator|->
name|iMaxSize
operator|=
name|iMaxLength
expr_stmt|;
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
name|PagedInfo
argument_list|(
name|i
argument_list|,
name|wi
argument_list|)
expr_stmt|;
name|SlabInfo
argument_list|(
name|i
argument_list|,
name|wi
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|DlInfo
argument_list|(
name|i
argument_list|,
name|wi
argument_list|)
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Methods to commit/decommit memory pages from chunk
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|Map
name|void
modifier|*
name|RHybridHeap
operator|::
name|Map
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|TInt
name|sz
parameter_list|)
comment|//
comment|// allocate pages in the chunk
comment|// if p is NULL, Find an allocate the required number of pages (which must lie in the lower half)
comment|// otherwise commit the pages specified
comment|//
block|{
name|HEAP_ASSERT
argument_list|(
name|sz
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|iChunkSize
operator|+
name|sz
operator|>
name|iMaxLength
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|__KERNEL_MODE__
name|TInt
name|r
init|=
operator|(
operator|(
name|DChunk
operator|*
operator|)
name|iChunkHandle
operator|)
operator|->
name|Adjust
argument_list|(
name|iChunkSize
operator|+
name|iOffset
operator|+
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|iChunkSize
operator|+=
name|sz
expr_stmt|;
else|#
directive|else
name|RChunk
name|chunk
decl_stmt|;
name|chunk
operator|.
name|SetHandle
argument_list|(
name|iChunkHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|TInt
name|r
decl_stmt|;
if|if
condition|(
name|iUseAdjust
condition|)
name|r
operator|=
name|chunk
operator|.
name|Adjust
argument_list|(
name|iChunkSize
operator|+
name|sz
argument_list|)
expr_stmt|;
else|else
block|{
name|HEAP_ASSERT
argument_list|(
name|sz
operator|==
name|Ceiling
argument_list|(
name|sz
argument_list|,
name|iPageSize
argument_list|)
argument_list|)
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|p
operator|==
name|Floor
argument_list|(
name|p
argument_list|,
name|iPageSize
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|chunk
operator|.
name|Commit
argument_list|(
name|iOffset
operator|+
name|PtrDiff
argument_list|(
name|p
argument_list|,
name|this
argument_list|)
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|TInt
name|r
init|=
name|chunk
operator|.
name|Allocate
argument_list|(
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|r
operator|>
name|iOffset
condition|)
block|{
comment|// can't allow page allocations in DL zone
name|chunk
operator|.
name|Decommit
argument_list|(
name|r
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|=
name|Offset
argument_list|(
name|this
argument_list|,
name|r
operator|-
name|iOffset
argument_list|)
expr_stmt|;
block|}
name|iChunkSize
operator|+=
name|sz
expr_stmt|;
if|if
condition|(
name|iChunkSize
operator|>=
name|iSlabInitThreshold
condition|)
block|{
comment|// set up slab system now that heap is large enough
name|SlabConfig
argument_list|(
name|iSlabConfigBits
argument_list|)
expr_stmt|;
name|iSlabInitThreshold
operator|=
name|KMaxTInt32
expr_stmt|;
block|}
endif|#
directive|endif
comment|//	__KERNEL_MODE__
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
if|if
condition|(
name|iChunkSize
operator|>
name|iHighWaterMark
condition|)
block|{
name|iHighWaterMark
operator|=
name|Ceiling
argument_list|(
name|iChunkSize
argument_list|,
literal|16
operator|*
name|iPageSize
argument_list|)
expr_stmt|;
name|TUint32
name|traceData
index|[
literal|6
index|]
decl_stmt|;
name|traceData
index|[
literal|0
index|]
operator|=
name|iChunkHandle
expr_stmt|;
name|traceData
index|[
literal|1
index|]
operator|=
name|iMinLength
expr_stmt|;
name|traceData
index|[
literal|2
index|]
operator|=
name|iMaxLength
expr_stmt|;
name|traceData
index|[
literal|3
index|]
operator|=
name|sz
expr_stmt|;
name|traceData
index|[
literal|4
index|]
operator|=
name|iChunkSize
expr_stmt|;
name|traceData
index|[
literal|5
index|]
operator|=
name|iHighWaterMark
expr_stmt|;
name|BTraceContextN
argument_list|(
name|BTrace
operator|::
name|ETest1
argument_list|,
literal|90
argument_list|,
operator|(
name|TUint32
operator|)
name|this
argument_list|,
literal|33
argument_list|,
name|traceData
argument_list|,
sizeof|sizeof
argument_list|(
name|traceData
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|Unmap
name|void
name|RHybridHeap
operator|::
name|Unmap
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|TInt
name|sz
parameter_list|)
block|{
name|HEAP_ASSERT
argument_list|(
name|sz
operator|>
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__KERNEL_MODE__
operator|(
name|void
operator|)
name|p
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|sz
operator|==
name|Ceiling
argument_list|(
name|sz
argument_list|,
name|iPageSize
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|TInt
name|r
init|=
endif|#
directive|endif
operator|(
operator|(
name|DChunk
operator|*
operator|)
name|iChunkHandle
operator|)
operator|->
name|Adjust
argument_list|(
name|iChunkSize
operator|+
name|iOffset
operator|-
name|sz
argument_list|)
decl_stmt|;
name|HEAP_ASSERT
argument_list|(
name|r
operator|>=
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|RChunk
name|chunk
decl_stmt|;
name|chunk
operator|.
name|SetHandle
argument_list|(
name|iChunkHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|iUseAdjust
condition|)
block|{
name|HEAP_ASSERT
argument_list|(
name|sz
operator|==
name|Ceiling
argument_list|(
name|sz
argument_list|,
name|iPageSize
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|TInt
name|r
init|=
endif|#
directive|endif
name|chunk
operator|.
name|Adjust
argument_list|(
name|iChunkSize
operator|-
name|sz
argument_list|)
decl_stmt|;
name|HEAP_ASSERT
argument_list|(
name|r
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HEAP_ASSERT
argument_list|(
name|sz
operator|==
name|Ceiling
argument_list|(
name|sz
argument_list|,
name|iPageSize
argument_list|)
argument_list|)
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|p
operator|==
name|Floor
argument_list|(
name|p
argument_list|,
name|iPageSize
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|TInt
name|r
init|=
endif|#
directive|endif
name|chunk
operator|.
name|Decommit
argument_list|(
name|PtrDiff
argument_list|(
name|p
argument_list|,
name|Offset
argument_list|(
name|this
argument_list|,
operator|-
name|iOffset
argument_list|)
argument_list|)
argument_list|,
name|sz
argument_list|)
decl_stmt|;
name|HEAP_ASSERT
argument_list|(
name|r
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// __KERNEL_MODE__
name|iChunkSize
operator|-=
name|sz
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
end_ifndef
begin_comment
comment|//
end_comment
begin_comment
comment|// Slab allocator code
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//inline slab* slab::SlabFor(void* p)
end_comment
begin_function
DECL|function|SlabFor
name|slab
modifier|*
name|slab
operator|::
name|SlabFor
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|slab
operator|*
operator|)
operator|(
name|Floor
argument_list|(
name|p
argument_list|,
name|SLABSIZE
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Remove slab s from its tree/heap (not necessarily the root), preserving the address order
end_comment
begin_comment
comment|// invariant of the heap
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|TreeRemove
name|void
name|RHybridHeap
operator|::
name|TreeRemove
parameter_list|(
name|slab
modifier|*
name|s
parameter_list|)
block|{
name|slab
modifier|*
modifier|*
name|r
init|=
name|s
operator|->
name|iParent
decl_stmt|;
name|slab
modifier|*
name|c1
init|=
name|s
operator|->
name|iChild1
decl_stmt|;
name|slab
modifier|*
name|c2
init|=
name|s
operator|->
name|iChild2
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|c2
condition|)
block|{
operator|*
name|r
operator|=
name|c1
expr_stmt|;
if|if
condition|(
name|c1
condition|)
name|c1
operator|->
name|iParent
operator|=
name|r
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|c1
condition|)
block|{
operator|*
name|r
operator|=
name|c2
expr_stmt|;
name|c2
operator|->
name|iParent
operator|=
name|r
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c1
operator|>
name|c2
condition|)
block|{
name|slab
modifier|*
name|c3
init|=
name|c1
decl_stmt|;
name|c1
operator|=
name|c2
expr_stmt|;
name|c2
operator|=
name|c3
expr_stmt|;
block|}
name|slab
modifier|*
name|newc2
init|=
name|c1
operator|->
name|iChild2
decl_stmt|;
operator|*
name|r
operator|=
name|c1
expr_stmt|;
name|c1
operator|->
name|iParent
operator|=
name|r
expr_stmt|;
name|c1
operator|->
name|iChild2
operator|=
name|c2
expr_stmt|;
name|c2
operator|->
name|iParent
operator|=
operator|&
name|c1
operator|->
name|iChild2
expr_stmt|;
name|s
operator|=
name|c1
expr_stmt|;
name|c1
operator|=
name|s
operator|->
name|iChild1
expr_stmt|;
name|c2
operator|=
name|newc2
expr_stmt|;
name|r
operator|=
operator|&
name|s
operator|->
name|iChild1
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Insert slab s into the tree/heap rooted at r, preserving the address ordering
end_comment
begin_comment
comment|// invariant of the heap
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|TreeInsert
name|void
name|RHybridHeap
operator|::
name|TreeInsert
parameter_list|(
name|slab
modifier|*
name|s
parameter_list|,
name|slab
modifier|*
modifier|*
name|r
parameter_list|)
block|{
name|slab
modifier|*
name|n
init|=
operator|*
name|r
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|// tree empty
operator|*
name|r
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|iParent
operator|=
name|r
expr_stmt|;
name|s
operator|->
name|iChild1
operator|=
name|s
operator|->
name|iChild2
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|<
name|n
condition|)
block|{
comment|// insert between iParent and n
operator|*
name|r
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|iParent
operator|=
name|r
expr_stmt|;
name|s
operator|->
name|iChild1
operator|=
name|n
expr_stmt|;
name|s
operator|->
name|iChild2
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|iParent
operator|=
operator|&
name|s
operator|->
name|iChild1
expr_stmt|;
break|break;
block|}
name|slab
modifier|*
name|c1
init|=
name|n
operator|->
name|iChild1
decl_stmt|;
name|slab
modifier|*
name|c2
init|=
name|n
operator|->
name|iChild2
decl_stmt|;
if|if
condition|(
operator|(
name|c1
operator|-
literal|1
operator|)
operator|>
operator|(
name|c2
operator|-
literal|1
operator|)
condition|)
block|{
name|r
operator|=
operator|&
name|n
operator|->
name|iChild1
expr_stmt|;
name|n
operator|=
name|c1
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
operator|&
name|n
operator|->
name|iChild2
expr_stmt|;
name|n
operator|=
name|c2
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|AllocNewSlab
name|void
modifier|*
name|RHybridHeap
operator|::
name|AllocNewSlab
parameter_list|(
name|slabset
modifier|&
name|allocator
parameter_list|)
comment|//
comment|// Acquire and initialise a new slab, returning a cell from the slab
comment|// The strategy is:
comment|// 1. Use the lowest address free slab, if available. This is done by using the lowest slab
comment|//    in the page at the root of the iPartialPage heap (which is address ordered). If the
comment|//    is now fully used, remove it from the iPartialPage heap.
comment|// 2. Allocate a new page for iSlabs if no empty iSlabs are available
comment|//
block|{
name|page
modifier|*
name|p
init|=
name|page
operator|::
name|PageFor
argument_list|(
name|iPartialPage
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|AllocNewPage
argument_list|(
name|allocator
argument_list|)
return|;
name|unsigned
name|h
init|=
name|p
operator|->
name|iSlabs
index|[
literal|0
index|]
operator|.
name|iHeader
decl_stmt|;
name|unsigned
name|pagemap
init|=
name|SlabHeaderPagemap
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|HEAP_ASSERT
argument_list|(
operator|&
name|p
operator|->
name|iSlabs
index|[
name|HIBIT
argument_list|(
name|pagemap
argument_list|)
index|]
operator|==
name|iPartialPage
argument_list|)
expr_stmt|;
name|unsigned
name|slabix
init|=
name|LOWBIT
argument_list|(
name|pagemap
argument_list|)
decl_stmt|;
name|p
operator|->
name|iSlabs
index|[
literal|0
index|]
operator|.
name|iHeader
operator|=
name|h
operator|&
operator|~
operator|(
literal|0x100
operator|<<
name|slabix
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pagemap
operator|&
operator|~
operator|(
literal|1
operator|<<
name|slabix
operator|)
operator|)
condition|)
block|{
name|TreeRemove
argument_list|(
name|iPartialPage
argument_list|)
expr_stmt|;
comment|// last free slab in page
block|}
return|return
name|InitNewSlab
argument_list|(
name|allocator
argument_list|,
operator|&
name|p
operator|->
name|iSlabs
index|[
name|slabix
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**Defination of this functionis not there in proto code***/
end_comment
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
unit|void RHybridHeap::partial_insert(slab* s) {
comment|// slab has had first cell freed and needs to be linked back into iPartial tree
end_comment
begin_comment
unit|slabset& ss = iSlabAlloc[iSizeMap[s->clz]]; 	 	HEAP_ASSERT(s->used == slabfull); 	s->used = ss.fulluse - s->clz;
comment|// full-1 loading
end_comment
begin_comment
unit|TreeInsert(s,&ss.iPartial); 	CHECKTREE(&ss.iPartial); }
comment|/**Defination of this functionis not there in proto code***/
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|AllocNewPage
name|void
modifier|*
name|RHybridHeap
operator|::
name|AllocNewPage
parameter_list|(
name|slabset
modifier|&
name|allocator
parameter_list|)
comment|//
comment|// Acquire and initialise a new page, returning a cell from a new slab
comment|// The iPartialPage tree is empty (otherwise we'd have used a slab from there)
comment|// The iPartialPage link is put in the highest addressed slab in the page, and the
comment|// lowest addressed slab is used to fulfill the allocation request
comment|//
block|{
name|page
modifier|*
name|p
init|=
name|iSparePage
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|iSparePage
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|p
operator|=
cast|static_cast
argument_list|<
name|page
operator|*
argument_list|>
argument_list|(
name|Map
argument_list|(
literal|0
argument_list|,
name|iPageSize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
literal|0
return|;
block|}
name|HEAP_ASSERT
argument_list|(
name|p
operator|==
name|Floor
argument_list|(
name|p
argument_list|,
name|iPageSize
argument_list|)
argument_list|)
expr_stmt|;
comment|// Store page allocated for slab into paged_bitmap (for RHybridHeap::Reset())
if|if
condition|(
operator|!
name|PagedSetSize
argument_list|(
name|p
argument_list|,
name|iPageSize
argument_list|)
condition|)
block|{
name|Unmap
argument_list|(
name|p
argument_list|,
name|iPageSize
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|->
name|iSlabs
index|[
literal|0
index|]
operator|.
name|iHeader
operator|=
operator|(
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|<<
literal|8
expr_stmt|;
comment|// set pagemap
name|p
operator|->
name|iSlabs
index|[
literal|3
index|]
operator|.
name|iParent
operator|=
operator|&
name|iPartialPage
expr_stmt|;
name|p
operator|->
name|iSlabs
index|[
literal|3
index|]
operator|.
name|iChild1
operator|=
name|p
operator|->
name|iSlabs
index|[
literal|3
index|]
operator|.
name|iChild2
operator|=
literal|0
expr_stmt|;
name|iPartialPage
operator|=
operator|&
name|p
operator|->
name|iSlabs
index|[
literal|3
index|]
expr_stmt|;
return|return
name|InitNewSlab
argument_list|(
name|allocator
argument_list|,
operator|&
name|p
operator|->
name|iSlabs
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|FreePage
name|void
name|RHybridHeap
operator|::
name|FreePage
parameter_list|(
name|page
modifier|*
name|p
parameter_list|)
comment|//
comment|// Release an unused page to the OS
comment|// A single page is cached for reuse to reduce thrashing
comment|// the OS allocator.
comment|//
block|{
name|HEAP_ASSERT
argument_list|(
name|Ceiling
argument_list|(
name|p
argument_list|,
name|iPageSize
argument_list|)
operator|==
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iSparePage
condition|)
block|{
name|iSparePage
operator|=
name|p
expr_stmt|;
return|return;
block|}
comment|// unmapped slab page must be cleared from paged_bitmap, too
name|PagedZapSize
argument_list|(
name|p
argument_list|,
name|iPageSize
argument_list|)
expr_stmt|;
comment|// clear page map
name|Unmap
argument_list|(
name|p
argument_list|,
name|iPageSize
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|FreeSlab
name|void
name|RHybridHeap
operator|::
name|FreeSlab
parameter_list|(
name|slab
modifier|*
name|s
parameter_list|)
comment|//
comment|// Release an empty slab to the slab manager
comment|// The strategy is:
comment|// 1. The page containing the slab is checked to see the state of the other iSlabs in the page by
comment|//    inspecting the pagemap field in the iHeader of the first slab in the page.
comment|// 2. The pagemap is updated to indicate the new unused slab
comment|// 3. If this is the only unused slab in the page then the slab iHeader is used to add the page to
comment|//    the iPartialPage tree/heap
comment|// 4. If all the iSlabs in the page are now unused the page is release back to the OS
comment|// 5. If this slab has a higher address than the one currently used to track this page in
comment|//    the iPartialPage heap, the linkage is moved to the new unused slab
comment|//
block|{
name|TreeRemove
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|CHECKTREE
argument_list|(
name|s
operator|->
name|iParent
argument_list|)
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|SlabHeaderUsedm4
argument_list|(
name|s
operator|->
name|iHeader
argument_list|)
operator|==
name|SlabHeaderSize
argument_list|(
name|s
operator|->
name|iHeader
argument_list|)
operator|-
literal|4
argument_list|)
expr_stmt|;
name|page
modifier|*
name|p
init|=
name|page
operator|::
name|PageFor
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|unsigned
name|h
init|=
name|p
operator|->
name|iSlabs
index|[
literal|0
index|]
operator|.
name|iHeader
decl_stmt|;
name|int
name|slabix
init|=
name|s
operator|-
operator|&
name|p
operator|->
name|iSlabs
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|pagemap
init|=
name|SlabHeaderPagemap
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|p
operator|->
name|iSlabs
index|[
literal|0
index|]
operator|.
name|iHeader
operator|=
name|h
operator||
operator|(
literal|0x100
operator|<<
name|slabix
operator|)
expr_stmt|;
if|if
condition|(
name|pagemap
operator|==
literal|0
condition|)
block|{
comment|// page was full before, use this slab as link in empty heap
name|TreeInsert
argument_list|(
name|s
argument_list|,
operator|&
name|iPartialPage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Find the current empty-link slab
name|slab
modifier|*
name|sl
init|=
operator|&
name|p
operator|->
name|iSlabs
index|[
name|HIBIT
argument_list|(
name|pagemap
argument_list|)
index|]
decl_stmt|;
name|pagemap
operator|^=
operator|(
literal|1
operator|<<
name|slabix
operator|)
expr_stmt|;
if|if
condition|(
name|pagemap
operator|==
literal|0xf
condition|)
block|{
comment|// page is now empty so recycle page to os
name|TreeRemove
argument_list|(
name|sl
argument_list|)
expr_stmt|;
name|FreePage
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// ensure the free list link is in highest address slab in page
if|if
condition|(
name|s
operator|>
name|sl
condition|)
block|{
comment|// replace current link with new one. Address-order tree so position stays the same
name|slab
modifier|*
modifier|*
name|r
init|=
name|sl
operator|->
name|iParent
decl_stmt|;
name|slab
modifier|*
name|c1
init|=
name|sl
operator|->
name|iChild1
decl_stmt|;
name|slab
modifier|*
name|c2
init|=
name|sl
operator|->
name|iChild2
decl_stmt|;
name|s
operator|->
name|iParent
operator|=
name|r
expr_stmt|;
name|s
operator|->
name|iChild1
operator|=
name|c1
expr_stmt|;
name|s
operator|->
name|iChild2
operator|=
name|c2
expr_stmt|;
operator|*
name|r
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|c1
condition|)
name|c1
operator|->
name|iParent
operator|=
operator|&
name|s
operator|->
name|iChild1
expr_stmt|;
if|if
condition|(
name|c2
condition|)
name|c2
operator|->
name|iParent
operator|=
operator|&
name|s
operator|->
name|iChild2
expr_stmt|;
block|}
name|CHECK
argument_list|(
argument|if (s< sl) s=sl
argument_list|)
empty_stmt|;
block|}
name|HEAP_ASSERT
argument_list|(
name|SlabHeaderPagemap
argument_list|(
name|p
operator|->
name|iSlabs
index|[
literal|0
index|]
operator|.
name|iHeader
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|HIBIT
argument_list|(
name|SlabHeaderPagemap
argument_list|(
name|p
operator|->
name|iSlabs
index|[
literal|0
index|]
operator|.
name|iHeader
argument_list|)
argument_list|)
operator|==
name|unsigned
argument_list|(
name|s
operator|-
operator|&
name|p
operator|->
name|iSlabs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|SlabInit
name|void
name|RHybridHeap
operator|::
name|SlabInit
parameter_list|()
block|{
name|iSlabThreshold
operator|=
literal|0
expr_stmt|;
name|iPartialPage
operator|=
literal|0
expr_stmt|;
name|iFullSlab
operator|=
literal|0
expr_stmt|;
name|iSparePage
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|iSizeMap
index|[
literal|0
index|]
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|iSizeMap
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|iSlabAlloc
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iSlabAlloc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|SlabConfig
name|void
name|RHybridHeap
operator|::
name|SlabConfig
parameter_list|(
name|unsigned
name|slabbitmap
parameter_list|)
block|{
name|HEAP_ASSERT
argument_list|(
operator|(
name|slabbitmap
operator|&
operator|~
name|EOkBits
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|MAXSLABSIZE
operator|<=
literal|60
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|ix
init|=
literal|0xff
decl_stmt|;
name|unsigned
name|int
name|bit
init|=
literal|1
operator|<<
operator|(
operator|(
name|MAXSLABSIZE
operator|>>
literal|2
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
for|for
control|(
name|int
name|sz
init|=
name|MAXSLABSIZE
init|;
name|sz
operator|>=
literal|0
condition|;
name|sz
operator|-=
literal|4
operator|,
name|bit
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|slabbitmap
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|ix
operator|==
literal|0xff
condition|)
name|iSlabThreshold
operator|=
name|sz
operator|+
literal|1
expr_stmt|;
name|ix
operator|=
operator|(
name|sz
operator|>>
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|iSizeMap
index|[
name|sz
operator|>>
literal|2
index|]
operator|=
operator|(
name|TUint8
operator|)
name|ix
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|SlabAllocate
name|void
modifier|*
name|RHybridHeap
operator|::
name|SlabAllocate
parameter_list|(
name|slabset
modifier|&
name|ss
parameter_list|)
comment|//
comment|// Allocate a cell from the given slabset
comment|// Strategy:
comment|// 1. Take the partially full slab at the iTop of the heap (lowest address).
comment|// 2. If there is no such slab, allocate from a new slab
comment|// 3. If the slab has a non-empty freelist, pop the cell from the front of the list and update the slab
comment|// 4. Otherwise, if the slab is not full, return the cell at the end of the currently used region of
comment|//    the slab, updating the slab
comment|// 5. Otherwise, release the slab from the iPartial tree/heap, marking it as 'floating' and go back to
comment|//    step 1
comment|//
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|slab
modifier|*
name|s
init|=
name|ss
operator|.
name|iPartial
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
break|break;
name|unsigned
name|h
init|=
name|s
operator|->
name|iHeader
decl_stmt|;
name|unsigned
name|free
init|=
name|h
operator|&
literal|0xff
decl_stmt|;
comment|// extract free cell positioning
if|if
condition|(
name|free
condition|)
block|{
name|HEAP_ASSERT
argument_list|(
operator|(
operator|(
name|free
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|slabhdr
argument_list|)
operator|)
operator|%
name|SlabHeaderSize
argument_list|(
name|h
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|void
modifier|*
name|p
init|=
name|Offset
argument_list|(
name|s
argument_list|,
name|free
operator|<<
literal|2
argument_list|)
decl_stmt|;
name|free
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
expr_stmt|;
comment|// get next pos in free list
name|h
operator|+=
operator|(
name|h
operator|&
literal|0x3C000
operator|)
operator|<<
literal|6
expr_stmt|;
comment|// update usedm4
name|h
operator|&=
operator|~
literal|0xff
expr_stmt|;
name|h
operator||=
name|free
expr_stmt|;
comment|// update freelist
name|s
operator|->
name|iHeader
operator|=
name|h
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|SlabHeaderFree
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|SlabHeaderFree
argument_list|(
name|h
argument_list|)
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|slabhdr
argument_list|)
operator|)
operator|%
name|SlabHeaderSize
argument_list|(
name|h
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
name|SlabHeaderUsedm4
argument_list|(
name|h
argument_list|)
operator|<=
literal|0x3F8u
argument_list|)
expr_stmt|;
name|HEAP_ASSERT
argument_list|(
operator|(
name|SlabHeaderUsedm4
argument_list|(
name|h
argument_list|)
operator|+
literal|4
operator|)
operator|%
name|SlabHeaderSize
argument_list|(
name|h
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
name|unsigned
name|h2
init|=
name|h
operator|+
operator|(
operator|(
name|h
operator|&
literal|0x3C000
operator|)
operator|<<
literal|6
operator|)
decl_stmt|;
comment|//		if (h2< 0xfc00000)
if|if
condition|(
name|h2
operator|<
name|MAXUSEDM4BITS
condition|)
block|{
name|HEAP_ASSERT
argument_list|(
operator|(
name|SlabHeaderUsedm4
argument_list|(
name|h2
argument_list|)
operator|+
literal|4
operator|)
operator|%
name|SlabHeaderSize
argument_list|(
name|h2
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|s
operator|->
name|iHeader
operator|=
name|h2
expr_stmt|;
return|return
name|Offset
argument_list|(
name|s
argument_list|,
operator|(
name|h
operator|>>
literal|18
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|slabhdr
argument_list|)
argument_list|)
return|;
block|}
name|h
operator||=
name|FLOATING_BIT
expr_stmt|;
comment|// mark the slab as full-floating
name|s
operator|->
name|iHeader
operator|=
name|h
expr_stmt|;
name|TreeRemove
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|slab
modifier|*
name|c
init|=
name|iFullSlab
decl_stmt|;
comment|// add to full list
name|iFullSlab
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|iParent
operator|=
operator|&
name|iFullSlab
expr_stmt|;
name|s
operator|->
name|iChild1
operator|=
name|c
expr_stmt|;
name|s
operator|->
name|iChild2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|c
operator|->
name|iParent
operator|=
operator|&
name|s
operator|->
name|iChild1
expr_stmt|;
name|CHECKTREE
argument_list|(
operator|&
name|ss
operator|.
name|iPartial
argument_list|)
expr_stmt|;
comment|// go back and try the next slab...
block|}
comment|// no iPartial iSlabs found, so allocate from a new slab
return|return
name|AllocNewSlab
argument_list|(
name|ss
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|SlabFree
name|void
name|RHybridHeap
operator|::
name|SlabFree
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
comment|//
comment|// Free a cell from the slab allocator
comment|// Strategy:
comment|// 1. Find the containing slab (round down to nearest 1KB boundary)
comment|// 2. Push the cell into the slab's freelist, and update the slab usage count
comment|// 3. If this is the last allocated cell, free the slab to the main slab manager
comment|// 4. If the slab was full-floating then insert the slab in it's respective iPartial tree
comment|//
block|{
name|HEAP_ASSERT
argument_list|(
name|LowBits
argument_list|(
name|p
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|slab
modifier|*
name|s
init|=
name|slab
operator|::
name|SlabFor
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|CHECKSLAB
argument_list|(
name|s
argument_list|,
name|ESlabAllocator
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|CHECKSLABBFR
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|unsigned
name|pos
init|=
name|LowBits
argument_list|(
name|p
argument_list|,
name|SLABSIZE
argument_list|)
decl_stmt|;
name|unsigned
name|h
init|=
name|s
operator|->
name|iHeader
decl_stmt|;
name|HEAP_ASSERT
argument_list|(
name|SlabHeaderUsedm4
argument_list|(
name|h
argument_list|)
operator|!=
literal|0x3fC
argument_list|)
expr_stmt|;
comment|// slab is empty already
name|HEAP_ASSERT
argument_list|(
operator|(
name|pos
operator|-
sizeof|sizeof
argument_list|(
name|slabhdr
argument_list|)
operator|)
operator|%
name|SlabHeaderSize
argument_list|(
name|h
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|=
operator|(
name|unsigned
name|char
operator|)
name|h
expr_stmt|;
name|h
operator|&=
operator|~
literal|0xFF
expr_stmt|;
name|h
operator||=
operator|(
name|pos
operator|>>
literal|2
operator|)
expr_stmt|;
name|unsigned
name|size
init|=
name|h
operator|&
literal|0x3C000
decl_stmt|;
if|if
condition|(
name|int
argument_list|(
name|h
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|h
operator|-=
name|size
operator|<<
literal|6
expr_stmt|;
if|if
condition|(
name|int
argument_list|(
name|h
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|s
operator|->
name|iHeader
operator|=
name|h
expr_stmt|;
return|return;
block|}
name|FreeSlab
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|h
operator|-=
name|size
operator|<<
literal|6
expr_stmt|;
name|h
operator|&=
operator|~
name|FLOATING_BIT
expr_stmt|;
name|s
operator|->
name|iHeader
operator|=
name|h
expr_stmt|;
name|slab
modifier|*
modifier|*
name|full
init|=
name|s
operator|->
name|iParent
decl_stmt|;
comment|// remove from full list
name|slab
modifier|*
name|c
init|=
name|s
operator|->
name|iChild1
decl_stmt|;
operator|*
name|full
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|c
operator|->
name|iParent
operator|=
name|full
expr_stmt|;
name|slabset
modifier|&
name|ss
init|=
name|iSlabAlloc
index|[
name|iSizeMap
index|[
name|size
operator|>>
literal|14
index|]
index|]
decl_stmt|;
name|TreeInsert
argument_list|(
name|s
argument_list|,
operator|&
name|ss
operator|.
name|iPartial
argument_list|)
expr_stmt|;
name|CHECKTREE
argument_list|(
operator|&
name|ss
operator|.
name|iPartial
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|InitNewSlab
name|void
modifier|*
name|RHybridHeap
operator|::
name|InitNewSlab
parameter_list|(
name|slabset
modifier|&
name|allocator
parameter_list|,
name|slab
modifier|*
name|s
parameter_list|)
comment|//
comment|// initialise an empty slab for this allocator and return the fist cell
comment|// pre-condition: the slabset has no iPartial iSlabs for allocation
comment|//
block|{
name|HEAP_ASSERT
argument_list|(
name|allocator
operator|.
name|iPartial
operator|==
literal|0
argument_list|)
expr_stmt|;
name|TInt
name|size
init|=
literal|4
operator|+
operator|(
operator|(
operator|&
name|allocator
operator|-
operator|&
name|iSlabAlloc
index|[
literal|0
index|]
operator|)
operator|<<
literal|2
operator|)
decl_stmt|;
comment|// infer size from slab allocator address
name|unsigned
name|h
init|=
name|s
operator|->
name|iHeader
operator|&
literal|0xF00
decl_stmt|;
comment|// preserve pagemap only
name|h
operator||=
operator|(
name|size
operator|<<
literal|12
operator|)
expr_stmt|;
comment|// set size
name|h
operator||=
operator|(
name|size
operator|-
literal|4
operator|)
operator|<<
literal|18
expr_stmt|;
comment|// set usedminus4 to one object minus 4
name|s
operator|->
name|iHeader
operator|=
name|h
expr_stmt|;
name|allocator
operator|.
name|iPartial
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|iParent
operator|=
operator|&
name|allocator
operator|.
name|iPartial
expr_stmt|;
name|s
operator|->
name|iChild1
operator|=
name|s
operator|->
name|iChild2
operator|=
literal|0
expr_stmt|;
return|return
name|Offset
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|slabhdr
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|slab_bitcount
specifier|const
name|unsigned
name|char
name|slab_bitcount
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|slab_ext_frag
specifier|const
name|unsigned
name|char
name|slab_ext_frag
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|4
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|8
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|12
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|16
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|20
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|24
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|28
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|32
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|36
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|40
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|44
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|48
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|52
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|56
operator|)
block|,
literal|16
operator|+
operator|(
literal|1008
operator|%
literal|60
operator|)
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|TreeWalk
name|void
name|RHybridHeap
operator|::
name|TreeWalk
parameter_list|(
name|slab
modifier|*
specifier|const
modifier|*
name|root
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|slab
modifier|*
parameter_list|,
name|struct
name|HeapInfo
modifier|*
parameter_list|,
name|SWalkInfo
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|HeapInfo
modifier|*
name|i
parameter_list|,
name|SWalkInfo
modifier|*
name|wi
parameter_list|)
block|{
comment|// iterative walk around the tree at root
name|slab
modifier|*
name|s
init|=
operator|*
name|root
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|slab
modifier|*
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|s
operator|->
name|iChild1
operator|)
operator|!=
literal|0
condition|)
name|s
operator|=
name|c
expr_stmt|;
comment|// walk down left side to end
for|for
control|(
init|;
condition|;
control|)
block|{
name|f
argument_list|(
name|s
argument_list|,
name|i
argument_list|,
name|wi
argument_list|)
expr_stmt|;
name|c
operator|=
name|s
operator|->
name|iChild2
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
comment|// one step down right side, now try and walk down left
name|s
operator|=
name|c
expr_stmt|;
break|break;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// loop to walk up right side
name|slab
modifier|*
modifier|*
name|pp
init|=
name|s
operator|->
name|iParent
decl_stmt|;
if|if
condition|(
name|pp
operator|==
name|root
condition|)
return|return;
name|s
operator|=
name|slab
operator|::
name|SlabFor
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
operator|&
name|s
operator|->
name|iChild1
condition|)
break|break;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|SlabEmptyInfo
name|void
name|RHybridHeap
operator|::
name|SlabEmptyInfo
parameter_list|(
name|slab
modifier|*
name|s
parameter_list|,
name|struct
name|HeapInfo
modifier|*
name|i
parameter_list|,
name|SWalkInfo
modifier|*
name|wi
parameter_list|)
block|{
name|Walk
argument_list|(
name|wi
argument_list|,
name|s
argument_list|,
name|SLABSIZE
argument_list|,
name|EGoodFreeCell
argument_list|,
name|EEmptySlab
argument_list|)
expr_stmt|;
comment|// Introduce an empty slab to the walk function
name|int
name|nslab
init|=
name|slab_bitcount
index|[
name|SlabHeaderPagemap
argument_list|(
name|page
operator|::
name|PageFor
argument_list|(
name|s
argument_list|)
operator|->
name|iSlabs
index|[
literal|0
index|]
operator|.
name|iHeader
argument_list|)
index|]
decl_stmt|;
name|i
operator|->
name|iFreeN
operator|+=
name|nslab
expr_stmt|;
name|i
operator|->
name|iFreeBytes
operator|+=
name|nslab
operator|<<
name|SLABSHIFT
expr_stmt|;
block|}
end_function
begin_function
DECL|function|SlabPartialInfo
name|void
name|RHybridHeap
operator|::
name|SlabPartialInfo
parameter_list|(
name|slab
modifier|*
name|s
parameter_list|,
name|struct
name|HeapInfo
modifier|*
name|i
parameter_list|,
name|SWalkInfo
modifier|*
name|wi
parameter_list|)
block|{
name|Walk
argument_list|(
name|wi
argument_list|,
name|s
argument_list|,
name|SLABSIZE
argument_list|,
name|EGoodAllocatedCell
argument_list|,
name|EPartialFullSlab
argument_list|)
expr_stmt|;
comment|// Introduce a full slab to the walk function
name|unsigned
name|h
init|=
name|s
operator|->
name|iHeader
decl_stmt|;
name|unsigned
name|used
init|=
name|SlabHeaderUsedm4
argument_list|(
name|h
argument_list|)
operator|+
literal|4
decl_stmt|;
name|unsigned
name|size
init|=
name|SlabHeaderSize
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|unsigned
name|free
init|=
literal|1024
operator|-
name|slab_ext_frag
index|[
name|size
operator|>>
literal|2
index|]
operator|-
name|used
decl_stmt|;
name|i
operator|->
name|iFreeN
operator|+=
operator|(
name|free
operator|/
name|size
operator|)
expr_stmt|;
name|i
operator|->
name|iFreeBytes
operator|+=
name|free
expr_stmt|;
name|i
operator|->
name|iAllocN
operator|+=
operator|(
name|used
operator|/
name|size
operator|)
expr_stmt|;
name|i
operator|->
name|iAllocBytes
operator|+=
name|used
expr_stmt|;
block|}
end_function
begin_function
DECL|function|SlabFullInfo
name|void
name|RHybridHeap
operator|::
name|SlabFullInfo
parameter_list|(
name|slab
modifier|*
name|s
parameter_list|,
name|struct
name|HeapInfo
modifier|*
name|i
parameter_list|,
name|SWalkInfo
modifier|*
name|wi
parameter_list|)
block|{
name|Walk
argument_list|(
name|wi
argument_list|,
name|s
argument_list|,
name|SLABSIZE
argument_list|,
name|EGoodAllocatedCell
argument_list|,
name|EFullSlab
argument_list|)
expr_stmt|;
comment|// Introduce a full slab to the walk function
name|unsigned
name|h
init|=
name|s
operator|->
name|iHeader
decl_stmt|;
name|unsigned
name|used
init|=
name|SlabHeaderUsedm4
argument_list|(
name|h
argument_list|)
operator|+
literal|4
decl_stmt|;
name|unsigned
name|size
init|=
name|SlabHeaderSize
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|HEAP_ASSERT
argument_list|(
literal|1024
operator|-
name|slab_ext_frag
index|[
name|size
operator|>>
literal|2
index|]
operator|-
name|used
operator|==
literal|0
argument_list|)
expr_stmt|;
name|i
operator|->
name|iAllocN
operator|+=
operator|(
name|used
operator|/
name|size
operator|)
expr_stmt|;
name|i
operator|->
name|iAllocBytes
operator|+=
name|used
expr_stmt|;
block|}
end_function
begin_function
DECL|function|SlabInfo
name|void
name|RHybridHeap
operator|::
name|SlabInfo
parameter_list|(
name|struct
name|HeapInfo
modifier|*
name|i
parameter_list|,
name|SWalkInfo
modifier|*
name|wi
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|iSparePage
condition|)
block|{
name|i
operator|->
name|iFreeBytes
operator|+=
name|iPageSize
expr_stmt|;
name|i
operator|->
name|iFreeN
operator|=
literal|4
expr_stmt|;
name|Walk
argument_list|(
name|wi
argument_list|,
name|iSparePage
argument_list|,
name|iPageSize
argument_list|,
name|EGoodFreeCell
argument_list|,
name|ESlabSpare
argument_list|)
expr_stmt|;
comment|// Introduce Slab spare page to the walk function
block|}
name|TreeWalk
argument_list|(
operator|&
name|iFullSlab
argument_list|,
operator|&
name|SlabFullInfo
argument_list|,
name|i
argument_list|,
name|wi
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|ix
init|=
literal|0
init|;
name|ix
operator|<
operator|(
name|MAXSLABSIZE
operator|>>
literal|2
operator|)
condition|;
operator|++
name|ix
control|)
name|TreeWalk
argument_list|(
operator|&
name|iSlabAlloc
index|[
name|ix
index|]
operator|.
name|iPartial
argument_list|,
operator|&
name|SlabPartialInfo
argument_list|,
name|i
argument_list|,
name|wi
argument_list|)
expr_stmt|;
name|TreeWalk
argument_list|(
operator|&
name|iPartialPage
argument_list|,
operator|&
name|SlabEmptyInfo
argument_list|,
name|i
argument_list|,
name|wi
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Bitmap class implementation for large page allocator
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|Addr
specifier|inline
name|unsigned
name|char
modifier|*
name|paged_bitmap
operator|::
name|Addr
parameter_list|()
specifier|const
block|{
return|return
name|iBase
return|;
block|}
end_function
begin_function
DECL|function|Size
specifier|inline
name|unsigned
name|paged_bitmap
operator|::
name|Size
parameter_list|()
specifier|const
block|{
return|return
name|iNbits
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_function
DECL|function|Init
name|void
name|paged_bitmap
operator|::
name|Init
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|size
parameter_list|,
name|unsigned
name|bit
parameter_list|)
block|{
name|iBase
operator|=
name|p
expr_stmt|;
name|iNbits
operator|=
name|size
expr_stmt|;
name|int
name|bytes
init|=
name|Ceiling
argument_list|(
name|size
argument_list|,
literal|8
argument_list|)
operator|>>
literal|3
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
name|bit
condition|?
literal|0xff
else|:
literal|0
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Set
specifier|inline
name|void
name|paged_bitmap
operator|::
name|Set
parameter_list|(
name|unsigned
name|ix
parameter_list|,
name|unsigned
name|bit
parameter_list|)
block|{
if|if
condition|(
name|bit
condition|)
name|iBase
index|[
name|ix
operator|>>
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|ix
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
else|else
name|iBase
index|[
name|ix
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|ix
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|operator []
specifier|inline
name|unsigned
name|paged_bitmap
operator|::
name|operator
name|[]
parameter_list|(
name|unsigned
name|ix
parameter_list|)
specifier|const
block|{
return|return
literal|1U
operator|&
operator|(
name|iBase
index|[
name|ix
operator|>>
literal|3
index|]
operator|>>
operator|(
name|ix
operator|&
literal|7
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|Setn
name|void
name|paged_bitmap
operator|::
name|Setn
parameter_list|(
name|unsigned
name|ix
parameter_list|,
name|unsigned
name|len
parameter_list|,
name|unsigned
name|bit
parameter_list|)
block|{
name|int
name|l
init|=
name|len
decl_stmt|;
while|while
condition|(
operator|--
name|l
operator|>=
literal|0
condition|)
name|Set
argument_list|(
name|ix
operator|++
argument_list|,
name|bit
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Set
name|void
name|paged_bitmap
operator|::
name|Set
parameter_list|(
name|unsigned
name|ix
parameter_list|,
name|unsigned
name|len
parameter_list|,
name|unsigned
name|val
parameter_list|)
block|{
name|int
name|l
init|=
name|len
decl_stmt|;
while|while
condition|(
operator|--
name|l
operator|>=
literal|0
condition|)
block|{
name|Set
argument_list|(
name|ix
operator|++
argument_list|,
name|val
operator|&
literal|1
argument_list|)
expr_stmt|;
name|val
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|Bits
name|unsigned
name|paged_bitmap
operator|::
name|Bits
parameter_list|(
name|unsigned
name|ix
parameter_list|,
name|unsigned
name|len
parameter_list|)
specifier|const
block|{
name|int
name|l
init|=
name|len
decl_stmt|;
name|unsigned
name|val
init|=
literal|0
decl_stmt|;
name|unsigned
name|bit
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|--
name|l
operator|>=
literal|0
condition|)
name|val
operator||=
operator|(
operator|*
name|this
operator|)
index|[
name|ix
operator|++
index|]
operator|<<
name|bit
operator|++
expr_stmt|;
return|return
name|val
return|;
block|}
end_function
begin_function
DECL|function|Is
name|bool
name|paged_bitmap
operator|::
name|Is
parameter_list|(
name|unsigned
name|ix
parameter_list|,
name|unsigned
name|len
parameter_list|,
name|unsigned
name|bit
parameter_list|)
specifier|const
block|{
name|unsigned
name|i2
init|=
name|ix
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|i2
operator|>
name|iNbits
condition|)
return|return
literal|false
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|this
operator|)
index|[
name|ix
index|]
operator|!=
name|bit
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|++
name|ix
operator|==
name|i2
condition|)
return|return
literal|true
return|;
block|}
block|}
end_function
begin_function
DECL|function|Find
name|int
name|paged_bitmap
operator|::
name|Find
parameter_list|(
name|unsigned
name|start
parameter_list|,
name|unsigned
name|bit
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|start
operator|<
name|iNbits
condition|)
do|do
block|{
if|if
condition|(
operator|(
operator|*
name|this
operator|)
index|[
name|start
index|]
operator|==
name|bit
condition|)
return|return
name|start
return|;
block|}
do|while
condition|(
operator|++
name|start
operator|<
name|iNbits
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Page allocator code
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|PagedInit
name|void
name|RHybridHeap
operator|::
name|PagedInit
parameter_list|(
name|TInt
name|aPagePower
parameter_list|)
block|{
if|if
condition|(
name|aPagePower
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|aPagePower
operator|<
name|MINPAGEPOWER
condition|)
name|aPagePower
operator|=
name|MINPAGEPOWER
expr_stmt|;
block|}
else|else
name|aPagePower
operator|=
literal|31
expr_stmt|;
name|iPageThreshold
operator|=
name|aPagePower
expr_stmt|;
comment|/*------------------------------------------------------------- 	 * Initialize page bitmap 	 *-------------------------------------------------------------*/
name|iPageMap
operator|.
name|Init
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|iBitMapBuffer
argument_list|,
name|MAXSMALLPAGEBITS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|PagedAllocate
name|void
modifier|*
name|RHybridHeap
operator|::
name|PagedAllocate
parameter_list|(
name|unsigned
name|size
parameter_list|)
block|{
name|TInt
name|nbytes
init|=
name|Ceiling
argument_list|(
name|size
argument_list|,
name|iPageSize
argument_list|)
decl_stmt|;
name|void
modifier|*
name|p
init|=
name|Map
argument_list|(
literal|0
argument_list|,
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|PagedSetSize
argument_list|(
name|p
argument_list|,
name|nbytes
argument_list|)
condition|)
block|{
name|Unmap
argument_list|(
name|p
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|PagedReallocate
name|void
modifier|*
name|RHybridHeap
operator|::
name|PagedReallocate
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|unsigned
name|size
parameter_list|,
name|TInt
name|mode
parameter_list|)
block|{
name|HEAP_ASSERT
argument_list|(
name|Ceiling
argument_list|(
name|p
argument_list|,
name|iPageSize
argument_list|)
operator|==
name|p
argument_list|)
expr_stmt|;
name|unsigned
name|nbytes
init|=
name|Ceiling
argument_list|(
name|size
argument_list|,
name|iPageSize
argument_list|)
decl_stmt|;
name|unsigned
name|osize
init|=
name|PagedSize
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
comment|// Special case to handle shrinking below min page threshold
name|nbytes
operator|=
name|Min
argument_list|(
operator|(
literal|1
operator|<<
name|MINPAGEPOWER
operator|)
argument_list|,
name|osize
argument_list|)
expr_stmt|;
if|if
condition|(
name|osize
operator|==
name|nbytes
condition|)
return|return
name|p
return|;
if|if
condition|(
name|nbytes
operator|<
name|osize
condition|)
block|{
comment|// shrink in place, unmap final pages and rewrite the pagemap
name|Unmap
argument_list|(
name|Offset
argument_list|(
name|p
argument_list|,
name|nbytes
argument_list|)
argument_list|,
name|osize
operator|-
name|nbytes
argument_list|)
expr_stmt|;
comment|// zap old code and then write new code (will not fail)
name|PagedZapSize
argument_list|(
name|p
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|TBool
name|check
init|=
name|PagedSetSize
argument_list|(
name|p
argument_list|,
name|nbytes
argument_list|)
decl_stmt|;
name|__ASSERT_ALWAYS
argument_list|(
name|check
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapBadCellAddress
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|// nbytes> osize
comment|// try and extend current region first
name|void
modifier|*
name|newp
init|=
name|Map
argument_list|(
name|Offset
argument_list|(
name|p
argument_list|,
name|osize
argument_list|)
argument_list|,
name|nbytes
operator|-
name|osize
argument_list|)
decl_stmt|;
if|if
condition|(
name|newp
condition|)
block|{
comment|// In place growth. Possibility that pagemap may have to grow AND then fails
if|if
condition|(
operator|!
name|PagedSetSize
argument_list|(
name|p
argument_list|,
name|nbytes
argument_list|)
condition|)
block|{
comment|// must release extra mapping
name|Unmap
argument_list|(
name|Offset
argument_list|(
name|p
argument_list|,
name|osize
argument_list|)
argument_list|,
name|nbytes
operator|-
name|osize
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// if successful, the new length code will have overwritten the old one (it is at least as long)
return|return
name|p
return|;
block|}
comment|// fallback to  allocate/copy/free
if|if
condition|(
name|mode
operator|&
name|ENeverMove
condition|)
return|return
literal|0
return|;
comment|// not allowed to move cell
name|newp
operator|=
name|PagedAllocate
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newp
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|newp
argument_list|,
name|p
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|PagedFree
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|newp
return|;
block|}
end_function
begin_function
DECL|function|PagedFree
name|void
name|RHybridHeap
operator|::
name|PagedFree
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|HEAP_ASSERT
argument_list|(
name|Ceiling
argument_list|(
name|p
argument_list|,
name|iPageSize
argument_list|)
operator|==
name|p
argument_list|)
expr_stmt|;
name|unsigned
name|size
init|=
name|PagedSize
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|PagedZapSize
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|// clear page map
name|Unmap
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|PagedInfo
name|void
name|RHybridHeap
operator|::
name|PagedInfo
parameter_list|(
name|struct
name|HeapInfo
modifier|*
name|i
parameter_list|,
name|SWalkInfo
modifier|*
name|wi
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|ix
init|=
literal|0
init|;
operator|(
name|ix
operator|=
name|iPageMap
operator|.
name|Find
argument_list|(
name|ix
argument_list|,
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|;
control|)
block|{
name|int
name|npage
init|=
name|PagedDecode
argument_list|(
name|ix
argument_list|)
decl_stmt|;
comment|// Introduce paged buffer to the walk function
name|TAny
modifier|*
name|bfr
init|=
name|Bitmap2addr
argument_list|(
name|ix
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|npage
operator|<<
name|PAGESHIFT
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|iPageSize
condition|)
block|{
comment|// If buffer is not larger than one page it must be a slab page mapped into bitmap
name|i
operator|->
name|iAllocBytes
operator|+=
name|len
expr_stmt|;
operator|++
name|i
operator|->
name|iAllocN
expr_stmt|;
name|Walk
argument_list|(
name|wi
argument_list|,
name|bfr
argument_list|,
name|len
argument_list|,
name|EGoodAllocatedCell
argument_list|,
name|EPageAllocator
argument_list|)
expr_stmt|;
block|}
name|ix
operator|+=
operator|(
name|npage
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ResetBitmap
name|void
name|RHybridHeap
operator|::
name|ResetBitmap
parameter_list|()
comment|/*---------------------------------------------------------  * Go through paged_bitmap and unmap all buffers to system  * This method is called from RHybridHeap::Reset() to unmap all page  * allocated - and slab pages which are stored in bitmap, too  *---------------------------------------------------------*/
block|{
name|unsigned
name|iNbits
init|=
name|iPageMap
operator|.
name|Size
argument_list|()
decl_stmt|;
if|if
condition|(
name|iNbits
condition|)
block|{
for|for
control|(
name|int
name|ix
init|=
literal|0
init|;
operator|(
name|ix
operator|=
name|iPageMap
operator|.
name|Find
argument_list|(
name|ix
argument_list|,
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|;
control|)
block|{
name|int
name|npage
init|=
name|PagedDecode
argument_list|(
name|ix
argument_list|)
decl_stmt|;
name|void
modifier|*
name|p
init|=
name|Bitmap2addr
argument_list|(
name|ix
argument_list|)
decl_stmt|;
name|unsigned
name|size
init|=
name|PagedSize
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|PagedZapSize
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|// clear page map
name|Unmap
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ix
operator|+=
operator|(
name|npage
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TInt
operator|)
name|iNbits
operator|>
name|MAXSMALLPAGEBITS
condition|)
block|{
comment|// unmap page reserved for enlarged bitmap
name|Unmap
argument_list|(
name|iPageMap
operator|.
name|Addr
argument_list|()
argument_list|,
operator|(
name|iNbits
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|CheckBitmap
name|TBool
name|RHybridHeap
operator|::
name|CheckBitmap
parameter_list|(
name|void
modifier|*
name|aBfr
parameter_list|,
name|TInt
name|aSize
parameter_list|,
name|TUint32
modifier|&
name|aDummy
parameter_list|,
name|TInt
modifier|&
name|aNPages
parameter_list|)
comment|/*---------------------------------------------------------  * If aBfr = NULL  *   Go through paged_bitmap and unmap all buffers to system  *   and assure that by reading the first word of each page of aBfr  *   that aBfr is still accessible  * else    *   Assure that specified buffer is mapped with correct length in  *   page map  *---------------------------------------------------------*/
block|{
name|TBool
name|ret
decl_stmt|;
if|if
condition|(
name|aBfr
condition|)
block|{
name|__ASSERT_ALWAYS
argument_list|(
operator|(
name|Ceiling
argument_list|(
name|aBfr
argument_list|,
name|iPageSize
argument_list|)
operator|==
name|aBfr
operator|)
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapBadCellAddress
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|aSize
operator|==
operator|(
name|TInt
operator|)
name|PagedSize
argument_list|(
name|aBfr
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|ETrue
expr_stmt|;
name|unsigned
name|iNbits
init|=
name|iPageMap
operator|.
name|Size
argument_list|()
decl_stmt|;
if|if
condition|(
name|iNbits
condition|)
block|{
name|TInt
name|npage
decl_stmt|;
name|aNPages
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|ix
init|=
literal|0
init|;
operator|(
name|ix
operator|=
name|iPageMap
operator|.
name|Find
argument_list|(
name|ix
argument_list|,
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|;
control|)
block|{
name|npage
operator|=
name|PagedDecode
argument_list|(
name|ix
argument_list|)
expr_stmt|;
name|aNPages
operator|+=
name|npage
expr_stmt|;
name|void
modifier|*
name|p
init|=
name|Bitmap2addr
argument_list|(
name|ix
argument_list|)
decl_stmt|;
name|__ASSERT_ALWAYS
argument_list|(
operator|(
name|Ceiling
argument_list|(
name|p
argument_list|,
name|iPageSize
argument_list|)
operator|==
name|p
operator|)
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapBadCellAddress
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned
name|s
init|=
name|PagedSize
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|__ASSERT_ALWAYS
argument_list|(
operator|(
name|Ceiling
argument_list|(
name|s
argument_list|,
name|iPageSize
argument_list|)
operator|==
name|s
operator|)
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapBadCellAddress
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
condition|)
block|{
name|aDummy
operator|+=
operator|*
operator|(
name|TUint32
operator|*
operator|)
operator|(
operator|(
name|TUint8
operator|*
operator|)
name|p
operator|+
operator|(
name|s
operator|-
name|iPageSize
operator|)
operator|)
expr_stmt|;
name|s
operator|-=
name|iPageSize
expr_stmt|;
block|}
name|ix
operator|+=
operator|(
name|npage
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TInt
operator|)
name|iNbits
operator|>
name|MAXSMALLPAGEBITS
condition|)
block|{
comment|// add enlarged bitmap page(s) to total page count
name|npage
operator|=
operator|(
name|iNbits
operator|>>
literal|3
operator|)
expr_stmt|;
name|__ASSERT_ALWAYS
argument_list|(
operator|(
name|Ceiling
argument_list|(
name|npage
argument_list|,
name|iPageSize
argument_list|)
operator|==
name|npage
operator|)
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapBadCellAddress
argument_list|)
argument_list|)
expr_stmt|;
name|aNPages
operator|+=
operator|(
name|npage
operator|/
name|iPageSize
operator|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|// The paged allocations are tracked in a bitmap which has 2 bits per page
end_comment
begin_comment
comment|// this allows us to store allocations as small as 4KB
end_comment
begin_comment
comment|// The presence and size of an allocation is encoded as follows:
end_comment
begin_comment
comment|// let N = number of pages in the allocation, then
end_comment
begin_comment
comment|// 10            : N = 1			// 4KB
end_comment
begin_comment
comment|// 110n			 : N = 2 + n		// 8-12KB
end_comment
begin_comment
comment|// 1110nnnn      : N = nnnn			// 16-60KB
end_comment
begin_comment
comment|// 1111n[18]	 : N = n[18]		// 64KB-1GB
end_comment
begin_struct
DECL|struct|etab
DECL|member|offset
DECL|member|len
DECL|member|codelen
DECL|member|code
DECL|variable|encode_table
specifier|const
struct|struct
name|etab
block|{
name|unsigned
name|char
name|offset
decl_stmt|,
name|len
decl_stmt|,
name|codelen
decl_stmt|,
name|code
decl_stmt|;
block|}
name|encode_table
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|0x1
block|}
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|3
block|,
literal|0x3
block|}
block|,
block|{
literal|0
block|,
literal|8
block|,
literal|4
block|,
literal|0x7
block|}
block|,
block|{
literal|0
block|,
literal|22
block|,
literal|4
block|,
literal|0xf
block|}
block|}
struct|;
end_struct
begin_comment
comment|// Return code length for specified allocation Size(assumed to be aligned to pages)
end_comment
begin_function
DECL|function|paged_codelen
specifier|inline
name|unsigned
name|paged_codelen
parameter_list|(
name|unsigned
name|size
parameter_list|,
name|unsigned
name|pagesz
parameter_list|)
block|{
name|HEAP_ASSERT
argument_list|(
name|size
operator|==
name|Ceiling
argument_list|(
name|size
argument_list|,
name|pagesz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|pagesz
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|size
operator|<
literal|4
operator|*
name|pagesz
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|size
operator|<
literal|16
operator|*
name|pagesz
condition|)
return|return
literal|8
return|;
else|else
return|return
literal|22
return|;
block|}
end_function
begin_function
DECL|function|paged_coding
specifier|inline
specifier|const
name|etab
modifier|&
name|paged_coding
parameter_list|(
name|unsigned
name|npage
parameter_list|)
block|{
if|if
condition|(
name|npage
operator|<
literal|4
condition|)
return|return
name|encode_table
index|[
name|npage
operator|>>
literal|1
index|]
return|;
elseif|else
if|if
condition|(
name|npage
operator|<
literal|16
condition|)
return|return
name|encode_table
index|[
literal|2
index|]
return|;
else|else
return|return
name|encode_table
index|[
literal|3
index|]
return|;
block|}
end_function
begin_function
DECL|function|PagedEncode
name|bool
name|RHybridHeap
operator|::
name|PagedEncode
parameter_list|(
name|unsigned
name|pos
parameter_list|,
name|unsigned
name|npage
parameter_list|)
block|{
specifier|const
name|etab
modifier|&
name|e
init|=
name|paged_coding
argument_list|(
name|npage
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|+
name|e
operator|.
name|len
operator|>
name|iPageMap
operator|.
name|Size
argument_list|()
condition|)
block|{
comment|// need to grow the page bitmap to fit the cell length into the map
comment|// if we outgrow original bitmap buffer in RHybridHeap metadata, then just get enough pages to cover the full space:
comment|// * initial 68 byte bitmap mapped (68*8*4kB):2 = 1,1MB
comment|// * 4KB can Map(4096*8*4kB):2 = 64MB
name|unsigned
name|maxsize
init|=
name|Ceiling
argument_list|(
name|iMaxLength
argument_list|,
name|iPageSize
argument_list|)
decl_stmt|;
name|unsigned
name|mapbits
init|=
name|maxsize
operator|>>
operator|(
name|PAGESHIFT
operator|-
literal|1
operator|)
decl_stmt|;
name|maxsize
operator|=
name|Ceiling
argument_list|(
name|mapbits
operator|>>
literal|3
argument_list|,
name|iPageSize
argument_list|)
expr_stmt|;
name|void
modifier|*
name|newb
init|=
name|Map
argument_list|(
literal|0
argument_list|,
name|maxsize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newb
condition|)
return|return
literal|false
return|;
name|unsigned
name|char
modifier|*
name|oldb
init|=
name|iPageMap
operator|.
name|Addr
argument_list|()
decl_stmt|;
name|iPageMap
operator|.
name|Init
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|newb
argument_list|,
operator|(
name|maxsize
operator|<<
literal|3
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newb
argument_list|,
name|oldb
argument_list|,
name|Ceiling
argument_list|(
name|MAXSMALLPAGEBITS
argument_list|,
literal|8
argument_list|)
operator|>>
literal|3
argument_list|)
expr_stmt|;
block|}
comment|// encode the allocation block size into the bitmap, starting at the bit for the start page
name|unsigned
name|bits
init|=
name|e
operator|.
name|code
decl_stmt|;
name|bits
operator||=
operator|(
name|npage
operator|-
name|e
operator|.
name|offset
operator|)
operator|<<
name|e
operator|.
name|codelen
expr_stmt|;
name|iPageMap
operator|.
name|Set
argument_list|(
name|pos
argument_list|,
name|e
operator|.
name|len
argument_list|,
name|bits
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|PagedDecode
name|unsigned
name|RHybridHeap
operator|::
name|PagedDecode
parameter_list|(
name|unsigned
name|pos
parameter_list|)
specifier|const
block|{
name|__ASSERT_ALWAYS
argument_list|(
name|pos
operator|+
literal|2
operator|<=
name|iPageMap
operator|.
name|Size
argument_list|()
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapBadCellAddress
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned
name|bits
init|=
name|iPageMap
operator|.
name|Bits
argument_list|(
name|pos
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|__ASSERT_ALWAYS
argument_list|(
name|bits
operator|&
literal|1
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapBadCellAddress
argument_list|)
argument_list|)
expr_stmt|;
name|bits
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|__ASSERT_ALWAYS
argument_list|(
name|pos
operator|+
literal|4
operator|<=
name|iPageMap
operator|.
name|Size
argument_list|()
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapBadCellAddress
argument_list|)
argument_list|)
expr_stmt|;
name|bits
operator|=
name|iPageMap
operator|.
name|Bits
argument_list|(
name|pos
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bits
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|2
operator|+
operator|(
name|bits
operator|>>
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|bits
operator|>>
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|__ASSERT_ALWAYS
argument_list|(
name|pos
operator|+
literal|8
operator|<=
name|iPageMap
operator|.
name|Size
argument_list|()
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapBadCellAddress
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|iPageMap
operator|.
name|Bits
argument_list|(
name|pos
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
return|;
block|}
else|else
block|{
name|__ASSERT_ALWAYS
argument_list|(
name|pos
operator|+
literal|22
operator|<=
name|iPageMap
operator|.
name|Size
argument_list|()
argument_list|,
name|HEAP_PANIC
argument_list|(
name|ETHeapBadCellAddress
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|iPageMap
operator|.
name|Bits
argument_list|(
name|pos
operator|+
literal|4
argument_list|,
literal|18
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|PagedZapSize
specifier|inline
name|void
name|RHybridHeap
operator|::
name|PagedZapSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|iPageMap
operator|.
name|Setn
argument_list|(
name|PtrDiff
argument_list|(
name|p
argument_list|,
name|iMemBase
argument_list|)
operator|>>
operator|(
name|PAGESHIFT
operator|-
literal|1
operator|)
argument_list|,
name|paged_codelen
argument_list|(
name|size
argument_list|,
name|iPageSize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|PagedSize
specifier|inline
name|unsigned
name|RHybridHeap
operator|::
name|PagedSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
specifier|const
block|{
return|return
name|PagedDecode
argument_list|(
name|PtrDiff
argument_list|(
name|p
argument_list|,
name|iMemBase
argument_list|)
operator|>>
operator|(
name|PAGESHIFT
operator|-
literal|1
operator|)
argument_list|)
operator|<<
name|PAGESHIFT
return|;
block|}
end_function
begin_function
DECL|function|PagedSetSize
specifier|inline
name|bool
name|RHybridHeap
operator|::
name|PagedSetSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
return|return
name|PagedEncode
argument_list|(
name|PtrDiff
argument_list|(
name|p
argument_list|,
name|iMemBase
argument_list|)
operator|>>
operator|(
name|PAGESHIFT
operator|-
literal|1
operator|)
argument_list|,
name|size
operator|>>
name|PAGESHIFT
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|Bitmap2addr
specifier|inline
name|void
modifier|*
name|RHybridHeap
operator|::
name|Bitmap2addr
parameter_list|(
name|unsigned
name|pos
parameter_list|)
specifier|const
block|{
return|return
name|iMemBase
operator|+
operator|(
literal|1
operator|<<
operator|(
name|PAGESHIFT
operator|-
literal|1
operator|)
operator|)
operator|*
name|pos
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_SYMBIAN4_ALLOCATOR_UNWANTED_CODE
end_ifndef
begin_comment
comment|//////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|//////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|/** Constructor where minimum and maximum length of the heap can be defined. It defaults the chunk heap to be created to have use a new local chunk,  to have a grow by value of KMinHeapGrowBy, to be unaligned, not to be  single threaded and not to have any mode flags set.  @param aMinLength    The minimum length of the heap to be created. @param aMaxLength    The maximum length to which the heap to be created can grow.                      If the supplied value is less than a page size, then it                      is discarded and the page size is used instead. */
end_comment
begin_macro
DECL|function|TChunkHeapCreateInfo
name|EXPORT_C
end_macro
begin_constructor
DECL|function|TChunkHeapCreateInfo
name|TChunkHeapCreateInfo
operator|::
name|TChunkHeapCreateInfo
parameter_list|(
name|TInt
name|aMinLength
parameter_list|,
name|TInt
name|aMaxLength
parameter_list|)
member_init_list|:
name|iVersionNumber
argument_list|(
name|EVersion0
argument_list|)
member_init_list|,
name|iMinLength
argument_list|(
name|aMinLength
argument_list|)
member_init_list|,
name|iMaxLength
argument_list|(
name|aMaxLength
argument_list|)
member_init_list|,
name|iAlign
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|iGrowBy
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|iSingleThread
argument_list|(
name|EFalse
argument_list|)
member_init_list|,
name|iOffset
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|iPaging
argument_list|(
name|EUnspecified
argument_list|)
member_init_list|,
name|iMode
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|iName
argument_list|(
name|NULL
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/** Sets the chunk heap to create a new chunk with the specified name.  This overriddes any previous call to TChunkHeapCreateInfo::SetNewChunkHeap() or TChunkHeapCreateInfo::SetExistingChunkHeap() for this TChunkHeapCreateInfo object.  @param aName	The name to be given to the chunk heap to be created If NULL, the function constructs a local chunk to host the heap. If not NULL, a pointer to a descriptor containing the name to be  assigned to the global chunk hosting the heap. */
end_comment
begin_function
DECL|function|SetCreateChunk
name|EXPORT_C
name|void
name|TChunkHeapCreateInfo
operator|::
name|SetCreateChunk
parameter_list|(
specifier|const
name|TDesC
modifier|*
name|aName
parameter_list|)
block|{
name|iName
operator|=
operator|(
name|TDesC
operator|*
operator|)
name|aName
expr_stmt|;
name|iChunk
operator|.
name|SetHandle
argument_list|(
name|KNullHandle
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/** Sets the chunk heap to be created to use the chunk specified.  This overriddes any previous call to TChunkHeapCreateInfo::SetNewChunkHeap() or TChunkHeapCreateInfo::SetExistingChunkHeap() for this TChunkHeapCreateInfo object.  @param aChunk	A handle to the chunk to use for the heap. */
end_comment
begin_function
DECL|function|SetUseChunk
name|EXPORT_C
name|void
name|TChunkHeapCreateInfo
operator|::
name|SetUseChunk
parameter_list|(
specifier|const
name|RChunk
name|aChunk
parameter_list|)
block|{
name|iName
operator|=
name|NULL
expr_stmt|;
name|iChunk
operator|=
name|aChunk
expr_stmt|;
block|}
end_function
begin_function
DECL|function|FixedHeap
name|EXPORT_C
name|RHeap
modifier|*
name|UserHeap
operator|::
name|FixedHeap
parameter_list|(
name|TAny
modifier|*
name|aBase
parameter_list|,
name|TInt
name|aMaxLength
parameter_list|,
name|TInt
name|aAlign
parameter_list|,
name|TBool
name|aSingleThread
parameter_list|)
comment|/** Creates a fixed length heap at a specified location.  On successful return from this function, the heap is ready to use.  This assumes that the memory pointed to by aBase is mapped and able to be used.  You must ensure that you pass in a large enough value for aMaxLength.  Passing in a value that is too small to hold the metadata for the heap (~1 KB) will result in the size being rounded up and the heap thereby running over the end of the memory assigned to it.  But then if you were to pass in such as small value then you would not be able to do any allocations from the heap anyway.  Moral of the story: Use a sensible value for aMaxLength!  @param aBase         A pointer to the location where the heap is to be constructed. @param aMaxLength    The maximum length in bytes to which the heap can grow.  If the                      supplied value is too small to hold the heap's metadata, it                      will be increased. @param aAlign        From Symbian^4 onwards, this value is ignored but EABI 8                      byte alignment is guaranteed for all allocations 8 bytes or                      more in size.  4 byte allocations will be aligned to a 4                      byte boundary.  Best to pass in zero. @param aSingleThread EFalse if the heap is to be accessed from multiple threads.                      This will cause internal locks to be created, guaranteeing                      thread safety.  @return A pointer to the new heap, or NULL if the heap could not be created.  @panic USER 56 if aMaxLength is negative. */
block|{
name|__ASSERT_ALWAYS
argument_list|(
name|aMaxLength
operator|>=
literal|0
argument_list|,
operator|::
name|Panic
argument_list|(
name|ETHeapMaxLengthNegative
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aMaxLength
operator|<
operator|(
name|TInt
operator|)
sizeof|sizeof
argument_list|(
name|RHybridHeap
argument_list|)
condition|)
name|aMaxLength
operator|=
sizeof|sizeof
argument_list|(
name|RHybridHeap
argument_list|)
expr_stmt|;
name|RHybridHeap
modifier|*
name|h
init|=
operator|new
operator|(
name|aBase
operator|)
name|RHybridHeap
argument_list|(
name|aMaxLength
argument_list|,
name|aAlign
argument_list|,
name|aSingleThread
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|aSingleThread
condition|)
block|{
name|TInt
name|r
init|=
name|h
operator|->
name|iLock
operator|.
name|CreateLocal
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|!=
name|KErrNone
condition|)
return|return
name|NULL
return|;
comment|// No need to delete the RHybridHeap instance as the new above is only a placement new
name|h
operator|->
name|iHandles
operator|=
operator|(
name|TInt
operator|*
operator|)
operator|&
name|h
operator|->
name|iLock
expr_stmt|;
name|h
operator|->
name|iHandleCount
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
end_function
begin_comment
comment|/** Creates a chunk heap of the type specified by the parameter aCreateInfo.  @param aCreateInfo	A reference to a TChunkHeapCreateInfo object specifying the type of chunk heap to create.  @return A pointer to the new heap or NULL if the heap could not be created.  @panic USER 41 if the heap's specified minimum length is greater than the specified maximum length. @panic USER 55 if the heap's specified minimum length is negative. @panic USER 172 if the heap's specified alignment is not a power of 2 or is less than the size of a TAny*. */
end_comment
begin_function
DECL|function|ChunkHeap
name|EXPORT_C
name|RHeap
modifier|*
name|UserHeap
operator|::
name|ChunkHeap
parameter_list|(
specifier|const
name|TChunkHeapCreateInfo
modifier|&
name|aCreateInfo
parameter_list|)
block|{
comment|// aCreateInfo must have been configured to use a new chunk or an exiting chunk.
name|__ASSERT_ALWAYS
argument_list|(
operator|!
operator|(
name|aCreateInfo
operator|.
name|iMode
operator|&
operator|(
name|TUint32
operator|)
operator|~
name|EChunkHeapMask
operator|)
argument_list|,
operator|::
name|Panic
argument_list|(
name|EHeapCreateInvalidMode
argument_list|)
argument_list|)
expr_stmt|;
name|RHeap
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|aCreateInfo
operator|.
name|iChunk
operator|.
name|Handle
argument_list|()
operator|==
name|KNullHandle
condition|)
block|{
comment|// A new chunk is to be created for this heap.
name|__ASSERT_ALWAYS
argument_list|(
name|aCreateInfo
operator|.
name|iMinLength
operator|>=
literal|0
argument_list|,
operator|::
name|Panic
argument_list|(
name|ETHeapMinLengthNegative
argument_list|)
argument_list|)
expr_stmt|;
name|__ASSERT_ALWAYS
argument_list|(
name|aCreateInfo
operator|.
name|iMaxLength
operator|>=
name|aCreateInfo
operator|.
name|iMinLength
argument_list|,
operator|::
name|Panic
argument_list|(
name|ETHeapCreateMaxLessThanMin
argument_list|)
argument_list|)
expr_stmt|;
name|TInt
name|maxLength
init|=
name|aCreateInfo
operator|.
name|iMaxLength
decl_stmt|;
name|TInt
name|page_size
decl_stmt|;
name|GET_PAGE_SIZE
argument_list|(
name|page_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxLength
operator|<
name|page_size
condition|)
name|maxLength
operator|=
name|page_size
expr_stmt|;
name|TChunkCreateInfo
name|chunkInfo
decl_stmt|;
if|#
directive|if
name|USE_HYBRID_HEAP
if|if
condition|(
name|aCreateInfo
operator|.
name|iOffset
condition|)
name|chunkInfo
operator|.
name|SetNormal
argument_list|(
literal|0
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
comment|// Create DL only heap
else|else
block|{
name|maxLength
operator|=
literal|2
operator|*
name|maxLength
expr_stmt|;
name|chunkInfo
operator|.
name|SetDisconnected
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
comment|// Create hybrid heap
block|}
else|#
directive|else
name|chunkInfo
operator|.
name|SetNormal
argument_list|(
literal|0
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
comment|// Create DL only heap
endif|#
directive|endif
name|chunkInfo
operator|.
name|SetOwner
argument_list|(
operator|(
name|aCreateInfo
operator|.
name|iSingleThread
operator|)
condition|?
name|EOwnerThread
else|:
name|EOwnerProcess
argument_list|)
expr_stmt|;
if|if
condition|(
name|aCreateInfo
operator|.
name|iName
condition|)
name|chunkInfo
operator|.
name|SetGlobal
argument_list|(
operator|*
name|aCreateInfo
operator|.
name|iName
argument_list|)
expr_stmt|;
comment|// Set the paging attributes of the chunk.
if|if
condition|(
name|aCreateInfo
operator|.
name|iPaging
operator|==
name|TChunkHeapCreateInfo
operator|::
name|EPaged
condition|)
name|chunkInfo
operator|.
name|SetPaging
argument_list|(
name|TChunkCreateInfo
operator|::
name|EPaged
argument_list|)
expr_stmt|;
if|if
condition|(
name|aCreateInfo
operator|.
name|iPaging
operator|==
name|TChunkHeapCreateInfo
operator|::
name|EUnpaged
condition|)
name|chunkInfo
operator|.
name|SetPaging
argument_list|(
name|TChunkCreateInfo
operator|::
name|EUnpaged
argument_list|)
expr_stmt|;
comment|// Create the chunk.
name|RChunk
name|chunk
decl_stmt|;
if|if
condition|(
name|chunk
operator|.
name|Create
argument_list|(
name|chunkInfo
argument_list|)
operator|!=
name|KErrNone
condition|)
return|return
name|NULL
return|;
comment|// Create the heap using the new chunk.
name|TUint
name|mode
init|=
name|aCreateInfo
operator|.
name|iMode
operator||
name|EChunkHeapDuplicate
decl_stmt|;
comment|// Must duplicate the handle.
name|h
operator|=
name|OffsetChunkHeap
argument_list|(
name|chunk
argument_list|,
name|aCreateInfo
operator|.
name|iMinLength
argument_list|,
name|aCreateInfo
operator|.
name|iOffset
argument_list|,
name|aCreateInfo
operator|.
name|iGrowBy
argument_list|,
name|maxLength
argument_list|,
name|aCreateInfo
operator|.
name|iAlign
argument_list|,
name|aCreateInfo
operator|.
name|iSingleThread
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|chunk
operator|.
name|Close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|OffsetChunkHeap
argument_list|(
name|aCreateInfo
operator|.
name|iChunk
argument_list|,
name|aCreateInfo
operator|.
name|iMinLength
argument_list|,
name|aCreateInfo
operator|.
name|iOffset
argument_list|,
name|aCreateInfo
operator|.
name|iGrowBy
argument_list|,
name|aCreateInfo
operator|.
name|iMaxLength
argument_list|,
name|aCreateInfo
operator|.
name|iAlign
argument_list|,
name|aCreateInfo
operator|.
name|iSingleThread
argument_list|,
name|aCreateInfo
operator|.
name|iMode
argument_list|)
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
end_function
begin_function
DECL|function|ChunkHeap
name|EXPORT_C
name|RHeap
modifier|*
name|UserHeap
operator|::
name|ChunkHeap
parameter_list|(
specifier|const
name|TDesC
modifier|*
name|aName
parameter_list|,
name|TInt
name|aMinLength
parameter_list|,
name|TInt
name|aMaxLength
parameter_list|,
name|TInt
name|aGrowBy
parameter_list|,
name|TInt
name|aAlign
parameter_list|,
name|TBool
name|aSingleThread
parameter_list|)
comment|/** Creates a heap in a local or global chunk.  The chunk hosting the heap can be local or global.  A local chunk is one which is private to the process creating it and is not intended for access by other user processes.  A global chunk is one which is visible to all processes.  The hosting chunk is local, if the pointer aName is NULL, otherwise the hosting chunk is global and the descriptor *aName is assumed to contain the name to be assigned to it.  Ownership of the host chunk is vested in the current process.  A minimum and a maximum size for the heap can be specified. On successful return from this function, the size of the heap is at least aMinLength. If subsequent requests for allocation of memory from the heap cannot be satisfied by compressing the heap, the size of the heap is extended in increments of aGrowBy until the request can be satisfied.  Attempts to extend the heap causes the size of the host chunk to be adjusted.  Note that the size of the heap cannot be adjusted by more than aMaxLength.  @param aName         If NULL, the function constructs a local chunk to host                      the heap.  If not NULL, a pointer to a descriptor containing                      the name to be assigned to the global chunk hosting the heap. @param aMinLength    The minimum length of the heap in bytes.  This will be                      rounded up to the nearest page size by the allocator. @param aMaxLength    The maximum length in bytes to which the heap can grow.  This                      will be rounded up to the nearest page size by the allocator. @param aGrowBy       The number of bytes by which the heap will grow when more                      memory is required.  This will be rounded up to the nearest                      page size by the allocator.  If a value is not explicitly                      specified, the page size is taken by default. @param aAlign        From Symbian^4 onwards, this value is ignored but EABI 8                      byte alignment is guaranteed for all allocations 8 bytes or                      more in size.  4 byte allocations will be aligned to a 4                      byte boundary.  Best to pass in zero. @param aSingleThread EFalse if the heap is to be accessed from multiple threads.                      This will cause internal locks to be created, guaranteeing                      thread safety.  @return A pointer to the new heap or NULL if the heap could not be created.  @panic USER 41 if aMaxLength is< aMinLength. @panic USER 55 if aMinLength is negative. @panic USER 56 if aMaxLength is negative. */
block|{
name|TInt
name|page_size
decl_stmt|;
name|GET_PAGE_SIZE
argument_list|(
name|page_size
argument_list|)
expr_stmt|;
name|TInt
name|minLength
init|=
name|_ALIGN_UP
argument_list|(
name|aMinLength
argument_list|,
name|page_size
argument_list|)
decl_stmt|;
name|TInt
name|maxLength
init|=
name|Max
argument_list|(
name|aMaxLength
argument_list|,
name|minLength
argument_list|)
decl_stmt|;
name|TChunkHeapCreateInfo
name|createInfo
argument_list|(
name|minLength
argument_list|,
name|maxLength
argument_list|)
decl_stmt|;
name|createInfo
operator|.
name|SetCreateChunk
argument_list|(
name|aName
argument_list|)
expr_stmt|;
name|createInfo
operator|.
name|SetGrowBy
argument_list|(
name|aGrowBy
argument_list|)
expr_stmt|;
name|createInfo
operator|.
name|SetAlignment
argument_list|(
name|aAlign
argument_list|)
expr_stmt|;
name|createInfo
operator|.
name|SetSingleThread
argument_list|(
name|aSingleThread
argument_list|)
expr_stmt|;
return|return
name|ChunkHeap
argument_list|(
name|createInfo
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_SYMBIAN4_ALLOCATOR_UNWANTED_CODE
end_comment
begin_function
DECL|function|ChunkHeap
name|EXPORT_C
name|RHeap
modifier|*
name|UserHeap
operator|::
name|ChunkHeap
parameter_list|(
name|RChunk
name|aChunk
parameter_list|,
name|TInt
name|aMinLength
parameter_list|,
name|TInt
name|aGrowBy
parameter_list|,
name|TInt
name|aMaxLength
parameter_list|,
name|TInt
name|aAlign
parameter_list|,
name|TBool
name|aSingleThread
parameter_list|,
name|TUint32
name|aMode
parameter_list|)
comment|/** Creates a heap in an existing chunk.  This function is intended to be used to create a heap in a user writable code chunk as created by a call to RChunk::CreateLocalCode().  This type of heap can be used to hold code fragments from a JIT compiler.  @param aChunk        The chunk that will host the heap. @param aMinLength    The minimum length of the heap in bytes.  This will be                      rounded up to the nearest page size by the allocator. @param aGrowBy       The number of bytes by which the heap will grow when more                      memory is required.  This will be rounded up to the nearest                      page size by the allocator.  If a value is not explicitly                      specified, the page size is taken by default. @param aMaxLength    The maximum length in bytes to which the heap can grow.  This                      will be rounded up to the nearest page size by the allocator.                      If 0 is passed in, the maximum lengt of the chunk is used. @param aAlign        From Symbian^4 onwards, this value is ignored but EABI 8                      byte alignment is guaranteed for all allocations 8 bytes or                      more in size.  4 byte allocations will be aligned to a 4                      byte boundary.  Best to pass in zero. @param aSingleThread EFalse if the heap is to be accessed from multiple threads.                      This will cause internal locks to be created, guaranteeing                      thread safety. @param aMode         Flags controlling the heap creation.  See RAllocator::TFlags.  @return A pointer to the new heap or NULL if the heap could not be created.  @see UserHeap::OffsetChunkHeap() */
block|{
return|return
name|OffsetChunkHeap
argument_list|(
name|aChunk
argument_list|,
name|aMinLength
argument_list|,
literal|0
argument_list|,
name|aGrowBy
argument_list|,
name|aMaxLength
argument_list|,
name|aAlign
argument_list|,
name|aSingleThread
argument_list|,
name|aMode
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|OffsetChunkHeap
name|EXPORT_C
name|RHeap
modifier|*
name|UserHeap
operator|::
name|OffsetChunkHeap
parameter_list|(
name|RChunk
name|aChunk
parameter_list|,
name|TInt
name|aMinLength
parameter_list|,
name|TInt
name|aOffset
parameter_list|,
name|TInt
name|aGrowBy
parameter_list|,
name|TInt
name|aMaxLength
parameter_list|,
name|TInt
name|aAlign
parameter_list|,
name|TBool
name|aSingleThread
parameter_list|,
name|TUint32
name|aMode
parameter_list|)
comment|/** Creates a heap in an existing chunk, offset from the beginning of the chunk.  This function is intended to be used to create a heap using a chunk which has some of its memory already used, at the start of that that chunk.  The maximum length to which the heap can grow is the maximum size of the chunk, minus the data at the start of the chunk.  The offset at which to create the heap is passed in as the aOffset parameter. Legacy heap implementations always respected the aOffset value, however more modern heap implementations are more sophisticated and cannot necessarily respect this value.  Therefore, if possible, you should always use an aOffset of 0 unless you have a very explicit requirement for using a non zero value.  Using a non zero value will result in a less efficient heap algorithm being used in order to respect the offset.  Another issue to consider when using this function is the type of the chunk passed in.  In order for the most efficient heap algorithms to be used, the chunk passed in should always be a disconnected chunk.  Passing in a non disconnected chunk will again result in a less efficient heap algorithm being used.  Finally, another requirement for the most efficient heap algorithms to be used is for the heap to be able to expand.  Therefore, unless you have a specific reason to do so, always specify aMaxLength> aMinLength.  So, if possible, use aOffset == zero, aMaxLength> aMinLength and a disconnected chunk for best results!  @param aChunk        The chunk that will host the heap. @param aMinLength    The minimum length of the heap in bytes.  This will be                      rounded up to the nearest page size by the allocator. @param aOffset       The offset in bytes from the start of the chunk at which to                      create the heap.  If used (and it shouldn't really be!)                      then it will be rounded up to a multiple of 8, to respect                      EABI 8 byte alignment requirements. @param aGrowBy       The number of bytes by which the heap will grow when more                      memory is required.  This will be rounded up to the nearest                      page size by the allocator.  If a value is not explicitly                      specified, the page size is taken by default. @param aMaxLength    The maximum length in bytes to which the heap can grow.  This                      will be rounded up to the nearest page size by the allocator.                      If 0 is passed in, the maximum length of the chunk is used. @param aAlign        From Symbian^4 onwards, this value is ignored but EABI 8                      byte alignment is guaranteed for all allocations 8 bytes or                      more in size.  4 byte allocations will be aligned to a 4                      byte boundary.  Best to pass in zero. @param aSingleThread EFalse if the heap is to be accessed from multiple threads.                      This will cause internal locks to be created, guaranteeing                      thread safety. @param aMode         Flags controlling the heap creation.  See RAllocator::TFlags.  @return A pointer to the new heap or NULL if the heap could not be created.  @panic USER 41 if aMaxLength is< aMinLength. @panic USER 55 if aMinLength is negative. @panic USER 56 if aMaxLength is negative. @panic USER 168 if aOffset is negative. */
block|{
name|TBool
name|dlOnly
init|=
name|EFalse
decl_stmt|;
name|TInt
name|pageSize
decl_stmt|;
name|GET_PAGE_SIZE
argument_list|(
name|pageSize
argument_list|)
expr_stmt|;
name|TInt
name|align
init|=
name|RHybridHeap
operator|::
name|ECellAlignment
decl_stmt|;
comment|// Always use EABI 8 byte alignment
name|__ASSERT_ALWAYS
argument_list|(
name|aMinLength
operator|>=
literal|0
argument_list|,
operator|::
name|Panic
argument_list|(
name|ETHeapMinLengthNegative
argument_list|)
argument_list|)
expr_stmt|;
name|__ASSERT_ALWAYS
argument_list|(
name|aMaxLength
operator|>=
literal|0
argument_list|,
operator|::
name|Panic
argument_list|(
name|ETHeapMaxLengthNegative
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aMaxLength
operator|>
literal|0
condition|)
name|__ASSERT_ALWAYS
argument_list|(
name|aMaxLength
operator|>=
name|aMinLength
argument_list|,
operator|::
name|Panic
argument_list|(
name|ETHeapCreateMaxLessThanMin
argument_list|)
argument_list|)
expr_stmt|;
comment|// Stick to EABI alignment for the start offset, if any
name|aOffset
operator|=
name|_ALIGN_UP
argument_list|(
name|aOffset
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|// Using an aOffset> 0 means that we can't use the hybrid allocator and have to revert to Doug Lea only
if|if
condition|(
name|aOffset
operator|>
literal|0
condition|)
name|dlOnly
operator|=
name|ETrue
expr_stmt|;
comment|// Ensure that the minimum length is enough to hold the RHybridHeap object itself
name|TInt
name|minCell
init|=
name|_ALIGN_UP
argument_list|(
name|Max
argument_list|(
operator|(
name|TInt
operator|)
name|RHybridHeap
operator|::
name|EAllocCellSize
argument_list|,
operator|(
name|TInt
operator|)
name|RHybridHeap
operator|::
name|EFreeCellSize
argument_list|)
argument_list|,
name|align
argument_list|)
decl_stmt|;
name|TInt
name|hybridHeapSize
init|=
operator|(
sizeof|sizeof
argument_list|(
name|RHybridHeap
argument_list|)
operator|+
name|minCell
operator|)
decl_stmt|;
if|if
condition|(
name|aMinLength
operator|<
name|hybridHeapSize
condition|)
name|aMinLength
operator|=
name|hybridHeapSize
expr_stmt|;
comment|// Round the minimum length up to a multiple of the page size, taking into account that the
comment|// offset takes up a part of the chunk's memory
name|aMinLength
operator|=
name|_ALIGN_UP
argument_list|(
operator|(
name|aMinLength
operator|+
name|aOffset
operator|)
argument_list|,
name|pageSize
argument_list|)
expr_stmt|;
comment|// If aMaxLength is 0 then use the entire chunk
name|TInt
name|chunkSize
init|=
name|aChunk
operator|.
name|MaxSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|aMaxLength
operator|==
literal|0
condition|)
block|{
name|aMaxLength
operator|=
name|chunkSize
expr_stmt|;
block|}
comment|// Otherwise round the maximum length up to a multiple of the page size, taking into account that
comment|// the offset takes up a part of the chunk's memory.  We also clip the maximum length to the chunk
comment|// size, so the user may get a little less than requested if the chunk size is not large enough
else|else
block|{
name|aMaxLength
operator|=
name|_ALIGN_UP
argument_list|(
operator|(
name|aMaxLength
operator|+
name|aOffset
operator|)
argument_list|,
name|pageSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|aMaxLength
operator|>
name|chunkSize
condition|)
name|aMaxLength
operator|=
name|chunkSize
expr_stmt|;
block|}
comment|// If the rounded up values don't make sense then a crazy aMinLength or aOffset must have been passed
comment|// in, so fail the heap creation
if|if
condition|(
name|aMinLength
operator|>
name|aMaxLength
condition|)
return|return
name|NULL
return|;
comment|// Adding the offset into the minimum and maximum length was only necessary for ensuring a good fit of
comment|// the heap into the chunk.  Re-adjust them now back to non offset relative sizes
name|aMinLength
operator|-=
name|aOffset
expr_stmt|;
name|aMaxLength
operator|-=
name|aOffset
expr_stmt|;
comment|// If we are still creating the hybrid allocator (call parameter
comment|// aOffset is 0 and aMaxLength> aMinLength), we must reduce heap
comment|// aMaxLength size to the value aMaxLength/2 and set the aOffset to point in the middle of chunk.
name|TInt
name|offset
init|=
name|aOffset
decl_stmt|;
name|TInt
name|maxLength
init|=
name|aMaxLength
decl_stmt|;
if|if
condition|(
operator|!
name|dlOnly
operator|&&
operator|(
name|aMaxLength
operator|>
name|aMinLength
operator|)
condition|)
name|maxLength
operator|=
name|offset
operator|=
name|_ALIGN_UP
argument_list|(
name|aMaxLength
operator|>>
literal|1
argument_list|,
name|pageSize
argument_list|)
expr_stmt|;
comment|// Try to use commit to map aMinLength physical memory for the heap, taking into account the offset.  If
comment|// the operation fails, suppose that the chunk is not a disconnected heap and try to map physical memory
comment|// with adjust.  In this case, we also can't use the hybrid allocator and have to revert to Doug Lea only
name|TBool
name|useAdjust
init|=
name|EFalse
decl_stmt|;
name|TInt
name|r
init|=
name|aChunk
operator|.
name|Commit
argument_list|(
name|offset
argument_list|,
name|aMinLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|KErrGeneral
condition|)
block|{
name|dlOnly
operator|=
name|useAdjust
operator|=
name|ETrue
expr_stmt|;
name|r
operator|=
name|aChunk
operator|.
name|Adjust
argument_list|(
name|aMinLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|KErrNone
condition|)
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|KErrNone
condition|)
block|{
comment|// We have a disconnected chunk reset aOffset and aMaxlength
name|aOffset
operator|=
name|offset
expr_stmt|;
name|aMaxLength
operator|=
name|maxLength
expr_stmt|;
block|}
else|else
return|return
name|NULL
return|;
comment|// Parameters have been mostly verified and we know whether to use the hybrid allocator or Doug Lea only.  The
comment|// constructor for the hybrid heap will automatically drop back to Doug Lea if it determines that aMinLength
comment|// == aMaxLength, so no need to worry about that requirement here.  The user specified alignment is not used but
comment|// is passed in so that it can be sanity checked in case the user is doing something totally crazy with it
name|RHybridHeap
modifier|*
name|h
init|=
operator|new
operator|(
name|aChunk
operator|.
name|Base
argument_list|()
operator|+
name|aOffset
operator|)
name|RHybridHeap
argument_list|(
name|aChunk
operator|.
name|Handle
argument_list|()
argument_list|,
name|aOffset
argument_list|,
name|aMinLength
argument_list|,
name|aMaxLength
argument_list|,
name|aGrowBy
argument_list|,
name|aAlign
argument_list|,
name|aSingleThread
argument_list|,
name|dlOnly
argument_list|,
name|useAdjust
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|ConstructLock
argument_list|(
name|aMode
argument_list|)
operator|!=
name|KErrNone
condition|)
return|return
name|NULL
return|;
comment|// Return the heap address
return|return
name|h
return|;
block|}
end_function
begin_define
DECL|macro|UserTestDebugMaskBit
define|#
directive|define
name|UserTestDebugMaskBit
parameter_list|(
name|bit
parameter_list|)
value|(TBool)(UserSvr::DebugMask(bit>>5)& (1<<(bit&31)))
end_define
begin_expr_stmt
name|_LIT
argument_list|(
name|KLitDollarHeap
argument_list|,
literal|"$HEAP"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_function
DECL|function|CreateThreadHeap
name|EXPORT_C
name|TInt
name|UserHeap
operator|::
name|CreateThreadHeap
parameter_list|(
name|SStdEpocThreadCreateInfo
modifier|&
name|aInfo
parameter_list|,
name|RHeap
modifier|*
modifier|&
name|aHeap
parameter_list|,
name|TInt
name|aAlign
parameter_list|,
name|TBool
name|aSingleThread
parameter_list|)
comment|/** @internalComponent */
comment|//
comment|// Create a user-side heap
comment|//
block|{
name|TInt
name|page_size
decl_stmt|;
name|GET_PAGE_SIZE
argument_list|(
name|page_size
argument_list|)
expr_stmt|;
name|TInt
name|minLength
init|=
name|_ALIGN_UP
argument_list|(
name|aInfo
operator|.
name|iHeapInitialSize
argument_list|,
name|page_size
argument_list|)
decl_stmt|;
name|TInt
name|maxLength
init|=
name|Max
argument_list|(
name|aInfo
operator|.
name|iHeapMaxSize
argument_list|,
name|minLength
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
if|if
condition|(
name|UserTestDebugMaskBit
argument_list|(
literal|96
argument_list|)
condition|)
comment|// 96 == KUSERHEAPTRACE in nk_trace.h
name|aInfo
operator|.
name|iFlags
operator||=
name|ETraceHeapAllocs
expr_stmt|;
endif|#
directive|endif
comment|// ENABLE_BTRACE
comment|// Create the thread's heap chunk.
name|RChunk
name|c
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_NAMED_LOCAL_CHUNKS
name|TChunkCreateInfo
name|createInfo
decl_stmt|;
name|createInfo
operator|.
name|SetThreadHeap
argument_list|(
literal|0
argument_list|,
name|maxLength
argument_list|,
name|KLitDollarHeap
argument_list|()
argument_list|)
expr_stmt|;
comment|// Initialise with no memory committed.
if|#
directive|if
name|USE_HYBRID_HEAP
comment|//
comment|// Create disconnected chunk for hybrid heap with double max length value
comment|//
name|maxLength
operator|=
literal|2
operator|*
name|maxLength
expr_stmt|;
name|createInfo
operator|.
name|SetDisconnected
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|maxLength
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYMBIAN_WRITABLE_DATA_PAGING
comment|// Set the paging policy of the heap chunk based on the thread's paging policy.
name|TUint
name|pagingflags
init|=
name|aInfo
operator|.
name|iFlags
operator|&
name|EThreadCreateFlagPagingMask
decl_stmt|;
switch|switch
condition|(
name|pagingflags
condition|)
block|{
case|case
name|EThreadCreateFlagPaged
case|:
name|createInfo
operator|.
name|SetPaging
argument_list|(
name|TChunkCreateInfo
operator|::
name|EPaged
argument_list|)
expr_stmt|;
break|break;
case|case
name|EThreadCreateFlagUnpaged
case|:
name|createInfo
operator|.
name|SetPaging
argument_list|(
name|TChunkCreateInfo
operator|::
name|EUnpaged
argument_list|)
expr_stmt|;
break|break;
case|case
name|EThreadCreateFlagPagingUnspec
case|:
comment|// Leave the chunk paging policy unspecified so the process's
comment|// paging policy is used.
break|break;
block|}
endif|#
directive|endif
comment|// SYMBIAN_WRITABLE_DATA_PAGING
name|TInt
name|r
init|=
name|c
operator|.
name|Create
argument_list|(
name|createInfo
argument_list|)
decl_stmt|;
else|#
directive|else
name|TInt
name|r
init|=
name|c
operator|.
name|CreateDisconnectedLocal
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|maxLength
operator|*
literal|2
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|!=
name|KErrNone
condition|)
return|return
name|r
return|;
name|aHeap
operator|=
name|ChunkHeap
argument_list|(
name|c
argument_list|,
name|minLength
argument_list|,
name|page_size
argument_list|,
name|maxLength
argument_list|,
name|aAlign
argument_list|,
name|aSingleThread
argument_list|,
name|EChunkHeapSwitchTo
operator||
name|EChunkHeapDuplicate
argument_list|)
expr_stmt|;
name|c
operator|.
name|Close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|aHeap
condition|)
return|return
name|KErrNoMemory
return|;
ifdef|#
directive|ifdef
name|ENABLE_BTRACE
if|if
condition|(
name|aInfo
operator|.
name|iFlags
operator|&
name|ETraceHeapAllocs
condition|)
block|{
name|aHeap
operator|->
name|iFlags
operator||=
name|RHeap
operator|::
name|ETraceAllocs
expr_stmt|;
name|BTraceContext8
argument_list|(
name|BTrace
operator|::
name|EHeap
argument_list|,
name|BTrace
operator|::
name|EHeapCreate
argument_list|,
operator|(
name|TUint32
operator|)
name|aHeap
argument_list|,
name|RHybridHeap
operator|::
name|EAllocCellSize
argument_list|)
expr_stmt|;
name|TInt
name|chunkId
init|=
operator|(
operator|(
name|RHandleBase
operator|&
operator|)
operator|(
operator|(
name|RHybridHeap
operator|*
operator|)
name|aHeap
operator|)
operator|->
name|iChunkHandle
operator|)
operator|.
name|BTraceId
argument_list|()
decl_stmt|;
name|BTraceContext8
argument_list|(
name|BTrace
operator|::
name|EHeap
argument_list|,
name|BTrace
operator|::
name|EHeapChunkCreate
argument_list|,
operator|(
name|TUint32
operator|)
name|aHeap
argument_list|,
name|chunkId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aInfo
operator|.
name|iFlags
operator|&
name|EMonitorHeapMemory
condition|)
name|aHeap
operator|->
name|iFlags
operator||=
name|RHeap
operator|::
name|EMonitorMemory
expr_stmt|;
endif|#
directive|endif
comment|// ENABLE_BTRACE
return|return
name|KErrNone
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// __KERNEL_MODE__
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* QT_USE_NEW_SYMBIAN_ALLOCATOR */
end_comment
end_unit
