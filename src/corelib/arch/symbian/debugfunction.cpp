begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qt_hybridheap_symbian_p.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QT_USE_NEW_SYMBIAN_ALLOCATOR
end_ifdef
begin_define
DECL|macro|GM
define|#
directive|define
name|GM
value|(&iGlobalMallocState)
end_define
begin_define
DECL|macro|__HEAP_CORRUPTED_TRACE
define|#
directive|define
name|__HEAP_CORRUPTED_TRACE
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|,
name|l
parameter_list|)
value|BTraceContext12(BTrace::EHeap, BTrace::EHeapCorruption, (TUint32)t, (TUint32)p, (TUint32)l);
end_define
begin_define
DECL|macro|__HEAP_CORRUPTED_TEST
define|#
directive|define
name|__HEAP_CORRUPTED_TEST
parameter_list|(
name|c
parameter_list|,
name|x
parameter_list|,
name|p
parameter_list|,
name|l
parameter_list|)
value|if (!c) { if (iFlags& (EMonitorMemory+ETraceAllocs) )  __HEAP_CORRUPTED_TRACE(this,p,l)  HEAP_PANIC(x); }
end_define
begin_define
DECL|macro|__HEAP_CORRUPTED_TEST_STATIC
define|#
directive|define
name|__HEAP_CORRUPTED_TEST_STATIC
parameter_list|(
name|c
parameter_list|,
name|t
parameter_list|,
name|x
parameter_list|,
name|p
parameter_list|,
name|l
parameter_list|)
value|if (!c) { if (t&& (t->iFlags& (EMonitorMemory+ETraceAllocs) )) __HEAP_CORRUPTED_TRACE(t,p,l) HEAP_PANIC(x); }
end_define
begin_function
DECL|function|DebugFunction
name|TInt
name|RHybridHeap
operator|::
name|DebugFunction
parameter_list|(
name|TInt
name|aFunc
parameter_list|,
name|TAny
modifier|*
name|a1
parameter_list|,
name|TAny
modifier|*
name|a2
parameter_list|)
block|{
name|TInt
name|r
init|=
name|KErrNone
decl_stmt|;
switch|switch
condition|(
name|aFunc
condition|)
block|{
case|case
name|RAllocator
operator|::
name|ECount
case|:
name|struct
name|HeapInfo
name|info
decl_stmt|;
name|Lock
argument_list|()
expr_stmt|;
name|GetInfo
argument_list|(
operator|&
name|info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|a1
operator|=
name|info
operator|.
name|iFreeN
expr_stmt|;
name|r
operator|=
name|info
operator|.
name|iAllocN
expr_stmt|;
name|Unlock
argument_list|()
expr_stmt|;
break|break;
case|case
name|RAllocator
operator|::
name|EMarkStart
case|:
name|__DEBUG_ONLY
argument_list|(
name|DoMarkStart
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAllocator
operator|::
name|EMarkEnd
case|:
name|__DEBUG_ONLY
argument_list|(
name|r
operator|=
name|DoMarkEnd
argument_list|(
operator|(
name|TInt
operator|)
name|a1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAllocator
operator|::
name|ECheck
case|:
name|r
operator|=
name|DoCheckHeap
argument_list|(
operator|(
name|SCheckInfo
operator|*
operator|)
name|a1
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAllocator
operator|::
name|ESetFail
case|:
name|__DEBUG_ONLY
argument_list|(
name|DoSetAllocFail
argument_list|(
operator|(
name|TAllocFail
operator|)
operator|(
name|TInt
operator|)
name|a1
argument_list|,
operator|(
name|TInt
operator|)
name|a2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RHybridHeap
operator|::
name|EGetFail
case|:
name|__DEBUG_ONLY
argument_list|(
name|r
operator|=
name|iFailType
argument_list|)
expr_stmt|;
break|break;
case|case
name|RHybridHeap
operator|::
name|ESetBurstFail
case|:
if|#
directive|if
name|_DEBUG
block|{
name|SRAllocatorBurstFail
modifier|*
name|fail
init|=
operator|(
name|SRAllocatorBurstFail
operator|*
operator|)
name|a2
decl_stmt|;
name|DoSetAllocFail
argument_list|(
operator|(
name|TAllocFail
operator|)
operator|(
name|TInt
operator|)
name|a1
argument_list|,
name|fail
operator|->
name|iRate
argument_list|,
name|fail
operator|->
name|iBurst
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|RHybridHeap
operator|::
name|ECheckFailure
case|:
comment|// iRand will be incremented for each EFailNext, EBurstFailNext,
comment|// EDeterministic and EBurstDeterministic failure.
name|r
operator|=
name|iRand
expr_stmt|;
break|break;
case|case
name|RAllocator
operator|::
name|ECopyDebugInfo
case|:
block|{
name|TInt
name|nestingLevel
init|=
operator|(
operator|(
name|SDebugCell
operator|*
operator|)
name|a1
operator|)
index|[
operator|-
literal|1
index|]
operator|.
name|nestingLevel
decl_stmt|;
operator|(
operator|(
name|SDebugCell
operator|*
operator|)
name|a2
operator|)
index|[
operator|-
literal|1
index|]
operator|.
name|nestingLevel
operator|=
name|nestingLevel
expr_stmt|;
break|break;
block|}
case|case
name|RHybridHeap
operator|::
name|EGetSize
case|:
block|{
name|r
operator|=
name|iChunkSize
operator|-
sizeof|sizeof
argument_list|(
name|RHybridHeap
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RHybridHeap
operator|::
name|EGetMaxLength
case|:
block|{
name|r
operator|=
name|iMaxLength
expr_stmt|;
break|break;
block|}
case|case
name|RHybridHeap
operator|::
name|EGetBase
case|:
block|{
operator|*
operator|(
name|TAny
operator|*
operator|*
operator|)
name|a1
operator|=
name|iBase
expr_stmt|;
break|break;
block|}
case|case
name|RHybridHeap
operator|::
name|EAlignInteger
case|:
block|{
name|r
operator|=
name|_ALIGN_UP
argument_list|(
operator|(
name|TInt
operator|)
name|a1
argument_list|,
name|iAlign
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RHybridHeap
operator|::
name|EAlignAddr
case|:
block|{
operator|*
operator|(
name|TAny
operator|*
operator|*
operator|)
name|a2
operator|=
operator|(
name|TAny
operator|*
operator|)
name|_ALIGN_UP
argument_list|(
operator|(
name|TLinAddr
operator|)
name|a1
argument_list|,
name|iAlign
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RHybridHeap
operator|::
name|EWalk
case|:
name|struct
name|HeapInfo
name|hinfo
decl_stmt|;
name|SWalkInfo
name|winfo
decl_stmt|;
name|Lock
argument_list|()
expr_stmt|;
name|winfo
operator|.
name|iFunction
operator|=
operator|(
name|TWalkFunc
operator|)
name|a1
expr_stmt|;
name|winfo
operator|.
name|iParam
operator|=
name|a2
expr_stmt|;
name|winfo
operator|.
name|iHeap
operator|=
operator|(
name|RHybridHeap
operator|*
operator|)
name|this
expr_stmt|;
name|GetInfo
argument_list|(
operator|&
name|hinfo
argument_list|,
operator|&
name|winfo
argument_list|)
expr_stmt|;
name|Unlock
argument_list|()
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
case|case
name|RHybridHeap
operator|::
name|EHybridHeap
case|:
block|{
if|if
condition|(
operator|!
name|a1
condition|)
return|return
name|KErrGeneral
return|;
name|STestCommand
modifier|*
name|cmd
init|=
operator|(
name|STestCommand
operator|*
operator|)
name|a1
decl_stmt|;
switch|switch
condition|(
name|cmd
operator|->
name|iCommand
condition|)
block|{
case|case
name|EGetConfig
case|:
name|cmd
operator|->
name|iConfig
operator|.
name|iSlabBits
operator|=
name|iSlabConfigBits
expr_stmt|;
name|cmd
operator|->
name|iConfig
operator|.
name|iDelayedSlabThreshold
operator|=
name|iPageThreshold
expr_stmt|;
name|cmd
operator|->
name|iConfig
operator|.
name|iPagePower
operator|=
name|iPageThreshold
expr_stmt|;
break|break;
case|case
name|ESetConfig
case|:
comment|//
comment|// New configuration data for slab and page allocator.
comment|// Reset heap to get data into use
comment|//
if|#
directive|if
name|USE_HYBRID_HEAP
name|iSlabConfigBits
operator|=
name|cmd
operator|->
name|iConfig
operator|.
name|iSlabBits
operator|&
literal|0x3fff
expr_stmt|;
name|iSlabInitThreshold
operator|=
name|cmd
operator|->
name|iConfig
operator|.
name|iDelayedSlabThreshold
expr_stmt|;
name|iPageThreshold
operator|=
operator|(
name|cmd
operator|->
name|iConfig
operator|.
name|iPagePower
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|Reset
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|EHeapMetaData
case|:
name|cmd
operator|->
name|iData
operator|=
name|this
expr_stmt|;
break|break;
case|case
name|ETestData
case|:
name|iTestData
operator|=
name|cmd
operator|->
name|iData
expr_stmt|;
break|break;
default|default:
return|return
name|KErrNotSupported
return|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|// __KERNEL_MODE
default|default:
return|return
name|KErrNotSupported
return|;
block|}
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|Walk
name|void
name|RHybridHeap
operator|::
name|Walk
parameter_list|(
name|SWalkInfo
modifier|*
name|aInfo
parameter_list|,
name|TAny
modifier|*
name|aBfr
parameter_list|,
name|TInt
name|aLth
parameter_list|,
name|TCellType
name|aBfrType
parameter_list|,
name|TAllocatorType
name|aAllocatorType
parameter_list|)
block|{
comment|//
comment|// This function is always called from RHybridHeap::GetInfo.
comment|// Actual walk function is called if SWalkInfo pointer is defined
comment|//
comment|//
if|if
condition|(
name|aInfo
condition|)
block|{
ifdef|#
directive|ifdef
name|__KERNEL_MODE__
operator|(
name|void
operator|)
name|aAllocatorType
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
if|if
condition|(
name|aBfrType
operator|==
name|EGoodAllocatedCell
condition|)
name|aInfo
operator|->
name|iFunction
argument_list|(
name|aInfo
operator|->
name|iParam
argument_list|,
name|aBfrType
argument_list|,
operator|(
operator|(
name|TUint8
operator|*
operator|)
name|aBfr
operator|+
name|EDebugHdrSize
operator|)
argument_list|,
operator|(
name|aLth
operator|-
name|EDebugHdrSize
operator|)
argument_list|)
expr_stmt|;
else|else
name|aInfo
operator|->
name|iFunction
argument_list|(
name|aInfo
operator|->
name|iParam
argument_list|,
name|aBfrType
argument_list|,
name|aBfr
argument_list|,
name|aLth
argument_list|)
expr_stmt|;
else|#
directive|else
name|aInfo
operator|->
name|iFunction
argument_list|(
name|aInfo
operator|->
name|iParam
argument_list|,
name|aBfrType
argument_list|,
name|aBfr
argument_list|,
name|aLth
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|// __KERNEL_MODE__
if|if
condition|(
name|aAllocatorType
operator|&
operator|(
name|EFullSlab
operator|+
name|EPartialFullSlab
operator|+
name|EEmptySlab
operator|+
name|ESlabSpare
operator|)
condition|)
block|{
if|if
condition|(
name|aInfo
operator|->
name|iHeap
condition|)
block|{
name|TUint32
name|dummy
decl_stmt|;
name|TInt
name|npages
decl_stmt|;
name|aInfo
operator|->
name|iHeap
operator|->
name|DoCheckSlab
argument_list|(
operator|(
name|slab
operator|*
operator|)
name|aBfr
argument_list|,
name|aAllocatorType
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST_STATIC
argument_list|(
name|aInfo
operator|->
name|iHeap
operator|->
name|CheckBitmap
argument_list|(
name|Floor
argument_list|(
name|aBfr
argument_list|,
name|PAGESIZE
argument_list|)
argument_list|,
name|PAGESIZE
argument_list|,
name|dummy
argument_list|,
name|npages
argument_list|)
argument_list|,
name|aInfo
operator|->
name|iHeap
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|aBfr
argument_list|,
name|aLth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aAllocatorType
operator|&
name|EPartialFullSlab
condition|)
name|WalkPartialFullSlab
argument_list|(
name|aInfo
argument_list|,
operator|(
name|slab
operator|*
operator|)
name|aBfr
argument_list|,
name|aBfrType
argument_list|,
name|aLth
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|aAllocatorType
operator|&
name|EFullSlab
condition|)
name|WalkFullSlab
argument_list|(
name|aInfo
argument_list|,
operator|(
name|slab
operator|*
operator|)
name|aBfr
argument_list|,
name|aBfrType
argument_list|,
name|aLth
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
elseif|else
if|if
condition|(
name|aBfrType
operator|==
name|EGoodAllocatedCell
condition|)
name|aInfo
operator|->
name|iFunction
argument_list|(
name|aInfo
operator|->
name|iParam
argument_list|,
name|aBfrType
argument_list|,
operator|(
operator|(
name|TUint8
operator|*
operator|)
name|aBfr
operator|+
name|EDebugHdrSize
operator|)
argument_list|,
operator|(
name|aLth
operator|-
name|EDebugHdrSize
operator|)
argument_list|)
expr_stmt|;
else|else
name|aInfo
operator|->
name|iFunction
argument_list|(
name|aInfo
operator|->
name|iParam
argument_list|,
name|aBfrType
argument_list|,
name|aBfr
argument_list|,
name|aLth
argument_list|)
expr_stmt|;
else|#
directive|else
else|else
name|aInfo
operator|->
name|iFunction
argument_list|(
name|aInfo
operator|->
name|iParam
argument_list|,
name|aBfrType
argument_list|,
name|aBfr
argument_list|,
name|aLth
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|// __KERNEL_MODE
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
end_ifndef
begin_function
DECL|function|WalkPartialFullSlab
name|void
name|RHybridHeap
operator|::
name|WalkPartialFullSlab
parameter_list|(
name|SWalkInfo
modifier|*
name|aInfo
parameter_list|,
name|slab
modifier|*
name|aSlab
parameter_list|,
name|TCellType
comment|/*aBfrType*/
parameter_list|,
name|TInt
comment|/*aLth*/
parameter_list|)
block|{
if|if
condition|(
name|aInfo
condition|)
block|{
comment|//
comment|// Build bitmap of free buffers in the partial full slab
comment|//
name|TUint32
name|bitmap
index|[
literal|4
index|]
decl_stmt|;
name|__HEAP_CORRUPTED_TEST_STATIC
argument_list|(
operator|(
name|aInfo
operator|->
name|iHeap
operator|!=
name|NULL
operator|)
argument_list|,
name|aInfo
operator|->
name|iHeap
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
literal|0
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
name|aInfo
operator|->
name|iHeap
operator|->
name|BuildPartialSlabBitmap
argument_list|(
name|bitmap
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
comment|//
comment|// Find used (allocated) buffers from iPartial full slab
comment|//
name|TUint32
name|h
init|=
name|aSlab
operator|->
name|iHeader
decl_stmt|;
name|TUint32
name|size
init|=
name|SlabHeaderSize
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|TUint32
name|count
init|=
name|KMaxSlabPayload
operator|/
name|size
decl_stmt|;
comment|// Total buffer count in slab
name|TUint32
name|i
init|=
literal|0
decl_stmt|;
name|TUint32
name|ix
init|=
literal|0
decl_stmt|;
name|TUint32
name|bit
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|count
condition|)
block|{
if|if
condition|(
name|bitmap
index|[
name|ix
index|]
operator|&
name|bit
condition|)
block|{
name|aInfo
operator|->
name|iFunction
argument_list|(
name|aInfo
operator|->
name|iParam
argument_list|,
name|EGoodFreeCell
argument_list|,
operator|&
name|aSlab
operator|->
name|iPayload
index|[
name|i
operator|*
name|size
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|aInfo
operator|->
name|iFunction
argument_list|(
name|aInfo
operator|->
name|iParam
argument_list|,
name|EGoodAllocatedCell
argument_list|,
operator|(
operator|&
name|aSlab
operator|->
name|iPayload
index|[
name|i
operator|*
name|size
index|]
operator|+
name|EDebugHdrSize
operator|)
argument_list|,
operator|(
name|size
operator|-
name|EDebugHdrSize
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|aInfo
operator|->
name|iFunction
argument_list|(
name|aInfo
operator|->
name|iParam
argument_list|,
name|EGoodAllocatedCell
argument_list|,
operator|&
name|aSlab
operator|->
name|iPayload
index|[
name|i
operator|*
name|size
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bit
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|bit
operator|==
literal|0
condition|)
block|{
name|bit
operator|=
literal|1
expr_stmt|;
name|ix
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|WalkFullSlab
name|void
name|RHybridHeap
operator|::
name|WalkFullSlab
parameter_list|(
name|SWalkInfo
modifier|*
name|aInfo
parameter_list|,
name|slab
modifier|*
name|aSlab
parameter_list|,
name|TCellType
name|aBfrType
parameter_list|,
name|TInt
comment|/*aLth*/
parameter_list|)
block|{
if|if
condition|(
name|aInfo
condition|)
block|{
name|TUint32
name|h
init|=
name|aSlab
operator|->
name|iHeader
decl_stmt|;
name|TUint32
name|size
init|=
name|SlabHeaderSize
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|TUint32
name|count
init|=
operator|(
name|SlabHeaderUsedm4
argument_list|(
name|h
argument_list|)
operator|+
literal|4
operator|)
operator|/
name|size
decl_stmt|;
name|TUint32
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|count
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
if|if
condition|(
name|aBfrType
operator|==
name|EGoodAllocatedCell
condition|)
name|aInfo
operator|->
name|iFunction
argument_list|(
name|aInfo
operator|->
name|iParam
argument_list|,
name|aBfrType
argument_list|,
operator|(
operator|&
name|aSlab
operator|->
name|iPayload
index|[
name|i
operator|*
name|size
index|]
operator|+
name|EDebugHdrSize
operator|)
argument_list|,
operator|(
name|size
operator|-
name|EDebugHdrSize
operator|)
argument_list|)
expr_stmt|;
else|else
name|aInfo
operator|->
name|iFunction
argument_list|(
name|aInfo
operator|->
name|iParam
argument_list|,
name|aBfrType
argument_list|,
operator|&
name|aSlab
operator|->
name|iPayload
index|[
name|i
operator|*
name|size
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
name|aInfo
operator|->
name|iFunction
argument_list|(
name|aInfo
operator|->
name|iParam
argument_list|,
name|aBfrType
argument_list|,
operator|&
name|aSlab
operator|->
name|iPayload
index|[
name|i
operator|*
name|size
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|BuildPartialSlabBitmap
name|void
name|RHybridHeap
operator|::
name|BuildPartialSlabBitmap
parameter_list|(
name|TUint32
modifier|*
name|aBitmap
parameter_list|,
name|slab
modifier|*
name|aSlab
parameter_list|,
name|TAny
modifier|*
name|aBfr
parameter_list|)
block|{
comment|//
comment|// Build a bitmap of free buffers in a partial full slab
comment|//
name|TInt
name|i
decl_stmt|;
name|TUint32
name|bit
init|=
literal|0
decl_stmt|;
name|TUint32
name|index
decl_stmt|;
name|TUint32
name|h
init|=
name|aSlab
operator|->
name|iHeader
decl_stmt|;
name|TUint32
name|used
init|=
name|SlabHeaderUsedm4
argument_list|(
name|h
argument_list|)
operator|+
literal|4
decl_stmt|;
name|TUint32
name|size
init|=
name|SlabHeaderSize
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|TInt
name|count
init|=
operator|(
name|KMaxSlabPayload
operator|/
name|size
operator|)
decl_stmt|;
name|TInt
name|free_count
init|=
name|count
operator|-
operator|(
name|used
operator|/
name|size
operator|)
decl_stmt|;
comment|// Total free buffer count in slab
name|aBitmap
index|[
literal|0
index|]
operator|=
literal|0
operator|,
name|aBitmap
index|[
literal|1
index|]
operator|=
literal|0
operator|,
name|aBitmap
index|[
literal|2
index|]
operator|=
literal|0
operator|,
name|aBitmap
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|TUint32
name|offs
init|=
operator|(
name|h
operator|&
literal|0xff
operator|)
operator|<<
literal|2
decl_stmt|;
comment|//
comment|// Process first buffer in partial slab free buffer chain
comment|//
while|while
condition|(
name|offs
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|Offset
argument_list|(
name|aSlab
argument_list|,
name|offs
argument_list|)
decl_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|slabhdr
argument_list|)
operator|<=
name|offs
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
name|offs
operator|-=
sizeof|sizeof
argument_list|(
name|slabhdr
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|offs
operator|%
name|size
operator|==
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|offs
operator|/
name|size
operator|)
expr_stmt|;
comment|// Bit index in bitmap
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|4
condition|)
block|{
if|if
condition|(
name|index
operator|<
literal|32
condition|)
block|{
name|bit
operator|=
operator|(
literal|1
operator|<<
name|index
operator|)
expr_stmt|;
break|break;
block|}
name|index
operator|-=
literal|32
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|(
name|aBitmap
index|[
name|i
index|]
operator|&
name|bit
operator|)
operator|==
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
comment|// Buffer already in chain
name|aBitmap
index|[
name|i
index|]
operator||=
name|bit
expr_stmt|;
name|free_count
operator|--
expr_stmt|;
name|offs
operator|=
operator|(
operator|(
name|unsigned
operator|)
operator|*
name|p
operator|)
operator|<<
literal|2
expr_stmt|;
comment|// Next in free chain
block|}
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|free_count
operator|>=
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|aBfr
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
comment|// free buffer count/size mismatch
comment|//
comment|// Process next rest of the free buffers which are in the
comment|// wilderness (at end of the slab)
comment|//
name|index
operator|=
name|count
operator|-
literal|1
expr_stmt|;
name|i
operator|=
name|index
operator|/
literal|32
expr_stmt|;
name|index
operator|=
name|index
operator|%
literal|32
expr_stmt|;
while|while
condition|(
name|free_count
operator|&&
operator|(
name|i
operator|>=
literal|0
operator|)
condition|)
block|{
name|bit
operator|=
operator|(
literal|1
operator|<<
name|index
operator|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|(
name|aBitmap
index|[
name|i
index|]
operator|&
name|bit
operator|)
operator|==
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|aBfr
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
comment|// Buffer already in chain
name|aBitmap
index|[
name|i
index|]
operator||=
name|bit
expr_stmt|;
if|if
condition|(
name|index
condition|)
name|index
operator|--
expr_stmt|;
else|else
block|{
name|index
operator|=
literal|31
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
name|free_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|aBfr
condition|)
comment|// Assure that specified buffer does NOT exist in partial slab free buffer chain
block|{
name|offs
operator|=
name|LowBits
argument_list|(
name|aBfr
argument_list|,
name|SLABSIZE
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|slabhdr
argument_list|)
operator|<=
name|offs
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|aBfr
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
name|offs
operator|-=
sizeof|sizeof
argument_list|(
name|slabhdr
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|(
name|offs
operator|%
name|size
operator|)
operator|==
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|aBfr
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|offs
operator|/
name|size
operator|)
expr_stmt|;
comment|// Bit index in bitmap
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|4
condition|)
block|{
if|if
condition|(
name|index
operator|<
literal|32
condition|)
block|{
name|bit
operator|=
operator|(
literal|1
operator|<<
name|index
operator|)
expr_stmt|;
break|break;
block|}
name|index
operator|-=
literal|32
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|(
name|aBitmap
index|[
name|i
index|]
operator|&
name|bit
operator|)
operator|==
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|aBfr
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
comment|// Buffer already in chain
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// __KERNEL_MODE__
end_comment
begin_function
DECL|function|WalkCheckCell
name|void
name|RHybridHeap
operator|::
name|WalkCheckCell
parameter_list|(
name|TAny
modifier|*
name|aPtr
parameter_list|,
name|TCellType
name|aType
parameter_list|,
name|TAny
modifier|*
name|aCell
parameter_list|,
name|TInt
name|aLen
parameter_list|)
block|{
operator|(
name|void
operator|)
name|aCell
expr_stmt|;
name|SHeapCellInfo
modifier|&
name|info
init|=
operator|*
operator|(
name|SHeapCellInfo
operator|*
operator|)
name|aPtr
decl_stmt|;
switch|switch
condition|(
name|aType
condition|)
block|{
case|case
name|EGoodAllocatedCell
case|:
block|{
operator|++
name|info
operator|.
name|iTotalAlloc
expr_stmt|;
name|info
operator|.
name|iTotalAllocSize
operator|+=
name|aLen
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
name|RHybridHeap
modifier|&
name|h
init|=
operator|*
name|info
operator|.
name|iHeap
decl_stmt|;
name|SDebugCell
modifier|*
name|DbgCell
init|=
operator|(
name|SDebugCell
operator|*
operator|)
operator|(
operator|(
name|TUint8
operator|*
operator|)
name|aCell
operator|-
name|EDebugHdrSize
operator|)
decl_stmt|;
if|if
condition|(
name|DbgCell
operator|->
name|nestingLevel
operator|==
name|h
operator|.
name|iNestingLevel
condition|)
block|{
if|if
condition|(
operator|++
name|info
operator|.
name|iLevelAlloc
operator|==
literal|1
condition|)
name|info
operator|.
name|iStranded
operator|=
name|DbgCell
expr_stmt|;
ifdef|#
directive|ifdef
name|__KERNEL_MODE__
if|if
condition|(
name|KDebugNum
argument_list|(
name|KSERVER
argument_list|)
operator|||
name|KDebugNum
argument_list|(
name|KTESTFAST
argument_list|)
condition|)
block|{
name|Kern
operator|::
name|Printf
argument_list|(
literal|"LEAKED KERNEL HEAP CELL @ %08x : len=%d"
argument_list|,
name|aCell
argument_list|,
name|aLen
argument_list|)
expr_stmt|;
name|TLinAddr
name|base
init|=
operator|(
operator|(
name|TLinAddr
operator|)
name|aCell
operator|)
operator|&
operator|~
literal|0x0f
decl_stmt|;
name|TLinAddr
name|end
init|=
operator|(
operator|(
name|TLinAddr
operator|)
name|aCell
operator|)
operator|+
operator|(
name|TLinAddr
operator|)
name|aLen
decl_stmt|;
while|while
condition|(
name|base
operator|<
name|end
condition|)
block|{
specifier|const
name|TUint32
modifier|*
name|p
init|=
operator|(
specifier|const
name|TUint32
operator|*
operator|)
name|base
decl_stmt|;
name|Kern
operator|::
name|Printf
argument_list|(
literal|"%08x: %08x %08x %08x %08x"
argument_list|,
name|p
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|base
operator|+=
literal|16
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
break|break;
block|}
case|case
name|EGoodFreeCell
case|:
operator|++
name|info
operator|.
name|iTotalFree
expr_stmt|;
break|break;
case|case
name|EBadAllocatedCellSize
case|:
name|HEAP_PANIC
argument_list|(
name|ETHeapBadAllocatedCellSize
argument_list|)
expr_stmt|;
case|case
name|EBadAllocatedCellAddress
case|:
name|HEAP_PANIC
argument_list|(
name|ETHeapBadAllocatedCellAddress
argument_list|)
expr_stmt|;
case|case
name|EBadFreeCellAddress
case|:
name|HEAP_PANIC
argument_list|(
name|ETHeapBadFreeCellAddress
argument_list|)
expr_stmt|;
case|case
name|EBadFreeCellSize
case|:
name|HEAP_PANIC
argument_list|(
name|ETHeapBadFreeCellSize
argument_list|)
expr_stmt|;
default|default:
name|HEAP_PANIC
argument_list|(
name|ETHeapWalkBadCellType
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|DoCheckHeap
name|TInt
name|RHybridHeap
operator|::
name|DoCheckHeap
parameter_list|(
name|SCheckInfo
modifier|*
name|aInfo
parameter_list|)
block|{
operator|(
name|void
operator|)
name|aInfo
expr_stmt|;
name|SHeapCellInfo
name|info
decl_stmt|;
name|memclr
argument_list|(
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|iHeap
operator|=
name|this
expr_stmt|;
name|struct
name|HeapInfo
name|hinfo
decl_stmt|;
name|SWalkInfo
name|winfo
decl_stmt|;
name|Lock
argument_list|()
expr_stmt|;
name|DoCheckMallocState
argument_list|(
name|GM
argument_list|)
expr_stmt|;
comment|// Check DL heap internal structure
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
name|TUint32
name|dummy
decl_stmt|;
name|TInt
name|npages
decl_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
name|CheckBitmap
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|dummy
argument_list|,
name|npages
argument_list|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Check page allocator buffers
name|DoCheckSlabTrees
argument_list|()
expr_stmt|;
name|DoCheckCommittedSize
argument_list|(
name|npages
argument_list|,
name|GM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|winfo
operator|.
name|iFunction
operator|=
name|WalkCheckCell
expr_stmt|;
name|winfo
operator|.
name|iParam
operator|=
operator|&
name|info
expr_stmt|;
name|winfo
operator|.
name|iHeap
operator|=
operator|(
name|RHybridHeap
operator|*
operator|)
name|this
expr_stmt|;
name|GetInfo
argument_list|(
operator|&
name|hinfo
argument_list|,
operator|&
name|winfo
argument_list|)
expr_stmt|;
name|Unlock
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG
argument_list|)
if|if
condition|(
operator|!
name|aInfo
condition|)
return|return
name|KErrNone
return|;
name|TInt
name|expected
init|=
name|aInfo
operator|->
name|iCount
decl_stmt|;
name|TInt
name|actual
init|=
name|aInfo
operator|->
name|iAll
condition|?
name|info
operator|.
name|iTotalAlloc
else|:
name|info
operator|.
name|iLevelAlloc
decl_stmt|;
if|if
condition|(
name|actual
operator|!=
name|expected
operator|&&
operator|!
name|iTestData
condition|)
block|{
ifdef|#
directive|ifdef
name|__KERNEL_MODE__
name|Kern
operator|::
name|Fault
argument_list|(
literal|"KERN-ALLOC COUNT"
argument_list|,
operator|(
name|expected
operator|<<
literal|16
operator|)
operator||
name|actual
argument_list|)
expr_stmt|;
else|#
directive|else
name|User
operator|::
name|Panic
argument_list|(
name|_L
argument_list|(
literal|"ALLOC COUNT"
argument_list|)
argument_list|,
operator|(
name|expected
operator|<<
literal|16
operator|)
operator||
name|actual
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
return|return
name|KErrNone
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|_DEBUG
end_ifdef
begin_function
DECL|function|DoMarkStart
name|void
name|RHybridHeap
operator|::
name|DoMarkStart
parameter_list|()
block|{
if|if
condition|(
name|iNestingLevel
operator|==
literal|0
condition|)
name|iAllocCount
operator|=
literal|0
expr_stmt|;
name|iNestingLevel
operator|++
expr_stmt|;
block|}
end_function
begin_function
DECL|function|DoMarkEnd
name|TUint32
name|RHybridHeap
operator|::
name|DoMarkEnd
parameter_list|(
name|TInt
name|aExpected
parameter_list|)
block|{
if|if
condition|(
name|iNestingLevel
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|SHeapCellInfo
name|info
decl_stmt|;
name|SHeapCellInfo
modifier|*
name|p
init|=
name|iTestData
condition|?
operator|(
name|SHeapCellInfo
operator|*
operator|)
name|iTestData
else|:
operator|&
name|info
decl_stmt|;
name|memclr
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|iHeap
operator|=
name|this
expr_stmt|;
name|struct
name|HeapInfo
name|hinfo
decl_stmt|;
name|SWalkInfo
name|winfo
decl_stmt|;
name|Lock
argument_list|()
expr_stmt|;
name|winfo
operator|.
name|iFunction
operator|=
name|WalkCheckCell
expr_stmt|;
name|winfo
operator|.
name|iParam
operator|=
name|p
expr_stmt|;
name|winfo
operator|.
name|iHeap
operator|=
operator|(
name|RHybridHeap
operator|*
operator|)
name|this
expr_stmt|;
name|GetInfo
argument_list|(
operator|&
name|hinfo
argument_list|,
operator|&
name|winfo
argument_list|)
expr_stmt|;
name|Unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|iLevelAlloc
operator|!=
name|aExpected
operator|&&
operator|!
name|iTestData
condition|)
return|return
call|(
name|TUint32
call|)
argument_list|(
name|p
operator|->
name|iStranded
operator|+
literal|1
argument_list|)
return|;
if|if
condition|(
operator|--
name|iNestingLevel
operator|==
literal|0
condition|)
name|iAllocCount
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|DoSetAllocFail
name|void
name|RHybridHeap
operator|::
name|DoSetAllocFail
parameter_list|(
name|TAllocFail
name|aType
parameter_list|,
name|TInt
name|aRate
parameter_list|)
block|{
comment|// Default to a burst mode of 1, as aType may be a burst type.
name|DoSetAllocFail
argument_list|(
name|aType
argument_list|,
name|aRate
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ResetAllocCellLevels
name|void
name|ResetAllocCellLevels
parameter_list|(
name|TAny
modifier|*
name|aPtr
parameter_list|,
name|RHybridHeap
operator|::
name|TCellType
name|aType
parameter_list|,
name|TAny
modifier|*
name|aCell
parameter_list|,
name|TInt
name|aLen
parameter_list|)
block|{
operator|(
name|void
operator|)
name|aPtr
expr_stmt|;
operator|(
name|void
operator|)
name|aLen
expr_stmt|;
if|if
condition|(
name|aType
operator|==
name|RHybridHeap
operator|::
name|EGoodAllocatedCell
condition|)
block|{
name|RHybridHeap
operator|::
name|SDebugCell
modifier|*
name|DbgCell
init|=
operator|(
name|RHybridHeap
operator|::
name|SDebugCell
operator|*
operator|)
operator|(
operator|(
name|TUint8
operator|*
operator|)
name|aCell
operator|-
name|RHybridHeap
operator|::
name|EDebugHdrSize
operator|)
decl_stmt|;
name|DbgCell
operator|->
name|nestingLevel
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// Don't change as the ETHeapBadDebugFailParameter check below and the API
end_comment
begin_comment
comment|// documentation rely on this being 16 for RHybridHeap.
end_comment
begin_decl_stmt
DECL|variable|KBurstFailRateShift
name|LOCAL_D
specifier|const
name|TInt
name|KBurstFailRateShift
init|=
literal|16
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|KBurstFailRateMask
name|LOCAL_D
specifier|const
name|TInt
name|KBurstFailRateMask
init|=
operator|(
literal|1
operator|<<
name|KBurstFailRateShift
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|DoSetAllocFail
name|void
name|RHybridHeap
operator|::
name|DoSetAllocFail
parameter_list|(
name|TAllocFail
name|aType
parameter_list|,
name|TInt
name|aRate
parameter_list|,
name|TUint
name|aBurst
parameter_list|)
block|{
if|if
condition|(
name|aType
operator|==
name|EReset
condition|)
block|{
comment|// reset levels of all allocated cells to 0
comment|// this should prevent subsequent tests failing unnecessarily
name|iFailed
operator|=
name|EFalse
expr_stmt|;
comment|// Reset for ECheckFailure relies on this.
name|struct
name|HeapInfo
name|hinfo
decl_stmt|;
name|SWalkInfo
name|winfo
decl_stmt|;
name|Lock
argument_list|()
expr_stmt|;
name|winfo
operator|.
name|iFunction
operator|=
operator|(
name|TWalkFunc
operator|)
operator|&
name|ResetAllocCellLevels
expr_stmt|;
name|winfo
operator|.
name|iParam
operator|=
name|NULL
expr_stmt|;
name|winfo
operator|.
name|iHeap
operator|=
operator|(
name|RHybridHeap
operator|*
operator|)
name|this
expr_stmt|;
name|GetInfo
argument_list|(
operator|&
name|hinfo
argument_list|,
operator|&
name|winfo
argument_list|)
expr_stmt|;
name|Unlock
argument_list|()
expr_stmt|;
comment|// reset heap allocation mark as well
name|iNestingLevel
operator|=
literal|0
expr_stmt|;
name|iAllocCount
operator|=
literal|0
expr_stmt|;
name|aType
operator|=
name|ENone
expr_stmt|;
block|}
switch|switch
condition|(
name|aType
condition|)
block|{
case|case
name|EBurstRandom
case|:
case|case
name|EBurstTrueRandom
case|:
case|case
name|EBurstDeterministic
case|:
case|case
name|EBurstFailNext
case|:
comment|// If the fail type is a burst type then iFailRate is split in 2:
comment|// the 16 lsbs are the fail rate and the 16 msbs are the burst length.
if|if
condition|(
name|TUint
argument_list|(
name|aRate
argument_list|)
operator|>
operator|(
name|TUint
operator|)
name|KMaxTUint16
operator|||
name|aBurst
operator|>
name|KMaxTUint16
condition|)
name|HEAP_PANIC
argument_list|(
name|ETHeapBadDebugFailParameter
argument_list|)
expr_stmt|;
name|iFailed
operator|=
name|EFalse
expr_stmt|;
name|iFailType
operator|=
name|aType
expr_stmt|;
name|iFailRate
operator|=
operator|(
name|aRate
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|aRate
expr_stmt|;
name|iFailAllocCount
operator|=
operator|-
name|iFailRate
expr_stmt|;
name|iFailRate
operator|=
name|iFailRate
operator||
operator|(
name|aBurst
operator|<<
name|KBurstFailRateShift
operator|)
expr_stmt|;
break|break;
default|default:
name|iFailed
operator|=
name|EFalse
expr_stmt|;
name|iFailType
operator|=
name|aType
expr_stmt|;
name|iFailRate
operator|=
operator|(
name|aRate
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|aRate
expr_stmt|;
comment|// A rate of<1 is meaningless
name|iFailAllocCount
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|// Set up iRand for either:
comment|//      - random seed value, or
comment|//      - a count of the number of failures so far.
name|iRand
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
switch|switch
condition|(
name|iFailType
condition|)
block|{
case|case
name|ETrueRandom
case|:
case|case
name|EBurstTrueRandom
case|:
block|{
name|TTime
name|time
decl_stmt|;
name|time
operator|.
name|HomeTime
argument_list|()
expr_stmt|;
name|TInt64
name|seed
init|=
name|time
operator|.
name|Int64
argument_list|()
decl_stmt|;
name|iRand
operator|=
name|Math
operator|::
name|Rand
argument_list|(
name|seed
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ERandom
case|:
case|case
name|EBurstRandom
case|:
block|{
name|TInt64
name|seed
init|=
literal|12345
decl_stmt|;
name|iRand
operator|=
name|Math
operator|::
name|Rand
argument_list|(
name|seed
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|CheckForSimulatedAllocFail
name|TBool
name|RHybridHeap
operator|::
name|CheckForSimulatedAllocFail
parameter_list|()
comment|//
comment|// Check to see if the user has requested simulated alloc failure, and if so possibly
comment|// Return ETrue indicating a failure.
comment|//
block|{
comment|// For burst mode failures iFailRate is shared
name|TUint16
name|rate
init|=
call|(
name|TUint16
call|)
argument_list|(
name|iFailRate
operator|&
name|KBurstFailRateMask
argument_list|)
decl_stmt|;
name|TUint16
name|burst
init|=
call|(
name|TUint16
call|)
argument_list|(
name|iFailRate
operator|>>
name|KBurstFailRateShift
argument_list|)
decl_stmt|;
name|TBool
name|r
init|=
name|EFalse
decl_stmt|;
switch|switch
condition|(
name|iFailType
condition|)
block|{
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
case|case
name|ERandom
case|:
case|case
name|ETrueRandom
case|:
if|if
condition|(
operator|++
name|iFailAllocCount
operator|>=
name|iFailRate
condition|)
block|{
name|iFailAllocCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|iFailed
condition|)
comment|// haven't failed yet after iFailRate allocations so fail now
return|return
operator|(
name|ETrue
operator|)
return|;
name|iFailed
operator|=
name|EFalse
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|iFailed
condition|)
block|{
name|TInt64
name|seed
init|=
name|iRand
decl_stmt|;
name|iRand
operator|=
name|Math
operator|::
name|Rand
argument_list|(
name|seed
argument_list|)
expr_stmt|;
if|if
condition|(
name|iRand
operator|%
name|iFailRate
operator|==
literal|0
condition|)
block|{
name|iFailed
operator|=
name|ETrue
expr_stmt|;
return|return
operator|(
name|ETrue
operator|)
return|;
block|}
block|}
block|}
break|break;
case|case
name|EBurstRandom
case|:
case|case
name|EBurstTrueRandom
case|:
if|if
condition|(
operator|++
name|iFailAllocCount
operator|<
literal|0
condition|)
block|{
comment|// We haven't started failing yet so should we now?
name|TInt64
name|seed
init|=
name|iRand
decl_stmt|;
name|iRand
operator|=
name|Math
operator|::
name|Rand
argument_list|(
name|seed
argument_list|)
expr_stmt|;
if|if
condition|(
name|iRand
operator|%
name|rate
operator|==
literal|0
condition|)
block|{
comment|// Fail now.  Reset iFailAllocCount so we fail burst times
name|iFailAllocCount
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|ETrue
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|iFailAllocCount
operator|<
name|burst
condition|)
block|{
comment|// Keep failing for burst times
name|r
operator|=
name|ETrue
expr_stmt|;
block|}
else|else
block|{
comment|// We've now failed burst times so start again.
name|iFailAllocCount
operator|=
operator|-
operator|(
name|rate
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
case|case
name|EDeterministic
case|:
if|if
condition|(
operator|++
name|iFailAllocCount
operator|%
name|iFailRate
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|ETrue
expr_stmt|;
name|iRand
operator|++
expr_stmt|;
comment|// Keep count of how many times we have failed
block|}
break|break;
case|case
name|EBurstDeterministic
case|:
comment|// This will fail burst number of times, every rate attempts.
if|if
condition|(
operator|++
name|iFailAllocCount
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|iFailAllocCount
operator|==
name|burst
operator|-
literal|1
condition|)
block|{
comment|// This is the burst time we have failed so make it the last by
comment|// reseting counts so we next fail after rate attempts.
name|iFailAllocCount
operator|=
operator|-
name|rate
expr_stmt|;
block|}
name|r
operator|=
name|ETrue
expr_stmt|;
name|iRand
operator|++
expr_stmt|;
comment|// Keep count of how many times we have failed
block|}
break|break;
case|case
name|EFailNext
case|:
if|if
condition|(
operator|(
operator|++
name|iFailAllocCount
operator|%
name|iFailRate
operator|)
operator|==
literal|0
condition|)
block|{
name|iFailType
operator|=
name|ENone
expr_stmt|;
name|r
operator|=
name|ETrue
expr_stmt|;
name|iRand
operator|++
expr_stmt|;
comment|// Keep count of how many times we have failed
block|}
break|break;
case|case
name|EBurstFailNext
case|:
if|if
condition|(
operator|++
name|iFailAllocCount
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|iFailAllocCount
operator|==
name|burst
operator|-
literal|1
condition|)
block|{
comment|// This is the burst time we have failed so make it the last.
name|iFailType
operator|=
name|ENone
expr_stmt|;
block|}
name|r
operator|=
name|ETrue
expr_stmt|;
name|iRand
operator|++
expr_stmt|;
comment|// Keep count of how many times we have failed
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|r
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// DEBUG
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//  Methods for Doug Lea allocator detailed check
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|DoCheckAnyChunk
name|void
name|RHybridHeap
operator|::
name|DoCheckAnyChunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
block|{
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|(
name|IS_ALIGNED
argument_list|(
name|CHUNK2MEM
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|p
operator|->
name|iHead
operator|==
name|FENCEPOST_HEAD
operator|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Check properties of iTop chunk */
end_comment
begin_function
DECL|function|DoCheckTopChunk
name|void
name|RHybridHeap
operator|::
name|DoCheckTopChunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
block|{
name|msegmentptr
name|sp
init|=
operator|&
name|m
operator|->
name|iSeg
decl_stmt|;
name|size_t
name|sz
init|=
name|CHUNKSIZE
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|sp
operator|!=
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|(
name|IS_ALIGNED
argument_list|(
name|CHUNK2MEM
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|p
operator|->
name|iHead
operator|==
name|FENCEPOST_HEAD
operator|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|sz
operator|==
name|m
operator|->
name|iTopSize
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|sz
operator|>
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|sz
operator|==
operator|(
operator|(
name|sp
operator|->
name|iBase
operator|+
name|sp
operator|->
name|iSize
operator|)
operator|-
operator|(
name|TUint8
operator|*
operator|)
name|p
operator|)
operator|-
name|TOP_FOOT_SIZE
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|PINUSE
argument_list|(
name|p
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|!
name|NEXT_PINUSE
argument_list|(
name|p
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Check properties of inuse chunks */
end_comment
begin_function
DECL|function|DoCheckInuseChunk
name|void
name|RHybridHeap
operator|::
name|DoCheckInuseChunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
block|{
name|DoCheckAnyChunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|CINUSE
argument_list|(
name|p
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|NEXT_PINUSE
argument_list|(
name|p
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If not PINUSE and not mmapped, previous chunk has OK offset */
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|PINUSE
argument_list|(
name|p
argument_list|)
operator|||
name|NEXT_CHUNK
argument_list|(
name|PREV_CHUNK
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|p
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Check properties of free chunks */
end_comment
begin_function
DECL|function|DoCheckFreeChunk
name|void
name|RHybridHeap
operator|::
name|DoCheckFreeChunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
block|{
name|size_t
name|sz
init|=
name|p
operator|->
name|iHead
operator|&
operator|~
operator|(
name|PINUSE_BIT
operator||
name|CINUSE_BIT
operator|)
decl_stmt|;
name|mchunkptr
name|next
init|=
name|CHUNK_PLUS_OFFSET
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
decl_stmt|;
name|DoCheckAnyChunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|!
name|CINUSE
argument_list|(
name|p
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|!
name|NEXT_PINUSE
argument_list|(
name|p
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|m
operator|->
name|iDv
operator|&&
name|p
operator|!=
name|m
operator|->
name|iTop
condition|)
block|{
if|if
condition|(
name|sz
operator|>=
name|MIN_CHUNK_SIZE
condition|)
block|{
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|(
name|sz
operator|&
name|CHUNK_ALIGN_MASK
operator|)
operator|==
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|IS_ALIGNED
argument_list|(
name|CHUNK2MEM
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|next
operator|->
name|iPrevFoot
operator|==
name|sz
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|PINUSE
argument_list|(
name|p
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|next
operator|==
name|m
operator|->
name|iTop
operator|||
name|CINUSE
argument_list|(
name|next
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|p
operator|->
name|iFd
operator|->
name|iBk
operator|==
name|p
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|p
operator|->
name|iBk
operator|->
name|iFd
operator|==
name|p
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* markers are always of size SIZE_T_SIZE */
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|sz
operator|==
name|SIZE_T_SIZE
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Check properties of malloced chunks at the point they are malloced */
end_comment
begin_function
DECL|function|DoCheckMallocedChunk
name|void
name|RHybridHeap
operator|::
name|DoCheckMallocedChunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
if|if
condition|(
name|mem
operator|!=
literal|0
condition|)
block|{
name|mchunkptr
name|p
init|=
name|MEM2CHUNK
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|size_t
name|sz
init|=
name|p
operator|->
name|iHead
operator|&
operator|~
operator|(
name|PINUSE_BIT
operator||
name|CINUSE_BIT
operator|)
decl_stmt|;
name|DoCheckInuseChunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|(
name|sz
operator|&
name|CHUNK_ALIGN_MASK
operator|)
operator|==
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|sz
operator|>=
name|MIN_CHUNK_SIZE
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|sz
operator|>=
name|s
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unless mmapped, size is less than MIN_CHUNK_SIZE more than request */
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|sz
operator|<
operator|(
name|s
operator|+
name|MIN_CHUNK_SIZE
operator|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Check a tree and its subtrees.   */
end_comment
begin_function
DECL|function|DoCheckTree
name|void
name|RHybridHeap
operator|::
name|DoCheckTree
parameter_list|(
name|mstate
name|m
parameter_list|,
name|tchunkptr
name|t
parameter_list|)
block|{
name|tchunkptr
name|head
init|=
literal|0
decl_stmt|;
name|tchunkptr
name|u
init|=
name|t
decl_stmt|;
name|bindex_t
name|tindex
init|=
name|t
operator|->
name|iIndex
decl_stmt|;
name|size_t
name|tsize
init|=
name|CHUNKSIZE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|bindex_t
name|idx
decl_stmt|;
name|DoComputeTreeIndex
argument_list|(
name|tsize
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|tindex
operator|==
name|idx
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|tsize
operator|>=
name|MIN_LARGE_SIZE
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|tsize
operator|>=
name|MINSIZE_FOR_TREE_INDEX
argument_list|(
name|idx
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|(
name|idx
operator|==
name|NTREEBINS
operator|-
literal|1
operator|)
operator|||
operator|(
name|tsize
operator|<
name|MINSIZE_FOR_TREE_INDEX
argument_list|(
operator|(
name|idx
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* traverse through chain of same-sized nodes */
name|DoCheckAnyChunk
argument_list|(
name|m
argument_list|,
operator|(
operator|(
name|mchunkptr
operator|)
name|u
operator|)
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|u
operator|->
name|iIndex
operator|==
name|tindex
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|CHUNKSIZE
argument_list|(
name|u
argument_list|)
operator|==
name|tsize
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|!
name|CINUSE
argument_list|(
name|u
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|!
name|NEXT_PINUSE
argument_list|(
name|u
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|u
operator|->
name|iFd
operator|->
name|iBk
operator|==
name|u
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|u
operator|->
name|iBk
operator|->
name|iFd
operator|==
name|u
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|->
name|iParent
operator|==
literal|0
condition|)
block|{
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|u
operator|->
name|iChild
index|[
literal|0
index|]
operator|==
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|u
operator|->
name|iChild
index|[
literal|1
index|]
operator|==
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|head
operator|==
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* only one node on chain has iParent */
name|head
operator|=
name|u
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|u
operator|->
name|iParent
operator|!=
name|u
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|u
operator|->
name|iParent
operator|->
name|iChild
index|[
literal|0
index|]
operator|==
name|u
operator|||
name|u
operator|->
name|iParent
operator|->
name|iChild
index|[
literal|1
index|]
operator|==
name|u
operator|||
operator|*
operator|(
operator|(
name|tbinptr
operator|*
operator|)
operator|(
name|u
operator|->
name|iParent
operator|)
operator|)
operator|==
name|u
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|->
name|iChild
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|u
operator|->
name|iChild
index|[
literal|0
index|]
operator|->
name|iParent
operator|==
name|u
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|u
operator|->
name|iChild
index|[
literal|0
index|]
operator|!=
name|u
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DoCheckTree
argument_list|(
name|m
argument_list|,
name|u
operator|->
name|iChild
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|u
operator|->
name|iChild
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|u
operator|->
name|iChild
index|[
literal|1
index|]
operator|->
name|iParent
operator|==
name|u
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|u
operator|->
name|iChild
index|[
literal|1
index|]
operator|!=
name|u
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DoCheckTree
argument_list|(
name|m
argument_list|,
name|u
operator|->
name|iChild
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|u
operator|->
name|iChild
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|u
operator|->
name|iChild
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|CHUNKSIZE
argument_list|(
name|u
operator|->
name|iChild
index|[
literal|0
index|]
argument_list|)
operator|<
name|CHUNKSIZE
argument_list|(
name|u
operator|->
name|iChild
index|[
literal|1
index|]
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|u
operator|=
name|u
operator|->
name|iFd
expr_stmt|;
block|}
do|while
condition|(
name|u
operator|!=
name|t
condition|)
do|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|head
operator|!=
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|u
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  Check all the chunks in a treebin.  */
end_comment
begin_function
DECL|function|DoCheckTreebin
name|void
name|RHybridHeap
operator|::
name|DoCheckTreebin
parameter_list|(
name|mstate
name|m
parameter_list|,
name|bindex_t
name|i
parameter_list|)
block|{
name|tbinptr
modifier|*
name|tb
init|=
name|TREEBIN_AT
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tchunkptr
name|t
init|=
operator|*
name|tb
decl_stmt|;
name|int
name|empty
init|=
operator|(
name|m
operator|->
name|iTreeMap
operator|&
operator|(
literal|1U
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|empty
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|empty
condition|)
name|DoCheckTree
argument_list|(
name|m
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  Check all the chunks in a smallbin. */
end_comment
begin_function
DECL|function|DoCheckSmallbin
name|void
name|RHybridHeap
operator|::
name|DoCheckSmallbin
parameter_list|(
name|mstate
name|m
parameter_list|,
name|bindex_t
name|i
parameter_list|)
block|{
name|sbinptr
name|b
init|=
name|SMALLBIN_AT
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|mchunkptr
name|p
init|=
name|b
operator|->
name|iBk
decl_stmt|;
name|unsigned
name|int
name|empty
init|=
operator|(
name|m
operator|->
name|iSmallMap
operator|&
operator|(
literal|1U
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|b
condition|)
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|empty
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|empty
condition|)
block|{
for|for
control|(
init|;
name|p
operator|!=
name|b
condition|;
name|p
operator|=
name|p
operator|->
name|iBk
control|)
block|{
name|size_t
name|size
init|=
name|CHUNKSIZE
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|mchunkptr
name|q
decl_stmt|;
comment|/* each chunk claims to be free */
name|DoCheckFreeChunk
argument_list|(
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* chunk belongs in bin */
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|SMALL_INDEX
argument_list|(
name|size
argument_list|)
operator|==
name|i
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|p
operator|->
name|iBk
operator|==
name|b
operator|||
name|CHUNKSIZE
argument_list|(
name|p
operator|->
name|iBk
argument_list|)
operator|==
name|CHUNKSIZE
argument_list|(
name|p
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* chunk is followed by an inuse chunk */
name|q
operator|=
name|NEXT_CHUNK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|iHead
operator|!=
name|FENCEPOST_HEAD
condition|)
name|DoCheckInuseChunk
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Find x in a bin. Used in other check functions. */
end_comment
begin_function
DECL|function|BinFind
name|TInt
name|RHybridHeap
operator|::
name|BinFind
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|x
parameter_list|)
block|{
name|size_t
name|size
init|=
name|CHUNKSIZE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_SMALL
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|bindex_t
name|sidx
init|=
name|SMALL_INDEX
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|sbinptr
name|b
init|=
name|SMALLBIN_AT
argument_list|(
name|m
argument_list|,
name|sidx
argument_list|)
decl_stmt|;
if|if
condition|(
name|SMALLMAP_IS_MARKED
argument_list|(
name|m
argument_list|,
name|sidx
argument_list|)
condition|)
block|{
name|mchunkptr
name|p
init|=
name|b
decl_stmt|;
do|do
block|{
if|if
condition|(
name|p
operator|==
name|x
condition|)
return|return
literal|1
return|;
block|}
do|while
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|iFd
operator|)
operator|!=
name|b
condition|)
do|;
block|}
block|}
else|else
block|{
name|bindex_t
name|tidx
decl_stmt|;
name|DoComputeTreeIndex
argument_list|(
name|size
argument_list|,
name|tidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREEMAP_IS_MARKED
argument_list|(
name|m
argument_list|,
name|tidx
argument_list|)
condition|)
block|{
name|tchunkptr
name|t
init|=
operator|*
name|TREEBIN_AT
argument_list|(
name|m
argument_list|,
name|tidx
argument_list|)
decl_stmt|;
name|size_t
name|sizebits
init|=
name|size
operator|<<
name|LEFTSHIFT_FOR_TREE_INDEX
argument_list|(
name|tidx
argument_list|)
decl_stmt|;
while|while
condition|(
name|t
operator|!=
literal|0
operator|&&
name|CHUNKSIZE
argument_list|(
name|t
argument_list|)
operator|!=
name|size
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|iChild
index|[
operator|(
name|sizebits
operator|>>
operator|(
name|SIZE_T_BITSIZE
operator|-
name|SIZE_T_ONE
operator|)
operator|)
operator|&
literal|1
index|]
expr_stmt|;
name|sizebits
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
block|{
name|tchunkptr
name|u
init|=
name|t
decl_stmt|;
do|do
block|{
if|if
condition|(
name|u
operator|==
operator|(
name|tchunkptr
operator|)
name|x
condition|)
return|return
literal|1
return|;
block|}
do|while
condition|(
operator|(
name|u
operator|=
name|u
operator|->
name|iFd
operator|)
operator|!=
name|t
condition|)
do|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Traverse each chunk and check it; return total */
end_comment
begin_function
DECL|function|TraverseAndCheck
name|size_t
name|RHybridHeap
operator|::
name|TraverseAndCheck
parameter_list|(
name|mstate
name|m
parameter_list|)
block|{
name|size_t
name|sum
init|=
literal|0
decl_stmt|;
name|msegmentptr
name|s
init|=
operator|&
name|m
operator|->
name|iSeg
decl_stmt|;
name|sum
operator|+=
name|m
operator|->
name|iTopSize
operator|+
name|TOP_FOOT_SIZE
expr_stmt|;
name|mchunkptr
name|q
init|=
name|ALIGN_AS_CHUNK
argument_list|(
name|s
operator|->
name|iBase
argument_list|)
decl_stmt|;
name|mchunkptr
name|lastq
init|=
literal|0
decl_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|PINUSE
argument_list|(
name|q
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|m
operator|->
name|iTop
operator|&&
name|q
operator|->
name|iHead
operator|!=
name|FENCEPOST_HEAD
condition|)
block|{
name|sum
operator|+=
name|CHUNKSIZE
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|CINUSE
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|!
name|BinFind
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DoCheckInuseChunk
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|q
operator|==
name|m
operator|->
name|iDv
operator|||
name|BinFind
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|lastq
operator|==
literal|0
operator|||
name|CINUSE
argument_list|(
name|lastq
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Not 2 consecutive free */
name|DoCheckFreeChunk
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
name|lastq
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|NEXT_CHUNK
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function
begin_comment
comment|/* Check all properties of malloc_state. */
end_comment
begin_function
DECL|function|DoCheckMallocState
name|void
name|RHybridHeap
operator|::
name|DoCheckMallocState
parameter_list|(
name|mstate
name|m
parameter_list|)
block|{
name|bindex_t
name|i
decl_stmt|;
comment|//    size_t total;
comment|/* check bins */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSMALLBINS
condition|;
operator|++
name|i
control|)
name|DoCheckSmallbin
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTREEBINS
condition|;
operator|++
name|i
control|)
name|DoCheckTreebin
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|iDvSize
operator|!=
literal|0
condition|)
block|{
comment|/* check iDv chunk */
name|DoCheckAnyChunk
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|iDv
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|m
operator|->
name|iDvSize
operator|==
name|CHUNKSIZE
argument_list|(
name|m
operator|->
name|iDv
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|m
operator|->
name|iDv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|m
operator|->
name|iDvSize
operator|>=
name|MIN_CHUNK_SIZE
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|m
operator|->
name|iDv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|BinFind
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|iDv
argument_list|)
operator|==
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|m
operator|->
name|iDv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|iTop
operator|!=
literal|0
condition|)
block|{
comment|/* check iTop chunk */
name|DoCheckTopChunk
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|iTop
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|m
operator|->
name|iTopSize
operator|==
name|CHUNKSIZE
argument_list|(
name|m
operator|->
name|iTop
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|m
operator|->
name|iTop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|m
operator|->
name|iTopSize
operator|>
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|m
operator|->
name|iTop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|BinFind
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|iTop
argument_list|)
operator|==
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|m
operator|->
name|iTop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//    total =
name|TraverseAndCheck
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
end_ifndef
begin_comment
comment|//
end_comment
begin_comment
comment|//  Methods for Slab allocator detailed check
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|DoCheckSlabTree
name|void
name|RHybridHeap
operator|::
name|DoCheckSlabTree
parameter_list|(
name|slab
modifier|*
modifier|*
name|aS
parameter_list|,
name|TBool
name|aPartialPage
parameter_list|)
block|{
name|slab
modifier|*
name|s
init|=
operator|*
name|aS
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return;
name|TUint
name|size
init|=
name|SlabHeaderSize
argument_list|(
name|s
operator|->
name|iHeader
argument_list|)
decl_stmt|;
name|slab
modifier|*
modifier|*
name|parent
init|=
name|aS
decl_stmt|;
name|slab
modifier|*
modifier|*
name|child2
init|=
operator|&
name|s
operator|->
name|iChild2
decl_stmt|;
while|while
condition|(
name|s
condition|)
block|{
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|s
operator|->
name|iParent
operator|==
name|parent
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|s
argument_list|,
name|SLABSIZE
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|!
name|s
operator|->
name|iChild1
operator|||
name|s
operator|<
name|s
operator|->
name|iChild1
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|s
argument_list|,
name|SLABSIZE
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|!
name|s
operator|->
name|iChild2
operator|||
name|s
operator|<
name|s
operator|->
name|iChild2
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|s
argument_list|,
name|SLABSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aPartialPage
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|iChild1
condition|)
name|size
operator|=
name|SlabHeaderSize
argument_list|(
name|s
operator|->
name|iChild1
operator|->
name|iHeader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|SlabHeaderSize
argument_list|(
name|s
operator|->
name|iHeader
argument_list|)
operator|==
name|size
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|s
argument_list|,
name|SLABSIZE
argument_list|)
expr_stmt|;
block|}
name|parent
operator|=
operator|&
name|s
operator|->
name|iChild1
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|iChild1
expr_stmt|;
block|}
name|parent
operator|=
name|child2
expr_stmt|;
name|s
operator|=
operator|*
name|child2
expr_stmt|;
while|while
condition|(
name|s
condition|)
block|{
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|s
operator|->
name|iParent
operator|==
name|parent
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|s
argument_list|,
name|SLABSIZE
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|!
name|s
operator|->
name|iChild1
operator|||
name|s
operator|<
name|s
operator|->
name|iChild1
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|s
argument_list|,
name|SLABSIZE
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|!
name|s
operator|->
name|iChild2
operator|||
name|s
operator|<
name|s
operator|->
name|iChild2
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|s
argument_list|,
name|SLABSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aPartialPage
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|iChild2
condition|)
name|size
operator|=
name|SlabHeaderSize
argument_list|(
name|s
operator|->
name|iChild2
operator|->
name|iHeader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|SlabHeaderSize
argument_list|(
name|s
operator|->
name|iHeader
argument_list|)
operator|==
name|size
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|s
argument_list|,
name|SLABSIZE
argument_list|)
expr_stmt|;
block|}
name|parent
operator|=
operator|&
name|s
operator|->
name|iChild2
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|iChild2
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|DoCheckSlabTrees
name|void
name|RHybridHeap
operator|::
name|DoCheckSlabTrees
parameter_list|()
block|{
for|for
control|(
name|TInt
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
name|MAXSLABSIZE
operator|>>
literal|2
operator|)
condition|;
operator|++
name|i
control|)
name|DoCheckSlabTree
argument_list|(
operator|&
name|iSlabAlloc
index|[
name|i
index|]
operator|.
name|iPartial
argument_list|,
name|EFalse
argument_list|)
expr_stmt|;
name|DoCheckSlabTree
argument_list|(
operator|&
name|iPartialPage
argument_list|,
name|ETrue
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|DoCheckSlab
name|void
name|RHybridHeap
operator|::
name|DoCheckSlab
parameter_list|(
name|slab
modifier|*
name|aSlab
parameter_list|,
name|TAllocatorType
name|aSlabType
parameter_list|,
name|TAny
modifier|*
name|aBfr
parameter_list|)
block|{
if|if
condition|(
operator|(
name|aSlabType
operator|==
name|ESlabSpare
operator|)
operator|||
operator|(
name|aSlabType
operator|==
name|EEmptySlab
operator|)
condition|)
return|return;
name|unsigned
name|h
init|=
name|aSlab
operator|->
name|iHeader
decl_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|ZEROBITS
argument_list|(
name|h
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|aBfr
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
name|unsigned
name|used
init|=
name|SlabHeaderUsedm4
argument_list|(
name|h
argument_list|)
operator|+
literal|4
decl_stmt|;
name|unsigned
name|size
init|=
name|SlabHeaderSize
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|used
operator|<
name|SLABSIZE
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|aBfr
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|(
name|size
operator|>
literal|3
operator|)
operator|&&
operator|(
name|size
operator|<=
name|MAXSLABSIZE
operator|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|aBfr
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|aSlabType
condition|)
block|{
case|case
name|EFullSlab
case|:
name|count
operator|=
operator|(
name|KMaxSlabPayload
operator|/
name|size
operator|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|used
operator|==
name|count
operator|*
name|size
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|aBfr
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|HeaderFloating
argument_list|(
name|h
argument_list|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|aBfr
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPartialFullSlab
case|:
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|(
name|used
operator|%
name|size
operator|)
operator|==
literal|0
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|aBfr
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
operator|(
name|SlabHeaderFree
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|SlabHeaderFree
argument_list|(
name|h
argument_list|)
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|slabhdr
argument_list|)
operator|)
operator|%
name|SlabHeaderSize
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|)
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|aBfr
argument_list|,
name|aSlab
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|//  Check that committed size in heap equals number of pages in bitmap
end_comment
begin_comment
comment|//  plus size of Doug Lea region
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|DoCheckCommittedSize
name|void
name|RHybridHeap
operator|::
name|DoCheckCommittedSize
parameter_list|(
name|TInt
name|aNPages
parameter_list|,
name|mstate
name|aM
parameter_list|)
block|{
name|TInt
name|total_committed
init|=
operator|(
name|aNPages
operator|*
name|iPageSize
operator|)
operator|+
name|aM
operator|->
name|iSeg
operator|.
name|iSize
operator|+
operator|(
name|iBase
operator|-
operator|(
name|TUint8
operator|*
operator|)
name|this
operator|)
decl_stmt|;
name|__HEAP_CORRUPTED_TEST
argument_list|(
operator|(
name|total_committed
operator|==
name|iChunkSize
operator|)
argument_list|,
name|ETHeapBadCellAddress
argument_list|,
name|total_committed
argument_list|,
name|iChunkSize
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// __KERNEL_MODE__
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* QT_USE_NEW_SYMBIAN_ALLOCATOR */
end_comment
end_unit
