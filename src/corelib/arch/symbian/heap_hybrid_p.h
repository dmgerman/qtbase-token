begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|__HEAP_HYBRID_H__
end_ifndef
begin_define
DECL|macro|__HEAP_HYBRID_H__
define|#
directive|define
name|__HEAP_HYBRID_H__
end_define
begin_include
include|#
directive|include
file|<e32cmn.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|__WINS__
end_ifdef
begin_define
DECL|macro|USE_HYBRID_HEAP
define|#
directive|define
name|USE_HYBRID_HEAP
value|0
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|USE_HYBRID_HEAP
define|#
directive|define
name|USE_HYBRID_HEAP
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// This stuff is all temporary in order to prevent having to include dla.h from heap_hybrid.h, which causes
end_comment
begin_comment
comment|// problems due to its definition of size_t (and possibly other types).  This is unfortunate but we cannot
end_comment
begin_comment
comment|// pollute the namespace with these types or it will cause problems with Open C and other POSIX compatibility
end_comment
begin_comment
comment|// efforts in Symbian
end_comment
begin_define
DECL|macro|NSMALLBINS
define|#
directive|define
name|NSMALLBINS
value|(32U)
end_define
begin_define
DECL|macro|NTREEBINS
define|#
directive|define
name|NTREEBINS
value|(32U)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_ALIGNMENT
end_ifndef
begin_define
DECL|macro|MALLOC_ALIGNMENT
define|#
directive|define
name|MALLOC_ALIGNMENT
value|((TUint)8U)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MALLOC_ALIGNMENT */
end_comment
begin_define
DECL|macro|CHUNK_OVERHEAD
define|#
directive|define
name|CHUNK_OVERHEAD
value|(sizeof(TUint))
end_define
begin_typedef
DECL|typedef|bindex_t
typedef|typedef
name|unsigned
name|int
name|bindex_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|binmap_t
typedef|typedef
name|unsigned
name|int
name|binmap_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|mchunkptr
typedef|typedef
name|struct
name|malloc_chunk
modifier|*
name|mchunkptr
typedef|;
end_typedef
begin_typedef
DECL|typedef|msegment
typedef|typedef
name|struct
name|malloc_segment
name|msegment
typedef|;
end_typedef
begin_typedef
DECL|typedef|mstate
typedef|typedef
name|struct
name|malloc_state
modifier|*
name|mstate
typedef|;
end_typedef
begin_typedef
DECL|typedef|tbinptr
typedef|typedef
name|struct
name|malloc_tree_chunk
modifier|*
name|tbinptr
typedef|;
end_typedef
begin_typedef
DECL|typedef|tchunkptr
typedef|typedef
name|struct
name|malloc_tree_chunk
modifier|*
name|tchunkptr
typedef|;
end_typedef
begin_struct
DECL|struct|malloc_segment
struct|struct
name|malloc_segment
block|{
DECL|member|iBase
name|TUint8
modifier|*
name|iBase
decl_stmt|;
comment|/* base address */
DECL|member|iSize
name|TUint
name|iSize
decl_stmt|;
comment|/* allocated size */
block|}
struct|;
end_struct
begin_struct
DECL|struct|malloc_state
struct|struct
name|malloc_state
block|{
DECL|member|iSmallMap
name|binmap_t
name|iSmallMap
decl_stmt|;
DECL|member|iTreeMap
name|binmap_t
name|iTreeMap
decl_stmt|;
DECL|member|iDvSize
name|TUint
name|iDvSize
decl_stmt|;
DECL|member|iTopSize
name|TUint
name|iTopSize
decl_stmt|;
DECL|member|iDv
name|mchunkptr
name|iDv
decl_stmt|;
DECL|member|iTop
name|mchunkptr
name|iTop
decl_stmt|;
DECL|member|iTrimCheck
name|TUint
name|iTrimCheck
decl_stmt|;
DECL|member|iSmallBins
name|mchunkptr
name|iSmallBins
index|[
operator|(
name|NSMALLBINS
operator|+
literal|1
operator|)
operator|*
literal|2
index|]
decl_stmt|;
DECL|member|iTreeBins
name|tbinptr
name|iTreeBins
index|[
name|NTREEBINS
index|]
decl_stmt|;
DECL|member|iSeg
name|msegment
name|iSeg
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
name|class
name|RHybridHeap
range|:
name|public
name|RHeap
block|{
name|public
operator|:
comment|// declarations copied from Symbian^4 RAllocator and RHeap
typedef|typedef
name|void
argument_list|(
operator|*
name|TWalkFunc
argument_list|)
argument_list|(
name|TAny
operator|*
argument_list|,
name|RHeap
operator|::
name|TCellType
argument_list|,
name|TAny
operator|*
argument_list|,
name|TInt
argument_list|)
expr_stmt|;
block|enum
name|TFlags
block|{
name|ESingleThreaded
operator|=
literal|1
block|,
name|EFixedSize
operator|=
literal|2
block|,
name|ETraceAllocs
operator|=
literal|4
block|,
name|EMonitorMemory
operator|=
literal|8
block|,}
decl_stmt|;
end_decl_stmt
begin_enum
enum|enum
name|TAllocDebugOp
block|{
name|ECount
block|,
name|EMarkStart
block|,
name|EMarkEnd
block|,
name|ECheck
block|,
name|ESetFail
block|,
name|ECopyDebugInfo
block|,
name|ESetBurstFail
block|,
name|EGetFail
block|,
name|EGetSize
init|=
literal|48
block|,
name|EGetMaxLength
block|,
name|EGetBase
block|,
name|EAlignInteger
block|,
name|EAlignAddr
block|}
enum|;
end_enum
begin_enum
enum|enum
name|TDebugOp
block|{
name|EWalk
init|=
literal|128
block|,
name|EHybridHeap
block|}
enum|;
end_enum
begin_enum
enum|enum
name|THybridAllocFail
block|{
name|ERandom
block|,
name|ETrueRandom
block|,
name|EDeterministic
block|,
name|EHybridNone
block|,
name|EFailNext
block|,
name|EReset
block|,
name|EBurstRandom
block|,
name|EBurstTrueRandom
block|,
name|EBurstDeterministic
block|,
name|EBurstFailNext
block|,
name|ECheckFailure
block|, 		}
enum|;
end_enum
begin_enum
enum|enum
block|{
name|EDebugHdrSize
init|=
expr|sizeof
operator|(
name|SDebugCell
operator|)
block|}
enum|;
end_enum
begin_ifndef
ifndef|#
directive|ifndef
name|SYMBIAN_ENABLE_SPLIT_HEADERS
end_ifndef
begin_struct
struct|struct
name|SRAllocatorBurstFail
block|{
name|TInt
name|iBurst
decl_stmt|;
name|TInt
name|iRate
decl_stmt|;
name|TInt
name|iUnused
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_endif
endif|#
directive|endif
end_endif
begin_struct
struct|struct
name|HeapInfo
block|{
name|unsigned
name|iFootprint
decl_stmt|;
name|unsigned
name|iMaxSize
decl_stmt|;
name|unsigned
name|iAllocBytes
decl_stmt|;
name|unsigned
name|iAllocN
decl_stmt|;
name|unsigned
name|iFreeBytes
decl_stmt|;
name|unsigned
name|iFreeN
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
struct|struct
name|SHeapCellInfo
block|{
name|RHybridHeap
modifier|*
name|iHeap
decl_stmt|;
name|TInt
name|iTotalAlloc
decl_stmt|;
name|TInt
name|iTotalAllocSize
decl_stmt|;
name|TInt
name|iTotalFree
decl_stmt|;
name|TInt
name|iLevelAlloc
decl_stmt|;
name|SDebugCell
modifier|*
name|iStranded
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/**     @internalComponent     */
end_comment
begin_enum
enum|enum
name|TAllocatorType
block|{
name|ESlabAllocator
block|,
name|EDougLeaAllocator
block|,
name|EPageAllocator
block|,
name|EFullSlab
init|=
literal|0x80
block|,
name|EPartialFullSlab
init|=
literal|0x40
block|,
name|EEmptySlab
init|=
literal|0x20
block|,
name|ESlabSpare
init|=
literal|0x10
block|,
name|ESlabMask
init|=
literal|0xf0
block|}
enum|;
end_enum
begin_comment
comment|/**     @internalComponent     */
end_comment
begin_struct
struct|struct
name|SWalkInfo
block|{
comment|/** 	                  Walk function address shall be called 	                  */
name|TWalkFunc
name|iFunction
decl_stmt|;
comment|/** 	                  The first parameter for callback function 	                  */
name|TAny
modifier|*
name|iParam
decl_stmt|;
comment|/** 	                  Pointer to RHybridHeap object 	                  */
name|RHybridHeap
modifier|*
name|iHeap
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/**     @internalComponent     */
end_comment
begin_struct
struct|struct
name|SConfig
block|{
comment|/** 	                  Required slab configuration ( bit 0=4, bit 1=8 .. 	                  bit 13 = 56) 	                  */
name|TUint32
name|iSlabBits
decl_stmt|;
comment|/** 	                  Delayed slab threshold in bytes (0 = no threshold) 	                  */
name|TInt
name|iDelayedSlabThreshold
decl_stmt|;
comment|/** 	                  2^n is smallest size allocated in paged allocator (14-31 = 16 Kb --> ) 	                  */
name|TInt
name|iPagePower
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/** 	@internalComponent  	This structure is used by test code for configuring the allocators and obtaining information 	from them in order to ensure they are behaving as required.  This is internal test specific 	code and is liable to be changed without warning at any time.  You should under no circumstances 	be using it! 	*/
end_comment
begin_struct
struct|struct
name|STestCommand
block|{
name|TInt
name|iCommand
decl_stmt|;
comment|// The test related command to be executed
union|union
block|{
name|SConfig
name|iConfig
decl_stmt|;
comment|// Configuration used by test code only
name|TAny
modifier|*
name|iData
decl_stmt|;
comment|// Extra supporting data for the test command
block|}
union|;
block|}
struct|;
end_struct
begin_comment
comment|/** 	@internalComponent  	Commands used by test code for configuring the allocators and obtaining information them them 	*/
end_comment
begin_enum
enum|enum
name|TTestCommand
block|{
name|EGetConfig
block|,
name|ESetConfig
block|,
name|EHeapMetaData
block|,
name|ETestData
block|}
enum|;
end_enum
begin_function_decl
name|virtual
name|TAny
modifier|*
name|Alloc
parameter_list|(
name|TInt
name|aSize
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|virtual
name|void
name|Free
parameter_list|(
name|TAny
modifier|*
name|aPtr
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|virtual
name|TAny
modifier|*
name|ReAlloc
parameter_list|(
name|TAny
modifier|*
name|aPtr
parameter_list|,
name|TInt
name|aSize
parameter_list|,
name|TInt
name|aMode
init|=
literal|0
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
name|virtual
name|TInt
name|AllocLen
argument_list|(
specifier|const
name|TAny
operator|*
name|aCell
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
end_ifndef
begin_function_decl
name|virtual
name|TInt
name|Compress
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
name|virtual
name|void
name|Reset
parameter_list|()
function_decl|;
end_function_decl
begin_decl_stmt
name|virtual
name|TInt
name|AllocSize
argument_list|(
name|TInt
operator|&
name|aTotalAllocSize
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|virtual
name|TInt
name|Available
argument_list|(
name|TInt
operator|&
name|aBiggestBlock
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|virtual
name|TInt
name|DebugFunction
parameter_list|(
name|TInt
name|aFunc
parameter_list|,
name|TAny
modifier|*
name|a1
init|=
name|NULL
parameter_list|,
name|TAny
modifier|*
name|a2
init|=
name|NULL
parameter_list|)
function_decl|;
end_function_decl
begin_label
name|protected
label|:
end_label
begin_function_decl
name|virtual
name|TInt
name|Extension_
parameter_list|(
name|TUint
name|aExtensionId
parameter_list|,
name|TAny
modifier|*
modifier|&
name|a0
parameter_list|,
name|TAny
modifier|*
name|a1
parameter_list|)
function_decl|;
end_function_decl
begin_label
name|public
label|:
end_label
begin_decl_stmt
name|TAny
modifier|*
name|operator
name|new
argument_list|(
name|TUint
name|aSize
argument_list|,
name|TAny
operator|*
name|aBase
argument_list|)
name|__NO_THROW
decl_stmt|;
end_decl_stmt
begin_function_decl
name|void
name|operator
name|delete
parameter_list|(
name|TAny
modifier|*
parameter_list|,
name|TAny
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_label
name|private
label|:
end_label
begin_function_decl
name|TInt
name|DoCountAllocFree
parameter_list|(
name|TInt
modifier|&
name|aFree
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|TInt
name|DoCheckHeap
parameter_list|(
name|SCheckInfo
modifier|*
name|aInfo
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoMarkStart
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
name|TUint32
name|DoMarkEnd
parameter_list|(
name|TInt
name|aExpected
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoSetAllocFail
parameter_list|(
name|TAllocFail
name|aType
parameter_list|,
name|TInt
name|aRate
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|TBool
name|CheckForSimulatedAllocFail
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoSetAllocFail
parameter_list|(
name|TAllocFail
name|aType
parameter_list|,
name|TInt
name|aRate
parameter_list|,
name|TUint
name|aBurst
parameter_list|)
function_decl|;
end_function_decl
begin_expr_stmt
name|void
name|Lock
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|void
name|Unlock
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt
begin_function_decl
name|TInt
name|ChunkHandle
parameter_list|()
function_decl|const;
end_function_decl
begin_macro
name|RHybridHeap
argument_list|(
argument|TInt aChunkHandle
argument_list|,
argument|TInt aOffset
argument_list|,
argument|TInt aMinLength
argument_list|,
argument|TInt aMaxLength
argument_list|,
argument|TInt aGrowBy
argument_list|,
argument|TInt aAlign
argument_list|,
argument|TBool aSingleThread
argument_list|,
argument|TBool aDlOnly
argument_list|,
argument|TBool aUseAdjust
argument_list|)
end_macro
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_macro
name|RHybridHeap
argument_list|(
argument|TInt aMaxLength
argument_list|,
argument|TInt aAlign=
literal|0
argument_list|,
argument|TBool aSingleThread=ETrue
argument_list|)
end_macro
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|RHybridHeap
argument_list|()
expr_stmt|;
end_expr_stmt
begin_function_decl
name|void
name|Init
parameter_list|(
name|TInt
name|aBitmapSlab
parameter_list|,
name|TInt
name|aPagePower
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|inline
name|void
name|InitBins
parameter_list|(
name|mstate
name|m
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|inline
name|void
name|InitTop
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|,
name|TUint
name|psize
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|SysAlloc
parameter_list|(
name|mstate
name|m
parameter_list|,
name|TUint
name|nb
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|SysTrim
parameter_list|(
name|mstate
name|m
parameter_list|,
name|TUint
name|pad
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|TmallocLarge
parameter_list|(
name|mstate
name|m
parameter_list|,
name|TUint
name|nb
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|TmallocSmall
parameter_list|(
name|mstate
name|m
parameter_list|,
name|TUint
name|nb
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*MACROS converted functions*/
end_comment
begin_function_decl
specifier|static
specifier|inline
name|void
name|UnlinkFirstSmallChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|mchunkptr
name|B
parameter_list|,
name|mchunkptr
name|P
parameter_list|,
name|bindex_t
modifier|&
name|I
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|void
name|InsertSmallChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|mchunkptr
name|P
parameter_list|,
name|TUint
name|S
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|void
name|InsertChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|mchunkptr
name|P
parameter_list|,
name|TUint
name|S
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|void
name|UnlinkLargeChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|tchunkptr
name|X
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|void
name|UnlinkSmallChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|mchunkptr
name|P
parameter_list|,
name|TUint
name|S
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|void
name|UnlinkChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|mchunkptr
name|P
parameter_list|,
name|TUint
name|S
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|void
name|ComputeTreeIndex
parameter_list|(
name|TUint
name|S
parameter_list|,
name|bindex_t
modifier|&
name|I
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|void
name|InsertLargeChunk
parameter_list|(
name|mstate
name|M
parameter_list|,
name|tchunkptr
name|X
parameter_list|,
name|TUint
name|S
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|void
name|ReplaceDv
parameter_list|(
name|mstate
name|M
parameter_list|,
name|mchunkptr
name|P
parameter_list|,
name|TUint
name|S
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
specifier|inline
name|void
name|ComputeBit2idx
parameter_list|(
name|binmap_t
name|X
parameter_list|,
name|bindex_t
modifier|&
name|I
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoComputeTreeIndex
parameter_list|(
name|TUint
name|S
parameter_list|,
name|bindex_t
modifier|&
name|I
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoCheckAnyChunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoCheckTopChunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoCheckInuseChunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoCheckFreeChunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|p
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoCheckMallocedChunk
parameter_list|(
name|mstate
name|m
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|TUint
name|s
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoCheckTree
parameter_list|(
name|mstate
name|m
parameter_list|,
name|tchunkptr
name|t
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoCheckTreebin
parameter_list|(
name|mstate
name|m
parameter_list|,
name|bindex_t
name|i
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoCheckSmallbin
parameter_list|(
name|mstate
name|m
parameter_list|,
name|bindex_t
name|i
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|TInt
name|BinFind
parameter_list|(
name|mstate
name|m
parameter_list|,
name|mchunkptr
name|x
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|TUint
name|TraverseAndCheck
parameter_list|(
name|mstate
name|m
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoCheckMallocState
parameter_list|(
name|mstate
name|m
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
name|TInt
name|GetInfo
argument_list|(
expr|struct
name|HeapInfo
operator|*
name|i
argument_list|,
name|SWalkInfo
operator|*
name|wi
operator|=
name|NULL
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt
begin_function_decl
name|void
name|InitDlMalloc
parameter_list|(
name|TUint
name|capacity
parameter_list|,
name|int
name|locked
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|DlMalloc
parameter_list|(
name|TUint
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DlFree
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|DlRealloc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|TUint
parameter_list|,
name|TInt
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
name|TUint
name|DlInfo
argument_list|(
expr|struct
name|HeapInfo
operator|*
name|i
argument_list|,
name|SWalkInfo
operator|*
name|wi
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt
begin_function_decl
name|void
name|DoCheckCommittedSize
parameter_list|(
name|TInt
name|aNPages
parameter_list|,
name|mstate
name|aM
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|TAny
modifier|*
name|ReAllocImpl
parameter_list|(
name|TAny
modifier|*
name|aPtr
parameter_list|,
name|TInt
name|aSize
parameter_list|,
name|TInt
name|aMode
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|Construct
parameter_list|(
name|TBool
name|aSingleThread
parameter_list|,
name|TBool
name|aDLOnly
parameter_list|,
name|TBool
name|aUseAdjust
parameter_list|,
name|TInt
name|aAlign
parameter_list|)
function_decl|;
end_function_decl
begin_ifndef
ifndef|#
directive|ifndef
name|__KERNEL_MODE__
end_ifndef
begin_function_decl
name|TInt
name|ConstructLock
parameter_list|(
name|TUint32
name|aMode
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|static
name|void
name|Walk
parameter_list|(
name|SWalkInfo
modifier|*
name|aInfo
parameter_list|,
name|TAny
modifier|*
name|aBfr
parameter_list|,
name|TInt
name|aLth
parameter_list|,
name|TCellType
name|aBfrType
parameter_list|,
name|TAllocatorType
name|aAlloctorType
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|WalkCheckCell
parameter_list|(
name|TAny
modifier|*
name|aPtr
parameter_list|,
name|TCellType
name|aType
parameter_list|,
name|TAny
modifier|*
name|aCell
parameter_list|,
name|TInt
name|aLen
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|Map
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|TInt
name|sz
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|Unmap
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|TInt
name|sz
parameter_list|)
function_decl|;
end_function_decl
begin_label
name|private
label|:
end_label
begin_decl_stmt
name|TInt
name|iMinLength
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TInt
name|iOffset
decl_stmt|;
end_decl_stmt
begin_comment
comment|// offset of RHeap object from chunk base
end_comment
begin_decl_stmt
name|TInt
name|iGrowBy
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TInt
name|iMinCell
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TInt
name|iPageSize
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Temporarily commented out and exported from RHeap to prevent source breaks from req417-52840.
end_comment
begin_comment
comment|// This will be moved with another REQ after submission and subsequent fixing of bad code
end_comment
begin_comment
comment|//TInt iNestingLevel;
end_comment
begin_decl_stmt
name|TInt
name|iAllocCount
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Temporarily commented out.  See comment above regarding req417-52840 source breaks
end_comment
begin_comment
comment|//TAllocFail iFailType;
end_comment
begin_decl_stmt
name|TInt
name|iFailRate
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TBool
name|iFailed
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TInt
name|iFailAllocCount
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TInt
name|iRand
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Temporarily commented out.  See comment above regarding req417-52840 source breaks
end_comment
begin_comment
comment|//TAny* iTestData;
end_comment
begin_decl_stmt
name|TInt
name|iChunkSize
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TInt
name|iHighWaterMark
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TBool
name|iUseAdjust
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|TBool
name|iDLOnly
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|malloc_state
name|iGlobalMallocState
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|__KERNEL_MODE__
end_ifdef
begin_decl_stmt
name|friend
name|class
name|RHeapK
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
name|friend
name|class
name|UserHeap
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|friend
name|class
name|HybridHeap
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|friend
name|class
name|TestHybridHeap
decl_stmt|;
end_decl_stmt
begin_label
name|private
label|:
end_label
begin_function_decl
specifier|static
name|void
name|TreeRemove
parameter_list|(
name|slab
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|TreeInsert
parameter_list|(
name|slab
modifier|*
name|s
parameter_list|,
name|slab
modifier|*
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl
begin_enum
enum|enum
block|{
name|EOkBits
init|=
operator|(
literal|1
operator|<<
operator|(
name|MAXSLABSIZE
operator|>>
literal|2
operator|)
operator|)
operator|-
literal|1
block|}
enum|;
end_enum
begin_function_decl
name|void
name|SlabInit
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
name|void
name|SlabConfig
parameter_list|(
name|unsigned
name|slabbitmap
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|SlabAllocate
parameter_list|(
name|slabset
modifier|&
name|allocator
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|SlabFree
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|AllocNewSlab
parameter_list|(
name|slabset
modifier|&
name|allocator
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|AllocNewPage
parameter_list|(
name|slabset
modifier|&
name|allocator
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|InitNewSlab
parameter_list|(
name|slabset
modifier|&
name|allocator
parameter_list|,
name|slab
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|FreeSlab
parameter_list|(
name|slab
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|FreePage
parameter_list|(
name|page
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
name|void
name|SlabInfo
argument_list|(
expr|struct
name|HeapInfo
operator|*
name|i
argument_list|,
name|SWalkInfo
operator|*
name|wi
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|void
name|SlabFullInfo
parameter_list|(
name|slab
modifier|*
name|s
parameter_list|,
name|struct
name|HeapInfo
modifier|*
name|i
parameter_list|,
name|SWalkInfo
modifier|*
name|wi
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|SlabPartialInfo
parameter_list|(
name|slab
modifier|*
name|s
parameter_list|,
name|struct
name|HeapInfo
modifier|*
name|i
parameter_list|,
name|SWalkInfo
modifier|*
name|wi
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|SlabEmptyInfo
parameter_list|(
name|slab
modifier|*
name|s
parameter_list|,
name|struct
name|HeapInfo
modifier|*
name|i
parameter_list|,
name|SWalkInfo
modifier|*
name|wi
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|TreeWalk
parameter_list|(
name|slab
modifier|*
specifier|const
modifier|*
name|root
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|slab
modifier|*
parameter_list|,
name|struct
name|HeapInfo
modifier|*
parameter_list|,
name|SWalkInfo
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|HeapInfo
modifier|*
name|i
parameter_list|,
name|SWalkInfo
modifier|*
name|wi
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|WalkPartialFullSlab
parameter_list|(
name|SWalkInfo
modifier|*
name|aInfo
parameter_list|,
name|slab
modifier|*
name|aSlab
parameter_list|,
name|TCellType
name|aBfrType
parameter_list|,
name|TInt
name|aLth
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|WalkFullSlab
parameter_list|(
name|SWalkInfo
modifier|*
name|aInfo
parameter_list|,
name|slab
modifier|*
name|aSlab
parameter_list|,
name|TCellType
name|aBfrType
parameter_list|,
name|TInt
name|aLth
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoCheckSlab
parameter_list|(
name|slab
modifier|*
name|aSlab
parameter_list|,
name|TAllocatorType
name|aSlabType
parameter_list|,
name|TAny
modifier|*
name|aBfr
init|=
name|NULL
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoCheckSlabTrees
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
name|void
name|DoCheckSlabTree
parameter_list|(
name|slab
modifier|*
modifier|*
name|aS
parameter_list|,
name|TBool
name|aPartialPage
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|BuildPartialSlabBitmap
parameter_list|(
name|TUint32
modifier|*
name|aBitmap
parameter_list|,
name|slab
modifier|*
name|aSlab
parameter_list|,
name|TAny
modifier|*
name|aBfr
init|=
name|NULL
parameter_list|)
function_decl|;
end_function_decl
begin_function
specifier|static
specifier|inline
name|unsigned
name|SlabHeaderFree
parameter_list|(
name|unsigned
name|h
parameter_list|)
block|{
return|return
operator|(
name|h
operator|&
literal|0x000000ff
operator|)
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|unsigned
name|SlabHeaderPagemap
parameter_list|(
name|unsigned
name|h
parameter_list|)
block|{
return|return
operator|(
name|h
operator|&
literal|0x00000f00
operator|)
operator|>>
literal|8
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|unsigned
name|SlabHeaderSize
parameter_list|(
name|unsigned
name|h
parameter_list|)
block|{
return|return
operator|(
name|h
operator|&
literal|0x0003f000
operator|)
operator|>>
literal|12
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|unsigned
name|SlabHeaderUsedm4
parameter_list|(
name|unsigned
name|h
parameter_list|)
block|{
return|return
operator|(
name|h
operator|&
literal|0x0ffc0000
operator|)
operator|>>
literal|18
return|;
block|}
end_function
begin_comment
comment|/***paged allocator code***/
end_comment
begin_function_decl
name|void
name|PagedInit
parameter_list|(
name|TInt
name|aPagePower
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|PagedAllocate
parameter_list|(
name|unsigned
name|size
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|PagedFree
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
modifier|*
name|PagedReallocate
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|unsigned
name|size
parameter_list|,
name|TInt
name|mode
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|bool
name|PagedEncode
parameter_list|(
name|unsigned
name|pos
parameter_list|,
name|unsigned
name|npage
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
name|unsigned
name|PagedDecode
argument_list|(
name|unsigned
name|pos
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|inline
name|unsigned
name|PagedSize
argument_list|(
name|void
operator|*
name|p
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|inline
name|bool
name|PagedSetSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|unsigned
name|size
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|inline
name|void
name|PagedZapSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|unsigned
name|size
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
specifier|inline
name|void
modifier|*
name|Bitmap2addr
argument_list|(
name|unsigned
name|pos
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|void
name|PagedInfo
argument_list|(
expr|struct
name|HeapInfo
operator|*
name|i
argument_list|,
name|SWalkInfo
operator|*
name|wi
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt
begin_function_decl
name|void
name|ResetBitmap
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
name|TBool
name|CheckBitmap
parameter_list|(
name|void
modifier|*
name|aBfr
parameter_list|,
name|TInt
name|aSize
parameter_list|,
name|TUint32
modifier|&
name|aDummy
parameter_list|,
name|TInt
modifier|&
name|aNPages
parameter_list|)
function_decl|;
end_function_decl
begin_label
name|private
label|:
end_label
begin_decl_stmt
name|paged_bitmap
name|iPageMap
decl_stmt|;
end_decl_stmt
begin_comment
comment|// bitmap representing page allocator's pages
end_comment
begin_decl_stmt
name|TUint8
modifier|*
name|iMemBase
decl_stmt|;
end_decl_stmt
begin_comment
comment|// bottom of paged/slab memory (chunk base)
end_comment
begin_expr_stmt
name|TUint8
name|iBitMapBuffer
index|[
name|MAXSMALLPAGEBITS
operator|>>
literal|3
index|]
expr_stmt|;
end_expr_stmt
begin_comment
comment|// buffer for initial page bitmap
end_comment
begin_decl_stmt
name|TInt
name|iSlabThreshold
decl_stmt|;
end_decl_stmt
begin_comment
comment|// allocations< than this are done by the slab allocator
end_comment
begin_decl_stmt
name|TInt
name|iPageThreshold
decl_stmt|;
end_decl_stmt
begin_comment
comment|// 2^n is smallest cell size allocated in paged allocator
end_comment
begin_decl_stmt
name|TInt
name|iSlabInitThreshold
decl_stmt|;
end_decl_stmt
begin_comment
comment|// slab allocator will be used after chunk reaches this size
end_comment
begin_decl_stmt
name|TUint32
name|iSlabConfigBits
decl_stmt|;
end_decl_stmt
begin_comment
comment|// set of bits that specify which slab sizes to use
end_comment
begin_decl_stmt
name|slab
modifier|*
name|iPartialPage
decl_stmt|;
end_decl_stmt
begin_comment
comment|// partial-use page tree
end_comment
begin_decl_stmt
name|slab
modifier|*
name|iFullSlab
decl_stmt|;
end_decl_stmt
begin_comment
comment|// full slabs list (so we can find them when walking)
end_comment
begin_decl_stmt
name|page
modifier|*
name|iSparePage
decl_stmt|;
end_decl_stmt
begin_comment
comment|// cached, to avoid kernel exec calls for unmapping/remapping
end_comment
begin_expr_stmt
name|TUint8
name|iSizeMap
index|[
operator|(
name|MAXSLABSIZE
operator|>>
literal|2
operator|)
operator|+
literal|1
index|]
expr_stmt|;
end_expr_stmt
begin_comment
comment|// index of slabset indexes based on size class
end_comment
begin_expr_stmt
name|slabset
name|iSlabAlloc
index|[
name|MAXSLABSIZE
operator|>>
literal|2
index|]
expr_stmt|;
end_expr_stmt
begin_comment
comment|// array of pointers to slabsets
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// __KERNEL_MODE__
end_comment
begin_define
DECL|macro|HEAP_ASSERT
unit|};
define|#
directive|define
name|HEAP_ASSERT
parameter_list|(
name|x
parameter_list|)
value|__ASSERT_DEBUG(x, HEAP_PANIC(ETHeapBadCellAddress))
end_define
begin_expr_stmt
DECL|function|Floor
name|template
operator|<
name|class
name|T
operator|>
specifier|inline
name|T
name|Floor
argument_list|(
argument|const T addr
argument_list|,
argument|unsigned aln
argument_list|)
block|{
return|return
name|T
argument_list|(
operator|(
name|unsigned
argument_list|(
name|addr
argument_list|)
operator|)
operator|&
operator|~
operator|(
name|aln
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|Ceiling
name|template
operator|<
name|class
name|T
operator|>
specifier|inline
name|T
name|Ceiling
argument_list|(
argument|T addr
argument_list|,
argument|unsigned aln
argument_list|)
block|{
return|return
name|T
argument_list|(
operator|(
name|unsigned
argument_list|(
name|addr
argument_list|)
operator|+
operator|(
name|aln
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|aln
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|LowBits
name|template
operator|<
name|class
name|T
operator|>
specifier|inline
name|unsigned
name|LowBits
argument_list|(
argument|T addr
argument_list|,
argument|unsigned aln
argument_list|)
block|{
return|return
name|unsigned
argument_list|(
name|addr
argument_list|)
operator|&
operator|(
name|aln
operator|-
literal|1
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|variable|T1
DECL|function|PtrDiff
name|template
operator|<
name|class
name|T1
operator|,
name|class
name|T2
operator|>
specifier|inline
name|int
name|PtrDiff
argument_list|(
argument|const T1* a1
argument_list|,
argument|const T2* a2
argument_list|)
block|{
return|return
name|reinterpret_cast
operator|<
specifier|const
name|unsigned
name|char
operator|*
operator|>
operator|(
name|a1
operator|)
operator|-
name|reinterpret_cast
operator|<
specifier|const
name|unsigned
name|char
operator|*
operator|>
operator|(
name|a2
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|Offset
name|template
operator|<
name|class
name|T
operator|>
specifier|inline
name|T
name|Offset
argument_list|(
argument|T addr
argument_list|,
argument|unsigned ofs
argument_list|)
block|{
return|return
name|T
argument_list|(
name|unsigned
argument_list|(
name|addr
argument_list|)
operator|+
name|ofs
argument_list|)
return|;
block|}
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//__HEAP_HYBRID_H__
end_comment
end_unit
