begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|__DLA__
end_ifndef
begin_define
DECL|macro|__DLA__
define|#
directive|define
name|__DLA__
end_define
begin_define
DECL|macro|DEFAULT_TRIM_THRESHOLD
define|#
directive|define
name|DEFAULT_TRIM_THRESHOLD
value|((size_t)4U * (size_t)1024U)
end_define
begin_define
DECL|macro|MSPACES
define|#
directive|define
name|MSPACES
value|0
end_define
begin_define
DECL|macro|HAVE_MORECORE
define|#
directive|define
name|HAVE_MORECORE
value|1
end_define
begin_define
DECL|macro|MORECORE_CONTIGUOUS
define|#
directive|define
name|MORECORE_CONTIGUOUS
value|1
end_define
begin_define
DECL|macro|HAVE_MMAP
define|#
directive|define
name|HAVE_MMAP
value|0
end_define
begin_define
DECL|macro|HAVE_MREMAP
define|#
directive|define
name|HAVE_MREMAP
value|0
end_define
begin_define
DECL|macro|DEFAULT_GRANULARITY
define|#
directive|define
name|DEFAULT_GRANULARITY
value|(4096U)
end_define
begin_define
DECL|macro|FOOTERS
define|#
directive|define
name|FOOTERS
value|0
end_define
begin_define
DECL|macro|USE_LOCKS
define|#
directive|define
name|USE_LOCKS
value|0
end_define
begin_define
DECL|macro|INSECURE
define|#
directive|define
name|INSECURE
value|1
end_define
begin_define
DECL|macro|NO_MALLINFO
define|#
directive|define
name|NO_MALLINFO
value|0
end_define
begin_define
DECL|macro|LACKS_SYS_TYPES_H
define|#
directive|define
name|LACKS_SYS_TYPES_H
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_SYS_TYPES_H
end_ifndef
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_comment
comment|/* For size_t */
end_comment
begin_else
else|#
directive|else
end_else
begin_ifndef
ifndef|#
directive|ifndef
name|_SIZE_T_DECLARED
end_ifndef
begin_typedef
DECL|typedef|size_t
typedef|typedef
name|unsigned
name|int
name|size_t
typedef|;
end_typedef
begin_define
DECL|macro|_SIZE_T_DECLARED
define|#
directive|define
name|_SIZE_T_DECLARED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_SYS_TYPES_H */
end_comment
begin_comment
comment|/* The maximum possible size_t value has all bits set */
end_comment
begin_define
DECL|macro|MAX_SIZE_T
define|#
directive|define
name|MAX_SIZE_T
value|(~(size_t)0)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|ONLY_MSPACES
end_ifndef
begin_define
DECL|macro|ONLY_MSPACES
define|#
directive|define
name|ONLY_MSPACES
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MSPACES
end_ifndef
begin_if
if|#
directive|if
name|ONLY_MSPACES
end_if
begin_define
DECL|macro|MSPACES
define|#
directive|define
name|MSPACES
value|1
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_define
DECL|macro|MSPACES
define|#
directive|define
name|MSPACES
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MSPACES */
end_comment
begin_comment
comment|//#ifndef MALLOC_ALIGNMENT
end_comment
begin_comment
comment|//	#define MALLOC_ALIGNMENT ((size_t)8U)
end_comment
begin_comment
comment|//#endif  /* MALLOC_ALIGNMENT */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FOOTERS
end_ifndef
begin_define
DECL|macro|FOOTERS
define|#
directive|define
name|FOOTERS
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FOOTERS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|ABORT
end_ifndef
begin_comment
comment|//	#define ABORT  abort()
end_comment
begin_comment
comment|//	#define ABORT  User::Invariant()// redefined so euser isn't dependant on oe
end_comment
begin_define
DECL|macro|ABORT
define|#
directive|define
name|ABORT
value|HEAP_PANIC(ETHeapBadCellAddress)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ABORT */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PROCEED_ON_ERROR
end_ifndef
begin_define
DECL|macro|PROCEED_ON_ERROR
define|#
directive|define
name|PROCEED_ON_ERROR
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PROCEED_ON_ERROR */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USE_LOCKS
end_ifndef
begin_define
DECL|macro|USE_LOCKS
define|#
directive|define
name|USE_LOCKS
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|INSECURE
end_ifndef
begin_define
DECL|macro|INSECURE
define|#
directive|define
name|INSECURE
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* INSECURE */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MMAP
end_ifndef
begin_define
DECL|macro|HAVE_MMAP
define|#
directive|define
name|HAVE_MMAP
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MMAP */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MMAP_CLEARS
end_ifndef
begin_define
DECL|macro|MMAP_CLEARS
define|#
directive|define
name|MMAP_CLEARS
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MMAP_CLEARS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MREMAP
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef
begin_define
DECL|macro|HAVE_MREMAP
define|#
directive|define
name|HAVE_MREMAP
value|1
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* linux */
end_comment
begin_define
DECL|macro|HAVE_MREMAP
define|#
directive|define
name|HAVE_MREMAP
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* linux */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MREMAP */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_FAILURE_ACTION
end_ifndef
begin_comment
comment|//#define MALLOC_FAILURE_ACTION  errno = ENOMEM;
end_comment
begin_define
DECL|macro|MALLOC_FAILURE_ACTION
define|#
directive|define
name|MALLOC_FAILURE_ACTION
value|;
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MALLOC_FAILURE_ACTION */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MORECORE
end_ifndef
begin_if
if|#
directive|if
name|ONLY_MSPACES
end_if
begin_define
DECL|macro|HAVE_MORECORE
define|#
directive|define
name|HAVE_MORECORE
value|1
end_define
begin_comment
DECL|macro|HAVE_MORECORE
comment|/*AMOD: has changed */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_define
DECL|macro|HAVE_MORECORE
define|#
directive|define
name|HAVE_MORECORE
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_if
if|#
directive|if
operator|!
name|HAVE_MORECORE
end_if
begin_define
DECL|macro|MORECORE_CONTIGUOUS
define|#
directive|define
name|MORECORE_CONTIGUOUS
value|0
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !HAVE_MORECORE */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MORECORE
end_ifndef
begin_define
DECL|macro|MORECORE
define|#
directive|define
name|MORECORE
value|DLAdjust
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MORECORE */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MORECORE_CONTIGUOUS
end_ifndef
begin_define
DECL|macro|MORECORE_CONTIGUOUS
define|#
directive|define
name|MORECORE_CONTIGUOUS
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MORECORE_CONTIGUOUS */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !HAVE_MORECORE */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_GRANULARITY
end_ifndef
begin_if
if|#
directive|if
name|MORECORE_CONTIGUOUS
end_if
begin_define
DECL|macro|DEFAULT_GRANULARITY
define|#
directive|define
name|DEFAULT_GRANULARITY
value|4096
end_define
begin_comment
DECL|macro|DEFAULT_GRANULARITY
comment|/* 0 means to compute in init_mparams */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* MORECORE_CONTIGUOUS */
end_comment
begin_define
DECL|macro|DEFAULT_GRANULARITY
define|#
directive|define
name|DEFAULT_GRANULARITY
value|((size_t)64U * (size_t)1024U)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MORECORE_CONTIGUOUS */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DEFAULT_GRANULARITY */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_TRIM_THRESHOLD
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|MORECORE_CANNOT_TRIM
end_ifndef
begin_define
DECL|macro|DEFAULT_TRIM_THRESHOLD
define|#
directive|define
name|DEFAULT_TRIM_THRESHOLD
value|((size_t)2U * (size_t)1024U * (size_t)1024U)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* MORECORE_CANNOT_TRIM */
end_comment
begin_define
DECL|macro|DEFAULT_TRIM_THRESHOLD
define|#
directive|define
name|DEFAULT_TRIM_THRESHOLD
value|MAX_SIZE_T
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MORECORE_CANNOT_TRIM */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DEFAULT_TRIM_THRESHOLD */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_MMAP_THRESHOLD
end_ifndef
begin_if
if|#
directive|if
name|HAVE_MMAP
end_if
begin_define
DECL|macro|DEFAULT_MMAP_THRESHOLD
define|#
directive|define
name|DEFAULT_MMAP_THRESHOLD
value|((size_t)256U * (size_t)1024U)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* HAVE_MMAP */
end_comment
begin_define
DECL|macro|DEFAULT_MMAP_THRESHOLD
define|#
directive|define
name|DEFAULT_MMAP_THRESHOLD
value|MAX_SIZE_T
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MMAP */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DEFAULT_MMAP_THRESHOLD */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USE_BUILTIN_FFS
end_ifndef
begin_define
DECL|macro|USE_BUILTIN_FFS
define|#
directive|define
name|USE_BUILTIN_FFS
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_BUILTIN_FFS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USE_DEV_RANDOM
end_ifndef
begin_define
DECL|macro|USE_DEV_RANDOM
define|#
directive|define
name|USE_DEV_RANDOM
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_DEV_RANDOM */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|NO_MALLINFO
end_ifndef
begin_define
DECL|macro|NO_MALLINFO
define|#
directive|define
name|NO_MALLINFO
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* NO_MALLINFO */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MALLINFO_FIELD_TYPE
end_ifndef
begin_define
DECL|macro|MALLINFO_FIELD_TYPE
define|#
directive|define
name|MALLINFO_FIELD_TYPE
value|size_t
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MALLINFO_FIELD_TYPE */
end_comment
begin_comment
comment|/*   mallopt tuning options.  SVID/XPG defines four standard parameter   numbers for mallopt, normally defined in malloc.h.  None of these   are used in this malloc, so setting them has no effect. But this   malloc does support the following options. */
end_comment
begin_define
DECL|macro|M_TRIM_THRESHOLD
define|#
directive|define
name|M_TRIM_THRESHOLD
value|(-1)
end_define
begin_define
DECL|macro|M_GRANULARITY
define|#
directive|define
name|M_GRANULARITY
value|(-2)
end_define
begin_define
DECL|macro|M_MMAP_THRESHOLD
define|#
directive|define
name|M_MMAP_THRESHOLD
value|(-3)
end_define
begin_if
if|#
directive|if
operator|!
name|NO_MALLINFO
end_if
begin_comment
comment|/*   This version of malloc supports the standard SVID/XPG mallinfo   routine that returns a struct containing usage properties and   statistics. It should work on any system that has a   /usr/include/malloc.h defining struct mallinfo.  The main   declaration needed is the mallinfo struct that is returned (by-copy)   by mallinfo().  The malloinfo struct contains a bunch of fields that   are not even meaningful in this version of malloc.  These fields are   are instead filled by mallinfo() with other numbers that might be of   interest.    HAVE_USR_INCLUDE_MALLOC_H should be set if you have a   /usr/include/malloc.h file that includes a declaration of struct   mallinfo.  If so, it is included; else a compliant version is   declared below.  These must be precisely the same for mallinfo() to   work.  The original SVID version of this struct, defined on most   systems with mallinfo, declares all fields as ints. But some others   define as unsigned long. If your system defines the fields using a   type of different width than listed here, you MUST #include your   system version and #define HAVE_USR_INCLUDE_MALLOC_H. */
end_comment
begin_comment
comment|/* #define HAVE_USR_INCLUDE_MALLOC_H */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_USR_INCLUDE_MALLOC_H
end_ifdef
begin_include
include|#
directive|include
file|"/usr/include/malloc.h"
end_include
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* HAVE_USR_INCLUDE_MALLOC_H */
end_comment
begin_struct
DECL|struct|mallinfo
struct|struct
name|mallinfo
block|{
DECL|member|iArena
name|MALLINFO_FIELD_TYPE
name|iArena
decl_stmt|;
comment|/* non-mmapped space allocated from system */
DECL|member|iOrdblks
name|MALLINFO_FIELD_TYPE
name|iOrdblks
decl_stmt|;
comment|/* number of free chunks */
DECL|member|iSmblks
name|MALLINFO_FIELD_TYPE
name|iSmblks
decl_stmt|;
comment|/* always 0 */
DECL|member|iHblks
name|MALLINFO_FIELD_TYPE
name|iHblks
decl_stmt|;
comment|/* always 0 */
DECL|member|iHblkhd
name|MALLINFO_FIELD_TYPE
name|iHblkhd
decl_stmt|;
comment|/* space in mmapped regions */
DECL|member|iUsmblks
name|MALLINFO_FIELD_TYPE
name|iUsmblks
decl_stmt|;
comment|/* maximum total allocated space */
DECL|member|iFsmblks
name|MALLINFO_FIELD_TYPE
name|iFsmblks
decl_stmt|;
comment|/* always 0 */
DECL|member|iUordblks
name|MALLINFO_FIELD_TYPE
name|iUordblks
decl_stmt|;
comment|/* total allocated space */
DECL|member|iFordblks
name|MALLINFO_FIELD_TYPE
name|iFordblks
decl_stmt|;
comment|/* total free space */
DECL|member|iKeepcost
name|MALLINFO_FIELD_TYPE
name|iKeepcost
decl_stmt|;
comment|/* releasable (via malloc_trim) space */
DECL|member|iCellCount
name|MALLINFO_FIELD_TYPE
name|iCellCount
decl_stmt|;
comment|/* Number of chunks allocated*/
block|}
struct|;
end_struct
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_USR_INCLUDE_MALLOC_H */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* NO_MALLINFO */
end_comment
begin_if
if|#
directive|if
name|MSPACES
end_if
begin_typedef
DECL|typedef|mspace
typedef|typedef
name|void
modifier|*
name|mspace
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MSPACES */
end_comment
begin_if
if|#
directive|if
literal|0
end_if
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_comment
comment|/* for printing in malloc_stats */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_ERRNO_H
end_ifndef
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_comment
comment|/* for MALLOC_FAILURE_ACTION */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_ERRNO_H */
end_comment
begin_if
if|#
directive|if
name|FOOTERS
end_if
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_comment
comment|/* for iMagic initialization */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FOOTERS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_STDLIB_H
end_ifndef
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_comment
comment|/* for abort() */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_STDLIB_H */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ASSERT
argument_list|)
end_if
begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|x
parameter_list|)
value|__ASSERT_DEBUG(x, HEAP_PANIC(ETHeapBadCellAddress))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_STRING_H
end_ifndef
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|/* for memset etc */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_STRING_H */
end_comment
begin_if
if|#
directive|if
name|USE_BUILTIN_FFS
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_STRINGS_H
end_ifndef
begin_include
include|#
directive|include
file|<strings.h>
end_include
begin_comment
comment|/* for ffs */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_STRINGS_H */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_BUILTIN_FFS */
end_comment
begin_if
if|#
directive|if
name|HAVE_MMAP
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_SYS_MMAN_H
end_ifndef
begin_include
include|#
directive|include
file|<sys/mman.h>
end_include
begin_comment
comment|/* for mmap */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_SYS_MMAN_H */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_FCNTL_H
end_ifndef
begin_include
include|#
directive|include
file|<fcntl.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_FCNTL_H */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MMAP */
end_comment
begin_if
if|#
directive|if
name|HAVE_MORECORE
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_UNISTD_H
end_ifndef
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_comment
comment|/* for sbrk */
end_comment
begin_else
unit|extern void*     sbrk(size_t);
else|#
directive|else
end_else
begin_comment
comment|/* LACKS_UNISTD_H */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if
begin_comment
unit|extern void*     sbrk(ptrdiff_t);
comment|/*Amod sbrk is not defined in WIN32 need to check in symbian*/
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FreeBSD etc */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* LACKS_UNISTD_H */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*AMOD: For MALLOC_GETPAGESIZE*/
end_comment
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|// replaced with GET_PAGE_SIZE() defined in heap.cpp
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_GETPAGESIZE
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|_SC_PAGESIZE
end_ifdef
begin_comment
comment|/* some SVR4 systems omit an underscore */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_SC_PAGE_SIZE
end_ifndef
begin_define
define|#
directive|define
name|_SC_PAGE_SIZE
value|_SC_PAGESIZE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|_SC_PAGE_SIZE
end_ifdef
begin_define
define|#
directive|define
name|MALLOC_GETPAGESIZE
value|sysconf(_SC_PAGE_SIZE)
end_define
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|DGUX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GETPAGESIZE
argument_list|)
end_if
begin_define
unit|extern size_t getpagesize();
define|#
directive|define
name|MALLOC_GETPAGESIZE
value|getpagesize()
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef
begin_comment
comment|/* use supplied emulation of getpagesize */
end_comment
begin_define
define|#
directive|define
name|MALLOC_GETPAGESIZE
value|getpagesize()
end_define
begin_else
else|#
directive|else
end_else
begin_ifndef
ifndef|#
directive|ifndef
name|LACKS_SYS_PARAM_H
end_ifndef
begin_include
include|#
directive|include
file|<sys/param.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|EXEC_PAGESIZE
end_ifdef
begin_define
define|#
directive|define
name|MALLOC_GETPAGESIZE
value|EXEC_PAGESIZE
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|NBPG
end_ifdef
begin_ifndef
ifndef|#
directive|ifndef
name|CLSIZE
end_ifndef
begin_define
define|#
directive|define
name|MALLOC_GETPAGESIZE
value|NBPG
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|MALLOC_GETPAGESIZE
value|(NBPG * CLSIZE)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|NBPC
end_ifdef
begin_define
define|#
directive|define
name|MALLOC_GETPAGESIZE
value|NBPC
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|PAGESIZE
end_ifdef
begin_define
define|#
directive|define
name|MALLOC_GETPAGESIZE
value|PAGESIZE
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* just guess */
end_comment
begin_define
define|#
directive|define
name|MALLOC_GETPAGESIZE
value|((size_t)4096U)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*AMOD: For MALLOC_GETPAGESIZE*/
end_comment
begin_comment
comment|/* ------------------- size_t and alignment properties -------------------- */
end_comment
begin_comment
comment|/* The byte and bit size of a size_t */
end_comment
begin_define
DECL|macro|SIZE_T_SIZE
define|#
directive|define
name|SIZE_T_SIZE
value|(sizeof(size_t))
end_define
begin_define
DECL|macro|SIZE_T_BITSIZE
define|#
directive|define
name|SIZE_T_BITSIZE
value|(sizeof(size_t)<< 3)
end_define
begin_comment
comment|/* Some constants coerced to size_t */
end_comment
begin_comment
comment|/* Annoying but necessary to avoid errors on some plaftorms */
end_comment
begin_define
DECL|macro|SIZE_T_ZERO
define|#
directive|define
name|SIZE_T_ZERO
value|((size_t)0)
end_define
begin_define
DECL|macro|SIZE_T_ONE
define|#
directive|define
name|SIZE_T_ONE
value|((size_t)1)
end_define
begin_define
DECL|macro|SIZE_T_TWO
define|#
directive|define
name|SIZE_T_TWO
value|((size_t)2)
end_define
begin_define
DECL|macro|TWO_SIZE_T_SIZES
define|#
directive|define
name|TWO_SIZE_T_SIZES
value|(SIZE_T_SIZE<<1)
end_define
begin_define
DECL|macro|FOUR_SIZE_T_SIZES
define|#
directive|define
name|FOUR_SIZE_T_SIZES
value|(SIZE_T_SIZE<<2)
end_define
begin_define
DECL|macro|SIX_SIZE_T_SIZES
define|#
directive|define
name|SIX_SIZE_T_SIZES
value|(FOUR_SIZE_T_SIZES+TWO_SIZE_T_SIZES)
end_define
begin_define
DECL|macro|HALF_MAX_SIZE_T
define|#
directive|define
name|HALF_MAX_SIZE_T
value|(MAX_SIZE_T / 2U)
end_define
begin_comment
comment|/* The bit mask value corresponding to MALLOC_ALIGNMENT */
end_comment
begin_define
DECL|macro|CHUNK_ALIGN_MASK
define|#
directive|define
name|CHUNK_ALIGN_MASK
value|(MALLOC_ALIGNMENT - SIZE_T_ONE)
end_define
begin_comment
comment|/* True if address a has acceptable alignment */
end_comment
begin_comment
comment|//#define IS_ALIGNED(A)       (((size_t)((A))& (CHUNK_ALIGN_MASK)) == 0)
end_comment
begin_define
DECL|macro|IS_ALIGNED
define|#
directive|define
name|IS_ALIGNED
parameter_list|(
name|A
parameter_list|)
value|(((unsigned int)((A))& (CHUNK_ALIGN_MASK)) == 0)
end_define
begin_comment
comment|/* the number of bytes to offset an address to align it */
end_comment
begin_define
DECL|macro|ALIGN_OFFSET
define|#
directive|define
name|ALIGN_OFFSET
parameter_list|(
name|A
parameter_list|)
define|\
value|((((size_t)(A)& CHUNK_ALIGN_MASK) == 0)? 0 :\ 	((MALLOC_ALIGNMENT - ((size_t)(A)& CHUNK_ALIGN_MASK))& CHUNK_ALIGN_MASK))
end_define
begin_comment
comment|/* -------------------------- MMAP preliminaries ------------------------- */
end_comment
begin_comment
comment|/*    If HAVE_MORECORE or HAVE_MMAP are false, we just define calls and    checks to fail so compiler optimizer can delete code rather than    using so many "#if"s. */
end_comment
begin_comment
comment|/* MORECORE and MMAP must return MFAIL on failure */
end_comment
begin_define
DECL|macro|MFAIL
define|#
directive|define
name|MFAIL
value|((void*)(MAX_SIZE_T))
end_define
begin_define
DECL|macro|CMFAIL
define|#
directive|define
name|CMFAIL
value|((TUint8*)(MFAIL))
end_define
begin_comment
DECL|macro|CMFAIL
comment|/* defined for convenience */
end_comment
begin_if
if|#
directive|if
operator|!
name|HAVE_MMAP
end_if
begin_define
DECL|macro|IS_MMAPPED_BIT
define|#
directive|define
name|IS_MMAPPED_BIT
value|(SIZE_T_ZERO)
end_define
begin_define
DECL|macro|USE_MMAP_BIT
define|#
directive|define
name|USE_MMAP_BIT
value|(SIZE_T_ZERO)
end_define
begin_define
DECL|macro|CALL_MMAP
define|#
directive|define
name|CALL_MMAP
parameter_list|(
name|s
parameter_list|)
value|MFAIL
end_define
begin_define
DECL|macro|CALL_MUNMAP
define|#
directive|define
name|CALL_MUNMAP
parameter_list|(
name|a
parameter_list|,
name|s
parameter_list|)
value|(-1)
end_define
begin_define
DECL|macro|DIRECT_MMAP
define|#
directive|define
name|DIRECT_MMAP
parameter_list|(
name|s
parameter_list|)
value|MFAIL
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !HAVE_MMAP */
end_comment
begin_define
DECL|macro|IS_MMAPPED_BIT
define|#
directive|define
name|IS_MMAPPED_BIT
value|(SIZE_T_ONE)
end_define
begin_define
DECL|macro|USE_MMAP_BIT
define|#
directive|define
name|USE_MMAP_BIT
value|(SIZE_T_ONE)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef
begin_define
DECL|macro|CALL_MUNMAP
define|#
directive|define
name|CALL_MUNMAP
parameter_list|(
name|a
parameter_list|,
name|s
parameter_list|)
value|DLUMMAP((a),(s))
end_define
begin_comment
DECL|macro|CALL_MUNMAP
comment|/*munmap((a), (s))*/
end_comment
begin_define
DECL|macro|MMAP_PROT
define|#
directive|define
name|MMAP_PROT
value|(PROT_READ|PROT_WRITE)
end_define
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|MAP_ANON
argument_list|)
end_if
begin_define
DECL|macro|MAP_ANONYMOUS
define|#
directive|define
name|MAP_ANONYMOUS
value|MAP_ANON
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MAP_ANON */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|MAP_ANONYMOUS
end_ifdef
begin_define
DECL|macro|MMAP_FLAGS
define|#
directive|define
name|MMAP_FLAGS
value|(MAP_PRIVATE|MAP_ANONYMOUS)
end_define
begin_define
DECL|macro|CALL_MMAP
define|#
directive|define
name|CALL_MMAP
parameter_list|(
name|s
parameter_list|)
value|mmap(0, (s), MMAP_PROT, (int)MMAP_FLAGS, -1, 0)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* MAP_ANONYMOUS */
end_comment
begin_comment
comment|/* 				   Nearly all versions of mmap support MAP_ANONYMOUS, so the following 				   is unlikely to be needed, but is supplied just in case. 				*/
end_comment
begin_define
DECL|macro|MMAP_FLAGS
define|#
directive|define
name|MMAP_FLAGS
value|(MAP_PRIVATE)
end_define
begin_comment
comment|//static int dev_zero_fd = -1; /* Cached file descriptor for /dev/zero. */
end_comment
begin_define
DECL|macro|CALL_MMAP
define|#
directive|define
name|CALL_MMAP
parameter_list|(
name|s
parameter_list|)
value|DLMMAP(s)
end_define
begin_comment
comment|/*#define CALL_MMAP(s) ((dev_zero_fd< 0) ? \ 			           (dev_zero_fd = open("/dev/zero", O_RDWR), \ 			            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \ 			            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) 			            */
end_comment
begin_define
DECL|macro|CALL_REMAP
define|#
directive|define
name|CALL_REMAP
parameter_list|(
name|a
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|)
value|DLREMAP((a),(s),(d))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MAP_ANONYMOUS */
end_comment
begin_define
DECL|macro|DIRECT_MMAP
define|#
directive|define
name|DIRECT_MMAP
parameter_list|(
name|s
parameter_list|)
value|CALL_MMAP(s)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* WIN32 */
end_comment
begin_define
DECL|macro|CALL_MMAP
define|#
directive|define
name|CALL_MMAP
parameter_list|(
name|s
parameter_list|)
value|win32mmap(s)
end_define
begin_define
DECL|macro|CALL_MUNMAP
define|#
directive|define
name|CALL_MUNMAP
parameter_list|(
name|a
parameter_list|,
name|s
parameter_list|)
value|win32munmap((a), (s))
end_define
begin_define
DECL|macro|DIRECT_MMAP
define|#
directive|define
name|DIRECT_MMAP
parameter_list|(
name|s
parameter_list|)
value|win32direct_mmap(s)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WIN32 */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MMAP */
end_comment
begin_if
if|#
directive|if
name|HAVE_MMAP
operator|&&
name|HAVE_MREMAP
end_if
begin_define
DECL|macro|CALL_MREMAP
define|#
directive|define
name|CALL_MREMAP
parameter_list|(
name|addr
parameter_list|,
name|osz
parameter_list|,
name|nsz
parameter_list|,
name|mv
parameter_list|)
value|mremap((addr), (osz), (nsz), (mv))
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* HAVE_MMAP&& HAVE_MREMAP */
end_comment
begin_define
DECL|macro|CALL_MREMAP
define|#
directive|define
name|CALL_MREMAP
parameter_list|(
name|addr
parameter_list|,
name|osz
parameter_list|,
name|nsz
parameter_list|,
name|mv
parameter_list|)
value|MFAIL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MMAP&& HAVE_MREMAP */
end_comment
begin_if
if|#
directive|if
name|HAVE_MORECORE
end_if
begin_define
DECL|macro|CALL_MORECORE
define|#
directive|define
name|CALL_MORECORE
parameter_list|(
name|S
parameter_list|)
value|SetBrk(S)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_define
DECL|macro|CALL_MORECORE
define|#
directive|define
name|CALL_MORECORE
parameter_list|(
name|S
parameter_list|)
value|MFAIL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_comment
comment|/* mstate bit set if continguous morecore disabled or failed */
end_comment
begin_define
DECL|macro|USE_NONCONTIGUOUS_BIT
define|#
directive|define
name|USE_NONCONTIGUOUS_BIT
value|(4U)
end_define
begin_comment
comment|/* segment bit set in create_mspace_with_base */
end_comment
begin_define
DECL|macro|EXTERN_BIT
define|#
directive|define
name|EXTERN_BIT
value|(8U)
end_define
begin_if
if|#
directive|if
name|USE_LOCKS
end_if
begin_comment
comment|/*   When locks are defined, there are up to two global locks:   * If HAVE_MORECORE, iMorecoreMutex protects sequences of calls to     MORECORE.  In many cases sys_alloc requires two calls, that should     not be interleaved with calls by other threads.  This does not     protect against direct calls to MORECORE by other threads not     using this lock, so there is still code to cope the best we can on     interference.   * iMagicInitMutex ensures that mparams.iMagic and other     unique mparams values are initialized only once. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef
begin_comment
comment|/* By default use posix locks */
end_comment
begin_include
include|#
directive|include
file|<pthread.h>
end_include
begin_define
DECL|macro|MLOCK_T
define|#
directive|define
name|MLOCK_T
value|pthread_mutex_t
end_define
begin_define
DECL|macro|INITIAL_LOCK
define|#
directive|define
name|INITIAL_LOCK
parameter_list|(
name|l
parameter_list|)
value|pthread_mutex_init(l, NULL)
end_define
begin_define
DECL|macro|ACQUIRE_LOCK
define|#
directive|define
name|ACQUIRE_LOCK
parameter_list|(
name|l
parameter_list|)
value|pthread_mutex_lock(l)
end_define
begin_define
DECL|macro|RELEASE_LOCK
define|#
directive|define
name|RELEASE_LOCK
parameter_list|(
name|l
parameter_list|)
value|pthread_mutex_unlock(l)
end_define
begin_if
if|#
directive|if
name|HAVE_MORECORE
end_if
begin_comment
comment|//static MLOCK_T iMorecoreMutex = PTHREAD_MUTEX_INITIALIZER;
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_comment
comment|//static MLOCK_T iMagicInitMutex = PTHREAD_MUTEX_INITIALIZER;
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* WIN32 */
end_comment
begin_define
DECL|macro|MLOCK_T
define|#
directive|define
name|MLOCK_T
value|long
end_define
begin_define
DECL|macro|INITIAL_LOCK
define|#
directive|define
name|INITIAL_LOCK
parameter_list|(
name|l
parameter_list|)
value|*(l)=0
end_define
begin_define
DECL|macro|ACQUIRE_LOCK
define|#
directive|define
name|ACQUIRE_LOCK
parameter_list|(
name|l
parameter_list|)
value|win32_acquire_lock(l)
end_define
begin_define
DECL|macro|RELEASE_LOCK
define|#
directive|define
name|RELEASE_LOCK
parameter_list|(
name|l
parameter_list|)
value|win32_release_lock(l)
end_define
begin_if
if|#
directive|if
name|HAVE_MORECORE
end_if
begin_decl_stmt
DECL|variable|iMorecoreMutex
specifier|static
name|MLOCK_T
name|iMorecoreMutex
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_MORECORE */
end_comment
begin_decl_stmt
DECL|variable|iMagicInitMutex
specifier|static
name|MLOCK_T
name|iMagicInitMutex
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* WIN32 */
end_comment
begin_define
DECL|macro|USE_LOCK_BIT
define|#
directive|define
name|USE_LOCK_BIT
value|(2U)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_define
DECL|macro|USE_LOCK_BIT
define|#
directive|define
name|USE_LOCK_BIT
value|(0U)
end_define
begin_define
DECL|macro|INITIAL_LOCK
define|#
directive|define
name|INITIAL_LOCK
parameter_list|(
name|l
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_if
if|#
directive|if
name|USE_LOCKS
operator|&&
name|HAVE_MORECORE
end_if
begin_define
DECL|macro|ACQUIRE_MORECORE_LOCK
define|#
directive|define
name|ACQUIRE_MORECORE_LOCK
parameter_list|(
name|M
parameter_list|)
value|ACQUIRE_LOCK((M->iMorecoreMutex)
comment|/*&iMorecoreMutex*/
value|);
end_define
begin_define
DECL|macro|RELEASE_MORECORE_LOCK
define|#
directive|define
name|RELEASE_MORECORE_LOCK
parameter_list|(
name|M
parameter_list|)
value|RELEASE_LOCK((M->iMorecoreMutex)
comment|/*&iMorecoreMutex*/
value|);
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* USE_LOCKS&& HAVE_MORECORE */
end_comment
begin_define
DECL|macro|ACQUIRE_MORECORE_LOCK
define|#
directive|define
name|ACQUIRE_MORECORE_LOCK
parameter_list|(
name|M
parameter_list|)
end_define
begin_define
DECL|macro|RELEASE_MORECORE_LOCK
define|#
directive|define
name|RELEASE_MORECORE_LOCK
parameter_list|(
name|M
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS&& HAVE_MORECORE */
end_comment
begin_if
if|#
directive|if
name|USE_LOCKS
end_if
begin_comment
comment|/*Currently not suporting this*/
end_comment
begin_define
DECL|macro|ACQUIRE_MAGIC_INIT_LOCK
define|#
directive|define
name|ACQUIRE_MAGIC_INIT_LOCK
parameter_list|(
name|M
parameter_list|)
value|ACQUIRE_LOCK(((M)->iMagicInitMutex));
end_define
begin_comment
comment|//AMOD: changed #define ACQUIRE_MAGIC_INIT_LOCK()
end_comment
begin_comment
comment|//#define RELEASE_MAGIC_INIT_LOCK()
end_comment
begin_define
DECL|macro|RELEASE_MAGIC_INIT_LOCK
define|#
directive|define
name|RELEASE_MAGIC_INIT_LOCK
parameter_list|(
name|M
parameter_list|)
value|RELEASE_LOCK(((M)->iMagicInitMutex));
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_define
DECL|macro|ACQUIRE_MAGIC_INIT_LOCK
define|#
directive|define
name|ACQUIRE_MAGIC_INIT_LOCK
parameter_list|(
name|M
parameter_list|)
end_define
begin_define
DECL|macro|RELEASE_MAGIC_INIT_LOCK
define|#
directive|define
name|RELEASE_MAGIC_INIT_LOCK
parameter_list|(
name|M
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_comment
comment|/*CHUNK representation*/
end_comment
begin_struct
DECL|struct|malloc_chunk
struct|struct
name|malloc_chunk
block|{
DECL|member|iPrevFoot
name|size_t
name|iPrevFoot
decl_stmt|;
comment|/* Size of previous chunk (if free).  */
DECL|member|iHead
name|size_t
name|iHead
decl_stmt|;
comment|/* Size and inuse bits. */
DECL|member|iFd
name|struct
name|malloc_chunk
modifier|*
name|iFd
decl_stmt|;
comment|/* double links -- used only if free. */
DECL|member|iBk
name|struct
name|malloc_chunk
modifier|*
name|iBk
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|mchunk
typedef|typedef
name|struct
name|malloc_chunk
name|mchunk
typedef|;
end_typedef
begin_typedef
DECL|typedef|mchunkptr
typedef|typedef
name|struct
name|malloc_chunk
modifier|*
name|mchunkptr
typedef|;
end_typedef
begin_typedef
DECL|typedef|sbinptr
typedef|typedef
name|struct
name|malloc_chunk
modifier|*
name|sbinptr
typedef|;
end_typedef
begin_comment
DECL|typedef|sbinptr
comment|/* The type of bins of chunks */
end_comment
begin_typedef
DECL|typedef|bindex_t
typedef|typedef
name|unsigned
name|int
name|bindex_t
typedef|;
end_typedef
begin_comment
DECL|typedef|bindex_t
comment|/* Described below */
end_comment
begin_typedef
DECL|typedef|binmap_t
typedef|typedef
name|unsigned
name|int
name|binmap_t
typedef|;
end_typedef
begin_comment
DECL|typedef|binmap_t
comment|/* Described below */
end_comment
begin_typedef
DECL|typedef|flag_t
typedef|typedef
name|unsigned
name|int
name|flag_t
typedef|;
end_typedef
begin_comment
DECL|typedef|flag_t
comment|/* The type of various bit flag sets */
end_comment
begin_comment
comment|/* ------------------- Chunks sizes and alignments ----------------------- */
end_comment
begin_define
DECL|macro|MCHUNK_SIZE
define|#
directive|define
name|MCHUNK_SIZE
value|(sizeof(mchunk))
end_define
begin_comment
comment|//#if FOOTERS
end_comment
begin_comment
comment|//	#define CHUNK_OVERHEAD      (TWO_SIZE_T_SIZES)
end_comment
begin_comment
comment|//#else /* FOOTERS */
end_comment
begin_comment
comment|//	#define CHUNK_OVERHEAD      (SIZE_T_SIZE)
end_comment
begin_comment
comment|//#endif /* FOOTERS */
end_comment
begin_comment
comment|/* MMapped chunks need a second word of overhead ... */
end_comment
begin_define
DECL|macro|MMAP_CHUNK_OVERHEAD
define|#
directive|define
name|MMAP_CHUNK_OVERHEAD
value|(TWO_SIZE_T_SIZES)
end_define
begin_comment
comment|/* ... and additional padding for fake next-chunk at foot */
end_comment
begin_define
DECL|macro|MMAP_FOOT_PAD
define|#
directive|define
name|MMAP_FOOT_PAD
value|(FOUR_SIZE_T_SIZES)
end_define
begin_comment
comment|/* The smallest size we can malloc is an aligned minimal chunk */
end_comment
begin_define
DECL|macro|MIN_CHUNK_SIZE
define|#
directive|define
name|MIN_CHUNK_SIZE
value|((MCHUNK_SIZE + CHUNK_ALIGN_MASK)& ~CHUNK_ALIGN_MASK)
end_define
begin_comment
comment|/* conversion from malloc headers to user pointers, and back */
end_comment
begin_define
DECL|macro|CHUNK2MEM
define|#
directive|define
name|CHUNK2MEM
parameter_list|(
name|p
parameter_list|)
value|((void*)((TUint8*)(p)       + TWO_SIZE_T_SIZES))
end_define
begin_define
DECL|macro|MEM2CHUNK
define|#
directive|define
name|MEM2CHUNK
parameter_list|(
name|mem
parameter_list|)
value|((mchunkptr)((TUint8*)(mem) - TWO_SIZE_T_SIZES))
end_define
begin_comment
comment|/* chunk associated with aligned address A */
end_comment
begin_define
DECL|macro|ALIGN_AS_CHUNK
define|#
directive|define
name|ALIGN_AS_CHUNK
parameter_list|(
name|A
parameter_list|)
value|(mchunkptr)((A) + ALIGN_OFFSET(CHUNK2MEM(A)))
end_define
begin_comment
comment|/* Bounds on request (not chunk) sizes. */
end_comment
begin_define
DECL|macro|MAX_REQUEST
define|#
directive|define
name|MAX_REQUEST
value|((-MIN_CHUNK_SIZE)<< 2)
end_define
begin_define
DECL|macro|MIN_REQUEST
define|#
directive|define
name|MIN_REQUEST
value|(MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)
end_define
begin_comment
comment|/* pad request bytes into a usable size */
end_comment
begin_define
DECL|macro|PAD_REQUEST
define|#
directive|define
name|PAD_REQUEST
parameter_list|(
name|req
parameter_list|)
value|(((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK)& ~CHUNK_ALIGN_MASK)
end_define
begin_comment
comment|/* pad request, checking for minimum (but not maximum) */
end_comment
begin_define
DECL|macro|REQUEST2SIZE
define|#
directive|define
name|REQUEST2SIZE
parameter_list|(
name|req
parameter_list|)
value|(((req)< MIN_REQUEST)? MIN_CHUNK_SIZE : PAD_REQUEST(req))
end_define
begin_comment
comment|/* ------------------ Operations on iHead and foot fields ----------------- */
end_comment
begin_comment
comment|/*   The iHead field of a chunk is or'ed with PINUSE_BIT when previous   adjacent chunk in use, and or'ed with CINUSE_BIT if this chunk is in   use. If the chunk was obtained with mmap, the iPrevFoot field has   IS_MMAPPED_BIT set, otherwise holding the offset of the base of the   mmapped region to the base of the chunk. */
end_comment
begin_define
DECL|macro|PINUSE_BIT
define|#
directive|define
name|PINUSE_BIT
value|(SIZE_T_ONE)
end_define
begin_define
DECL|macro|CINUSE_BIT
define|#
directive|define
name|CINUSE_BIT
value|(SIZE_T_TWO)
end_define
begin_define
DECL|macro|INUSE_BITS
define|#
directive|define
name|INUSE_BITS
value|(PINUSE_BIT|CINUSE_BIT)
end_define
begin_comment
comment|/* Head value for fenceposts */
end_comment
begin_define
DECL|macro|FENCEPOST_HEAD
define|#
directive|define
name|FENCEPOST_HEAD
value|(INUSE_BITS|SIZE_T_SIZE)
end_define
begin_comment
comment|/* extraction of fields from iHead words */
end_comment
begin_define
DECL|macro|CINUSE
define|#
directive|define
name|CINUSE
parameter_list|(
name|p
parameter_list|)
value|((p)->iHead& CINUSE_BIT)
end_define
begin_define
DECL|macro|PINUSE
define|#
directive|define
name|PINUSE
parameter_list|(
name|p
parameter_list|)
value|((p)->iHead& PINUSE_BIT)
end_define
begin_define
DECL|macro|CHUNKSIZE
define|#
directive|define
name|CHUNKSIZE
parameter_list|(
name|p
parameter_list|)
value|((p)->iHead& ~(INUSE_BITS))
end_define
begin_define
DECL|macro|CLEAR_PINUSE
define|#
directive|define
name|CLEAR_PINUSE
parameter_list|(
name|p
parameter_list|)
value|((p)->iHead&= ~PINUSE_BIT)
end_define
begin_define
DECL|macro|CLEAR_CINUSE
define|#
directive|define
name|CLEAR_CINUSE
parameter_list|(
name|p
parameter_list|)
value|((p)->iHead&= ~CINUSE_BIT)
end_define
begin_comment
comment|/* Treat space at ptr +/- offset as a chunk */
end_comment
begin_define
DECL|macro|CHUNK_PLUS_OFFSET
define|#
directive|define
name|CHUNK_PLUS_OFFSET
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|((mchunkptr)(((TUint8*)(p)) + (s)))
end_define
begin_define
DECL|macro|CHUNK_MINUS_OFFSET
define|#
directive|define
name|CHUNK_MINUS_OFFSET
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|((mchunkptr)(((TUint8*)(p)) - (s)))
end_define
begin_comment
comment|/* Ptr to next or previous physical malloc_chunk. */
end_comment
begin_define
DECL|macro|NEXT_CHUNK
define|#
directive|define
name|NEXT_CHUNK
parameter_list|(
name|p
parameter_list|)
value|((mchunkptr)( ((TUint8*)(p)) + ((p)->iHead& ~INUSE_BITS)))
end_define
begin_define
DECL|macro|PREV_CHUNK
define|#
directive|define
name|PREV_CHUNK
parameter_list|(
name|p
parameter_list|)
value|((mchunkptr)( ((TUint8*)(p)) - ((p)->iPrevFoot) ))
end_define
begin_comment
comment|/* extract next chunk's PINUSE bit */
end_comment
begin_define
DECL|macro|NEXT_PINUSE
define|#
directive|define
name|NEXT_PINUSE
parameter_list|(
name|p
parameter_list|)
value|((NEXT_CHUNK(p)->iHead)& PINUSE_BIT)
end_define
begin_comment
comment|/* Get/set size at footer */
end_comment
begin_define
DECL|macro|GET_FOOT
define|#
directive|define
name|GET_FOOT
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|(((mchunkptr)((TUint8*)(p) + (s)))->iPrevFoot)
end_define
begin_define
DECL|macro|SET_FOOT
define|#
directive|define
name|SET_FOOT
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|(((mchunkptr)((TUint8*)(p) + (s)))->iPrevFoot = (s))
end_define
begin_comment
comment|/* Set size, PINUSE bit, and foot */
end_comment
begin_define
DECL|macro|SET_SIZE_AND_PINUSE_OF_FREE_CHUNK
define|#
directive|define
name|SET_SIZE_AND_PINUSE_OF_FREE_CHUNK
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|((p)->iHead = (s|PINUSE_BIT), SET_FOOT(p, s))
end_define
begin_comment
comment|/* Set size, PINUSE bit, foot, and clear next PINUSE */
end_comment
begin_define
DECL|macro|SET_FREE_WITH_PINUSE
define|#
directive|define
name|SET_FREE_WITH_PINUSE
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|(CLEAR_PINUSE(n), SET_SIZE_AND_PINUSE_OF_FREE_CHUNK(p, s))
end_define
begin_define
DECL|macro|IS_MMAPPED
define|#
directive|define
name|IS_MMAPPED
parameter_list|(
name|p
parameter_list|)
value|(!((p)->iHead& PINUSE_BIT)&& ((p)->iPrevFoot& IS_MMAPPED_BIT))
end_define
begin_comment
comment|/* Get the internal overhead associated with chunk p */
end_comment
begin_define
DECL|macro|OVERHEAD_FOR
define|#
directive|define
name|OVERHEAD_FOR
parameter_list|(
name|p
parameter_list|)
value|(IS_MMAPPED(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD)
end_define
begin_comment
comment|/* Return true if malloced space is not necessarily cleared */
end_comment
begin_if
if|#
directive|if
name|MMAP_CLEARS
end_if
begin_define
DECL|macro|CALLOC_MUST_CLEAR
define|#
directive|define
name|CALLOC_MUST_CLEAR
parameter_list|(
name|p
parameter_list|)
value|(!IS_MMAPPED(p))
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* MMAP_CLEARS */
end_comment
begin_define
DECL|macro|CALLOC_MUST_CLEAR
define|#
directive|define
name|CALLOC_MUST_CLEAR
parameter_list|(
name|p
parameter_list|)
value|(1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MMAP_CLEARS */
end_comment
begin_comment
comment|/* ---------------------- Overlaid data structures ----------------------- */
end_comment
begin_struct
DECL|struct|malloc_tree_chunk
struct|struct
name|malloc_tree_chunk
block|{
comment|/* The first four fields must be compatible with malloc_chunk */
DECL|member|iPrevFoot
name|size_t
name|iPrevFoot
decl_stmt|;
DECL|member|iHead
name|size_t
name|iHead
decl_stmt|;
DECL|member|iFd
name|struct
name|malloc_tree_chunk
modifier|*
name|iFd
decl_stmt|;
DECL|member|iBk
name|struct
name|malloc_tree_chunk
modifier|*
name|iBk
decl_stmt|;
DECL|member|iChild
name|struct
name|malloc_tree_chunk
modifier|*
name|iChild
index|[
literal|2
index|]
decl_stmt|;
DECL|member|iParent
name|struct
name|malloc_tree_chunk
modifier|*
name|iParent
decl_stmt|;
DECL|member|iIndex
name|bindex_t
name|iIndex
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|tchunk
typedef|typedef
name|struct
name|malloc_tree_chunk
name|tchunk
typedef|;
end_typedef
begin_typedef
DECL|typedef|tchunkptr
typedef|typedef
name|struct
name|malloc_tree_chunk
modifier|*
name|tchunkptr
typedef|;
end_typedef
begin_typedef
DECL|typedef|tbinptr
typedef|typedef
name|struct
name|malloc_tree_chunk
modifier|*
name|tbinptr
typedef|;
end_typedef
begin_comment
DECL|typedef|tbinptr
comment|/* The type of bins of trees */
end_comment
begin_comment
comment|/* A little helper macro for trees */
end_comment
begin_define
DECL|macro|LEFTMOST_CHILD
define|#
directive|define
name|LEFTMOST_CHILD
parameter_list|(
name|t
parameter_list|)
value|((t)->iChild[0] != 0? (t)->iChild[0] : (t)->iChild[1])
end_define
begin_comment
comment|/*Segment structur*/
end_comment
begin_comment
comment|//struct malloc_segment {
end_comment
begin_comment
comment|//  TUint8*        iBase;             /* base address */
end_comment
begin_comment
comment|//  size_t       iSize;             /* allocated size */
end_comment
begin_comment
comment|//};
end_comment
begin_define
DECL|macro|IS_MMAPPED_SEGMENT
define|#
directive|define
name|IS_MMAPPED_SEGMENT
parameter_list|(
name|S
parameter_list|)
value|((S)->iSflags& IS_MMAPPED_BIT)
end_define
begin_define
DECL|macro|IS_EXTERN_SEGMENT
define|#
directive|define
name|IS_EXTERN_SEGMENT
parameter_list|(
name|S
parameter_list|)
value|((S)->iSflags& EXTERN_BIT)
end_define
begin_typedef
DECL|typedef|msegment
typedef|typedef
name|struct
name|malloc_segment
name|msegment
typedef|;
end_typedef
begin_typedef
DECL|typedef|msegmentptr
typedef|typedef
name|struct
name|malloc_segment
modifier|*
name|msegmentptr
typedef|;
end_typedef
begin_comment
comment|/*Malloc State data structur*/
end_comment
begin_comment
comment|//#define NSMALLBINS        (32U)
end_comment
begin_comment
comment|//#define NTREEBINS         (32U)
end_comment
begin_define
DECL|macro|SMALLBIN_SHIFT
define|#
directive|define
name|SMALLBIN_SHIFT
value|(3U)
end_define
begin_define
DECL|macro|SMALLBIN_WIDTH
define|#
directive|define
name|SMALLBIN_WIDTH
value|(SIZE_T_ONE<< SMALLBIN_SHIFT)
end_define
begin_define
DECL|macro|TREEBIN_SHIFT
define|#
directive|define
name|TREEBIN_SHIFT
value|(8U)
end_define
begin_define
DECL|macro|MIN_LARGE_SIZE
define|#
directive|define
name|MIN_LARGE_SIZE
value|(SIZE_T_ONE<< TREEBIN_SHIFT)
end_define
begin_define
DECL|macro|MAX_SMALL_SIZE
define|#
directive|define
name|MAX_SMALL_SIZE
value|(MIN_LARGE_SIZE - SIZE_T_ONE)
end_define
begin_define
DECL|macro|MAX_SMALL_REQUEST
define|#
directive|define
name|MAX_SMALL_REQUEST
value|(MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD)
end_define
begin_comment
comment|/*struct malloc_state { 	binmap_t	 iSmallMap; 	binmap_t	 iTreeMap; 	size_t		 iDvSize; 	size_t		 iTopSize; 	mchunkptr	iDv; 	mchunkptr	iTop; 	size_t		 iTrimCheck; 	mchunkptr	iSmallBins[(NSMALLBINS+1)*2]; 	tbinptr		iTreeBins[NTREEBINS]; 	msegment	iSeg; 	};*/
end_comment
begin_comment
comment|/* struct malloc_state {   binmap_t   iSmallMap;   binmap_t   iTreeMap;   size_t     iDvSize;   size_t     iTopSize;   TUint8*      iLeastAddr;   mchunkptr  iDv;   mchunkptr  iTop;   size_t     iTrimCheck;   size_t     iMagic;   mchunkptr  iSmallBins[(NSMALLBINS+1)*2];   tbinptr    iTreeBins[NTREEBINS];   size_t     iFootprint;   size_t     iMaxFootprint;   flag_t     iMflags; #if USE_LOCKS   MLOCK_T    iMutex;   MLOCK_T	iMagicInitMutex;     MLOCK_T	iMorecoreMutex; #endif    msegment   iSeg; }; */
end_comment
begin_typedef
DECL|typedef|mstate
typedef|typedef
name|struct
name|malloc_state
modifier|*
name|mstate
typedef|;
end_typedef
begin_comment
comment|/* ------------- Global malloc_state and malloc_params ------------------- */
end_comment
begin_comment
comment|/*   malloc_params holds global properties, including those that can be   dynamically set using mallopt. There is a single instance, mparams,   initialized in init_mparams. */
end_comment
begin_struct
DECL|struct|malloc_params
struct|struct
name|malloc_params
block|{
DECL|member|iMagic
name|size_t
name|iMagic
decl_stmt|;
DECL|member|iPageSize
name|size_t
name|iPageSize
decl_stmt|;
DECL|member|iGranularity
name|size_t
name|iGranularity
decl_stmt|;
DECL|member|iMmapThreshold
name|size_t
name|iMmapThreshold
decl_stmt|;
DECL|member|iTrimThreshold
name|size_t
name|iTrimThreshold
decl_stmt|;
DECL|member|iDefaultMflags
name|flag_t
name|iDefaultMflags
decl_stmt|;
if|#
directive|if
name|USE_LOCKS
DECL|member|iMagicInitMutex
name|MLOCK_T
name|iMagicInitMutex
decl_stmt|;
endif|#
directive|endif
comment|/* USE_LOCKS */
block|}
struct|;
end_struct
begin_comment
comment|/* The global malloc_state used for all non-"mspace" calls */
end_comment
begin_comment
comment|/*AMOD: Need to check this as this will be the member of the class*/
end_comment
begin_comment
comment|//static struct malloc_state _gm_;
end_comment
begin_comment
comment|//#define GM                 (&_gm_)
end_comment
begin_comment
comment|//#define IS_GLOBAL(M)       ((M) ==&_gm_)
end_comment
begin_comment
comment|/*AMOD: has changed*/
end_comment
begin_define
DECL|macro|IS_GLOBAL
define|#
directive|define
name|IS_GLOBAL
parameter_list|(
name|M
parameter_list|)
value|((M) == GM)
end_define
begin_define
DECL|macro|IS_INITIALIZED
define|#
directive|define
name|IS_INITIALIZED
parameter_list|(
name|M
parameter_list|)
value|((M)->iTop != 0)
end_define
begin_comment
comment|/* -------------------------- system alloc setup ------------------------- */
end_comment
begin_comment
comment|/* Operations on iMflags */
end_comment
begin_define
DECL|macro|USE_LOCK
define|#
directive|define
name|USE_LOCK
parameter_list|(
name|M
parameter_list|)
value|((M)->iMflags&   USE_LOCK_BIT)
end_define
begin_define
DECL|macro|ENABLE_LOCK
define|#
directive|define
name|ENABLE_LOCK
parameter_list|(
name|M
parameter_list|)
value|((M)->iMflags |=  USE_LOCK_BIT)
end_define
begin_define
DECL|macro|DISABLE_LOCK
define|#
directive|define
name|DISABLE_LOCK
parameter_list|(
name|M
parameter_list|)
value|((M)->iMflags&= ~USE_LOCK_BIT)
end_define
begin_define
DECL|macro|USE_MMAP
define|#
directive|define
name|USE_MMAP
parameter_list|(
name|M
parameter_list|)
value|((M)->iMflags&   USE_MMAP_BIT)
end_define
begin_define
DECL|macro|ENABLE_MMAP
define|#
directive|define
name|ENABLE_MMAP
parameter_list|(
name|M
parameter_list|)
value|((M)->iMflags |=  USE_MMAP_BIT)
end_define
begin_define
DECL|macro|DISABLE_MMAP
define|#
directive|define
name|DISABLE_MMAP
parameter_list|(
name|M
parameter_list|)
value|((M)->iMflags&= ~USE_MMAP_BIT)
end_define
begin_define
DECL|macro|USE_NONCONTIGUOUS
define|#
directive|define
name|USE_NONCONTIGUOUS
parameter_list|(
name|M
parameter_list|)
value|((M)->iMflags&   USE_NONCONTIGUOUS_BIT)
end_define
begin_define
DECL|macro|DISABLE_CONTIGUOUS
define|#
directive|define
name|DISABLE_CONTIGUOUS
parameter_list|(
name|M
parameter_list|)
value|((M)->iMflags |=  USE_NONCONTIGUOUS_BIT)
end_define
begin_define
DECL|macro|SET_LOCK
define|#
directive|define
name|SET_LOCK
parameter_list|(
name|M
parameter_list|,
name|L
parameter_list|)
value|((M)->iMflags = (L)? ((M)->iMflags | USE_LOCK_BIT) :  ((M)->iMflags& ~USE_LOCK_BIT))
end_define
begin_comment
comment|/* page-align a size */
end_comment
begin_define
DECL|macro|PAGE_ALIGN
define|#
directive|define
name|PAGE_ALIGN
parameter_list|(
name|S
parameter_list|)
value|(((S) + (mparams.iPageSize))& ~(mparams.iPageSize - SIZE_T_ONE))
end_define
begin_comment
comment|/* iGranularity-align a size */
end_comment
begin_define
DECL|macro|GRANULARITY_ALIGN
define|#
directive|define
name|GRANULARITY_ALIGN
parameter_list|(
name|S
parameter_list|)
value|(((S) + (mparams.iGranularity))& ~(mparams.iGranularity - SIZE_T_ONE))
end_define
begin_define
DECL|macro|IS_PAGE_ALIGNED
define|#
directive|define
name|IS_PAGE_ALIGNED
parameter_list|(
name|S
parameter_list|)
value|(((size_t)(S)& (mparams.iPageSize - SIZE_T_ONE)) == 0)
end_define
begin_define
DECL|macro|IS_GRANULARITY_ALIGNED
define|#
directive|define
name|IS_GRANULARITY_ALIGNED
parameter_list|(
name|S
parameter_list|)
value|(((size_t)(S)& (mparams.iGranularity - SIZE_T_ONE)) == 0)
end_define
begin_comment
comment|/*  True if segment S holds address A */
end_comment
begin_define
DECL|macro|SEGMENT_HOLDS
define|#
directive|define
name|SEGMENT_HOLDS
parameter_list|(
name|S
parameter_list|,
name|A
parameter_list|)
value|((TUint8*)(A)>= S->iBase&& (TUint8*)(A)< S->iBase + S->iSize)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|MORECORE_CANNOT_TRIM
end_ifndef
begin_define
DECL|macro|SHOULD_TRIM
define|#
directive|define
name|SHOULD_TRIM
parameter_list|(
name|M
parameter_list|,
name|s
parameter_list|)
value|((s)> (M)->iTrimCheck)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* MORECORE_CANNOT_TRIM */
end_comment
begin_define
DECL|macro|SHOULD_TRIM
define|#
directive|define
name|SHOULD_TRIM
parameter_list|(
name|M
parameter_list|,
name|s
parameter_list|)
value|(0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MORECORE_CANNOT_TRIM */
end_comment
begin_comment
comment|/*   TOP_FOOT_SIZE is padding at the end of a segment, including space   that may be needed to place segment records and fenceposts when new   noncontiguous segments are added. */
end_comment
begin_define
DECL|macro|TOP_FOOT_SIZE
define|#
directive|define
name|TOP_FOOT_SIZE
value|(ALIGN_OFFSET(CHUNK2MEM(0))+PAD_REQUEST(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)
end_define
begin_define
DECL|macro|SYS_ALLOC_PADDING
define|#
directive|define
name|SYS_ALLOC_PADDING
value|(TOP_FOOT_SIZE + MALLOC_ALIGNMENT)
end_define
begin_comment
comment|/* -------------------------------  Hooks -------------------------------- */
end_comment
begin_comment
comment|/*   PREACTION should be defined to return 0 on success, and nonzero on   failure. If you are not using locking, you can redefine these to do   anything you like. */
end_comment
begin_if
if|#
directive|if
name|USE_LOCKS
end_if
begin_comment
comment|/* Ensure locks are initialized */
end_comment
begin_define
DECL|macro|GLOBALLY_INITIALIZE
define|#
directive|define
name|GLOBALLY_INITIALIZE
parameter_list|()
value|(mparams.iPageSize == 0&& init_mparams())
end_define
begin_define
DECL|macro|PREACTION
define|#
directive|define
name|PREACTION
parameter_list|(
name|M
parameter_list|)
value|(USE_LOCK((M))?(ACQUIRE_LOCK((M)->iMutex),0):0)
end_define
begin_comment
DECL|macro|PREACTION
comment|/*Action to take like lock before alloc*/
end_comment
begin_define
DECL|macro|POSTACTION
define|#
directive|define
name|POSTACTION
parameter_list|(
name|M
parameter_list|)
value|{ if (USE_LOCK(M)) RELEASE_LOCK((M)->iMutex); }
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PREACTION
end_ifndef
begin_define
DECL|macro|PREACTION
define|#
directive|define
name|PREACTION
parameter_list|(
name|M
parameter_list|)
value|(0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PREACTION */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|POSTACTION
end_ifndef
begin_define
DECL|macro|POSTACTION
define|#
directive|define
name|POSTACTION
parameter_list|(
name|M
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* POSTACTION */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USE_LOCKS */
end_comment
begin_comment
comment|/*   CORRUPTION_ERROR_ACTION is triggered upon detected bad addresses.   USAGE_ERROR_ACTION is triggered on detected bad frees and   reallocs. The argument p is an address that might have triggered the   fault. It is ignored by the two predefined actions, but might be   useful in custom actions that try to help diagnose errors. */
end_comment
begin_if
if|#
directive|if
name|PROCEED_ON_ERROR
end_if
begin_comment
comment|/* A count of the number of corruption errors causing resets */
end_comment
begin_decl_stmt
DECL|variable|malloc_corruption_error_count
name|int
name|malloc_corruption_error_count
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* default corruption action */
end_comment
begin_function_decl
specifier|static
name|void
name|ResetOnError
parameter_list|(
name|mstate
name|m
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|CORRUPTION_ERROR_ACTION
define|#
directive|define
name|CORRUPTION_ERROR_ACTION
parameter_list|(
name|m
parameter_list|)
value|ResetOnError(m)
end_define
begin_define
DECL|macro|USAGE_ERROR_ACTION
define|#
directive|define
name|USAGE_ERROR_ACTION
parameter_list|(
name|m
parameter_list|,
name|p
parameter_list|)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* PROCEED_ON_ERROR */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|CORRUPTION_ERROR_ACTION
end_ifndef
begin_define
DECL|macro|CORRUPTION_ERROR_ACTION
define|#
directive|define
name|CORRUPTION_ERROR_ACTION
parameter_list|(
name|m
parameter_list|)
value|ABORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* CORRUPTION_ERROR_ACTION */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USAGE_ERROR_ACTION
end_ifndef
begin_define
DECL|macro|USAGE_ERROR_ACTION
define|#
directive|define
name|USAGE_ERROR_ACTION
parameter_list|(
name|m
parameter_list|,
name|p
parameter_list|)
value|ABORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* USAGE_ERROR_ACTION */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PROCEED_ON_ERROR */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|_DEBUG
end_ifdef
begin_define
DECL|macro|CHECK_FREE_CHUNK
define|#
directive|define
name|CHECK_FREE_CHUNK
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
value|DoCheckFreeChunk(M,P)
end_define
begin_define
DECL|macro|CHECK_INUSE_CHUNK
define|#
directive|define
name|CHECK_INUSE_CHUNK
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
value|DoCheckInuseChunk(M,P)
end_define
begin_define
DECL|macro|CHECK_TOP_CHUNK
define|#
directive|define
name|CHECK_TOP_CHUNK
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
value|DoCheckTopChunk(M,P)
end_define
begin_define
DECL|macro|CHECK_MALLOCED_CHUNK
define|#
directive|define
name|CHECK_MALLOCED_CHUNK
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|,
name|N
parameter_list|)
value|DoCheckMallocedChunk(M,P,N)
end_define
begin_define
DECL|macro|CHECK_MMAPPED_CHUNK
define|#
directive|define
name|CHECK_MMAPPED_CHUNK
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
value|DoCheckMmappedChunk(M,P)
end_define
begin_define
DECL|macro|CHECK_MALLOC_STATE
define|#
directive|define
name|CHECK_MALLOC_STATE
parameter_list|(
name|M
parameter_list|)
value|DoCheckMallocState(M)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* DEBUG */
end_comment
begin_define
DECL|macro|CHECK_FREE_CHUNK
define|#
directive|define
name|CHECK_FREE_CHUNK
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
end_define
begin_define
DECL|macro|CHECK_INUSE_CHUNK
define|#
directive|define
name|CHECK_INUSE_CHUNK
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
end_define
begin_define
DECL|macro|CHECK_MALLOCED_CHUNK
define|#
directive|define
name|CHECK_MALLOCED_CHUNK
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|,
name|N
parameter_list|)
end_define
begin_define
DECL|macro|CHECK_MMAPPED_CHUNK
define|#
directive|define
name|CHECK_MMAPPED_CHUNK
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
end_define
begin_define
DECL|macro|CHECK_MALLOC_STATE
define|#
directive|define
name|CHECK_MALLOC_STATE
parameter_list|(
name|M
parameter_list|)
end_define
begin_define
DECL|macro|CHECK_TOP_CHUNK
define|#
directive|define
name|CHECK_TOP_CHUNK
parameter_list|(
name|M
parameter_list|,
name|P
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DEBUG */
end_comment
begin_comment
comment|/* ---------------------------- Indexing Bins ---------------------------- */
end_comment
begin_define
DECL|macro|IS_SMALL
define|#
directive|define
name|IS_SMALL
parameter_list|(
name|s
parameter_list|)
value|(((s)>> SMALLBIN_SHIFT)< NSMALLBINS)
end_define
begin_define
DECL|macro|SMALL_INDEX
define|#
directive|define
name|SMALL_INDEX
parameter_list|(
name|s
parameter_list|)
value|((s)>> SMALLBIN_SHIFT)
end_define
begin_define
DECL|macro|SMALL_INDEX2SIZE
define|#
directive|define
name|SMALL_INDEX2SIZE
parameter_list|(
name|i
parameter_list|)
value|((i)<< SMALLBIN_SHIFT)
end_define
begin_define
DECL|macro|MIN_SMALL_INDEX
define|#
directive|define
name|MIN_SMALL_INDEX
value|(SMALL_INDEX(MIN_CHUNK_SIZE))
end_define
begin_comment
comment|/* addressing by index. See above about smallbin repositioning */
end_comment
begin_define
DECL|macro|SMALLBIN_AT
define|#
directive|define
name|SMALLBIN_AT
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((sbinptr)((TUint8*)&((M)->iSmallBins[(i)<<1])))
end_define
begin_define
DECL|macro|TREEBIN_AT
define|#
directive|define
name|TREEBIN_AT
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|(&((M)->iTreeBins[i]))
end_define
begin_comment
comment|/* Bit representing maximum resolved size in a treebin at i */
end_comment
begin_define
DECL|macro|BIT_FOR_TREE_INDEX
define|#
directive|define
name|BIT_FOR_TREE_INDEX
parameter_list|(
name|i
parameter_list|)
value|(i == NTREEBINS-1)? (SIZE_T_BITSIZE-1) : (((i)>> 1) + TREEBIN_SHIFT - 2)
end_define
begin_comment
comment|/* Shift placing maximum resolved bit in a treebin at i as sign bit */
end_comment
begin_define
DECL|macro|LEFTSHIFT_FOR_TREE_INDEX
define|#
directive|define
name|LEFTSHIFT_FOR_TREE_INDEX
parameter_list|(
name|i
parameter_list|)
value|((i == NTREEBINS-1)? 0 : ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i)>> 1) + TREEBIN_SHIFT - 2)))
end_define
begin_comment
comment|/* The size of the smallest chunk held in bin with index i */
end_comment
begin_define
DECL|macro|MINSIZE_FOR_TREE_INDEX
define|#
directive|define
name|MINSIZE_FOR_TREE_INDEX
parameter_list|(
name|i
parameter_list|)
value|((SIZE_T_ONE<< (((i)>> 1) + TREEBIN_SHIFT)) |  (((size_t)((i)& SIZE_T_ONE))<< (((i)>> 1) + TREEBIN_SHIFT - 1)))
end_define
begin_comment
comment|/* ------------------------ Operations on bin maps ----------------------- */
end_comment
begin_comment
comment|/* bit corresponding to given index */
end_comment
begin_define
DECL|macro|IDX2BIT
define|#
directive|define
name|IDX2BIT
parameter_list|(
name|i
parameter_list|)
value|((binmap_t)(1)<< (i))
end_define
begin_comment
comment|/* Mark/Clear bits with given index */
end_comment
begin_define
DECL|macro|MARK_SMALLMAP
define|#
directive|define
name|MARK_SMALLMAP
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((M)->iSmallMap |=  IDX2BIT(i))
end_define
begin_define
DECL|macro|CLEAR_SMALLMAP
define|#
directive|define
name|CLEAR_SMALLMAP
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((M)->iSmallMap&= ~IDX2BIT(i))
end_define
begin_define
DECL|macro|SMALLMAP_IS_MARKED
define|#
directive|define
name|SMALLMAP_IS_MARKED
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((M)->iSmallMap&   IDX2BIT(i))
end_define
begin_define
DECL|macro|MARK_TREEMAP
define|#
directive|define
name|MARK_TREEMAP
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((M)->iTreeMap  |=  IDX2BIT(i))
end_define
begin_define
DECL|macro|CLEAR_TREEMAP
define|#
directive|define
name|CLEAR_TREEMAP
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((M)->iTreeMap&= ~IDX2BIT(i))
end_define
begin_define
DECL|macro|TREEMAP_IS_MARKED
define|#
directive|define
name|TREEMAP_IS_MARKED
parameter_list|(
name|M
parameter_list|,
name|i
parameter_list|)
value|((M)->iTreeMap&   IDX2BIT(i))
end_define
begin_comment
comment|/* isolate the least set bit of a bitmap */
end_comment
begin_define
DECL|macro|LEAST_BIT
define|#
directive|define
name|LEAST_BIT
parameter_list|(
name|x
parameter_list|)
value|((x)& -(x))
end_define
begin_comment
comment|/* mask with all bits to left of least bit of x on */
end_comment
begin_define
DECL|macro|LEFT_BITS
define|#
directive|define
name|LEFT_BITS
parameter_list|(
name|x
parameter_list|)
value|((x<<1) | -(x<<1))
end_define
begin_comment
comment|/* mask with all bits to left of or equal to least bit of x on */
end_comment
begin_define
DECL|macro|SAME_OR_LEFT_BITS
define|#
directive|define
name|SAME_OR_LEFT_BITS
parameter_list|(
name|x
parameter_list|)
value|((x) | -(x))
end_define
begin_if
if|#
directive|if
operator|!
name|INSECURE
end_if
begin_comment
comment|/* Check if address a is at least as high as any from MORECORE or MMAP */
end_comment
begin_define
DECL|macro|OK_ADDRESS
define|#
directive|define
name|OK_ADDRESS
parameter_list|(
name|M
parameter_list|,
name|a
parameter_list|)
value|((TUint8*)(a)>= (M)->iLeastAddr)
end_define
begin_comment
comment|/* Check if address of next chunk n is higher than base chunk p */
end_comment
begin_define
DECL|macro|OK_NEXT
define|#
directive|define
name|OK_NEXT
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
value|((TUint8*)(p)< (TUint8*)(n))
end_define
begin_comment
comment|/* Check if p has its CINUSE bit on */
end_comment
begin_define
DECL|macro|OK_CINUSE
define|#
directive|define
name|OK_CINUSE
parameter_list|(
name|p
parameter_list|)
value|CINUSE(p)
end_define
begin_comment
comment|/* Check if p has its PINUSE bit on */
end_comment
begin_define
DECL|macro|OK_PINUSE
define|#
directive|define
name|OK_PINUSE
parameter_list|(
name|p
parameter_list|)
value|PINUSE(p)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !INSECURE */
end_comment
begin_define
DECL|macro|OK_ADDRESS
define|#
directive|define
name|OK_ADDRESS
parameter_list|(
name|M
parameter_list|,
name|a
parameter_list|)
value|(1)
end_define
begin_define
DECL|macro|OK_NEXT
define|#
directive|define
name|OK_NEXT
parameter_list|(
name|b
parameter_list|,
name|n
parameter_list|)
value|(1)
end_define
begin_define
DECL|macro|OK_CINUSE
define|#
directive|define
name|OK_CINUSE
parameter_list|(
name|p
parameter_list|)
value|(1)
end_define
begin_define
DECL|macro|OK_PINUSE
define|#
directive|define
name|OK_PINUSE
parameter_list|(
name|p
parameter_list|)
value|(1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !INSECURE */
end_comment
begin_if
if|#
directive|if
operator|(
name|FOOTERS
operator|&&
operator|!
name|INSECURE
operator|)
end_if
begin_comment
comment|/* Check if (alleged) mstate m has expected iMagic field */
end_comment
begin_define
DECL|macro|OK_MAGIC
define|#
directive|define
name|OK_MAGIC
parameter_list|(
name|M
parameter_list|)
value|((M)->iMagic == mparams.iMagic)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* (FOOTERS&& !INSECURE) */
end_comment
begin_define
DECL|macro|OK_MAGIC
define|#
directive|define
name|OK_MAGIC
parameter_list|(
name|M
parameter_list|)
value|(1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* (FOOTERS&& !INSECURE) */
end_comment
begin_comment
comment|/* In gcc, use __builtin_expect to minimize impact of checks */
end_comment
begin_if
if|#
directive|if
operator|!
name|INSECURE
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|3
end_if
begin_define
DECL|macro|RTCHECK
define|#
directive|define
name|RTCHECK
parameter_list|(
name|e
parameter_list|)
value|__builtin_expect(e, 1)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* GNUC */
end_comment
begin_define
DECL|macro|RTCHECK
define|#
directive|define
name|RTCHECK
parameter_list|(
name|e
parameter_list|)
value|(e)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* GNUC */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !INSECURE */
end_comment
begin_define
DECL|macro|RTCHECK
define|#
directive|define
name|RTCHECK
parameter_list|(
name|e
parameter_list|)
value|(1)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !INSECURE */
end_comment
begin_comment
comment|/* macros to set up inuse chunks with or without footers */
end_comment
begin_if
if|#
directive|if
operator|!
name|FOOTERS
end_if
begin_define
DECL|macro|MARK_INUSE_FOOT
define|#
directive|define
name|MARK_INUSE_FOOT
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
end_define
begin_comment
comment|/* Set CINUSE bit and PINUSE bit of next chunk */
end_comment
begin_define
DECL|macro|SET_INUSE
define|#
directive|define
name|SET_INUSE
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
value|((p)->iHead = (((p)->iHead& PINUSE_BIT)|s|CINUSE_BIT),((mchunkptr)(((TUint8*)(p)) + (s)))->iHead |= PINUSE_BIT)
end_define
begin_comment
comment|/* Set CINUSE and PINUSE of this chunk and PINUSE of next chunk */
end_comment
begin_define
DECL|macro|SET_INUSE_AND_PINUSE
define|#
directive|define
name|SET_INUSE_AND_PINUSE
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
value|((p)->iHead = (s|PINUSE_BIT|CINUSE_BIT),((mchunkptr)(((TUint8*)(p)) + (s)))->iHead |= PINUSE_BIT)
end_define
begin_comment
comment|/* Set size, CINUSE and PINUSE bit of this chunk */
end_comment
begin_define
DECL|macro|SET_SIZE_AND_PINUSE_OF_INUSE_CHUNK
define|#
directive|define
name|SET_SIZE_AND_PINUSE_OF_INUSE_CHUNK
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
value|((p)->iHead = (s|PINUSE_BIT|CINUSE_BIT))
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* FOOTERS */
end_comment
begin_comment
comment|/* Set foot of inuse chunk to be xor of mstate and seed */
end_comment
begin_define
DECL|macro|MARK_INUSE_FOOT
define|#
directive|define
name|MARK_INUSE_FOOT
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
value|(((mchunkptr)((TUint8*)(p) + (s)))->iPrevFoot = ((size_t)(M) ^ mparams.iMagic))
end_define
begin_define
DECL|macro|GET_MSTATE_FOR
define|#
directive|define
name|GET_MSTATE_FOR
parameter_list|(
name|p
parameter_list|)
value|((mstate)(((mchunkptr)((TUint8*)(p)+(CHUNKSIZE(p))))->iPrevFoot ^ mparams.iMagic))
end_define
begin_define
DECL|macro|SET_INUSE
define|#
directive|define
name|SET_INUSE
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|((p)->iHead = (((p)->iHead& PINUSE_BIT)|s|CINUSE_BIT),\ 		(((mchunkptr)(((TUint8*)(p)) + (s)))->iHead |= PINUSE_BIT), \ 		MARK_INUSE_FOOT(M,p,s))
end_define
begin_define
DECL|macro|SET_INUSE_AND_PINUSE
define|#
directive|define
name|SET_INUSE_AND_PINUSE
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|((p)->iHead = (s|PINUSE_BIT|CINUSE_BIT),\ 	(((mchunkptr)(((TUint8*)(p)) + (s)))->iHead |= PINUSE_BIT),\ 	MARK_INUSE_FOOT(M,p,s))
end_define
begin_define
DECL|macro|SET_SIZE_AND_PINUSE_OF_INUSE_CHUNK
define|#
directive|define
name|SET_SIZE_AND_PINUSE_OF_INUSE_CHUNK
parameter_list|(
name|M
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|)
define|\
value|((p)->iHead = (s|PINUSE_BIT|CINUSE_BIT),\ 	MARK_INUSE_FOOT(M, p, s))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FOOTERS */
end_comment
begin_if
if|#
directive|if
name|ONLY_MSPACES
end_if
begin_define
DECL|macro|INTERNAL_MALLOC
define|#
directive|define
name|INTERNAL_MALLOC
parameter_list|(
name|m
parameter_list|,
name|b
parameter_list|)
value|mspace_malloc(m, b)
end_define
begin_define
DECL|macro|INTERNAL_FREE
define|#
directive|define
name|INTERNAL_FREE
parameter_list|(
name|m
parameter_list|,
name|mem
parameter_list|)
value|mspace_free(m,mem);
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_if
if|#
directive|if
name|MSPACES
end_if
begin_define
DECL|macro|INTERNAL_MALLOC
define|#
directive|define
name|INTERNAL_MALLOC
parameter_list|(
name|m
parameter_list|,
name|b
parameter_list|)
value|(m == GM)? dlmalloc(b) : mspace_malloc(m, b)
end_define
begin_define
DECL|macro|INTERNAL_FREE
define|#
directive|define
name|INTERNAL_FREE
parameter_list|(
name|m
parameter_list|,
name|mem
parameter_list|)
value|if (m == GM) dlfree(mem); else mspace_free(m,mem);
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* MSPACES */
end_comment
begin_define
DECL|macro|INTERNAL_MALLOC
define|#
directive|define
name|INTERNAL_MALLOC
parameter_list|(
name|m
parameter_list|,
name|b
parameter_list|)
value|dlmalloc(b)
end_define
begin_define
DECL|macro|INTERNAL_FREE
define|#
directive|define
name|INTERNAL_FREE
parameter_list|(
name|m
parameter_list|,
name|mem
parameter_list|)
value|dlfree(mem)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MSPACES */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* ONLY_MSPACES */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef
begin_define
DECL|macro|CHECKING
define|#
directive|define
name|CHECKING
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//  #define HYSTERESIS 4
end_comment
begin_define
DECL|macro|HYSTERESIS
define|#
directive|define
name|HYSTERESIS
value|1
end_define
begin_define
DECL|macro|HYSTERESIS_BYTES
define|#
directive|define
name|HYSTERESIS_BYTES
value|(2*PAGESIZE)
end_define
begin_define
DECL|macro|HYSTERESIS_GROW
define|#
directive|define
name|HYSTERESIS_GROW
value|(HYSTERESIS*PAGESIZE)
end_define
begin_if
if|#
directive|if
name|CHECKING
end_if
begin_define
DECL|macro|CHECK
define|#
directive|define
name|CHECK
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_else
else|#
directive|else
end_else
begin_undef
DECL|macro|ASSERT
undef|#
directive|undef
name|ASSERT
end_undef
begin_define
DECL|macro|ASSERT
define|#
directive|define
name|ASSERT
parameter_list|(
name|x
parameter_list|)
value|(void)0
end_define
begin_define
DECL|macro|CHECK
define|#
directive|define
name|CHECK
parameter_list|(
name|x
parameter_list|)
value|(void)0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*__DLA__*/
end_comment
end_unit
