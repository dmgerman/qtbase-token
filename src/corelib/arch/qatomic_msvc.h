begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Copyright (C) 2016 Intel Corporation. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QATOMIC_MSVC_H
end_ifndef
begin_define
DECL|macro|QATOMIC_MSVC_H
define|#
directive|define
name|QATOMIC_MSVC_H
end_define
begin_include
include|#
directive|include
file|<QtCore/qgenericatomic.h>
end_include
begin_comment
comment|////////////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_WINCE
end_ifndef
begin_comment
comment|// use compiler intrinsics for all atomic functions
end_comment
begin_define
DECL|macro|QT_INTERLOCKED_PREFIX
define|#
directive|define
name|QT_INTERLOCKED_PREFIX
value|_
end_define
begin_define
DECL|macro|QT_INTERLOCKED_PROTOTYPE
define|#
directive|define
name|QT_INTERLOCKED_PROTOTYPE
end_define
begin_define
DECL|macro|QT_INTERLOCKED_DECLARE_PROTOTYPES
define|#
directive|define
name|QT_INTERLOCKED_DECLARE_PROTOTYPES
end_define
begin_define
DECL|macro|QT_INTERLOCKED_INTRINSIC
define|#
directive|define
name|QT_INTERLOCKED_INTRINSIC
end_define
begin_define
DECL|macro|Q_ATOMIC_INT16_IS_SUPPORTED
define|#
directive|define
name|Q_ATOMIC_INT16_IS_SUPPORTED
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|_WIN64
end_ifdef
begin_define
DECL|macro|Q_ATOMIC_INT64_IS_SUPPORTED
define|#
directive|define
name|Q_ATOMIC_INT64_IS_SUPPORTED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_comment
comment|// Q_OS_WINCE
end_comment
begin_if
if|#
directive|if
name|_WIN32_WCE
operator|<
literal|0x600
operator|&&
name|defined
argument_list|(
name|_X86_
argument_list|)
end_if
begin_comment
comment|// For X86 Windows CE, include winbase.h to catch inline functions which
end_comment
begin_comment
comment|// override the regular definitions inside of coredll.dll.
end_comment
begin_comment
comment|// Though one could use the original version of Increment/Decrement, others are
end_comment
begin_comment
comment|// not exported at all.
end_comment
begin_include
include|#
directive|include
file|<winbase.h>
end_include
begin_comment
comment|// It's safer to remove the volatile and let the compiler add it as needed.
end_comment
begin_define
DECL|macro|QT_INTERLOCKED_VOLATILE
define|#
directive|define
name|QT_INTERLOCKED_VOLATILE
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|// _WIN32_WCE>= 0x600 || !_X86_
end_comment
begin_define
DECL|macro|QT_INTERLOCKED_PROTOTYPE
define|#
directive|define
name|QT_INTERLOCKED_PROTOTYPE
value|__cdecl
end_define
begin_define
DECL|macro|QT_INTERLOCKED_DECLARE_PROTOTYPES
define|#
directive|define
name|QT_INTERLOCKED_DECLARE_PROTOTYPES
end_define
begin_if
if|#
directive|if
name|_WIN32_WCE
operator|>=
literal|0x600
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_X86_
argument_list|)
end_if
begin_define
DECL|macro|QT_INTERLOCKED_PREFIX
define|#
directive|define
name|QT_INTERLOCKED_PREFIX
value|_
end_define
begin_define
DECL|macro|QT_INTERLOCKED_INTRINSIC
define|#
directive|define
name|QT_INTERLOCKED_INTRINSIC
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_INTERLOCKED_VOLATILE
define|#
directive|define
name|QT_INTERLOCKED_VOLATILE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// _WIN32_WCE>= 0x600 || !_X86_
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_OS_WINCE
end_comment
begin_comment
comment|////////////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|// Prototype declaration
end_comment
begin_define
DECL|macro|QT_INTERLOCKED_CONCAT_I
define|#
directive|define
name|QT_INTERLOCKED_CONCAT_I
parameter_list|(
name|prefix
parameter_list|,
name|suffix
parameter_list|)
define|\
value|prefix ## suffix
end_define
begin_define
DECL|macro|QT_INTERLOCKED_CONCAT
define|#
directive|define
name|QT_INTERLOCKED_CONCAT
parameter_list|(
name|prefix
parameter_list|,
name|suffix
parameter_list|)
define|\
value|QT_INTERLOCKED_CONCAT_I(prefix, suffix)
end_define
begin_comment
comment|// MSVC intrinsics prefix function names with an underscore. Also, if platform
end_comment
begin_comment
comment|// SDK headers have been included, the Interlocked names may be defined as
end_comment
begin_comment
comment|// macros.
end_comment
begin_comment
comment|// To avoid double underscores, we paste the prefix with Interlocked first and
end_comment
begin_comment
comment|// then the remainder of the function name.
end_comment
begin_define
DECL|macro|QT_INTERLOCKED_FUNCTION
define|#
directive|define
name|QT_INTERLOCKED_FUNCTION
parameter_list|(
name|name
parameter_list|)
define|\
value|QT_INTERLOCKED_CONCAT( \         QT_INTERLOCKED_CONCAT(QT_INTERLOCKED_PREFIX, Interlocked), name)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_INTERLOCKED_VOLATILE
end_ifndef
begin_define
DECL|macro|QT_INTERLOCKED_VOLATILE
define|#
directive|define
name|QT_INTERLOCKED_VOLATILE
value|volatile
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_INTERLOCKED_PREFIX
end_ifndef
begin_define
DECL|macro|QT_INTERLOCKED_PREFIX
define|#
directive|define
name|QT_INTERLOCKED_PREFIX
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_INTERLOCKED_PROTOTYPE
end_ifndef
begin_define
DECL|macro|QT_INTERLOCKED_PROTOTYPE
define|#
directive|define
name|QT_INTERLOCKED_PROTOTYPE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_INTERLOCKED_DECLARE_PROTOTYPES
end_ifdef
begin_undef
DECL|macro|QT_INTERLOCKED_DECLARE_PROTOTYPES
undef|#
directive|undef
name|QT_INTERLOCKED_DECLARE_PROTOTYPES
end_undef
begin_extern
extern|extern
literal|"C"
block|{
name|long
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|Increment
function_decl|)
parameter_list|(
name|long
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|)
function_decl|;
name|long
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|Decrement
function_decl|)
parameter_list|(
name|long
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|)
function_decl|;
name|long
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|CompareExchange
function_decl|)
parameter_list|(
name|long
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|,
name|long
parameter_list|,
name|long
parameter_list|)
function_decl|;
name|long
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|Exchange
function_decl|)
parameter_list|(
name|long
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
name|long
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|ExchangeAdd
function_decl|)
parameter_list|(
name|long
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_M_IX86
argument_list|)
name|void
modifier|*
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|CompareExchangePointer
function_decl|)
parameter_list|(
name|void
modifier|*
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|ExchangePointer
function_decl|)
parameter_list|(
name|void
modifier|*
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|__int64
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|ExchangeAdd64
function_decl|)
parameter_list|(
name|__int64
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|,
name|__int64
parameter_list|)
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_ATOMIC_INT16_IS_SUPPORTED
name|short
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|Increment16
function_decl|)
parameter_list|(
name|short
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|)
function_decl|;
name|short
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|Decrement16
function_decl|)
parameter_list|(
name|short
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|)
function_decl|;
name|short
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|CompareExchange16
function_decl|)
parameter_list|(
name|short
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|,
name|short
parameter_list|,
name|short
parameter_list|)
function_decl|;
name|short
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|Exchange16
function_decl|)
parameter_list|(
name|short
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
name|short
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|ExchangeAdd16
function_decl|)
parameter_list|(
name|short
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_ATOMIC_INT64_IS_SUPPORTED
name|__int64
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|Increment64
function_decl|)
parameter_list|(
name|__int64
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|)
function_decl|;
name|__int64
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|Decrement64
function_decl|)
parameter_list|(
name|__int64
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|)
function_decl|;
name|__int64
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|CompareExchange64
function_decl|)
parameter_list|(
name|__int64
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|,
name|__int64
parameter_list|,
name|__int64
parameter_list|)
function_decl|;
name|__int64
name|QT_INTERLOCKED_PROTOTYPE
name|QT_INTERLOCKED_FUNCTION
function_decl|(
name|Exchange64
function_decl|)
parameter_list|(
name|__int64
name|QT_INTERLOCKED_VOLATILE
modifier|*
parameter_list|,
name|__int64
parameter_list|)
function_decl|;
comment|//above already: qint64 QT_INTERLOCKED_PROTOTYPE QT_INTERLOCKED_FUNCTION( ExchangeAdd64 )(qint64 QT_INTERLOCKED_VOLATILE *, qint64);
endif|#
directive|endif
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_INTERLOCKED_DECLARE_PROTOTYPES
end_comment
begin_undef
DECL|macro|QT_INTERLOCKED_PROTOTYPE
undef|#
directive|undef
name|QT_INTERLOCKED_PROTOTYPE
end_undef
begin_comment
comment|////////////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_INTERLOCKED_INTRINSIC
end_ifdef
begin_undef
DECL|macro|QT_INTERLOCKED_INTRINSIC
undef|#
directive|undef
name|QT_INTERLOCKED_INTRINSIC
end_undef
begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_InterlockedIncrement
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_InterlockedDecrement
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_InterlockedExchange
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_InterlockedCompareExchange
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_InterlockedExchangeAdd
name|)
end_pragma
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_M_IX86
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_InterlockedCompareExchangePointer
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_InterlockedExchangePointer
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_InterlockedExchangeAdd64
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_INTERLOCKED_INTRINSIC
end_comment
begin_comment
comment|////////////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|// Interlocked* replacement macros
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_IX86
argument_list|)
end_if
begin_define
DECL|macro|QT_INTERLOCKED_COMPARE_EXCHANGE_POINTER
define|#
directive|define
name|QT_INTERLOCKED_COMPARE_EXCHANGE_POINTER
parameter_list|(
name|value
parameter_list|,
name|newValue
parameter_list|,
name|expectedValue
parameter_list|)
define|\
value|reinterpret_cast<void *>( \         QT_INTERLOCKED_FUNCTION(CompareExchange)( \                 reinterpret_cast<long QT_INTERLOCKED_VOLATILE *>(value), \                 long(newValue), \                 long(expectedValue)))
end_define
begin_define
DECL|macro|QT_INTERLOCKED_EXCHANGE_POINTER
define|#
directive|define
name|QT_INTERLOCKED_EXCHANGE_POINTER
parameter_list|(
name|value
parameter_list|,
name|newValue
parameter_list|)
define|\
value|QT_INTERLOCKED_FUNCTION(Exchange)( \             reinterpret_cast<long QT_INTERLOCKED_VOLATILE *>(value), \             long(newValue))
end_define
begin_define
DECL|macro|QT_INTERLOCKED_EXCHANGE_ADD_POINTER
define|#
directive|define
name|QT_INTERLOCKED_EXCHANGE_ADD_POINTER
parameter_list|(
name|value
parameter_list|,
name|valueToAdd
parameter_list|)
define|\
value|QT_INTERLOCKED_FUNCTION(ExchangeAdd)( \             reinterpret_cast<long QT_INTERLOCKED_VOLATILE *>(value), \             (valueToAdd))
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|// !defined(Q_OS_WINCE)&& !defined(__i386__)&& !defined(_M_IX86)
end_comment
begin_define
DECL|macro|QT_INTERLOCKED_COMPARE_EXCHANGE_POINTER
define|#
directive|define
name|QT_INTERLOCKED_COMPARE_EXCHANGE_POINTER
parameter_list|(
name|value
parameter_list|,
name|newValue
parameter_list|,
name|expectedValue
parameter_list|)
define|\
value|QT_INTERLOCKED_FUNCTION(CompareExchangePointer)( \             (void * QT_INTERLOCKED_VOLATILE *)(value), \             (void *) (newValue), \             (void *) (expectedValue))
end_define
begin_define
DECL|macro|QT_INTERLOCKED_EXCHANGE_POINTER
define|#
directive|define
name|QT_INTERLOCKED_EXCHANGE_POINTER
parameter_list|(
name|value
parameter_list|,
name|newValue
parameter_list|)
define|\
value|QT_INTERLOCKED_FUNCTION(ExchangePointer)( \             (void * QT_INTERLOCKED_VOLATILE *)(value), \             (void *) (newValue))
end_define
begin_define
DECL|macro|QT_INTERLOCKED_EXCHANGE_ADD_POINTER
define|#
directive|define
name|QT_INTERLOCKED_EXCHANGE_ADD_POINTER
parameter_list|(
name|value
parameter_list|,
name|valueToAdd
parameter_list|)
define|\
value|QT_INTERLOCKED_FUNCTION(ExchangeAdd64)( \             reinterpret_cast<qint64 QT_INTERLOCKED_VOLATILE *>(value), \             (valueToAdd))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !defined(Q_OS_WINCE)&& !defined(__i386__)&& !defined(_M_IX86)
end_comment
begin_comment
comment|////////////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_expr_stmt
name|QT_BEGIN_NAMESPACE
if|#
directive|if
literal|0
comment|// silence syncqt warnings
expr|QT_END_NAMESPACE
pragma|#
directive|pragma
name|qt_sync_skip_header_check
pragma|#
directive|pragma
name|qt_sync_stop_processing
endif|#
directive|endif
DECL|macro|Q_ATOMIC_INT_REFERENCE_COUNTING_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT_REFERENCE_COUNTING_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_INT_REFERENCE_COUNTING_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT_REFERENCE_COUNTING_IS_WAIT_FREE
DECL|macro|Q_ATOMIC_INT_TEST_AND_SET_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT_TEST_AND_SET_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_INT_TEST_AND_SET_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT_TEST_AND_SET_IS_WAIT_FREE
DECL|macro|Q_ATOMIC_INT_FETCH_AND_STORE_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT_FETCH_AND_STORE_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_INT_FETCH_AND_STORE_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT_FETCH_AND_STORE_IS_WAIT_FREE
DECL|macro|Q_ATOMIC_INT_FETCH_AND_ADD_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT_FETCH_AND_ADD_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_INT_FETCH_AND_ADD_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT_FETCH_AND_ADD_IS_WAIT_FREE
DECL|macro|Q_ATOMIC_INT32_IS_SUPPORTED
define|#
directive|define
name|Q_ATOMIC_INT32_IS_SUPPORTED
DECL|macro|Q_ATOMIC_INT32_REFERENCE_COUNTING_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT32_REFERENCE_COUNTING_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_INT32_REFERENCE_COUNTING_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT32_REFERENCE_COUNTING_IS_WAIT_FREE
DECL|macro|Q_ATOMIC_INT32_TEST_AND_SET_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT32_TEST_AND_SET_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_INT32_TEST_AND_SET_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT32_TEST_AND_SET_IS_WAIT_FREE
DECL|macro|Q_ATOMIC_INT32_FETCH_AND_STORE_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT32_FETCH_AND_STORE_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_INT32_FETCH_AND_STORE_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT32_FETCH_AND_STORE_IS_WAIT_FREE
DECL|macro|Q_ATOMIC_INT32_FETCH_AND_ADD_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT32_FETCH_AND_ADD_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_INT32_FETCH_AND_ADD_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT32_FETCH_AND_ADD_IS_WAIT_FREE
DECL|macro|Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE
DECL|macro|Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE
DECL|macro|Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE
ifdef|#
directive|ifdef
name|Q_ATOMIC_INT16_IS_SUPPORTED
DECL|macro|Q_ATOMIC_INT16_REFERENCE_COUNTING_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT16_REFERENCE_COUNTING_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_INT16_REFERENCE_COUNTING_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT16_REFERENCE_COUNTING_IS_WAIT_FREE
DECL|macro|Q_ATOMIC_INT16_TEST_AND_SET_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT16_TEST_AND_SET_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_INT16_TEST_AND_SET_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT16_TEST_AND_SET_IS_WAIT_FREE
DECL|macro|Q_ATOMIC_INT16_FETCH_AND_STORE_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT16_FETCH_AND_STORE_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_INT16_FETCH_AND_STORE_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT16_FETCH_AND_STORE_IS_WAIT_FREE
DECL|macro|Q_ATOMIC_INT16_FETCH_AND_ADD_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT16_FETCH_AND_ADD_IS_ALWAYS_NATIVE
DECL|macro|Q_ATOMIC_INT16_FETCH_AND_ADD_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT16_FETCH_AND_ADD_IS_WAIT_FREE
DECL|struct|QAtomicOpsSupport
DECL|enumerator|IsSupported
name|template
operator|<
operator|>
expr|struct
name|QAtomicOpsSupport
operator|<
literal|2
operator|>
block|{ enum
block|{
name|IsSupported
operator|=
literal|1
block|}
block|; }
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_ATOMIC_INT64_IS_SUPPORTED
end_ifdef
begin_define
DECL|macro|Q_ATOMIC_INT64_REFERENCE_COUNTING_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT64_REFERENCE_COUNTING_IS_ALWAYS_NATIVE
end_define
begin_define
DECL|macro|Q_ATOMIC_INT64_REFERENCE_COUNTING_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT64_REFERENCE_COUNTING_IS_WAIT_FREE
end_define
begin_define
DECL|macro|Q_ATOMIC_INT64_TEST_AND_SET_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT64_TEST_AND_SET_IS_ALWAYS_NATIVE
end_define
begin_define
DECL|macro|Q_ATOMIC_INT64_TEST_AND_SET_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT64_TEST_AND_SET_IS_WAIT_FREE
end_define
begin_define
DECL|macro|Q_ATOMIC_INT64_FETCH_AND_STORE_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT64_FETCH_AND_STORE_IS_ALWAYS_NATIVE
end_define
begin_define
DECL|macro|Q_ATOMIC_INT64_FETCH_AND_STORE_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT64_FETCH_AND_STORE_IS_WAIT_FREE
end_define
begin_define
DECL|macro|Q_ATOMIC_INT64_FETCH_AND_ADD_IS_ALWAYS_NATIVE
define|#
directive|define
name|Q_ATOMIC_INT64_FETCH_AND_ADD_IS_ALWAYS_NATIVE
end_define
begin_define
DECL|macro|Q_ATOMIC_INT64_FETCH_AND_ADD_IS_WAIT_FREE
define|#
directive|define
name|Q_ATOMIC_INT64_FETCH_AND_ADD_IS_WAIT_FREE
end_define
begin_expr_stmt
DECL|struct|QAtomicOpsSupport
DECL|enumerator|IsSupported
name|template
operator|<
operator|>
expr|struct
name|QAtomicOpsSupport
operator|<
literal|8
operator|>
block|{ enum
block|{
name|IsSupported
operator|=
literal|1
block|}
block|; }
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|////////////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_expr_stmt
DECL|struct|QAtomicWindowsType
DECL|typedef|Type
name|template
operator|<
name|int
name|N
operator|>
expr|struct
name|QAtomicWindowsType
block|{
typedef|typedef
name|typename
name|QIntegerForSize
operator|<
name|N
operator|>
operator|::
name|Signed
name|Type
expr_stmt|;
block|}
end_expr_stmt
begin_empty_stmt
DECL|struct|QAtomicWindowsType
DECL|typedef|Type
empty_stmt|;
end_empty_stmt
begin_expr_stmt
DECL|struct|QAtomicWindowsType
DECL|typedef|Type
name|template
operator|<
operator|>
expr|struct
name|QAtomicWindowsType
operator|<
literal|4
operator|>
block|{
typedef|typedef
name|long
name|Type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
DECL|struct|QAtomicWindowsType
DECL|typedef|Type
empty_stmt|;
end_empty_stmt
begin_expr_stmt
DECL|struct|N
name|template
operator|<
name|int
name|N
operator|>
expr|struct
name|QAtomicOpsBySize
operator|:
name|QGenericAtomicOps
operator|<
name|QAtomicOpsBySize
operator|<
name|N
operator|>
expr|>
block|{
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isReferenceCountingNative
argument_list|()
name|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isReferenceCountingWaitFree
argument_list|()
name|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|member|Q_DECL_NOTHROW
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|bool
name|ref
argument_list|(
argument|T&_q_value
argument_list|)
name|Q_DECL_NOTHROW
expr_stmt|;
end_expr_stmt
begin_expr_stmt
DECL|member|Q_DECL_NOTHROW
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|bool
name|deref
argument_list|(
argument|T&_q_value
argument_list|)
name|Q_DECL_NOTHROW
expr_stmt|;
end_expr_stmt
begin_function
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isTestAndSetNative
parameter_list|()
function|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isTestAndSetWaitFree
parameter_list|()
function|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
end_function
begin_expr_stmt
DECL|member|Q_DECL_NOTHROW
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|bool
name|testAndSetRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|T expectedValue
argument_list|,
argument|T newValue
argument_list|)
name|Q_DECL_NOTHROW
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|member|Q_DECL_NOTHROW
specifier|static
name|bool
name|testAndSetRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|T expectedValue
argument_list|,
argument|T newValue
argument_list|,
argument|T *currentValue
argument_list|)
name|Q_DECL_NOTHROW
expr_stmt|;
end_expr_stmt
begin_function
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isFetchAndStoreNative
parameter_list|()
function|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isFetchAndStoreWaitFree
parameter_list|()
function|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
end_function
begin_expr_stmt
DECL|member|Q_DECL_NOTHROW
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|T
name|fetchAndStoreRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|T newValue
argument_list|)
name|Q_DECL_NOTHROW
expr_stmt|;
end_expr_stmt
begin_function
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isFetchAndAddNative
parameter_list|()
function|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isFetchAndAddWaitFree
parameter_list|()
function|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
end_function
begin_expr_stmt
DECL|member|Q_DECL_NOTHROW
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|T
name|fetchAndAddRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|typename QAtomicAdditiveType<T>::AdditiveT valueToAdd
argument_list|)
name|Q_DECL_NOTHROW
expr_stmt|;
end_expr_stmt
begin_label
DECL|member|private
name|private
label|:
end_label
begin_typedef
typedef|typedef
name|typename
name|QAtomicWindowsType
operator|<
name|N
operator|>
operator|::
name|Type
name|Type
expr_stmt|;
end_typedef
begin_expr_stmt
DECL|function|atomic
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
specifier|inline
name|Type
operator|*
name|atomic
argument_list|(
argument|T *t
argument_list|)
block|{
name|Q_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|Type
argument_list|)
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
name|Type
operator|*
operator|>
operator|(
name|t
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|value
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
specifier|inline
name|Type
name|value
argument_list|(
argument|T t
argument_list|)
block|{
name|Q_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|Type
argument_list|)
argument_list|)
block|;
return|return
name|Type
argument_list|(
name|t
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
DECL|function|sizeof
name|QAtomicOps
operator|:
name|QAtomicOpsBySize
operator|<
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|>
block|{
typedef|typedef
name|T
name|Type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOpsBySize
operator|<
literal|4
operator|>
operator|::
name|ref
argument_list|(
argument|T&_q_value
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|Increment
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOpsBySize
operator|<
literal|4
operator|>
operator|::
name|deref
argument_list|(
argument|T&_q_value
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|Decrement
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOpsBySize
operator|<
literal|4
operator|>
operator|::
name|testAndSetRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|T expectedValue
argument_list|,
argument|T newValue
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|CompareExchange
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|,
name|value
argument_list|(
name|newValue
argument_list|)
argument_list|,
name|value
argument_list|(
name|expectedValue
argument_list|)
argument_list|)
operator|==
name|value
argument_list|(
name|expectedValue
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOpsBySize
operator|<
literal|4
operator|>
operator|::
name|testAndSetRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|T expectedValue
argument_list|,
argument|T newValue
argument_list|,
argument|T *currentValue
argument_list|)
name|Q_DECL_NOTHROW
block|{
operator|*
name|currentValue
operator|=
name|T
argument_list|(
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|CompareExchange
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|,
name|newValue
argument_list|,
name|expectedValue
argument_list|)
argument_list|)
block|;
return|return
operator|*
name|currentValue
operator|==
name|expectedValue
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
name|QAtomicOpsBySize
operator|<
literal|4
operator|>
operator|::
name|fetchAndStoreRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|T newValue
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|Exchange
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|,
name|value
argument_list|(
name|newValue
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
name|QAtomicOpsBySize
operator|<
literal|4
operator|>
operator|::
name|fetchAndAddRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|typename QAtomicAdditiveType<T>::AdditiveT valueToAdd
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|ExchangeAdd
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|,
name|value
operator|<
name|T
operator|>
operator|(
name|valueToAdd
operator|*
name|QAtomicAdditiveType
operator|<
name|T
operator|>
operator|::
name|AddScale
operator|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|Q_ATOMIC_INT16_IS_SUPPORTED
end_ifdef
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOpsBySize
operator|<
literal|2
operator|>
operator|::
name|ref
argument_list|(
argument|T&_q_value
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|Increment16
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOpsBySize
operator|<
literal|2
operator|>
operator|::
name|deref
argument_list|(
argument|T&_q_value
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|Decrement16
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOpsBySize
operator|<
literal|2
operator|>
operator|::
name|testAndSetRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|T expectedValue
argument_list|,
argument|T newValue
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|CompareExchange16
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|,
name|value
argument_list|(
name|newValue
argument_list|)
argument_list|,
name|value
argument_list|(
name|expectedValue
argument_list|)
argument_list|)
operator|==
name|value
argument_list|(
name|expectedValue
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOpsBySize
operator|<
literal|2
operator|>
operator|::
name|testAndSetRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|T expectedValue
argument_list|,
argument|T newValue
argument_list|,
argument|T *currentValue
argument_list|)
name|Q_DECL_NOTHROW
block|{
operator|*
name|currentValue
operator|=
name|T
argument_list|(
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|CompareExchange16
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|,
name|newValue
argument_list|,
name|expectedValue
argument_list|)
argument_list|)
block|;
return|return
operator|*
name|currentValue
operator|==
name|expectedValue
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
name|QAtomicOpsBySize
operator|<
literal|2
operator|>
operator|::
name|fetchAndStoreRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|T newValue
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|Exchange16
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|,
name|value
argument_list|(
name|newValue
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
name|QAtomicOpsBySize
operator|<
literal|2
operator|>
operator|::
name|fetchAndAddRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|typename QAtomicAdditiveType<T>::AdditiveT valueToAdd
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|ExchangeAdd16
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|,
name|value
operator|<
name|T
operator|>
operator|(
name|valueToAdd
operator|*
name|QAtomicAdditiveType
operator|<
name|T
operator|>
operator|::
name|AddScale
operator|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_ATOMIC_INT64_IS_SUPPORTED
end_ifdef
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOpsBySize
operator|<
literal|8
operator|>
operator|::
name|ref
argument_list|(
argument|T&_q_value
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|Increment64
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOpsBySize
operator|<
literal|8
operator|>
operator|::
name|deref
argument_list|(
argument|T&_q_value
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|Decrement64
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOpsBySize
operator|<
literal|8
operator|>
operator|::
name|testAndSetRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|T expectedValue
argument_list|,
argument|T newValue
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|CompareExchange64
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|,
name|value
argument_list|(
name|newValue
argument_list|)
argument_list|,
name|value
argument_list|(
name|expectedValue
argument_list|)
argument_list|)
operator|==
name|value
argument_list|(
name|expectedValue
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOpsBySize
operator|<
literal|8
operator|>
operator|::
name|testAndSetRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|T expectedValue
argument_list|,
argument|T newValue
argument_list|,
argument|T *currentValue
argument_list|)
name|Q_DECL_NOTHROW
block|{
operator|*
name|currentValue
operator|=
name|T
argument_list|(
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|CompareExchange64
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|,
name|newValue
argument_list|,
name|expectedValue
argument_list|)
argument_list|)
block|;
return|return
operator|*
name|currentValue
operator|==
name|expectedValue
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
name|QAtomicOpsBySize
operator|<
literal|8
operator|>
operator|::
name|fetchAndStoreRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|T newValue
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|Exchange64
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|,
name|value
argument_list|(
name|newValue
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
name|QAtomicOpsBySize
operator|<
literal|8
operator|>
operator|::
name|fetchAndAddRelaxed
argument_list|(
argument|T&_q_value
argument_list|,
argument|typename QAtomicAdditiveType<T>::AdditiveT valueToAdd
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_FUNCTION
argument_list|(
name|ExchangeAdd64
argument_list|)
argument_list|(
name|atomic
argument_list|(
operator|&
name|_q_value
argument_list|)
argument_list|,
name|value
operator|<
name|T
operator|>
operator|(
name|valueToAdd
operator|*
name|QAtomicAdditiveType
operator|<
name|T
operator|>
operator|::
name|AddScale
operator|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Specialization for pointer types, since we have Interlocked*Pointer() variants in some configurations
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
DECL|struct|T
name|QAtomicOps
operator|<
name|T
operator|*
operator|>
operator|:
name|QGenericAtomicOps
operator|<
name|QAtomicOps
operator|<
name|T
operator|*
operator|>
expr|>
block|{
DECL|typedef|Type
typedef|typedef
name|T
modifier|*
name|Type
typedef|;
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isTestAndSetNative
argument_list|()
name|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isTestAndSetWaitFree
argument_list|()
name|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
DECL|member|Q_DECL_NOTHROW
specifier|static
name|bool
name|testAndSetRelaxed
argument_list|(
argument|T *&_q_value
argument_list|,
argument|T *expectedValue
argument_list|,
argument|T *newValue
argument_list|)
name|Q_DECL_NOTHROW
expr_stmt|;
end_expr_stmt
begin_decl_stmt
DECL|member|Q_DECL_NOTHROW
specifier|static
name|bool
name|testAndSetRelaxed
argument_list|(
name|T
operator|*
operator|&
name|_q_value
argument_list|,
name|T
operator|*
name|expectedValue
argument_list|,
name|T
operator|*
name|newValue
argument_list|,
name|T
operator|*
operator|*
name|currentValue
argument_list|)
name|Q_DECL_NOTHROW
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isFetchAndStoreNative
parameter_list|()
function|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isFetchAndStoreWaitFree
parameter_list|()
function|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
end_function
begin_decl_stmt
DECL|member|Q_DECL_NOTHROW
specifier|static
name|T
modifier|*
name|fetchAndStoreRelaxed
argument_list|(
name|T
operator|*
operator|&
name|_q_value
argument_list|,
name|T
operator|*
name|newValue
argument_list|)
name|Q_DECL_NOTHROW
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isFetchAndAddNative
parameter_list|()
function|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
end_function
begin_function
specifier|static
specifier|inline
name|Q_DECL_CONSTEXPR
name|bool
name|isFetchAndAddWaitFree
parameter_list|()
function|Q_DECL_NOTHROW
block|{
return|return
name|true
return|;
block|}
end_function
begin_decl_stmt
DECL|member|Q_DECL_NOTHROW
specifier|static
name|T
modifier|*
name|fetchAndAddRelaxed
argument_list|(
name|T
operator|*
operator|&
name|_q_value
argument_list|,
name|qptrdiff
name|valueToAdd
argument_list|)
name|Q_DECL_NOTHROW
decl_stmt|;
end_decl_stmt
begin_expr_stmt
DECL|member|Q_DECL_NOTHROW
unit|};
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOps
operator|<
name|T
operator|*
operator|>
operator|::
name|testAndSetRelaxed
argument_list|(
argument|T *&_q_value
argument_list|,
argument|T *expectedValue
argument_list|,
argument|T *newValue
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_INTERLOCKED_COMPARE_EXCHANGE_POINTER
argument_list|(
operator|&
name|_q_value
argument_list|,
name|newValue
argument_list|,
name|expectedValue
argument_list|)
operator|==
name|expectedValue
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|QAtomicOps
operator|<
name|T
operator|*
operator|>
operator|::
name|testAndSetRelaxed
argument_list|(
argument|T *&_q_value
argument_list|,
argument|T *expectedValue
argument_list|,
argument|T *newValue
argument_list|,
argument|T **currentValue
argument_list|)
name|Q_DECL_NOTHROW
block|{
operator|*
name|currentValue
operator|=
name|reinterpret_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|QT_INTERLOCKED_COMPARE_EXCHANGE_POINTER
argument_list|(
operator|&
name|_q_value
argument_list|,
name|newValue
argument_list|,
name|expectedValue
argument_list|)
operator|)
block|;
return|return
operator|*
name|currentValue
operator|==
name|expectedValue
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
operator|*
name|QAtomicOps
operator|<
name|T
operator|*
operator|>
operator|::
name|fetchAndStoreRelaxed
argument_list|(
argument|T *&_q_value
argument_list|,
argument|T *newValue
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|reinterpret_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|QT_INTERLOCKED_EXCHANGE_POINTER
argument_list|(
operator|&
name|_q_value
argument_list|,
name|newValue
argument_list|)
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
operator|*
name|QAtomicOps
operator|<
name|T
operator|*
operator|>
operator|::
name|fetchAndAddRelaxed
argument_list|(
argument|T *&_q_value
argument_list|,
argument|qptrdiff valueToAdd
argument_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|reinterpret_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|QT_INTERLOCKED_EXCHANGE_ADD_POINTER
argument_list|(
operator|&
name|_q_value
argument_list|,
name|valueToAdd
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_expr_stmt
begin_comment
comment|////////////////////////////////////////////////////////////////////////////////////////////////////
end_comment
begin_comment
comment|// Cleanup
end_comment
begin_undef
DECL|macro|QT_INTERLOCKED_CONCAT_I
undef|#
directive|undef
name|QT_INTERLOCKED_CONCAT_I
end_undef
begin_undef
DECL|macro|QT_INTERLOCKED_CONCAT
undef|#
directive|undef
name|QT_INTERLOCKED_CONCAT
end_undef
begin_undef
DECL|macro|QT_INTERLOCKED_FUNCTION
undef|#
directive|undef
name|QT_INTERLOCKED_FUNCTION
end_undef
begin_undef
DECL|macro|QT_INTERLOCKED_PREFIX
undef|#
directive|undef
name|QT_INTERLOCKED_PREFIX
end_undef
begin_undef
DECL|macro|QT_INTERLOCKED_VOLATILE
undef|#
directive|undef
name|QT_INTERLOCKED_VOLATILE
end_undef
begin_undef
DECL|macro|QT_INTERLOCKED_INCREMENT
undef|#
directive|undef
name|QT_INTERLOCKED_INCREMENT
end_undef
begin_undef
DECL|macro|QT_INTERLOCKED_DECREMENT
undef|#
directive|undef
name|QT_INTERLOCKED_DECREMENT
end_undef
begin_undef
DECL|macro|QT_INTERLOCKED_COMPARE_EXCHANGE
undef|#
directive|undef
name|QT_INTERLOCKED_COMPARE_EXCHANGE
end_undef
begin_undef
DECL|macro|QT_INTERLOCKED_EXCHANGE
undef|#
directive|undef
name|QT_INTERLOCKED_EXCHANGE
end_undef
begin_undef
DECL|macro|QT_INTERLOCKED_EXCHANGE_ADD
undef|#
directive|undef
name|QT_INTERLOCKED_EXCHANGE_ADD
end_undef
begin_undef
DECL|macro|QT_INTERLOCKED_COMPARE_EXCHANGE_POINTER
undef|#
directive|undef
name|QT_INTERLOCKED_COMPARE_EXCHANGE_POINTER
end_undef
begin_undef
DECL|macro|QT_INTERLOCKED_EXCHANGE_POINTER
undef|#
directive|undef
name|QT_INTERLOCKED_EXCHANGE_POINTER
end_undef
begin_undef
DECL|macro|QT_INTERLOCKED_EXCHANGE_ADD_POINTER
undef|#
directive|undef
name|QT_INTERLOCKED_EXCHANGE_ADD_POINTER
end_undef
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QATOMIC_MSVC_H
end_comment
end_unit
