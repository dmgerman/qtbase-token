begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 KlarÃ¤lvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Marc Mutz<marc.mutz@kdab.com> ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|// BEGIN Google Code
end_comment
begin_comment
comment|// Copyright (c) 2006, Google Inc.
end_comment
begin_comment
comment|// All rights reserved.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment
begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment
begin_comment
comment|// met:
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment
begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment
begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment
begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment
begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment
begin_comment
comment|// distribution.
end_comment
begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment
begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment
begin_comment
comment|// this software without specific prior written permission.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment
begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment
begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment
begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment
begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment
begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment
begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment
begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment
begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment
begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment
begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment
begin_comment
comment|// ----
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// This code is compiled directly on many platforms, including client
end_comment
begin_comment
comment|// platforms like Windows, Mac, and embedded systems.  Before making
end_comment
begin_comment
comment|// any changes here, make sure that you're not breaking any platforms.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Define a small subset of tr1 type traits. The traits we define are:
end_comment
begin_comment
comment|//   is_integral
end_comment
begin_comment
comment|//   is_floating_point
end_comment
begin_comment
comment|//   is_pointer
end_comment
begin_comment
comment|//   is_enum
end_comment
begin_comment
comment|//   is_reference
end_comment
begin_comment
comment|//   is_pod
end_comment
begin_comment
comment|//   has_trivial_constructor
end_comment
begin_comment
comment|//   has_trivial_copy
end_comment
begin_comment
comment|//   has_trivial_assign
end_comment
begin_comment
comment|//   has_trivial_destructor
end_comment
begin_comment
comment|//   remove_const
end_comment
begin_comment
comment|//   remove_volatile
end_comment
begin_comment
comment|//   remove_cv
end_comment
begin_comment
comment|//   remove_reference
end_comment
begin_comment
comment|//   add_reference
end_comment
begin_comment
comment|//   remove_pointer
end_comment
begin_comment
comment|//   is_same
end_comment
begin_comment
comment|//   is_convertible
end_comment
begin_comment
comment|// We can add more type traits as required.
end_comment
begin_comment
comment|// Changes from the original implementation:
end_comment
begin_comment
comment|//  - Move base types from template_util.h directly into this header.
end_comment
begin_comment
comment|//  - Use Qt macros for long long type differences on Windows.
end_comment
begin_comment
comment|//  - Enclose in QtPrivate namespace.
end_comment
begin_include
include|#
directive|include
file|"QtCore/qglobal.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QTYPETRAITS_H
end_ifndef
begin_define
DECL|macro|QTYPETRAITS_H
define|#
directive|define
name|QTYPETRAITS_H
end_define
begin_include
include|#
directive|include
file|<utility>
end_include
begin_comment
comment|// For pair
end_comment
begin_decl_stmt
name|QT_BEGIN_HEADER
name|QT_BEGIN_NAMESPACE
name|namespace
name|QtPrivate
block|{
comment|// Types small_ and big_ are guaranteed such that sizeof(small_)<
comment|// sizeof(big_)
typedef|typedef
name|char
name|small_
typedef|;
struct|struct
name|big_
block|{
name|char
name|dummy
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
comment|// Identity metafunction.
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|identity_
block|{
typedef|typedef
name|T
name|type
typedef|;
block|}
empty_stmt|;
comment|// integral_constant, defined in tr1, is a wrapper for an integer
comment|// value. We don't really need this generality; we could get away
comment|// with hardcoding the integer type to bool. We use the fully
comment|// general integer_constant for compatibility with tr1.
name|template
operator|<
name|class
name|T
operator|,
name|T
name|v
operator|>
expr|struct
name|integral_constant
block|{
specifier|static
specifier|const
name|T
name|value
operator|=
name|v
block|;
typedef|typedef
name|T
name|value_type
typedef|;
typedef|typedef
name|integral_constant
operator|<
name|T
operator|,
name|v
operator|>
name|type
expr_stmt|;
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|T
name|v
operator|>
specifier|const
name|T
name|integral_constant
operator|<
name|T
operator|,
name|v
operator|>
operator|::
name|value
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Abbreviations: true_type and false_type are structs that represent boolean
end_comment
begin_comment
comment|// true and false values. Also define the boost::mpl versions of those names,
end_comment
begin_comment
comment|// true_ and false_.
end_comment
begin_typedef
typedef|typedef
name|integral_constant
operator|<
name|bool
operator|,
name|true
operator|>
name|true_type
expr_stmt|;
end_typedef
begin_typedef
typedef|typedef
name|integral_constant
operator|<
name|bool
operator|,
name|false
operator|>
name|false_type
expr_stmt|;
end_typedef
begin_typedef
typedef|typedef
name|true_type
name|true_
typedef|;
end_typedef
begin_typedef
typedef|typedef
name|false_type
name|false_
typedef|;
end_typedef
begin_comment
comment|// if_ is a templatized conditional statement.
end_comment
begin_comment
comment|// if_<cond, A, B> is a compile time evaluation of cond.
end_comment
begin_comment
comment|// if_<>::type contains A if cond is true, B otherwise.
end_comment
begin_expr_stmt
name|template
operator|<
name|bool
name|cond
operator|,
name|typename
name|A
operator|,
name|typename
name|B
operator|>
expr|struct
name|if_
block|{
typedef|typedef
name|A
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|A
operator|,
name|typename
name|B
operator|>
expr|struct
name|if_
operator|<
name|false
operator|,
name|A
operator|,
name|B
operator|>
block|{
typedef|typedef
name|B
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|// type_equals_ is a template type comparator, similar to Loki IsSameType.
end_comment
begin_comment
comment|// type_equals_<A, B>::value is true iff "A" is the same type as "B".
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// New code should prefer base::is_same, defined in base/type_traits.h.
end_comment
begin_comment
comment|// It is functionally identical, but is_same is the standard spelling.
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|A
operator|,
name|typename
name|B
operator|>
expr|struct
name|type_equals_
operator|:
name|public
name|false_
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|A
operator|>
expr|struct
name|type_equals_
operator|<
name|A
operator|,
name|A
operator|>
operator|:
name|public
name|true_
block|{ }
expr_stmt|;
end_expr_stmt
begin_comment
comment|// and_ is a template&& operator.
end_comment
begin_comment
comment|// and_<A, B>::value evaluates "A::value&& B::value".
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|A
operator|,
name|typename
name|B
operator|>
expr|struct
name|and_
operator|:
name|public
name|integral_constant
operator|<
name|bool
operator|,
operator|(
name|A
operator|::
name|value
operator|&&
name|B
operator|::
name|value
operator|)
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_comment
comment|// or_ is a template || operator.
end_comment
begin_comment
comment|// or_<A, B>::value evaluates "A::value || B::value".
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|A
operator|,
name|typename
name|B
operator|>
expr|struct
name|or_
operator|:
name|public
name|integral_constant
operator|<
name|bool
operator|,
operator|(
name|A
operator|::
name|value
operator|||
name|B
operator|::
name|value
operator|)
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_integral
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_floating_point
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_pointer
expr_stmt|;
end_expr_stmt
begin_comment
comment|// MSVC can't compile this correctly, and neither can gcc 3.3.5 (at least)
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|<=
literal|3
operator|)
end_if
begin_comment
comment|// is_enum uses is_convertible, which is not available on MSVC.
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_enum
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_reference
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_pod
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_trivial_constructor
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_trivial_copy
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_trivial_assign
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_trivial_destructor
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|remove_const
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|remove_volatile
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|remove_cv
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|remove_reference
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|add_reference
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|remove_pointer
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|U
operator|>
expr|struct
name|is_same
expr_stmt|;
end_expr_stmt
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|<=
literal|3
operator|)
end_if
begin_expr_stmt
name|template
operator|<
name|class
name|From
operator|,
name|class
name|To
operator|>
expr|struct
name|is_convertible
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// is_integral is false except for the built-in integer types. A
end_comment
begin_comment
comment|// cv-qualified type is integral if and only if the underlying type is.
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_integral
operator|:
name|false_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|bool
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|char
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|unsigned
name|char
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|signed
name|char
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_comment
comment|// wchar_t is not by default a distinct type from unsigned short in
end_comment
begin_comment
comment|// Microsoft C.
end_comment
begin_comment
comment|// See http://msdn2.microsoft.com/en-us/library/dh8che7s(VS.80).aspx
end_comment
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|__wchar_t
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_else
else|#
directive|else
end_else
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|wchar_t
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|short
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|unsigned
name|short
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|int
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|unsigned
name|int
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|long
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|unsigned
name|long
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
end_if
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|__int64
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|unsigned
name|__int64
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_else
else|#
directive|else
end_else
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|long
name|long
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|unsigned
name|long
name|long
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_integral
operator|<
specifier|const
name|T
operator|>
operator|:
name|is_integral
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_integral
operator|<
specifier|volatile
name|T
operator|>
operator|:
name|is_integral
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_integral
operator|<
specifier|const
specifier|volatile
name|T
operator|>
operator|:
name|is_integral
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_COMPILER_UNICODE_STRINGS
argument_list|)
end_if
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|char16_t
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_integral
operator|<
name|char32_t
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// is_floating_point is false except for the built-in floating-point types.
end_comment
begin_comment
comment|// A cv-qualified type is integral if and only if the underlying type is.
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_floating_point
operator|:
name|false_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_floating_point
operator|<
name|float
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_floating_point
operator|<
name|double
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
expr|struct
name|is_floating_point
operator|<
name|long
name|double
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_floating_point
operator|<
specifier|const
name|T
operator|>
operator|:
name|is_floating_point
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_floating_point
operator|<
specifier|volatile
name|T
operator|>
operator|:
name|is_floating_point
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_floating_point
operator|<
specifier|const
specifier|volatile
name|T
operator|>
operator|:
name|is_floating_point
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_comment
comment|// is_pointer is false except for pointer types. A cv-qualified type (e.g.
end_comment
begin_comment
comment|// "int* const", as opposed to "int const*") is cv-qualified if and only if
end_comment
begin_comment
comment|// the underlying type is.
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_pointer
operator|:
name|false_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_pointer
operator|<
name|T
operator|*
operator|>
operator|:
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_pointer
operator|<
specifier|const
name|T
operator|>
operator|:
name|is_pointer
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_pointer
operator|<
specifier|volatile
name|T
operator|>
operator|:
name|is_pointer
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_pointer
operator|<
specifier|const
specifier|volatile
name|T
operator|>
operator|:
name|is_pointer
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|<=
literal|3
operator|)
end_if
begin_decl_stmt
name|namespace
name|internal
block|{
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_class_or_union
block|{
name|template
operator|<
name|class
name|U
operator|>
specifier|static
name|small_
name|tester
argument_list|(
name|void
argument_list|(
name|U
operator|::
operator|*
argument_list|)
argument_list|()
argument_list|)
block|;
name|template
operator|<
name|class
name|U
operator|>
specifier|static
name|big_
name|tester
argument_list|(
operator|...
argument_list|)
block|;
specifier|static
specifier|const
name|bool
name|value
operator|=
sizeof|sizeof
argument_list|(
name|tester
operator|<
name|T
operator|>
operator|(
literal|0
operator|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|small_
argument_list|)
block|; }
expr_stmt|;
comment|// is_convertible chokes if the first argument is an array. That's why
comment|// we use add_reference here.
name|template
operator|<
name|bool
name|NotUnum
operator|,
name|class
name|T
operator|>
expr|struct
name|is_enum_impl
operator|:
name|is_convertible
operator|<
name|typename
name|add_reference
operator|<
name|T
operator|>
operator|::
name|type
operator|,
name|int
operator|>
block|{ }
expr_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_enum_impl
operator|<
name|true
operator|,
name|T
operator|>
operator|:
name|false_type
block|{ }
expr_stmt|;
block|}
end_decl_stmt
begin_comment
comment|// namespace internal
end_comment
begin_comment
comment|// Specified by TR1 [4.5.1] primary type categories.
end_comment
begin_comment
comment|// Implementation note:
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Each type is either void, integral, floating point, array, pointer,
end_comment
begin_comment
comment|// reference, member object pointer, member function pointer, enum,
end_comment
begin_comment
comment|// union or class. Out of these, only integral, floating point, reference,
end_comment
begin_comment
comment|// class and enum types are potentially convertible to int. Therefore,
end_comment
begin_comment
comment|// if a type is not a reference, integral, floating point or class and
end_comment
begin_comment
comment|// is convertible to int, it's a enum. Adding cv-qualification to a type
end_comment
begin_comment
comment|// does not change whether it's an enum.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Is-convertible-to-int check is done only if all other checks pass,
end_comment
begin_comment
comment|// because it can't be used with some types (e.g. void or classes with
end_comment
begin_comment
comment|// inaccessible conversion operators).
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_enum
operator|:
name|internal
operator|::
name|is_enum_impl
operator|<
name|is_same
operator|<
name|T
operator|,
name|void
operator|>
operator|::
name|value
operator|||
name|is_integral
operator|<
name|T
operator|>
operator|::
name|value
operator|||
name|is_floating_point
operator|<
name|T
operator|>
operator|::
name|value
operator|||
name|is_reference
operator|<
name|T
operator|>
operator|::
name|value
operator|||
name|internal
operator|::
name|is_class_or_union
operator|<
name|T
operator|>
operator|::
name|value
operator|,
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_enum
operator|<
specifier|const
name|T
operator|>
operator|:
name|is_enum
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_enum
operator|<
specifier|volatile
name|T
operator|>
operator|:
name|is_enum
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_enum
operator|<
specifier|const
specifier|volatile
name|T
operator|>
operator|:
name|is_enum
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// is_reference is false except for reference types.
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|is_reference
operator|:
name|false_type
block|{}
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|is_reference
operator|<
name|T
operator|&
operator|>
operator|:
name|true_type
block|{}
expr_stmt|;
end_expr_stmt
begin_comment
comment|// We can't get is_pod right without compiler help, so fail conservatively.
end_comment
begin_comment
comment|// We will assume it's false except for arithmetic types, enumerations,
end_comment
begin_comment
comment|// pointers and cv-qualified versions thereof. Note that std::pair<T,U>
end_comment
begin_comment
comment|// is not a POD even if T and U are PODs.
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_pod
operator|:
name|integral_constant
operator|<
name|bool
operator|,
operator|(
name|is_integral
operator|<
name|T
operator|>
operator|::
name|value
operator|||
name|is_floating_point
operator|<
name|T
operator|>
operator|::
name|value
operator|||
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|<=
literal|3
operator|)
comment|// is_enum is not available on MSVC.
name|is_enum
operator|<
name|T
operator|>
operator|::
name|value
operator|||
endif|#
directive|endif
name|is_pointer
operator|<
name|T
operator|>
operator|::
name|value
operator|)
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_pod
operator|<
specifier|const
name|T
operator|>
operator|:
name|is_pod
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_pod
operator|<
specifier|volatile
name|T
operator|>
operator|:
name|is_pod
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|is_pod
operator|<
specifier|const
specifier|volatile
name|T
operator|>
operator|:
name|is_pod
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_comment
comment|// We can't get has_trivial_constructor right without compiler help, so
end_comment
begin_comment
comment|// fail conservatively. We will assume it's false except for: (1) types
end_comment
begin_comment
comment|// for which is_pod is true. (2) std::pair of types with trivial
end_comment
begin_comment
comment|// constructors. (3) array of a type with a trivial constructor.
end_comment
begin_comment
comment|// (4) const versions thereof.
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_trivial_constructor
operator|:
name|is_pod
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|U
operator|>
expr|struct
name|has_trivial_constructor
operator|<
name|std
operator|::
name|pair
operator|<
name|T
operator|,
name|U
operator|>
expr|>
operator|:
name|integral_constant
operator|<
name|bool
operator|,
operator|(
name|has_trivial_constructor
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
name|has_trivial_constructor
operator|<
name|U
operator|>
operator|::
name|value
operator|)
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|A
operator|,
name|int
name|N
operator|>
expr|struct
name|has_trivial_constructor
operator|<
name|A
index|[
name|N
index|]
operator|>
operator|:
name|has_trivial_constructor
operator|<
name|A
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_trivial_constructor
operator|<
specifier|const
name|T
operator|>
operator|:
name|has_trivial_constructor
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_comment
comment|// We can't get has_trivial_copy right without compiler help, so fail
end_comment
begin_comment
comment|// conservatively. We will assume it's false except for: (1) types
end_comment
begin_comment
comment|// for which is_pod is true. (2) std::pair of types with trivial copy
end_comment
begin_comment
comment|// constructors. (3) array of a type with a trivial copy constructor.
end_comment
begin_comment
comment|// (4) const versions thereof.
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_trivial_copy
operator|:
name|is_pod
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|U
operator|>
expr|struct
name|has_trivial_copy
operator|<
name|std
operator|::
name|pair
operator|<
name|T
operator|,
name|U
operator|>
expr|>
operator|:
name|integral_constant
operator|<
name|bool
operator|,
operator|(
name|has_trivial_copy
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
name|has_trivial_copy
operator|<
name|U
operator|>
operator|::
name|value
operator|)
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|A
operator|,
name|int
name|N
operator|>
expr|struct
name|has_trivial_copy
operator|<
name|A
index|[
name|N
index|]
operator|>
operator|:
name|has_trivial_copy
operator|<
name|A
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_trivial_copy
operator|<
specifier|const
name|T
operator|>
operator|:
name|has_trivial_copy
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_comment
comment|// We can't get has_trivial_assign right without compiler help, so fail
end_comment
begin_comment
comment|// conservatively. We will assume it's false except for: (1) types
end_comment
begin_comment
comment|// for which is_pod is true. (2) std::pair of types with trivial copy
end_comment
begin_comment
comment|// constructors. (3) array of a type with a trivial assign constructor.
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_trivial_assign
operator|:
name|is_pod
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|U
operator|>
expr|struct
name|has_trivial_assign
operator|<
name|std
operator|::
name|pair
operator|<
name|T
operator|,
name|U
operator|>
expr|>
operator|:
name|integral_constant
operator|<
name|bool
operator|,
operator|(
name|has_trivial_assign
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
name|has_trivial_assign
operator|<
name|U
operator|>
operator|::
name|value
operator|)
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|A
operator|,
name|int
name|N
operator|>
expr|struct
name|has_trivial_assign
operator|<
name|A
index|[
name|N
index|]
operator|>
operator|:
name|has_trivial_assign
operator|<
name|A
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_comment
comment|// We can't get has_trivial_destructor right without compiler help, so
end_comment
begin_comment
comment|// fail conservatively. We will assume it's false except for: (1) types
end_comment
begin_comment
comment|// for which is_pod is true. (2) std::pair of types with trivial
end_comment
begin_comment
comment|// destructors. (3) array of a type with a trivial destructor.
end_comment
begin_comment
comment|// (4) const versions thereof.
end_comment
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_trivial_destructor
operator|:
name|is_pod
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|,
name|class
name|U
operator|>
expr|struct
name|has_trivial_destructor
operator|<
name|std
operator|::
name|pair
operator|<
name|T
operator|,
name|U
operator|>
expr|>
operator|:
name|integral_constant
operator|<
name|bool
operator|,
operator|(
name|has_trivial_destructor
operator|<
name|T
operator|>
operator|::
name|value
operator|&&
name|has_trivial_destructor
operator|<
name|U
operator|>
operator|::
name|value
operator|)
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|A
operator|,
name|int
name|N
operator|>
expr|struct
name|has_trivial_destructor
operator|<
name|A
index|[
name|N
index|]
operator|>
operator|:
name|has_trivial_destructor
operator|<
name|A
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|has_trivial_destructor
operator|<
specifier|const
name|T
operator|>
operator|:
name|has_trivial_destructor
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Specified by TR1 [4.7.1]
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|remove_const
block|{
typedef|typedef
name|T
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|remove_const
operator|<
name|T
specifier|const
operator|>
block|{
typedef|typedef
name|T
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|remove_volatile
block|{
typedef|typedef
name|T
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|remove_volatile
operator|<
name|T
specifier|volatile
operator|>
block|{
typedef|typedef
name|T
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|remove_cv
block|{
typedef|typedef
name|typename
name|remove_const
operator|<
name|typename
name|remove_volatile
operator|<
name|T
operator|>
operator|::
name|type
operator|>
operator|::
name|type
name|type
expr_stmt|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|// Specified by TR1 [4.7.2] Reference modifications.
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|remove_reference
block|{
typedef|typedef
name|T
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|remove_reference
operator|<
name|T
operator|&
operator|>
block|{
typedef|typedef
name|T
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|add_reference
block|{
typedef|typedef
name|T
modifier|&
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|add_reference
operator|<
name|T
operator|&
operator|>
block|{
typedef|typedef
name|T
modifier|&
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|// Specified by TR1 [4.7.4] Pointer modifications.
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|remove_pointer
block|{
typedef|typedef
name|T
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|remove_pointer
operator|<
name|T
operator|*
operator|>
block|{
typedef|typedef
name|T
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|remove_pointer
operator|<
name|T
operator|*
specifier|const
operator|>
block|{
typedef|typedef
name|T
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|remove_pointer
operator|<
name|T
operator|*
specifier|volatile
operator|>
block|{
typedef|typedef
name|T
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|remove_pointer
operator|<
name|T
operator|*
specifier|const
specifier|volatile
operator|>
block|{
typedef|typedef
name|T
name|type
typedef|;
block|}
end_expr_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|// Specified by TR1 [4.6] Relationships between types
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|U
operator|>
expr|struct
name|is_same
operator|:
name|public
name|false_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|is_same
operator|<
name|T
operator|,
name|T
operator|>
operator|:
name|public
name|true_type
block|{ }
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Specified by TR1 [4.6] Relationships between types
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|<=
literal|3
operator|)
end_if
begin_decl_stmt
name|namespace
name|internal
block|{
comment|// This class is an implementation detail for is_convertible, and you
comment|// don't need to know how it works to use is_convertible. For those
comment|// who care: we declare two different functions, one whose argument is
comment|// of type To and one with a variadic argument list. We give them
comment|// return types of different size, so we can use sizeof to trick the
comment|// compiler into telling us which function it would have chosen if we
comment|// had called it with an argument of type From.  See Alexandrescu's
comment|// _Modern C++ Design_ for more details on this sort of trick.
name|template
operator|<
name|typename
name|From
operator|,
name|typename
name|To
operator|>
expr|struct
name|ConvertHelper
block|{
specifier|static
name|small_
name|Test
argument_list|(
name|To
argument_list|)
block|;
specifier|static
name|big_
name|Test
argument_list|(
operator|...
argument_list|)
block|;
specifier|static
name|From
name|Create
argument_list|()
block|; }
expr_stmt|;
block|}
end_decl_stmt
begin_comment
comment|// namespace internal
end_comment
begin_comment
comment|// Inherits from true_type if From is convertible to To, false_type otherwise.
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|From
operator|,
name|typename
name|To
operator|>
expr|struct
name|is_convertible
operator|:
name|integral_constant
operator|<
name|bool
operator|,
sizeof|sizeof
argument_list|(
name|internal
operator|::
name|ConvertHelper
operator|<
name|From
argument_list|,
name|To
operator|>
operator|::
name|Test
argument_list|(
name|internal
operator|::
name|ConvertHelper
operator|<
name|From
argument_list|,
name|To
operator|>
operator|::
name|Create
argument_list|()
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|small_
argument_list|)
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// END Google Code
end_comment
begin_comment
comment|// a metafunction to invert an integral_constant:
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|not_
operator|:
name|integral_constant
operator|<
name|bool
operator|,
operator|!
name|T
operator|::
name|value
operator|>
block|{}
expr_stmt|;
end_expr_stmt
begin_comment
comment|// same, with a bool argument:
end_comment
begin_expr_stmt
name|template
operator|<
name|bool
name|B
operator|>
expr|struct
name|not_c
operator|:
name|integral_constant
operator|<
name|bool
operator|,
operator|!
name|B
operator|>
block|{}
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Checks whether a type is unsigned (T must be convertible to unsigned int):
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|is_unsigned
operator|:
name|integral_constant
operator|<
name|bool
operator|,
operator|(
name|T
argument_list|(
literal|0
argument_list|)
operator|<
name|T
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|>
block|{}
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Checks whether a type is signed (T must be convertible to int):
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|is_signed
operator|:
name|not_
operator|<
name|is_unsigned
operator|<
name|T
operator|>
expr|>
block|{}
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
name|is_unsigned
operator|<
name|quint8
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
operator|!
name|is_unsigned
operator|<
name|qint8
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
operator|!
name|is_signed
operator|<
name|quint8
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
name|is_signed
operator|<
name|qint8
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
name|is_unsigned
operator|<
name|quint16
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
operator|!
name|is_unsigned
operator|<
name|qint16
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
operator|!
name|is_signed
operator|<
name|quint16
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
name|is_signed
operator|<
name|qint16
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
name|is_unsigned
operator|<
name|quint32
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
operator|!
name|is_unsigned
operator|<
name|qint32
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
operator|!
name|is_signed
operator|<
name|quint32
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
name|is_signed
operator|<
name|qint32
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
name|is_unsigned
operator|<
name|quint64
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
operator|!
name|is_unsigned
operator|<
name|qint64
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
operator|!
name|is_signed
operator|<
name|quint64
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT
argument_list|(
operator|(
name|is_signed
operator|<
name|qint64
operator|>
operator|::
name|value
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
unit|}
comment|// namespace QtPrivate
end_comment
begin_macro
unit|QT_END_NAMESPACE
name|QT_END_HEADER
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QTYPETRAITS_H
end_comment
end_unit
