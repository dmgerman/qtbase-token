begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Copyright (C) 2014 Intel Corporation ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qvector.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qthreadstorage.h"
end_include
begin_include
include|#
directive|include
file|"qdir.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QOBJECT
end_ifndef
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_EXCEPTIONS
end_ifndef
begin_include
include|#
directive|include
file|<string>
end_include
begin_include
include|#
directive|include
file|<exception>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
end_if
begin_include
include|#
directive|include
file|<crtdbg.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
operator|&&
name|defined
argument_list|(
name|_WRS_KERNEL
argument_list|)
end_if
begin_include
include|#
directive|include
file|<envLib.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MACX
argument_list|)
end_if
begin_include
include|#
directive|include
file|<CoreServices/CoreServices.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_ANDROID_NO_SDK
argument_list|)
end_if
begin_include
include|#
directive|include
file|<private/qjni_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
end_if
begin_include
include|#
directive|include
file|<bps/deviceinfo.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include
begin_include
include|#
directive|include
file|<private/qcore_unix_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"archdetect.cpp"
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
if|#
directive|if
operator|!
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|0
argument_list|)
comment|// Make sure they're defined to be exported
name|Q_CORE_EXPORT
name|void
modifier|*
name|qMemCopy
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qMemSet
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
name|int
name|c
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Statically check assumptions about the environment we're running
end_comment
begin_comment
comment|// in. The idea here is to error or warn if otherwise implicit Qt
end_comment
begin_comment
comment|// assumptions are not fulfilled on new hardware or compilers
end_comment
begin_comment
comment|// (if this list becomes too long, consider factoring into a separate file)
end_comment
begin_expr_stmt
name|Q_STATIC_ASSERT_X
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|==
literal|4
argument_list|,
literal|"Qt assumes that int is 32 bits"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_STATIC_ASSERT_X
argument_list|(
name|UCHAR_MAX
operator|==
literal|255
argument_list|,
literal|"Qt assumes that char is 8 bits"
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/*!     \class QFlag     \inmodule QtCore     \brief The QFlag class is a helper data type for QFlags.      It is equivalent to a plain \c int, except with respect to     function overloading and type conversions. You should never need     to use this class in your applications.      \sa QFlags */
end_comment
begin_comment
comment|/*!     \fn QFlag::QFlag(int value)      Constructs a QFlag object that stores the given \a value. */
end_comment
begin_comment
comment|/*!     \fn QFlag::QFlag(uint value)     \since Qt 5.3      Constructs a QFlag object that stores the given \a value. */
end_comment
begin_comment
comment|/*!     \fn QFlag::QFlag(short value)     \since 5.3      Constructs a QFlag object that stores the given \a value. */
end_comment
begin_comment
comment|/*!     \fn QFlag::QFlag(ushort value)     \since Qt 5.3      Constructs a QFlag object that stores the given \a value. */
end_comment
begin_comment
comment|/*!     \fn QFlag::operator int() const      Returns the value stored by the QFlag object. */
end_comment
begin_comment
comment|/*!     \fn QFlag::operator uint() const     \since Qt 5.3      Returns the value stored by the QFlag object. */
end_comment
begin_comment
comment|/*!     \class QFlags     \inmodule QtCore     \brief The QFlags class provides a type-safe way of storing     OR-combinations of enum values.       \ingroup tools      The QFlags<Enum> class is a template class, where Enum is an enum     type. QFlags is used throughout Qt for storing combinations of     enum values.      The traditional C++ approach for storing OR-combinations of enum     values is to use an \c int or \c uint variable. The inconvenience     with this approach is that there's no type checking at all; any     enum value can be OR'd with any other enum value and passed on to     a function that takes an \c int or \c uint.      Qt uses QFlags to provide type safety. For example, the     Qt::Alignment type is simply a typedef for     QFlags<Qt::AlignmentFlag>. QLabel::setAlignment() takes a     Qt::Alignment parameter, which means that any combination of     Qt::AlignmentFlag values, or 0, is legal:      \snippet code/src_corelib_global_qglobal.cpp 0      If you try to pass a value from another enum or just a plain     integer other than 0, the compiler will report an error. If you     need to cast integer values to flags in a untyped fashion, you can     use the explicit QFlags constructor as cast operator.      If you want to use QFlags for your own enum types, use     the Q_DECLARE_FLAGS() and Q_DECLARE_OPERATORS_FOR_FLAGS().      Example:      \snippet code/src_corelib_global_qglobal.cpp 1      You can then use the \c MyClass::Options type to store     combinations of \c MyClass::Option values.      \section1 Flags and the Meta-Object System      The Q_DECLARE_FLAGS() macro does not expose the flags to the meta-object     system, so they cannot be used by Qt Script or edited in Qt Designer.     To make the flags available for these purposes, the Q_FLAGS() macro must     be used:      \snippet code/src_corelib_global_qglobal.cpp meta-object flags      \section1 Naming Convention      A sensible naming convention for enum types and associated QFlags     types is to give a singular name to the enum type (e.g., \c     Option) and a plural name to the QFlags type (e.g., \c Options).     When a singular name is desired for the QFlags type (e.g., \c     Alignment), you can use \c Flag as the suffix for the enum type     (e.g., \c AlignmentFlag).      \sa QFlag */
end_comment
begin_comment
comment|/*!     \typedef QFlags::Int     \since 5.0      Typedef for the integer type used for storage as well as for     implicit conversion. Either \c int or \c{unsigned int}, depending     on whether the enum's underlying type is signed or unsigned. */
end_comment
begin_comment
comment|/*!     \typedef QFlags::enum_type      Typedef for the Enum template type. */
end_comment
begin_comment
comment|/*!     \fn QFlags::QFlags(const QFlags&other)      Constructs a copy of \a other. */
end_comment
begin_comment
comment|/*!     \fn QFlags::QFlags(Enum flag)      Constructs a QFlags object storing the given \a flag. */
end_comment
begin_comment
comment|/*!     \fn QFlags::QFlags(Zero zero)      Constructs a QFlags object with no flags set. \a zero must be a     literal 0 value. */
end_comment
begin_comment
comment|/*!     \fn QFlags::QFlags(QFlag value)      Constructs a QFlags object initialized with the given integer \a     value.      The QFlag type is a helper type. By using it here instead of \c     int, we effectively ensure that arbitrary enum values cannot be     cast to a QFlags, whereas untyped enum values (i.e., \c int     values) can. */
end_comment
begin_comment
comment|/*!     \fn QFlags::QFlags(std::initializer_list<Enum> flags)     \since 5.4      Constructs a QFlags object initialized with all \a flags     combined using the bitwise OR operator.      \sa operator|=(), operator|() */
end_comment
begin_comment
comment|/*!     \fn QFlags&QFlags::operator=(const QFlags&other)      Assigns \a other to this object and returns a reference to this     object. */
end_comment
begin_comment
comment|/*!     \fn QFlags&QFlags::operator&=(int mask)      Performs a bitwise AND operation with \a mask and stores the     result in this QFlags object. Returns a reference to this object.      \sa operator&(), operator|=(), operator^=() */
end_comment
begin_comment
comment|/*!     \fn QFlags&QFlags::operator&=(uint mask)      \overload */
end_comment
begin_comment
comment|/*!     \fn QFlags&QFlags::operator&=(Enum mask)      \overload */
end_comment
begin_comment
comment|/*!     \fn QFlags&QFlags::operator|=(QFlags other)      Performs a bitwise OR operation with \a other and stores the     result in this QFlags object. Returns a reference to this object.      \sa operator|(), operator&=(), operator^=() */
end_comment
begin_comment
comment|/*!     \fn QFlags&QFlags::operator|=(Enum other)      \overload */
end_comment
begin_comment
comment|/*!     \fn QFlags&QFlags::operator^=(QFlags other)      Performs a bitwise XOR operation with \a other and stores the     result in this QFlags object. Returns a reference to this object.      \sa operator^(), operator&=(), operator|=() */
end_comment
begin_comment
comment|/*!     \fn QFlags&QFlags::operator^=(Enum other)      \overload */
end_comment
begin_comment
comment|/*!     \fn QFlags::operator Int() const      Returns the value stored in the QFlags object as an integer.      \sa Int */
end_comment
begin_comment
comment|/*!     \fn QFlags QFlags::operator|(QFlags other) const      Returns a QFlags object containing the result of the bitwise OR     operation on this object and \a other.      \sa operator|=(), operator^(), operator&(), operator~() */
end_comment
begin_comment
comment|/*!     \fn QFlags QFlags::operator|(Enum other) const      \overload */
end_comment
begin_comment
comment|/*!     \fn QFlags QFlags::operator^(QFlags other) const      Returns a QFlags object containing the result of the bitwise XOR     operation on this object and \a other.      \sa operator^=(), operator&(), operator|(), operator~() */
end_comment
begin_comment
comment|/*!     \fn QFlags QFlags::operator^(Enum other) const      \overload */
end_comment
begin_comment
comment|/*!     \fn QFlags QFlags::operator&(int mask) const      Returns a QFlags object containing the result of the bitwise AND     operation on this object and \a mask.      \sa operator&=(), operator|(), operator^(), operator~() */
end_comment
begin_comment
comment|/*!     \fn QFlags QFlags::operator&(uint mask) const      \overload */
end_comment
begin_comment
comment|/*!     \fn QFlags QFlags::operator&(Enum mask) const      \overload */
end_comment
begin_comment
comment|/*!     \fn QFlags QFlags::operator~() const      Returns a QFlags object that contains the bitwise negation of     this object.      \sa operator&(), operator|(), operator^() */
end_comment
begin_comment
comment|/*!     \fn bool QFlags::operator!() const      Returns \c true if no flag is set (i.e., if the value stored by the     QFlags object is 0); otherwise returns \c false. */
end_comment
begin_comment
comment|/*!     \fn bool QFlags::testFlag(Enum flag) const     \since 4.2      Returns \c true if the \a flag is set, otherwise \c false. */
end_comment
begin_comment
comment|/*!   \macro Q_DISABLE_COPY(Class)   \relates QObject    Disables the use of copy constructors and assignment operators   for the given \a Class.    Instances of subclasses of QObject should not be thought of as   values that can be copied or assigned, but as unique identities.   This means that when you create your own subclass of QObject   (director or indirect), you should \e not give it a copy constructor   or an assignment operator.  However, it may not enough to simply   omit them from your class, because, if you mistakenly write some code   that requires a copy constructor or an assignment operator (it's easy   to do), your compiler will thoughtfully create it for you. You must   do more.    The curious user will have seen that the Qt classes derived   from QObject typically include this macro in a private section:    \snippet code/src_corelib_global_qglobal.cpp 43    It declares a copy constructor and an assignment operator in the   private section, so that if you use them by mistake, the compiler   will report an error.    \snippet code/src_corelib_global_qglobal.cpp 44    But even this might not catch absolutely every case. You might be   tempted to do something like this:    \snippet code/src_corelib_global_qglobal.cpp 45    First of all, don't do that. Most compilers will generate code that   uses the copy constructor, so the privacy violation error will be   reported, but your C++ compiler is not required to generate code for   this statement in a specific way. It could generate code using   \e{neither} the copy constructor \e{nor} the assignment operator we   made private. In that case, no error would be reported, but your   application would probably crash when you called a member function   of \c{w}. */
end_comment
begin_comment
comment|/*!     \macro Q_DECLARE_FLAGS(Flags, Enum)     \relates QFlags      The Q_DECLARE_FLAGS() macro expands to      \snippet code/src_corelib_global_qglobal.cpp 2      \a Enum is the name of an existing enum type, whereas \a Flags is     the name of the QFlags<\e{Enum}> typedef.      See the QFlags documentation for details.      \sa Q_DECLARE_OPERATORS_FOR_FLAGS() */
end_comment
begin_comment
comment|/*!     \macro Q_DECLARE_OPERATORS_FOR_FLAGS(Flags)     \relates QFlags      The Q_DECLARE_OPERATORS_FOR_FLAGS() macro declares global \c     operator|() functions for \a Flags, which is of type QFlags<T>.      See the QFlags documentation for details.      \sa Q_DECLARE_FLAGS() */
end_comment
begin_comment
comment|/*!     \headerfile<QtGlobal>     \title Global Qt Declarations     \ingroup funclists      \brief The<QtGlobal> header file includes the fundamental global     declarations. It is included by most other Qt header files.      The global declarations include \l{types}, \l{functions} and     \l{macros}.      The type definitions are partly convenience definitions for basic     types (some of which guarantee certain bit-sizes on all platforms     supported by Qt), partly types related to Qt message handling. The     functions are related to generating messages, Qt version handling     and comparing and adjusting object values. And finally, some of     the declared macros enable programmers to add compiler or platform     specific code to their applications, while others are convenience     macros for larger operations.      \section1 Types      The header file declares several type definitions that guarantee a     specified bit-size on all platforms supported by Qt for various     basic types, for example \l qint8 which is a signed char     guaranteed to be 8-bit on all platforms supported by Qt. The     header file also declares the \l qlonglong type definition for \c     {long long int } (\c __int64 on Windows).      Several convenience type definitions are declared: \l qreal for \c     double, \l uchar for \c unsigned char, \l uint for \c unsigned     int, \l ulong for \c unsigned long and \l ushort for \c unsigned     short.      Finally, the QtMsgType definition identifies the various messages     that can be generated and sent to a Qt message handler;     QtMessageHandler is a type definition for a pointer to a function with     the signature     \c {void myMessageHandler(QtMsgType, const QMessageLogContext&, const char *)}.     QMessageLogContext class contains the line, file, and function the     message was logged at. This information is created by the QMessageLogger     class.      \section1 Functions      The<QtGlobal> header file contains several functions comparing     and adjusting an object's value. These functions take a template     type as argument: You can retrieve the absolute value of an object     using the qAbs() function, and you can bound a given object's     value by given minimum and maximum values using the qBound()     function. You can retrieve the minimum and maximum of two given     objects using qMin() and qMax() respectively. All these functions     return a corresponding template type; the template types can be     replaced by any other type.      Example:      \snippet code/src_corelib_global_qglobal.cpp 3<QtGlobal> also contains functions that generate messages from the     given string argument: qCritical(), qDebug(), qFatal() and     qWarning(). These functions call the message handler with the     given message.      Example:      \snippet code/src_corelib_global_qglobal.cpp 4      The remaining functions are qRound() and qRound64(), which both     accept a \l qreal value as their argument returning the value     rounded up to the nearest integer and 64-bit integer respectively,     the qInstallMessageHandler() function which installs the given     QtMessageHandler, and the qVersion() function which returns the     version number of Qt at run-time as a string.      \section1 Macros      The<QtGlobal> header file provides a range of macros (Q_CC_*)     that are defined if the application is compiled using the     specified platforms. For example, the Q_CC_SUN macro is defined if     the application is compiled using Forte Developer, or Sun Studio     C++.  The header file also declares a range of macros (Q_OS_*)     that are defined for the specified platforms. For example,     Q_OS_UNIX which is defined for the Unix-based systems.      The purpose of these macros is to enable programmers to add     compiler or platform specific code to their application.      The remaining macros are convenience macros for larger operations:     The QT_TRANSLATE_NOOP() and QT_TR_NOOP() macros provide the     possibility of marking text for dynamic translation,     i.e. translation without changing the stored source text. The     Q_ASSERT() and Q_ASSERT_X() enables warning messages of various     level of refinement. The Q_FOREACH() and foreach() macros     implement Qt's foreach loop.      The Q_INT64_C() and Q_UINT64_C() macros wrap signed and unsigned     64-bit integer literals in a platform-independent way. The     Q_CHECK_PTR() macro prints a warning containing the source code's     file name and line number, saying that the program ran out of     memory, if the pointer is 0. The qPrintable() and qUtf8Printable()     macros represent an easy way of printing text.      Finally, the QT_POINTER_SIZE macro expands to the size of a     pointer in bytes, and the QT_VERSION and QT_VERSION_STR macros     expand to a numeric value or a string, respectively, specifying     Qt's version number, i.e the version the application is compiled     against.      \sa<QtAlgorithms>, QSysInfo */
end_comment
begin_comment
comment|/*!     \typedef qreal     \relates<QtGlobal>      Typedef for \c double unless Qt is configured with the     \c{-qreal float} option. */
end_comment
begin_comment
comment|/*! \typedef uchar     \relates<QtGlobal>      Convenience typedef for \c{unsigned char}. */
end_comment
begin_comment
comment|/*! \typedef ushort     \relates<QtGlobal>      Convenience typedef for \c{unsigned short}. */
end_comment
begin_comment
comment|/*! \typedef uint     \relates<QtGlobal>      Convenience typedef for \c{unsigned int}. */
end_comment
begin_comment
comment|/*! \typedef ulong     \relates<QtGlobal>      Convenience typedef for \c{unsigned long}. */
end_comment
begin_comment
comment|/*! \typedef qint8     \relates<QtGlobal>      Typedef for \c{signed char}. This type is guaranteed to be 8-bit     on all platforms supported by Qt. */
end_comment
begin_comment
comment|/*!     \typedef quint8     \relates<QtGlobal>      Typedef for \c{unsigned char}. This type is guaranteed to     be 8-bit on all platforms supported by Qt. */
end_comment
begin_comment
comment|/*! \typedef qint16     \relates<QtGlobal>      Typedef for \c{signed short}. This type is guaranteed to be     16-bit on all platforms supported by Qt. */
end_comment
begin_comment
comment|/*!     \typedef quint16     \relates<QtGlobal>      Typedef for \c{unsigned short}. This type is guaranteed to     be 16-bit on all platforms supported by Qt. */
end_comment
begin_comment
comment|/*! \typedef qint32     \relates<QtGlobal>      Typedef for \c{signed int}. This type is guaranteed to be 32-bit     on all platforms supported by Qt. */
end_comment
begin_comment
comment|/*!     \typedef quint32     \relates<QtGlobal>      Typedef for \c{unsigned int}. This type is guaranteed to     be 32-bit on all platforms supported by Qt. */
end_comment
begin_comment
comment|/*! \typedef qint64     \relates<QtGlobal>      Typedef for \c{long long int} (\c __int64 on Windows). This type     is guaranteed to be 64-bit on all platforms supported by Qt.      Literals of this type can be created using the Q_INT64_C() macro:      \snippet code/src_corelib_global_qglobal.cpp 5      \sa Q_INT64_C(), quint64, qlonglong */
end_comment
begin_comment
comment|/*!     \typedef quint64     \relates<QtGlobal>      Typedef for \c{unsigned long long int} (\c{unsigned __int64} on     Windows). This type is guaranteed to be 64-bit on all platforms     supported by Qt.      Literals of this type can be created using the Q_UINT64_C()     macro:      \snippet code/src_corelib_global_qglobal.cpp 6      \sa Q_UINT64_C(), qint64, qulonglong */
end_comment
begin_comment
comment|/*!     \typedef qintptr     \relates<QtGlobal>      Integral type for representing pointers in a signed integer (useful for     hashing, etc.).      Typedef for either qint32 or qint64. This type is guaranteed to     be the same size as a pointer on all platforms supported by Qt. On     a system with 32-bit pointers, qintptr is a typedef for qint32;     on a system with 64-bit pointers, qintptr is a typedef for     qint64.      Note that qintptr is signed. Use quintptr for unsigned values.      \sa qptrdiff, qint32, qint64 */
end_comment
begin_comment
comment|/*!     \typedef quintptr     \relates<QtGlobal>      Integral type for representing pointers in an unsigned integer (useful for     hashing, etc.).      Typedef for either quint32 or quint64. This type is guaranteed to     be the same size as a pointer on all platforms supported by Qt. On     a system with 32-bit pointers, quintptr is a typedef for quint32;     on a system with 64-bit pointers, quintptr is a typedef for     quint64.      Note that quintptr is unsigned. Use qptrdiff for signed values.      \sa qptrdiff, quint32, quint64 */
end_comment
begin_comment
comment|/*!     \typedef qptrdiff     \relates<QtGlobal>      Integral type for representing pointer differences.      Typedef for either qint32 or qint64. This type is guaranteed to be     the same size as a pointer on all platforms supported by Qt. On a     system with 32-bit pointers, quintptr is a typedef for quint32; on     a system with 64-bit pointers, quintptr is a typedef for quint64.      Note that qptrdiff is signed. Use quintptr for unsigned values.      \sa quintptr, qint32, qint64 */
end_comment
begin_comment
comment|/*!     \enum QtMsgType     \relates<QtGlobal>      This enum describes the messages that can be sent to a message     handler (QtMessageHandler). You can use the enum to identify and     associate the various message types with the appropriate     actions.      \value QtDebugMsg            A message generated by the qDebug() function.     \value QtWarningMsg            A message generated by the qWarning() function.     \value QtCriticalMsg            A message generated by the qCritical() function.     \value QtFatalMsg            A message generated by the qFatal() function.     \value QtSystemMsg       \sa QtMessageHandler, qInstallMessageHandler() */
end_comment
begin_comment
comment|/*! \typedef QFunctionPointer     \relates<QtGlobal>      This is a typedef for \c{void (*)()}, a pointer to a function that takes     no arguments and returns void. */
end_comment
begin_comment
comment|/*! \macro qint64 Q_INT64_C(literal)     \relates<QtGlobal>      Wraps the signed 64-bit integer \a literal in a     platform-independent way.      Example:      \snippet code/src_corelib_global_qglobal.cpp 8      \sa qint64, Q_UINT64_C() */
end_comment
begin_comment
comment|/*! \macro quint64 Q_UINT64_C(literal)     \relates<QtGlobal>      Wraps the unsigned 64-bit integer \a literal in a     platform-independent way.      Example:      \snippet code/src_corelib_global_qglobal.cpp 9      \sa quint64, Q_INT64_C() */
end_comment
begin_comment
comment|/*! \typedef qlonglong     \relates<QtGlobal>      Typedef for \c{long long int} (\c __int64 on Windows). This is     the same as \l qint64.      \sa qulonglong, qint64 */
end_comment
begin_comment
comment|/*!     \typedef qulonglong     \relates<QtGlobal>      Typedef for \c{unsigned long long int} (\c{unsigned __int64} on     Windows). This is the same as \l quint64.      \sa quint64, qlonglong */
end_comment
begin_comment
comment|/*! \fn T qAbs(const T&value)     \relates<QtGlobal>      Compares \a value to the 0 of type T and returns the absolute     value. Thus if T is \e {double}, then \a value is compared to     \e{(double) 0}.      Example:      \snippet code/src_corelib_global_qglobal.cpp 10 */
end_comment
begin_comment
comment|/*! \fn int qRound(qreal value)     \relates<QtGlobal>      Rounds \a value to the nearest integer.      Example:      \snippet code/src_corelib_global_qglobal.cpp 11 */
end_comment
begin_comment
comment|/*! \fn qint64 qRound64(qreal value)     \relates<QtGlobal>      Rounds \a value to the nearest 64-bit integer.      Example:      \snippet code/src_corelib_global_qglobal.cpp 12 */
end_comment
begin_comment
comment|/*! \fn const T&qMin(const T&value1, const T&value2)     \relates<QtGlobal>      Returns the minimum of \a value1 and \a value2.      Example:      \snippet code/src_corelib_global_qglobal.cpp 13      \sa qMax(), qBound() */
end_comment
begin_comment
comment|/*! \fn const T&qMax(const T&value1, const T&value2)     \relates<QtGlobal>      Returns the maximum of \a value1 and \a value2.      Example:      \snippet code/src_corelib_global_qglobal.cpp 14      \sa qMin(), qBound() */
end_comment
begin_comment
comment|/*! \fn const T&qBound(const T&min, const T&value, const T&max)     \relates<QtGlobal>      Returns \a value bounded by \a min and \a max. This is equivalent     to qMax(\a min, qMin(\a value, \a max)).      Example:      \snippet code/src_corelib_global_qglobal.cpp 15      \sa qMin(), qMax() */
end_comment
begin_comment
comment|/*!     \macro QT_VERSION_CHECK     \relates<QtGlobal>      Turns the major, minor and patch numbers of a version into an     integer, 0xMMNNPP (MM = major, NN = minor, PP = patch). This can     be compared with another similarly processed version id.      Example:      \snippet code/src_corelib_global_qglobal.cpp qt-version-check      \sa QT_VERSION */
end_comment
begin_comment
comment|/*!     \macro QT_VERSION     \relates<QtGlobal>      This macro expands a numeric value of the form 0xMMNNPP (MM =     major, NN = minor, PP = patch) that specifies Qt's version     number. For example, if you compile your application against Qt     4.1.2, the QT_VERSION macro will expand to 0x040102.      You can use QT_VERSION to use the latest Qt features where     available.      Example:      \snippet code/src_corelib_global_qglobal.cpp 16      \sa QT_VERSION_STR, qVersion() */
end_comment
begin_comment
comment|/*!     \macro QT_VERSION_STR     \relates<QtGlobal>      This macro expands to a string that specifies Qt's version number     (for example, "4.1.2"). This is the version against which the     application is compiled.      \sa qVersion(), QT_VERSION */
end_comment
begin_comment
comment|/*!     \relates<QtGlobal>      Returns the version number of Qt at run-time as a string (for     example, "4.1.2"). This may be a different version than the     version the application was compiled against.      \sa QT_VERSION_STR */
end_comment
begin_function
specifier|const
name|char
modifier|*
name|qVersion
parameter_list|()
name|Q_DECL_NOTHROW
block|{
return|return
name|QT_VERSION_STR
return|;
block|}
end_function
begin_function
name|bool
name|qSharedBuild
parameter_list|()
name|Q_DECL_NOTHROW
block|{
ifdef|#
directive|ifdef
name|QT_SHARED
return|return
literal|true
return|;
else|#
directive|else
return|return
literal|false
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*****************************************************************************   System detection routines  *****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QSysInfo     \inmodule QtCore     \brief The QSysInfo class provides information about the system.      \list     \li \l WordSize specifies the size of a pointer for the platform        on which the application is compiled.     \li \l ByteOrder specifies whether the platform is big-endian or        little-endian.     \li \l WindowsVersion specifies the version of the Windows operating        system on which the application is run (Windows only)     \li \l MacintoshVersion specifies the version of the Macintosh        operating system on which the application is run (Mac only).     \endlist      Some constants are defined only on certain platforms. You can use     the preprocessor symbols Q_OS_WIN and Q_OS_OSX to test that     the application is compiled under Windows or OS X.      \sa QLibraryInfo */
end_comment
begin_comment
comment|/*!     \enum QSysInfo::Sizes      This enum provides platform-specific information about the sizes of data     structures used by the underlying architecture.      \value WordSize The size in bits of a pointer for the platform on which            the application is compiled (32 or 64). */
end_comment
begin_comment
comment|/*!     \variable QSysInfo::WindowsVersion     \brief the version of the Windows operating system on which the            application is run (Windows only) */
end_comment
begin_comment
comment|/*!     \fn QSysInfo::WindowsVersion QSysInfo::windowsVersion()     \since 4.4      Returns the version of the Windows operating system on which the     application is run (Windows only). */
end_comment
begin_comment
comment|/*!     \variable QSysInfo::MacintoshVersion     \brief the version of the Macintosh operating system on which            the application is run (Mac only). */
end_comment
begin_comment
comment|/*!     \fn QSysInfo::MacVersion QSysInfo::macVersion()      Returns the version of Darwin (OS X or iOS) on which the application is run. */
end_comment
begin_comment
comment|/*!     \enum QSysInfo::Endian      \value BigEndian  Big-endian byte order (also called Network byte order)     \value LittleEndian  Little-endian byte order     \value ByteOrder  Equals BigEndian or LittleEndian, depending on                       the platform's byte order. */
end_comment
begin_comment
comment|/*!     \enum QSysInfo::WinVersion      This enum provides symbolic names for the various versions of the     Windows operating system. On Windows, the     QSysInfo::WindowsVersion variable gives the version of the system     on which the application is run.      MS-DOS-based versions:      \value WV_32s   Windows 3.1 with Win 32s     \value WV_95    Windows 95     \value WV_98    Windows 98     \value WV_Me    Windows Me      NT-based versions (note that each operating system version is only represented once rather than each Windows edition):      \value WV_NT    Windows NT (operating system version 4.0)     \value WV_2000  Windows 2000 (operating system version 5.0)     \value WV_XP    Windows XP (operating system version 5.1)     \value WV_2003  Windows Server 2003, Windows Server 2003 R2, Windows Home Server, Windows XP Professional x64 Edition (operating system version 5.2)     \value WV_VISTA Windows Vista, Windows Server 2008 (operating system version 6.0)     \value WV_WINDOWS7 Windows 7, Windows Server 2008 R2 (operating system version 6.1)     \value WV_WINDOWS8 Windows 8 (operating system version 6.2)     \value WV_WINDOWS8_1 Windows 8.1 (operating system version 6.3), introduced in Qt 5.2      Alternatively, you may use the following macros which correspond directly to the Windows operating system version number:      \value WV_4_0   Operating system version 4.0, corresponds to Windows NT     \value WV_5_0   Operating system version 5.0, corresponds to Windows 2000     \value WV_5_1   Operating system version 5.1, corresponds to Windows XP     \value WV_5_2   Operating system version 5.2, corresponds to Windows Server 2003, Windows Server 2003 R2, Windows Home Server, and Windows XP Professional x64 Edition     \value WV_6_0   Operating system version 6.0, corresponds to Windows Vista and Windows Server 2008     \value WV_6_1   Operating system version 6.1, corresponds to Windows 7 and Windows Server 2008 R2     \value WV_6_2   Operating system version 6.2, corresponds to Windows 8     \value WV_6_3   Operating system version 6.3, corresponds to Windows 8.1, introduced in Qt 5.2      CE-based versions:      \value WV_CE    Windows CE     \value WV_CENET Windows CE .NET     \value WV_CE_5  Windows CE 5.x     \value WV_CE_6  Windows CE 6.x      The following masks can be used for testing whether a Windows     version is MS-DOS-based, NT-based, or CE-based:      \value WV_DOS_based MS-DOS-based version of Windows     \value WV_NT_based  NT-based version of Windows     \value WV_CE_based  CE-based version of Windows      \sa MacVersion */
end_comment
begin_comment
comment|/*!     \enum QSysInfo::MacVersion      This enum provides symbolic names for the various versions of the     Darwin operating system, covering both OS X and iOS. The     QSysInfo::MacintoshVersion variable gives the version of the     system on which the application is run.      \value MV_9        Mac OS 9 (unsupported)     \value MV_10_0     Mac OS X 10.0 (unsupported)     \value MV_10_1     Mac OS X 10.1 (unsupported)     \value MV_10_2     Mac OS X 10.2 (unsupported)     \value MV_10_3     Mac OS X 10.3 (unsupported)     \value MV_10_4     Mac OS X 10.4 (unsupported)     \value MV_10_5     Mac OS X 10.5 (unsupported)     \value MV_10_6     Mac OS X 10.6     \value MV_10_7     OS X 10.7     \value MV_10_8     OS X 10.8     \value MV_10_9     OS X 10.9     \value MV_10_10    OS X 10.10     \value MV_Unknown  An unknown and currently unsupported platform      \value MV_CHEETAH  Apple codename for MV_10_0     \value MV_PUMA     Apple codename for MV_10_1     \value MV_JAGUAR   Apple codename for MV_10_2     \value MV_PANTHER  Apple codename for MV_10_3     \value MV_TIGER    Apple codename for MV_10_4     \value MV_LEOPARD  Apple codename for MV_10_5     \value MV_SNOWLEOPARD  Apple codename for MV_10_6     \value MV_LION     Apple codename for MV_10_7     \value MV_MOUNTAINLION Apple codename for MV_10_8     \value MV_MAVERICKS    Apple codename for MV_10_9     \value MV_YOSEMITE     Apple codename for MV_10_10      \value MV_IOS      iOS (any)     \value MV_IOS_4_3  iOS 4.3     \value MV_IOS_5_0  iOS 5.0     \value MV_IOS_5_1  iOS 5.1     \value MV_IOS_6_0  iOS 6.0     \value MV_IOS_6_1  iOS 6.1     \value MV_IOS_7_0  iOS 7.0     \value MV_IOS_7_1  iOS 7.1     \value MV_IOS_8_0  iOS 8.0      \sa WinVersion */
end_comment
begin_comment
comment|/*!     \macro Q_OS_DARWIN     \relates<QtGlobal>      Defined on Darwin-based operating systems such as OS X and iOS,     including any open source version(s) of Darwin. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_MAC     \relates<QtGlobal>      Defined on Darwin-based operating systems distributed by Apple, which     currently includes OS X and iOS, but not the open source version.  */
end_comment
begin_comment
comment|/*!     \macro Q_OS_OSX     \relates<QtGlobal>      Defined on OS X.  */
end_comment
begin_comment
comment|/*!     \macro Q_OS_IOS     \relates<QtGlobal>      Defined on iOS.  */
end_comment
begin_comment
comment|/*!     \macro Q_OS_WIN     \relates<QtGlobal>      Defined on all supported versions of Windows. That is, if     \l Q_OS_WIN32, \l Q_OS_WIN64 or \l Q_OS_WINCE is defined. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_WIN32     \relates<QtGlobal>      Defined on 32-bit and 64-bit versions of Windows (not on Windows CE). */
end_comment
begin_comment
comment|/*!     \macro Q_OS_WIN64     \relates<QtGlobal>      Defined on 64-bit versions of Windows. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_WINCE     \relates<QtGlobal>      Defined on Windows CE. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_WINRT     \relates<QtGlobal>      Defined for Windows Runtime (Windows Store apps) on Windows 8, Windows RT,     and Windows Phone 8. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_WINPHONE     \relates<QtGlobal>      Defined on Windows Phone 8. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_CYGWIN     \relates<QtGlobal>      Defined on Cygwin. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_SOLARIS     \relates<QtGlobal>      Defined on Sun Solaris. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_HPUX     \relates<QtGlobal>      Defined on HP-UX. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_ULTRIX     \relates<QtGlobal>      Defined on DEC Ultrix. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_LINUX     \relates<QtGlobal>      Defined on Linux. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_ANDROID     \relates<QtGlobal>      Defined on Android. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_FREEBSD     \relates<QtGlobal>      Defined on FreeBSD. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_NETBSD     \relates<QtGlobal>      Defined on NetBSD. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_OPENBSD     \relates<QtGlobal>      Defined on OpenBSD. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_BSDI     \relates<QtGlobal>      Defined on BSD/OS. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_IRIX     \relates<QtGlobal>      Defined on SGI Irix. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_OSF     \relates<QtGlobal>      Defined on HP Tru64 UNIX. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_SCO     \relates<QtGlobal>      Defined on SCO OpenServer 5. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_UNIXWARE     \relates<QtGlobal>      Defined on UnixWare 7, Open UNIX 8. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_AIX     \relates<QtGlobal>      Defined on AIX. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_HURD     \relates<QtGlobal>      Defined on GNU Hurd. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_DGUX     \relates<QtGlobal>      Defined on DG/UX. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_RELIANT     \relates<QtGlobal>      Defined on Reliant UNIX. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_DYNIX     \relates<QtGlobal>      Defined on DYNIX/ptx. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_QNX     \relates<QtGlobal>      Defined on QNX Neutrino. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_LYNX     \relates<QtGlobal>      Defined on LynxOS. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_BSD4     \relates<QtGlobal>      Defined on Any BSD 4.4 system. */
end_comment
begin_comment
comment|/*!     \macro Q_OS_UNIX     \relates<QtGlobal>      Defined on Any UNIX BSD/SYSV system. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_SYM     \relates<QtGlobal>      Defined if the application is compiled using Digital Mars C/C++     (used to be Symantec C++). */
end_comment
begin_comment
comment|/*!     \macro Q_CC_MSVC     \relates<QtGlobal>      Defined if the application is compiled using Microsoft Visual     C/C++, Intel C++ for Windows. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_BOR     \relates<QtGlobal>      Defined if the application is compiled using Borland/Turbo C++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_WAT     \relates<QtGlobal>      Defined if the application is compiled using Watcom C++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_GNU     \relates<QtGlobal>      Defined if the application is compiled using GNU C++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_COMEAU     \relates<QtGlobal>      Defined if the application is compiled using Comeau C++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_EDG     \relates<QtGlobal>      Defined if the application is compiled using Edison Design Group     C++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_OC     \relates<QtGlobal>      Defined if the application is compiled using CenterLine C++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_SUN     \relates<QtGlobal>      Defined if the application is compiled using Forte Developer, or     Sun Studio C++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_MIPS     \relates<QtGlobal>      Defined if the application is compiled using MIPSpro C++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_DEC     \relates<QtGlobal>      Defined if the application is compiled using DEC C++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_HPACC     \relates<QtGlobal>      Defined if the application is compiled using HP aC++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_USLC     \relates<QtGlobal>      Defined if the application is compiled using SCO OUDK and UDK. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_CDS     \relates<QtGlobal>      Defined if the application is compiled using Reliant C++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_KAI     \relates<QtGlobal>      Defined if the application is compiled using KAI C++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_INTEL     \relates<QtGlobal>      Defined if the application is compiled using Intel C++ for Linux,     Intel C++ for Windows. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_HIGHC     \relates<QtGlobal>      Defined if the application is compiled using MetaWare High C/C++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_PGI     \relates<QtGlobal>      Defined if the application is compiled using Portland Group C++. */
end_comment
begin_comment
comment|/*!     \macro Q_CC_GHS     \relates<QtGlobal>      Defined if the application is compiled using Green Hills     Optimizing C++ Compilers. */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_ALPHA     \relates<QtGlobal>      Defined if the application is compiled for Alpha processors.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_ARM     \relates<QtGlobal>      Defined if the application is compiled for ARM processors. Qt currently     supports three optional ARM revisions: \l Q_PROCESSOR_ARM_V5, \l     Q_PROCESSOR_ARM_V6, and \l Q_PROCESSOR_ARM_V7.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_ARM_V5     \relates<QtGlobal>      Defined if the application is compiled for ARMv5 processors. The \l     Q_PROCESSOR_ARM macro is also defined when Q_PROCESSOR_ARM_V5 is defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_ARM_V6     \relates<QtGlobal>      Defined if the application is compiled for ARMv6 processors. The \l     Q_PROCESSOR_ARM and \l Q_PROCESSOR_ARM_V5 macros are also defined when     Q_PROCESSOR_ARM_V6 is defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_ARM_V7     \relates<QtGlobal>      Defined if the application is compiled for ARMv7 processors. The \l     Q_PROCESSOR_ARM, \l Q_PROCESSOR_ARM_V5, and \l Q_PROCESSOR_ARM_V6 macros     are also defined when Q_PROCESSOR_ARM_V7 is defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_AVR32     \relates<QtGlobal>      Defined if the application is compiled for AVR32 processors.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_BLACKFIN     \relates<QtGlobal>      Defined if the application is compiled for Blackfin processors.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_IA64     \relates<QtGlobal>      Defined if the application is compiled for IA-64 processors. This includes     all Itanium and Itanium 2 processors.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_MIPS     \relates<QtGlobal>      Defined if the application is compiled for MIPS processors. Qt currently     supports seven MIPS revisions: \l Q_PROCESSOR_MIPS_I, \l     Q_PROCESSOR_MIPS_II, \l Q_PROCESSOR_MIPS_III, \l Q_PROCESSOR_MIPS_IV, \l     Q_PROCESSOR_MIPS_V, \l Q_PROCESSOR_MIPS_32, and \l Q_PROCESSOR_MIPS_64.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_MIPS_I     \relates<QtGlobal>      Defined if the application is compiled for MIPS-I processors. The \l     Q_PROCESSOR_MIPS macro is also defined when Q_PROCESSOR_MIPS_I is defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_MIPS_II     \relates<QtGlobal>      Defined if the application is compiled for MIPS-II processors. The \l     Q_PROCESSOR_MIPS and \l Q_PROCESSOR_MIPS_I macros are also defined when     Q_PROCESSOR_MIPS_II is defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_MIPS_32     \relates<QtGlobal>      Defined if the application is compiled for MIPS32 processors. The \l     Q_PROCESSOR_MIPS, \l Q_PROCESSOR_MIPS_I, and \l Q_PROCESSOR_MIPS_II macros     are also defined when Q_PROCESSOR_MIPS_32 is defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_MIPS_III     \relates<QtGlobal>      Defined if the application is compiled for MIPS-III processors. The \l     Q_PROCESSOR_MIPS, \l Q_PROCESSOR_MIPS_I, and \l Q_PROCESSOR_MIPS_II macros     are also defined when Q_PROCESSOR_MIPS_III is defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_MIPS_IV     \relates<QtGlobal>      Defined if the application is compiled for MIPS-IV processors. The \l     Q_PROCESSOR_MIPS, \l Q_PROCESSOR_MIPS_I, \l Q_PROCESSOR_MIPS_II, and \l     Q_PROCESSOR_MIPS_III macros are also defined when Q_PROCESSOR_MIPS_IV is     defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_MIPS_V     \relates<QtGlobal>      Defined if the application is compiled for MIPS-V processors. The \l     Q_PROCESSOR_MIPS, \l Q_PROCESSOR_MIPS_I, \l Q_PROCESSOR_MIPS_II, \l     Q_PROCESSOR_MIPS_III, and \l Q_PROCESSOR_MIPS_IV macros are also defined     when Q_PROCESSOR_MIPS_V is defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_MIPS_64     \relates<QtGlobal>      Defined if the application is compiled for MIPS64 processors. The \l     Q_PROCESSOR_MIPS, \l Q_PROCESSOR_MIPS_I, \l Q_PROCESSOR_MIPS_II, \l     Q_PROCESSOR_MIPS_III, \l Q_PROCESSOR_MIPS_IV, and \l Q_PROCESSOR_MIPS_V     macros are also defined when Q_PROCESSOR_MIPS_64 is defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_POWER     \relates<QtGlobal>      Defined if the application is compiled for POWER processors. Qt currently     supports two Power variants: \l Q_PROCESSOR_POWER_32 and \l     Q_PROCESSOR_POWER_64.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_POWER_32     \relates<QtGlobal>      Defined if the application is compiled for 32-bit Power processors. The \l     Q_PROCESSOR_POWER macro is also defined when Q_PROCESSOR_POWER_32 is     defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_POWER_64     \relates<QtGlobal>      Defined if the application is compiled for 64-bit Power processors. The \l     Q_PROCESSOR_POWER macro is also defined when Q_PROCESSOR_POWER_64 is     defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_S390     \relates<QtGlobal>      Defined if the application is compiled for S/390 processors. Qt supports     one optional variant of S/390: Q_PROCESSOR_S390_X.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_S390_X     \relates<QtGlobal>      Defined if the application is compiled for S/390x processors. The \l     Q_PROCESSOR_S390 macro is also defined when Q_PROCESSOR_S390_X is defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_SH     \relates<QtGlobal>      Defined if the application is compiled for SuperH processors. Qt currently     supports one SuperH revision: \l Q_PROCESSOR_SH_4A.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_SH_4A     \relates<QtGlobal>      Defined if the application is compiled for SuperH 4A processors. The \l     Q_PROCESSOR_SH macro is also defined when Q_PROCESSOR_SH_4A is defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_SPARC     \relates<QtGlobal>      Defined if the application is compiled for SPARC processors. Qt currently     supports one optional SPARC revision: \l Q_PROCESSOR_SPARC_V9.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_SPARC_V9     \relates<QtGlobal>      Defined if the application is compiled for SPARC V9 processors. The \l     Q_PROCESSOR_SPARC macro is also defined when Q_PROCESSOR_SPARC_V9 is     defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_X86     \relates<QtGlobal>      Defined if the application is compiled for x86 processors. Qt currently     supports two x86 variants: \l Q_PROCESSOR_X86_32 and \l Q_PROCESSOR_X86_64.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_X86_32     \relates<QtGlobal>      Defined if the application is compiled for 32-bit x86 processors. This     includes all i386, i486, i586, and i686 processors. The \l Q_PROCESSOR_X86     macro is also defined when Q_PROCESSOR_X86_32 is defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!     \macro Q_PROCESSOR_X86_64     \relates<QtGlobal>      Defined if the application is compiled for 64-bit x86 processors. This     includes all AMD64, Intel 64, and other x86_64/x64 processors. The \l     Q_PROCESSOR_X86 macro is also defined when Q_PROCESSOR_X86_64 is defined.      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_comment
comment|/*!   \macro QT_DISABLE_DEPRECATED_BEFORE   \relates<QtGlobal>    This macro can be defined in the project file to disable functions deprecated in   a specified version of Qt or any earlier version. The default version number is 5.0,   meaning that functions deprecated in or before Qt 5.0 will not be included.    Examples:   When using a future release of Qt 5, set QT_DISABLE_DEPRECATED_BEFORE=0x050100 to   disable functions deprecated in Qt 5.1 and earlier. In any release, set   QT_DISABLE_DEPRECATED_BEFORE=0x000000 to enable any functions, including the ones   deprecated in Qt 5.0  */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_QMAKE
argument_list|)
end_if
begin_comment
comment|// needed to bootstrap qmake
end_comment
begin_decl_stmt
DECL|variable|qt_one
specifier|static
specifier|const
name|unsigned
name|int
name|qt_one
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|ByteOrder
specifier|const
name|int
name|QSysInfo
operator|::
name|ByteOrder
init|=
operator|(
operator|(
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|qt_one
operator|)
operator|==
literal|0
operator|)
condition|?
name|BigEndian
else|:
name|LittleEndian
operator|)
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_function
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|"private/qcore_mac_p.h"
include|#
directive|include
file|"qnamespace.h"
name|QT_END_INCLUDE_NAMESPACE
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_OSX
argument_list|)
DECL|function|qt_mac_create_fsref
name|Q_CORE_EXPORT
name|OSErr
name|qt_mac_create_fsref
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|,
name|FSRef
modifier|*
name|fsref
parameter_list|)
block|{
return|return
name|FSPathMakeRef
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|UInt8
operator|*
argument_list|>
argument_list|(
name|file
operator|.
name|toUtf8
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|,
name|fsref
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qt_mac_to_pascal_string
name|Q_CORE_EXPORT
name|void
name|qt_mac_to_pascal_string
parameter_list|(
name|QString
name|s
parameter_list|,
name|Str255
name|str
parameter_list|,
name|TextEncoding
name|encoding
init|=
literal|0
parameter_list|,
name|int
name|len
init|=
operator|-
literal|1
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|CFStringGetPascalString
argument_list|(
name|QCFString
argument_list|(
name|s
argument_list|)
argument_list|,
name|str
argument_list|,
literal|256
argument_list|,
name|CFStringGetSystemEncoding
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_mac_from_pascal_string
name|Q_CORE_EXPORT
name|QString
name|qt_mac_from_pascal_string
parameter_list|(
specifier|const
name|Str255
name|pstr
parameter_list|)
block|{
return|return
name|QCFString
argument_list|(
name|CFStringCreateWithPascalString
argument_list|(
literal|0
argument_list|,
name|pstr
argument_list|,
name|CFStringGetSystemEncoding
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// defined(Q_OS_OSX)
end_comment
begin_function
DECL|function|macVersion
name|QSysInfo
operator|::
name|MacVersion
name|QSysInfo
operator|::
name|macVersion
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_OSX
argument_list|)
name|SInt32
name|gestalt_version
decl_stmt|;
if|if
condition|(
name|Gestalt
argument_list|(
name|gestaltSystemVersionMinor
argument_list|,
operator|&
name|gestalt_version
argument_list|)
operator|==
name|noErr
condition|)
block|{
comment|// add 2 because OS X 10.0 is 0x02 in the enum
return|return
name|QSysInfo
operator|::
name|MacVersion
argument_list|(
name|gestalt_version
operator|+
literal|2
argument_list|)
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
return|return
name|qt_ios_version
argument_list|()
return|;
comment|// qtcore_mac_objc.mm
endif|#
directive|endif
return|return
name|QSysInfo
operator|::
name|MV_Unknown
return|;
block|}
end_function
begin_decl_stmt
DECL|member|MacintoshVersion
specifier|const
name|QSysInfo
operator|::
name|MacVersion
name|QSysInfo
operator|::
name|MacintoshVersion
init|=
name|QSysInfo
operator|::
name|macVersion
argument_list|()
decl_stmt|;
end_decl_stmt
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_CYGWIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
end_elif
begin_function
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|"qt_windows.h"
name|QT_END_INCLUDE_NAMESPACE
ifndef|#
directive|ifndef
name|Q_OS_WINRT
DECL|function|winOsVersion
specifier|static
specifier|inline
name|OSVERSIONINFO
name|winOsVersion
parameter_list|()
block|{
name|OSVERSIONINFO
name|result
init|=
block|{
sizeof|sizeof
argument_list|(
name|OSVERSIONINFO
argument_list|)
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|'\0'
block|}
block|}
decl_stmt|;
comment|// GetVersionEx() has been deprecated in Windows 8.1 and will return
comment|// only Windows 8 from that version on.
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1800
pragma|#
directive|pragma
name|warning
name|(
name|push
name|)
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4996
name|)
endif|#
directive|endif
name|GetVersionEx
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1800
pragma|#
directive|pragma
name|warning
name|(
name|pop
name|)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_OS_WINCE
if|if
condition|(
name|result
operator|.
name|dwMajorVersion
operator|==
literal|6
operator|&&
name|result
operator|.
name|dwMinorVersion
operator|==
literal|2
condition|)
block|{
comment|// This could be Windows 8.1 or higher. Note that as of Windows 9,
comment|// the major version needs to be checked as well.
name|DWORDLONG
name|conditionMask
init|=
literal|0
decl_stmt|;
name|VER_SET_CONDITION
argument_list|(
name|conditionMask
argument_list|,
name|VER_MAJORVERSION
argument_list|,
name|VER_GREATER_EQUAL
argument_list|)
expr_stmt|;
name|VER_SET_CONDITION
argument_list|(
name|conditionMask
argument_list|,
name|VER_MINORVERSION
argument_list|,
name|VER_GREATER_EQUAL
argument_list|)
expr_stmt|;
name|VER_SET_CONDITION
argument_list|(
name|conditionMask
argument_list|,
name|VER_PLATFORMID
argument_list|,
name|VER_EQUAL
argument_list|)
expr_stmt|;
name|OSVERSIONINFOEX
name|checkVersion
init|=
block|{
sizeof|sizeof
argument_list|(
name|OSVERSIONINFOEX
argument_list|)
block|,
name|result
operator|.
name|dwMajorVersion
block|,
name|result
operator|.
name|dwMinorVersion
block|,
name|result
operator|.
name|dwBuildNumber
block|,
name|result
operator|.
name|dwPlatformId
block|,
block|{
literal|'\0'
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
init|;
name|VerifyVersionInfo
argument_list|(
operator|&
name|checkVersion
argument_list|,
name|VER_MAJORVERSION
operator||
name|VER_MINORVERSION
operator||
name|VER_PLATFORMID
argument_list|,
name|conditionMask
argument_list|)
condition|;
operator|++
name|checkVersion
operator|.
name|dwMinorVersion
control|)
name|result
operator|.
name|dwMinorVersion
operator|=
name|checkVersion
operator|.
name|dwMinorVersion
expr_stmt|;
block|}
endif|#
directive|endif
comment|// !Q_OS_WINCE
return|return
name|result
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !Q_OS_WINRT
end_comment
begin_function
DECL|function|windowsVersion
name|QSysInfo
operator|::
name|WinVersion
name|QSysInfo
operator|::
name|windowsVersion
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|VER_PLATFORM_WIN32s
DECL|macro|VER_PLATFORM_WIN32s
define|#
directive|define
name|VER_PLATFORM_WIN32s
value|0
endif|#
directive|endif
ifndef|#
directive|ifndef
name|VER_PLATFORM_WIN32_WINDOWS
DECL|macro|VER_PLATFORM_WIN32_WINDOWS
define|#
directive|define
name|VER_PLATFORM_WIN32_WINDOWS
value|1
endif|#
directive|endif
ifndef|#
directive|ifndef
name|VER_PLATFORM_WIN32_NT
DECL|macro|VER_PLATFORM_WIN32_NT
define|#
directive|define
name|VER_PLATFORM_WIN32_NT
value|2
endif|#
directive|endif
ifndef|#
directive|ifndef
name|VER_PLATFORM_WIN32_CE
DECL|macro|VER_PLATFORM_WIN32_CE
define|#
directive|define
name|VER_PLATFORM_WIN32_CE
value|3
endif|#
directive|endif
specifier|static
name|QSysInfo
operator|::
name|WinVersion
name|winver
decl_stmt|;
if|if
condition|(
name|winver
condition|)
return|return
name|winver
return|;
ifdef|#
directive|ifdef
name|Q_OS_WINRT
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_WINDOWS8_1
expr_stmt|;
else|#
directive|else
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_NT
expr_stmt|;
specifier|const
name|OSVERSIONINFO
name|osver
init|=
name|winOsVersion
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WINCE
name|DWORD
name|qt_cever
init|=
literal|0
decl_stmt|;
name|qt_cever
operator|=
name|osver
operator|.
name|dwMajorVersion
operator|*
literal|100
expr_stmt|;
name|qt_cever
operator|+=
name|osver
operator|.
name|dwMinorVersion
operator|*
literal|10
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|osver
operator|.
name|dwPlatformId
condition|)
block|{
case|case
name|VER_PLATFORM_WIN32s
case|:
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_32s
expr_stmt|;
break|break;
case|case
name|VER_PLATFORM_WIN32_WINDOWS
case|:
comment|// We treat Windows Me (minor 90) the same as Windows 98
if|if
condition|(
name|osver
operator|.
name|dwMinorVersion
operator|==
literal|90
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_Me
expr_stmt|;
elseif|else
if|if
condition|(
name|osver
operator|.
name|dwMinorVersion
operator|==
literal|10
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_98
expr_stmt|;
else|else
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_95
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|Q_OS_WINCE
case|case
name|VER_PLATFORM_WIN32_CE
case|:
if|if
condition|(
name|qt_cever
operator|>=
literal|600
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_CE_6
expr_stmt|;
if|if
condition|(
name|qt_cever
operator|>=
literal|500
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_CE_5
expr_stmt|;
elseif|else
if|if
condition|(
name|qt_cever
operator|>=
literal|400
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_CENET
expr_stmt|;
else|else
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_CE
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|// VER_PLATFORM_WIN32_NT
if|if
condition|(
name|osver
operator|.
name|dwMajorVersion
operator|<
literal|5
condition|)
block|{
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_NT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osver
operator|.
name|dwMajorVersion
operator|==
literal|5
operator|&&
name|osver
operator|.
name|dwMinorVersion
operator|==
literal|0
condition|)
block|{
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_2000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osver
operator|.
name|dwMajorVersion
operator|==
literal|5
operator|&&
name|osver
operator|.
name|dwMinorVersion
operator|==
literal|1
condition|)
block|{
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_XP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osver
operator|.
name|dwMajorVersion
operator|==
literal|5
operator|&&
name|osver
operator|.
name|dwMinorVersion
operator|==
literal|2
condition|)
block|{
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_2003
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osver
operator|.
name|dwMajorVersion
operator|==
literal|6
operator|&&
name|osver
operator|.
name|dwMinorVersion
operator|==
literal|0
condition|)
block|{
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_VISTA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osver
operator|.
name|dwMajorVersion
operator|==
literal|6
operator|&&
name|osver
operator|.
name|dwMinorVersion
operator|==
literal|1
condition|)
block|{
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_WINDOWS7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osver
operator|.
name|dwMajorVersion
operator|==
literal|6
operator|&&
name|osver
operator|.
name|dwMinorVersion
operator|==
literal|2
condition|)
block|{
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_WINDOWS8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osver
operator|.
name|dwMajorVersion
operator|==
literal|6
operator|&&
name|osver
operator|.
name|dwMinorVersion
operator|==
literal|3
condition|)
block|{
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_WINDOWS8_1
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Qt: Untested Windows version %d.%d detected!"
argument_list|,
name|int
argument_list|(
name|osver
operator|.
name|dwMajorVersion
argument_list|)
argument_list|,
name|int
argument_list|(
name|osver
operator|.
name|dwMinorVersion
argument_list|)
argument_list|)
expr_stmt|;
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_NT_based
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|QT_DEBUG
block|{
name|QByteArray
name|override
init|=
name|qgetenv
argument_list|(
literal|"QT_WINVER_OVERRIDE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|override
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|winver
return|;
if|if
condition|(
name|override
operator|==
literal|"Me"
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_Me
expr_stmt|;
if|if
condition|(
name|override
operator|==
literal|"95"
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_95
expr_stmt|;
elseif|else
if|if
condition|(
name|override
operator|==
literal|"98"
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_98
expr_stmt|;
elseif|else
if|if
condition|(
name|override
operator|==
literal|"NT"
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_NT
expr_stmt|;
elseif|else
if|if
condition|(
name|override
operator|==
literal|"2000"
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_2000
expr_stmt|;
elseif|else
if|if
condition|(
name|override
operator|==
literal|"2003"
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_2003
expr_stmt|;
elseif|else
if|if
condition|(
name|override
operator|==
literal|"XP"
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_XP
expr_stmt|;
elseif|else
if|if
condition|(
name|override
operator|==
literal|"VISTA"
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_VISTA
expr_stmt|;
elseif|else
if|if
condition|(
name|override
operator|==
literal|"WINDOWS7"
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_WINDOWS7
expr_stmt|;
elseif|else
if|if
condition|(
name|override
operator|==
literal|"WINDOWS8"
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_WINDOWS8
expr_stmt|;
elseif|else
if|if
condition|(
name|override
operator|==
literal|"WINDOWS8_1"
condition|)
name|winver
operator|=
name|QSysInfo
operator|::
name|WV_WINDOWS8_1
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|// !Q_OS_WINRT
return|return
name|winver
return|;
block|}
end_function
begin_function
DECL|function|winVer_helper
specifier|static
specifier|const
name|char
modifier|*
name|winVer_helper
parameter_list|()
block|{
switch|switch
condition|(
name|int
argument_list|(
name|QSysInfo
operator|::
name|WindowsVersion
argument_list|)
condition|)
block|{
case|case
name|QSysInfo
operator|::
name|WV_NT
case|:
return|return
literal|"NT"
return|;
case|case
name|QSysInfo
operator|::
name|WV_2000
case|:
return|return
literal|"2000"
return|;
case|case
name|QSysInfo
operator|::
name|WV_XP
case|:
return|return
literal|"XP"
return|;
case|case
name|QSysInfo
operator|::
name|WV_2003
case|:
return|return
literal|"2003"
return|;
case|case
name|QSysInfo
operator|::
name|WV_VISTA
case|:
return|return
literal|"Vista"
return|;
case|case
name|QSysInfo
operator|::
name|WV_WINDOWS7
case|:
return|return
literal|"7"
return|;
case|case
name|QSysInfo
operator|::
name|WV_WINDOWS8
case|:
return|return
literal|"8"
return|;
case|case
name|QSysInfo
operator|::
name|WV_WINDOWS8_1
case|:
return|return
literal|"8.1"
return|;
case|case
name|QSysInfo
operator|::
name|WV_CE
case|:
return|return
literal|"CE"
return|;
case|case
name|QSysInfo
operator|::
name|WV_CENET
case|:
return|return
literal|"CENET"
return|;
case|case
name|QSysInfo
operator|::
name|WV_CE_5
case|:
return|return
literal|"CE5"
return|;
case|case
name|QSysInfo
operator|::
name|WV_CE_6
case|:
return|return
literal|"CE6"
return|;
block|}
comment|// unknown, future version
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|member|WindowsVersion
specifier|const
name|QSysInfo
operator|::
name|WinVersion
name|QSysInfo
operator|::
name|WindowsVersion
init|=
name|QSysInfo
operator|::
name|windowsVersion
argument_list|()
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
end_if
begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|Q_OS_FREEBSD
argument_list|)
end_if
begin_define
DECL|macro|USE_ETC_OS_RELEASE
define|#
directive|define
name|USE_ETC_OS_RELEASE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_struct
DECL|struct|QUnixOSVersion
struct|struct
name|QUnixOSVersion
block|{
comment|// from uname(2)
DECL|member|sysName
name|QString
name|sysName
decl_stmt|;
DECL|member|sysNameLower
name|QString
name|sysNameLower
decl_stmt|;
DECL|member|sysRelease
name|QString
name|sysRelease
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
comment|// from /etc/os-release or guessed
DECL|member|versionIdentifier
name|QString
name|versionIdentifier
decl_stmt|;
comment|// ${ID}_$VERSION_ID
DECL|member|versionText
name|QString
name|versionText
decl_stmt|;
comment|// $PRETTY_NAME
endif|#
directive|endif
block|}
struct|;
end_struct
begin_ifdef
ifdef|#
directive|ifdef
name|USE_ETC_OS_RELEASE
end_ifdef
begin_function
DECL|function|unquote
specifier|static
name|QString
name|unquote
parameter_list|(
specifier|const
name|char
modifier|*
name|begin
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
operator|*
name|begin
operator|==
literal|'"'
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|end
index|[
operator|-
literal|1
index|]
operator|==
literal|'"'
argument_list|)
expr_stmt|;
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|begin
operator|+
literal|1
argument_list|,
name|end
operator|-
name|begin
operator|-
literal|2
argument_list|)
return|;
block|}
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|begin
argument_list|,
name|end
operator|-
name|begin
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|readEtcOsRelease
specifier|static
name|bool
name|readEtcOsRelease
parameter_list|(
name|QUnixOSVersion
modifier|&
name|v
parameter_list|)
block|{
comment|// we're avoiding QFile here
name|int
name|fd
init|=
name|qt_safe_open
argument_list|(
literal|"/etc/os-release"
argument_list|,
name|O_RDONLY
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
name|QT_STATBUF
name|sbuf
decl_stmt|;
if|if
condition|(
name|QT_FSTAT
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|qt_safe_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QString
name|partialIdentifier
decl_stmt|;
name|QByteArray
name|buffer
argument_list|(
name|sbuf
operator|.
name|st_size
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|resize
argument_list|(
name|qt_safe_read
argument_list|(
name|fd
argument_list|,
name|buffer
operator|.
name|data
argument_list|()
argument_list|,
name|sbuf
operator|.
name|st_size
argument_list|)
argument_list|)
expr_stmt|;
name|qt_safe_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|ptr
init|=
name|buffer
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|buffer
operator|.
name|constEnd
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
for|for
control|(
init|;
name|ptr
operator|!=
name|end
condition|;
name|ptr
operator|=
name|eol
operator|+
literal|1
control|)
block|{
specifier|static
specifier|const
name|char
name|idString
index|[]
init|=
literal|"ID="
decl_stmt|;
specifier|static
specifier|const
name|char
name|prettyNameString
index|[]
init|=
literal|"PRETTY_NAME="
decl_stmt|;
specifier|static
specifier|const
name|char
name|versionIdString
index|[]
init|=
literal|"VERSION_ID="
decl_stmt|;
comment|// find the end of the line after ptr
name|eol
operator|=
cast|static_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|memchr
argument_list|(
name|ptr
argument_list|,
literal|'\n'
argument_list|,
name|end
operator|-
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eol
condition|)
name|eol
operator|=
name|end
operator|-
literal|1
expr_stmt|;
name|int
name|cmp
init|=
name|strncmp
argument_list|(
name|ptr
argument_list|,
name|idString
argument_list|,
name|strlen
argument_list|(
name|idString
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
name|strlen
argument_list|(
name|idString
argument_list|)
expr_stmt|;
name|QString
name|id
init|=
name|unquote
argument_list|(
name|ptr
argument_list|,
name|eol
argument_list|)
decl_stmt|;
if|if
condition|(
name|partialIdentifier
operator|.
name|isNull
argument_list|()
condition|)
name|partialIdentifier
operator|=
name|id
expr_stmt|;
else|else
name|v
operator|.
name|versionIdentifier
operator|=
name|id
operator|+
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
operator|+
name|partialIdentifier
expr_stmt|;
continue|continue;
block|}
name|cmp
operator|=
name|strncmp
argument_list|(
name|ptr
argument_list|,
name|prettyNameString
argument_list|,
name|strlen
argument_list|(
name|prettyNameString
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
name|strlen
argument_list|(
name|prettyNameString
argument_list|)
expr_stmt|;
name|v
operator|.
name|versionText
operator|=
name|unquote
argument_list|(
name|ptr
argument_list|,
name|eol
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cmp
operator|=
name|strncmp
argument_list|(
name|ptr
argument_list|,
name|versionIdString
argument_list|,
name|strlen
argument_list|(
name|versionIdString
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
name|strlen
argument_list|(
name|versionIdString
argument_list|)
expr_stmt|;
name|QString
name|id
init|=
name|unquote
argument_list|(
name|ptr
argument_list|,
name|eol
argument_list|)
decl_stmt|;
if|if
condition|(
name|partialIdentifier
operator|.
name|isNull
argument_list|()
condition|)
name|partialIdentifier
operator|=
name|id
expr_stmt|;
else|else
name|v
operator|.
name|versionIdentifier
operator|=
name|partialIdentifier
operator|+
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
operator|+
name|id
expr_stmt|;
continue|continue;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// USE_ETC_OS_RELEASE
end_comment
begin_function
DECL|function|detectUnixVersion
specifier|static
name|QUnixOSVersion
name|detectUnixVersion
parameter_list|()
block|{
name|QUnixOSVersion
name|v
decl_stmt|;
name|struct
name|utsname
name|u
decl_stmt|;
if|if
condition|(
name|uname
argument_list|(
operator|&
name|u
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|v
operator|.
name|sysName
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|u
operator|.
name|sysname
argument_list|)
expr_stmt|;
name|v
operator|.
name|sysNameLower
operator|=
name|v
operator|.
name|sysName
operator|.
name|toLower
argument_list|()
expr_stmt|;
name|v
operator|.
name|sysRelease
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|u
operator|.
name|release
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|.
name|sysName
operator|=
name|QLatin1String
argument_list|(
literal|"Detection failed"
argument_list|)
expr_stmt|;
comment|// leave sysNameLower& sysRelease unset
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
ifdef|#
directive|ifdef
name|USE_ETC_OS_RELEASE
if|if
condition|(
name|readEtcOsRelease
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|v
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|v
operator|.
name|sysNameLower
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// will produce "qnx_6.5" or "sunos_5.9"
name|v
operator|.
name|versionIdentifier
operator|=
name|v
operator|.
name|sysNameLower
operator|+
name|QLatin1Char
argument_list|(
literal|'_'
argument_list|)
operator|+
name|v
operator|.
name|sysRelease
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|v
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_OS_UNIX
end_comment
begin_comment
comment|/*!     \since 5.4      Returns the architecture of the CPU that Qt was compiled for, in text     format. Note that this may not match the actual CPU that the application is     running on if there's an emulation layer or if the CPU supports multiple     architectures (like x86-64 processors supporting i386 applications).      Values returned by this function are stable and will not change over time,     so applications can rely on the returned value as an identifier, except     that new CPU types may be added over time.      Typical returned values are (note: list not exhaustive):     \list         \li "arm"         \li "i386"         \li "mips"         \li "x86_64"         \li "power"         \li "sparc"     \endlist      \sa QSysInfo::buildAbi() */
end_comment
begin_function
DECL|function|buildCpuArchitecture
name|QString
name|QSysInfo
operator|::
name|buildCpuArchitecture
parameter_list|()
block|{
return|return
name|QStringLiteral
argument_list|(
name|ARCH_PROCESSOR
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.4      Returns the full architecture string that Qt was compiled for. This string     is useful for identifying different, incompatible builds. For example, it     can be used as an identifier to request an upgrade package from a server.      The values returned from this function are kept stable as follows: the     mandatory components of the result will not change in future versions of     Qt, but optional suffixes may be added.      The returned value is composed of three or more parts, separated by dashes     ("-"). They are:      \table     \header \li Component           \li Value     \row    \li CPU Architecture    \li The same as QSysInfo::buildCpuArchitecture(), such as "arm", "i386", "mips" or "x86_64"     \row    \li Endianness          \li "little_endian" or "big_endian"     \row    \li Word size           \li Whether it's a 32- or 64-bit application. Possible values are:                                         "llp64" (Windows 64-bit), "lp64" (Unix 64-bit), "ilp32" (32-bit)     \row    \li (Optional) ABI      \li Zero or more components identifying different ABIs possible in this architecture.                                         Currently, Qt has optional ABI components for ARM and MIPS processors: one                                         component is the main ABI (such as "eabi", "o32", "n32", "o64"); another is                                         whether the calling convention is using hardware floating point registers ("hardfloat"                                         is present).                                          Additionally, if Qt was configured with \c{-qreal float}, the ABI option tag "qreal_float"                                         will be present. If Qt was configured with another type as qreal, that type is present after                                         "qreal_", with all characters other than letters and digits escaped by an underscore, followed                                         by two hex digits. For example, \c{-qreal long double} becomes "qreal_long_20double".     \endtable      \sa QSysInfo::buildCpuArchitecture() */
end_comment
begin_function
DECL|function|buildAbi
name|QString
name|QSysInfo
operator|::
name|buildAbi
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_COMPILER_UNICODE_STRINGS
comment|// ARCH_FULL is a concatenation of strings (incl. ARCH_PROCESSOR), which breaks
comment|// QStringLiteral on MSVC. Since the concatenation behavior we want is specified
comment|// the same C++11 paper as the Unicode strings, we'll use that macro and hope
comment|// that Microsoft implements the new behavior when they add support for Unicode strings.
return|return
name|QStringLiteral
argument_list|(
name|ARCH_FULL
argument_list|)
return|;
else|#
directive|else
return|return
name|QLatin1String
argument_list|(
name|ARCH_FULL
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|unknownText
specifier|static
name|QString
name|unknownText
parameter_list|()
block|{
return|return
name|QStringLiteral
argument_list|(
literal|"unknown"
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.4      Returns the type of the operating system Qt was compiled for. It's also the     operating system the application is running on, unless the host operating     system is running a form of compatibility layer.      Values returned by this function are stable and will not change over time,     so applications can rely on the returned value as an identifier, except     that new OS types may be added over time.      \b{Android note}: this function returns "android" for Linux systems running     Android userspace, notably when using the Bionic library. For all other     Linux systems, regardless of C library being used, it returns "linux".      \b{BlackBerry note}: this function returns "blackberry" for QNX systems     running the BlackBerry userspace, but "qnx" for all other QNX-based     systems.      \b{Darwin, OS X and iOS note}: this function returns "osx" for OS X     systems, "ios" for iOS systems and "darwin" in case the system could not be     determined.      \b{FreeBSD note}: this function returns "freebsd" for systems running the     FreeBSD kernel, regardless of whether the userspace runs the traditional     BSD code or whether it's the GNU system (Debian GNU/kFreeBSD).      \sa QFileSelector, prettyOsName() */
end_comment
begin_function
DECL|function|osType
name|QString
name|QSysInfo
operator|::
name|osType
parameter_list|()
block|{
comment|// similar, but not identical to QFileSelectorPrivate::platformSelectors
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINPHONE
argument_list|)
return|return
name|QStringLiteral
argument_list|(
literal|"winphone"
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
return|return
name|QStringLiteral
argument_list|(
literal|"winrt"
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
return|return
name|QStringLiteral
argument_list|(
literal|"wince"
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
return|return
name|QStringLiteral
argument_list|(
literal|"windows"
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
return|return
name|QStringLiteral
argument_list|(
literal|"blackberry"
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
return|return
name|QStringLiteral
argument_list|(
literal|"qnx"
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
return|return
name|QStringLiteral
argument_list|(
literal|"android"
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
return|return
name|QStringLiteral
argument_list|(
literal|"linux"
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
return|return
name|QStringLiteral
argument_list|(
literal|"ios"
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_OSX
argument_list|)
return|return
name|QStringLiteral
argument_list|(
literal|"osx"
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
return|return
name|QStringLiteral
argument_list|(
literal|"darwin"
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_FREEBSD_KERNEL
argument_list|)
return|return
name|QStringLiteral
argument_list|(
literal|"freebsd"
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|QUnixOSVersion
name|unixOsVersion
init|=
name|detectUnixVersion
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|unixOsVersion
operator|.
name|sysNameLower
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|unixOsVersion
operator|.
name|sysNameLower
return|;
endif|#
directive|endif
return|return
name|unknownText
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.4      Returns the version of the host operating system in string form. For both     OS X and iOS systems, this returns just the main OS version, such as "7.1",     "10.6" and "10.7". For Windows systems, this returns the same types     detected by winVersion(), without the word "Windows". For Linux-based     systems, it will try to determine the Linux distribution and version.      If the version could not be determined, this function returns "unknown" for     Windows and a combination of the osType() and osKernelVersion() for Unix     systems.      \sa prettyOsName(), osKernelVersion() */
end_comment
begin_function
DECL|function|osVersion
name|QString
name|QSysInfo
operator|::
name|osVersion
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
name|int
name|major
init|=
operator|(
name|int
argument_list|(
name|MacintoshVersion
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0xf
decl_stmt|;
name|int
name|minor
init|=
name|int
argument_list|(
name|MacintoshVersion
argument_list|)
operator|&
literal|0xf
decl_stmt|;
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|major
operator|<
literal|10
operator|&&
name|minor
operator|<
literal|10
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|4
index|]
init|=
block|{
name|char
argument_list|(
name|major
operator|+
literal|'0'
argument_list|)
block|,
literal|'.'
block|,
name|char
argument_list|(
name|minor
operator|+
literal|'0'
argument_list|)
block|,
literal|'\0'
block|}
decl_stmt|;
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
return|;
block|}
return|return
name|QString
operator|::
name|number
argument_list|(
name|major
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|minor
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_OSX
argument_list|)
name|int
name|minor
init|=
name|int
argument_list|(
name|MacintoshVersion
argument_list|)
operator|-
literal|2
decl_stmt|;
comment|// we're not running on Mac OS 9
name|Q_ASSERT
argument_list|(
name|minor
operator|<
literal|100
argument_list|)
expr_stmt|;
name|char
name|buf
index|[]
init|=
literal|"10.0\0"
decl_stmt|;
if|if
condition|(
name|Q_LIKELY
argument_list|(
name|minor
operator|<
literal|10
argument_list|)
condition|)
block|{
name|buf
index|[
literal|3
index|]
operator|+=
name|minor
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|3
index|]
operator|+=
name|minor
operator|/
literal|10
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
literal|'0'
operator|+
name|minor
operator|%
literal|10
expr_stmt|;
block|}
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|buf
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
specifier|const
name|char
modifier|*
name|version
init|=
name|winVer_helper
argument_list|()
decl_stmt|;
if|if
condition|(
name|version
condition|)
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|version
argument_list|)
operator|.
name|toLower
argument_list|()
return|;
comment|// fall through
comment|// Android and Blackberry should not fall through to the Unix code
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
comment|// TBD
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
name|deviceinfo_details_t
modifier|*
name|deviceInfo
decl_stmt|;
if|if
condition|(
name|deviceinfo_get_details
argument_list|(
operator|&
name|deviceInfo
argument_list|)
operator|==
name|BPS_SUCCESS
condition|)
block|{
name|QString
name|bbVersion
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|deviceinfo_details_get_device_os_version
argument_list|(
name|deviceInfo
argument_list|)
argument_list|)
decl_stmt|;
name|deviceinfo_free_details
argument_list|(
operator|&
name|deviceInfo
argument_list|)
expr_stmt|;
return|return
name|bbVersion
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|QUnixOSVersion
name|unixOsVersion
init|=
name|detectUnixVersion
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|unixOsVersion
operator|.
name|versionIdentifier
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|unixOsVersion
operator|.
name|versionIdentifier
return|;
endif|#
directive|endif
comment|// fallback
return|return
name|unknownText
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.4      Returns a prettier form of osVersion(), containing other information like     the operating system type, codenames and other information. The result of     this function is suitable for displaying to the user, but not for long-term     storage, as the string may change with updates to Qt.      \sa osType(), osVersion() */
end_comment
begin_function
DECL|function|prettyOsName
name|QString
name|QSysInfo
operator|::
name|prettyOsName
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
return|return
name|QLatin1String
argument_list|(
literal|"iOS "
argument_list|)
operator|+
name|osVersion
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_OSX
argument_list|)
comment|// get the known codenames
specifier|const
name|char
modifier|*
name|basename
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|int
argument_list|(
name|MacintoshVersion
argument_list|)
condition|)
block|{
case|case
name|MV_CHEETAH
case|:
case|case
name|MV_PUMA
case|:
case|case
name|MV_JAGUAR
case|:
case|case
name|MV_PANTHER
case|:
case|case
name|MV_TIGER
case|:
comment|// This version of Qt does not run on those versions of OS X
comment|// so this case label will never be reached
name|Q_UNREACHABLE
argument_list|()
expr_stmt|;
break|break;
case|case
name|MV_LEOPARD
case|:
name|basename
operator|=
literal|"Mac OS X Leopard ("
expr_stmt|;
break|break;
case|case
name|MV_SNOWLEOPARD
case|:
name|basename
operator|=
literal|"Mac OS X Snow Leopard ("
expr_stmt|;
break|break;
case|case
name|MV_LION
case|:
name|basename
operator|=
literal|"Mac OS X Lion ("
expr_stmt|;
break|break;
case|case
name|MV_MOUNTAINLION
case|:
name|basename
operator|=
literal|"OS X Mountain Lion ("
expr_stmt|;
break|break;
case|case
name|MV_MAVERICKS
case|:
name|basename
operator|=
literal|"OS X Mavericks ("
expr_stmt|;
break|break;
case|case
name|MV_YOSEMITE
case|:
name|basename
operator|=
literal|"OS X Yosemite ("
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|basename
condition|)
return|return
name|QLatin1String
argument_list|(
name|basename
argument_list|)
operator|+
name|osVersion
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
return|;
comment|// a future version of OS X
return|return
name|QLatin1String
argument_list|(
literal|"OS X "
argument_list|)
operator|+
name|osVersion
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WINPHONE
argument_list|)
return|return
name|QLatin1String
argument_list|(
literal|"Windows Phone "
argument_list|)
operator|+
name|QLatin1String
argument_list|(
name|winVer_helper
argument_list|()
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
return|return
name|QLatin1String
argument_list|(
literal|"Windows "
argument_list|)
operator|+
name|QLatin1String
argument_list|(
name|winVer_helper
argument_list|()
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
return|return
name|QLatin1String
argument_list|(
literal|"Android "
argument_list|)
operator|+
name|osVersion
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
return|return
name|QLatin1String
argument_list|(
literal|"BlackBerry "
argument_list|)
operator|+
name|osVersion
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|QUnixOSVersion
name|unixOsVersion
init|=
name|detectUnixVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|unixOsVersion
operator|.
name|versionText
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|unixOsVersion
operator|.
name|sysName
return|;
else|else
return|return
name|unixOsVersion
operator|.
name|sysName
operator|+
name|QLatin1String
argument_list|(
literal|" ("
argument_list|)
operator|+
name|unixOsVersion
operator|.
name|versionText
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
return|;
else|#
directive|else
return|return
name|unknownText
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \since 5.4      Returns the release version of the operating system. On Windows, it returns     the version of the kernel, which does not match the version number of the     OS (e.g., Windows 8 has NT kernel version 6.2). On Unix systems, including     Android, BlackBerry and OS X, it returns the same as the \c{uname -r}     command would return.      If the version could not be determined, this function may return an empty     string.      \sa osVersion(), prettyOsName() */
end_comment
begin_function
DECL|function|osKernelVersion
name|QString
name|QSysInfo
operator|::
name|osKernelVersion
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_OS_WINRT
comment|// TBD
return|return
name|QString
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
specifier|const
name|OSVERSIONINFO
name|osver
init|=
name|winOsVersion
argument_list|()
decl_stmt|;
return|return
name|QString
operator|::
name|number
argument_list|(
name|int
argument_list|(
name|osver
operator|.
name|dwMajorVersion
argument_list|)
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|int
argument_list|(
name|osver
operator|.
name|dwMinorVersion
argument_list|)
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|int
argument_list|(
name|osver
operator|.
name|dwBuildNumber
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|detectUnixVersion
argument_list|()
operator|.
name|sysRelease
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \macro void Q_ASSERT(bool test)     \relates<QtGlobal>      Prints a warning message containing the source code file name and     line number if \a test is \c false.      Q_ASSERT() is useful for testing pre- and post-conditions     during development. It does nothing if \c QT_NO_DEBUG was defined     during compilation.      Example:      \snippet code/src_corelib_global_qglobal.cpp 17      If \c b is zero, the Q_ASSERT statement will output the following     message using the qFatal() function:      \snippet code/src_corelib_global_qglobal.cpp 18      \sa Q_ASSERT_X(), qFatal(), {Debugging Techniques} */
end_comment
begin_comment
comment|/*!     \macro void Q_ASSERT_X(bool test, const char *where, const char *what)     \relates<QtGlobal>      Prints the message \a what together with the location \a where,     the source file name and line number if \a test is \c false.      Q_ASSERT_X is useful for testing pre- and post-conditions during     development. It does nothing if \c QT_NO_DEBUG was defined during     compilation.      Example:      \snippet code/src_corelib_global_qglobal.cpp 19      If \c b is zero, the Q_ASSERT_X statement will output the following     message using the qFatal() function:      \snippet code/src_corelib_global_qglobal.cpp 20      \sa Q_ASSERT(), qFatal(), {Debugging Techniques} */
end_comment
begin_comment
comment|/*!     \macro void Q_ASSUME(bool expr)     \relates<QtGlobal>     \since 5.0      Causes the compiler to assume that \a expr is \c true. This macro is useful     for improving code generation, by providing the compiler with hints about     conditions that it would not otherwise know about. However, there is no     guarantee that the compiler will actually use those hints.      This macro could be considered a "lighter" version of \l{Q_ASSERT()}. While     Q_ASSERT will abort the program's execution if the condition is \c false,     Q_ASSUME will tell the compiler not to generate code for those conditions.     Therefore, it is important that the assumptions always hold, otherwise     undefined behaviour may occur.      If \a expr is a constantly \c false condition, Q_ASSUME will tell the compiler     that the current code execution cannot be reached. That is, Q_ASSUME(false)     is equivalent to Q_UNREACHABLE().      In debug builds the condition is enforced by an assert to facilitate debugging.      \note Q_LIKELY() tells the compiler that the expression is likely, but not     the only possibility. Q_ASSUME tells the compiler that it is the only     possibility.      \sa Q_ASSERT(), Q_UNREACHABLE(), Q_LIKELY() */
end_comment
begin_comment
comment|/*!     \macro void Q_UNREACHABLE()     \relates<QtGlobal>     \since 5.0      Tells the compiler that the current point cannot be reached by any     execution, so it may optimize any code paths leading here as dead code, as     well as code continuing from here.      This macro is useful to mark impossible conditions. For example, given the     following enum:      \snippet code/src_corelib_global_qglobal.cpp qunreachable-enum      One can write a switch table like so:      \snippet code/src_corelib_global_qglobal.cpp qunreachable-switch      The advantage of inserting Q_UNREACHABLE() at that point is that the     compiler is told not to generate code for a shape variable containing that     value. If the macro is missing, the compiler will still generate the     necessary comparisons for that value. If the case label were removed, some     compilers could produce a warning that some enum values were not checked.      By using this macro in impossible conditions, code coverage may be improved     as dead code paths may be eliminated.      In debug builds the condition is enforced by an assert to facilitate debugging.      \sa Q_ASSERT(), Q_ASSUME(), qFatal() */
end_comment
begin_comment
comment|/*!     \macro void Q_CHECK_PTR(void *pointer)     \relates<QtGlobal>      If \a pointer is 0, prints a warning message containing the source     code's file name and line number, saying that the program ran out     of memory.      Q_CHECK_PTR does nothing if \c QT_NO_DEBUG was defined during     compilation.      Example:      \snippet code/src_corelib_global_qglobal.cpp 21      \sa qWarning(), {Debugging Techniques} */
end_comment
begin_comment
comment|/*!     \fn T *q_check_ptr(T *pointer)     \relates<QtGlobal>      Uses Q_CHECK_PTR on \a pointer, then returns \a pointer.      This can be used as an inline version of Q_CHECK_PTR. */
end_comment
begin_comment
comment|/*!     \macro const char* Q_FUNC_INFO()     \relates<QtGlobal>      Expands to a string that describe the function the macro resides in. How this string looks     more specifically is compiler dependent. With GNU GCC it is typically the function signature,     while with other compilers it might be the line and column number.      Q_FUNC_INFO can be conveniently used with qDebug(). For example, this function:      \snippet code/src_corelib_global_qglobal.cpp 22      when instantiated with the integer type, will with the GCC compiler produce:      \tt{const TInputType& myMin(const TInputType&, const TInputType&) [with TInputType = int] was called with value1: 3 value2: 4}      If this macro is used outside a function, the behavior is undefined.  */
end_comment
begin_comment
comment|/*   The Q_CHECK_PTR macro calls this function if an allocation check   fails. */
end_comment
begin_function
DECL|function|qt_check_pointer
name|void
name|qt_check_pointer
parameter_list|(
specifier|const
name|char
modifier|*
name|n
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|qFatal
argument_list|(
literal|"In file %s, line %d: Out of memory"
argument_list|,
name|n
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*    \internal    Allows you to throw an exception without including<new>    Called internally from Q_CHECK_PTR on certain OS combinations */
end_comment
begin_function
DECL|function|qBadAlloc
name|void
name|qBadAlloc
parameter_list|()
block|{
name|QT_THROW
argument_list|(
name|std
operator|::
name|bad_alloc
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_EXCEPTIONS
end_ifndef
begin_comment
comment|/*    \internal    Allows you to call std::terminate() without including<exception>.    Called internally from QT_TERMINATE_ON_EXCEPTION */
end_comment
begin_function
name|Q_NORETURN
name|void
name|qTerminate
parameter_list|()
name|Q_DECL_NOTHROW
block|{
name|std
operator|::
name|terminate
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*   The Q_ASSERT macro calls this function when the test fails. */
end_comment
begin_function
name|void
name|qt_assert
parameter_list|(
specifier|const
name|char
modifier|*
name|assertion
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
name|Q_DECL_NOTHROW
block|{
name|qFatal
argument_list|(
literal|"ASSERT: \"%s\" in file %s, line %d"
argument_list|,
name|assertion
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   The Q_ASSERT_X macro calls this function when the test fails. */
end_comment
begin_function
name|void
name|qt_assert_x
parameter_list|(
specifier|const
name|char
modifier|*
name|where
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
name|Q_DECL_NOTHROW
block|{
name|qFatal
argument_list|(
literal|"ASSERT failure in %s: \"%s\", file %s, line %d"
argument_list|,
name|where
argument_list|,
name|what
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     Dijkstra's bisection algorithm to find the square root of an integer.     Deliberately not exported as part of the Qt API, but used in both     qsimplerichtext.cpp and qgfxraster_qws.cpp */
end_comment
begin_function
DECL|function|qt_int_sqrt
name|Q_CORE_EXPORT
name|unsigned
name|int
name|qt_int_sqrt
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
comment|// n must be in the range 0...UINT_MAX/2-1
if|if
condition|(
name|n
operator|>=
operator|(
name|UINT_MAX
operator|>>
literal|2
operator|)
condition|)
block|{
name|unsigned
name|int
name|r
init|=
literal|2
operator|*
name|qt_int_sqrt
argument_list|(
name|n
operator|/
literal|4
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|r2
init|=
name|r
operator|+
literal|1
decl_stmt|;
return|return
operator|(
name|n
operator|>=
name|r2
operator|*
name|r2
operator|)
condition|?
name|r2
else|:
name|r
return|;
block|}
name|uint
name|h
decl_stmt|,
name|p
init|=
literal|0
decl_stmt|,
name|q
init|=
literal|1
decl_stmt|,
name|r
init|=
name|n
decl_stmt|;
while|while
condition|(
name|q
operator|<=
name|n
condition|)
name|q
operator|<<=
literal|2
expr_stmt|;
while|while
condition|(
name|q
operator|!=
literal|1
condition|)
block|{
name|q
operator|>>=
literal|2
expr_stmt|;
name|h
operator|=
name|p
operator|+
name|q
expr_stmt|;
name|p
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|h
condition|)
block|{
name|p
operator|+=
name|q
expr_stmt|;
name|r
operator|-=
name|h
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|qMemCopy
name|void
modifier|*
name|qMemCopy
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
return|return
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qMemSet
name|void
modifier|*
name|qMemSet
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
name|int
name|c
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
return|return
name|memset
argument_list|(
name|dest
argument_list|,
name|c
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_INTEGRITY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
operator|&&
name|_POSIX_VERSION
operator|>=
literal|200112L
end_if
begin_namespace
namespace|namespace
block|{
comment|// There are two incompatible versions of strerror_r:
comment|// a) the XSI/POSIX.1 version, which returns an int,
comment|//    indicating success or not
comment|// b) the GNU version, which returns a char*, which may or may not
comment|//    be the beginning of the buffer we used
comment|// The GNU libc manpage for strerror_r says you should use the XSI
comment|// version in portable code. However, it's impossible to do that if
comment|// _GNU_SOURCE is defined so we use C++ overloading to decide what to do
comment|// depending on the return type
DECL|function|fromstrerror_helper
specifier|static
specifier|inline
name|Q_DECL_UNUSED
name|QString
name|fromstrerror_helper
parameter_list|(
name|int
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|buf
parameter_list|)
block|{
return|return
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|buf
argument_list|)
return|;
block|}
DECL|function|fromstrerror_helper
specifier|static
specifier|inline
name|Q_DECL_UNUSED
name|QString
name|fromstrerror_helper
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|QByteArray
modifier|&
parameter_list|)
block|{
return|return
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|str
argument_list|)
return|;
block|}
block|}
end_namespace
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qt_error_string
name|QString
name|qt_error_string
parameter_list|(
name|int
name|errorCode
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
literal|0
decl_stmt|;
name|QString
name|ret
decl_stmt|;
if|if
condition|(
name|errorCode
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|errorCode
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
else|#
directive|else
name|errorCode
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|errorCode
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|EACCES
case|:
name|s
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QIODevice"
argument_list|,
literal|"Permission denied"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EMFILE
case|:
name|s
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QIODevice"
argument_list|,
literal|"Too many open files"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOENT
case|:
name|s
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QIODevice"
argument_list|,
literal|"No such file or directory"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOSPC
case|:
name|s
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QIODevice"
argument_list|,
literal|"No space left on device"
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
comment|// Retrieve the system error message for the last-error code.
ifndef|#
directive|ifndef
name|Q_OS_WINRT
name|wchar_t
modifier|*
name|string
init|=
literal|0
decl_stmt|;
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_ALLOCATE_BUFFER
operator||
name|FORMAT_MESSAGE_FROM_SYSTEM
argument_list|,
name|NULL
argument_list|,
name|errorCode
argument_list|,
name|MAKELANGID
argument_list|(
name|LANG_NEUTRAL
argument_list|,
name|SUBLANG_DEFAULT
argument_list|)
argument_list|,
operator|(
name|LPWSTR
operator|)
operator|&
name|string
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|LocalFree
argument_list|(
operator|(
name|HLOCAL
operator|)
name|string
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// !Q_OS_WINRT
name|__declspec
argument_list|(
argument|thread
argument_list|)
specifier|static
name|wchar_t
name|errorString
index|[
literal|4096
index|]
decl_stmt|;
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_FROM_SYSTEM
operator||
name|FORMAT_MESSAGE_IGNORE_INSERTS
argument_list|,
name|NULL
argument_list|,
name|errorCode
argument_list|,
name|MAKELANGID
argument_list|(
name|LANG_NEUTRAL
argument_list|,
name|SUBLANG_DEFAULT
argument_list|)
argument_list|,
name|errorString
argument_list|,
name|ARRAYSIZE
argument_list|(
name|errorString
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|errorString
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Q_OS_WINRT
if|if
condition|(
name|ret
operator|.
name|isEmpty
argument_list|()
operator|&&
name|errorCode
operator|==
name|ERROR_MOD_NOT_FOUND
condition|)
name|ret
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"The specified module could not be found."
argument_list|)
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
operator|&&
name|_POSIX_VERSION
operator|>=
literal|200112L
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_INTEGRITY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
name|QByteArray
name|buf
argument_list|(
literal|1024
argument_list|,
literal|'\0'
argument_list|)
decl_stmt|;
name|ret
operator|=
name|fromstrerror_helper
argument_list|(
name|strerror_r
argument_list|(
name|errorCode
argument_list|,
name|buf
operator|.
name|data
argument_list|()
argument_list|,
name|buf
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|strerror
argument_list|(
name|errorCode
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
if|if
condition|(
name|s
condition|)
comment|// ######## this breaks moc build currently
comment|//         ret = QCoreApplication::translate("QIODevice", s);
name|ret
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
operator|.
name|trimmed
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// getenv is declared as deprecated in VS2005. This function
end_comment
begin_comment
comment|// makes use of the new secure getenv function.
end_comment
begin_comment
comment|/*!     \relates<QtGlobal>      Returns the value of the environment variable with name \a     varName. To get the variable string, use QByteArray::constData().      \note qgetenv() was introduced because getenv() from the standard     C library was deprecated in VC2005 (and later versions). qgetenv()     uses the new replacement function in VC, and calls the standard C     library's implementation on all other platforms.      \sa qputenv(), qEnvironmentVariableIsSet(), qEnvironmentVariableIsEmpty() */
end_comment
begin_function
DECL|function|qgetenv
name|QByteArray
name|qgetenv
parameter_list|(
specifier|const
name|char
modifier|*
name|varName
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
name|size_t
name|requiredSize
init|=
literal|0
decl_stmt|;
name|QByteArray
name|buffer
decl_stmt|;
name|getenv_s
argument_list|(
operator|&
name|requiredSize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|varName
argument_list|)
expr_stmt|;
if|if
condition|(
name|requiredSize
operator|==
literal|0
condition|)
return|return
name|buffer
return|;
name|buffer
operator|.
name|resize
argument_list|(
name|int
argument_list|(
name|requiredSize
argument_list|)
argument_list|)
expr_stmt|;
name|getenv_s
argument_list|(
operator|&
name|requiredSize
argument_list|,
name|buffer
operator|.
name|data
argument_list|()
argument_list|,
name|requiredSize
argument_list|,
name|varName
argument_list|)
expr_stmt|;
comment|// requiredSize includes the terminating null, which we don't want.
name|Q_ASSERT
argument_list|(
name|buffer
operator|.
name|endsWith
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
else|#
directive|else
return|return
name|QByteArray
argument_list|(
operator|::
name|getenv
argument_list|(
name|varName
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \relates<QtGlobal>     \since 5.1      Returns whether the environment variable \a varName is empty.      Equivalent to     \code     qgetenv(varName).isEmpty()     \endcode     except that it's potentially much faster, and can't throw exceptions.      \sa qgetenv(), qEnvironmentVariableIsSet() */
end_comment
begin_function
name|bool
name|qEnvironmentVariableIsEmpty
parameter_list|(
specifier|const
name|char
modifier|*
name|varName
parameter_list|)
name|Q_DECL_NOEXCEPT
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
comment|// we provide a buffer that can only hold the empty string, so
comment|// when the env.var isn't empty, we'll get an ERANGE error (buffer
comment|// too small):
name|size_t
name|dummy
decl_stmt|;
name|char
name|buffer
init|=
literal|'\0'
decl_stmt|;
return|return
name|getenv_s
argument_list|(
operator|&
name|dummy
argument_list|,
operator|&
name|buffer
argument_list|,
literal|1
argument_list|,
name|varName
argument_list|)
operator|!=
name|ERANGE
return|;
else|#
directive|else
specifier|const
name|char
modifier|*
specifier|const
name|value
init|=
operator|::
name|getenv
argument_list|(
name|varName
argument_list|)
decl_stmt|;
return|return
operator|!
name|value
operator|||
operator|!
operator|*
name|value
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \relates<QtGlobal>     \since 5.1      Returns whether the environment variable \a varName is set.      Equivalent to     \code     !qgetenv(varName).isNull()     \endcode     except that it's potentially much faster, and can't throw exceptions.      \sa qgetenv(), qEnvironmentVariableIsEmpty() */
end_comment
begin_function
name|bool
name|qEnvironmentVariableIsSet
parameter_list|(
specifier|const
name|char
modifier|*
name|varName
parameter_list|)
name|Q_DECL_NOEXCEPT
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
name|size_t
name|requiredSize
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|getenv_s
argument_list|(
operator|&
name|requiredSize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|varName
argument_list|)
expr_stmt|;
return|return
name|requiredSize
operator|!=
literal|0
return|;
else|#
directive|else
return|return
operator|::
name|getenv
argument_list|(
name|varName
argument_list|)
operator|!=
literal|0
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \relates<QtGlobal>      This function sets the \a value of the environment variable named     \a varName. It will create the variable if it does not exist. It     returns 0 if the variable could not be set.      Calling qputenv with an empty value removes the environment variable on     Windows, and makes it set (but empty) on Unix. Prefer using qunsetenv()     for fully portable behavior.      \note qputenv() was introduced because putenv() from the standard     C library was deprecated in VC2005 (and later versions). qputenv()     uses the replacement function in VC, and calls the standard C     library's implementation on all other platforms.      \sa qgetenv() */
end_comment
begin_function
DECL|function|qputenv
name|bool
name|qputenv
parameter_list|(
specifier|const
name|char
modifier|*
name|varName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|value
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
return|return
name|_putenv_s
argument_list|(
name|varName
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|)
operator|==
literal|0
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
operator|&&
operator|(
name|_POSIX_VERSION
operator|-
literal|0
operator|)
operator|>=
literal|200112L
comment|// POSIX.1-2001 has setenv
return|return
name|setenv
argument_list|(
name|varName
argument_list|,
name|value
operator|.
name|constData
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|==
literal|0
return|;
else|#
directive|else
name|QByteArray
name|buffer
argument_list|(
name|varName
argument_list|)
decl_stmt|;
name|buffer
operator|+=
literal|'='
expr_stmt|;
name|buffer
operator|+=
name|value
expr_stmt|;
name|char
modifier|*
name|envVar
init|=
name|qstrdup
argument_list|(
name|buffer
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|result
init|=
name|putenv
argument_list|(
name|envVar
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
comment|// error. we have to delete the string.
operator|delete
index|[]
name|envVar
expr_stmt|;
return|return
name|result
operator|==
literal|0
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \relates<QtGlobal>      This function deletes the variable \a varName from the environment.      Returns \c true on success.      \since 5.1      \sa qputenv(), qgetenv() */
end_comment
begin_function
DECL|function|qunsetenv
name|bool
name|qunsetenv
parameter_list|(
specifier|const
name|char
modifier|*
name|varName
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
return|return
name|_putenv_s
argument_list|(
name|varName
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
return|;
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
operator|&&
operator|(
name|_POSIX_VERSION
operator|-
literal|0
operator|)
operator|>=
literal|200112L
operator|)
operator|||
name|defined
argument_list|(
name|Q_OS_BSD4
argument_list|)
comment|// POSIX.1-2001 and BSD have unsetenv
return|return
name|unsetenv
argument_list|(
name|varName
argument_list|)
operator|==
literal|0
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
comment|// On mingw, putenv("var=") removes "var" from the environment
name|QByteArray
name|buffer
argument_list|(
name|varName
argument_list|)
decl_stmt|;
name|buffer
operator|+=
literal|'='
expr_stmt|;
return|return
name|putenv
argument_list|(
name|buffer
operator|.
name|constData
argument_list|()
argument_list|)
operator|==
literal|0
return|;
else|#
directive|else
comment|// Fallback to putenv("var=") which will insert an empty var into the
comment|// environment and leak it
name|QByteArray
name|buffer
argument_list|(
name|varName
argument_list|)
decl_stmt|;
name|buffer
operator|+=
literal|'='
expr_stmt|;
name|char
modifier|*
name|envVar
init|=
name|qstrdup
argument_list|(
name|buffer
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|putenv
argument_list|(
name|envVar
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
operator|&&
operator|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
operator|-
literal|0
operator|>
literal|0
operator|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_INTEGRITY
argument_list|)
operator|&&
name|defined
argument_list|(
name|__GHS_VERSION_NUMBER
argument_list|)
operator|&&
operator|(
name|__GHS_VERSION_NUMBER
operator|<
literal|500
operator|)
end_if
begin_comment
comment|// older versions of INTEGRITY used a long instead of a uint for the seed.
end_comment
begin_typedef
DECL|typedef|SeedStorageType
typedef|typedef
name|long
name|SeedStorageType
typedef|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_typedef
DECL|typedef|SeedStorageType
typedef|typedef
name|uint
name|SeedStorageType
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|SeedStorage
typedef|typedef
name|QThreadStorage
argument_list|<
name|SeedStorageType
modifier|*
argument_list|>
name|SeedStorage
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|SeedStorage
argument_list|,
argument|randTLS
argument_list|)
end_macro
begin_comment
comment|// Thread Local Storage for seed value
end_comment
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_ANDROID_NO_SDK
argument_list|)
end_elif
begin_typedef
typedef|typedef
name|QThreadStorage
argument_list|<
name|QJNIObjectPrivate
argument_list|>
name|AndroidRandomStorage
typedef|;
end_typedef
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|AndroidRandomStorage
argument_list|,
argument|randomTLS
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \relates<QtGlobal>     \since 4.2      Thread-safe version of the standard C++ \c srand() function.      Sets the argument \a seed to be used to generate a new random number sequence of     pseudo random integers to be returned by qrand().      The sequence of random numbers generated is deterministic per thread. For example,     if two threads call qsrand(1) and subsequently calls qrand(), the threads will get     the same random number sequence.      \sa qrand() */
end_comment
begin_function
DECL|function|qsrand
name|void
name|qsrand
parameter_list|(
name|uint
name|seed
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
operator|&&
operator|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
operator|-
literal|0
operator|>
literal|0
operator|)
name|SeedStorage
modifier|*
name|seedStorage
init|=
name|randTLS
argument_list|()
decl_stmt|;
if|if
condition|(
name|seedStorage
condition|)
block|{
name|SeedStorageType
modifier|*
name|pseed
init|=
name|seedStorage
operator|->
name|localData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pseed
condition|)
name|seedStorage
operator|->
name|setLocalData
argument_list|(
name|pseed
operator|=
operator|new
name|SeedStorageType
argument_list|)
expr_stmt|;
operator|*
name|pseed
operator|=
name|seed
expr_stmt|;
block|}
else|else
block|{
comment|//global static seed storage should always exist,
comment|//except after being deleted by QGlobalStaticDeleter.
comment|//But since it still can be called from destructor of another
comment|//global static object, fallback to srand(seed)
name|srand
argument_list|(
name|seed
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_ANDROID_NO_SDK
argument_list|)
if|if
condition|(
name|randomTLS
operator|->
name|hasLocalData
argument_list|()
condition|)
block|{
name|randomTLS
operator|->
name|localData
argument_list|()
operator|.
name|callMethod
argument_list|<
name|void
argument_list|>
argument_list|(
literal|"setSeed"
argument_list|,
literal|"(J)V"
argument_list|,
name|jlong
argument_list|(
name|seed
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|QJNIObjectPrivate
name|random
argument_list|(
literal|"java/util/Random"
argument_list|,
literal|"(J)V"
argument_list|,
name|jlong
argument_list|(
name|seed
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|random
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|srand
argument_list|(
name|seed
argument_list|)
expr_stmt|;
return|return;
block|}
name|randomTLS
operator|->
name|setLocalData
argument_list|(
name|random
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// On Windows srand() and rand() already use Thread-Local-Storage
comment|// to store the seed between calls
comment|// this is also valid for QT_NO_THREAD
name|srand
argument_list|(
name|seed
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \relates<QtGlobal>     \since 4.2      Thread-safe version of the standard C++ \c rand() function.      Returns a value between 0 and \c RAND_MAX (defined in \c<cstdlib> and     \c<stdlib.h>), the next number in the current sequence of pseudo-random     integers.      Use \c qsrand() to initialize the pseudo-random number generator with     a seed value.      \sa qsrand() */
end_comment
begin_function
DECL|function|qrand
name|int
name|qrand
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
argument_list|)
operator|&&
operator|(
name|_POSIX_THREAD_SAFE_FUNCTIONS
operator|-
literal|0
operator|>
literal|0
operator|)
name|SeedStorage
modifier|*
name|seedStorage
init|=
name|randTLS
argument_list|()
decl_stmt|;
if|if
condition|(
name|seedStorage
condition|)
block|{
name|SeedStorageType
modifier|*
name|pseed
init|=
name|seedStorage
operator|->
name|localData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pseed
condition|)
block|{
name|seedStorage
operator|->
name|setLocalData
argument_list|(
name|pseed
operator|=
operator|new
name|SeedStorageType
argument_list|)
expr_stmt|;
operator|*
name|pseed
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|rand_r
argument_list|(
name|pseed
argument_list|)
return|;
block|}
else|else
block|{
comment|//global static seed storage should always exist,
comment|//except after being deleted by QGlobalStaticDeleter.
comment|//But since it still can be called from destructor of another
comment|//global static object, fallback to rand()
return|return
name|rand
argument_list|()
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_ANDROID_NO_SDK
argument_list|)
name|AndroidRandomStorage
modifier|*
name|randomStorage
init|=
name|randomTLS
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|randomStorage
condition|)
return|return
name|rand
argument_list|()
return|;
if|if
condition|(
name|randomStorage
operator|->
name|hasLocalData
argument_list|()
condition|)
block|{
return|return
name|randomStorage
operator|->
name|localData
argument_list|()
operator|.
name|callMethod
argument_list|<
name|jint
argument_list|>
argument_list|(
literal|"nextInt"
argument_list|,
literal|"(I)I"
argument_list|,
name|RAND_MAX
argument_list|)
return|;
block|}
name|QJNIObjectPrivate
name|random
argument_list|(
literal|"java/util/Random"
argument_list|,
literal|"(J)V"
argument_list|,
name|jlong
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|random
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|rand
argument_list|()
return|;
name|randomStorage
operator|->
name|setLocalData
argument_list|(
name|random
argument_list|)
expr_stmt|;
return|return
name|random
operator|.
name|callMethod
argument_list|<
name|jint
argument_list|>
argument_list|(
literal|"nextInt"
argument_list|,
literal|"(I)I"
argument_list|,
name|RAND_MAX
argument_list|)
return|;
else|#
directive|else
comment|// On Windows srand() and rand() already use Thread-Local-Storage
comment|// to store the seed between calls
comment|// this is also valid for QT_NO_THREAD
return|return
name|rand
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \macro forever     \relates<QtGlobal>      This macro is provided for convenience for writing infinite     loops.      Example:      \snippet code/src_corelib_global_qglobal.cpp 31      It is equivalent to \c{for (;;)}.      If you're worried about namespace pollution, you can disable this     macro by adding the following line to your \c .pro file:      \snippet code/src_corelib_global_qglobal.cpp 32      \sa Q_FOREVER */
end_comment
begin_comment
comment|/*!     \macro Q_FOREVER     \relates<QtGlobal>      Same as \l{forever}.      This macro is available even when \c no_keywords is specified     using the \c .pro file's \c CONFIG variable.      \sa foreach() */
end_comment
begin_comment
comment|/*!     \macro foreach(variable, container)     \relates<QtGlobal>      This macro is used to implement Qt's \c foreach loop. The \a     variable parameter is a variable name or variable definition; the     \a container parameter is a Qt container whose value type     corresponds to the type of the variable. See \l{The foreach     Keyword} for details.      If you're worried about namespace pollution, you can disable this     macro by adding the following line to your \c .pro file:      \snippet code/src_corelib_global_qglobal.cpp 33      \sa Q_FOREACH() */
end_comment
begin_comment
comment|/*!     \macro Q_FOREACH(variable, container)     \relates<QtGlobal>      Same as foreach(\a variable, \a container).      This macro is available even when \c no_keywords is specified     using the \c .pro file's \c CONFIG variable.      \sa foreach() */
end_comment
begin_comment
comment|/*!     \macro QT_TR_NOOP(sourceText)     \relates<QtGlobal>      Marks the string literal \a sourceText for dynamic translation in     the current context (class), i.e the stored \a sourceText will not     be altered.      The macro expands to \a sourceText.      Example:      \snippet code/src_corelib_global_qglobal.cpp 34      The macro QT_TR_NOOP_UTF8() is identical except that it tells lupdate     that the source string is encoded in UTF-8. Corresponding variants     exist in the QT_TRANSLATE_NOOP() family of macros, too.      \sa QT_TRANSLATE_NOOP(), {Internationalization with Qt} */
end_comment
begin_comment
comment|/*!     \macro QT_TRANSLATE_NOOP(context, sourceText)     \relates<QtGlobal>      Marks the string literal \a sourceText for dynamic translation in     the given \a context; i.e, the stored \a sourceText will not be     altered. The \a context is typically a class and also needs to     be specified as string literal.      The macro expands to \a sourceText.      Example:      \snippet code/src_corelib_global_qglobal.cpp 35      \sa QT_TR_NOOP(), QT_TRANSLATE_NOOP3(), {Internationalization with Qt} */
end_comment
begin_comment
comment|/*!     \macro QT_TRANSLATE_NOOP3(context, sourceText, comment)     \relates<QtGlobal>     \since 4.4      Marks the string literal \a sourceText for dynamic translation in the     given \a context and with \a comment, i.e the stored \a sourceText will     not be altered. The \a context is typically a class and also needs to     be specified as string literal. The string literal \a comment     will be available for translators using e.g. Qt Linguist.      The macro expands to anonymous struct of the two string     literals passed as \a sourceText and \a comment.      Example:      \snippet code/src_corelib_global_qglobal.cpp 36      \sa QT_TR_NOOP(), QT_TRANSLATE_NOOP(), {Internationalization with Qt} */
end_comment
begin_comment
comment|/*!     \fn QString qtTrId(const char *id, int n = -1)     \relates<QtGlobal>     \reentrant     \since 4.6      \brief The qtTrId function finds and returns a translated string.      Returns a translated string identified by \a id.     If no matching string is found, the id itself is returned. This     should not happen under normal conditions.      If \a n>= 0, all occurrences of \c %n in the resulting string     are replaced with a decimal representation of \a n. In addition,     depending on \a n's value, the translation text may vary.      Meta data and comments can be passed as documented for QObject::tr().     In addition, it is possible to supply a source string template like that:      \tt{//%<C string>}      or      \tt{\\begincomment%<C string> \\endcomment}      Example:      \snippet code/src_corelib_global_qglobal.cpp qttrid      Creating QM files suitable for use with this function requires passing     the \c -idbased option to the \c lrelease tool.      \warning This method is reentrant only if all translators are     installed \e before calling this method. Installing or removing     translators while performing translations is not supported. Doing     so will probably result in crashes or other undesirable behavior.      \sa QObject::tr(), QCoreApplication::translate(), {Internationalization with Qt} */
end_comment
begin_comment
comment|/*!     \macro QT_TRID_NOOP(id)     \relates<QtGlobal>     \since 4.6      \brief The QT_TRID_NOOP macro marks an id for dynamic translation.      The only purpose of this macro is to provide an anchor for attaching     meta data like to qtTrId().      The macro expands to \a id.      Example:      \snippet code/src_corelib_global_qglobal.cpp qttrid_noop      \sa qtTrId(), {Internationalization with Qt} */
end_comment
begin_comment
comment|/*!     \macro Q_LIKELY(expr)     \relates<QtGlobal>     \since 4.8      \brief Hints to the compiler that the enclosed condition, \a expr, is     likely to evaluate to \c true.      Use of this macro can help the compiler to optimize the code.      Example:      \snippet code/src_corelib_global_qglobal.cpp qlikely      \sa Q_UNLIKELY() */
end_comment
begin_comment
comment|/*!     \macro Q_UNLIKELY(expr)     \relates<QtGlobal>     \since 4.8      \brief Hints to the compiler that the enclosed condition, \a expr, is     likely to evaluate to \c false.      Use of this macro can help the compiler to optimize the code.      Example:      \snippet code/src_corelib_global_qglobal.cpp qunlikely      \sa Q_LIKELY() */
end_comment
begin_comment
comment|/*!     \macro QT_POINTER_SIZE     \relates<QtGlobal>      Expands to the size of a pointer in bytes (4 or 8). This is     equivalent to \c sizeof(void *) but can be used in a preprocessor     directive. */
end_comment
begin_comment
comment|/*!     \macro QABS(n)     \relates<QtGlobal>     \obsolete      Use qAbs(\a n) instead.      \sa QMIN(), QMAX() */
end_comment
begin_comment
comment|/*!     \macro QMIN(x, y)     \relates<QtGlobal>     \obsolete      Use qMin(\a x, \a y) instead.      \sa QMAX(), QABS() */
end_comment
begin_comment
comment|/*!     \macro QMAX(x, y)     \relates<QtGlobal>     \obsolete      Use qMax(\a x, \a y) instead.      \sa QMIN(), QABS() */
end_comment
begin_comment
comment|/*!     \macro const char *qPrintable(const QString&str)     \relates<QtGlobal>      Returns \a str as a \c{const char *}. This is equivalent to     \a{str}.toLocal8Bit().constData().      The char pointer will be invalid after the statement in which     qPrintable() is used. This is because the array returned by     QString::toLocal8Bit() will fall out of scope.      \note qDebug(), qWarning(), qCritical(), qFatal() expect %s     arguments to be UTF-8 encoded, while qPrintable() converts to     local 8-bit encoding. Therefore qUtf8Printable() should be used     for logging strings instead of qPrintable().      \sa qUtf8Printable() */
end_comment
begin_comment
comment|/*!     \macro const char *qUtf8Printable(const QString&str)     \relates<QtGlobal>     \since 5.4      Returns \a str as a \c{const char *}. This is equivalent to     \a{str}.toUtf8().constData().      The char pointer will be invalid after the statement in which     qUtf8Printable() is used. This is because the array returned by     QString::toUtf8() will fall out of scope.      Example:      \snippet code/src_corelib_global_qglobal.cpp 37      \sa qPrintable(), qDebug(), qWarning(), qCritical(), qFatal() */
end_comment
begin_comment
comment|/*!     \macro Q_DECLARE_TYPEINFO(Type, Flags)     \relates<QtGlobal>      You can use this macro to specify information about a custom type     \a Type. With accurate type information, Qt's \l{Container Classes}     {generic containers} can choose appropriate storage methods and     algorithms.      \a Flags can be one of the following:      \list     \li \c Q_PRIMITIVE_TYPE specifies that \a Type is a POD (plain old        data) type with no constructor or destructor, or else a type where        every bit pattern is a valid object and memcpy() creates a valid        independent copy of the object.     \li \c Q_MOVABLE_TYPE specifies that \a Type has a constructor        and/or a destructor but can be moved in memory using \c        memcpy().     \li \c Q_COMPLEX_TYPE (the default) specifies that \a Type has        constructors and/or a destructor and that it may not be moved        in memory.     \endlist      Example of a "primitive" type:      \snippet code/src_corelib_global_qglobal.cpp 38      An example of a non-POD "primitive" type is QUuid: Even though     QUuid has constructors (and therefore isn't POD), every bit     pattern still represents a valid object, and memcpy() can be used     to create a valid independent copy of a QUuid object.      Example of a movable type:      \snippet code/src_corelib_global_qglobal.cpp 39 */
end_comment
begin_comment
comment|/*!     \macro Q_UNUSED(name)     \relates<QtGlobal>      Indicates to the compiler that the parameter with the specified     \a name is not used in the body of a function. This can be used to     suppress compiler warnings while allowing functions to be defined     with meaningful parameter names in their signatures. */
end_comment
begin_struct
DECL|struct|QInternal_CallBackTable
struct|struct
name|QInternal_CallBackTable
block|{
DECL|member|callbacks
name|QVector
argument_list|<
name|QList
argument_list|<
name|qInternalCallback
argument_list|>
argument_list|>
name|callbacks
decl_stmt|;
block|}
struct|;
end_struct
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QInternal_CallBackTable
argument_list|,
argument|global_callback_table
argument_list|)
end_macro
begin_function
DECL|function|registerCallback
name|bool
name|QInternal
operator|::
name|registerCallback
parameter_list|(
name|Callback
name|cb
parameter_list|,
name|qInternalCallback
name|callback
parameter_list|)
block|{
if|if
condition|(
name|cb
operator|>=
literal|0
operator|&&
name|cb
operator|<
name|QInternal
operator|::
name|LastCallback
condition|)
block|{
name|QInternal_CallBackTable
modifier|*
name|cbt
init|=
name|global_callback_table
argument_list|()
decl_stmt|;
name|cbt
operator|->
name|callbacks
operator|.
name|resize
argument_list|(
name|cb
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cbt
operator|->
name|callbacks
index|[
name|cb
index|]
operator|.
name|append
argument_list|(
name|callback
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|unregisterCallback
name|bool
name|QInternal
operator|::
name|unregisterCallback
parameter_list|(
name|Callback
name|cb
parameter_list|,
name|qInternalCallback
name|callback
parameter_list|)
block|{
if|if
condition|(
name|cb
operator|>=
literal|0
operator|&&
name|cb
operator|<
name|QInternal
operator|::
name|LastCallback
condition|)
block|{
name|QInternal_CallBackTable
modifier|*
name|cbt
init|=
name|global_callback_table
argument_list|()
decl_stmt|;
return|return
operator|(
name|bool
operator|)
name|cbt
operator|->
name|callbacks
index|[
name|cb
index|]
operator|.
name|removeAll
argument_list|(
name|callback
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|activateCallbacks
name|bool
name|QInternal
operator|::
name|activateCallbacks
parameter_list|(
name|Callback
name|cb
parameter_list|,
name|void
modifier|*
modifier|*
name|parameters
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
name|cb
operator|>=
literal|0
argument_list|,
literal|"QInternal::activateCallback()"
argument_list|,
literal|"Callback id must be a valid id"
argument_list|)
expr_stmt|;
name|QInternal_CallBackTable
modifier|*
name|cbt
init|=
name|global_callback_table
argument_list|()
decl_stmt|;
if|if
condition|(
name|cbt
operator|&&
name|cb
operator|<
name|cbt
operator|->
name|callbacks
operator|.
name|size
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|qInternalCallback
argument_list|>
name|callbacks
init|=
name|cbt
operator|->
name|callbacks
index|[
name|cb
index|]
decl_stmt|;
name|bool
name|ret
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|callbacks
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|ret
operator||=
operator|(
name|callbacks
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|)
operator|(
name|parameters
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \macro Q_BYTE_ORDER     \relates<QtGlobal>      This macro can be used to determine the byte order your system     uses for storing data in memory. i.e., whether your system is     little-endian or big-endian. It is set by Qt to one of the macros     Q_LITTLE_ENDIAN or Q_BIG_ENDIAN. You normally won't need to worry     about endian-ness, but you might, for example if you need to know     which byte of an integer or UTF-16 character is stored in the     lowest address. Endian-ness is important in networking, where     computers with different values for Q_BYTE_ORDER must pass data     back and forth.      Use this macro as in the following examples.      \snippet code/src_corelib_global_qglobal.cpp 40      \sa Q_BIG_ENDIAN, Q_LITTLE_ENDIAN */
end_comment
begin_comment
comment|/*!     \macro Q_LITTLE_ENDIAN     \relates<QtGlobal>      This macro represents a value you can compare to the macro     Q_BYTE_ORDER to determine the endian-ness of your system.  In a     little-endian system, the least significant byte is stored at the     lowest address. The other bytes follow in increasing order of     significance.      \snippet code/src_corelib_global_qglobal.cpp 41      \sa Q_BYTE_ORDER, Q_BIG_ENDIAN */
end_comment
begin_comment
comment|/*!     \macro Q_BIG_ENDIAN     \relates<QtGlobal>      This macro represents a value you can compare to the macro     Q_BYTE_ORDER to determine the endian-ness of your system.  In a     big-endian system, the most significant byte is stored at the     lowest address. The other bytes follow in decreasing order of     significance.      \snippet code/src_corelib_global_qglobal.cpp 42      \sa Q_BYTE_ORDER, Q_LITTLE_ENDIAN */
end_comment
begin_comment
comment|/*!     \macro Q_GLOBAL_STATIC(type, name)     \internal      Declares a global static variable with the given \a type and \a name.      Use this macro to instantiate an object in a thread-safe way, creating     a global pointer that can be used to refer to it.      \warning This macro is subject to a race condition that can cause the object     to be constructed twice. However, if this occurs, the second instance will     be immediately deleted.      See also     \l{http://www.aristeia.com/publications.html}{"C++ and the perils of Double-Checked Locking"}     by Scott Meyers and Andrei Alexandrescu. */
end_comment
begin_comment
comment|/*!     \macro Q_GLOBAL_STATIC_WITH_ARGS(type, name, arguments)     \internal      Declares a global static variable with the specified \a type and \a name.      Use this macro to instantiate an object using the \a arguments specified     in a thread-safe way, creating a global pointer that can be used to refer     to it.      \warning This macro is subject to a race condition that can cause the object     to be constructed twice. However, if this occurs, the second instance will     be immediately deleted.      See also     \l{http://www.aristeia.com/publications.html}{"C++ and the perils of Double-Checked Locking"}     by Scott Meyers and Andrei Alexandrescu. */
end_comment
begin_comment
comment|/*!     \macro QT_NAMESPACE     \internal      If this macro is defined to \c ns all Qt classes are put in a namespace     called \c ns. Also, moc will output code putting metaobjects etc.     into namespace \c ns.      \sa QT_BEGIN_NAMESPACE, QT_END_NAMESPACE,     QT_PREPEND_NAMESPACE, QT_USE_NAMESPACE,     QT_BEGIN_INCLUDE_NAMESPACE, QT_END_INCLUDE_NAMESPACE,     QT_BEGIN_MOC_NAMESPACE, QT_END_MOC_NAMESPACE, */
end_comment
begin_comment
comment|/*!     \macro QT_PREPEND_NAMESPACE(identifier)     \internal      This macro qualifies \a identifier with the full namespace.     It expands to \c{::QT_NAMESPACE::identifier} if \c QT_NAMESPACE is defined     and only \a identifier otherwise.      \sa QT_NAMESPACE */
end_comment
begin_comment
comment|/*!     \macro QT_USE_NAMESPACE     \internal      This macro expands to using QT_NAMESPACE if QT_NAMESPACE is defined     and nothing otherwise.      \sa QT_NAMESPACE */
end_comment
begin_comment
comment|/*!     \macro QT_BEGIN_NAMESPACE     \internal      This macro expands to      \snippet code/src_corelib_global_qglobal.cpp begin namespace macro      if \c QT_NAMESPACE is defined and nothing otherwise. If should always     appear in the file-level scope and be followed by \c QT_END_NAMESPACE     at the same logical level with respect to preprocessor conditionals     in the same file.      As a rule of thumb, \c QT_BEGIN_NAMESPACE should appear in all Qt header     and Qt source files after the last \c{#include} line and before the first     declaration.      If that rule can't be followed because, e.g., \c{#include} lines and     declarations are wildly mixed, place \c QT_BEGIN_NAMESPACE before     the first declaration and wrap the \c{#include} lines in     \c QT_BEGIN_INCLUDE_NAMESPACE and \c QT_END_INCLUDE_NAMESPACE.      When using the \c QT_NAMESPACE feature in user code     (e.g., when building plugins statically linked to Qt) where     the user code is not intended to go into the \c QT_NAMESPACE     namespace, all forward declarations of Qt classes need to     be wrapped in \c QT_BEGIN_NAMESPACE and \c QT_END_NAMESPACE.     After that, a \c QT_USE_NAMESPACE should follow.     No further changes should be needed.      \sa QT_NAMESPACE */
end_comment
begin_comment
comment|/*!     \macro QT_END_NAMESPACE     \internal      This macro expands to      \snippet code/src_corelib_global_qglobal.cpp end namespace macro      if \c QT_NAMESPACE is defined and nothing otherwise. It is used to cancel     the effect of \c QT_BEGIN_NAMESPACE.      If a source file ends with a \c{#include} directive that includes a moc file,     \c QT_END_NAMESPACE should be placed before that \c{#include}.      \sa QT_NAMESPACE */
end_comment
begin_comment
comment|/*!     \macro QT_BEGIN_INCLUDE_NAMESPACE     \internal      This macro is equivalent to \c QT_END_NAMESPACE.     It only serves as syntactic sugar and is intended     to be used before #include lines within a     \c QT_BEGIN_NAMESPACE ... \c QT_END_NAMESPACE block.      \sa QT_NAMESPACE */
end_comment
begin_comment
comment|/*!     \macro QT_END_INCLUDE_NAMESPACE     \internal      This macro is equivalent to \c QT_BEGIN_NAMESPACE.     It only serves as syntactic sugar and is intended     to be used after #include lines within a     \c QT_BEGIN_NAMESPACE ... \c QT_END_NAMESPACE block.      \sa QT_NAMESPACE */
end_comment
begin_comment
comment|/*!     \macro QT_BEGIN_MOC_NAMESPACE     \internal      This macro is output by moc at the beginning of     moc files. It is equivalent to \c QT_USE_NAMESPACE.      \sa QT_NAMESPACE */
end_comment
begin_comment
comment|/*!     \macro QT_END_MOC_NAMESPACE     \internal      This macro is output by moc at the beginning of     moc files. It expands to nothing.      \sa QT_NAMESPACE */
end_comment
begin_comment
comment|/*!  \fn bool qFuzzyCompare(double p1, double p2)  \relates<QtGlobal>  \since 4.4  \threadsafe   Compares the floating point value \a p1 and \a p2 and  returns \c true if they are considered equal, otherwise \c false.   Note that comparing values where either \a p1 or \a p2 is 0.0 will not work.  The solution to this is to compare against values greater than or equal to 1.0.   \snippet code/src_corelib_global_qglobal.cpp 46   The two numbers are compared in a relative way, where the  exactness is stronger the smaller the numbers are.  */
end_comment
begin_comment
comment|/*!  \fn bool qFuzzyCompare(float p1, float p2)  \relates<QtGlobal>  \since 4.4  \threadsafe   Compares the floating point value \a p1 and \a p2 and  returns \c true if they are considered equal, otherwise \c false.   The two numbers are compared in a relative way, where the  exactness is stronger the smaller the numbers are.  */
end_comment
begin_comment
comment|/*!     \macro QT_REQUIRE_VERSION(int argc, char **argv, const char *version)     \relates<QtGlobal>      This macro can be used to ensure that the application is run     against a recent enough version of Qt. This is especially useful     if your application depends on a specific bug fix introduced in a     bug-fix release (e.g., 4.0.2).      The \a argc and \a argv parameters are the \c main() function's     \c argc and \c argv parameters. The \a version parameter is a     string literal that specifies which version of Qt the application     requires (e.g., "4.0.2").      Example:      \snippet code/src_gui_dialogs_qmessagebox.cpp 4 */
end_comment
begin_comment
comment|/*!     \macro Q_DECL_EXPORT     \relates<QtGlobal>      This macro marks a symbol for shared library export (see      \l{sharedlibrary.html}{Creating Shared Libraries}).      \sa Q_DECL_IMPORT */
end_comment
begin_comment
comment|/*!     \macro Q_DECL_IMPORT     \relates<QtGlobal>      This macro declares a symbol to be an import from a shared library (see     \l{sharedlibrary.html}{Creating Shared Libraries}).      \sa Q_DECL_EXPORT */
end_comment
begin_comment
comment|/*!     \macro Q_DECL_CONSTEXPR     \relates<QtGlobal>      This macro can be used to declare variable that should be constructed at compile-time,     or an inline function that can be computed at compile-time.      It expands to "constexpr" if your compiler supports that C++11 keyword, or to nothing     otherwise. */
end_comment
begin_comment
comment|/*!     \macro qDebug(const char *message, ...)     \relates<QtGlobal>      Calls the message handler with the debug message \a message. If no     message handler has been installed, the message is printed to     stderr. Under Windows, the message is sent to the console, if it is a     console application; otherwise, it is sent to the debugger. On Blackberry the     message is sent to slogger2. This function does nothing if \c QT_NO_DEBUG_OUTPUT     was defined during compilation.      If you pass the function a format string and a list of arguments,     it works in similar way to the C printf() function. The format     should be a Latin-1 string.      Example:      \snippet code/src_corelib_global_qglobal.cpp 24      If you include \c<QtDebug>, a more convenient syntax is also     available:      \snippet code/src_corelib_global_qglobal.cpp 25      With this syntax, the function returns a QDebug object that is     configured to use the QtDebugMsg message type. It automatically     puts a single space between each item, and outputs a newline at     the end. It supports many C++ and Qt types.      To suppress the output at run-time, install your own message handler     with qInstallMessageHandler().      \sa qWarning(), qCritical(), qFatal(), qInstallMessageHandler(),         {Debugging Techniques} */
end_comment
begin_comment
comment|/*!     \macro qWarning(const char *message, ...)     \relates<QtGlobal>      Calls the message handler with the warning message \a message. If no     message handler has been installed, the message is printed to     stderr. Under Windows, the message is sent to the debugger.     On Blackberry the message is sent to slogger2. This     function does nothing if \c QT_NO_WARNING_OUTPUT was defined     during compilation; it exits if the environment variable \c     QT_FATAL_WARNINGS is not empty.      This function takes a format string and a list of arguments,     similar to the C printf() function. The format should be a Latin-1     string.      Example:     \snippet code/src_corelib_global_qglobal.cpp 26      If you include<QtDebug>, a more convenient syntax is     also available:      \snippet code/src_corelib_global_qglobal.cpp 27      This syntax inserts a space between each item, and     appends a newline at the end.      To suppress the output at runtime, install your own message handler     with qInstallMessageHandler().      \sa qDebug(), qCritical(), qFatal(), qInstallMessageHandler(),         {Debugging Techniques} */
end_comment
begin_comment
comment|/*!     \macro qCritical(const char *message, ...)     \relates<QtGlobal>      Calls the message handler with the critical message \a message. If no     message handler has been installed, the message is printed to     stderr. Under Windows, the message is sent to the debugger.     On Blackberry the message is sent to slogger2.      It exits if the environment variable QT_FATAL_CRITICALS is not empty.      This function takes a format string and a list of arguments,     similar to the C printf() function. The format should be a Latin-1     string.      Example:     \snippet code/src_corelib_global_qglobal.cpp 28      If you include<QtDebug>, a more convenient syntax is     also available:      \snippet code/src_corelib_global_qglobal.cpp 29      A space is inserted between the items, and a newline is     appended at the end.      To suppress the output at runtime, install your own message handler     with qInstallMessageHandler().      \sa qDebug(), qWarning(), qFatal(), qInstallMessageHandler(),         {Debugging Techniques} */
end_comment
begin_comment
comment|/*!     \macro qFatal(const char *message, ...)     \relates<QtGlobal>      Calls the message handler with the fatal message \a message. If no     message handler has been installed, the message is printed to     stderr. Under Windows, the message is sent to the debugger.     On Blackberry the message is sent to slogger2.      If you are using the \b{default message handler} this function will     abort on Unix systems to create a core dump. On Windows, for debug builds,     this function will report a _CRT_ERROR enabling you to connect a debugger     to the application.      This function takes a format string and a list of arguments,     similar to the C printf() function.      Example:     \snippet code/src_corelib_global_qglobal.cpp 30      To suppress the output at runtime, install your own message handler     with qInstallMessageHandler().      \sa qDebug(), qCritical(), qWarning(), qInstallMessageHandler(),         {Debugging Techniques} */
end_comment
begin_comment
comment|/*!     \macro qMove(x)     \relates<QtGlobal>      It expands to "std::move" if your compiler supports that C++11 function, or to nothing     otherwise.      qMove takes an rvalue reference to its parameter \a x, and converts it to an xvalue. */
end_comment
begin_comment
comment|/*!     \macro Q_DECL_NOTHROW     \relates<QtGlobal>     \since 5.0      This macro marks a function as never throwing, under no     circumstances. If the function does nevertheless throw, the     behaviour is undefined.      The macro expands to either "throw()", if that has some benefit on     the compiler, or to C++11 noexcept, if available, or to nothing     otherwise.      If you need C++11 noexcept semantics, don't use this macro, use     Q_DECL_NOEXCEPT/Q_DECL_NOEXCEPT_EXPR instead.      \sa Q_DECL_NOEXCEPT, Q_DECL_NOEXCEPT_EXPR() */
end_comment
begin_comment
comment|/*!     \macro QT_TERMINATE_ON_EXCEPTION(expr)     \relates<QtGlobal>     \internal      In general, use of the Q_DECL_NOEXCEPT macro is preferred over     Q_DECL_NOTHROW, because it exhibits well-defined behavior and     supports the more powerful Q_DECL_NOEXCEPT_EXPR variant. However,     use of Q_DECL_NOTHROW has the advantage that Windows builds     benefit on a wide range or compiler versions that do not yet     support the C++11 noexcept feature.      It may therefore be beneficial to use Q_DECL_NOTHROW and emulate     the C++11 behavior manually with an embedded try/catch.      Qt provides the QT_TERMINATE_ON_EXCEPTION(expr) macro for this     purpose. It either expands to \c expr (if Qt is compiled without     exception support or the compiler supports C++11 noexcept     semantics) or to     \code     try { expr; } catch(...) { qTerminate(); }     \endcode     otherwise.      Since this macro expands to just \c expr if the compiler supports     C++11 noexcept, expecting the compiler to take over responsibility     of calling std::terminate() in that case, it should not be used     outside Q_DECL_NOTHROW functions.      \sa Q_DECL_NOEXCEPT, Q_DECL_NOTHROW, qTerminate() */
end_comment
begin_comment
comment|/*!     \macro Q_DECL_NOEXCEPT     \relates<QtGlobal>     \since 5.0      This macro marks a function as never throwing. If the function     does nevertheless throw, the behaviour is defined:     std::terminate() is called.      The macro expands to C++11 noexcept, if available, or to nothing     otherwise.      If you need the operator version of C++11 noexcept, use     Q_DECL_NOEXCEPT_EXPR(x).      If you don't need C++11 noexcept semantics, e.g. because your     function can't possibly throw, don't use this macro, use     Q_DECL_NOTHROW instead.      \sa Q_DECL_NOTHROW, Q_DECL_NOEXCEPT_EXPR() */
end_comment
begin_comment
comment|/*!     \macro Q_DECL_NOEXCEPT_EXPR(x)     \relates<QtGlobal>     \since 5.0      This macro marks a function as non-throwing if \a x is \c true. If     the function does nevertheless throw, the behaviour is defined:     std::terminate() is called.      The macro expands to C++11 noexcept(x), if available, or to     nothing otherwise.      If you need the always-true version of C++11 noexcept, use     Q_DECL_NOEXCEPT.      If you don't need C++11 noexcept semantics, e.g. because your     function can't possibly throw, don't use this macro, use     Q_DECL_NOTHROW instead.      \sa Q_DECL_NOTHROW, Q_DECL_NOEXCEPT */
end_comment
begin_comment
comment|/*!     \macro Q_DECL_OVERRIDE     \since 5.0     \relates<QtGlobal>      This macro can be used to declare an overriding virtual     function. Use of this markup will allow the compiler to generate     an error if the overriding virtual function does not in fact     override anything.      It expands to "override" if your compiler supports that C++11     contextual keyword, or to nothing otherwise.      The macro goes at the end of the function, usually after the     \c{const}, if any:     \code     // generate error if this doesn't actually override anything:     virtual void MyWidget::paintEvent(QPaintEvent*) Q_DECL_OVERRIDE;     \endcode      \sa Q_DECL_FINAL */
end_comment
begin_comment
comment|/*!     \macro Q_DECL_FINAL     \since 5.0     \relates<QtGlobal>      This macro can be used to declare an overriding virtual or a class     as "final", with Java semantics. Further-derived classes can then     no longer override this virtual function, or inherit from this     class, respectively.      It expands to "final" if your compiler supports that C++11     contextual keyword, or something non-standard if your compiler     supports something close enough to the C++11 semantics, or to     nothing otherwise.      The macro goes at the end of the function, usually after the     \c{const}, if any:     \code     // more-derived classes no longer permitted to override this:     virtual void MyWidget::paintEvent(QPaintEvent*) Q_DECL_FINAL;     \endcode      For classes, it goes in front of the \c{:} in the class     definition, if any:     \code     class QRect Q_DECL_FINAL { // cannot be derived from         // ...     };     \endcode      \sa Q_DECL_OVERRIDE */
end_comment
begin_comment
comment|/*!     \macro Q_FORWARD_DECLARE_OBJC_CLASS(classname)     \since 5.2     \relates<QtGlobal>      Forward-declares an Objective-C \a classname in a manner such that it can be     compiled as either Objective-C or C++.      This is primarily intended for use in header files that may be included by     both Objective-C and C++ source files. */
end_comment
begin_comment
comment|/*!     \macro Q_FORWARD_DECLARE_CF_TYPE(type)     \since 5.2     \relates<QtGlobal>      Forward-declares a Core Foundation \a type. This includes the actual     type and the ref type. For example, Q_FORWARD_DECLARE_CF_TYPE(CFString)     declares __CFString and CFStringRef. */
end_comment
begin_comment
comment|/*!     \macro Q_FORWARD_DECLARE_MUTABLE_CF_TYPE(type)     \since 5.2     \relates<QtGlobal>      Forward-declares a mutable Core Foundation \a type. This includes the actual     type and the ref type. For example, Q_FORWARD_DECLARE_CF_TYPE(CFString)     declares __CFMutableString and CFMutableStringRef. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
