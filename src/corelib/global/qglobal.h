begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QGLOBAL_H
end_ifndef
begin_define
DECL|macro|QGLOBAL_H
define|#
directive|define
name|QGLOBAL_H
end_define
begin_include
include|#
directive|include
file|<stddef.h>
end_include
begin_define
DECL|macro|QT_VERSION_STR
define|#
directive|define
name|QT_VERSION_STR
value|"5.0.0"
end_define
begin_comment
comment|/*    QT_VERSION is (major<< 16) + (minor<< 8) + patch. */
end_comment
begin_define
DECL|macro|QT_VERSION
define|#
directive|define
name|QT_VERSION
value|0x050000
end_define
begin_comment
comment|/*    can be used like #if (QT_VERSION>= QT_VERSION_CHECK(4, 4, 0)) */
end_comment
begin_define
DECL|macro|QT_VERSION_CHECK
define|#
directive|define
name|QT_VERSION_CHECK
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|,
name|patch
parameter_list|)
value|((major<<16)|(minor<<8)|(patch))
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_DISABLE_DEPRECATED_BEFORE
end_ifndef
begin_define
DECL|macro|QT_DISABLE_DEPRECATED_BEFORE
define|#
directive|define
name|QT_DISABLE_DEPRECATED_BEFORE
value|QT_VERSION_CHECK(5, 0, 0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*     QT_DEPRECATED_SINCE(major, minor) evaluates as true if the Qt version is greater than     the deprecation point specified.      Use it to specify from which version of Qt a function or class has been deprecated      Example:         #if QT_DEPRECATED_SINCE(5,1)             QT_DEPRECATED void deprecatedFunction(); //function deprecated sine Qt 5.1         #endif  */
end_comment
begin_define
DECL|macro|QT_DEPRECATED_SINCE
define|#
directive|define
name|QT_DEPRECATED_SINCE
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
value|(QT_VERSION_CHECK(major, minor, 0)> QT_DISABLE_DEPRECATED_BEFORE)
end_define
begin_define
DECL|macro|QT_PACKAGEDATE_STR
define|#
directive|define
name|QT_PACKAGEDATE_STR
value|"YYYY-MM-DD"
end_define
begin_define
DECL|macro|QT_PACKAGE_TAG
define|#
directive|define
name|QT_PACKAGE_TAG
value|""
end_define
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_BUILD_MOC
argument_list|)
end_if
begin_include
include|#
directive|include
file|<QtCore/qconfig.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STL
end_ifndef
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NAMESPACE
end_ifndef
begin_comment
comment|/* user namespace */
end_comment
begin_define
DECL|macro|QT_PREPEND_NAMESPACE
define|#
directive|define
name|QT_PREPEND_NAMESPACE
parameter_list|(
name|name
parameter_list|)
value|::name
end_define
begin_define
DECL|macro|QT_USE_NAMESPACE
define|#
directive|define
name|QT_USE_NAMESPACE
end_define
begin_define
DECL|macro|QT_BEGIN_NAMESPACE
define|#
directive|define
name|QT_BEGIN_NAMESPACE
end_define
begin_define
DECL|macro|QT_END_NAMESPACE
define|#
directive|define
name|QT_END_NAMESPACE
end_define
begin_define
DECL|macro|QT_BEGIN_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_BEGIN_INCLUDE_NAMESPACE
end_define
begin_define
DECL|macro|QT_END_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_END_INCLUDE_NAMESPACE
end_define
begin_define
DECL|macro|QT_BEGIN_MOC_NAMESPACE
define|#
directive|define
name|QT_BEGIN_MOC_NAMESPACE
end_define
begin_define
DECL|macro|QT_END_MOC_NAMESPACE
define|#
directive|define
name|QT_END_MOC_NAMESPACE
end_define
begin_define
DECL|macro|QT_FORWARD_DECLARE_CLASS
define|#
directive|define
name|QT_FORWARD_DECLARE_CLASS
parameter_list|(
name|name
parameter_list|)
value|class name;
end_define
begin_define
DECL|macro|QT_FORWARD_DECLARE_STRUCT
define|#
directive|define
name|QT_FORWARD_DECLARE_STRUCT
parameter_list|(
name|name
parameter_list|)
value|struct name;
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE
define|#
directive|define
name|QT_MANGLE_NAMESPACE
parameter_list|(
name|name
parameter_list|)
value|name
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* user namespace */
end_comment
begin_define
DECL|macro|QT_PREPEND_NAMESPACE
define|#
directive|define
name|QT_PREPEND_NAMESPACE
parameter_list|(
name|name
parameter_list|)
value|::QT_NAMESPACE::name
end_define
begin_define
DECL|macro|QT_USE_NAMESPACE
define|#
directive|define
name|QT_USE_NAMESPACE
value|using namespace ::QT_NAMESPACE;
end_define
begin_define
DECL|macro|QT_BEGIN_NAMESPACE
define|#
directive|define
name|QT_BEGIN_NAMESPACE
value|namespace QT_NAMESPACE {
end_define
begin_define
DECL|macro|QT_END_NAMESPACE
define|#
directive|define
name|QT_END_NAMESPACE
value|}
end_define
begin_define
DECL|macro|QT_BEGIN_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_BEGIN_INCLUDE_NAMESPACE
value|}
end_define
begin_define
DECL|macro|QT_END_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_END_INCLUDE_NAMESPACE
value|namespace QT_NAMESPACE {
end_define
begin_define
DECL|macro|QT_BEGIN_MOC_NAMESPACE
define|#
directive|define
name|QT_BEGIN_MOC_NAMESPACE
value|QT_USE_NAMESPACE
end_define
begin_define
DECL|macro|QT_END_MOC_NAMESPACE
define|#
directive|define
name|QT_END_MOC_NAMESPACE
end_define
begin_define
DECL|macro|QT_FORWARD_DECLARE_CLASS
define|#
directive|define
name|QT_FORWARD_DECLARE_CLASS
parameter_list|(
name|name
parameter_list|)
define|\
value|QT_BEGIN_NAMESPACE class name; QT_END_NAMESPACE \     using QT_PREPEND_NAMESPACE(name);
end_define
begin_define
DECL|macro|QT_FORWARD_DECLARE_STRUCT
define|#
directive|define
name|QT_FORWARD_DECLARE_STRUCT
parameter_list|(
name|name
parameter_list|)
define|\
value|QT_BEGIN_NAMESPACE struct name; QT_END_NAMESPACE \     using QT_PREPEND_NAMESPACE(name);
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE0
define|#
directive|define
name|QT_MANGLE_NAMESPACE0
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE1
define|#
directive|define
name|QT_MANGLE_NAMESPACE1
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a##_##b
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE2
define|#
directive|define
name|QT_MANGLE_NAMESPACE2
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|QT_MANGLE_NAMESPACE1(a,b)
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE
define|#
directive|define
name|QT_MANGLE_NAMESPACE
parameter_list|(
name|name
parameter_list|)
value|QT_MANGLE_NAMESPACE2( \         QT_MANGLE_NAMESPACE0(name), QT_MANGLE_NAMESPACE0(QT_NAMESPACE))
end_define
begin_decl_stmt
name|namespace
name|QT_NAMESPACE
block|{}
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_USING_NAMESPACE
end_ifndef
begin_comment
comment|/*     This expands to a "using QT_NAMESPACE" also in _header files_.     It is the only way the feature can be used without too much     pain, but if people _really_ do not want it they can add     DEFINES += QT_NO_USING_NAMESPACE to their .pro files.     */
end_comment
begin_expr_stmt
name|QT_USE_NAMESPACE
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* user namespace */
else|#
directive|else
comment|/* __cplusplus */
define|#
directive|define
name|QT_BEGIN_NAMESPACE
define|#
directive|define
name|QT_END_NAMESPACE
define|#
directive|define
name|QT_USE_NAMESPACE
define|#
directive|define
name|QT_BEGIN_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_END_INCLUDE_NAMESPACE
endif|#
directive|endif
comment|/* __cplusplus */
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
DECL|macro|QT_BEGIN_HEADER
define|#
directive|define
name|QT_BEGIN_HEADER
value|extern "C++" {
DECL|macro|QT_END_HEADER
define|#
directive|define
name|QT_END_HEADER
value|}
DECL|macro|QT_BEGIN_INCLUDE_HEADER
define|#
directive|define
name|QT_BEGIN_INCLUDE_HEADER
value|}
DECL|macro|QT_END_INCLUDE_HEADER
define|#
directive|define
name|QT_END_INCLUDE_HEADER
value|extern "C++" {
else|#
directive|else
define|#
directive|define
name|QT_BEGIN_HEADER
define|#
directive|define
name|QT_END_HEADER
define|#
directive|define
name|QT_BEGIN_INCLUDE_HEADER
define|#
directive|define
name|QT_END_INCLUDE_HEADER
value|extern "C++"
endif|#
directive|endif
comment|/*    The operating system, must be one of: (Q_OS_x)       DARWIN   - Darwin OS (synonym for Q_OS_MAC)      SYMBIAN  - Symbian      MSDOS    - MS-DOS and Windows      OS2      - OS/2      OS2EMX   - XFree86 on OS/2 (not PM)      WIN32    - Win32 (Windows 2000/XP/Vista/7 and Windows Server 2003/2008)      WINCE    - WinCE (Windows CE 5.0)      CYGWIN   - Cygwin      SOLARIS  - Sun Solaris      HPUX     - HP-UX      ULTRIX   - DEC Ultrix      LINUX    - Linux      FREEBSD  - FreeBSD      NETBSD   - NetBSD      OPENBSD  - OpenBSD      BSDI     - BSD/OS      IRIX     - SGI Irix      OSF      - HP Tru64 UNIX      SCO      - SCO OpenServer 5      UNIXWARE - UnixWare 7, Open UNIX 8      AIX      - AIX      HURD     - GNU Hurd      DGUX     - DG/UX      RELIANT  - Reliant UNIX      DYNIX    - DYNIX/ptx      QNX      - QNX      QNX6     - QNX RTP 6.1      LYNX     - LynxOS      BSD4     - Any BSD 4.4 system      UNIX     - Any UNIX BSD/SYSV system */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__xlC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__xlc__
argument_list|)
operator|)
DECL|macro|Q_OS_DARWIN
define|#
directive|define
name|Q_OS_DARWIN
DECL|macro|Q_OS_BSD4
define|#
directive|define
name|Q_OS_BSD4
ifdef|#
directive|ifdef
name|__LP64__
DECL|macro|Q_OS_DARWIN64
define|#
directive|define
name|Q_OS_DARWIN64
else|#
directive|else
define|#
directive|define
name|Q_OS_DARWIN32
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|__SYMBIAN32__
argument_list|)
operator|||
name|defined
argument_list|(
name|SYMBIAN
argument_list|)
define|#
directive|define
name|Q_OS_SYMBIAN
define|#
directive|define
name|Q_NO_POSIX_SIGNALS
define|#
directive|define
name|QT_NO_GETIFADDRS
elif|#
directive|elif
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
define|#
directive|define
name|Q_OS_CYGWIN
elif|#
directive|elif
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|_MSDOS
argument_list|)
define|#
directive|define
name|Q_OS_MSDOS
elif|#
directive|elif
name|defined
argument_list|(
name|__OS2__
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|__EMX__
argument_list|)
define|#
directive|define
name|Q_OS_OS2EMX
else|#
directive|else
define|#
directive|define
name|Q_OS_OS2
endif|#
directive|endif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|SAG_COM
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|WIN64
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN64
argument_list|)
operator|||
name|defined
argument_list|(
name|__WIN64__
argument_list|)
operator|)
define|#
directive|define
name|Q_OS_WIN32
define|#
directive|define
name|Q_OS_WIN64
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|SAG_COM
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NT__
argument_list|)
operator|)
if|#
directive|if
name|defined
argument_list|(
name|WINCE
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
define|#
directive|define
name|Q_OS_WINCE
else|#
directive|else
define|#
directive|define
name|Q_OS_WIN32
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|__MWERKS__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__INTEL__
argument_list|)
define|#
directive|define
name|Q_OS_WIN32
elif|#
directive|elif
name|defined
argument_list|(
name|__sun
argument_list|)
operator|||
name|defined
argument_list|(
name|sun
argument_list|)
define|#
directive|define
name|Q_OS_SOLARIS
elif|#
directive|elif
name|defined
argument_list|(
name|hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
define|#
directive|define
name|Q_OS_HPUX
elif|#
directive|elif
name|defined
argument_list|(
name|__ultrix
argument_list|)
operator|||
name|defined
argument_list|(
name|ultrix
argument_list|)
define|#
directive|define
name|Q_OS_ULTRIX
elif|#
directive|elif
name|defined
argument_list|(
name|sinix
argument_list|)
define|#
directive|define
name|Q_OS_RELIANT
elif|#
directive|elif
name|defined
argument_list|(
name|__native_client__
argument_list|)
define|#
directive|define
name|Q_OS_NACL
elif|#
directive|elif
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|||
name|defined
argument_list|(
name|__linux
argument_list|)
define|#
directive|define
name|Q_OS_LINUX
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
define|#
directive|define
name|Q_OS_FREEBSD
define|#
directive|define
name|Q_OS_BSD4
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
define|#
directive|define
name|Q_OS_NETBSD
define|#
directive|define
name|Q_OS_BSD4
elif|#
directive|elif
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
define|#
directive|define
name|Q_OS_OPENBSD
define|#
directive|define
name|Q_OS_BSD4
elif|#
directive|elif
name|defined
argument_list|(
name|__bsdi__
argument_list|)
define|#
directive|define
name|Q_OS_BSDI
define|#
directive|define
name|Q_OS_BSD4
elif|#
directive|elif
name|defined
argument_list|(
name|__sgi
argument_list|)
define|#
directive|define
name|Q_OS_IRIX
elif|#
directive|elif
name|defined
argument_list|(
name|__osf__
argument_list|)
define|#
directive|define
name|Q_OS_OSF
elif|#
directive|elif
name|defined
argument_list|(
name|_AIX
argument_list|)
define|#
directive|define
name|Q_OS_AIX
elif|#
directive|elif
name|defined
argument_list|(
name|__Lynx__
argument_list|)
define|#
directive|define
name|Q_OS_LYNX
elif|#
directive|elif
name|defined
argument_list|(
name|__GNU__
argument_list|)
define|#
directive|define
name|Q_OS_HURD
elif|#
directive|elif
name|defined
argument_list|(
name|__DGUX__
argument_list|)
define|#
directive|define
name|Q_OS_DGUX
elif|#
directive|elif
name|defined
argument_list|(
name|__QNXNTO__
argument_list|)
define|#
directive|define
name|Q_OS_QNX
elif|#
directive|elif
name|defined
argument_list|(
name|_SEQUENT_
argument_list|)
define|#
directive|define
name|Q_OS_DYNIX
elif|#
directive|elif
name|defined
argument_list|(
name|_SCO_DS
argument_list|)
comment|/* SCO OpenServer 5 + GCC */
define|#
directive|define
name|Q_OS_SCO
elif|#
directive|elif
name|defined
argument_list|(
name|__USLC__
argument_list|)
comment|/* all SCO platforms + UDK or OUDK */
define|#
directive|define
name|Q_OS_UNIXWARE
elif|#
directive|elif
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|&&
name|defined
argument_list|(
name|i386
argument_list|)
comment|/* Open UNIX 8 + GCC */
define|#
directive|define
name|Q_OS_UNIXWARE
elif|#
directive|elif
name|defined
argument_list|(
name|__INTEGRITY
argument_list|)
define|#
directive|define
name|Q_OS_INTEGRITY
elif|#
directive|elif
name|defined
argument_list|(
name|VXWORKS
argument_list|)
comment|/* there is no "real" VxWorks define - this has to be set in the mkspec! */
define|#
directive|define
name|Q_OS_VXWORKS
elif|#
directive|elif
name|defined
argument_list|(
name|__MAKEDEPEND__
argument_list|)
else|#
directive|else
error|#
directive|error
literal|"Qt has not been ported to this OS - talk to qt-bugs@trolltech.com"
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WIN64
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
DECL|macro|Q_OS_WIN
define|#
directive|define
name|Q_OS_WIN
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
DECL|macro|Q_OS_MAC
define|#
directive|define
name|Q_OS_MAC
comment|/* Q_OS_MAC is mostly for compatibility, but also more clear */
DECL|macro|Q_OS_MACX
define|#
directive|define
name|Q_OS_MACX
comment|/* Q_OS_MACX is only for compatibility.*/
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_DARWIN64
argument_list|)
DECL|macro|Q_OS_MAC64
define|#
directive|define
name|Q_OS_MAC64
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_DARWIN32
argument_list|)
define|#
directive|define
name|Q_OS_MAC32
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_AUTODETECT_COCOA
ifdef|#
directive|ifdef
name|Q_OS_MAC64
DECL|macro|QT_MAC_USE_COCOA
define|#
directive|define
name|QT_MAC_USE_COCOA
value|1
DECL|macro|QT_BUILD_KEY
define|#
directive|define
name|QT_BUILD_KEY
value|QT_BUILD_KEY_COCOA
else|#
directive|else
define|#
directive|define
name|QT_BUILD_KEY
value|QT_BUILD_KEY_CARBON
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_MAC64
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_MAC_USE_COCOA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BUILD_QMAKE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
error|#
directive|error
literal|"You are building a 64-bit application, but using a 32-bit version of Qt. Check your build configuration."
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
DECL|macro|Q_OS_UNIX
undef|#
directive|undef
name|Q_OS_UNIX
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
define|#
directive|define
name|Q_OS_UNIX
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_LARGEFILE_SUPPORT
argument_list|)
DECL|macro|QT_LARGEFILE_SUPPORT
define|#
directive|define
name|QT_LARGEFILE_SUPPORT
value|64
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_DARWIN
ifdef|#
directive|ifdef
name|MAC_OS_X_VERSION_MIN_REQUIRED
DECL|macro|MAC_OS_X_VERSION_MIN_REQUIRED
undef|#
directive|undef
name|MAC_OS_X_VERSION_MIN_REQUIRED
endif|#
directive|endif
DECL|macro|MAC_OS_X_VERSION_MIN_REQUIRED
define|#
directive|define
name|MAC_OS_X_VERSION_MIN_REQUIRED
value|MAC_OS_X_VERSION_10_4
include|#
directive|include
file|<AvailabilityMacros.h>
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAC_OS_X_VERSION_10_3
argument_list|)
DECL|macro|MAC_OS_X_VERSION_10_3
define|#
directive|define
name|MAC_OS_X_VERSION_10_3
value|MAC_OS_X_VERSION_10_2 + 1
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAC_OS_X_VERSION_10_4
argument_list|)
DECL|macro|MAC_OS_X_VERSION_10_4
define|#
directive|define
name|MAC_OS_X_VERSION_10_4
value|MAC_OS_X_VERSION_10_3 + 1
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAC_OS_X_VERSION_10_5
argument_list|)
DECL|macro|MAC_OS_X_VERSION_10_5
define|#
directive|define
name|MAC_OS_X_VERSION_10_5
value|MAC_OS_X_VERSION_10_4 + 1
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAC_OS_X_VERSION_10_6
argument_list|)
DECL|macro|MAC_OS_X_VERSION_10_6
define|#
directive|define
name|MAC_OS_X_VERSION_10_6
value|MAC_OS_X_VERSION_10_5 + 1
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAC_OS_X_VERSION_10_7
argument_list|)
DECL|macro|MAC_OS_X_VERSION_10_7
define|#
directive|define
name|MAC_OS_X_VERSION_10_7
value|MAC_OS_X_VERSION_10_6 + 1
endif|#
directive|endif
if|#
directive|if
operator|(
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|>
name|MAC_OS_X_VERSION_10_7
operator|)
warning|#
directive|warning
literal|"This version of Mac OS X is unsupported"
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__LSB_VERSION__
if|#
directive|if
name|__LSB_VERSION__
operator|<
literal|40
error|#
directive|error
literal|"This version of the Linux Standard Base is unsupported"
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_LINUXBASE
DECL|macro|QT_LINUXBASE
define|#
directive|define
name|QT_LINUXBASE
endif|#
directive|endif
endif|#
directive|endif
comment|/*    The compiler, must be one of: (Q_CC_x)       SYM      - Digital Mars C/C++ (used to be Symantec C++)      MWERKS   - Metrowerks CodeWarrior      MSVC     - Microsoft Visual C/C++, Intel C++ for Windows      BOR      - Borland/Turbo C++      WAT      - Watcom C++      GNU      - GNU C++      COMEAU   - Comeau C++      EDG      - Edison Design Group C++      OC       - CenterLine C++      SUN      - Forte Developer, or Sun Studio C++      MIPS     - MIPSpro C++      DEC      - DEC C++      HPACC    - HP aC++      USLC     - SCO OUDK and UDK      CDS      - Reliant C++      KAI      - KAI C++      INTEL    - Intel C++ for Linux, Intel C++ for Windows      HIGHC    - MetaWare High C/C++      PGI      - Portland Group C++      GHS      - Green Hills Optimizing C++ Compilers      GCCE     - GCCE (Symbian GCCE builds)      RVCT     - ARM Realview Compiler Suite      NOKIAX86 - Nokia x86 (Symbian WINSCW builds)      CLANG    - C++ front-end for the LLVM compiler      Should be sorted most to least authoritative. */
if|#
directive|if
name|defined
argument_list|(
name|__ghs
argument_list|)
DECL|macro|Q_OUTOFLINE_TEMPLATE
define|#
directive|define
name|Q_OUTOFLINE_TEMPLATE
value|inline
comment|/* the following are necessary because the GHS C++ name mangling relies on __*/
DECL|macro|Q_CONSTRUCTOR_FUNCTION0
define|#
directive|define
name|Q_CONSTRUCTOR_FUNCTION0
parameter_list|(
name|AFUNC
parameter_list|)
define|\
value|static const int AFUNC ## _init_variable_ = AFUNC();
DECL|macro|Q_CONSTRUCTOR_FUNCTION
define|#
directive|define
name|Q_CONSTRUCTOR_FUNCTION
parameter_list|(
name|AFUNC
parameter_list|)
value|Q_CONSTRUCTOR_FUNCTION0(AFUNC)
DECL|macro|Q_DESTRUCTOR_FUNCTION0
define|#
directive|define
name|Q_DESTRUCTOR_FUNCTION0
parameter_list|(
name|AFUNC
parameter_list|)
define|\
value|class AFUNC ## _dest_class_ { \     public: \        inline AFUNC ## _dest_class_() { } \        inline ~ AFUNC ## _dest_class_() { AFUNC(); } \     } AFUNC ## _dest_instance_;
DECL|macro|Q_DESTRUCTOR_FUNCTION
define|#
directive|define
name|Q_DESTRUCTOR_FUNCTION
parameter_list|(
name|AFUNC
parameter_list|)
value|Q_DESTRUCTOR_FUNCTION0(AFUNC)
endif|#
directive|endif
comment|/* Symantec C++ is now Digital Mars */
if|#
directive|if
name|defined
argument_list|(
name|__DMC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__SC__
argument_list|)
DECL|macro|Q_CC_SYM
define|#
directive|define
name|Q_CC_SYM
comment|/* "explicit" semantics implemented in 8.1e but keyword recognized since 7.5 */
if|#
directive|if
name|defined
argument_list|(
name|__SC__
argument_list|)
operator|&&
name|__SC__
operator|<
literal|0x750
DECL|macro|Q_NO_EXPLICIT_KEYWORD
define|#
directive|define
name|Q_NO_EXPLICIT_KEYWORD
endif|#
directive|endif
DECL|macro|Q_NO_USING_KEYWORD
define|#
directive|define
name|Q_NO_USING_KEYWORD
elif|#
directive|elif
name|defined
argument_list|(
name|__MWERKS__
argument_list|)
define|#
directive|define
name|Q_CC_MWERKS
if|#
directive|if
name|defined
argument_list|(
name|__EMU_SYMBIAN_OS__
argument_list|)
define|#
directive|define
name|Q_CC_NOKIAX86
endif|#
directive|endif
comment|/* "explicit" recognized since 4.0d1 */
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
define|#
directive|define
name|Q_CC_MSVC
define|#
directive|define
name|Q_CC_MSVC_NET
define|#
directive|define
name|Q_CANNOT_DELETE_CONSTANT
define|#
directive|define
name|Q_OUTOFLINE_TEMPLATE
value|inline
define|#
directive|define
name|Q_NO_TEMPLATE_FRIENDS
define|#
directive|define
name|Q_ALIGNOF
parameter_list|(
name|type
parameter_list|)
value|__alignof(type)
define|#
directive|define
name|Q_DECL_ALIGN
parameter_list|(
name|n
parameter_list|)
value|__declspec(align(n))
comment|/* Intel C++ disguising as Visual C++: the `using' keyword avoids warnings */
if|#
directive|if
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
define|#
directive|define
name|Q_CC_INTEL
endif|#
directive|endif
comment|/* MSVC does not support SSE/MMX on x64 */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
operator|&&
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|)
undef|#
directive|undef
name|QT_HAVE_SSE
undef|#
directive|undef
name|QT_HAVE_MMX
undef|#
directive|undef
name|QT_HAVE_3DNOW
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1600
define|#
directive|define
name|Q_COMPILER_RVALUE_REFS
define|#
directive|define
name|Q_COMPILER_AUTO_TYPE
define|#
directive|define
name|Q_COMPILER_LAMBDA
define|#
directive|define
name|Q_COMPILER_DECLTYPE
comment|//  MSCV has std::initilizer_list, but do not support the braces initialization
comment|//#      define Q_COMPILER_INITIALIZER_LISTS
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__TURBOC__
argument_list|)
define|#
directive|define
name|Q_CC_BOR
define|#
directive|define
name|Q_INLINE_TEMPLATE
if|#
directive|if
name|__BORLANDC__
operator|<
literal|0x502
define|#
directive|define
name|Q_NO_BOOL_TYPE
define|#
directive|define
name|Q_NO_EXPLICIT_KEYWORD
endif|#
directive|endif
define|#
directive|define
name|Q_NO_USING_KEYWORD
elif|#
directive|elif
name|defined
argument_list|(
name|__WATCOMC__
argument_list|)
define|#
directive|define
name|Q_CC_WAT
comment|/* Symbian GCCE */
elif|#
directive|elif
name|defined
argument_list|(
name|__GCCE__
argument_list|)
define|#
directive|define
name|Q_CC_GCCE
define|#
directive|define
name|QT_VISIBILITY_AVAILABLE
if|#
directive|if
name|defined
argument_list|(
name|__ARM_ARCH_6__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7A__
argument_list|)
define|#
directive|define
name|QT_HAVE_ARMV6
endif|#
directive|endif
comment|/* ARM Realview Compiler Suite    RVCT compiler also defines __EDG__ and __GNUC__ (if --gnu flag is given),    so check for it before that */
elif|#
directive|elif
name|defined
argument_list|(
name|__ARMCC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__CC_ARM
argument_list|)
define|#
directive|define
name|Q_CC_RVCT
if|#
directive|if
name|__TARGET_ARCH_ARM
operator|>=
literal|6
define|#
directive|define
name|QT_HAVE_ARMV6
endif|#
directive|endif
comment|/* work-around for missing compiler intrinsics */
define|#
directive|define
name|__is_empty
parameter_list|(
name|X
parameter_list|)
value|false
define|#
directive|define
name|__is_pod
parameter_list|(
name|X
parameter_list|)
value|false
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
define|#
directive|define
name|Q_CC_GNU
define|#
directive|define
name|Q_C_CALLBACKS
if|#
directive|if
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
define|#
directive|define
name|Q_CC_MINGW
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
comment|/* Intel C++ also masquerades as GCC 3.2.0 */
define|#
directive|define
name|Q_CC_INTEL
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__clang__
argument_list|)
comment|/* Clang also masquerades as GCC 4.2.1 */
define|#
directive|define
name|Q_CC_CLANG
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__APPLE__
define|#
directive|define
name|Q_NO_DEPRECATED_CONSTRUCTORS
endif|#
directive|endif
if|#
directive|if
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|<=
literal|7
define|#
directive|define
name|Q_FULL_TEMPLATE_INSTANTIATION
endif|#
directive|endif
comment|/* GCC 2.95 knows "using" but does not support it correctly */
if|#
directive|if
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|<=
literal|95
define|#
directive|define
name|Q_NO_USING_KEYWORD
define|#
directive|define
name|QT_NO_STL_WCHAR
endif|#
directive|endif
if|#
directive|if
name|__GNUC__
operator|>
literal|2
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|95
operator|)
define|#
directive|define
name|Q_ALIGNOF
parameter_list|(
name|type
parameter_list|)
value|__alignof__(type)
define|#
directive|define
name|Q_TYPEOF
parameter_list|(
name|expr
parameter_list|)
value|__typeof__(expr)
define|#
directive|define
name|Q_DECL_ALIGN
parameter_list|(
name|n
parameter_list|)
value|__attribute__((__aligned__(n)))
endif|#
directive|endif
if|#
directive|if
name|__GNUC__
operator|>
literal|2
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|96
operator|)
define|#
directive|define
name|Q_LIKELY
parameter_list|(
name|expr
parameter_list|)
value|__builtin_expect(!!(expr), true)
define|#
directive|define
name|Q_UNLIKELY
parameter_list|(
name|expr
parameter_list|)
value|__builtin_expect(!!(expr), false)
endif|#
directive|endif
comment|/* GCC 3.1 and GCC 3.2 wrongly define _SB_CTYPE_MACROS on HP-UX */
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
operator|&&
name|__GNUC__
operator|==
literal|3
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|1
define|#
directive|define
name|Q_WRONG_SB_CTYPE_MACROS
endif|#
directive|endif
comment|/* GCC<= 3.3 cannot handle template friends */
if|#
directive|if
name|__GNUC__
operator|<
literal|3
operator|||
operator|(
name|__GNUC__
operator|==
literal|3
operator|&&
name|__GNUC_MINOR__
operator|<=
literal|3
operator|)
define|#
directive|define
name|Q_NO_TEMPLATE_FRIENDS
endif|#
directive|endif
comment|/* Apple's GCC 3.1 chokes on our streaming qDebug() */
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
operator|&&
name|__GNUC__
operator|==
literal|3
operator|&&
operator|(
name|__GNUC_MINOR__
operator|>=
literal|1
operator|&&
name|__GNUC_MINOR__
operator|<
literal|3
operator|)
define|#
directive|define
name|Q_BROKEN_DEBUG_STREAM
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_MOC_CPP
argument_list|)
define|#
directive|define
name|Q_PACKED
value|__attribute__ ((__packed__))
define|#
directive|define
name|Q_NO_PACKED_REFERENCE
ifndef|#
directive|ifndef
name|__ARM_EABI__
define|#
directive|define
name|QT_NO_ARM_EABI
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__GXX_EXPERIMENTAL_CXX0X__
argument_list|)
if|#
directive|if
operator|(
name|__GNUC__
operator|*
literal|100
operator|+
name|__GNUC_MINOR__
operator|)
operator|>=
literal|403
comment|/* C++0x features supported in GCC 4.3: */
define|#
directive|define
name|Q_COMPILER_RVALUE_REFS
define|#
directive|define
name|Q_COMPILER_DECLTYPE
endif|#
directive|endif
if|#
directive|if
operator|(
name|__GNUC__
operator|*
literal|100
operator|+
name|__GNUC_MINOR__
operator|)
operator|>=
literal|404
comment|/* C++0x features supported in GCC 4.4: */
define|#
directive|define
name|Q_COMPILER_UNICODE_STRINGS
define|#
directive|define
name|Q_COMPILER_VARIADIC_TEMPLATES
define|#
directive|define
name|Q_COMPILER_AUTO_TYPE
define|#
directive|define
name|Q_COMPILER_EXTERN_TEMPLATES
define|#
directive|define
name|Q_COMPILER_DEFAULT_DELETE_MEMBERS
define|#
directive|define
name|Q_COMPILER_CLASS_ENUM
define|#
directive|define
name|Q_COMPILER_INITIALIZER_LISTS
endif|#
directive|endif
if|#
directive|if
operator|(
name|__GNUC__
operator|*
literal|100
operator|+
name|__GNUC_MINOR__
operator|)
operator|>=
literal|405
comment|/* C++0x features supported in GCC 4.5: */
define|#
directive|define
name|Q_COMPILER_LAMBDA
endif|#
directive|endif
if|#
directive|if
operator|(
name|__GNUC__
operator|*
literal|100
operator|+
name|__GNUC_MINOR__
operator|)
operator|>=
literal|406
comment|/* C++0x features supported in GCC 4.6: */
define|#
directive|define
name|Q_COMPILER_CONSTEXPR
endif|#
directive|endif
endif|#
directive|endif
comment|/* IBM compiler versions are a bit messy. There are actually two products:    the C product, and the C++ product. The C++ compiler is always packaged    with the latest version of the C compiler. Version numbers do not always    match. This little table (I'm not sure it's accurate) should be helpful:     C++ product                C product     C Set 3.1                  C Compiler 3.0    ...                        ...    C++ Compiler 3.6.6         C Compiler 4.3    ...                        ...    Visual Age C++ 4.0         ...    ...                        ...    Visual Age C++ 5.0         C Compiler 5.0    ...                        ...    Visual Age C++ 6.0         C Compiler 6.0     Now:    __xlC__    is the version of the C compiler in hexadecimal notation               is only an approximation of the C++ compiler version    __IBMCPP__ is the version of the C++ compiler in decimal notation               but it is not defined on older compilers like C Set 3.1 */
elif|#
directive|elif
name|defined
argument_list|(
name|__xlC__
argument_list|)
define|#
directive|define
name|Q_CC_XLC
define|#
directive|define
name|Q_FULL_TEMPLATE_INSTANTIATION
if|#
directive|if
name|__xlC__
operator|<
literal|0x400
define|#
directive|define
name|Q_NO_BOOL_TYPE
define|#
directive|define
name|Q_NO_EXPLICIT_KEYWORD
define|#
directive|define
name|Q_NO_USING_KEYWORD
define|#
directive|define
name|Q_TYPENAME
define|#
directive|define
name|Q_OUTOFLINE_TEMPLATE
value|inline
define|#
directive|define
name|Q_BROKEN_TEMPLATE_SPECIALIZATION
define|#
directive|define
name|Q_CANNOT_DELETE_CONSTANT
elif|#
directive|elif
name|__xlC__
operator|>=
literal|0x0600
define|#
directive|define
name|Q_ALIGNOF
parameter_list|(
name|type
parameter_list|)
value|__alignof__(type)
define|#
directive|define
name|Q_TYPEOF
parameter_list|(
name|expr
parameter_list|)
value|__typeof__(expr)
define|#
directive|define
name|Q_DECL_ALIGN
parameter_list|(
name|n
parameter_list|)
value|__attribute__((__aligned__(n)))
define|#
directive|define
name|Q_PACKED
value|__attribute__((__packed__))
endif|#
directive|endif
comment|/* Older versions of DEC C++ do not define __EDG__ or __EDG - observed    on DEC C++ V5.5-004. New versions do define  __EDG__ - observed on    Compaq C++ V6.3-002.    This compiler is different enough from other EDG compilers to handle    it separately anyway. */
elif|#
directive|elif
name|defined
argument_list|(
name|__DECCXX
argument_list|)
operator|||
name|defined
argument_list|(
name|__DECC
argument_list|)
define|#
directive|define
name|Q_CC_DEC
comment|/* Compaq C++ V6 compilers are EDG-based but I'm not sure about older    DEC C++ V5 compilers. */
if|#
directive|if
name|defined
argument_list|(
name|__EDG__
argument_list|)
define|#
directive|define
name|Q_CC_EDG
endif|#
directive|endif
comment|/* Compaq have disabled EDG's _BOOL macro and use _BOOL_EXISTS instead    - observed on Compaq C++ V6.3-002.    In any case versions prior to Compaq C++ V6.0-005 do not have bool. */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_BOOL_EXISTS
argument_list|)
define|#
directive|define
name|Q_NO_BOOL_TYPE
endif|#
directive|endif
comment|/* Spurious (?) error messages observed on Compaq C++ V6.5-014. */
define|#
directive|define
name|Q_NO_USING_KEYWORD
comment|/* Apply to all versions prior to Compaq C++ V6.0-000 - observed on    DEC C++ V5.5-004. */
if|#
directive|if
name|__DECCXX_VER
operator|<
literal|60060000
define|#
directive|define
name|Q_TYPENAME
define|#
directive|define
name|Q_BROKEN_TEMPLATE_SPECIALIZATION
define|#
directive|define
name|Q_CANNOT_DELETE_CONSTANT
endif|#
directive|endif
comment|/* avoid undefined symbol problems with out-of-line template members */
define|#
directive|define
name|Q_OUTOFLINE_TEMPLATE
value|inline
comment|/* The Portland Group C++ compiler is based on EDG and does define __EDG__    but the C compiler does not */
elif|#
directive|elif
name|defined
argument_list|(
name|__PGI
argument_list|)
define|#
directive|define
name|Q_CC_PGI
if|#
directive|if
name|defined
argument_list|(
name|__EDG__
argument_list|)
define|#
directive|define
name|Q_CC_EDG
endif|#
directive|endif
comment|/* Compilers with EDG front end are similar. To detect them we test:    __EDG documented by SGI, observed on MIPSpro 7.3.1.1 and KAI C++ 4.0b    __EDG__ documented in EDG online docs, observed on Compaq C++ V6.3-002    and PGI C++ 5.2-4 */
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__EDG
argument_list|)
operator|||
name|defined
argument_list|(
name|__EDG__
argument_list|)
operator|)
define|#
directive|define
name|Q_CC_EDG
comment|/* From the EDG documentation (does not seem to apply to Compaq C++):    _BOOL         Defined in C++ mode when bool is a keyword. The name of this         predefined macro is specified by a configuration flag. _BOOL         is the default.    __BOOL_DEFINED         Defined in Microsoft C++ mode when bool is a keyword. */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_BOOL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__BOOL_DEFINED
argument_list|)
define|#
directive|define
name|Q_NO_BOOL_TYPE
endif|#
directive|endif
comment|/* The Comeau compiler is based on EDG and does define __EDG__ */
if|#
directive|if
name|defined
argument_list|(
name|__COMO__
argument_list|)
define|#
directive|define
name|Q_CC_COMEAU
define|#
directive|define
name|Q_C_CALLBACKS
comment|/* The `using' keyword was introduced to avoid KAI C++ warnings    but it's now causing KAI C++ errors instead. The standard is    unclear about the use of this keyword, and in practice every    compiler is using its own set of rules. Forget it. */
elif|#
directive|elif
name|defined
argument_list|(
name|__KCC
argument_list|)
define|#
directive|define
name|Q_CC_KAI
define|#
directive|define
name|Q_NO_USING_KEYWORD
comment|/* Using the `using' keyword avoids Intel C++ for Linux warnings */
elif|#
directive|elif
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
define|#
directive|define
name|Q_CC_INTEL
comment|/* Uses CFront, make sure to read the manual how to tweak templates. */
elif|#
directive|elif
name|defined
argument_list|(
name|__ghs
argument_list|)
define|#
directive|define
name|Q_CC_GHS
elif|#
directive|elif
name|defined
argument_list|(
name|__DCC__
argument_list|)
define|#
directive|define
name|Q_CC_DIAB
undef|#
directive|undef
name|Q_NO_BOOL_TYPE
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__bool
argument_list|)
define|#
directive|define
name|Q_NO_BOOL_TYPE
endif|#
directive|endif
comment|/* The UnixWare 7 UDK compiler is based on EDG and does define __EDG__ */
elif|#
directive|elif
name|defined
argument_list|(
name|__USLC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__SCO_VERSION__
argument_list|)
define|#
directive|define
name|Q_CC_USLC
comment|/* The latest UDK 7.1.1b does not need this, but previous versions do */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__SCO_VERSION__
argument_list|)
operator|||
operator|(
name|__SCO_VERSION__
operator|<
literal|302200010
operator|)
define|#
directive|define
name|Q_OUTOFLINE_TEMPLATE
value|inline
endif|#
directive|endif
define|#
directive|define
name|Q_NO_USING_KEYWORD
comment|/* ### check "using" status */
comment|/* Never tested! */
elif|#
directive|elif
name|defined
argument_list|(
name|CENTERLINE_CLPP
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJECTCENTER
argument_list|)
define|#
directive|define
name|Q_CC_OC
define|#
directive|define
name|Q_NO_USING_KEYWORD
comment|/* CDS++ defines __EDG__ although this is not documented in the Reliant    documentation. It also follows conventions like _BOOL and this documented */
elif|#
directive|elif
name|defined
argument_list|(
name|sinix
argument_list|)
define|#
directive|define
name|Q_CC_CDS
define|#
directive|define
name|Q_NO_USING_KEYWORD
comment|/* The MIPSpro compiler defines __EDG */
elif|#
directive|elif
name|defined
argument_list|(
name|__sgi
argument_list|)
define|#
directive|define
name|Q_CC_MIPS
define|#
directive|define
name|Q_NO_USING_KEYWORD
comment|/* ### check "using" status */
define|#
directive|define
name|Q_NO_TEMPLATE_FRIENDS
if|#
directive|if
name|defined
argument_list|(
name|_COMPILER_VERSION
argument_list|)
operator|&&
operator|(
name|_COMPILER_VERSION
operator|>=
literal|740
operator|)
define|#
directive|define
name|Q_OUTOFLINE_TEMPLATE
value|inline
pragma|#
directive|pragma
name|set
name|woff
name|3624
name|,
name|3625
name|,
name|3649
comment|/* turn off some harmless warnings */
endif|#
directive|endif
endif|#
directive|endif
comment|/* VxWorks' DIAB toolchain has an additional EDG type C++ compiler    (see __DCC__ above). This one is for C mode files (__EDG is not defined) */
elif|#
directive|elif
name|defined
argument_list|(
name|_DIAB_TOOL
argument_list|)
define|#
directive|define
name|Q_CC_DIAB
comment|/* Never tested! */
elif|#
directive|elif
name|defined
argument_list|(
name|__HIGHC__
argument_list|)
define|#
directive|define
name|Q_CC_HIGHC
elif|#
directive|elif
name|defined
argument_list|(
name|__SUNPRO_CC
argument_list|)
operator|||
name|defined
argument_list|(
name|__SUNPRO_C
argument_list|)
define|#
directive|define
name|Q_CC_SUN
comment|/* 5.0 compiler or better     'bool' is enabled by default but can be disabled using -features=nobool     in which case _BOOL is not defined         this is the default in 4.2 compatibility mode triggered by -compat=4 */
if|#
directive|if
name|__SUNPRO_CC
operator|>=
literal|0x500
define|#
directive|define
name|QT_NO_TEMPLATE_TEMPLATE_PARAMETERS
comment|/* see http://developers.sun.com/sunstudio/support/Ccompare.html */
if|#
directive|if
name|__SUNPRO_CC
operator|>=
literal|0x590
define|#
directive|define
name|Q_ALIGNOF
parameter_list|(
name|type
parameter_list|)
value|__alignof__(type)
define|#
directive|define
name|Q_TYPEOF
parameter_list|(
name|expr
parameter_list|)
value|__typeof__(expr)
define|#
directive|define
name|Q_DECL_ALIGN
parameter_list|(
name|n
parameter_list|)
value|__attribute__((__aligned__(n)))
endif|#
directive|endif
if|#
directive|if
name|__SUNPRO_CC
operator|>=
literal|0x550
define|#
directive|define
name|Q_DECL_EXPORT
value|__global
endif|#
directive|endif
if|#
directive|if
name|__SUNPRO_CC
operator|<
literal|0x5a0
define|#
directive|define
name|Q_NO_TEMPLATE_FRIENDS
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_BOOL
argument_list|)
define|#
directive|define
name|Q_NO_BOOL_TYPE
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__SUNPRO_CC_COMPAT
argument_list|)
operator|&&
operator|(
name|__SUNPRO_CC_COMPAT
operator|<=
literal|4
operator|)
define|#
directive|define
name|Q_NO_USING_KEYWORD
endif|#
directive|endif
define|#
directive|define
name|Q_C_CALLBACKS
comment|/* 4.2 compiler or older */
else|#
directive|else
define|#
directive|define
name|Q_NO_BOOL_TYPE
define|#
directive|define
name|Q_NO_EXPLICIT_KEYWORD
define|#
directive|define
name|Q_NO_USING_KEYWORD
endif|#
directive|endif
comment|/* CDS++ does not seem to define __EDG__ or __EDG according to Reliant    documentation but nevertheless uses EDG conventions like _BOOL */
elif|#
directive|elif
name|defined
argument_list|(
name|sinix
argument_list|)
define|#
directive|define
name|Q_CC_EDG
define|#
directive|define
name|Q_CC_CDS
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_BOOL
argument_list|)
define|#
directive|define
name|Q_NO_BOOL_TYPE
endif|#
directive|endif
define|#
directive|define
name|Q_BROKEN_TEMPLATE_SPECIALIZATION
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
comment|/* __HP_aCC was not defined in first aCC releases */
if|#
directive|if
name|defined
argument_list|(
name|__HP_aCC
argument_list|)
operator|||
name|__cplusplus
operator|>=
literal|199707L
define|#
directive|define
name|Q_NO_TEMPLATE_FRIENDS
define|#
directive|define
name|Q_CC_HPACC
if|#
directive|if
name|__HP_aCC
operator|-
literal|0
operator|<
literal|060000
define|#
directive|define
name|QT_NO_TEMPLATE_TEMPLATE_PARAMETERS
define|#
directive|define
name|Q_DECL_EXPORT
value|__declspec(dllexport)
define|#
directive|define
name|Q_DECL_IMPORT
value|__declspec(dllimport)
endif|#
directive|endif
if|#
directive|if
name|__HP_aCC
operator|-
literal|0
operator|>=
literal|061200
define|#
directive|define
name|Q_DECL_ALIGN
parameter_list|(
name|n
parameter_list|)
value|__attribute__((aligned(n)))
endif|#
directive|endif
if|#
directive|if
name|__HP_aCC
operator|-
literal|0
operator|>=
literal|062000
define|#
directive|define
name|Q_DECL_EXPORT
value|__attribute__((visibility("default")))
define|#
directive|define
name|Q_DECL_HIDDEN
value|__attribute__((visibility("hidden")))
define|#
directive|define
name|Q_DECL_IMPORT
value|Q_DECL_EXPORT
endif|#
directive|endif
else|#
directive|else
define|#
directive|define
name|Q_CC_HP
define|#
directive|define
name|Q_NO_BOOL_TYPE
define|#
directive|define
name|Q_FULL_TEMPLATE_INSTANTIATION
define|#
directive|define
name|Q_BROKEN_TEMPLATE_SPECIALIZATION
define|#
directive|define
name|Q_NO_EXPLICIT_KEYWORD
endif|#
directive|endif
define|#
directive|define
name|Q_NO_USING_KEYWORD
comment|/* ### check "using" status */
elif|#
directive|elif
name|defined
argument_list|(
name|__WINSCW__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_NOKIAX86
argument_list|)
define|#
directive|define
name|Q_CC_NOKIAX86
else|#
directive|else
error|#
directive|error
literal|"Qt has not been tested with this compiler - talk to qt-bugs@trolltech.com"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_CC_INTEL
if|#
directive|if
name|__INTEL_COMPILER
operator|<
literal|1200
DECL|macro|Q_NO_TEMPLATE_FRIENDS
define|#
directive|define
name|Q_NO_TEMPLATE_FRIENDS
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__GXX_EXPERIMENTAL_CXX0X__
argument_list|)
operator|||
name|defined
argument_list|(
name|__GXX_EXPERIMENTAL_CPP0X__
argument_list|)
if|#
directive|if
name|__INTEL_COMPILER
operator|>=
literal|1100
DECL|macro|Q_COMPILER_RVALUE_REFS
define|#
directive|define
name|Q_COMPILER_RVALUE_REFS
DECL|macro|Q_COMPILER_EXTERN_TEMPLATES
define|#
directive|define
name|Q_COMPILER_EXTERN_TEMPLATES
DECL|macro|Q_COMPILER_DECLTYPE
define|#
directive|define
name|Q_COMPILER_DECLTYPE
elif|#
directive|elif
name|__INTEL_COMPILER
operator|>=
literal|1200
define|#
directive|define
name|Q_COMPILER_VARIADIC_TEMPLATES
define|#
directive|define
name|Q_COMPILER_AUTO_TYPE
define|#
directive|define
name|Q_COMPILER_DEFAULT_DELETE_MEMBERS
define|#
directive|define
name|Q_COMPILER_CLASS_ENUM
define|#
directive|define
name|Q_COMPILER_LAMBDA
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_PACKED
DECL|macro|Q_PACKED
define|#
directive|define
name|Q_PACKED
DECL|macro|Q_NO_PACKED_REFERENCE
undef|#
directive|undef
name|Q_NO_PACKED_REFERENCE
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_LIKELY
DECL|macro|Q_LIKELY
define|#
directive|define
name|Q_LIKELY
parameter_list|(
name|x
parameter_list|)
value|(x)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_UNLIKELY
DECL|macro|Q_UNLIKELY
define|#
directive|define
name|Q_UNLIKELY
parameter_list|(
name|x
parameter_list|)
value|(x)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_CONSTRUCTOR_FUNCTION
DECL|macro|Q_CONSTRUCTOR_FUNCTION0
define|#
directive|define
name|Q_CONSTRUCTOR_FUNCTION0
parameter_list|(
name|AFUNC
parameter_list|)
define|\
value|static const int AFUNC ## __init_variable__ = AFUNC();
DECL|macro|Q_CONSTRUCTOR_FUNCTION
define|#
directive|define
name|Q_CONSTRUCTOR_FUNCTION
parameter_list|(
name|AFUNC
parameter_list|)
value|Q_CONSTRUCTOR_FUNCTION0(AFUNC)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_DESTRUCTOR_FUNCTION
DECL|macro|Q_DESTRUCTOR_FUNCTION0
define|#
directive|define
name|Q_DESTRUCTOR_FUNCTION0
parameter_list|(
name|AFUNC
parameter_list|)
define|\
value|class AFUNC ## __dest_class__ { \     public: \        inline AFUNC ## __dest_class__() { } \        inline ~ AFUNC ## __dest_class__() { AFUNC(); } \     } AFUNC ## __dest_instance__;
DECL|macro|Q_DESTRUCTOR_FUNCTION
define|#
directive|define
name|Q_DESTRUCTOR_FUNCTION
parameter_list|(
name|AFUNC
parameter_list|)
value|Q_DESTRUCTOR_FUNCTION0(AFUNC)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_REQUIRED_RESULT
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>
literal|4
operator|||
operator|(
name|__GNUC__
operator|==
literal|4
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|1
operator|)
operator|)
DECL|macro|Q_REQUIRED_RESULT
define|#
directive|define
name|Q_REQUIRED_RESULT
value|__attribute__ ((warn_unused_result))
else|#
directive|else
define|#
directive|define
name|Q_REQUIRED_RESULT
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_COMPILER_MANGLES_RETURN_TYPE
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
DECL|macro|Q_COMPILER_MANGLES_RETURN_TYPE
define|#
directive|define
name|Q_COMPILER_MANGLES_RETURN_TYPE
endif|#
directive|endif
endif|#
directive|endif
comment|/*    The window system, must be one of: (Q_WS_x)       MACX     - Mac OS X      MAC9     - Mac OS 9      QWS      - Qt for Embedded Linux      WIN32    - Windows      X11      - X Window System      S60      - Symbian S60      PM       - unsupported      WIN16    - unsupported */
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MSDOS
argument_list|)
DECL|macro|Q_WS_WIN16
define|#
directive|define
name|Q_WS_WIN16
error|#
directive|error
literal|"Qt requires Win32 and does not work with Windows 3.x"
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32_X11_
argument_list|)
define|#
directive|define
name|Q_WS_X11
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
define|#
directive|define
name|Q_WS_WIN32
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN64
argument_list|)
define|#
directive|define
name|Q_WS_WIN64
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
define|#
directive|define
name|Q_WS_WIN32
define|#
directive|define
name|Q_WS_WINCE
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE_WM
argument_list|)
define|#
directive|define
name|Q_WS_WINCE_WM
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_OS2
argument_list|)
define|#
directive|define
name|Q_WS_PM
error|#
directive|error
literal|"Qt does not work with OS/2 Presentation Manager or Workplace Shell"
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__USE_WS_X11__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
define|#
directive|define
name|Q_WS_MAC
define|#
directive|define
name|Q_WS_MACX
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC64
argument_list|)
define|#
directive|define
name|Q_WS_MAC64
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_MAC32
argument_list|)
define|#
directive|define
name|Q_WS_MAC32
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_S60
argument_list|)
define|#
directive|define
name|Q_WS_S60
endif|#
directive|endif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
define|#
directive|define
name|Q_WS_X11
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN16
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_WS_WINCE
argument_list|)
DECL|macro|Q_WS_WIN
define|#
directive|define
name|Q_WS_WIN
endif|#
directive|endif
name|QT_BEGIN_HEADER
name|QT_BEGIN_NAMESPACE
end_expr_stmt
begin_comment
comment|/*    Size-dependent types (architechture-dependent byte order)     Make sure to update QMetaType when changing these typedefs */
end_comment
begin_typedef
DECL|typedef|qint8
typedef|typedef
name|signed
name|char
name|qint8
typedef|;
end_typedef
begin_comment
DECL|typedef|qint8
comment|/* 8 bit signed */
end_comment
begin_typedef
DECL|typedef|quint8
typedef|typedef
name|unsigned
name|char
name|quint8
typedef|;
end_typedef
begin_comment
DECL|typedef|quint8
comment|/* 8 bit unsigned */
end_comment
begin_typedef
DECL|typedef|qint16
typedef|typedef
name|short
name|qint16
typedef|;
end_typedef
begin_comment
DECL|typedef|qint16
comment|/* 16 bit signed */
end_comment
begin_typedef
DECL|typedef|quint16
typedef|typedef
name|unsigned
name|short
name|quint16
typedef|;
end_typedef
begin_comment
DECL|typedef|quint16
comment|/* 16 bit unsigned */
end_comment
begin_typedef
DECL|typedef|qint32
typedef|typedef
name|int
name|qint32
typedef|;
end_typedef
begin_comment
DECL|typedef|qint32
comment|/* 32 bit signed */
end_comment
begin_typedef
DECL|typedef|quint32
typedef|typedef
name|unsigned
name|int
name|quint32
typedef|;
end_typedef
begin_comment
DECL|typedef|quint32
comment|/* 32 bit unsigned */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_MWERKS
argument_list|)
end_if
begin_define
DECL|macro|Q_INT64_C
define|#
directive|define
name|Q_INT64_C
parameter_list|(
name|c
parameter_list|)
value|c ## i64
end_define
begin_comment
DECL|macro|Q_INT64_C
comment|/* signed 64 bit constant */
end_comment
begin_define
DECL|macro|Q_UINT64_C
define|#
directive|define
name|Q_UINT64_C
parameter_list|(
name|c
parameter_list|)
value|c ## ui64
end_define
begin_comment
DECL|macro|Q_UINT64_C
comment|/* unsigned 64 bit constant */
end_comment
begin_typedef
DECL|typedef|qint64
typedef|typedef
name|__int64
name|qint64
typedef|;
end_typedef
begin_comment
DECL|typedef|qint64
comment|/* 64 bit signed */
end_comment
begin_typedef
DECL|typedef|quint64
typedef|typedef
name|unsigned
name|__int64
name|quint64
typedef|;
end_typedef
begin_comment
DECL|typedef|quint64
comment|/* 64 bit unsigned */
end_comment
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_INT64_C
define|#
directive|define
name|Q_INT64_C
parameter_list|(
name|c
parameter_list|)
value|static_cast<long long>(c ## LL)
end_define
begin_comment
DECL|macro|Q_INT64_C
comment|/* signed 64 bit constant */
end_comment
begin_define
DECL|macro|Q_UINT64_C
define|#
directive|define
name|Q_UINT64_C
parameter_list|(
name|c
parameter_list|)
value|static_cast<unsigned long long>(c ## ULL)
end_define
begin_comment
DECL|macro|Q_UINT64_C
comment|/* unsigned 64 bit constant */
end_comment
begin_typedef
DECL|typedef|qint64
typedef|typedef
name|long
name|long
name|qint64
typedef|;
end_typedef
begin_comment
DECL|typedef|qint64
comment|/* 64 bit signed */
end_comment
begin_typedef
DECL|typedef|quint64
typedef|typedef
name|unsigned
name|long
name|long
name|quint64
typedef|;
end_typedef
begin_comment
DECL|typedef|quint64
comment|/* 64 bit unsigned */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|qlonglong
typedef|typedef
name|qint64
name|qlonglong
typedef|;
end_typedef
begin_typedef
DECL|typedef|qulonglong
typedef|typedef
name|quint64
name|qulonglong
typedef|;
end_typedef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_POINTER_SIZE
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN64
argument_list|)
end_if
begin_define
DECL|macro|QT_POINTER_SIZE
define|#
directive|define
name|QT_POINTER_SIZE
value|8
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
end_elif
begin_define
DECL|macro|QT_POINTER_SIZE
define|#
directive|define
name|QT_POINTER_SIZE
value|4
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Q_INIT_RESOURCE_EXTERN
define|#
directive|define
name|Q_INIT_RESOURCE_EXTERN
parameter_list|(
name|name
parameter_list|)
define|\
value|extern int QT_MANGLE_NAMESPACE(qInitResources_ ## name) ();
end_define
begin_define
DECL|macro|Q_INIT_RESOURCE
define|#
directive|define
name|Q_INIT_RESOURCE
parameter_list|(
name|name
parameter_list|)
define|\
value|do { extern int QT_MANGLE_NAMESPACE(qInitResources_ ## name) ();       \         QT_MANGLE_NAMESPACE(qInitResources_ ## name) (); } while (0)
end_define
begin_define
DECL|macro|Q_CLEANUP_RESOURCE
define|#
directive|define
name|Q_CLEANUP_RESOURCE
parameter_list|(
name|name
parameter_list|)
define|\
value|do { extern int QT_MANGLE_NAMESPACE(qCleanupResources_ ## name) ();    \         QT_MANGLE_NAMESPACE(qCleanupResources_ ## name) (); } while (0)
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if
begin_comment
comment|/*   quintptr and qptrdiff is guaranteed to be the same size as a pointer, i.e.        sizeof(void *) == sizeof(quintptr)&& sizeof(void *) == sizeof(qptrdiff) */
end_comment
begin_expr_stmt
name|template
operator|<
name|int
operator|>
expr|struct
name|QIntegerForSize
expr_stmt|;
end_expr_stmt
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
name|template
operator|<
operator|>
expr|struct
name|QIntegerForSize
operator|<
literal|1
operator|>
block|{
typedef|typedef
name|quint8
name|Unsigned
typedef|;
end_expr_stmt
begin_typedef
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
typedef|typedef
name|qint8
name|Signed
typedef|;
end_typedef
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
unit|};
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
name|template
operator|<
operator|>
expr|struct
name|QIntegerForSize
operator|<
literal|2
operator|>
block|{
typedef|typedef
name|quint16
name|Unsigned
typedef|;
end_expr_stmt
begin_typedef
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
typedef|typedef
name|qint16
name|Signed
typedef|;
end_typedef
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
unit|};
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
name|template
operator|<
operator|>
expr|struct
name|QIntegerForSize
operator|<
literal|4
operator|>
block|{
typedef|typedef
name|quint32
name|Unsigned
typedef|;
end_expr_stmt
begin_typedef
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
typedef|typedef
name|qint32
name|Signed
typedef|;
end_typedef
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
unit|};
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
name|template
operator|<
operator|>
expr|struct
name|QIntegerForSize
operator|<
literal|8
operator|>
block|{
typedef|typedef
name|quint64
name|Unsigned
typedef|;
end_expr_stmt
begin_typedef
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
typedef|typedef
name|qint64
name|Signed
typedef|;
end_typedef
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
unit|};
DECL|function|sizeof
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|QIntegerForSizeof
operator|:
name|QIntegerForSize
operator|<
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_typedef
DECL|typedef|quintptr
typedef|typedef
name|QIntegerForSizeof
operator|<
name|void
operator|*
operator|>
operator|::
name|Unsigned
name|quintptr
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|qptrdiff
typedef|typedef
name|QIntegerForSizeof
operator|<
name|void
operator|*
operator|>
operator|::
name|Signed
name|qptrdiff
expr_stmt|;
end_typedef
begin_comment
comment|/*    Useful type definitions for Qt */
end_comment
begin_macro
name|QT_BEGIN_INCLUDE_NAMESPACE
end_macro
begin_typedef
DECL|typedef|uchar
typedef|typedef
name|unsigned
name|char
name|uchar
typedef|;
end_typedef
begin_typedef
DECL|typedef|ushort
typedef|typedef
name|unsigned
name|short
name|ushort
typedef|;
end_typedef
begin_typedef
DECL|typedef|uint
typedef|typedef
name|unsigned
name|int
name|uint
typedef|;
end_typedef
begin_typedef
DECL|typedef|ulong
typedef|typedef
name|unsigned
name|long
name|ulong
typedef|;
end_typedef
begin_macro
name|QT_END_INCLUDE_NAMESPACE
end_macro
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_NO_BOOL_TYPE
argument_list|)
end_if
begin_error
error|#
directive|error
literal|"Compiler doesn't support the bool type"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Constant bool values */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_LINUXBASE
end_ifndef
begin_comment
comment|/* the LSB defines TRUE and FALSE for us */
end_comment
begin_comment
comment|/* Symbian OS defines TRUE = 1 and FALSE = 0, redefine to built-in booleans to make autotests work properly */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
end_ifdef
begin_include
include|#
directive|include
file|<e32def.h>
end_include
begin_comment
comment|/* Symbian OS defines */
end_comment
begin_undef
DECL|macro|TRUE
undef|#
directive|undef
name|TRUE
end_undef
begin_undef
DECL|macro|FALSE
undef|#
directive|undef
name|FALSE
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef
begin_define
DECL|macro|TRUE
define|#
directive|define
name|TRUE
value|true
end_define
begin_define
DECL|macro|FALSE
define|#
directive|define
name|FALSE
value|false
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Proper for-scoping in MIPSpro CC */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_KEYWORDS
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MIPS
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|Q_CC_HPACC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__ia64
argument_list|)
operator|)
end_if
begin_define
DECL|macro|for
define|#
directive|define
name|for
value|if(0){}else for
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Workaround for static const members on MSVC++. */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
end_if
begin_define
DECL|macro|QT_STATIC_CONST
define|#
directive|define
name|QT_STATIC_CONST
value|static
end_define
begin_define
DECL|macro|QT_STATIC_CONST_IMPL
define|#
directive|define
name|QT_STATIC_CONST_IMPL
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_STATIC_CONST
value|static const
end_define
begin_define
define|#
directive|define
name|QT_STATIC_CONST_IMPL
value|const
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Warnings and errors when using deprecated methods */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_MOC_RUN
argument_list|)
end_if
begin_define
DECL|macro|Q_DECL_DEPRECATED
define|#
directive|define
name|Q_DECL_DEPRECATED
value|Q_DECL_DEPRECATED
end_define
begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|-
literal|0
operator|>
literal|3
operator|||
operator|(
name|__GNUC__
operator|-
literal|0
operator|==
literal|3
operator|&&
name|__GNUC_MINOR__
operator|-
literal|0
operator|>=
literal|2
operator|)
operator|)
operator|)
operator|||
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_elif
begin_define
define|#
directive|define
name|Q_DECL_DEPRECATED
value|__attribute__ ((__deprecated__))
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
end_elif
begin_define
define|#
directive|define
name|Q_DECL_DEPRECATED
value|__declspec(deprecated)
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
end_if
begin_define
define|#
directive|define
name|Q_DECL_VARIABLE_DEPRECATED
end_define
begin_else
else|#
directive|else
end_else
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|Q_DECL_DEPRECATED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_DECL_VARIABLE_DEPRECATED
end_ifndef
begin_define
DECL|macro|Q_DECL_VARIABLE_DEPRECATED
define|#
directive|define
name|Q_DECL_VARIABLE_DEPRECATED
value|Q_DECL_DEPRECATED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_DECL_CONSTRUCTOR_DEPRECATED
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_MOC_RUN
argument_list|)
end_if
begin_define
DECL|macro|Q_DECL_CONSTRUCTOR_DEPRECATED
define|#
directive|define
name|Q_DECL_CONSTRUCTOR_DEPRECATED
value|Q_DECL_CONSTRUCTOR_DEPRECATED
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_NO_DEPRECATED_CONSTRUCTORS
argument_list|)
end_elif
begin_define
define|#
directive|define
name|Q_DECL_CONSTRUCTOR_DEPRECATED
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|Q_DECL_CONSTRUCTOR_DEPRECATED
value|Q_DECL_DEPRECATED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEPRECATED
argument_list|)
end_if
begin_undef
DECL|macro|QT_DEPRECATED
undef|#
directive|undef
name|QT_DEPRECATED
end_undef
begin_undef
DECL|macro|QT_DEPRECATED_VARIABLE
undef|#
directive|undef
name|QT_DEPRECATED_VARIABLE
end_undef
begin_undef
DECL|macro|QT_DEPRECATED_CONSTRUCTOR
undef|#
directive|undef
name|QT_DEPRECATED_CONSTRUCTOR
end_undef
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_DEPRECATED_WARNINGS
argument_list|)
end_elif
begin_undef
undef|#
directive|undef
name|QT_DEPRECATED
end_undef
begin_define
define|#
directive|define
name|QT_DEPRECATED
value|Q_DECL_DEPRECATED
end_define
begin_undef
undef|#
directive|undef
name|QT_DEPRECATED_VARIABLE
end_undef
begin_define
define|#
directive|define
name|QT_DEPRECATED_VARIABLE
value|Q_DECL_VARIABLE_DEPRECATED
end_define
begin_undef
undef|#
directive|undef
name|QT_DEPRECATED_CONSTRUCTOR
end_undef
begin_define
define|#
directive|define
name|QT_DEPRECATED_CONSTRUCTOR
value|explicit Q_DECL_CONSTRUCTOR_DEPRECATED
end_define
begin_else
else|#
directive|else
end_else
begin_undef
undef|#
directive|undef
name|QT_DEPRECATED
end_undef
begin_define
define|#
directive|define
name|QT_DEPRECATED
end_define
begin_undef
undef|#
directive|undef
name|QT_DEPRECATED_VARIABLE
end_undef
begin_define
define|#
directive|define
name|QT_DEPRECATED_VARIABLE
end_define
begin_undef
undef|#
directive|undef
name|QT_DEPRECATED_CONSTRUCTOR
end_undef
begin_define
define|#
directive|define
name|QT_DEPRECATED_CONSTRUCTOR
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* moc compats (signals/slots) */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_MOC_COMPAT
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT3_SUPPORT
argument_list|)
end_if
begin_define
DECL|macro|QT_MOC_COMPAT
define|#
directive|define
name|QT_MOC_COMPAT
value|QT3_SUPPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_MOC_COMPAT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_undef
undef|#
directive|undef
name|QT_MOC_COMPAT
end_undef
begin_define
define|#
directive|define
name|QT_MOC_COMPAT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_ASCII_CAST_WARNINGS
end_ifdef
begin_define
DECL|macro|QT_ASCII_CAST_WARN
define|#
directive|define
name|QT_ASCII_CAST_WARN
value|Q_DECL_DEPRECATED
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
name|__GNUC__
operator|<
literal|4
end_if
begin_comment
comment|/* gcc< 4 doesn't like Q_DECL_DEPRECATED in front of constructors */
end_comment
begin_define
DECL|macro|QT_ASCII_CAST_WARN_CONSTRUCTOR
define|#
directive|define
name|QT_ASCII_CAST_WARN_CONSTRUCTOR
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_ASCII_CAST_WARN_CONSTRUCTOR
value|Q_DECL_CONSTRUCTOR_DEPRECATED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_ASCII_CAST_WARN
end_define
begin_define
define|#
directive|define
name|QT_ASCII_CAST_WARN_CONSTRUCTOR
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
end_if
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|&&
operator|(
operator|(
literal|100
operator|*
operator|(
name|__GNUC__
operator|-
literal|0
operator|)
operator|+
literal|10
operator|*
operator|(
name|__GNUC_MINOR__
operator|-
literal|0
operator|)
operator|+
name|__GNUC_PATCHLEVEL__
operator|)
operator|>=
literal|332
operator|)
end_if
begin_define
DECL|macro|QT_FASTCALL
define|#
directive|define
name|QT_FASTCALL
value|__attribute__((regparm(3)))
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_FASTCALL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
end_elif
begin_define
define|#
directive|define
name|QT_FASTCALL
value|__fastcall
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_FASTCALL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_FASTCALL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_CONSTEXPR
end_ifdef
begin_define
DECL|macro|Q_DECL_CONSTEXPR
define|#
directive|define
name|Q_DECL_CONSTEXPR
value|constexpr
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|Q_DECL_CONSTEXPR
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//defines the type for the WNDPROC on windows
end_comment
begin_comment
comment|//the alignment needs to be forced for sse2 to not crash with mingw
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
end_if
begin_define
DECL|macro|QT_ENSURE_STACK_ALIGNED_FOR_SSE
define|#
directive|define
name|QT_ENSURE_STACK_ALIGNED_FOR_SSE
value|__attribute__ ((force_align_arg_pointer))
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_ENSURE_STACK_ALIGNED_FOR_SSE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QT_WIN_CALLBACK
define|#
directive|define
name|QT_WIN_CALLBACK
value|CALLBACK QT_ENSURE_STACK_ALIGNED_FOR_SSE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|QNoImplicitBoolCast
typedef|typedef
name|int
name|QNoImplicitBoolCast
typedef|;
end_typedef
begin_comment
comment|// This logic must match the one in qmetatype.h
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_COORD_TYPE
argument_list|)
end_if
begin_typedef
DECL|typedef|qreal
typedef|typedef
name|QT_COORD_TYPE
name|qreal
typedef|;
end_typedef
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_NO_FPU
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_ARCH_ARM
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_ARCH_WINDOWSCE
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_ARCH_SYMBIAN
argument_list|)
end_elif
begin_typedef
DECL|typedef|qreal
typedef|typedef
name|float
name|qreal
typedef|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_typedef
DECL|typedef|qreal
typedef|typedef
name|double
name|qreal
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Utility macros and inline functions */
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qAbs
name|Q_DECL_CONSTEXPR
specifier|inline
name|T
name|qAbs
argument_list|(
argument|const T&t
argument_list|)
block|{
return|return
name|t
operator|>=
literal|0
operator|?
name|t
operator|:
operator|-
name|t
return|;
block|}
end_expr_stmt
begin_function
DECL|function|qRound
name|Q_DECL_CONSTEXPR
specifier|inline
name|int
name|qRound
parameter_list|(
name|qreal
name|d
parameter_list|)
block|{
return|return
name|d
operator|>=
name|qreal
argument_list|(
literal|0.0
argument_list|)
condition|?
name|int
argument_list|(
name|d
operator|+
name|qreal
argument_list|(
literal|0.5
argument_list|)
argument_list|)
else|:
name|int
argument_list|(
name|d
operator|-
name|int
argument_list|(
name|d
operator|-
literal|1
argument_list|)
operator|+
name|qreal
argument_list|(
literal|0.5
argument_list|)
argument_list|)
operator|+
name|int
argument_list|(
name|d
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_FPU
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_ARCH_ARM
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_ARCH_WINDOWSCE
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_ARCH_SYMBIAN
argument_list|)
end_if
begin_function
DECL|function|qRound64
name|Q_DECL_CONSTEXPR
specifier|inline
name|qint64
name|qRound64
parameter_list|(
name|double
name|d
parameter_list|)
block|{
return|return
name|d
operator|>=
literal|0.0
condition|?
name|qint64
argument_list|(
name|d
operator|+
literal|0.5
argument_list|)
else|:
name|qint64
argument_list|(
name|d
operator|-
name|qreal
argument_list|(
name|qint64
argument_list|(
name|d
operator|-
literal|1
argument_list|)
argument_list|)
operator|+
literal|0.5
argument_list|)
operator|+
name|qint64
argument_list|(
name|d
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|qRound64
name|Q_DECL_CONSTEXPR
specifier|inline
name|qint64
name|qRound64
parameter_list|(
name|qreal
name|d
parameter_list|)
block|{
return|return
name|d
operator|>=
name|qreal
argument_list|(
literal|0.0
argument_list|)
condition|?
name|qint64
argument_list|(
name|d
operator|+
name|qreal
argument_list|(
literal|0.5
argument_list|)
argument_list|)
else|:
name|qint64
argument_list|(
name|d
operator|-
name|qreal
argument_list|(
name|qint64
argument_list|(
name|d
operator|-
literal|1
argument_list|)
argument_list|)
operator|+
name|qreal
argument_list|(
literal|0.5
argument_list|)
argument_list|)
operator|+
name|qint64
argument_list|(
name|d
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qMin
name|Q_DECL_CONSTEXPR
specifier|inline
specifier|const
name|T
operator|&
name|qMin
argument_list|(
argument|const T&a
argument_list|,
argument|const T&b
argument_list|)
block|{
return|return
operator|(
name|a
operator|<
name|b
operator|)
operator|?
name|a
operator|:
name|b
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qMax
name|Q_DECL_CONSTEXPR
specifier|inline
specifier|const
name|T
operator|&
name|qMax
argument_list|(
argument|const T&a
argument_list|,
argument|const T&b
argument_list|)
block|{
return|return
operator|(
name|a
operator|<
name|b
operator|)
operator|?
name|b
operator|:
name|a
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qBound
name|Q_DECL_CONSTEXPR
specifier|inline
specifier|const
name|T
operator|&
name|qBound
argument_list|(
argument|const T&min
argument_list|,
argument|const T&val
argument_list|,
argument|const T&max
argument_list|)
block|{
return|return
name|qMax
argument_list|(
name|min
argument_list|,
name|qMin
argument_list|(
name|max
argument_list|,
name|val
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_comment
comment|/*    Data stream functions are provided by many classes (defined in qdatastream.h) */
end_comment
begin_decl_stmt
DECL|variable|QDataStream
name|class
name|QDataStream
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BUILD_KEY
end_ifndef
begin_define
DECL|macro|QT_BUILD_KEY
define|#
directive|define
name|QT_BUILD_KEY
value|"unspecified"
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|QMAC_QMENUBAR_NO_EVENT
end_ifndef
begin_define
DECL|macro|QMAC_QMENUBAR_NO_EVENT
define|#
directive|define
name|QMAC_QMENUBAR_NO_EVENT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_WS_QWS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_COP
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_COP
define|#
directive|define
name|QT_NO_COP
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_CRASHHANDLER
define|#
directive|define
name|QT_NO_CRASHHANDLER
end_define
begin_comment
DECL|macro|QT_NO_CRASHHANDLER
comment|// no popen
end_comment
begin_define
DECL|macro|QT_NO_PROCESS
define|#
directive|define
name|QT_NO_PROCESS
end_define
begin_comment
DECL|macro|QT_NO_PROCESS
comment|// no exec*, no fork
end_comment
begin_define
DECL|macro|QT_NO_LPR
define|#
directive|define
name|QT_NO_LPR
end_define
begin_define
DECL|macro|QT_NO_SHAREDMEMORY
define|#
directive|define
name|QT_NO_SHAREDMEMORY
end_define
begin_comment
DECL|macro|QT_NO_SHAREDMEMORY
comment|// only POSIX, no SysV and in the end...
end_comment
begin_define
DECL|macro|QT_NO_SYSTEMSEMAPHORE
define|#
directive|define
name|QT_NO_SYSTEMSEMAPHORE
end_define
begin_comment
DECL|macro|QT_NO_SYSTEMSEMAPHORE
comment|// not needed at all in a flat address space
end_comment
begin_define
DECL|macro|QT_NO_QWS_MULTIPROCESS
define|#
directive|define
name|QT_NO_QWS_MULTIPROCESS
end_define
begin_comment
DECL|macro|QT_NO_QWS_MULTIPROCESS
comment|// no processes
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QtCore/qfeatures.h>
end_include
begin_define
DECL|macro|QT_SUPPORTS
define|#
directive|define
name|QT_SUPPORTS
parameter_list|(
name|FEATURE
parameter_list|)
value|(!defined(QT_NO_##FEATURE))
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_if
begin_define
DECL|macro|Q_DECL_EXPORT
define|#
directive|define
name|Q_DECL_EXPORT
value|__attribute__((visibility("default")))
end_define
begin_define
DECL|macro|Q_DECL_IMPORT
define|#
directive|define
name|Q_DECL_IMPORT
value|__attribute__((visibility("default")))
end_define
begin_define
DECL|macro|Q_DECL_HIDDEN
define|#
directive|define
name|Q_DECL_HIDDEN
value|__attribute__((visibility("hidden")))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_DECL_EXPORT
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_NOKIAX86
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_if
begin_define
DECL|macro|Q_DECL_EXPORT
define|#
directive|define
name|Q_DECL_EXPORT
value|__declspec(dllexport)
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_VISIBILITY_AVAILABLE
argument_list|)
end_elif
begin_define
DECL|macro|Q_DECL_EXPORT
define|#
directive|define
name|Q_DECL_EXPORT
value|__attribute__((visibility("default")))
end_define
begin_define
DECL|macro|Q_DECL_HIDDEN
define|#
directive|define
name|Q_DECL_HIDDEN
value|__attribute__((visibility("hidden")))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_DECL_EXPORT
end_ifndef
begin_define
DECL|macro|Q_DECL_EXPORT
define|#
directive|define
name|Q_DECL_EXPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_DECL_IMPORT
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_NOKIAX86
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_if
begin_define
DECL|macro|Q_DECL_IMPORT
define|#
directive|define
name|Q_DECL_IMPORT
value|__declspec(dllimport)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_DECL_IMPORT
define|#
directive|define
name|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_DECL_HIDDEN
end_ifndef
begin_define
DECL|macro|Q_DECL_HIDDEN
define|#
directive|define
name|Q_DECL_HIDDEN
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Create Qt DLL if QT_DLL is defined (Windows and Symbian only) */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NODLL
argument_list|)
end_if
begin_undef
DECL|macro|QT_MAKEDLL
undef|#
directive|undef
name|QT_MAKEDLL
end_undef
begin_undef
DECL|macro|QT_DLL
undef|#
directive|undef
name|QT_DLL
end_undef
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_MAKEDLL
argument_list|)
end_elif
begin_comment
comment|/* create a Qt DLL library */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_DLL
argument_list|)
end_if
begin_undef
DECL|macro|QT_DLL
undef|#
directive|undef
name|QT_DLL
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_CORE_EXPORT
define|#
directive|define
name|Q_CORE_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CORE_EXPORT
define|#
directive|define
name|Q_CORE_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_GUI_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_GUI_EXPORT
define|#
directive|define
name|Q_GUI_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_GUI_EXPORT
define|#
directive|define
name|Q_GUI_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_SQL_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_SQL_EXPORT
define|#
directive|define
name|Q_SQL_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_SQL_EXPORT
define|#
directive|define
name|Q_SQL_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_NETWORK_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_NETWORK_EXPORT
define|#
directive|define
name|Q_NETWORK_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_NETWORK_EXPORT
define|#
directive|define
name|Q_NETWORK_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_SVG_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_SVG_EXPORT
define|#
directive|define
name|Q_SVG_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_SVG_EXPORT
define|#
directive|define
name|Q_SVG_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_DECLARATIVE_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_DECLARATIVE_EXPORT
define|#
directive|define
name|Q_DECLARATIVE_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_DECLARATIVE_EXPORT
define|#
directive|define
name|Q_DECLARATIVE_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_OPENGL_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_OPENGL_EXPORT
define|#
directive|define
name|Q_OPENGL_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_OPENGL_EXPORT
define|#
directive|define
name|Q_OPENGL_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_MULTIMEDIA_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_MULTIMEDIA_EXPORT
define|#
directive|define
name|Q_MULTIMEDIA_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_MULTIMEDIA_EXPORT
define|#
directive|define
name|Q_MULTIMEDIA_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_OPENVG_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_OPENVG_EXPORT
define|#
directive|define
name|Q_OPENVG_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_OPENVG_EXPORT
define|#
directive|define
name|Q_OPENVG_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_XML_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_XML_EXPORT
define|#
directive|define
name|Q_XML_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_XML_EXPORT
define|#
directive|define
name|Q_XML_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_XMLPATTERNS_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_XMLPATTERNS_EXPORT
define|#
directive|define
name|Q_XMLPATTERNS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_XMLPATTERNS_EXPORT
define|#
directive|define
name|Q_XMLPATTERNS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_SCRIPT_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_SCRIPT_EXPORT
define|#
directive|define
name|Q_SCRIPT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_SCRIPT_EXPORT
define|#
directive|define
name|Q_SCRIPT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_SCRIPTTOOLS_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_SCRIPTTOOLS_EXPORT
define|#
directive|define
name|Q_SCRIPTTOOLS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_SCRIPTTOOLS_EXPORT
define|#
directive|define
name|Q_SCRIPTTOOLS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_CANVAS_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_CANVAS_EXPORT
define|#
directive|define
name|Q_CANVAS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CANVAS_EXPORT
define|#
directive|define
name|Q_CANVAS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_COMPAT_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_COMPAT_EXPORT
define|#
directive|define
name|Q_COMPAT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_COMPAT_EXPORT
define|#
directive|define
name|Q_COMPAT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_DBUS_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_DBUS_EXPORT
define|#
directive|define
name|Q_DBUS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_DBUS_EXPORT
define|#
directive|define
name|Q_DBUS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_LOCATION_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_LOCATION_EXPORT
define|#
directive|define
name|Q_LOCATION_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_LOCATION_EXPORT
define|#
directive|define
name|Q_LOCATION_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_SENSORS_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_SENSORS_EXPORT
define|#
directive|define
name|Q_SENSORS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_SENSORS_EXPORT
define|#
directive|define
name|Q_SENSORS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Q_TEMPLATEDLL
define|#
directive|define
name|Q_TEMPLATEDLL
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_DLL
argument_list|)
end_elif
begin_comment
comment|/* use a Qt DLL library */
end_comment
begin_define
DECL|macro|Q_CORE_EXPORT
define|#
directive|define
name|Q_CORE_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_GUI_EXPORT
define|#
directive|define
name|Q_GUI_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_SQL_EXPORT
define|#
directive|define
name|Q_SQL_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_NETWORK_EXPORT
define|#
directive|define
name|Q_NETWORK_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_SVG_EXPORT
define|#
directive|define
name|Q_SVG_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_DECLARATIVE_EXPORT
define|#
directive|define
name|Q_DECLARATIVE_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_CANVAS_EXPORT
define|#
directive|define
name|Q_CANVAS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_OPENGL_EXPORT
define|#
directive|define
name|Q_OPENGL_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_MULTIMEDIA_EXPORT
define|#
directive|define
name|Q_MULTIMEDIA_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_OPENVG_EXPORT
define|#
directive|define
name|Q_OPENVG_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_XML_EXPORT
define|#
directive|define
name|Q_XML_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_XMLPATTERNS_EXPORT
define|#
directive|define
name|Q_XMLPATTERNS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_SCRIPT_EXPORT
define|#
directive|define
name|Q_SCRIPT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_SCRIPTTOOLS_EXPORT
define|#
directive|define
name|Q_SCRIPTTOOLS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_COMPAT_EXPORT
define|#
directive|define
name|Q_COMPAT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_DBUS_EXPORT
define|#
directive|define
name|Q_DBUS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_LOCATION_EXPORT
define|#
directive|define
name|Q_LOCATION_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_SENSORS_EXPORT
define|#
directive|define
name|Q_SENSORS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_TEMPLATEDLL
define|#
directive|define
name|Q_TEMPLATEDLL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Q_NO_DECLARED_NOT_DEFINED
define|#
directive|define
name|Q_NO_DECLARED_NOT_DEFINED
end_define
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_BOR
argument_list|)
end_if
begin_define
DECL|macro|Q_TEMPLATEDLL
define|#
directive|define
name|Q_TEMPLATEDLL
end_define
begin_define
DECL|macro|Q_NO_DECLARED_NOT_DEFINED
define|#
directive|define
name|Q_NO_DECLARED_NOT_DEFINED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|QT_MAKEDLL
undef|#
directive|undef
name|QT_MAKEDLL
end_undef
begin_comment
DECL|macro|QT_MAKEDLL
comment|/* ignore these for other platforms */
end_comment
begin_undef
DECL|macro|QT_DLL
undef|#
directive|undef
name|QT_DLL
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CORE_EXPORT
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_SHARED
argument_list|)
end_if
begin_define
DECL|macro|Q_CORE_EXPORT
define|#
directive|define
name|Q_CORE_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_GUI_EXPORT
define|#
directive|define
name|Q_GUI_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_SQL_EXPORT
define|#
directive|define
name|Q_SQL_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_NETWORK_EXPORT
define|#
directive|define
name|Q_NETWORK_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_SVG_EXPORT
define|#
directive|define
name|Q_SVG_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_DECLARATIVE_EXPORT
define|#
directive|define
name|Q_DECLARATIVE_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_OPENGL_EXPORT
define|#
directive|define
name|Q_OPENGL_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_MULTIMEDIA_EXPORT
define|#
directive|define
name|Q_MULTIMEDIA_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_OPENVG_EXPORT
define|#
directive|define
name|Q_OPENVG_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_XML_EXPORT
define|#
directive|define
name|Q_XML_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_XMLPATTERNS_EXPORT
define|#
directive|define
name|Q_XMLPATTERNS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_SCRIPT_EXPORT
define|#
directive|define
name|Q_SCRIPT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_SCRIPTTOOLS_EXPORT
define|#
directive|define
name|Q_SCRIPTTOOLS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_COMPAT_EXPORT
define|#
directive|define
name|Q_COMPAT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_DBUS_EXPORT
define|#
directive|define
name|Q_DBUS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_LOCATION_EXPORT
define|#
directive|define
name|Q_LOCATION_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_SENSORS_EXPORT
define|#
directive|define
name|Q_SENSORS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CORE_EXPORT
define|#
directive|define
name|Q_CORE_EXPORT
end_define
begin_define
DECL|macro|Q_GUI_EXPORT
define|#
directive|define
name|Q_GUI_EXPORT
end_define
begin_define
DECL|macro|Q_SQL_EXPORT
define|#
directive|define
name|Q_SQL_EXPORT
end_define
begin_define
DECL|macro|Q_NETWORK_EXPORT
define|#
directive|define
name|Q_NETWORK_EXPORT
end_define
begin_define
DECL|macro|Q_SVG_EXPORT
define|#
directive|define
name|Q_SVG_EXPORT
end_define
begin_define
DECL|macro|Q_DECLARATIVE_EXPORT
define|#
directive|define
name|Q_DECLARATIVE_EXPORT
end_define
begin_define
DECL|macro|Q_OPENGL_EXPORT
define|#
directive|define
name|Q_OPENGL_EXPORT
end_define
begin_define
DECL|macro|Q_MULTIMEDIA_EXPORT
define|#
directive|define
name|Q_MULTIMEDIA_EXPORT
end_define
begin_define
DECL|macro|Q_XML_EXPORT
define|#
directive|define
name|Q_XML_EXPORT
end_define
begin_define
DECL|macro|Q_XMLPATTERNS_EXPORT
define|#
directive|define
name|Q_XMLPATTERNS_EXPORT
end_define
begin_define
DECL|macro|Q_SCRIPT_EXPORT
define|#
directive|define
name|Q_SCRIPT_EXPORT
end_define
begin_define
DECL|macro|Q_SCRIPTTOOLS_EXPORT
define|#
directive|define
name|Q_SCRIPTTOOLS_EXPORT
end_define
begin_define
DECL|macro|Q_COMPAT_EXPORT
define|#
directive|define
name|Q_COMPAT_EXPORT
end_define
begin_define
DECL|macro|Q_DBUS_EXPORT
define|#
directive|define
name|Q_DBUS_EXPORT
end_define
begin_define
DECL|macro|Q_LOCATION_EXPORT
define|#
directive|define
name|Q_LOCATION_EXPORT
end_define
begin_define
DECL|macro|Q_SENSORS_EXPORT
define|#
directive|define
name|Q_SENSORS_EXPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Functions marked as Q_GUI_EXPORT_INLINE were exported and inlined by mistake.
end_comment
begin_comment
comment|// Compilers like MinGW complain that the import attribute is ignored.
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_CORE_EXPORT_INLINE
define|#
directive|define
name|Q_CORE_EXPORT_INLINE
value|Q_CORE_EXPORT inline
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CORE_EXPORT_INLINE
define|#
directive|define
name|Q_CORE_EXPORT_INLINE
value|inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_GUI_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_GUI_EXPORT_INLINE
define|#
directive|define
name|Q_GUI_EXPORT_INLINE
value|Q_GUI_EXPORT inline
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_GUI_EXPORT_INLINE
define|#
directive|define
name|Q_GUI_EXPORT_INLINE
value|inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_COMPAT_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_COMPAT_EXPORT_INLINE
define|#
directive|define
name|Q_COMPAT_EXPORT_INLINE
value|Q_COMPAT_EXPORT inline
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_COMPAT_EXPORT_INLINE
define|#
directive|define
name|Q_COMPAT_EXPORT_INLINE
value|inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_elif
begin_comment
comment|// we force RVCT not to export inlines by passing --visibility_inlines_hidden
end_comment
begin_comment
comment|// so we need to just inline it, rather than exporting and inlining
end_comment
begin_comment
comment|// note: this affects the contents of the DEF files (ie. these functions do not appear)
end_comment
begin_define
DECL|macro|Q_CORE_EXPORT_INLINE
define|#
directive|define
name|Q_CORE_EXPORT_INLINE
value|inline
end_define
begin_define
DECL|macro|Q_GUI_EXPORT_INLINE
define|#
directive|define
name|Q_GUI_EXPORT_INLINE
value|inline
end_define
begin_define
DECL|macro|Q_COMPAT_EXPORT_INLINE
define|#
directive|define
name|Q_COMPAT_EXPORT_INLINE
value|inline
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CORE_EXPORT_INLINE
define|#
directive|define
name|Q_CORE_EXPORT_INLINE
value|Q_CORE_EXPORT inline
end_define
begin_define
DECL|macro|Q_GUI_EXPORT_INLINE
define|#
directive|define
name|Q_GUI_EXPORT_INLINE
value|Q_GUI_EXPORT inline
end_define
begin_define
DECL|macro|Q_COMPAT_EXPORT_INLINE
define|#
directive|define
name|Q_COMPAT_EXPORT_INLINE
value|Q_COMPAT_EXPORT inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    No, this is not an evil backdoor. QT_BUILD_INTERNAL just exports more symbols    for Qt's internal unit tests. If you want slower loading times and more    symbols that can vanish from version to version, feel free to define QT_BUILD_INTERNAL. */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_INTERNAL
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|QT_MAKEDLL
argument_list|)
end_if
begin_define
DECL|macro|Q_AUTOTEST_EXPORT
define|#
directive|define
name|Q_AUTOTEST_EXPORT
value|Q_DECL_EXPORT
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_BUILD_INTERNAL
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|QT_DLL
argument_list|)
end_elif
begin_define
DECL|macro|Q_AUTOTEST_EXPORT
define|#
directive|define
name|Q_AUTOTEST_EXPORT
value|Q_DECL_IMPORT
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_BUILD_INTERNAL
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|QT_SHARED
argument_list|)
end_elif
begin_define
DECL|macro|Q_AUTOTEST_EXPORT
define|#
directive|define
name|Q_AUTOTEST_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_AUTOTEST_EXPORT
define|#
directive|define
name|Q_AUTOTEST_EXPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qt_noop
specifier|inline
name|void
name|qt_noop
parameter_list|(
name|void
parameter_list|)
block|{}
end_function
begin_comment
comment|/* These wrap try/catch so we can switch off exceptions later.     Beware - do not use more than one QT_CATCH per QT_TRY, and do not use    the exception instance in the catch block.    If you can't live with those constraints, don't use these macros.    Use the QT_NO_EXCEPTIONS macro to protect your code instead. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_BOOTSTRAPPED
end_ifdef
begin_define
DECL|macro|QT_NO_EXCEPTIONS
define|#
directive|define
name|QT_NO_EXCEPTIONS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_EXCEPTIONS
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__EXCEPTIONS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_MOC_RUN
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_EXCEPTIONS
define|#
directive|define
name|QT_NO_EXCEPTIONS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_EXCEPTIONS
end_ifdef
begin_define
DECL|macro|QT_TRY
define|#
directive|define
name|QT_TRY
value|if (true)
end_define
begin_define
DECL|macro|QT_CATCH
define|#
directive|define
name|QT_CATCH
parameter_list|(
name|A
parameter_list|)
value|else
end_define
begin_define
DECL|macro|QT_THROW
define|#
directive|define
name|QT_THROW
parameter_list|(
name|A
parameter_list|)
value|qt_noop()
end_define
begin_define
DECL|macro|QT_RETHROW
define|#
directive|define
name|QT_RETHROW
value|qt_noop()
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_TRY
define|#
directive|define
name|QT_TRY
value|try
end_define
begin_define
DECL|macro|QT_CATCH
define|#
directive|define
name|QT_CATCH
parameter_list|(
name|A
parameter_list|)
value|catch (A)
end_define
begin_define
DECL|macro|QT_THROW
define|#
directive|define
name|QT_THROW
parameter_list|(
name|A
parameter_list|)
value|throw A
end_define
begin_define
DECL|macro|QT_RETHROW
define|#
directive|define
name|QT_RETHROW
value|throw
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    System information */
end_comment
begin_decl_stmt
DECL|variable|QString
name|class
name|QString
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|class
name|Q_CORE_EXPORT
name|QSysInfo
block|{
name|public
label|:
enum|enum
name|Sizes
block|{
name|WordSize
init|=
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|<<
literal|3
operator|)
block|}
enum|;
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_QMAKE
argument_list|)
enum|enum
name|Endian
block|{
name|BigEndian
block|,
name|LittleEndian
block|}
enum|;
comment|/* needed to bootstrap qmake */
specifier|static
specifier|const
name|int
name|ByteOrder
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_BYTE_ORDER
argument_list|)
enum|enum
name|Endian
block|{
name|BigEndian
block|,
name|LittleEndian
ifdef|#
directive|ifdef
name|qdoc
block|,
name|ByteOrder
init|=
operator|<
name|platform
operator|-
name|dependent
operator|>
elif|#
directive|elif
name|Q_BYTE_ORDER
operator|==
name|Q_BIG_ENDIAN
block|,
name|ByteOrder
init|=
name|BigEndian
elif|#
directive|elif
name|Q_BYTE_ORDER
operator|==
name|Q_LITTLE_ENDIAN
block|,
name|ByteOrder
init|=
name|LittleEndian
else|#
directive|else
error|#
directive|error
literal|"Undefined byte order"
endif|#
directive|endif
block|}
enum|;
else|#
directive|else
error|#
directive|error
literal|"Qt not configured correctly, please run configure"
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_CYGWIN
argument_list|)
enum|enum
name|WinVersion
block|{
name|WV_32s
init|=
literal|0x0001
block|,
name|WV_95
init|=
literal|0x0002
block|,
name|WV_98
init|=
literal|0x0003
block|,
name|WV_Me
init|=
literal|0x0004
block|,
name|WV_DOS_based
init|=
literal|0x000f
block|,
comment|/* codenames */
name|WV_NT
init|=
literal|0x0010
block|,
name|WV_2000
init|=
literal|0x0020
block|,
name|WV_XP
init|=
literal|0x0030
block|,
name|WV_2003
init|=
literal|0x0040
block|,
name|WV_VISTA
init|=
literal|0x0080
block|,
name|WV_WINDOWS7
init|=
literal|0x0090
block|,
name|WV_NT_based
init|=
literal|0x00f0
block|,
comment|/* version numbers */
name|WV_4_0
init|=
name|WV_NT
block|,
name|WV_5_0
init|=
name|WV_2000
block|,
name|WV_5_1
init|=
name|WV_XP
block|,
name|WV_5_2
init|=
name|WV_2003
block|,
name|WV_6_0
init|=
name|WV_VISTA
block|,
name|WV_6_1
init|=
name|WV_WINDOWS7
block|,
name|WV_CE
init|=
literal|0x0100
block|,
name|WV_CENET
init|=
literal|0x0200
block|,
name|WV_CE_5
init|=
literal|0x0300
block|,
name|WV_CE_6
init|=
literal|0x0400
block|,
name|WV_CE_based
init|=
literal|0x0f00
block|}
enum|;
specifier|static
specifier|const
name|WinVersion
name|WindowsVersion
decl_stmt|;
specifier|static
name|WinVersion
name|windowsVersion
parameter_list|()
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_MAC
enum|enum
name|MacVersion
block|{
name|MV_Unknown
init|=
literal|0x0000
block|,
comment|/* version */
name|MV_9
init|=
literal|0x0001
block|,
name|MV_10_0
init|=
literal|0x0002
block|,
name|MV_10_1
init|=
literal|0x0003
block|,
name|MV_10_2
init|=
literal|0x0004
block|,
name|MV_10_3
init|=
literal|0x0005
block|,
name|MV_10_4
init|=
literal|0x0006
block|,
name|MV_10_5
init|=
literal|0x0007
block|,
name|MV_10_6
init|=
literal|0x0008
block|,
name|MV_10_7
init|=
literal|0x0009
block|,
comment|/* codenames */
name|MV_CHEETAH
init|=
name|MV_10_0
block|,
name|MV_PUMA
init|=
name|MV_10_1
block|,
name|MV_JAGUAR
init|=
name|MV_10_2
block|,
name|MV_PANTHER
init|=
name|MV_10_3
block|,
name|MV_TIGER
init|=
name|MV_10_4
block|,
name|MV_LEOPARD
init|=
name|MV_10_5
block|,
name|MV_SNOWLEOPARD
init|=
name|MV_10_6
block|,
name|MV_LION
init|=
name|MV_10_7
block|}
enum|;
specifier|static
specifier|const
name|MacVersion
name|MacintoshVersion
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
enum|enum
name|SymbianVersion
block|{
name|SV_Unknown
init|=
literal|1000000
block|,
comment|// Assume unknown is something newer than what is supported
comment|//These are the Symbian Ltd versions 9.2-9.4
name|SV_9_2
init|=
literal|10
block|,
name|SV_9_3
init|=
literal|20
block|,
name|SV_9_4
init|=
literal|30
block|,
comment|//Following values are the symbian foundation versions, i.e. Symbian^1 == SV_SF_1
name|SV_SF_1
init|=
name|SV_9_4
block|,
name|SV_SF_2
init|=
literal|40
block|,
name|SV_SF_3
init|=
literal|50
block|,
name|SV_SF_4
init|=
literal|60
block|,
comment|// Deprecated
name|SV_API_5_3
init|=
literal|70
block|,
name|SV_API_5_4
init|=
literal|80
block|}
enum|;
specifier|static
name|SymbianVersion
name|symbianVersion
parameter_list|()
function_decl|;
enum|enum
name|S60Version
block|{
name|SV_S60_None
init|=
literal|0
block|,
name|SV_S60_Unknown
init|=
name|SV_Unknown
block|,
name|SV_S60_3_1
init|=
name|SV_9_2
block|,
name|SV_S60_3_2
init|=
name|SV_9_3
block|,
name|SV_S60_5_0
init|=
name|SV_9_4
block|,
name|SV_S60_5_1
init|=
name|SV_SF_2
block|,
comment|// Deprecated
name|SV_S60_5_2
init|=
name|SV_SF_3
block|,
name|SV_S60_5_3
init|=
name|SV_API_5_3
block|,
name|SV_S60_5_4
init|=
name|SV_API_5_4
block|}
enum|;
specifier|static
name|S60Version
name|s60Version
parameter_list|()
function_decl|;
endif|#
directive|endif
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_function_decl
name|Q_CORE_EXPORT
specifier|const
name|char
modifier|*
name|qVersion
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|bool
name|qSharedBuild
parameter_list|()
function_decl|;
end_function_decl
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_function
DECL|function|qMacVersion
specifier|inline
name|int
name|qMacVersion
parameter_list|()
block|{
return|return
name|QSysInfo
operator|::
name|MacintoshVersion
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OUTOFLINE_TEMPLATE
end_ifndef
begin_define
DECL|macro|Q_OUTOFLINE_TEMPLATE
define|#
directive|define
name|Q_OUTOFLINE_TEMPLATE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_INLINE_TEMPLATE
end_ifndef
begin_define
DECL|macro|Q_INLINE_TEMPLATE
define|#
directive|define
name|Q_INLINE_TEMPLATE
value|inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_TYPENAME
end_ifndef
begin_define
DECL|macro|Q_TYPENAME
define|#
directive|define
name|Q_TYPENAME
value|typename
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Avoid "unused parameter" warnings */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_if
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qUnused
specifier|inline
name|void
name|qUnused
argument_list|(
argument|T&x
argument_list|)
block|{
operator|(
name|void
operator|)
name|x
block|; }
DECL|macro|Q_UNUSED
define|#
directive|define
name|Q_UNUSED
parameter_list|(
name|x
parameter_list|)
value|qUnused(x);
else|#
directive|else
DECL|macro|Q_UNUSED
define|#
directive|define
name|Q_UNUSED
parameter_list|(
name|x
parameter_list|)
value|(void)x;
endif|#
directive|endif
comment|/*    Debugging and error handling */
comment|/*    On Symbian we do not know beforehand whether we are compiling in    release or debug mode, so check the Symbian build define here,    and set the QT_NO_DEBUG define appropriately. */
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|&&
name|defined
argument_list|(
name|NDEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
DECL|macro|QT_NO_DEBUG
define|#
directive|define
name|QT_NO_DEBUG
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
DECL|macro|QT_DEBUG
define|#
directive|define
name|QT_DEBUG
endif|#
directive|endif
ifndef|#
directive|ifndef
name|qPrintable
DECL|macro|qPrintable
define|#
directive|define
name|qPrintable
parameter_list|(
name|string
parameter_list|)
value|QString(string).toLocal8Bit().constData()
endif|#
directive|endif
name|Q_CORE_EXPORT
name|void
name|qDebug
argument_list|(
argument|const char *
argument_list|,
argument|...
argument_list|)
comment|/* print debug message */
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__INSURE__
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|format
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|)
argument_list|)
endif|#
directive|endif
expr_stmt|;
end_expr_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qWarning
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
comment|/* print warning message */
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__INSURE__
argument_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(format
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl
begin_endif
unit|)))
endif|#
directive|endif
end_endif
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_decl_stmt
DECL|variable|QString
name|class
name|QString
decl_stmt|;
end_decl_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|QString
name|qt_error_string
parameter_list|(
name|int
name|errorCode
init|=
operator|-
literal|1
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qCritical
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
comment|/* print critical message */
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__INSURE__
argument_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(format
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl
begin_endif
unit|)))
endif|#
directive|endif
end_endif
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qFatal
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
comment|/* print fatal message and exit */
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__INSURE__
argument_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(format
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl
begin_endif
unit|)))
endif|#
directive|endif
end_endif
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qErrnoWarning
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qErrnoWarning
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|QT_NO_DEBUG_OUTPUT
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_NO_TEXTSTREAM
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG_STREAM
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_DEBUG_STREAM
define|#
directive|define
name|QT_NO_DEBUG_STREAM
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*   Forward declarations only.    In order to use the qDebug() stream, you must #include<QDebug> */
end_comment
begin_decl_stmt
DECL|variable|QDebug
name|class
name|QDebug
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QNoDebug
name|class
name|QNoDebug
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function_decl
name|Q_CORE_EXPORT_INLINE
name|QDebug
name|qDebug
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT_INLINE
name|QDebug
name|qWarning
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT_INLINE
name|QDebug
name|qCritical
parameter_list|()
function_decl|;
end_function_decl
begin_else
else|#
directive|else
end_else
begin_function_decl
specifier|inline
name|QNoDebug
name|qDebug
parameter_list|()
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QT_NO_QDEBUG_MACRO
define|#
directive|define
name|QT_NO_QDEBUG_MACRO
value|while (false) qDebug
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_DEBUG_OUTPUT
end_ifdef
begin_define
DECL|macro|qDebug
define|#
directive|define
name|qDebug
value|QT_NO_QDEBUG_MACRO
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QT_NO_QWARNING_MACRO
define|#
directive|define
name|QT_NO_QWARNING_MACRO
value|while (false) qWarning
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_WARNING_OUTPUT
end_ifdef
begin_define
DECL|macro|qWarning
define|#
directive|define
name|qWarning
value|QT_NO_QWARNING_MACRO
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qt_assert
parameter_list|(
specifier|const
name|char
modifier|*
name|assertion
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_ASSERT
argument_list|)
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
end_ifndef
begin_define
DECL|macro|Q_ASSERT
define|#
directive|define
name|Q_ASSERT
parameter_list|(
name|cond
parameter_list|)
value|((!(cond)) ? qt_assert(#cond,__FILE__,__LINE__) : qt_noop())
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_ASSERT
define|#
directive|define
name|Q_ASSERT
parameter_list|(
name|cond
parameter_list|)
value|qt_noop()
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_PAINT_DEBUG
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_PAINT_DEBUG
define|#
directive|define
name|QT_NO_PAINT_DEBUG
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qt_assert_x
parameter_list|(
specifier|const
name|char
modifier|*
name|where
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_ASSERT_X
argument_list|)
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
end_ifndef
begin_define
DECL|macro|Q_ASSERT_X
define|#
directive|define
name|Q_ASSERT_X
parameter_list|(
name|cond
parameter_list|,
name|where
parameter_list|,
name|what
parameter_list|)
value|((!(cond)) ? qt_assert_x(where, what,__FILE__,__LINE__) : qt_noop())
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_ASSERT_X
define|#
directive|define
name|Q_ASSERT_X
parameter_list|(
name|cond
parameter_list|,
name|where
parameter_list|,
name|what
parameter_list|)
value|qt_noop()
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qt_check_pointer
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qBadAlloc
parameter_list|()
function_decl|;
end_function_decl
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_EXCEPTIONS
end_ifdef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
end_if
begin_define
DECL|macro|Q_CHECK_PTR
define|#
directive|define
name|Q_CHECK_PTR
parameter_list|(
name|p
parameter_list|)
value|qt_noop()
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CHECK_PTR
define|#
directive|define
name|Q_CHECK_PTR
parameter_list|(
name|p
parameter_list|)
value|do {if(!(p))qt_check_pointer(__FILE__,__LINE__);} while (0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CHECK_PTR
define|#
directive|define
name|Q_CHECK_PTR
parameter_list|(
name|p
parameter_list|)
value|do { if (!(p)) qBadAlloc(); } while (0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|q_check_ptr
specifier|inline
name|T
operator|*
name|q_check_ptr
argument_list|(
argument|T *p
argument_list|)
block|{
name|Q_CHECK_PTR
argument_list|(
name|p
argument_list|)
block|;
return|return
name|p
return|;
block|}
end_expr_stmt
begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_SOLARIS
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|Q_CC_HPACC
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_DIAB
argument_list|)
end_if
begin_define
DECL|macro|Q_FUNC_INFO
define|#
directive|define
name|Q_FUNC_INFO
value|__PRETTY_FUNCTION__
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_elif
begin_define
DECL|macro|Q_FUNC_INFO
define|#
directive|define
name|Q_FUNC_INFO
value|__FUNCSIG__
end_define
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SOLARIS
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_XLC
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
end_if
begin_define
DECL|macro|Q_FUNC_INFO
define|#
directive|define
name|Q_FUNC_INFO
value|__FILE__ "(line number unavailable)"
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* These two macros makes it possible to turn the builtin line expander into a          * string literal. */
end_comment
begin_define
DECL|macro|QT_STRINGIFY2
define|#
directive|define
name|QT_STRINGIFY2
parameter_list|(
name|x
parameter_list|)
value|#x
end_define
begin_define
DECL|macro|QT_STRINGIFY
define|#
directive|define
name|QT_STRINGIFY
parameter_list|(
name|x
parameter_list|)
value|QT_STRINGIFY2(x)
end_define
begin_define
DECL|macro|Q_FUNC_INFO
define|#
directive|define
name|Q_FUNC_INFO
value|__FILE__ ":" QT_STRINGIFY(__LINE__)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* The MIPSpro and RVCT compilers postpones macro expansion,        and therefore macros must be in scope when being used. */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CC_MIPS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_NOKIAX86
argument_list|)
end_if
begin_undef
DECL|macro|QT_STRINGIFY2
undef|#
directive|undef
name|QT_STRINGIFY2
end_undef
begin_undef
DECL|macro|QT_STRINGIFY
undef|#
directive|undef
name|QT_STRINGIFY
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_enum
DECL|enum|QtMsgType
DECL|enumerator|QtDebugMsg
DECL|enumerator|QtWarningMsg
DECL|enumerator|QtCriticalMsg
DECL|enumerator|QtFatalMsg
DECL|enumerator|QtSystemMsg
enum|enum
name|QtMsgType
block|{
name|QtDebugMsg
block|,
name|QtWarningMsg
block|,
name|QtCriticalMsg
block|,
name|QtFatalMsg
block|,
name|QtSystemMsg
init|=
name|QtCriticalMsg
block|}
enum|;
end_enum
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qt_message_output
parameter_list|(
name|QtMsgType
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl
begin_typedef
DECL|typedef|QtMsgHandler
typedef|typedef
name|void
function_decl|(
modifier|*
name|QtMsgHandler
function_decl|)
parameter_list|(
name|QtMsgType
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_typedef
begin_function_decl
name|Q_CORE_EXPORT
name|QtMsgHandler
name|qInstallMsgHandler
parameter_list|(
name|QtMsgHandler
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_UNIMPLEMENTED
argument_list|)
end_if
begin_define
DECL|macro|Q_UNIMPLEMENTED
define|#
directive|define
name|Q_UNIMPLEMENTED
parameter_list|()
value|qWarning("%s:%d: %s: Unimplemented code.", __FILE__, __LINE__, Q_FUNC_INFO)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
end_if
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QGlobalStatic
block|{
name|public
operator|:
name|T
operator|*
name|pointer
block|;
specifier|inline
name|QGlobalStatic
argument_list|(
name|T
operator|*
name|p
argument_list|)
operator|:
name|pointer
argument_list|(
argument|p
argument_list|)
block|{ }
specifier|inline
operator|~
name|QGlobalStatic
argument_list|()
block|{
name|pointer
operator|=
literal|0
block|; }
block|}
expr_stmt|;
end_expr_stmt
begin_define
DECL|macro|Q_GLOBAL_STATIC
define|#
directive|define
name|Q_GLOBAL_STATIC
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|)
define|\
value|static TYPE *NAME()                                              \     {                                                                \         static TYPE thisVariable;                                    \         static QGlobalStatic<TYPE> thisGlobalStatic(&thisVariable); \         return thisGlobalStatic.pointer;                             \     }
end_define
begin_define
DECL|macro|Q_GLOBAL_STATIC_WITH_ARGS
define|#
directive|define
name|Q_GLOBAL_STATIC_WITH_ARGS
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|,
name|ARGS
parameter_list|)
define|\
value|static TYPE *NAME()                                              \     {                                                                \         static TYPE thisVariable ARGS;                               \         static QGlobalStatic<TYPE> thisGlobalStatic(&thisVariable); \         return thisGlobalStatic.pointer;                             \     }
end_define
begin_define
DECL|macro|Q_GLOBAL_STATIC_WITH_INITIALIZER
define|#
directive|define
name|Q_GLOBAL_STATIC_WITH_INITIALIZER
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|,
name|INITIALIZER
parameter_list|)
define|\
value|static TYPE *NAME()                                              \     {                                                                \         static TYPE thisVariable;                                    \         static QGlobalStatic<TYPE> thisGlobalStatic(0);             \         if (!thisGlobalStatic.pointer) {                             \             TYPE *x = thisGlobalStatic.pointer =&thisVariable;      \             INITIALIZER;                                             \         }                                                            \         return thisGlobalStatic.pointer;                             \     }
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|// forward declaration, since qatomic.h needs qglobal.h
end_comment
begin_expr_stmt
DECL|variable|QBasicAtomicPointer
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QBasicAtomicPointer
expr_stmt|;
end_expr_stmt
begin_comment
comment|// POD for Q_GLOBAL_STATIC
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QGlobalStatic
block|{
name|public
operator|:
name|QBasicAtomicPointer
operator|<
name|T
operator|>
name|pointer
block|;
name|bool
name|destroyed
block|; }
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Created as a function-local static to delete a QGlobalStatic<T>
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QGlobalStaticDeleter
block|{
name|public
operator|:
name|QGlobalStatic
operator|<
name|T
operator|>
operator|&
name|globalStatic
block|;
name|QGlobalStaticDeleter
argument_list|(
name|QGlobalStatic
operator|<
name|T
operator|>
operator|&
name|_globalStatic
argument_list|)
operator|:
name|globalStatic
argument_list|(
argument|_globalStatic
argument_list|)
block|{ }
specifier|inline
operator|~
name|QGlobalStaticDeleter
argument_list|()
block|{
name|delete
name|globalStatic
operator|.
name|pointer
block|;
name|globalStatic
operator|.
name|pointer
operator|=
literal|0
block|;
name|globalStatic
operator|.
name|destroyed
operator|=
name|true
block|;     }
block|}
expr_stmt|;
end_expr_stmt
begin_define
DECL|macro|Q_GLOBAL_STATIC
define|#
directive|define
name|Q_GLOBAL_STATIC
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|)
define|\
value|static TYPE *NAME()                                                       \     {                                                                         \         static QGlobalStatic<TYPE> thisGlobalStatic                          \                             = { Q_BASIC_ATOMIC_INITIALIZER(0), false };       \         if (!thisGlobalStatic.pointer&& !thisGlobalStatic.destroyed) {       \             TYPE *x = new TYPE;                                               \             if (!thisGlobalStatic.pointer.testAndSetOrdered(0, x))            \                 delete x;                                                     \             else                                                              \                 static QGlobalStaticDeleter<TYPE> cleanup(thisGlobalStatic); \         }                                                                     \         return thisGlobalStatic.pointer;                                      \     }
end_define
begin_define
DECL|macro|Q_GLOBAL_STATIC_WITH_ARGS
define|#
directive|define
name|Q_GLOBAL_STATIC_WITH_ARGS
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|,
name|ARGS
parameter_list|)
define|\
value|static TYPE *NAME()                                                       \     {                                                                         \         static QGlobalStatic<TYPE> thisGlobalStatic                          \                             = { Q_BASIC_ATOMIC_INITIALIZER(0), false };       \         if (!thisGlobalStatic.pointer&& !thisGlobalStatic.destroyed) {       \             TYPE *x = new TYPE ARGS;                                          \             if (!thisGlobalStatic.pointer.testAndSetOrdered(0, x))            \                 delete x;                                                     \             else                                                              \                 static QGlobalStaticDeleter<TYPE> cleanup(thisGlobalStatic); \         }                                                                     \         return thisGlobalStatic.pointer;                                      \     }
end_define
begin_define
DECL|macro|Q_GLOBAL_STATIC_WITH_INITIALIZER
define|#
directive|define
name|Q_GLOBAL_STATIC_WITH_INITIALIZER
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|,
name|INITIALIZER
parameter_list|)
define|\
value|static TYPE *NAME()                                                       \     {                                                                         \         static QGlobalStatic<TYPE> thisGlobalStatic                          \                             = { Q_BASIC_ATOMIC_INITIALIZER(0), false };       \         if (!thisGlobalStatic.pointer&& !thisGlobalStatic.destroyed) {       \             QScopedPointer<TYPE> x(new TYPE);                                \             INITIALIZER;                                                      \             if (thisGlobalStatic.pointer.testAndSetOrdered(0, x.data())) {    \                 static QGlobalStaticDeleter<TYPE> cleanup(thisGlobalStatic); \                 x.take();                                                     \             }                                                                 \         }                                                                     \         return thisGlobalStatic.pointer;                                      \     }
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|class
name|QBool
block|{
name|bool
name|b
decl_stmt|;
name|public
label|:
specifier|inline
name|explicit
name|QBool
argument_list|(
argument|bool B
argument_list|)
operator|:
name|b
argument_list|(
argument|B
argument_list|)
block|{}
specifier|inline
name|operator
specifier|const
name|void
operator|*
operator|(
operator|)
specifier|const
block|{
return|return
name|b
operator|?
name|static_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
name|this
operator|)
operator|:
name|static_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
DECL|function|operator
specifier|inline
name|bool
name|operator
operator|==
operator|(
name|QBool
name|b1
operator|,
name|bool
name|b2
operator|)
block|{
return|return
operator|!
name|b1
operator|==
operator|!
name|b2
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|operator
specifier|inline
name|bool
name|operator
operator|==
operator|(
name|bool
name|b1
operator|,
name|QBool
name|b2
operator|)
block|{
return|return
operator|!
name|b1
operator|==
operator|!
name|b2
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|operator
specifier|inline
name|bool
name|operator
operator|==
operator|(
name|QBool
name|b1
operator|,
name|QBool
name|b2
operator|)
block|{
return|return
operator|!
name|b1
operator|==
operator|!
name|b2
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|operator
specifier|inline
name|bool
name|operator
operator|!=
operator|(
name|QBool
name|b1
operator|,
name|bool
name|b2
operator|)
block|{
return|return
operator|!
name|b1
operator|!=
operator|!
name|b2
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|operator
specifier|inline
name|bool
name|operator
operator|!=
operator|(
name|bool
name|b1
operator|,
name|QBool
name|b2
operator|)
block|{
return|return
operator|!
name|b1
operator|!=
operator|!
name|b2
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|operator
specifier|inline
name|bool
name|operator
operator|!=
operator|(
name|QBool
name|b1
operator|,
name|QBool
name|b2
operator|)
block|{
return|return
operator|!
name|b1
operator|!=
operator|!
name|b2
return|;
block|}
end_expr_stmt
begin_function
DECL|function|qFuzzyCompare
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyCompare
parameter_list|(
name|double
name|p1
parameter_list|,
name|double
name|p2
parameter_list|)
block|{
return|return
operator|(
name|qAbs
argument_list|(
name|p1
operator|-
name|p2
argument_list|)
operator|<=
literal|0.000000000001
operator|*
name|qMin
argument_list|(
name|qAbs
argument_list|(
name|p1
argument_list|)
argument_list|,
name|qAbs
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|qFuzzyCompare
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyCompare
parameter_list|(
name|float
name|p1
parameter_list|,
name|float
name|p2
parameter_list|)
block|{
return|return
operator|(
name|qAbs
argument_list|(
name|p1
operator|-
name|p2
argument_list|)
operator|<=
literal|0.00001f
operator|*
name|qMin
argument_list|(
name|qAbs
argument_list|(
name|p1
argument_list|)
argument_list|,
name|qAbs
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|qFuzzyIsNull
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyIsNull
parameter_list|(
name|double
name|d
parameter_list|)
block|{
return|return
name|qAbs
argument_list|(
name|d
argument_list|)
operator|<=
literal|0.000000000001
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|qFuzzyIsNull
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyIsNull
parameter_list|(
name|float
name|f
parameter_list|)
block|{
return|return
name|qAbs
argument_list|(
name|f
argument_list|)
operator|<=
literal|0.00001f
return|;
block|}
end_function
begin_comment
comment|/*    This function tests a double for a null value. It doesn't    check whether the actual value is 0 or close to 0, but whether    it is binary 0. */
end_comment
begin_function
DECL|function|qIsNull
specifier|static
specifier|inline
name|bool
name|qIsNull
parameter_list|(
name|double
name|d
parameter_list|)
block|{
union|union
name|U
block|{
name|double
name|d
decl_stmt|;
name|quint64
name|u
decl_stmt|;
block|}
union|;
name|U
name|val
decl_stmt|;
name|val
operator|.
name|d
operator|=
name|d
expr_stmt|;
return|return
name|val
operator|.
name|u
operator|==
name|quint64
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*    This function tests a float for a null value. It doesn't    check whether the actual value is 0 or close to 0, but whether    it is binary 0. */
end_comment
begin_function
DECL|function|qIsNull
specifier|static
specifier|inline
name|bool
name|qIsNull
parameter_list|(
name|float
name|f
parameter_list|)
block|{
union|union
name|U
block|{
name|float
name|f
decl_stmt|;
name|quint32
name|u
decl_stmt|;
block|}
union|;
name|U
name|val
decl_stmt|;
name|val
operator|.
name|f
operator|=
name|f
expr_stmt|;
return|return
name|val
operator|.
name|u
operator|==
literal|0u
return|;
block|}
end_function
begin_comment
comment|/*    Compilers which follow outdated template instantiation rules    require a class to have a comparison operator to exist when    a QList of this type is instantiated. It's not actually    used in the list, though. Hence the dummy implementation.    Just in case other code relies on it we better trigger a warning    mandating a real implementation. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_FULL_TEMPLATE_INSTANTIATION
end_ifdef
begin_define
DECL|macro|Q_DUMMY_COMPARISON_OPERATOR
define|#
directive|define
name|Q_DUMMY_COMPARISON_OPERATOR
parameter_list|(
name|C
parameter_list|)
define|\
value|bool operator==(const C&) const { \         qWarning(#C"::operator==(const "#C"&) was called"); \         return false; \     }
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_DUMMY_COMPARISON_OPERATOR
define|#
directive|define
name|Q_DUMMY_COMPARISON_OPERATOR
parameter_list|(
name|C
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    QTypeInfo     - type trait functionality    qIsDetached   - data sharing functionality */
end_comment
begin_comment
comment|/*   The catch-all template. */
end_comment
begin_expr_stmt
DECL|function|qIsDetached
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|qIsDetached
argument_list|(
argument|T&
argument_list|)
block|{
return|return
name|true
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QTypeInfo
block|{
name|public
operator|:
expr|enum
block|{
name|isPointer
operator|=
name|false
block|,
name|isComplex
operator|=
name|true
block|,
name|isStatic
operator|=
name|true
block|,
name|isLarge
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
block|,
name|isDummy
operator|=
name|false
block|}
block|; }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QTypeInfo
operator|<
name|T
operator|*
operator|>
block|{
name|public
operator|:
expr|enum
block|{
name|isPointer
operator|=
name|true
block|,
name|isComplex
operator|=
name|false
block|,
name|isStatic
operator|=
name|false
block|,
name|isLarge
operator|=
name|false
block|,
name|isDummy
operator|=
name|false
block|}
block|; }
expr_stmt|;
end_expr_stmt
begin_comment
comment|/*    Specialize a specific type with:       Q_DECLARE_TYPEINFO(type, flags);     where 'type' is the name of the type to specialize and 'flags' is    logically-OR'ed combination of the flags below. */
end_comment
begin_enum
enum|enum
block|{
comment|/* TYPEINFO flags */
DECL|enumerator|Q_COMPLEX_TYPE
name|Q_COMPLEX_TYPE
init|=
literal|0
block|,
DECL|enumerator|Q_PRIMITIVE_TYPE
name|Q_PRIMITIVE_TYPE
init|=
literal|0x1
block|,
DECL|enumerator|Q_STATIC_TYPE
name|Q_STATIC_TYPE
init|=
literal|0
block|,
DECL|enumerator|Q_MOVABLE_TYPE
name|Q_MOVABLE_TYPE
init|=
literal|0x2
block|,
DECL|enumerator|Q_DUMMY_TYPE
name|Q_DUMMY_TYPE
init|=
literal|0x4
block|}
enum|;
end_enum
begin_define
DECL|macro|Q_DECLARE_TYPEINFO_BODY
define|#
directive|define
name|Q_DECLARE_TYPEINFO_BODY
parameter_list|(
name|TYPE
parameter_list|,
name|FLAGS
parameter_list|)
define|\
value|class QTypeInfo<TYPE> \ { \ public: \     enum { \         isComplex = (((FLAGS)& Q_PRIMITIVE_TYPE) == 0), \         isStatic = (((FLAGS)& (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), \         isLarge = (sizeof(TYPE)>sizeof(void*)), \         isPointer = false, \         isDummy = (((FLAGS)& Q_DUMMY_TYPE) != 0) \     }; \     static inline const char *name() { return #TYPE; } \ }
end_define
begin_define
DECL|macro|Q_DECLARE_TYPEINFO
define|#
directive|define
name|Q_DECLARE_TYPEINFO
parameter_list|(
name|TYPE
parameter_list|,
name|FLAGS
parameter_list|)
define|\
value|template<> \ Q_DECLARE_TYPEINFO_BODY(TYPE, FLAGS)
end_define
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qSwap
specifier|inline
name|void
name|qSwap
argument_list|(
argument|T&value1
argument_list|,
argument|T&value2
argument_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_STL
specifier|const
name|T
name|t
operator|=
name|value1
block|;
name|value1
operator|=
name|value2
block|;
name|value2
operator|=
name|t
block|;
else|#
directive|else
name|using
name|std
operator|::
name|swap
block|;
name|swap
argument_list|(
name|value1
argument_list|,
name|value2
argument_list|)
block|;
endif|#
directive|endif
block|}
comment|/*    Specialize a shared type with:       Q_DECLARE_SHARED(type);     where 'type' is the name of the type to specialize.  NOTE: shared    types must declare a 'bool isDetached(void) const;' member for this    to work. */
ifdef|#
directive|ifdef
name|QT_NO_STL
DECL|macro|Q_DECLARE_SHARED_STL
define|#
directive|define
name|Q_DECLARE_SHARED_STL
parameter_list|(
name|TYPE
parameter_list|)
else|#
directive|else
DECL|macro|Q_DECLARE_SHARED_STL
define|#
directive|define
name|Q_DECLARE_SHARED_STL
parameter_list|(
name|TYPE
parameter_list|)
define|\
value|QT_END_NAMESPACE \ namespace std { \     template<> inline void swap<QT_PREPEND_NAMESPACE(TYPE)>(QT_PREPEND_NAMESPACE(TYPE)&value1, QT_PREPEND_NAMESPACE(TYPE)&value2) \     { swap(value1.data_ptr(), value2.data_ptr()); } \ } \ QT_BEGIN_NAMESPACE
endif|#
directive|endif
DECL|macro|Q_DECLARE_SHARED
define|#
directive|define
name|Q_DECLARE_SHARED
parameter_list|(
name|TYPE
parameter_list|)
define|\
value|template<> inline bool qIsDetached<TYPE>(TYPE&t) { return t.isDetached(); } \ template<> inline void qSwap<TYPE>(TYPE&value1, TYPE&value2) \ { qSwap(value1.data_ptr(), value2.data_ptr()); } \ Q_DECLARE_SHARED_STL(TYPE)
comment|/*    QTypeInfo primitive specializations */
name|Q_DECLARE_TYPEINFO
argument_list|(
name|bool
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|char
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_macro
name|Q_DECLARE_TYPEINFO
argument_list|(
argument|signed char
argument_list|,
argument|Q_PRIMITIVE_TYPE
argument_list|)
end_macro
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|uchar
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|short
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|ushort
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|int
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|uint
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|long
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|ulong
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|qint64
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|quint64
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|float
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|double
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_DARWIN
end_ifndef
begin_macro
name|Q_DECLARE_TYPEINFO
argument_list|(
argument|long double
argument_list|,
argument|Q_PRIMITIVE_TYPE
argument_list|)
end_macro
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    These functions make it possible to use standard C++ functions with    a similar name from Qt header files (especially template classes). */
end_comment
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qMalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qFree
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qRealloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qMallocAligned
parameter_list|(
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qReallocAligned
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|alignment
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qFreeAligned
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qMemCopy
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qMemSet
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
name|int
name|c
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*    Avoid some particularly useless warnings from some stupid compilers.    To get ALL C++ compiler warnings, define QT_CC_WARNINGS or comment out    the line "#define QT_NO_WARNINGS". */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_CC_WARNINGS
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_WARNINGS
define|#
directive|define
name|QT_NO_WARNINGS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_WARNINGS
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4251
name|)
end_pragma
begin_comment
comment|/* class 'A' needs to have dll interface for to be used by clients of class 'B'. */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4244
name|)
end_pragma
begin_comment
comment|/* 'conversion' conversion from 'type1' to 'type2', possible loss of data */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4275
name|)
end_pragma
begin_comment
comment|/* non - DLL-interface classkey 'identifier' used as base for DLL-interface classkey 'identifier' */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4514
name|)
end_pragma
begin_comment
comment|/* unreferenced inline/local function has been removed */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4800
name|)
end_pragma
begin_comment
comment|/* 'type' : forcing value to bool 'true' or 'false' (performance warning) */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4097
name|)
end_pragma
begin_comment
comment|/* typedef-name 'identifier1' used as synonym for class-name 'identifier2' */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4706
name|)
end_pragma
begin_comment
comment|/* assignment within conditional expression */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4786
name|)
end_pragma
begin_comment
comment|/* truncating debug info after 255 characters */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4660
name|)
end_pragma
begin_comment
comment|/* template-class specialization 'identifier' is already instantiated */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4355
name|)
end_pragma
begin_comment
comment|/* 'this' : used in base member initializer list */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4231
name|)
end_pragma
begin_comment
comment|/* nonstandard extension used : 'extern' before template explicit instantiation */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4710
name|)
end_pragma
begin_comment
comment|/* function not inlined */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4530
name|)
end_pragma
begin_comment
comment|/* C++ exception handler used, but unwind semantics are not enabled. Specify -GX */
end_comment
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_BOR
argument_list|)
end_elif
begin_pragma
pragma|#
directive|pragma
name|option
name|-
name|w
name|-
name|inl
end_pragma
begin_pragma
pragma|#
directive|pragma
name|option
name|-
name|w
name|-
name|aus
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|inl
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|pia
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|ccc
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|rch
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|sig
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|class
name|Q_CORE_EXPORT
name|QFlag
block|{
name|int
name|i
decl_stmt|;
name|public
label|:
specifier|inline
name|QFlag
argument_list|(
argument|int i
argument_list|)
expr_stmt|;
specifier|inline
name|operator
name|int
argument_list|()
specifier|const
block|{
return|return
name|i
return|;
block|}
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
DECL|function|QFlag
specifier|inline
name|QFlag
operator|::
name|QFlag
argument_list|(
argument|int ai
argument_list|)
operator|:
name|i
argument_list|(
argument|ai
argument_list|)
block|{}
name|class
name|Q_CORE_EXPORT
name|QIncompatibleFlag
block|{
name|int
name|i
block|;
name|public
operator|:
specifier|inline
name|explicit
name|QIncompatibleFlag
argument_list|(
argument|int i
argument_list|)
block|;
specifier|inline
name|operator
name|int
argument_list|()
specifier|const
block|{
return|return
name|i
return|;
block|}
end_expr_stmt
begin_expr_stmt
unit|};
DECL|function|QIncompatibleFlag
specifier|inline
name|QIncompatibleFlag
operator|::
name|QIncompatibleFlag
argument_list|(
argument|int ai
argument_list|)
operator|:
name|i
argument_list|(
argument|ai
argument_list|)
block|{}
ifndef|#
directive|ifndef
name|Q_NO_TYPESAFE_FLAGS
name|template
operator|<
name|typename
name|Enum
operator|>
name|class
name|QFlags
block|{
typedef|typedef
name|void
modifier|*
modifier|*
name|Zero
typedef|;
name|int
name|i
expr_stmt|;
end_expr_stmt
begin_label
name|public
label|:
end_label
begin_typedef
typedef|typedef
name|Enum
name|enum_type
typedef|;
end_typedef
begin_macro
name|Q_DECL_CONSTEXPR
end_macro
begin_expr_stmt
specifier|inline
name|QFlags
argument_list|(
specifier|const
name|QFlags
operator|&
name|f
argument_list|)
operator|:
name|i
argument_list|(
argument|f.i
argument_list|)
block|{}
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
argument_list|(
argument|Enum f
argument_list|)
operator|:
name|i
argument_list|(
argument|f
argument_list|)
block|{}
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
argument_list|(
name|Zero
operator|=
literal|0
argument_list|)
operator|:
name|i
argument_list|(
literal|0
argument_list|)
block|{}
specifier|inline
name|QFlags
argument_list|(
argument|QFlag f
argument_list|)
operator|:
name|i
argument_list|(
argument|f
argument_list|)
block|{}
specifier|inline
name|QFlags
operator|&
name|operator
operator|=
operator|(
specifier|const
name|QFlags
operator|&
name|f
operator|)
block|{
name|i
operator|=
name|f
operator|.
name|i
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QFlags
operator|&
name|operator
operator|&=
operator|(
name|int
name|mask
operator|)
block|{
name|i
operator|&=
name|mask
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QFlags
operator|&
name|operator
operator|&=
operator|(
name|uint
name|mask
operator|)
block|{
name|i
operator|&=
name|mask
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QFlags
operator|&
name|operator
operator||=
operator|(
name|QFlags
name|f
operator|)
block|{
name|i
operator||=
name|f
operator|.
name|i
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QFlags
operator|&
name|operator
operator||=
operator|(
name|Enum
name|f
operator|)
block|{
name|i
operator||=
name|f
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QFlags
operator|&
name|operator
operator|^=
operator|(
name|QFlags
name|f
operator|)
block|{
name|i
operator|^=
name|f
operator|.
name|i
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QFlags
operator|&
name|operator
operator|^=
operator|(
name|Enum
name|f
operator|)
block|{
name|i
operator|^=
name|f
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|operator
name|int
argument_list|()
specifier|const
block|{
return|return
name|i
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
operator||
operator|(
name|QFlags
name|f
operator|)
specifier|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator||
name|f
operator|.
name|i
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
operator||
operator|(
name|Enum
name|f
operator|)
specifier|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator||
name|f
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
modifier|^
argument_list|(
name|QFlags
name|f
argument_list|)
decl|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator|^
name|f
operator|.
name|i
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
modifier|^
argument_list|(
name|Enum
name|f
argument_list|)
decl|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator|^
name|f
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
modifier|&
argument_list|(
name|int
name|mask
argument_list|)
decl|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator|&
name|mask
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
modifier|&
argument_list|(
name|uint
name|mask
argument_list|)
decl|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator|&
name|mask
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
modifier|&
argument_list|(
name|Enum
name|f
argument_list|)
decl|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator|&
name|f
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt
begin_expr_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
operator|~
operator|(
operator|)
specifier|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
operator|~
name|i
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|bool
name|operator
operator|!
operator|(
operator|)
specifier|const
block|{
return|return
operator|!
name|i
return|;
block|}
end_expr_stmt
begin_decl_stmt
specifier|inline
name|bool
name|testFlag
argument_list|(
name|Enum
name|f
argument_list|)
decl|const
block|{
return|return
operator|(
name|i
operator|&
name|f
operator|)
operator|==
name|f
operator|&&
operator|(
name|f
operator|!=
literal|0
operator|||
name|i
operator|==
name|int
argument_list|(
name|f
argument_list|)
operator|)
return|;
block|}
end_decl_stmt
begin_define
DECL|macro|Q_DECLARE_FLAGS
unit|};
define|#
directive|define
name|Q_DECLARE_FLAGS
parameter_list|(
name|Flags
parameter_list|,
name|Enum
parameter_list|)
define|\
value|typedef QFlags<Enum> Flags;
end_define
begin_define
DECL|macro|Q_DECLARE_INCOMPATIBLE_FLAGS
define|#
directive|define
name|Q_DECLARE_INCOMPATIBLE_FLAGS
parameter_list|(
name|Flags
parameter_list|)
define|\
value|inline QIncompatibleFlag operator|(Flags::enum_type f1, int f2) \ { return QIncompatibleFlag(int(f1) | f2); }
end_define
begin_define
DECL|macro|Q_DECLARE_OPERATORS_FOR_FLAGS
define|#
directive|define
name|Q_DECLARE_OPERATORS_FOR_FLAGS
parameter_list|(
name|Flags
parameter_list|)
define|\
value|Q_DECL_CONSTEXPR inline QFlags<Flags::enum_type> operator|(Flags::enum_type f1, Flags::enum_type f2) \ { return QFlags<Flags::enum_type>(f1) | f2; } \ Q_DECL_CONSTEXPR inline QFlags<Flags::enum_type> operator|(Flags::enum_type f1, QFlags<Flags::enum_type> f2) \ { return f2 | f1; } Q_DECLARE_INCOMPATIBLE_FLAGS(Flags)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* Q_NO_TYPESAFE_FLAGS */
end_comment
begin_define
DECL|macro|Q_DECLARE_FLAGS
define|#
directive|define
name|Q_DECLARE_FLAGS
parameter_list|(
name|Flags
parameter_list|,
name|Enum
parameter_list|)
define|\
value|typedef uint Flags;
end_define
begin_define
DECL|macro|Q_DECLARE_OPERATORS_FOR_FLAGS
define|#
directive|define
name|Q_DECLARE_OPERATORS_FOR_FLAGS
parameter_list|(
name|Flags
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Q_NO_TYPESAFE_FLAGS */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_if
begin_comment
comment|/* make use of typeof-extension */
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QForeachContainer
block|{
name|public
operator|:
specifier|inline
name|QForeachContainer
argument_list|(
specifier|const
name|T
operator|&
name|t
argument_list|)
operator|:
name|c
argument_list|(
name|t
argument_list|)
block|,
name|brk
argument_list|(
literal|0
argument_list|)
block|,
name|i
argument_list|(
name|c
operator|.
name|begin
argument_list|()
argument_list|)
block|,
name|e
argument_list|(
argument|c.end()
argument_list|)
block|{ }
specifier|const
name|T
name|c
block|;
name|int
name|brk
block|;
name|typename
name|T
operator|::
name|const_iterator
name|i
block|,
name|e
block|; }
expr_stmt|;
end_expr_stmt
begin_define
DECL|macro|Q_FOREACH
define|#
directive|define
name|Q_FOREACH
parameter_list|(
name|variable
parameter_list|,
name|container
parameter_list|)
define|\
value|for (QForeachContainer<__typeof__(container)> _container_(container); \      !_container_.brk&& _container_.i != _container_.e;              \      __extension__  ({ ++_container_.brk; ++_container_.i; }))                       \     for (variable = *_container_.i;; __extension__ ({--_container_.brk; break;}))
end_define
begin_else
else|#
directive|else
end_else
begin_struct
DECL|struct|QForeachContainerBase
struct|struct
name|QForeachContainerBase
block|{}
struct|;
end_struct
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QForeachContainer
operator|:
name|public
name|QForeachContainerBase
block|{
name|public
operator|:
specifier|inline
name|QForeachContainer
argument_list|(
specifier|const
name|T
operator|&
name|t
argument_list|)
operator|:
name|c
argument_list|(
name|t
argument_list|)
block|,
name|brk
argument_list|(
literal|0
argument_list|)
block|,
name|i
argument_list|(
name|c
operator|.
name|begin
argument_list|()
argument_list|)
block|,
name|e
argument_list|(
argument|c.end()
argument_list|)
block|{}
block|;
specifier|const
name|T
name|c
block|;
name|mutable
name|int
name|brk
block|;
name|mutable
name|typename
name|T
operator|::
name|const_iterator
name|i
block|,
name|e
block|;
specifier|inline
name|bool
name|condition
argument_list|()
specifier|const
block|{
return|return
operator|(
operator|!
name|brk
operator|++
operator|&&
name|i
operator|!=
name|e
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
unit|};
DECL|function|qForeachPointer
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
operator|*
name|qForeachPointer
argument_list|(
argument|const T&
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|qForeachContainerNew
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|QForeachContainer
operator|<
name|T
operator|>
name|qForeachContainerNew
argument_list|(
argument|const T& t
argument_list|)
block|{
return|return
name|QForeachContainer
operator|<
name|T
operator|>
operator|(
name|t
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qForeachContainer
specifier|inline
specifier|const
name|QForeachContainer
operator|<
name|T
operator|>
operator|*
name|qForeachContainer
argument_list|(
argument|const QForeachContainerBase *base
argument_list|,
argument|const T *
argument_list|)
block|{
return|return
name|static_cast
operator|<
specifier|const
name|QForeachContainer
operator|<
name|T
operator|>
operator|*
operator|>
operator|(
name|base
operator|)
return|;
block|}
end_expr_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MIPS
argument_list|)
end_if
begin_comment
comment|/*    Proper for-scoping in MIPSpro CC */
end_comment
begin_define
DECL|macro|Q_FOREACH
define|#
directive|define
name|Q_FOREACH
parameter_list|(
name|variable
parameter_list|,
name|container
parameter_list|)
define|\
value|if(0){}else                                                                                     \     for (const QForeachContainerBase&_container_ = qForeachContainerNew(container);                \          qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->condition();       \          ++qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->i)               \         for (variable = *qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->i; \              qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->brk;           \              --qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->brk)
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_DIAB
argument_list|)
end_elif
begin_comment
comment|// VxWorks DIAB generates unresolvable symbols, if container is a function call
end_comment
begin_define
DECL|macro|Q_FOREACH
define|#
directive|define
name|Q_FOREACH
parameter_list|(
name|variable
parameter_list|,
name|container
parameter_list|)
define|\
value|if(0){}else                                                                                     \     for (const QForeachContainerBase&_container_ = qForeachContainerNew(container);                \          qForeachContainer(&_container_, (__typeof__(container) *) 0)->condition();       \          ++qForeachContainer(&_container_, (__typeof__(container) *) 0)->i)               \         for (variable = *qForeachContainer(&_container_, (__typeof__(container) *) 0)->i; \              qForeachContainer(&_container_, (__typeof__(container) *) 0)->brk;           \              --qForeachContainer(&_container_, (__typeof__(container) *) 0)->brk)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_FOREACH
define|#
directive|define
name|Q_FOREACH
parameter_list|(
name|variable
parameter_list|,
name|container
parameter_list|)
define|\
value|for (const QForeachContainerBase&_container_ = qForeachContainerNew(container); \          qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->condition();       \          ++qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->i)               \         for (variable = *qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->i; \              qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->brk;           \              --qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->brk)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// MSVC6 || MIPSpro
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Q_FOREVER
define|#
directive|define
name|Q_FOREVER
value|for(;;)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_KEYWORDS
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|foreach
end_ifndef
begin_define
DECL|macro|foreach
define|#
directive|define
name|foreach
value|Q_FOREACH
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|forever
end_ifndef
begin_define
DECL|macro|forever
define|#
directive|define
name|forever
value|Q_FOREVER
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/* tell gcc to use its built-in methods for some common functions */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
end_if
begin_define
define|#
directive|define
name|qMemCopy
value|__builtin_memcpy
end_define
begin_define
define|#
directive|define
name|qMemSet
value|__builtin_memset
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
DECL|function|qGetPtrHelper
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
specifier|inline
name|T
operator|*
name|qGetPtrHelper
argument_list|(
argument|T *ptr
argument_list|)
block|{
return|return
name|ptr
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|qGetPtrHelper
name|template
operator|<
name|typename
name|Wrapper
operator|>
specifier|static
specifier|inline
name|typename
name|Wrapper
operator|::
name|pointer
name|qGetPtrHelper
argument_list|(
argument|const Wrapper&p
argument_list|)
block|{
return|return
name|p
operator|.
name|data
argument_list|()
return|;
block|}
end_expr_stmt
begin_define
DECL|macro|Q_DECLARE_PRIVATE
define|#
directive|define
name|Q_DECLARE_PRIVATE
parameter_list|(
name|Class
parameter_list|)
define|\
value|inline Class##Private* d_func() { return reinterpret_cast<Class##Private *>(qGetPtrHelper(d_ptr)); } \     inline const Class##Private* d_func() const { return reinterpret_cast<const Class##Private *>(qGetPtrHelper(d_ptr)); } \     friend class Class##Private;
end_define
begin_define
DECL|macro|Q_DECLARE_PRIVATE_D
define|#
directive|define
name|Q_DECLARE_PRIVATE_D
parameter_list|(
name|Dptr
parameter_list|,
name|Class
parameter_list|)
define|\
value|inline Class##Private* d_func() { return reinterpret_cast<Class##Private *>(Dptr); } \     inline const Class##Private* d_func() const { return reinterpret_cast<const Class##Private *>(Dptr); } \     friend class Class##Private;
end_define
begin_define
DECL|macro|Q_DECLARE_PUBLIC
define|#
directive|define
name|Q_DECLARE_PUBLIC
parameter_list|(
name|Class
parameter_list|)
define|\
value|inline Class* q_func() { return static_cast<Class *>(q_ptr); } \     inline const Class* q_func() const { return static_cast<const Class *>(q_ptr); } \     friend class Class;
end_define
begin_define
DECL|macro|Q_D
define|#
directive|define
name|Q_D
parameter_list|(
name|Class
parameter_list|)
value|Class##Private * const d = d_func()
end_define
begin_define
DECL|macro|Q_Q
define|#
directive|define
name|Q_Q
parameter_list|(
name|Class
parameter_list|)
value|Class * const q = q_func()
end_define
begin_define
DECL|macro|QT_TR_NOOP
define|#
directive|define
name|QT_TR_NOOP
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define
begin_define
DECL|macro|QT_TR_NOOP_UTF8
define|#
directive|define
name|QT_TR_NOOP_UTF8
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define
begin_define
DECL|macro|QT_TRANSLATE_NOOP
define|#
directive|define
name|QT_TRANSLATE_NOOP
parameter_list|(
name|scope
parameter_list|,
name|x
parameter_list|)
value|(x)
end_define
begin_define
DECL|macro|QT_TRANSLATE_NOOP_UTF8
define|#
directive|define
name|QT_TRANSLATE_NOOP_UTF8
parameter_list|(
name|scope
parameter_list|,
name|x
parameter_list|)
value|(x)
end_define
begin_define
DECL|macro|QT_TRANSLATE_NOOP3
define|#
directive|define
name|QT_TRANSLATE_NOOP3
parameter_list|(
name|scope
parameter_list|,
name|x
parameter_list|,
name|comment
parameter_list|)
value|{x, comment}
end_define
begin_define
DECL|macro|QT_TRANSLATE_NOOP3_UTF8
define|#
directive|define
name|QT_TRANSLATE_NOOP3_UTF8
parameter_list|(
name|scope
parameter_list|,
name|x
parameter_list|,
name|comment
parameter_list|)
value|{x, comment}
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TRANSLATION
end_ifndef
begin_comment
comment|// ### This should enclose the NOOPs above
end_comment
begin_comment
comment|// Defined in qcoreapplication.cpp
end_comment
begin_comment
comment|// The better name qTrId() is reserved for an upcoming function which would
end_comment
begin_comment
comment|// return a much more powerful QStringFormatter instead of a QString.
end_comment
begin_function_decl
name|Q_CORE_EXPORT
name|QString
name|qtTrId
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|int
name|n
init|=
operator|-
literal|1
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|QT_TRID_NOOP
define|#
directive|define
name|QT_TRID_NOOP
parameter_list|(
name|id
parameter_list|)
value|id
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TRANSLATION
end_comment
begin_define
DECL|macro|QDOC_PROPERTY
define|#
directive|define
name|QDOC_PROPERTY
parameter_list|(
name|text
parameter_list|)
end_define
begin_comment
comment|/*    When RTTI is not available, define this macro to force any uses of    dynamic_cast to cause a compile failure. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_DYNAMIC_CAST
end_ifdef
begin_define
DECL|macro|dynamic_cast
define|#
directive|define
name|dynamic_cast
value|QT_PREPEND_NAMESPACE(qt_dynamic_cast_check)
end_define
begin_expr_stmt
DECL|variable|T
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|X
operator|>
DECL|function|qt_dynamic_cast_check
name|T
name|qt_dynamic_cast_check
argument_list|(
argument|X
argument_list|,
argument|T* =
literal|0
argument_list|)
block|{
return|return
name|T
operator|::
name|dynamic_cast_will_always_fail_because_rtti_is_disabled
return|;
block|}
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Some classes do not permit copies to be made of an object. These    classes contains a private copy constructor and assignment    operator to disable copying (the compiler gives an error message). */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_DEFAULT_DELETE_MEMBERS
end_ifdef
begin_define
DECL|macro|Q_DISABLE_COPY
define|#
directive|define
name|Q_DISABLE_COPY
parameter_list|(
name|Class
parameter_list|)
define|\
value|Class(const Class&) = delete;\     Class&operator=(const Class&) = delete;
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_DISABLE_COPY
define|#
directive|define
name|Q_DISABLE_COPY
parameter_list|(
name|Class
parameter_list|)
define|\
value|Class(const Class&); \     Class&operator=(const Class&);
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|QByteArray
name|class
name|QByteArray
decl_stmt|;
end_decl_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|QByteArray
name|qgetenv
parameter_list|(
specifier|const
name|char
modifier|*
name|varName
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|bool
name|qputenv
parameter_list|(
specifier|const
name|char
modifier|*
name|varName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|value
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|qIntCast
specifier|inline
name|int
name|qIntCast
parameter_list|(
name|double
name|f
parameter_list|)
block|{
return|return
name|int
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qIntCast
specifier|inline
name|int
name|qIntCast
parameter_list|(
name|float
name|f
parameter_list|)
block|{
return|return
name|int
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*   Reentrant versions of basic rand() functions for random number generation */
end_comment
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qsrand
parameter_list|(
name|uint
name|seed
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|int
name|qrand
parameter_list|()
function_decl|;
end_function_decl
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|SYMBIAN_BUILD_GCE
end_ifdef
begin_define
DECL|macro|Q_SYMBIAN_SUPPORTS_SURFACES
define|#
directive|define
name|Q_SYMBIAN_SUPPORTS_SURFACES
end_define
begin_comment
comment|//RWsPointerCursor is fixed, so don't use low performance sprites
end_comment
begin_define
DECL|macro|Q_SYMBIAN_FIXED_POINTER_CURSORS
define|#
directive|define
name|Q_SYMBIAN_FIXED_POINTER_CURSORS
end_define
begin_define
DECL|macro|Q_SYMBIAN_HAS_EXTENDED_BITMAP_TYPE
define|#
directive|define
name|Q_SYMBIAN_HAS_EXTENDED_BITMAP_TYPE
end_define
begin_define
DECL|macro|Q_SYMBIAN_WINDOW_SIZE_CACHE
define|#
directive|define
name|Q_SYMBIAN_WINDOW_SIZE_CACHE
end_define
begin_define
DECL|macro|QT_SYMBIAN_SUPPORTS_ADVANCED_POINTER
define|#
directive|define
name|QT_SYMBIAN_SUPPORTS_ADVANCED_POINTER
end_define
begin_comment
comment|//enabling new graphics resources
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|SYMBIAN_GRAPHICS_EGL_SGIMAGELITE
end_ifdef
begin_define
DECL|macro|QT_SYMBIAN_SUPPORTS_SGIMAGE
define|#
directive|define
name|QT_SYMBIAN_SUPPORTS_SGIMAGE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|SYMBIAN_GRAPHICS_SET_SURFACE_TRANSPARENCY_AVAILABLE
end_ifdef
begin_define
DECL|macro|Q_SYMBIAN_SEMITRANSPARENT_BG_SURFACE
define|#
directive|define
name|Q_SYMBIAN_SEMITRANSPARENT_BG_SURFACE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|SYMBIAN_GRAPHICS_TRANSITION_EFFECTS_SIGNALING_AVAILABLE
end_ifdef
begin_define
DECL|macro|Q_SYMBIAN_TRANSITION_EFFECTS
define|#
directive|define
name|Q_SYMBIAN_TRANSITION_EFFECTS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|SYMBIAN_WSERV_AND_CONE_MULTIPLE_SCREENS
end_ifdef
begin_define
DECL|macro|Q_SYMBIAN_SUPPORTS_MULTIPLE_SCREENS
define|#
directive|define
name|Q_SYMBIAN_SUPPORTS_MULTIPLE_SCREENS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|SYMBIAN_GRAPHICS_FIXNATIVEORIENTATION
end_ifdef
begin_define
DECL|macro|Q_SYMBIAN_SUPPORTS_FIXNATIVEORIENTATION
define|#
directive|define
name|Q_SYMBIAN_SUPPORTS_FIXNATIVEORIENTATION
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//Symbian does not support data imports from a DLL
end_comment
begin_define
DECL|macro|Q_NO_DATA_RELOCATION
define|#
directive|define
name|Q_NO_DATA_RELOCATION
end_define
begin_decl_stmt
name|QT_END_NAMESPACE
comment|// forward declare std::exception
ifdef|#
directive|ifdef
name|__cplusplus
name|namespace
name|std
block|{
name|class
name|exception
decl_stmt|;
block|}
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|Q_CORE_EXPORT
name|void
name|qt_symbian_throwIfError
parameter_list|(
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
name|Q_CORE_EXPORT
name|void
name|qt_symbian_exception2LeaveL
argument_list|(
specifier|const
name|std
operator|::
name|exception
operator|&
name|ex
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|Q_CORE_EXPORT
name|int
name|qt_symbian_exception2Error
argument_list|(
specifier|const
name|std
operator|::
name|exception
operator|&
name|ex
argument_list|)
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|QT_TRAP_THROWING
define|#
directive|define
name|QT_TRAP_THROWING
parameter_list|(
name|_f
parameter_list|)
define|\
value|{                                               \         TInt ____error;                             \         TRAP(____error, _f);                        \         qt_symbian_throwIfError(____error);                 \      }
end_define
begin_define
DECL|macro|QT_TRYCATCH_ERROR
define|#
directive|define
name|QT_TRYCATCH_ERROR
parameter_list|(
name|_err
parameter_list|,
name|_f
parameter_list|)
define|\
value|{                                                       \         _err = KErrNone;                                    \         try {                                               \             _f;                                             \         } catch (const std::exception&____ex) {            \             _err = qt_symbian_exception2Error(____ex);       \         }                                                   \     }
end_define
begin_define
DECL|macro|QT_TRYCATCH_LEAVING
define|#
directive|define
name|QT_TRYCATCH_LEAVING
parameter_list|(
name|_f
parameter_list|)
define|\
value|{                                                   \     TInt ____err;                                       \     QT_TRYCATCH_ERROR(____err, _f)                      \     User::LeaveIfError(____err);                        \     }
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    This gives us the possibility to check which modules the user can    use. These are purely compile time checks and will generate no code. */
end_comment
begin_comment
comment|/* Qt modules */
end_comment
begin_define
DECL|macro|QT_MODULE_CORE
define|#
directive|define
name|QT_MODULE_CORE
value|0x000001
end_define
begin_define
DECL|macro|QT_MODULE_GUI
define|#
directive|define
name|QT_MODULE_GUI
value|0x000002
end_define
begin_define
DECL|macro|QT_MODULE_NETWORK
define|#
directive|define
name|QT_MODULE_NETWORK
value|0x000004
end_define
begin_define
DECL|macro|QT_MODULE_OPENGL
define|#
directive|define
name|QT_MODULE_OPENGL
value|0x000008
end_define
begin_define
DECL|macro|QT_MODULE_SQL
define|#
directive|define
name|QT_MODULE_SQL
value|0x000010
end_define
begin_define
DECL|macro|QT_MODULE_XML
define|#
directive|define
name|QT_MODULE_XML
value|0x000020
end_define
begin_define
DECL|macro|QT_MODULE_SVG
define|#
directive|define
name|QT_MODULE_SVG
value|0x000100
end_define
begin_define
DECL|macro|QT_MODULE_ACTIVEQT
define|#
directive|define
name|QT_MODULE_ACTIVEQT
value|0x000200
end_define
begin_define
DECL|macro|QT_MODULE_GRAPHICSVIEW
define|#
directive|define
name|QT_MODULE_GRAPHICSVIEW
value|0x000400
end_define
begin_define
DECL|macro|QT_MODULE_SCRIPT
define|#
directive|define
name|QT_MODULE_SCRIPT
value|0x000800
end_define
begin_define
DECL|macro|QT_MODULE_XMLPATTERNS
define|#
directive|define
name|QT_MODULE_XMLPATTERNS
value|0x001000
end_define
begin_define
DECL|macro|QT_MODULE_HELP
define|#
directive|define
name|QT_MODULE_HELP
value|0x002000
end_define
begin_define
DECL|macro|QT_MODULE_TEST
define|#
directive|define
name|QT_MODULE_TEST
value|0x004000
end_define
begin_define
DECL|macro|QT_MODULE_DBUS
define|#
directive|define
name|QT_MODULE_DBUS
value|0x008000
end_define
begin_define
DECL|macro|QT_MODULE_SCRIPTTOOLS
define|#
directive|define
name|QT_MODULE_SCRIPTTOOLS
value|0x010000
end_define
begin_define
DECL|macro|QT_MODULE_OPENVG
define|#
directive|define
name|QT_MODULE_OPENVG
value|0x020000
end_define
begin_define
DECL|macro|QT_MODULE_MULTIMEDIA
define|#
directive|define
name|QT_MODULE_MULTIMEDIA
value|0x040000
end_define
begin_define
DECL|macro|QT_MODULE_DECLARATIVE
define|#
directive|define
name|QT_MODULE_DECLARATIVE
value|0x080000
end_define
begin_define
DECL|macro|QT_MODULE_LOCATION
define|#
directive|define
name|QT_MODULE_LOCATION
value|0x100000
end_define
begin_define
DECL|macro|QT_MODULE_SENSORS
define|#
directive|define
name|QT_MODULE_SENSORS
value|0x200000
end_define
begin_comment
comment|/* Qt editions */
end_comment
begin_define
DECL|macro|QT_EDITION_CONSOLE
define|#
directive|define
name|QT_EDITION_CONSOLE
value|(QT_MODULE_CORE \                                  | QT_MODULE_NETWORK \                                  | QT_MODULE_SQL \                                  | QT_MODULE_SCRIPT \                                  | QT_MODULE_MULTIMEDIA \                                  | QT_MODULE_XML \                                  | QT_MODULE_XMLPATTERNS \                                  | QT_MODULE_TEST \                                  | QT_MODULE_DBUS)
end_define
begin_define
DECL|macro|QT_EDITION_DESKTOPLIGHT
define|#
directive|define
name|QT_EDITION_DESKTOPLIGHT
value|(QT_MODULE_CORE \                                  | QT_MODULE_GUI \                                  | QT_MODULE_TEST \                                  | QT_MODULE_DBUS)
end_define
begin_define
DECL|macro|QT_EDITION_OPENSOURCE
define|#
directive|define
name|QT_EDITION_OPENSOURCE
value|(QT_MODULE_CORE \                                  | QT_MODULE_GUI \                                  | QT_MODULE_NETWORK \                                  | QT_MODULE_OPENGL \                                  | QT_MODULE_OPENVG \                                  | QT_MODULE_SQL \                                  | QT_MODULE_MULTIMEDIA \                                  | QT_MODULE_XML \                                  | QT_MODULE_XMLPATTERNS \                                  | QT_MODULE_SCRIPT \                                  | QT_MODULE_SCRIPTTOOLS \                                  | QT_MODULE_SVG \                                  | QT_MODULE_DECLARATIVE \                                  | QT_MODULE_GRAPHICSVIEW \                                  | QT_MODULE_HELP \                                  | QT_MODULE_TEST \                                  | QT_MODULE_DBUS \                                  | QT_MODULE_LOCATION \                                  | QT_MODULE_SENSORS \                                  | QT_MODULE_ACTIVEQT)
end_define
begin_define
DECL|macro|QT_EDITION_DESKTOP
define|#
directive|define
name|QT_EDITION_DESKTOP
value|(QT_EDITION_OPENSOURCE)
end_define
begin_define
DECL|macro|QT_EDITION_UNIVERSAL
define|#
directive|define
name|QT_EDITION_UNIVERSAL
value|QT_EDITION_DESKTOP
end_define
begin_define
DECL|macro|QT_EDITION_ACADEMIC
define|#
directive|define
name|QT_EDITION_ACADEMIC
value|QT_EDITION_DESKTOP
end_define
begin_define
DECL|macro|QT_EDITION_EDUCATIONAL
define|#
directive|define
name|QT_EDITION_EDUCATIONAL
value|QT_EDITION_DESKTOP
end_define
begin_define
DECL|macro|QT_EDITION_EVALUATION
define|#
directive|define
name|QT_EDITION_EVALUATION
value|QT_EDITION_DESKTOP
end_define
begin_comment
comment|/* Determine which modules can be used */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_EDITION
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|QT_BUILD_QMAKE
end_ifdef
begin_define
DECL|macro|QT_EDITION
define|#
directive|define
name|QT_EDITION
value|QT_EDITION_DESKTOP
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
literal|"Qt not configured correctly, please run configure"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QT_LICENSED_MODULE
define|#
directive|define
name|QT_LICENSED_MODULE
parameter_list|(
name|x
parameter_list|)
define|\
value|enum QtValidLicenseFor##x##Module { Licensed##x = true };
end_define
begin_comment
comment|/* qdoc is really unhappy with the following block of preprocessor checks,    making it difficult to document classes properly after this point. */
end_comment
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_CORE
operator|)
end_if
begin_macro
DECL|function|QT_LICENSED_MODULE
name|QT_LICENSED_MODULE
argument_list|(
argument|Core
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_GUI
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|Gui
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_NETWORK
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|Network
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_OPENGL
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|OpenGL
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_OPENVG
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|OpenVG
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_SQL
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|Sql
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_MULTIMEDIA
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|Multimedia
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_XML
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|Xml
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_XMLPATTERNS
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|XmlPatterns
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_HELP
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|Help
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_SCRIPT
operator|)
operator|||
name|defined
argument_list|(
name|QT_BUILD_QMAKE
argument_list|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|Script
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_SCRIPTTOOLS
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|ScriptTools
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_SVG
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|Svg
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_DECLARATIVE
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|Declarative
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_ACTIVEQT
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|ActiveQt
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_TEST
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|Test
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_DBUS
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|DBus
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_LOCATION
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|Location
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|QT_EDITION
operator|&
name|QT_MODULE_SENSORS
operator|)
end_if
begin_macro
name|QT_LICENSED_MODULE
argument_list|(
argument|Sensors
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QT_MODULE
define|#
directive|define
name|QT_MODULE
parameter_list|(
name|x
parameter_list|)
define|\
value|typedef QtValidLicenseFor##x##Module Qt##x##Module;
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_CONCURRENT
end_ifdef
begin_define
DECL|macro|QT_NO_QFUTURE
define|#
directive|define
name|QT_NO_QFUTURE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// gcc 3 version has problems with some of the
end_comment
begin_comment
comment|// map/filter overloads.
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|<
literal|4
operator|)
end_if
begin_define
DECL|macro|QT_NO_CONCURRENT_MAP
define|#
directive|define
name|QT_NO_CONCURRENT_MAP
end_define
begin_define
DECL|macro|QT_NO_CONCURRENT_FILTER
define|#
directive|define
name|QT_NO_CONCURRENT_FILTER
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_QNX
end_ifdef
begin_comment
comment|// QNX doesn't have SYSV style shared memory. Multiprocess QWS apps,
end_comment
begin_comment
comment|// shared fonts and QSystemSemaphore + QSharedMemory are not available
end_comment
begin_define
DECL|macro|QT_NO_QWS_MULTIPROCESS
define|#
directive|define
name|QT_NO_QWS_MULTIPROCESS
end_define
begin_define
DECL|macro|QT_NO_QWS_SHARE_FONTS
define|#
directive|define
name|QT_NO_QWS_SHARE_FONTS
end_define
begin_define
DECL|macro|QT_NO_SYSTEMSEMAPHORE
define|#
directive|define
name|QT_NO_SYSTEMSEMAPHORE
end_define
begin_define
DECL|macro|QT_NO_SHAREDMEMORY
define|#
directive|define
name|QT_NO_SHAREDMEMORY
end_define
begin_comment
comment|// QNX currently doesn't support forking in a thread, so disable QProcess
end_comment
begin_define
DECL|macro|QT_NO_PROCESS
define|#
directive|define
name|QT_NO_PROCESS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__ELF__
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_SOLARIS
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_FREEBSD
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_OPENBSD
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_IRIX
argument_list|)
end_if
begin_define
DECL|macro|Q_OF_ELF
define|#
directive|define
name|Q_OF_ELF
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|Q_WS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_WS_WINCE
argument_list|)
operator|)
expr|\
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|Q_WS_MAC
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_MAC_USE_COCOA
argument_list|)
operator|)
expr|\
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|Q_WS_X11
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_FREETYPE
argument_list|)
operator|)
expr|\
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|Q_WS_QPA
argument_list|)
operator|)
end_if
begin_define
DECL|macro|QT_NO_RAWFONT
define|#
directive|define
name|QT_NO_RAWFONT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|namespace
name|QtPrivate
block|{
comment|//like std::enable_if
name|template
operator|<
name|bool
name|B
operator|,
name|typename
name|T
operator|=
name|void
operator|>
expr|struct
name|QEnableIf
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|QEnableIf
operator|<
name|true
operator|,
name|T
operator|>
block|{
typedef|typedef
name|T
name|Type
typedef|;
block|}
empty_stmt|;
block|}
end_decl_stmt
begin_expr_stmt
name|QT_END_NAMESPACE
name|QT_END_HEADER
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __cplusplus */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* QGLOBAL_H */
end_comment
end_unit
