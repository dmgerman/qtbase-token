begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QGLOBAL_H
end_ifndef
begin_define
DECL|macro|QGLOBAL_H
define|#
directive|define
name|QGLOBAL_H
end_define
begin_include
include|#
directive|include
file|<stddef.h>
end_include
begin_define
DECL|macro|QT_VERSION_STR
define|#
directive|define
name|QT_VERSION_STR
value|"5.0.0"
end_define
begin_comment
comment|/*    QT_VERSION is (major<< 16) + (minor<< 8) + patch. */
end_comment
begin_define
DECL|macro|QT_VERSION
define|#
directive|define
name|QT_VERSION
value|0x050000
end_define
begin_comment
comment|/*    can be used like #if (QT_VERSION>= QT_VERSION_CHECK(4, 4, 0)) */
end_comment
begin_define
DECL|macro|QT_VERSION_CHECK
define|#
directive|define
name|QT_VERSION_CHECK
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|,
name|patch
parameter_list|)
value|((major<<16)|(minor<<8)|(patch))
end_define
begin_define
DECL|macro|QT_PACKAGEDATE_STR
define|#
directive|define
name|QT_PACKAGEDATE_STR
value|"YYYY-MM-DD"
end_define
begin_define
DECL|macro|QT_PACKAGE_TAG
define|#
directive|define
name|QT_PACKAGE_TAG
value|""
end_define
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_BUILD_MOC
argument_list|)
end_if
begin_include
include|#
directive|include
file|<QtCore/qconfig.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QtCore/qsystemdetection.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qcompilerdetection.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qprocessordetection.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_STL
end_ifndef
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NAMESPACE
end_ifndef
begin_comment
comment|/* user namespace */
end_comment
begin_define
DECL|macro|QT_PREPEND_NAMESPACE
define|#
directive|define
name|QT_PREPEND_NAMESPACE
parameter_list|(
name|name
parameter_list|)
value|::name
end_define
begin_define
DECL|macro|QT_USE_NAMESPACE
define|#
directive|define
name|QT_USE_NAMESPACE
end_define
begin_define
DECL|macro|QT_BEGIN_NAMESPACE
define|#
directive|define
name|QT_BEGIN_NAMESPACE
end_define
begin_define
DECL|macro|QT_END_NAMESPACE
define|#
directive|define
name|QT_END_NAMESPACE
end_define
begin_define
DECL|macro|QT_BEGIN_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_BEGIN_INCLUDE_NAMESPACE
end_define
begin_define
DECL|macro|QT_END_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_END_INCLUDE_NAMESPACE
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BEGIN_MOC_NAMESPACE
end_ifndef
begin_define
DECL|macro|QT_BEGIN_MOC_NAMESPACE
define|#
directive|define
name|QT_BEGIN_MOC_NAMESPACE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_END_MOC_NAMESPACE
end_ifndef
begin_define
DECL|macro|QT_END_MOC_NAMESPACE
define|#
directive|define
name|QT_END_MOC_NAMESPACE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QT_FORWARD_DECLARE_CLASS
define|#
directive|define
name|QT_FORWARD_DECLARE_CLASS
parameter_list|(
name|name
parameter_list|)
value|class name;
end_define
begin_define
DECL|macro|QT_FORWARD_DECLARE_STRUCT
define|#
directive|define
name|QT_FORWARD_DECLARE_STRUCT
parameter_list|(
name|name
parameter_list|)
value|struct name;
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE
define|#
directive|define
name|QT_MANGLE_NAMESPACE
parameter_list|(
name|name
parameter_list|)
value|name
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* user namespace */
end_comment
begin_define
DECL|macro|QT_PREPEND_NAMESPACE
define|#
directive|define
name|QT_PREPEND_NAMESPACE
parameter_list|(
name|name
parameter_list|)
value|::QT_NAMESPACE::name
end_define
begin_define
DECL|macro|QT_USE_NAMESPACE
define|#
directive|define
name|QT_USE_NAMESPACE
value|using namespace ::QT_NAMESPACE;
end_define
begin_define
DECL|macro|QT_BEGIN_NAMESPACE
define|#
directive|define
name|QT_BEGIN_NAMESPACE
value|namespace QT_NAMESPACE {
end_define
begin_define
DECL|macro|QT_END_NAMESPACE
define|#
directive|define
name|QT_END_NAMESPACE
value|}
end_define
begin_define
DECL|macro|QT_BEGIN_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_BEGIN_INCLUDE_NAMESPACE
value|}
end_define
begin_define
DECL|macro|QT_END_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_END_INCLUDE_NAMESPACE
value|namespace QT_NAMESPACE {
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BEGIN_MOC_NAMESPACE
end_ifndef
begin_define
DECL|macro|QT_BEGIN_MOC_NAMESPACE
define|#
directive|define
name|QT_BEGIN_MOC_NAMESPACE
value|QT_USE_NAMESPACE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_END_MOC_NAMESPACE
end_ifndef
begin_define
DECL|macro|QT_END_MOC_NAMESPACE
define|#
directive|define
name|QT_END_MOC_NAMESPACE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QT_FORWARD_DECLARE_CLASS
define|#
directive|define
name|QT_FORWARD_DECLARE_CLASS
parameter_list|(
name|name
parameter_list|)
define|\
value|QT_BEGIN_NAMESPACE class name; QT_END_NAMESPACE \     using QT_PREPEND_NAMESPACE(name);
end_define
begin_define
DECL|macro|QT_FORWARD_DECLARE_STRUCT
define|#
directive|define
name|QT_FORWARD_DECLARE_STRUCT
parameter_list|(
name|name
parameter_list|)
define|\
value|QT_BEGIN_NAMESPACE struct name; QT_END_NAMESPACE \     using QT_PREPEND_NAMESPACE(name);
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE0
define|#
directive|define
name|QT_MANGLE_NAMESPACE0
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE1
define|#
directive|define
name|QT_MANGLE_NAMESPACE1
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a##_##b
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE2
define|#
directive|define
name|QT_MANGLE_NAMESPACE2
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|QT_MANGLE_NAMESPACE1(a,b)
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE
define|#
directive|define
name|QT_MANGLE_NAMESPACE
parameter_list|(
name|name
parameter_list|)
value|QT_MANGLE_NAMESPACE2( \         QT_MANGLE_NAMESPACE0(name), QT_MANGLE_NAMESPACE0(QT_NAMESPACE))
end_define
begin_decl_stmt
name|namespace
name|QT_NAMESPACE
block|{}
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_USING_NAMESPACE
end_ifndef
begin_comment
comment|/*     This expands to a "using QT_NAMESPACE" also in _header files_.     It is the only way the feature can be used without too much     pain, but if people _really_ do not want it they can add     DEFINES += QT_NO_USING_NAMESPACE to their .pro files.     */
end_comment
begin_expr_stmt
name|QT_USE_NAMESPACE
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* user namespace */
else|#
directive|else
comment|/* __cplusplus */
define|#
directive|define
name|QT_BEGIN_NAMESPACE
define|#
directive|define
name|QT_END_NAMESPACE
define|#
directive|define
name|QT_USE_NAMESPACE
define|#
directive|define
name|QT_BEGIN_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_END_INCLUDE_NAMESPACE
endif|#
directive|endif
comment|/* __cplusplus */
DECL|macro|QT_BEGIN_HEADER
define|#
directive|define
name|QT_BEGIN_HEADER
DECL|macro|QT_END_HEADER
define|#
directive|define
name|QT_END_HEADER
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_LARGEFILE_SUPPORT
argument_list|)
DECL|macro|QT_LARGEFILE_SUPPORT
define|#
directive|define
name|QT_LARGEFILE_SUPPORT
value|64
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_PACKED
DECL|macro|Q_PACKED
define|#
directive|define
name|Q_PACKED
DECL|macro|Q_NO_PACKED_REFERENCE
undef|#
directive|undef
name|Q_NO_PACKED_REFERENCE
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_LIKELY
DECL|macro|Q_LIKELY
define|#
directive|define
name|Q_LIKELY
parameter_list|(
name|x
parameter_list|)
value|(x)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_UNLIKELY
DECL|macro|Q_UNLIKELY
define|#
directive|define
name|Q_UNLIKELY
parameter_list|(
name|x
parameter_list|)
value|(x)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_ALLOC_SIZE
DECL|macro|Q_ALLOC_SIZE
define|#
directive|define
name|Q_ALLOC_SIZE
parameter_list|(
name|x
parameter_list|)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_CONSTRUCTOR_FUNCTION
DECL|macro|Q_CONSTRUCTOR_FUNCTION0
define|#
directive|define
name|Q_CONSTRUCTOR_FUNCTION0
parameter_list|(
name|AFUNC
parameter_list|)
define|\
value|namespace { \     static const struct AFUNC ## _ctor_class_ { \         inline AFUNC ## _ctor_class_() { AFUNC(); } \     } AFUNC ## _ctor_instance_; \     }
DECL|macro|Q_CONSTRUCTOR_FUNCTION
define|#
directive|define
name|Q_CONSTRUCTOR_FUNCTION
parameter_list|(
name|AFUNC
parameter_list|)
value|Q_CONSTRUCTOR_FUNCTION0(AFUNC)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_DESTRUCTOR_FUNCTION
DECL|macro|Q_DESTRUCTOR_FUNCTION0
define|#
directive|define
name|Q_DESTRUCTOR_FUNCTION0
parameter_list|(
name|AFUNC
parameter_list|)
define|\
value|namespace { \     static const struct AFUNC ## _dtor_class_ { \         inline AFUNC ## _dtor_class_() { } \         inline ~ AFUNC ## _dtor_class_() { AFUNC(); } \     } AFUNC ## _dtor_instance_; \     }
DECL|macro|Q_DESTRUCTOR_FUNCTION
define|#
directive|define
name|Q_DESTRUCTOR_FUNCTION
parameter_list|(
name|AFUNC
parameter_list|)
value|Q_DESTRUCTOR_FUNCTION0(AFUNC)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Q_REQUIRED_RESULT
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>
literal|4
operator|||
operator|(
name|__GNUC__
operator|==
literal|4
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|1
operator|)
operator|)
DECL|macro|Q_REQUIRED_RESULT
define|#
directive|define
name|Q_REQUIRED_RESULT
value|__attribute__ ((warn_unused_result))
else|#
directive|else
define|#
directive|define
name|Q_REQUIRED_RESULT
endif|#
directive|endif
endif|#
directive|endif
name|QT_BEGIN_HEADER
name|QT_BEGIN_NAMESPACE
end_expr_stmt
begin_comment
comment|/*    Size-dependent types (architechture-dependent byte order)     Make sure to update QMetaType when changing these typedefs */
end_comment
begin_typedef
DECL|typedef|qint8
typedef|typedef
name|signed
name|char
name|qint8
typedef|;
end_typedef
begin_comment
DECL|typedef|qint8
comment|/* 8 bit signed */
end_comment
begin_typedef
DECL|typedef|quint8
typedef|typedef
name|unsigned
name|char
name|quint8
typedef|;
end_typedef
begin_comment
DECL|typedef|quint8
comment|/* 8 bit unsigned */
end_comment
begin_typedef
DECL|typedef|qint16
typedef|typedef
name|short
name|qint16
typedef|;
end_typedef
begin_comment
DECL|typedef|qint16
comment|/* 16 bit signed */
end_comment
begin_typedef
DECL|typedef|quint16
typedef|typedef
name|unsigned
name|short
name|quint16
typedef|;
end_typedef
begin_comment
DECL|typedef|quint16
comment|/* 16 bit unsigned */
end_comment
begin_typedef
DECL|typedef|qint32
typedef|typedef
name|int
name|qint32
typedef|;
end_typedef
begin_comment
DECL|typedef|qint32
comment|/* 32 bit signed */
end_comment
begin_typedef
DECL|typedef|quint32
typedef|typedef
name|unsigned
name|int
name|quint32
typedef|;
end_typedef
begin_comment
DECL|typedef|quint32
comment|/* 32 bit unsigned */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
end_if
begin_define
DECL|macro|Q_INT64_C
define|#
directive|define
name|Q_INT64_C
parameter_list|(
name|c
parameter_list|)
value|c ## i64
end_define
begin_comment
DECL|macro|Q_INT64_C
comment|/* signed 64 bit constant */
end_comment
begin_define
DECL|macro|Q_UINT64_C
define|#
directive|define
name|Q_UINT64_C
parameter_list|(
name|c
parameter_list|)
value|c ## ui64
end_define
begin_comment
DECL|macro|Q_UINT64_C
comment|/* unsigned 64 bit constant */
end_comment
begin_typedef
DECL|typedef|qint64
typedef|typedef
name|__int64
name|qint64
typedef|;
end_typedef
begin_comment
DECL|typedef|qint64
comment|/* 64 bit signed */
end_comment
begin_typedef
DECL|typedef|quint64
typedef|typedef
name|unsigned
name|__int64
name|quint64
typedef|;
end_typedef
begin_comment
DECL|typedef|quint64
comment|/* 64 bit unsigned */
end_comment
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_INT64_C
define|#
directive|define
name|Q_INT64_C
parameter_list|(
name|c
parameter_list|)
value|static_cast<long long>(c ## LL)
end_define
begin_comment
DECL|macro|Q_INT64_C
comment|/* signed 64 bit constant */
end_comment
begin_define
DECL|macro|Q_UINT64_C
define|#
directive|define
name|Q_UINT64_C
parameter_list|(
name|c
parameter_list|)
value|static_cast<unsigned long long>(c ## ULL)
end_define
begin_comment
DECL|macro|Q_UINT64_C
comment|/* unsigned 64 bit constant */
end_comment
begin_typedef
DECL|typedef|qint64
typedef|typedef
name|long
name|long
name|qint64
typedef|;
end_typedef
begin_comment
DECL|typedef|qint64
comment|/* 64 bit signed */
end_comment
begin_typedef
DECL|typedef|quint64
typedef|typedef
name|unsigned
name|long
name|long
name|quint64
typedef|;
end_typedef
begin_comment
DECL|typedef|quint64
comment|/* 64 bit unsigned */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|qlonglong
typedef|typedef
name|qint64
name|qlonglong
typedef|;
end_typedef
begin_typedef
DECL|typedef|qulonglong
typedef|typedef
name|quint64
name|qulonglong
typedef|;
end_typedef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_POINTER_SIZE
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN64
argument_list|)
end_if
begin_define
DECL|macro|QT_POINTER_SIZE
define|#
directive|define
name|QT_POINTER_SIZE
value|8
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_elif
begin_define
DECL|macro|QT_POINTER_SIZE
define|#
directive|define
name|QT_POINTER_SIZE
value|4
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Q_INIT_RESOURCE_EXTERN
define|#
directive|define
name|Q_INIT_RESOURCE_EXTERN
parameter_list|(
name|name
parameter_list|)
define|\
value|extern int QT_MANGLE_NAMESPACE(qInitResources_ ## name) ();
end_define
begin_define
DECL|macro|Q_INIT_RESOURCE
define|#
directive|define
name|Q_INIT_RESOURCE
parameter_list|(
name|name
parameter_list|)
define|\
value|do { extern int QT_MANGLE_NAMESPACE(qInitResources_ ## name) ();       \         QT_MANGLE_NAMESPACE(qInitResources_ ## name) (); } while (0)
end_define
begin_define
DECL|macro|Q_CLEANUP_RESOURCE
define|#
directive|define
name|Q_CLEANUP_RESOURCE
parameter_list|(
name|name
parameter_list|)
define|\
value|do { extern int QT_MANGLE_NAMESPACE(qCleanupResources_ ## name) ();    \         QT_MANGLE_NAMESPACE(qCleanupResources_ ## name) (); } while (0)
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if
begin_comment
comment|/*   quintptr and qptrdiff is guaranteed to be the same size as a pointer, i.e.        sizeof(void *) == sizeof(quintptr)&& sizeof(void *) == sizeof(qptrdiff) */
end_comment
begin_expr_stmt
name|template
operator|<
name|int
operator|>
expr|struct
name|QIntegerForSize
expr_stmt|;
end_expr_stmt
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
name|template
operator|<
operator|>
expr|struct
name|QIntegerForSize
operator|<
literal|1
operator|>
block|{
typedef|typedef
name|quint8
name|Unsigned
typedef|;
end_expr_stmt
begin_typedef
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
typedef|typedef
name|qint8
name|Signed
typedef|;
end_typedef
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
unit|};
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
name|template
operator|<
operator|>
expr|struct
name|QIntegerForSize
operator|<
literal|2
operator|>
block|{
typedef|typedef
name|quint16
name|Unsigned
typedef|;
end_expr_stmt
begin_typedef
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
typedef|typedef
name|qint16
name|Signed
typedef|;
end_typedef
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
unit|};
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
name|template
operator|<
operator|>
expr|struct
name|QIntegerForSize
operator|<
literal|4
operator|>
block|{
typedef|typedef
name|quint32
name|Unsigned
typedef|;
end_expr_stmt
begin_typedef
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
typedef|typedef
name|qint32
name|Signed
typedef|;
end_typedef
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
unit|};
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
name|template
operator|<
operator|>
expr|struct
name|QIntegerForSize
operator|<
literal|8
operator|>
block|{
typedef|typedef
name|quint64
name|Unsigned
typedef|;
end_expr_stmt
begin_typedef
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
typedef|typedef
name|qint64
name|Signed
typedef|;
end_typedef
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
unit|};
DECL|function|sizeof
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|QIntegerForSizeof
operator|:
name|QIntegerForSize
operator|<
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_typedef
DECL|typedef|quintptr
typedef|typedef
name|QIntegerForSizeof
operator|<
name|void
operator|*
operator|>
operator|::
name|Unsigned
name|quintptr
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|qptrdiff
typedef|typedef
name|QIntegerForSizeof
operator|<
name|void
operator|*
operator|>
operator|::
name|Signed
name|qptrdiff
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|qintptr
typedef|typedef
name|qptrdiff
name|qintptr
typedef|;
end_typedef
begin_comment
comment|/*    Useful type definitions for Qt */
end_comment
begin_macro
name|QT_BEGIN_INCLUDE_NAMESPACE
end_macro
begin_typedef
DECL|typedef|uchar
typedef|typedef
name|unsigned
name|char
name|uchar
typedef|;
end_typedef
begin_typedef
DECL|typedef|ushort
typedef|typedef
name|unsigned
name|short
name|ushort
typedef|;
end_typedef
begin_typedef
DECL|typedef|uint
typedef|typedef
name|unsigned
name|int
name|uint
typedef|;
end_typedef
begin_typedef
DECL|typedef|ulong
typedef|typedef
name|unsigned
name|long
name|ulong
typedef|;
end_typedef
begin_macro
name|QT_END_INCLUDE_NAMESPACE
end_macro
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_NO_BOOL_TYPE
argument_list|)
end_if
begin_error
error|#
directive|error
literal|"Compiler doesn't support the bool type"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Constant bool values */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_LINUXBASE
end_ifndef
begin_comment
comment|/* the LSB defines TRUE and FALSE for us */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef
begin_define
DECL|macro|TRUE
define|#
directive|define
name|TRUE
value|true
end_define
begin_define
DECL|macro|FALSE
define|#
directive|define
name|FALSE
value|false
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Proper for-scoping in MIPSpro CC */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_KEYWORDS
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MIPS
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|Q_CC_HPACC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__ia64
argument_list|)
operator|)
end_if
begin_define
DECL|macro|for
define|#
directive|define
name|for
value|if(0){}else for
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Workaround for static const members on MSVC++. */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
end_if
begin_define
DECL|macro|QT_STATIC_CONST
define|#
directive|define
name|QT_STATIC_CONST
value|static
end_define
begin_define
DECL|macro|QT_STATIC_CONST_IMPL
define|#
directive|define
name|QT_STATIC_CONST_IMPL
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_STATIC_CONST
value|static const
end_define
begin_define
define|#
directive|define
name|QT_STATIC_CONST_IMPL
value|const
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Warnings and errors when using deprecated methods */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_MOC_RUN
argument_list|)
end_if
begin_define
DECL|macro|Q_DECL_DEPRECATED
define|#
directive|define
name|Q_DECL_DEPRECATED
value|Q_DECL_DEPRECATED
end_define
begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|-
literal|0
operator|>
literal|3
operator|||
operator|(
name|__GNUC__
operator|-
literal|0
operator|==
literal|3
operator|&&
name|__GNUC_MINOR__
operator|-
literal|0
operator|>=
literal|2
operator|)
operator|)
operator|)
operator|||
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_elif
begin_define
define|#
directive|define
name|Q_DECL_DEPRECATED
value|__attribute__ ((__deprecated__))
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
end_elif
begin_define
define|#
directive|define
name|Q_DECL_DEPRECATED
value|__declspec(deprecated)
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
end_if
begin_define
define|#
directive|define
name|Q_DECL_VARIABLE_DEPRECATED
end_define
begin_else
else|#
directive|else
end_else
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|Q_DECL_DEPRECATED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_DECL_VARIABLE_DEPRECATED
end_ifndef
begin_define
DECL|macro|Q_DECL_VARIABLE_DEPRECATED
define|#
directive|define
name|Q_DECL_VARIABLE_DEPRECATED
value|Q_DECL_DEPRECATED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_DECL_CONSTRUCTOR_DEPRECATED
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_MOC_RUN
argument_list|)
end_if
begin_define
DECL|macro|Q_DECL_CONSTRUCTOR_DEPRECATED
define|#
directive|define
name|Q_DECL_CONSTRUCTOR_DEPRECATED
value|Q_DECL_CONSTRUCTOR_DEPRECATED
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_NO_DEPRECATED_CONSTRUCTORS
argument_list|)
end_elif
begin_define
define|#
directive|define
name|Q_DECL_CONSTRUCTOR_DEPRECATED
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|Q_DECL_CONSTRUCTOR_DEPRECATED
value|Q_DECL_DEPRECATED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEPRECATED
argument_list|)
end_if
begin_undef
DECL|macro|QT_DEPRECATED
undef|#
directive|undef
name|QT_DEPRECATED
end_undef
begin_undef
DECL|macro|QT_DEPRECATED_VARIABLE
undef|#
directive|undef
name|QT_DEPRECATED_VARIABLE
end_undef
begin_undef
DECL|macro|QT_DEPRECATED_CONSTRUCTOR
undef|#
directive|undef
name|QT_DEPRECATED_CONSTRUCTOR
end_undef
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_DEPRECATED_WARNINGS
argument_list|)
end_elif
begin_undef
undef|#
directive|undef
name|QT_DEPRECATED
end_undef
begin_define
define|#
directive|define
name|QT_DEPRECATED
value|Q_DECL_DEPRECATED
end_define
begin_undef
undef|#
directive|undef
name|QT_DEPRECATED_VARIABLE
end_undef
begin_define
define|#
directive|define
name|QT_DEPRECATED_VARIABLE
value|Q_DECL_VARIABLE_DEPRECATED
end_define
begin_undef
undef|#
directive|undef
name|QT_DEPRECATED_CONSTRUCTOR
end_undef
begin_define
define|#
directive|define
name|QT_DEPRECATED_CONSTRUCTOR
value|explicit Q_DECL_CONSTRUCTOR_DEPRECATED
end_define
begin_else
else|#
directive|else
end_else
begin_undef
undef|#
directive|undef
name|QT_DEPRECATED
end_undef
begin_define
define|#
directive|define
name|QT_DEPRECATED
end_define
begin_undef
undef|#
directive|undef
name|QT_DEPRECATED_VARIABLE
end_undef
begin_define
define|#
directive|define
name|QT_DEPRECATED_VARIABLE
end_define
begin_undef
undef|#
directive|undef
name|QT_DEPRECATED_CONSTRUCTOR
end_undef
begin_define
define|#
directive|define
name|QT_DEPRECATED_CONSTRUCTOR
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_DISABLE_DEPRECATED_BEFORE
end_ifndef
begin_comment
comment|// ### Qt5: remember to change that to 5 when we reach feature freeze
end_comment
begin_define
DECL|macro|QT_DISABLE_DEPRECATED_BEFORE
define|#
directive|define
name|QT_DISABLE_DEPRECATED_BEFORE
value|QT_VERSION_CHECK(4, 9, 0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*     QT_DEPRECATED_SINCE(major, minor) evaluates as true if the Qt version is greater than     the deprecation point specified.      Use it to specify from which version of Qt a function or class has been deprecated      Example:         #if QT_DEPRECATED_SINCE(5,1)             QT_DEPRECATED void deprecatedFunction(); //function deprecated since Qt 5.1         #endif  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_DEPRECATED
end_ifdef
begin_define
DECL|macro|QT_DEPRECATED_SINCE
define|#
directive|define
name|QT_DEPRECATED_SINCE
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
value|(QT_VERSION_CHECK(major, minor, 0)> QT_DISABLE_DEPRECATED_BEFORE)
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_DEPRECATED_SINCE
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* moc compats (signals/slots) */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_MOC_COMPAT
end_ifndef
begin_define
DECL|macro|QT_MOC_COMPAT
define|#
directive|define
name|QT_MOC_COMPAT
end_define
begin_else
else|#
directive|else
end_else
begin_undef
undef|#
directive|undef
name|QT_MOC_COMPAT
end_undef
begin_define
define|#
directive|define
name|QT_MOC_COMPAT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_ASCII_CAST_WARNINGS
end_ifdef
begin_define
DECL|macro|QT_ASCII_CAST_WARN
define|#
directive|define
name|QT_ASCII_CAST_WARN
value|Q_DECL_DEPRECATED
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
name|__GNUC__
operator|<
literal|4
end_if
begin_comment
comment|/* gcc< 4 doesn't like Q_DECL_DEPRECATED in front of constructors */
end_comment
begin_define
DECL|macro|QT_ASCII_CAST_WARN_CONSTRUCTOR
define|#
directive|define
name|QT_ASCII_CAST_WARN_CONSTRUCTOR
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_ASCII_CAST_WARN_CONSTRUCTOR
value|Q_DECL_CONSTRUCTOR_DEPRECATED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_ASCII_CAST_WARN
end_define
begin_define
define|#
directive|define
name|QT_ASCII_CAST_WARN_CONSTRUCTOR
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
end_if
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|&&
operator|(
operator|(
literal|100
operator|*
operator|(
name|__GNUC__
operator|-
literal|0
operator|)
operator|+
literal|10
operator|*
operator|(
name|__GNUC_MINOR__
operator|-
literal|0
operator|)
operator|+
name|__GNUC_PATCHLEVEL__
operator|)
operator|>=
literal|332
operator|)
end_if
begin_define
DECL|macro|QT_FASTCALL
define|#
directive|define
name|QT_FASTCALL
value|__attribute__((regparm(3)))
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_FASTCALL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
end_elif
begin_define
define|#
directive|define
name|QT_FASTCALL
value|__fastcall
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_FASTCALL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_FASTCALL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_NULLPTR
end_ifdef
begin_define
DECL|macro|Q_NULLPTR
define|#
directive|define
name|Q_NULLPTR
value|nullptr
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|Q_NULLPTR
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_DEFAULT_DELETE_MEMBERS
end_ifdef
begin_define
DECL|macro|Q_DECL_EQ_DELETE
define|#
directive|define
name|Q_DECL_EQ_DELETE
value|= delete
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|Q_DECL_EQ_DELETE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_CONSTEXPR
end_ifdef
begin_define
DECL|macro|Q_DECL_CONSTEXPR
define|#
directive|define
name|Q_DECL_CONSTEXPR
value|constexpr
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|Q_DECL_CONSTEXPR
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_EXPLICIT_OVERRIDES
end_ifdef
begin_define
DECL|macro|Q_DECL_OVERRIDE
define|#
directive|define
name|Q_DECL_OVERRIDE
value|override
end_define
begin_define
DECL|macro|Q_DECL_FINAL
define|#
directive|define
name|Q_DECL_FINAL
value|final
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|Q_DECL_OVERRIDE
end_define
begin_define
define|#
directive|define
name|Q_DECL_FINAL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//defines the type for the WNDPROC on windows
end_comment
begin_comment
comment|//the alignment needs to be forced for sse2 to not crash with mingw
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
end_if
begin_define
DECL|macro|QT_ENSURE_STACK_ALIGNED_FOR_SSE
define|#
directive|define
name|QT_ENSURE_STACK_ALIGNED_FOR_SSE
value|__attribute__ ((force_align_arg_pointer))
end_define
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|QT_ENSURE_STACK_ALIGNED_FOR_SSE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QT_WIN_CALLBACK
define|#
directive|define
name|QT_WIN_CALLBACK
value|CALLBACK QT_ENSURE_STACK_ALIGNED_FOR_SSE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|QNoImplicitBoolCast
typedef|typedef
name|int
name|QNoImplicitBoolCast
typedef|;
end_typedef
begin_comment
comment|// This logic must match the one in qmetatype.h
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_COORD_TYPE
argument_list|)
end_if
begin_typedef
DECL|typedef|qreal
typedef|typedef
name|QT_COORD_TYPE
name|qreal
typedef|;
end_typedef
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_NO_FPU
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_ARCH_ARM
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_ARCH_WINDOWSCE
argument_list|)
end_elif
begin_typedef
DECL|typedef|qreal
typedef|typedef
name|float
name|qreal
typedef|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_typedef
DECL|typedef|qreal
typedef|typedef
name|double
name|qreal
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Utility macros and inline functions */
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qAbs
name|Q_DECL_CONSTEXPR
specifier|inline
name|T
name|qAbs
argument_list|(
argument|const T&t
argument_list|)
block|{
return|return
name|t
operator|>=
literal|0
operator|?
name|t
operator|:
operator|-
name|t
return|;
block|}
end_expr_stmt
begin_function
DECL|function|qRound
name|Q_DECL_CONSTEXPR
specifier|inline
name|int
name|qRound
parameter_list|(
name|double
name|d
parameter_list|)
block|{
return|return
name|d
operator|>=
literal|0.0
condition|?
name|int
argument_list|(
name|d
operator|+
literal|0.5
argument_list|)
else|:
name|int
argument_list|(
name|d
operator|-
name|int
argument_list|(
name|d
operator|-
literal|1
argument_list|)
operator|+
literal|0.5
argument_list|)
operator|+
name|int
argument_list|(
name|d
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qRound
name|Q_DECL_CONSTEXPR
specifier|inline
name|int
name|qRound
parameter_list|(
name|float
name|d
parameter_list|)
block|{
return|return
name|d
operator|>=
literal|0.0f
condition|?
name|int
argument_list|(
name|d
operator|+
literal|0.5f
argument_list|)
else|:
name|int
argument_list|(
name|d
operator|-
name|int
argument_list|(
name|d
operator|-
literal|1
argument_list|)
operator|+
literal|0.5f
argument_list|)
operator|+
name|int
argument_list|(
name|d
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_QDOC
end_ifdef
begin_comment
comment|/*     Just for documentation generation */
end_comment
begin_function_decl
name|int
name|qRound
parameter_list|(
name|qreal
name|d
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qRound64
name|Q_DECL_CONSTEXPR
specifier|inline
name|qint64
name|qRound64
parameter_list|(
name|double
name|d
parameter_list|)
block|{
return|return
name|d
operator|>=
literal|0.0
condition|?
name|qint64
argument_list|(
name|d
operator|+
literal|0.5
argument_list|)
else|:
name|qint64
argument_list|(
name|d
operator|-
name|double
argument_list|(
name|qint64
argument_list|(
name|d
operator|-
literal|1
argument_list|)
argument_list|)
operator|+
literal|0.5
argument_list|)
operator|+
name|qint64
argument_list|(
name|d
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qRound64
name|Q_DECL_CONSTEXPR
specifier|inline
name|qint64
name|qRound64
parameter_list|(
name|float
name|d
parameter_list|)
block|{
return|return
name|d
operator|>=
literal|0.0f
condition|?
name|qint64
argument_list|(
name|d
operator|+
literal|0.5f
argument_list|)
else|:
name|qint64
argument_list|(
name|d
operator|-
name|float
argument_list|(
name|qint64
argument_list|(
name|d
operator|-
literal|1
argument_list|)
argument_list|)
operator|+
literal|0.5f
argument_list|)
operator|+
name|qint64
argument_list|(
name|d
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_QDOC
end_ifdef
begin_comment
comment|/*     Just for documentation generation */
end_comment
begin_function_decl
name|qint64
name|qRound64
parameter_list|(
name|qreal
name|d
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qMin
name|Q_DECL_CONSTEXPR
specifier|inline
specifier|const
name|T
operator|&
name|qMin
argument_list|(
argument|const T&a
argument_list|,
argument|const T&b
argument_list|)
block|{
return|return
operator|(
name|a
operator|<
name|b
operator|)
operator|?
name|a
operator|:
name|b
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qMax
name|Q_DECL_CONSTEXPR
specifier|inline
specifier|const
name|T
operator|&
name|qMax
argument_list|(
argument|const T&a
argument_list|,
argument|const T&b
argument_list|)
block|{
return|return
operator|(
name|a
operator|<
name|b
operator|)
operator|?
name|b
operator|:
name|a
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qBound
name|Q_DECL_CONSTEXPR
specifier|inline
specifier|const
name|T
operator|&
name|qBound
argument_list|(
argument|const T&min
argument_list|,
argument|const T&val
argument_list|,
argument|const T&max
argument_list|)
block|{
return|return
name|qMax
argument_list|(
name|min
argument_list|,
name|qMin
argument_list|(
name|max
argument_list|,
name|val
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_comment
comment|/*    Data stream functions are provided by many classes (defined in qdatastream.h) */
end_comment
begin_decl_stmt
DECL|variable|QDataStream
name|class
name|QDataStream
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_COP
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_COP
define|#
directive|define
name|QT_NO_COP
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_CRASHHANDLER
define|#
directive|define
name|QT_NO_CRASHHANDLER
end_define
begin_comment
DECL|macro|QT_NO_CRASHHANDLER
comment|// no popen
end_comment
begin_define
DECL|macro|QT_NO_PROCESS
define|#
directive|define
name|QT_NO_PROCESS
end_define
begin_comment
DECL|macro|QT_NO_PROCESS
comment|// no exec*, no fork
end_comment
begin_define
DECL|macro|QT_NO_LPR
define|#
directive|define
name|QT_NO_LPR
end_define
begin_define
DECL|macro|QT_NO_SHAREDMEMORY
define|#
directive|define
name|QT_NO_SHAREDMEMORY
end_define
begin_comment
DECL|macro|QT_NO_SHAREDMEMORY
comment|// only POSIX, no SysV and in the end...
end_comment
begin_define
DECL|macro|QT_NO_SYSTEMSEMAPHORE
define|#
directive|define
name|QT_NO_SYSTEMSEMAPHORE
end_define
begin_comment
DECL|macro|QT_NO_SYSTEMSEMAPHORE
comment|// not needed at all in a flat address space
end_comment
begin_define
DECL|macro|QT_NO_QWS_MULTIPROCESS
define|#
directive|define
name|QT_NO_QWS_MULTIPROCESS
end_define
begin_comment
DECL|macro|QT_NO_QWS_MULTIPROCESS
comment|// no processes
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QtCore/qfeatures.h>
end_include
begin_define
DECL|macro|QT_SUPPORTS
define|#
directive|define
name|QT_SUPPORTS
parameter_list|(
name|FEATURE
parameter_list|)
value|(!defined(QT_NO_##FEATURE))
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_if
begin_define
DECL|macro|Q_DECL_EXPORT
define|#
directive|define
name|Q_DECL_EXPORT
value|__attribute__((visibility("default")))
end_define
begin_define
DECL|macro|Q_DECL_IMPORT
define|#
directive|define
name|Q_DECL_IMPORT
value|__attribute__((visibility("default")))
end_define
begin_define
DECL|macro|Q_DECL_HIDDEN
define|#
directive|define
name|Q_DECL_HIDDEN
value|__attribute__((visibility("hidden")))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_DECL_EXPORT
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_if
begin_define
DECL|macro|Q_DECL_EXPORT
define|#
directive|define
name|Q_DECL_EXPORT
value|__declspec(dllexport)
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_VISIBILITY_AVAILABLE
argument_list|)
end_elif
begin_define
DECL|macro|Q_DECL_EXPORT
define|#
directive|define
name|Q_DECL_EXPORT
value|__attribute__((visibility("default")))
end_define
begin_define
DECL|macro|Q_DECL_HIDDEN
define|#
directive|define
name|Q_DECL_HIDDEN
value|__attribute__((visibility("hidden")))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_DECL_EXPORT
end_ifndef
begin_define
DECL|macro|Q_DECL_EXPORT
define|#
directive|define
name|Q_DECL_EXPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_DECL_IMPORT
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_if
begin_define
DECL|macro|Q_DECL_IMPORT
define|#
directive|define
name|Q_DECL_IMPORT
value|__declspec(dllimport)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_DECL_IMPORT
define|#
directive|define
name|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_DECL_HIDDEN
end_ifndef
begin_define
DECL|macro|Q_DECL_HIDDEN
define|#
directive|define
name|Q_DECL_HIDDEN
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Create Qt DLL if QT_DLL is defined (Windows only) */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NODLL
argument_list|)
end_if
begin_undef
DECL|macro|QT_MAKEDLL
undef|#
directive|undef
name|QT_MAKEDLL
end_undef
begin_undef
DECL|macro|QT_DLL
undef|#
directive|undef
name|QT_DLL
end_undef
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_MAKEDLL
argument_list|)
end_elif
begin_comment
comment|/* create a Qt DLL library */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_DLL
argument_list|)
end_if
begin_undef
DECL|macro|QT_DLL
undef|#
directive|undef
name|QT_DLL
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_CORE_EXPORT
define|#
directive|define
name|Q_CORE_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CORE_EXPORT
define|#
directive|define
name|Q_CORE_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_GUI_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_GUI_EXPORT
define|#
directive|define
name|Q_GUI_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_GUI_EXPORT
define|#
directive|define
name|Q_GUI_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_WIDGETS_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_WIDGETS_EXPORT
define|#
directive|define
name|Q_WIDGETS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_WIDGETS_EXPORT
define|#
directive|define
name|Q_WIDGETS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_PLATFORMSUPPORT_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_PLATFORMSUPPORT_EXPORT
define|#
directive|define
name|Q_PLATFORMSUPPORT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_PLATFORMSUPPORT_EXPORT
define|#
directive|define
name|Q_PLATFORMSUPPORT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_PRINTSUPPORT_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_PRINTSUPPORT_EXPORT
define|#
directive|define
name|Q_PRINTSUPPORT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_PRINTSUPPORT_EXPORT
define|#
directive|define
name|Q_PRINTSUPPORT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_SQL_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_SQL_EXPORT
define|#
directive|define
name|Q_SQL_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_SQL_EXPORT
define|#
directive|define
name|Q_SQL_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_NETWORK_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_NETWORK_EXPORT
define|#
directive|define
name|Q_NETWORK_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_NETWORK_EXPORT
define|#
directive|define
name|Q_NETWORK_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_SVG_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_SVG_EXPORT
define|#
directive|define
name|Q_SVG_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_SVG_EXPORT
define|#
directive|define
name|Q_SVG_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_QTQUICK1_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_QTQUICK1_EXPORT
define|#
directive|define
name|Q_QTQUICK1_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_QTQUICK1_EXPORT
define|#
directive|define
name|Q_QTQUICK1_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_DECLARATIVE_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_DECLARATIVE_EXPORT
define|#
directive|define
name|Q_DECLARATIVE_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_DECLARATIVE_EXPORT
define|#
directive|define
name|Q_DECLARATIVE_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_OPENGL_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_OPENGL_EXPORT
define|#
directive|define
name|Q_OPENGL_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_OPENGL_EXPORT
define|#
directive|define
name|Q_OPENGL_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_MULTIMEDIA_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_MULTIMEDIA_EXPORT
define|#
directive|define
name|Q_MULTIMEDIA_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_MULTIMEDIA_EXPORT
define|#
directive|define
name|Q_MULTIMEDIA_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_OPENVG_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_OPENVG_EXPORT
define|#
directive|define
name|Q_OPENVG_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_OPENVG_EXPORT
define|#
directive|define
name|Q_OPENVG_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_XML_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_XML_EXPORT
define|#
directive|define
name|Q_XML_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_XML_EXPORT
define|#
directive|define
name|Q_XML_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_XMLPATTERNS_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_XMLPATTERNS_EXPORT
define|#
directive|define
name|Q_XMLPATTERNS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_XMLPATTERNS_EXPORT
define|#
directive|define
name|Q_XMLPATTERNS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_SCRIPT_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_SCRIPT_EXPORT
define|#
directive|define
name|Q_SCRIPT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_SCRIPT_EXPORT
define|#
directive|define
name|Q_SCRIPT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_SCRIPTTOOLS_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_SCRIPTTOOLS_EXPORT
define|#
directive|define
name|Q_SCRIPTTOOLS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_SCRIPTTOOLS_EXPORT
define|#
directive|define
name|Q_SCRIPTTOOLS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_CANVAS_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_CANVAS_EXPORT
define|#
directive|define
name|Q_CANVAS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CANVAS_EXPORT
define|#
directive|define
name|Q_CANVAS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_COMPAT_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_COMPAT_EXPORT
define|#
directive|define
name|Q_COMPAT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_COMPAT_EXPORT
define|#
directive|define
name|Q_COMPAT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_DBUS_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_DBUS_EXPORT
define|#
directive|define
name|Q_DBUS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_DBUS_EXPORT
define|#
directive|define
name|Q_DBUS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Q_TEMPLATEDLL
define|#
directive|define
name|Q_TEMPLATEDLL
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_CONCURRENT_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_CONCURRENT_EXPORT
define|#
directive|define
name|Q_CONCURRENT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CONCURRENT_EXPORT
define|#
directive|define
name|Q_CONCURRENT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_DLL
argument_list|)
end_elif
begin_comment
comment|/* use a Qt DLL library */
end_comment
begin_define
DECL|macro|Q_CORE_EXPORT
define|#
directive|define
name|Q_CORE_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_GUI_EXPORT
define|#
directive|define
name|Q_GUI_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_WIDGETS_EXPORT
define|#
directive|define
name|Q_WIDGETS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_PLATFORMSUPPORT_EXPORT
define|#
directive|define
name|Q_PLATFORMSUPPORT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_PRINTSUPPORT_EXPORT
define|#
directive|define
name|Q_PRINTSUPPORT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_SQL_EXPORT
define|#
directive|define
name|Q_SQL_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_NETWORK_EXPORT
define|#
directive|define
name|Q_NETWORK_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_SVG_EXPORT
define|#
directive|define
name|Q_SVG_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_DECLARATIVE_EXPORT
define|#
directive|define
name|Q_DECLARATIVE_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_QTQUICK1_EXPORT
define|#
directive|define
name|Q_QTQUICK1_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_CANVAS_EXPORT
define|#
directive|define
name|Q_CANVAS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_OPENGL_EXPORT
define|#
directive|define
name|Q_OPENGL_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_MULTIMEDIA_EXPORT
define|#
directive|define
name|Q_MULTIMEDIA_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_OPENVG_EXPORT
define|#
directive|define
name|Q_OPENVG_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_XML_EXPORT
define|#
directive|define
name|Q_XML_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_XMLPATTERNS_EXPORT
define|#
directive|define
name|Q_XMLPATTERNS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_SCRIPT_EXPORT
define|#
directive|define
name|Q_SCRIPT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_SCRIPTTOOLS_EXPORT
define|#
directive|define
name|Q_SCRIPTTOOLS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_COMPAT_EXPORT
define|#
directive|define
name|Q_COMPAT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_DBUS_EXPORT
define|#
directive|define
name|Q_DBUS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_CONCURRENT_EXPORT
define|#
directive|define
name|Q_CONCURRENT_EXPORT
value|Q_DECL_IMPORT
end_define
begin_define
DECL|macro|Q_TEMPLATEDLL
define|#
directive|define
name|Q_TEMPLATEDLL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Q_NO_DECLARED_NOT_DEFINED
define|#
directive|define
name|Q_NO_DECLARED_NOT_DEFINED
end_define
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_BOR
argument_list|)
end_if
begin_define
DECL|macro|Q_TEMPLATEDLL
define|#
directive|define
name|Q_TEMPLATEDLL
end_define
begin_define
DECL|macro|Q_NO_DECLARED_NOT_DEFINED
define|#
directive|define
name|Q_NO_DECLARED_NOT_DEFINED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|QT_MAKEDLL
undef|#
directive|undef
name|QT_MAKEDLL
end_undef
begin_comment
DECL|macro|QT_MAKEDLL
comment|/* ignore these for other platforms */
end_comment
begin_undef
DECL|macro|QT_DLL
undef|#
directive|undef
name|QT_DLL
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CORE_EXPORT
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_SHARED
argument_list|)
end_if
begin_define
DECL|macro|Q_CORE_EXPORT
define|#
directive|define
name|Q_CORE_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_GUI_EXPORT
define|#
directive|define
name|Q_GUI_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_WIDGETS_EXPORT
define|#
directive|define
name|Q_WIDGETS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_PLATFORMSUPPORT_EXPORT
define|#
directive|define
name|Q_PLATFORMSUPPORT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_PRINTSUPPORT_EXPORT
define|#
directive|define
name|Q_PRINTSUPPORT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_SQL_EXPORT
define|#
directive|define
name|Q_SQL_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_NETWORK_EXPORT
define|#
directive|define
name|Q_NETWORK_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_SVG_EXPORT
define|#
directive|define
name|Q_SVG_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_DECLARATIVE_EXPORT
define|#
directive|define
name|Q_DECLARATIVE_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_QTQUICK1_EXPORT
define|#
directive|define
name|Q_QTQUICK1_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_OPENGL_EXPORT
define|#
directive|define
name|Q_OPENGL_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_MULTIMEDIA_EXPORT
define|#
directive|define
name|Q_MULTIMEDIA_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_OPENVG_EXPORT
define|#
directive|define
name|Q_OPENVG_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_XML_EXPORT
define|#
directive|define
name|Q_XML_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_XMLPATTERNS_EXPORT
define|#
directive|define
name|Q_XMLPATTERNS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_SCRIPT_EXPORT
define|#
directive|define
name|Q_SCRIPT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_SCRIPTTOOLS_EXPORT
define|#
directive|define
name|Q_SCRIPTTOOLS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_COMPAT_EXPORT
define|#
directive|define
name|Q_COMPAT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_DBUS_EXPORT
define|#
directive|define
name|Q_DBUS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_define
DECL|macro|Q_CONCURRENT_EXPORT
define|#
directive|define
name|Q_CONCURRENT_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CORE_EXPORT
define|#
directive|define
name|Q_CORE_EXPORT
end_define
begin_define
DECL|macro|Q_GUI_EXPORT
define|#
directive|define
name|Q_GUI_EXPORT
end_define
begin_define
DECL|macro|Q_WIDGETS_EXPORT
define|#
directive|define
name|Q_WIDGETS_EXPORT
end_define
begin_define
DECL|macro|Q_PLATFORMSUPPORT_EXPORT
define|#
directive|define
name|Q_PLATFORMSUPPORT_EXPORT
end_define
begin_define
DECL|macro|Q_PRINTSUPPORT_EXPORT
define|#
directive|define
name|Q_PRINTSUPPORT_EXPORT
end_define
begin_define
DECL|macro|Q_SQL_EXPORT
define|#
directive|define
name|Q_SQL_EXPORT
end_define
begin_define
DECL|macro|Q_NETWORK_EXPORT
define|#
directive|define
name|Q_NETWORK_EXPORT
end_define
begin_define
DECL|macro|Q_SVG_EXPORT
define|#
directive|define
name|Q_SVG_EXPORT
end_define
begin_define
DECL|macro|Q_DECLARATIVE_EXPORT
define|#
directive|define
name|Q_DECLARATIVE_EXPORT
end_define
begin_define
DECL|macro|Q_QTQUICK1_EXPORT
define|#
directive|define
name|Q_QTQUICK1_EXPORT
end_define
begin_define
DECL|macro|Q_OPENGL_EXPORT
define|#
directive|define
name|Q_OPENGL_EXPORT
end_define
begin_define
DECL|macro|Q_MULTIMEDIA_EXPORT
define|#
directive|define
name|Q_MULTIMEDIA_EXPORT
end_define
begin_define
DECL|macro|Q_OPENVG_EXPORT
define|#
directive|define
name|Q_OPENVG_EXPORT
end_define
begin_define
DECL|macro|Q_XML_EXPORT
define|#
directive|define
name|Q_XML_EXPORT
end_define
begin_define
DECL|macro|Q_XMLPATTERNS_EXPORT
define|#
directive|define
name|Q_XMLPATTERNS_EXPORT
end_define
begin_define
DECL|macro|Q_SCRIPT_EXPORT
define|#
directive|define
name|Q_SCRIPT_EXPORT
end_define
begin_define
DECL|macro|Q_SCRIPTTOOLS_EXPORT
define|#
directive|define
name|Q_SCRIPTTOOLS_EXPORT
end_define
begin_define
DECL|macro|Q_COMPAT_EXPORT
define|#
directive|define
name|Q_COMPAT_EXPORT
end_define
begin_define
DECL|macro|Q_DBUS_EXPORT
define|#
directive|define
name|Q_DBUS_EXPORT
end_define
begin_define
DECL|macro|Q_CONCURRENT_EXPORT
define|#
directive|define
name|Q_CONCURRENT_EXPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Functions marked as Q_GUI_EXPORT_INLINE were exported and inlined by mistake.
end_comment
begin_comment
comment|// Compilers like MinGW complain that the import attribute is ignored.
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_CORE_EXPORT_INLINE
define|#
directive|define
name|Q_CORE_EXPORT_INLINE
value|Q_CORE_EXPORT inline
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CORE_EXPORT_INLINE
define|#
directive|define
name|Q_CORE_EXPORT_INLINE
value|inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_GUI_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_GUI_EXPORT_INLINE
define|#
directive|define
name|Q_GUI_EXPORT_INLINE
value|Q_GUI_EXPORT inline
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_GUI_EXPORT_INLINE
define|#
directive|define
name|Q_GUI_EXPORT_INLINE
value|inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_WIDGETS_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_WIDGETS_EXPORT_INLINE
define|#
directive|define
name|Q_WIDGETS_EXPORT_INLINE
value|Q_WIDGETS_EXPORT inline
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_WIDGETS_EXPORT_INLINE
define|#
directive|define
name|Q_WIDGETS_EXPORT_INLINE
value|inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_PLATFORMSUPPORT_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_PLATFORMSUPPORT_EXPORT_INLINE
define|#
directive|define
name|Q_PLATFORMSUPPORT_EXPORT_INLINE
value|Q_PLATFORMSUPPORT_EXPORT inline
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_PLATFORMSUPPORT_EXPORT_INLINE
define|#
directive|define
name|Q_PLATFORMSUPPORT_EXPORT_INLINE
value|inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_PRINTSUPPORT_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_PRINTSUPPORT_EXPORT_INLINE
define|#
directive|define
name|Q_PRINTSUPPORT_EXPORT_INLINE
value|Q_PRINTSUPPORT_EXPORT inline
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_PRINTSUPPORT_EXPORT_INLINE
define|#
directive|define
name|Q_PRINTSUPPORT_EXPORT_INLINE
value|inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_COMPAT_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_COMPAT_EXPORT_INLINE
define|#
directive|define
name|Q_COMPAT_EXPORT_INLINE
value|Q_COMPAT_EXPORT inline
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_COMPAT_EXPORT_INLINE
define|#
directive|define
name|Q_COMPAT_EXPORT_INLINE
value|inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_elif
begin_comment
comment|// we force RVCT not to export inlines by passing --visibility_inlines_hidden
end_comment
begin_comment
comment|// so we need to just inline it, rather than exporting and inlining
end_comment
begin_comment
comment|// note: this affects the contents of the DEF files (ie. these functions do not appear)
end_comment
begin_define
DECL|macro|Q_CORE_EXPORT_INLINE
define|#
directive|define
name|Q_CORE_EXPORT_INLINE
value|inline
end_define
begin_define
DECL|macro|Q_GUI_EXPORT_INLINE
define|#
directive|define
name|Q_GUI_EXPORT_INLINE
value|inline
end_define
begin_define
DECL|macro|Q_WIDGETS_EXPORT_INLINE
define|#
directive|define
name|Q_WIDGETS_EXPORT_INLINE
value|inline
end_define
begin_define
DECL|macro|Q_PLATFORMSUPPORT_EXPORT_INLINE
define|#
directive|define
name|Q_PLATFORMSUPPORT_EXPORT_INLINE
value|inline
end_define
begin_define
DECL|macro|Q_PRINTSUPPORT_EXPORT_INLINE
define|#
directive|define
name|Q_PRINTSUPPORT_EXPORT_INLINE
value|inline
end_define
begin_define
DECL|macro|Q_COMPAT_EXPORT_INLINE
define|#
directive|define
name|Q_COMPAT_EXPORT_INLINE
value|inline
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CORE_EXPORT_INLINE
define|#
directive|define
name|Q_CORE_EXPORT_INLINE
value|Q_CORE_EXPORT inline
end_define
begin_define
DECL|macro|Q_GUI_EXPORT_INLINE
define|#
directive|define
name|Q_GUI_EXPORT_INLINE
value|Q_GUI_EXPORT inline
end_define
begin_define
DECL|macro|Q_WIDGETS_EXPORT_INLINE
define|#
directive|define
name|Q_WIDGETS_EXPORT_INLINE
value|Q_WIDGETS_EXPORT inline
end_define
begin_define
DECL|macro|Q_PLATFORMSUPPORT_EXPORT_INLINE
define|#
directive|define
name|Q_PLATFORMSUPPORT_EXPORT_INLINE
value|Q_PLATFORMSUPPORT_EXPORT inline
end_define
begin_define
DECL|macro|Q_PRINTSUPPORT_EXPORT_INLINE
define|#
directive|define
name|Q_PRINTSUPPORT_EXPORT_INLINE
value|Q_PRINTSUPPORT_EXPORT inline
end_define
begin_define
DECL|macro|Q_COMPAT_EXPORT_INLINE
define|#
directive|define
name|Q_COMPAT_EXPORT_INLINE
value|Q_COMPAT_EXPORT inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    No, this is not an evil backdoor. QT_BUILD_INTERNAL just exports more symbols    for Qt's internal unit tests. If you want slower loading times and more    symbols that can vanish from version to version, feel free to define QT_BUILD_INTERNAL. */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_INTERNAL
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_MAKEDLL
argument_list|)
end_if
begin_define
DECL|macro|Q_AUTOTEST_EXPORT
define|#
directive|define
name|Q_AUTOTEST_EXPORT
value|Q_DECL_EXPORT
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_BUILD_INTERNAL
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_DLL
argument_list|)
end_elif
begin_define
DECL|macro|Q_AUTOTEST_EXPORT
define|#
directive|define
name|Q_AUTOTEST_EXPORT
value|Q_DECL_IMPORT
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_BUILD_INTERNAL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_SHARED
argument_list|)
end_elif
begin_define
DECL|macro|Q_AUTOTEST_EXPORT
define|#
directive|define
name|Q_AUTOTEST_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_AUTOTEST_EXPORT
define|#
directive|define
name|Q_AUTOTEST_EXPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qt_noop
specifier|inline
name|void
name|qt_noop
parameter_list|(
name|void
parameter_list|)
block|{}
end_function
begin_comment
comment|/* These wrap try/catch so we can switch off exceptions later.     Beware - do not use more than one QT_CATCH per QT_TRY, and do not use    the exception instance in the catch block.    If you can't live with those constraints, don't use these macros.    Use the QT_NO_EXCEPTIONS macro to protect your code instead. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_BOOTSTRAPPED
end_ifdef
begin_define
DECL|macro|QT_NO_EXCEPTIONS
define|#
directive|define
name|QT_NO_EXCEPTIONS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_EXCEPTIONS
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__EXCEPTIONS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_MOC_RUN
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_EXCEPTIONS
define|#
directive|define
name|QT_NO_EXCEPTIONS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_EXCEPTIONS
end_ifdef
begin_define
DECL|macro|QT_TRY
define|#
directive|define
name|QT_TRY
value|if (true)
end_define
begin_define
DECL|macro|QT_CATCH
define|#
directive|define
name|QT_CATCH
parameter_list|(
name|A
parameter_list|)
value|else
end_define
begin_define
DECL|macro|QT_THROW
define|#
directive|define
name|QT_THROW
parameter_list|(
name|A
parameter_list|)
value|qt_noop()
end_define
begin_define
DECL|macro|QT_RETHROW
define|#
directive|define
name|QT_RETHROW
value|qt_noop()
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_TRY
define|#
directive|define
name|QT_TRY
value|try
end_define
begin_define
DECL|macro|QT_CATCH
define|#
directive|define
name|QT_CATCH
parameter_list|(
name|A
parameter_list|)
value|catch (A)
end_define
begin_define
DECL|macro|QT_THROW
define|#
directive|define
name|QT_THROW
parameter_list|(
name|A
parameter_list|)
value|throw A
end_define
begin_define
DECL|macro|QT_RETHROW
define|#
directive|define
name|QT_RETHROW
value|throw
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    System information */
end_comment
begin_decl_stmt
DECL|variable|QString
name|class
name|QString
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|class
name|Q_CORE_EXPORT
name|QSysInfo
block|{
name|public
label|:
enum|enum
name|Sizes
block|{
name|WordSize
init|=
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|<<
literal|3
operator|)
block|}
enum|;
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_QMAKE
argument_list|)
enum|enum
name|Endian
block|{
name|BigEndian
block|,
name|LittleEndian
block|}
enum|;
comment|/* needed to bootstrap qmake */
specifier|static
specifier|const
name|int
name|ByteOrder
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_BYTE_ORDER
argument_list|)
enum|enum
name|Endian
block|{
name|BigEndian
block|,
name|LittleEndian
ifdef|#
directive|ifdef
name|qdoc
block|,
name|ByteOrder
init|=
operator|<
name|platform
operator|-
name|dependent
operator|>
elif|#
directive|elif
name|Q_BYTE_ORDER
operator|==
name|Q_BIG_ENDIAN
block|,
name|ByteOrder
init|=
name|BigEndian
elif|#
directive|elif
name|Q_BYTE_ORDER
operator|==
name|Q_LITTLE_ENDIAN
block|,
name|ByteOrder
init|=
name|LittleEndian
else|#
directive|else
error|#
directive|error
literal|"Undefined byte order"
endif|#
directive|endif
block|}
enum|;
else|#
directive|else
error|#
directive|error
literal|"Qt not configured correctly, please run configure"
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_CYGWIN
argument_list|)
enum|enum
name|WinVersion
block|{
name|WV_32s
init|=
literal|0x0001
block|,
name|WV_95
init|=
literal|0x0002
block|,
name|WV_98
init|=
literal|0x0003
block|,
name|WV_Me
init|=
literal|0x0004
block|,
name|WV_DOS_based
init|=
literal|0x000f
block|,
comment|/* codenames */
name|WV_NT
init|=
literal|0x0010
block|,
name|WV_2000
init|=
literal|0x0020
block|,
name|WV_XP
init|=
literal|0x0030
block|,
name|WV_2003
init|=
literal|0x0040
block|,
name|WV_VISTA
init|=
literal|0x0080
block|,
name|WV_WINDOWS7
init|=
literal|0x0090
block|,
name|WV_NT_based
init|=
literal|0x00f0
block|,
comment|/* version numbers */
name|WV_4_0
init|=
name|WV_NT
block|,
name|WV_5_0
init|=
name|WV_2000
block|,
name|WV_5_1
init|=
name|WV_XP
block|,
name|WV_5_2
init|=
name|WV_2003
block|,
name|WV_6_0
init|=
name|WV_VISTA
block|,
name|WV_6_1
init|=
name|WV_WINDOWS7
block|,
name|WV_CE
init|=
literal|0x0100
block|,
name|WV_CENET
init|=
literal|0x0200
block|,
name|WV_CE_5
init|=
literal|0x0300
block|,
name|WV_CE_6
init|=
literal|0x0400
block|,
name|WV_CE_based
init|=
literal|0x0f00
block|}
enum|;
specifier|static
specifier|const
name|WinVersion
name|WindowsVersion
decl_stmt|;
specifier|static
name|WinVersion
name|windowsVersion
parameter_list|()
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_MAC
enum|enum
name|MacVersion
block|{
name|MV_Unknown
init|=
literal|0x0000
block|,
comment|/* version */
name|MV_9
init|=
literal|0x0001
block|,
name|MV_10_0
init|=
literal|0x0002
block|,
name|MV_10_1
init|=
literal|0x0003
block|,
name|MV_10_2
init|=
literal|0x0004
block|,
name|MV_10_3
init|=
literal|0x0005
block|,
name|MV_10_4
init|=
literal|0x0006
block|,
name|MV_10_5
init|=
literal|0x0007
block|,
name|MV_10_6
init|=
literal|0x0008
block|,
name|MV_10_7
init|=
literal|0x0009
block|,
comment|/* codenames */
name|MV_CHEETAH
init|=
name|MV_10_0
block|,
name|MV_PUMA
init|=
name|MV_10_1
block|,
name|MV_JAGUAR
init|=
name|MV_10_2
block|,
name|MV_PANTHER
init|=
name|MV_10_3
block|,
name|MV_TIGER
init|=
name|MV_10_4
block|,
name|MV_LEOPARD
init|=
name|MV_10_5
block|,
name|MV_SNOWLEOPARD
init|=
name|MV_10_6
block|,
name|MV_LION
init|=
name|MV_10_7
block|}
enum|;
specifier|static
specifier|const
name|MacVersion
name|MacintoshVersion
decl_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_function_decl
name|Q_CORE_EXPORT
specifier|const
name|char
modifier|*
name|qVersion
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|bool
name|qSharedBuild
parameter_list|()
function_decl|;
end_function_decl
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
end_if
begin_function
DECL|function|qMacVersion
specifier|inline
name|int
name|qMacVersion
parameter_list|()
block|{
return|return
name|QSysInfo
operator|::
name|MacintoshVersion
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OUTOFLINE_TEMPLATE
end_ifndef
begin_define
DECL|macro|Q_OUTOFLINE_TEMPLATE
define|#
directive|define
name|Q_OUTOFLINE_TEMPLATE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_INLINE_TEMPLATE
end_ifndef
begin_define
DECL|macro|Q_INLINE_TEMPLATE
define|#
directive|define
name|Q_INLINE_TEMPLATE
value|inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Avoid "unused parameter" warnings */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_if
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qUnused
specifier|inline
name|void
name|qUnused
argument_list|(
argument|T&x
argument_list|)
block|{
operator|(
name|void
operator|)
name|x
block|; }
DECL|macro|Q_UNUSED
define|#
directive|define
name|Q_UNUSED
parameter_list|(
name|x
parameter_list|)
value|qUnused(x);
else|#
directive|else
DECL|macro|Q_UNUSED
define|#
directive|define
name|Q_UNUSED
parameter_list|(
name|x
parameter_list|)
value|(void)x;
endif|#
directive|endif
comment|/*    Debugging and error handling */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
DECL|macro|QT_DEBUG
define|#
directive|define
name|QT_DEBUG
endif|#
directive|endif
ifndef|#
directive|ifndef
name|qPrintable
DECL|macro|qPrintable
define|#
directive|define
name|qPrintable
parameter_list|(
name|string
parameter_list|)
value|QString(string).toLocal8Bit().constData()
endif|#
directive|endif
DECL|variable|QString
name|class
name|QString
expr_stmt|;
end_expr_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|QString
name|qt_error_string
parameter_list|(
name|int
name|errorCode
init|=
operator|-
literal|1
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qErrnoWarning
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qErrnoWarning
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qt_assert
parameter_list|(
specifier|const
name|char
modifier|*
name|assertion
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_ASSERT
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_FORCE_ASSERTS
argument_list|)
end_if
begin_define
DECL|macro|Q_ASSERT
define|#
directive|define
name|Q_ASSERT
parameter_list|(
name|cond
parameter_list|)
value|qt_noop()
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_ASSERT
define|#
directive|define
name|Q_ASSERT
parameter_list|(
name|cond
parameter_list|)
value|((!(cond)) ? qt_assert(#cond,__FILE__,__LINE__) : qt_noop())
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_PAINT_DEBUG
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_PAINT_DEBUG
define|#
directive|define
name|QT_NO_PAINT_DEBUG
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qt_assert_x
parameter_list|(
specifier|const
name|char
modifier|*
name|where
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_ASSERT_X
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_FORCE_ASSERTS
argument_list|)
end_if
begin_define
DECL|macro|Q_ASSERT_X
define|#
directive|define
name|Q_ASSERT_X
parameter_list|(
name|cond
parameter_list|,
name|where
parameter_list|,
name|what
parameter_list|)
value|qt_noop()
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_ASSERT_X
define|#
directive|define
name|Q_ASSERT_X
parameter_list|(
name|cond
parameter_list|,
name|where
parameter_list|,
name|what
parameter_list|)
value|((!(cond)) ? qt_assert_x(where, what,__FILE__,__LINE__) : qt_noop())
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_STATIC_ASSERT
end_ifdef
begin_define
DECL|macro|Q_STATIC_ASSERT
define|#
directive|define
name|Q_STATIC_ASSERT
parameter_list|(
name|Condition
parameter_list|)
value|static_assert(bool(Condition), #Condition)
end_define
begin_define
DECL|macro|Q_STATIC_ASSERT_X
define|#
directive|define
name|Q_STATIC_ASSERT_X
parameter_list|(
name|Condition
parameter_list|,
name|Message
parameter_list|)
value|static_assert(bool(Condition), Message)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|// Intentionally undefined
end_comment
begin_expr_stmt
DECL|variable|QStaticAssertFailure
name|template
operator|<
name|bool
name|Test
operator|>
name|class
name|QStaticAssertFailure
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|class
name|QStaticAssertFailure
operator|<
name|true
operator|>
block|{}
expr_stmt|;
end_expr_stmt
begin_define
DECL|macro|Q_STATIC_ASSERT_PRIVATE_JOIN
define|#
directive|define
name|Q_STATIC_ASSERT_PRIVATE_JOIN
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|Q_STATIC_ASSERT_PRIVATE_JOIN_IMPL(A, B)
end_define
begin_define
DECL|macro|Q_STATIC_ASSERT_PRIVATE_JOIN_IMPL
define|#
directive|define
name|Q_STATIC_ASSERT_PRIVATE_JOIN_IMPL
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|A ## B
end_define
begin_define
DECL|macro|Q_STATIC_ASSERT
define|#
directive|define
name|Q_STATIC_ASSERT
parameter_list|(
name|Condition
parameter_list|)
define|\
value|enum {Q_STATIC_ASSERT_PRIVATE_JOIN(q_static_assert_result, __LINE__) = sizeof(QStaticAssertFailure<(Condition)>)}
end_define
begin_define
DECL|macro|Q_STATIC_ASSERT_X
define|#
directive|define
name|Q_STATIC_ASSERT_X
parameter_list|(
name|Condition
parameter_list|,
name|Message
parameter_list|)
value|Q_STATIC_ASSERT(Condition)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qt_check_pointer
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qBadAlloc
parameter_list|()
function_decl|;
end_function_decl
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_EXCEPTIONS
end_ifdef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
end_if
begin_define
DECL|macro|Q_CHECK_PTR
define|#
directive|define
name|Q_CHECK_PTR
parameter_list|(
name|p
parameter_list|)
value|qt_noop()
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CHECK_PTR
define|#
directive|define
name|Q_CHECK_PTR
parameter_list|(
name|p
parameter_list|)
value|do {if(!(p))qt_check_pointer(__FILE__,__LINE__);} while (0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CHECK_PTR
define|#
directive|define
name|Q_CHECK_PTR
parameter_list|(
name|p
parameter_list|)
value|do { if (!(p)) qBadAlloc(); } while (0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|q_check_ptr
specifier|inline
name|T
operator|*
name|q_check_ptr
argument_list|(
argument|T *p
argument_list|)
block|{
name|Q_CHECK_PTR
argument_list|(
name|p
argument_list|)
block|;
return|return
name|p
return|;
block|}
end_expr_stmt
begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_SOLARIS
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|Q_CC_HPACC
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_DIAB
argument_list|)
end_if
begin_define
DECL|macro|Q_FUNC_INFO
define|#
directive|define
name|Q_FUNC_INFO
value|__PRETTY_FUNCTION__
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_elif
begin_define
DECL|macro|Q_FUNC_INFO
define|#
directive|define
name|Q_FUNC_INFO
value|__FUNCSIG__
end_define
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SOLARIS
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_XLC
argument_list|)
end_if
begin_define
DECL|macro|Q_FUNC_INFO
define|#
directive|define
name|Q_FUNC_INFO
value|__FILE__ "(line number unavailable)"
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* These two macros makes it possible to turn the builtin line expander into a          * string literal. */
end_comment
begin_define
DECL|macro|QT_STRINGIFY2
define|#
directive|define
name|QT_STRINGIFY2
parameter_list|(
name|x
parameter_list|)
value|#x
end_define
begin_define
DECL|macro|QT_STRINGIFY
define|#
directive|define
name|QT_STRINGIFY
parameter_list|(
name|x
parameter_list|)
value|QT_STRINGIFY2(x)
end_define
begin_define
DECL|macro|Q_FUNC_INFO
define|#
directive|define
name|Q_FUNC_INFO
value|__FILE__ ":" QT_STRINGIFY(__LINE__)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* The MIPSpro and RVCT compilers postpones macro expansion,        and therefore macros must be in scope when being used. */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CC_MIPS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_if
begin_undef
DECL|macro|QT_STRINGIFY2
undef|#
directive|undef
name|QT_STRINGIFY2
end_undef
begin_undef
DECL|macro|QT_STRINGIFY
undef|#
directive|undef
name|QT_STRINGIFY
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|QFunctionPointer
typedef|typedef
name|void
function_decl|(
modifier|*
name|QFunctionPointer
function_decl|)
parameter_list|()
function_decl|;
end_typedef
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_UNIMPLEMENTED
argument_list|)
end_if
begin_define
DECL|macro|Q_UNIMPLEMENTED
define|#
directive|define
name|Q_UNIMPLEMENTED
parameter_list|()
value|qWarning("%s:%d: %s: Unimplemented code.", __FILE__, __LINE__, Q_FUNC_INFO)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_THREAD
argument_list|)
end_if
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QGlobalStatic
block|{
name|public
operator|:
name|T
operator|*
name|pointer
block|;
specifier|inline
name|QGlobalStatic
argument_list|(
name|T
operator|*
name|p
argument_list|)
operator|:
name|pointer
argument_list|(
argument|p
argument_list|)
block|{ }
specifier|inline
operator|~
name|QGlobalStatic
argument_list|()
block|{
name|pointer
operator|=
literal|0
block|; }
block|}
expr_stmt|;
end_expr_stmt
begin_define
DECL|macro|Q_GLOBAL_STATIC
define|#
directive|define
name|Q_GLOBAL_STATIC
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|)
define|\
value|static TYPE *NAME()                                              \     {                                                                \         static TYPE thisVariable;                                    \         static QGlobalStatic<TYPE> thisGlobalStatic(&thisVariable); \         return thisGlobalStatic.pointer;                             \     }
end_define
begin_define
DECL|macro|Q_GLOBAL_STATIC_WITH_ARGS
define|#
directive|define
name|Q_GLOBAL_STATIC_WITH_ARGS
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|,
name|ARGS
parameter_list|)
define|\
value|static TYPE *NAME()                                              \     {                                                                \         static TYPE thisVariable ARGS;                               \         static QGlobalStatic<TYPE> thisGlobalStatic(&thisVariable); \         return thisGlobalStatic.pointer;                             \     }
end_define
begin_define
DECL|macro|Q_GLOBAL_STATIC_WITH_INITIALIZER
define|#
directive|define
name|Q_GLOBAL_STATIC_WITH_INITIALIZER
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|,
name|INITIALIZER
parameter_list|)
define|\
value|static TYPE *NAME()                                              \     {                                                                \         static TYPE thisVariable;                                    \         static QGlobalStatic<TYPE> thisGlobalStatic(0);             \         if (!thisGlobalStatic.pointer) {                             \             TYPE *x = thisGlobalStatic.pointer =&thisVariable;      \             INITIALIZER;                                             \         }                                                            \         return thisGlobalStatic.pointer;                             \     }
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|// forward declaration, since qatomic.h needs qglobal.h
end_comment
begin_expr_stmt
DECL|variable|QBasicAtomicPointer
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QBasicAtomicPointer
expr_stmt|;
end_expr_stmt
begin_comment
comment|// POD for Q_GLOBAL_STATIC
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QGlobalStatic
block|{
name|public
operator|:
name|QBasicAtomicPointer
operator|<
name|T
operator|>
name|pointer
block|;
name|bool
name|destroyed
block|; }
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Created as a function-local static to delete a QGlobalStatic<T>
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QGlobalStaticDeleter
block|{
name|public
operator|:
name|QGlobalStatic
operator|<
name|T
operator|>
operator|&
name|globalStatic
block|;
name|QGlobalStaticDeleter
argument_list|(
name|QGlobalStatic
operator|<
name|T
operator|>
operator|&
name|_globalStatic
argument_list|)
operator|:
name|globalStatic
argument_list|(
argument|_globalStatic
argument_list|)
block|{ }
specifier|inline
operator|~
name|QGlobalStaticDeleter
argument_list|()
block|{
name|delete
name|globalStatic
operator|.
name|pointer
operator|.
name|load
argument_list|()
block|;
name|globalStatic
operator|.
name|pointer
operator|.
name|store
argument_list|(
literal|0
argument_list|)
block|;
name|globalStatic
operator|.
name|destroyed
operator|=
name|true
block|;     }
block|}
expr_stmt|;
end_expr_stmt
begin_define
DECL|macro|Q_GLOBAL_STATIC
define|#
directive|define
name|Q_GLOBAL_STATIC
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|)
define|\
value|static TYPE *NAME()                                                       \     {                                                                         \         static QGlobalStatic<TYPE> thisGlobalStatic                          \                             = { Q_BASIC_ATOMIC_INITIALIZER(0), false };       \         if (!thisGlobalStatic.pointer.load()&& !thisGlobalStatic.destroyed) { \             TYPE *x = new TYPE;                                               \             if (!thisGlobalStatic.pointer.testAndSetOrdered(0, x))            \                 delete x;                                                     \             else                                                              \                 static QGlobalStaticDeleter<TYPE> cleanup(thisGlobalStatic); \         }                                                                     \         return thisGlobalStatic.pointer.load();                               \     }
end_define
begin_define
DECL|macro|Q_GLOBAL_STATIC_WITH_ARGS
define|#
directive|define
name|Q_GLOBAL_STATIC_WITH_ARGS
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|,
name|ARGS
parameter_list|)
define|\
value|static TYPE *NAME()                                                       \     {                                                                         \         static QGlobalStatic<TYPE> thisGlobalStatic                          \                             = { Q_BASIC_ATOMIC_INITIALIZER(0), false };       \         if (!thisGlobalStatic.pointer.load()&& !thisGlobalStatic.destroyed) {       \             TYPE *x = new TYPE ARGS;                                          \             if (!thisGlobalStatic.pointer.testAndSetOrdered(0, x))            \                 delete x;                                                     \             else                                                              \                 static QGlobalStaticDeleter<TYPE> cleanup(thisGlobalStatic); \         }                                                                     \         return thisGlobalStatic.pointer.load();                               \     }
end_define
begin_define
DECL|macro|Q_GLOBAL_STATIC_WITH_INITIALIZER
define|#
directive|define
name|Q_GLOBAL_STATIC_WITH_INITIALIZER
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|,
name|INITIALIZER
parameter_list|)
define|\
value|static TYPE *NAME()                                                       \     {                                                                         \         static QGlobalStatic<TYPE> thisGlobalStatic                          \                             = { Q_BASIC_ATOMIC_INITIALIZER(0), false };       \         if (!thisGlobalStatic.pointer.load()&& !thisGlobalStatic.destroyed) {       \             QScopedPointer<TYPE> x(new TYPE);                                \             INITIALIZER;                                                      \             if (thisGlobalStatic.pointer.testAndSetOrdered(0, x.data())) {    \                 static QGlobalStaticDeleter<TYPE> cleanup(thisGlobalStatic); \                 x.take();                                                     \             }                                                                 \         }                                                                     \         return thisGlobalStatic.pointer.load();                               \     }
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qFuzzyCompare
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyCompare
parameter_list|(
name|double
name|p1
parameter_list|,
name|double
name|p2
parameter_list|)
block|{
return|return
operator|(
name|qAbs
argument_list|(
name|p1
operator|-
name|p2
argument_list|)
operator|<=
literal|0.000000000001
operator|*
name|qMin
argument_list|(
name|qAbs
argument_list|(
name|p1
argument_list|)
argument_list|,
name|qAbs
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|qFuzzyCompare
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyCompare
parameter_list|(
name|float
name|p1
parameter_list|,
name|float
name|p2
parameter_list|)
block|{
return|return
operator|(
name|qAbs
argument_list|(
name|p1
operator|-
name|p2
argument_list|)
operator|<=
literal|0.00001f
operator|*
name|qMin
argument_list|(
name|qAbs
argument_list|(
name|p1
argument_list|)
argument_list|,
name|qAbs
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|qFuzzyIsNull
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyIsNull
parameter_list|(
name|double
name|d
parameter_list|)
block|{
return|return
name|qAbs
argument_list|(
name|d
argument_list|)
operator|<=
literal|0.000000000001
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|qFuzzyIsNull
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyIsNull
parameter_list|(
name|float
name|f
parameter_list|)
block|{
return|return
name|qAbs
argument_list|(
name|f
argument_list|)
operator|<=
literal|0.00001f
return|;
block|}
end_function
begin_comment
comment|/*    This function tests a double for a null value. It doesn't    check whether the actual value is 0 or close to 0, but whether    it is binary 0. */
end_comment
begin_function
DECL|function|qIsNull
specifier|static
specifier|inline
name|bool
name|qIsNull
parameter_list|(
name|double
name|d
parameter_list|)
block|{
union|union
name|U
block|{
name|double
name|d
decl_stmt|;
name|quint64
name|u
decl_stmt|;
block|}
union|;
name|U
name|val
decl_stmt|;
name|val
operator|.
name|d
operator|=
name|d
expr_stmt|;
return|return
name|val
operator|.
name|u
operator|==
name|quint64
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*    This function tests a float for a null value. It doesn't    check whether the actual value is 0 or close to 0, but whether    it is binary 0. */
end_comment
begin_function
DECL|function|qIsNull
specifier|static
specifier|inline
name|bool
name|qIsNull
parameter_list|(
name|float
name|f
parameter_list|)
block|{
union|union
name|U
block|{
name|float
name|f
decl_stmt|;
name|quint32
name|u
decl_stmt|;
block|}
union|;
name|U
name|val
decl_stmt|;
name|val
operator|.
name|f
operator|=
name|f
expr_stmt|;
return|return
name|val
operator|.
name|u
operator|==
literal|0u
return|;
block|}
end_function
begin_comment
comment|/*    Compilers which follow outdated template instantiation rules    require a class to have a comparison operator to exist when    a QList of this type is instantiated. It's not actually    used in the list, though. Hence the dummy implementation.    Just in case other code relies on it we better trigger a warning    mandating a real implementation. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_FULL_TEMPLATE_INSTANTIATION
end_ifdef
begin_define
DECL|macro|Q_DUMMY_COMPARISON_OPERATOR
define|#
directive|define
name|Q_DUMMY_COMPARISON_OPERATOR
parameter_list|(
name|C
parameter_list|)
define|\
value|bool operator==(const C&) const { \         qWarning(#C"::operator==(const "#C"&) was called"); \         return false; \     }
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_DUMMY_COMPARISON_OPERATOR
define|#
directive|define
name|Q_DUMMY_COMPARISON_OPERATOR
parameter_list|(
name|C
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    QTypeInfo     - type trait functionality    qIsDetached   - data sharing functionality */
end_comment
begin_comment
comment|/*   The catch-all template. */
end_comment
begin_expr_stmt
DECL|function|qIsDetached
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|bool
name|qIsDetached
argument_list|(
argument|T&
argument_list|)
block|{
return|return
name|true
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QTypeInfo
block|{
name|public
operator|:
expr|enum
block|{
name|isPointer
operator|=
name|false
block|,
name|isComplex
operator|=
name|true
block|,
name|isStatic
operator|=
name|true
block|,
name|isLarge
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
block|,
name|isDummy
operator|=
name|false
block|,
name|sizeOf
operator|=
expr|sizeof
operator|(
name|T
operator|)
block|}
block|; }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|class
name|QTypeInfo
operator|<
name|void
operator|>
block|{
name|public
operator|:
expr|enum
block|{
name|isPointer
operator|=
name|false
block|,
name|isComplex
operator|=
name|false
block|,
name|isStatic
operator|=
name|false
block|,
name|isLarge
operator|=
name|false
block|,
name|isDummy
operator|=
name|false
block|,
name|sizeOf
operator|=
literal|0
block|}
block|; }
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QTypeInfo
operator|<
name|T
operator|*
operator|>
block|{
name|public
operator|:
expr|enum
block|{
name|isPointer
operator|=
name|true
block|,
name|isComplex
operator|=
name|false
block|,
name|isStatic
operator|=
name|false
block|,
name|isLarge
operator|=
name|false
block|,
name|isDummy
operator|=
name|false
block|,
name|sizeOf
operator|=
expr|sizeof
operator|(
name|T
operator|*
operator|)
block|}
block|; }
expr_stmt|;
end_expr_stmt
begin_define
DECL|macro|Q_DECLARE_MOVABLE_CONTAINER
define|#
directive|define
name|Q_DECLARE_MOVABLE_CONTAINER
parameter_list|(
name|CONTAINER
parameter_list|)
define|\
value|template<typename T> class CONTAINER; \ template<typename T> \ class QTypeInfo< CONTAINER<T>> \ { \ public: \     enum { \         isPointer = false, \         isComplex = true, \         isStatic = false, \         isLarge = (sizeof(CONTAINER<T>)> sizeof(void*)), \         isDummy = false, \         sizeOf = sizeof(CONTAINER<T>) \     }; \ };
end_define
begin_macro
DECL|function|Q_DECLARE_MOVABLE_CONTAINER
name|Q_DECLARE_MOVABLE_CONTAINER
argument_list|(
argument|QList
argument_list|)
end_macro
begin_macro
name|Q_DECLARE_MOVABLE_CONTAINER
argument_list|(
argument|QVector
argument_list|)
end_macro
begin_macro
name|Q_DECLARE_MOVABLE_CONTAINER
argument_list|(
argument|QQueue
argument_list|)
end_macro
begin_macro
name|Q_DECLARE_MOVABLE_CONTAINER
argument_list|(
argument|QStack
argument_list|)
end_macro
begin_macro
name|Q_DECLARE_MOVABLE_CONTAINER
argument_list|(
argument|QLinkedList
argument_list|)
end_macro
begin_expr_stmt
name|Q_DECLARE_MOVABLE_CONTAINER
argument_list|(
name|QSet
argument_list|)
DECL|macro|Q_DECLARE_MOVABLE_CONTAINER
undef|#
directive|undef
name|Q_DECLARE_MOVABLE_CONTAINER
comment|/*    Specialize a specific type with:       Q_DECLARE_TYPEINFO(type, flags);     where 'type' is the name of the type to specialize and 'flags' is    logically-OR'ed combination of the flags below. */
expr|enum
block|{
comment|/* TYPEINFO flags */
name|Q_COMPLEX_TYPE
operator|=
literal|0
block|,
name|Q_PRIMITIVE_TYPE
operator|=
literal|0x1
block|,
name|Q_STATIC_TYPE
operator|=
literal|0
block|,
name|Q_MOVABLE_TYPE
operator|=
literal|0x2
block|,
name|Q_DUMMY_TYPE
operator|=
literal|0x4
block|}
expr_stmt|;
end_expr_stmt
begin_define
DECL|macro|Q_DECLARE_TYPEINFO_BODY
define|#
directive|define
name|Q_DECLARE_TYPEINFO_BODY
parameter_list|(
name|TYPE
parameter_list|,
name|FLAGS
parameter_list|)
define|\
value|class QTypeInfo<TYPE> \ { \ public: \     enum { \         isComplex = (((FLAGS)& Q_PRIMITIVE_TYPE) == 0), \         isStatic = (((FLAGS)& (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), \         isLarge = (sizeof(TYPE)>sizeof(void*)), \         isPointer = false, \         isDummy = (((FLAGS)& Q_DUMMY_TYPE) != 0), \         sizeOf = sizeof(TYPE) \     }; \     static inline const char *name() { return #TYPE; } \ }
end_define
begin_define
DECL|macro|Q_DECLARE_TYPEINFO
define|#
directive|define
name|Q_DECLARE_TYPEINFO
parameter_list|(
name|TYPE
parameter_list|,
name|FLAGS
parameter_list|)
define|\
value|template<> \ Q_DECLARE_TYPEINFO_BODY(TYPE, FLAGS)
end_define
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qSwap
specifier|inline
name|void
name|qSwap
argument_list|(
argument|T&value1
argument_list|,
argument|T&value2
argument_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_STL
specifier|const
name|T
name|t
operator|=
name|value1
block|;
name|value1
operator|=
name|value2
block|;
name|value2
operator|=
name|t
block|;
else|#
directive|else
name|using
name|std
operator|::
name|swap
block|;
name|swap
argument_list|(
name|value1
argument_list|,
name|value2
argument_list|)
block|;
endif|#
directive|endif
block|}
comment|/*    Specialize a shared type with:       Q_DECLARE_SHARED(type);     where 'type' is the name of the type to specialize.  NOTE: shared    types must declare a 'bool isDetached(void) const;' member for this    to work. */
ifdef|#
directive|ifdef
name|QT_NO_STL
DECL|macro|Q_DECLARE_SHARED_STL
define|#
directive|define
name|Q_DECLARE_SHARED_STL
parameter_list|(
name|TYPE
parameter_list|)
else|#
directive|else
DECL|macro|Q_DECLARE_SHARED_STL
define|#
directive|define
name|Q_DECLARE_SHARED_STL
parameter_list|(
name|TYPE
parameter_list|)
define|\
value|QT_END_NAMESPACE \ namespace std { \     template<> inline void swap<QT_PREPEND_NAMESPACE(TYPE)>(QT_PREPEND_NAMESPACE(TYPE)&value1, QT_PREPEND_NAMESPACE(TYPE)&value2) \     { swap(value1.data_ptr(), value2.data_ptr()); } \ } \ QT_BEGIN_NAMESPACE
endif|#
directive|endif
DECL|macro|Q_DECLARE_SHARED
define|#
directive|define
name|Q_DECLARE_SHARED
parameter_list|(
name|TYPE
parameter_list|)
define|\
value|template<> inline bool qIsDetached<TYPE>(TYPE&t) { return t.isDetached(); } \ template<> inline void qSwap<TYPE>(TYPE&value1, TYPE&value2) \ { qSwap(value1.data_ptr(), value2.data_ptr()); } \ Q_DECLARE_SHARED_STL(TYPE)
comment|/*    QTypeInfo primitive specializations */
name|Q_DECLARE_TYPEINFO
argument_list|(
name|bool
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|char
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_macro
name|Q_DECLARE_TYPEINFO
argument_list|(
argument|signed char
argument_list|,
argument|Q_PRIMITIVE_TYPE
argument_list|)
end_macro
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|uchar
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|short
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|ushort
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|int
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|uint
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|long
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|ulong
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|qint64
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|quint64
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|float
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|double
argument_list|,
name|Q_PRIMITIVE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OS_DARWIN
end_ifndef
begin_macro
name|Q_DECLARE_TYPEINFO
argument_list|(
argument|long double
argument_list|,
argument|Q_PRIMITIVE_TYPE
argument_list|)
end_macro
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    These functions make it possible to use standard C++ functions with    a similar name from Qt header files (especially template classes). */
end_comment
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qMalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|Q_ALLOC_SIZE
parameter_list|(
function_decl|1
end_function_decl
begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qFree
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qRealloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|Q_ALLOC_SIZE
parameter_list|(
function_decl|2
end_function_decl
begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qMallocAligned
parameter_list|(
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|)
function_decl|Q_ALLOC_SIZE
parameter_list|(
function_decl|1
end_function_decl
begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qReallocAligned
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|alignment
parameter_list|)
function_decl|Q_ALLOC_SIZE
parameter_list|(
function_decl|2
end_function_decl
begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qFreeAligned
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qMemCopy
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qMemSet
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
name|int
name|c
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*    Avoid some particularly useless warnings from some stupid compilers.    To get ALL C++ compiler warnings, define QT_CC_WARNINGS or comment out    the line "#define QT_NO_WARNINGS". */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_CC_WARNINGS
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_WARNINGS
define|#
directive|define
name|QT_NO_WARNINGS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_WARNINGS
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4251
name|)
end_pragma
begin_comment
comment|/* class 'A' needs to have dll interface for to be used by clients of class 'B'. */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4244
name|)
end_pragma
begin_comment
comment|/* 'conversion' conversion from 'type1' to 'type2', possible loss of data */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4275
name|)
end_pragma
begin_comment
comment|/* non - DLL-interface classkey 'identifier' used as base for DLL-interface classkey 'identifier' */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4514
name|)
end_pragma
begin_comment
comment|/* unreferenced inline/local function has been removed */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4800
name|)
end_pragma
begin_comment
comment|/* 'type' : forcing value to bool 'true' or 'false' (performance warning) */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4097
name|)
end_pragma
begin_comment
comment|/* typedef-name 'identifier1' used as synonym for class-name 'identifier2' */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4706
name|)
end_pragma
begin_comment
comment|/* assignment within conditional expression */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4786
name|)
end_pragma
begin_comment
comment|/* truncating debug info after 255 characters */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4660
name|)
end_pragma
begin_comment
comment|/* template-class specialization 'identifier' is already instantiated */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4355
name|)
end_pragma
begin_comment
comment|/* 'this' : used in base member initializer list */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4231
name|)
end_pragma
begin_comment
comment|/* nonstandard extension used : 'extern' before template explicit instantiation */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4710
name|)
end_pragma
begin_comment
comment|/* function not inlined */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4530
name|)
end_pragma
begin_comment
comment|/* C++ exception handler used, but unwind semantics are not enabled. Specify -GX */
end_comment
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_BOR
argument_list|)
end_elif
begin_pragma
pragma|#
directive|pragma
name|option
name|-
name|w
name|-
name|inl
end_pragma
begin_pragma
pragma|#
directive|pragma
name|option
name|-
name|w
name|-
name|aus
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|inl
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|pia
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|ccc
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|rch
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|sig
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|class
name|Q_CORE_EXPORT
name|QFlag
block|{
name|int
name|i
decl_stmt|;
name|public
label|:
specifier|inline
name|QFlag
argument_list|(
argument|int i
argument_list|)
expr_stmt|;
specifier|inline
name|operator
name|int
argument_list|()
specifier|const
block|{
return|return
name|i
return|;
block|}
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
DECL|function|QFlag
specifier|inline
name|QFlag
operator|::
name|QFlag
argument_list|(
argument|int ai
argument_list|)
operator|:
name|i
argument_list|(
argument|ai
argument_list|)
block|{}
name|class
name|Q_CORE_EXPORT
name|QIncompatibleFlag
block|{
name|int
name|i
block|;
name|public
operator|:
specifier|inline
name|explicit
name|QIncompatibleFlag
argument_list|(
argument|int i
argument_list|)
block|;
specifier|inline
name|operator
name|int
argument_list|()
specifier|const
block|{
return|return
name|i
return|;
block|}
end_expr_stmt
begin_expr_stmt
unit|};
DECL|function|QIncompatibleFlag
specifier|inline
name|QIncompatibleFlag
operator|::
name|QIncompatibleFlag
argument_list|(
argument|int ai
argument_list|)
operator|:
name|i
argument_list|(
argument|ai
argument_list|)
block|{}
ifndef|#
directive|ifndef
name|Q_NO_TYPESAFE_FLAGS
name|template
operator|<
name|typename
name|Enum
operator|>
name|class
name|QFlags
block|{
typedef|typedef
name|void
modifier|*
modifier|*
name|Zero
typedef|;
name|int
name|i
expr_stmt|;
end_expr_stmt
begin_label
name|public
label|:
end_label
begin_typedef
typedef|typedef
name|Enum
name|enum_type
typedef|;
end_typedef
begin_macro
name|Q_DECL_CONSTEXPR
end_macro
begin_expr_stmt
specifier|inline
name|QFlags
argument_list|(
specifier|const
name|QFlags
operator|&
name|f
argument_list|)
operator|:
name|i
argument_list|(
argument|f.i
argument_list|)
block|{}
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
argument_list|(
argument|Enum f
argument_list|)
operator|:
name|i
argument_list|(
argument|f
argument_list|)
block|{}
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
argument_list|(
name|Zero
operator|=
literal|0
argument_list|)
operator|:
name|i
argument_list|(
literal|0
argument_list|)
block|{}
specifier|inline
name|QFlags
argument_list|(
argument|QFlag f
argument_list|)
operator|:
name|i
argument_list|(
argument|f
argument_list|)
block|{}
specifier|inline
name|QFlags
operator|&
name|operator
operator|=
operator|(
specifier|const
name|QFlags
operator|&
name|f
operator|)
block|{
name|i
operator|=
name|f
operator|.
name|i
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QFlags
operator|&
name|operator
operator|&=
operator|(
name|int
name|mask
operator|)
block|{
name|i
operator|&=
name|mask
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QFlags
operator|&
name|operator
operator|&=
operator|(
name|uint
name|mask
operator|)
block|{
name|i
operator|&=
name|mask
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QFlags
operator|&
name|operator
operator||=
operator|(
name|QFlags
name|f
operator|)
block|{
name|i
operator||=
name|f
operator|.
name|i
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QFlags
operator|&
name|operator
operator||=
operator|(
name|Enum
name|f
operator|)
block|{
name|i
operator||=
name|f
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QFlags
operator|&
name|operator
operator|^=
operator|(
name|QFlags
name|f
operator|)
block|{
name|i
operator|^=
name|f
operator|.
name|i
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
specifier|inline
name|QFlags
operator|&
name|operator
operator|^=
operator|(
name|Enum
name|f
operator|)
block|{
name|i
operator|^=
name|f
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|operator
name|int
argument_list|()
specifier|const
block|{
return|return
name|i
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
operator||
operator|(
name|QFlags
name|f
operator|)
specifier|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator||
name|f
operator|.
name|i
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
operator||
operator|(
name|Enum
name|f
operator|)
specifier|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator||
name|f
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
modifier|^
argument_list|(
name|QFlags
name|f
argument_list|)
decl|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator|^
name|f
operator|.
name|i
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
modifier|^
argument_list|(
name|Enum
name|f
argument_list|)
decl|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator|^
name|f
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
modifier|&
argument_list|(
name|int
name|mask
argument_list|)
decl|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator|&
name|mask
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
modifier|&
argument_list|(
name|uint
name|mask
argument_list|)
decl|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator|&
name|mask
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
modifier|&
argument_list|(
name|Enum
name|f
argument_list|)
decl|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
name|i
operator|&
name|f
argument_list|)
argument_list|)
return|;
block|}
end_decl_stmt
begin_expr_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|QFlags
name|operator
operator|~
operator|(
operator|)
specifier|const
block|{
return|return
name|QFlags
argument_list|(
name|Enum
argument_list|(
operator|~
name|i
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|Q_DECL_CONSTEXPR
specifier|inline
name|bool
name|operator
operator|!
operator|(
operator|)
specifier|const
block|{
return|return
operator|!
name|i
return|;
block|}
end_expr_stmt
begin_decl_stmt
specifier|inline
name|bool
name|testFlag
argument_list|(
name|Enum
name|f
argument_list|)
decl|const
block|{
return|return
operator|(
name|i
operator|&
name|f
operator|)
operator|==
name|f
operator|&&
operator|(
name|f
operator|!=
literal|0
operator|||
name|i
operator|==
name|int
argument_list|(
name|f
argument_list|)
operator|)
return|;
block|}
end_decl_stmt
begin_define
DECL|macro|Q_DECLARE_FLAGS
unit|};
define|#
directive|define
name|Q_DECLARE_FLAGS
parameter_list|(
name|Flags
parameter_list|,
name|Enum
parameter_list|)
define|\
value|typedef QFlags<Enum> Flags;
end_define
begin_define
DECL|macro|Q_DECLARE_INCOMPATIBLE_FLAGS
define|#
directive|define
name|Q_DECLARE_INCOMPATIBLE_FLAGS
parameter_list|(
name|Flags
parameter_list|)
define|\
value|inline QIncompatibleFlag operator|(Flags::enum_type f1, int f2) \ { return QIncompatibleFlag(int(f1) | f2); }
end_define
begin_define
DECL|macro|Q_DECLARE_OPERATORS_FOR_FLAGS
define|#
directive|define
name|Q_DECLARE_OPERATORS_FOR_FLAGS
parameter_list|(
name|Flags
parameter_list|)
define|\
value|Q_DECL_CONSTEXPR inline QFlags<Flags::enum_type> operator|(Flags::enum_type f1, Flags::enum_type f2) \ { return QFlags<Flags::enum_type>(f1) | f2; } \ Q_DECL_CONSTEXPR inline QFlags<Flags::enum_type> operator|(Flags::enum_type f1, QFlags<Flags::enum_type> f2) \ { return f2 | f1; } Q_DECLARE_INCOMPATIBLE_FLAGS(Flags)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* Q_NO_TYPESAFE_FLAGS */
end_comment
begin_define
DECL|macro|Q_DECLARE_FLAGS
define|#
directive|define
name|Q_DECLARE_FLAGS
parameter_list|(
name|Flags
parameter_list|,
name|Enum
parameter_list|)
define|\
value|typedef uint Flags;
end_define
begin_define
DECL|macro|Q_DECLARE_OPERATORS_FOR_FLAGS
define|#
directive|define
name|Q_DECLARE_OPERATORS_FOR_FLAGS
parameter_list|(
name|Flags
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Q_NO_TYPESAFE_FLAGS */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_if
begin_comment
comment|/* make use of typeof-extension */
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QForeachContainer
block|{
name|public
operator|:
specifier|inline
name|QForeachContainer
argument_list|(
specifier|const
name|T
operator|&
name|t
argument_list|)
operator|:
name|c
argument_list|(
name|t
argument_list|)
block|,
name|brk
argument_list|(
literal|0
argument_list|)
block|,
name|i
argument_list|(
name|c
operator|.
name|begin
argument_list|()
argument_list|)
block|,
name|e
argument_list|(
argument|c.end()
argument_list|)
block|{ }
specifier|const
name|T
name|c
block|;
name|int
name|brk
block|;
name|typename
name|T
operator|::
name|const_iterator
name|i
block|,
name|e
block|; }
expr_stmt|;
end_expr_stmt
begin_define
DECL|macro|Q_FOREACH
define|#
directive|define
name|Q_FOREACH
parameter_list|(
name|variable
parameter_list|,
name|container
parameter_list|)
define|\
value|for (QForeachContainer<__typeof__(container)> _container_(container); \      !_container_.brk&& _container_.i != _container_.e;              \      __extension__  ({ ++_container_.brk; ++_container_.i; }))                       \     for (variable = *_container_.i;; __extension__ ({--_container_.brk; break;}))
end_define
begin_else
else|#
directive|else
end_else
begin_struct
DECL|struct|QForeachContainerBase
struct|struct
name|QForeachContainerBase
block|{}
struct|;
end_struct
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QForeachContainer
operator|:
name|public
name|QForeachContainerBase
block|{
name|public
operator|:
specifier|inline
name|QForeachContainer
argument_list|(
specifier|const
name|T
operator|&
name|t
argument_list|)
operator|:
name|c
argument_list|(
name|t
argument_list|)
block|,
name|brk
argument_list|(
literal|0
argument_list|)
block|,
name|i
argument_list|(
name|c
operator|.
name|begin
argument_list|()
argument_list|)
block|,
name|e
argument_list|(
argument|c.end()
argument_list|)
block|{}
specifier|const
name|T
name|c
block|;
name|mutable
name|int
name|brk
block|;
name|mutable
name|typename
name|T
operator|::
name|const_iterator
name|i
block|,
name|e
block|;
specifier|inline
name|bool
name|condition
argument_list|()
specifier|const
block|{
return|return
operator|(
operator|!
name|brk
operator|++
operator|&&
name|i
operator|!=
name|e
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
unit|};
DECL|function|qForeachPointer
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
operator|*
name|qForeachPointer
argument_list|(
argument|const T&
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|qForeachContainerNew
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|QForeachContainer
operator|<
name|T
operator|>
name|qForeachContainerNew
argument_list|(
argument|const T& t
argument_list|)
block|{
return|return
name|QForeachContainer
operator|<
name|T
operator|>
operator|(
name|t
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qForeachContainer
specifier|inline
specifier|const
name|QForeachContainer
operator|<
name|T
operator|>
operator|*
name|qForeachContainer
argument_list|(
argument|const QForeachContainerBase *base
argument_list|,
argument|const T *
argument_list|)
block|{
return|return
name|static_cast
operator|<
specifier|const
name|QForeachContainer
operator|<
name|T
operator|>
operator|*
operator|>
operator|(
name|base
operator|)
return|;
block|}
end_expr_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MIPS
argument_list|)
end_if
begin_comment
comment|/*    Proper for-scoping in MIPSpro CC */
end_comment
begin_define
DECL|macro|Q_FOREACH
define|#
directive|define
name|Q_FOREACH
parameter_list|(
name|variable
parameter_list|,
name|container
parameter_list|)
define|\
value|if(0){}else                                                                                     \     for (const QForeachContainerBase&_container_ = qForeachContainerNew(container);                \          qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->condition();       \          ++qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->i)               \         for (variable = *qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->i; \              qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->brk;           \              --qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->brk)
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_DIAB
argument_list|)
end_elif
begin_comment
comment|// VxWorks DIAB generates unresolvable symbols, if container is a function call
end_comment
begin_define
DECL|macro|Q_FOREACH
define|#
directive|define
name|Q_FOREACH
parameter_list|(
name|variable
parameter_list|,
name|container
parameter_list|)
define|\
value|if(0){}else                                                                                     \     for (const QForeachContainerBase&_container_ = qForeachContainerNew(container);                \          qForeachContainer(&_container_, (__typeof__(container) *) 0)->condition();       \          ++qForeachContainer(&_container_, (__typeof__(container) *) 0)->i)               \         for (variable = *qForeachContainer(&_container_, (__typeof__(container) *) 0)->i; \              qForeachContainer(&_container_, (__typeof__(container) *) 0)->brk;           \              --qForeachContainer(&_container_, (__typeof__(container) *) 0)->brk)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_FOREACH
define|#
directive|define
name|Q_FOREACH
parameter_list|(
name|variable
parameter_list|,
name|container
parameter_list|)
define|\
value|for (const QForeachContainerBase&_container_ = qForeachContainerNew(container); \          qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->condition();       \          ++qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->i)               \         for (variable = *qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->i; \              qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->brk;           \              --qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->brk)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// MSVC6 || MIPSpro
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Q_FOREVER
define|#
directive|define
name|Q_FOREVER
value|for(;;)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_KEYWORDS
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|foreach
end_ifndef
begin_define
DECL|macro|foreach
define|#
directive|define
name|foreach
value|Q_FOREACH
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|forever
end_ifndef
begin_define
DECL|macro|forever
define|#
directive|define
name|forever
value|Q_FOREVER
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/* tell gcc to use its built-in methods for some common functions */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
end_if
begin_define
define|#
directive|define
name|qMemCopy
value|__builtin_memcpy
end_define
begin_define
define|#
directive|define
name|qMemSet
value|__builtin_memset
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
DECL|function|qGetPtrHelper
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
specifier|inline
name|T
operator|*
name|qGetPtrHelper
argument_list|(
argument|T *ptr
argument_list|)
block|{
return|return
name|ptr
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|qGetPtrHelper
name|template
operator|<
name|typename
name|Wrapper
operator|>
specifier|static
specifier|inline
name|typename
name|Wrapper
operator|::
name|pointer
name|qGetPtrHelper
argument_list|(
argument|const Wrapper&p
argument_list|)
block|{
return|return
name|p
operator|.
name|data
argument_list|()
return|;
block|}
end_expr_stmt
begin_define
DECL|macro|Q_DECLARE_PRIVATE
define|#
directive|define
name|Q_DECLARE_PRIVATE
parameter_list|(
name|Class
parameter_list|)
define|\
value|inline Class##Private* d_func() { return reinterpret_cast<Class##Private *>(qGetPtrHelper(d_ptr)); } \     inline const Class##Private* d_func() const { return reinterpret_cast<const Class##Private *>(qGetPtrHelper(d_ptr)); } \     friend class Class##Private;
end_define
begin_define
DECL|macro|Q_DECLARE_PRIVATE_D
define|#
directive|define
name|Q_DECLARE_PRIVATE_D
parameter_list|(
name|Dptr
parameter_list|,
name|Class
parameter_list|)
define|\
value|inline Class##Private* d_func() { return reinterpret_cast<Class##Private *>(Dptr); } \     inline const Class##Private* d_func() const { return reinterpret_cast<const Class##Private *>(Dptr); } \     friend class Class##Private;
end_define
begin_define
DECL|macro|Q_DECLARE_PUBLIC
define|#
directive|define
name|Q_DECLARE_PUBLIC
parameter_list|(
name|Class
parameter_list|)
define|\
value|inline Class* q_func() { return static_cast<Class *>(q_ptr); } \     inline const Class* q_func() const { return static_cast<const Class *>(q_ptr); } \     friend class Class;
end_define
begin_define
DECL|macro|Q_D
define|#
directive|define
name|Q_D
parameter_list|(
name|Class
parameter_list|)
value|Class##Private * const d = d_func()
end_define
begin_define
DECL|macro|Q_Q
define|#
directive|define
name|Q_Q
parameter_list|(
name|Class
parameter_list|)
value|Class * const q = q_func()
end_define
begin_define
DECL|macro|QT_TR_NOOP
define|#
directive|define
name|QT_TR_NOOP
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|QT_TR_NOOP_UTF8
define|#
directive|define
name|QT_TR_NOOP_UTF8
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|QT_TRANSLATE_NOOP
define|#
directive|define
name|QT_TRANSLATE_NOOP
parameter_list|(
name|scope
parameter_list|,
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|QT_TRANSLATE_NOOP_UTF8
define|#
directive|define
name|QT_TRANSLATE_NOOP_UTF8
parameter_list|(
name|scope
parameter_list|,
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|QT_TRANSLATE_NOOP3
define|#
directive|define
name|QT_TRANSLATE_NOOP3
parameter_list|(
name|scope
parameter_list|,
name|x
parameter_list|,
name|comment
parameter_list|)
value|{x, comment}
end_define
begin_define
DECL|macro|QT_TRANSLATE_NOOP3_UTF8
define|#
directive|define
name|QT_TRANSLATE_NOOP3_UTF8
parameter_list|(
name|scope
parameter_list|,
name|x
parameter_list|,
name|comment
parameter_list|)
value|{x, comment}
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TRANSLATION
end_ifndef
begin_comment
comment|// ### This should enclose the NOOPs above
end_comment
begin_comment
comment|// Defined in qcoreapplication.cpp
end_comment
begin_comment
comment|// The better name qTrId() is reserved for an upcoming function which would
end_comment
begin_comment
comment|// return a much more powerful QStringFormatter instead of a QString.
end_comment
begin_function_decl
name|Q_CORE_EXPORT
name|QString
name|qtTrId
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|int
name|n
init|=
operator|-
literal|1
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|QT_TRID_NOOP
define|#
directive|define
name|QT_TRID_NOOP
parameter_list|(
name|id
parameter_list|)
value|id
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TRANSLATION
end_comment
begin_define
DECL|macro|QDOC_PROPERTY
define|#
directive|define
name|QDOC_PROPERTY
parameter_list|(
name|text
parameter_list|)
end_define
begin_comment
comment|/*    When RTTI is not available, define this macro to force any uses of    dynamic_cast to cause a compile failure. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_DYNAMIC_CAST
end_ifdef
begin_define
DECL|macro|dynamic_cast
define|#
directive|define
name|dynamic_cast
value|QT_PREPEND_NAMESPACE(qt_dynamic_cast_check)
end_define
begin_expr_stmt
DECL|variable|T
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|X
operator|>
DECL|function|qt_dynamic_cast_check
name|T
name|qt_dynamic_cast_check
argument_list|(
argument|X
argument_list|,
argument|T* =
literal|0
argument_list|)
block|{
return|return
name|T
operator|::
name|dynamic_cast_will_always_fail_because_rtti_is_disabled
return|;
block|}
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Some classes do not permit copies to be made of an object. These    classes contains a private copy constructor and assignment    operator to disable copying (the compiler gives an error message). */
end_comment
begin_define
DECL|macro|Q_DISABLE_COPY
define|#
directive|define
name|Q_DISABLE_COPY
parameter_list|(
name|Class
parameter_list|)
define|\
value|Class(const Class&) Q_DECL_EQ_DELETE;\     Class&operator=(const Class&) Q_DECL_EQ_DELETE;
end_define
begin_decl_stmt
DECL|variable|QByteArray
name|class
name|QByteArray
decl_stmt|;
end_decl_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|QByteArray
name|qgetenv
parameter_list|(
specifier|const
name|char
modifier|*
name|varName
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|bool
name|qputenv
parameter_list|(
specifier|const
name|char
modifier|*
name|varName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|value
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|qIntCast
specifier|inline
name|int
name|qIntCast
parameter_list|(
name|double
name|f
parameter_list|)
block|{
return|return
name|int
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qIntCast
specifier|inline
name|int
name|qIntCast
parameter_list|(
name|float
name|f
parameter_list|)
block|{
return|return
name|int
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*   Reentrant versions of basic rand() functions for random number generation */
end_comment
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qsrand
parameter_list|(
name|uint
name|seed
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|int
name|qrand
parameter_list|()
function_decl|;
end_function_decl
begin_define
DECL|macro|QT_MODULE
define|#
directive|define
name|QT_MODULE
parameter_list|(
name|x
parameter_list|)
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_CONCURRENT
end_ifdef
begin_define
DECL|macro|QT_NO_QFUTURE
define|#
directive|define
name|QT_NO_QFUTURE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// gcc 3 version has problems with some of the
end_comment
begin_comment
comment|// map/filter overloads.
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|<
literal|4
operator|)
end_if
begin_define
DECL|macro|QT_NO_CONCURRENT_MAP
define|#
directive|define
name|QT_NO_CONCURRENT_MAP
end_define
begin_define
DECL|macro|QT_NO_CONCURRENT_FILTER
define|#
directive|define
name|QT_NO_CONCURRENT_FILTER
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_QNX
end_ifdef
begin_comment
comment|// QNX doesn't have SYSV style shared memory. Multiprocess QWS apps,
end_comment
begin_comment
comment|// shared fonts and QSystemSemaphore + QSharedMemory are not available
end_comment
begin_define
DECL|macro|QT_NO_QWS_MULTIPROCESS
define|#
directive|define
name|QT_NO_QWS_MULTIPROCESS
end_define
begin_define
DECL|macro|QT_NO_QWS_SHARE_FONTS
define|#
directive|define
name|QT_NO_QWS_SHARE_FONTS
end_define
begin_define
DECL|macro|QT_NO_SYSTEMSEMAPHORE
define|#
directive|define
name|QT_NO_SYSTEMSEMAPHORE
end_define
begin_define
DECL|macro|QT_NO_SHAREDMEMORY
define|#
directive|define
name|QT_NO_SHAREDMEMORY
end_define
begin_comment
comment|// QNX currently doesn't support forking in a thread, so disable QProcess
end_comment
begin_define
DECL|macro|QT_NO_PROCESS
define|#
directive|define
name|QT_NO_PROCESS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__ELF__
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_SOLARIS
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_FREEBSD
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_OPENBSD
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_IRIX
argument_list|)
end_if
begin_define
DECL|macro|Q_OF_ELF
define|#
directive|define
name|Q_OF_ELF
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|namespace
name|QtPrivate
block|{
comment|//like std::enable_if
name|template
operator|<
name|bool
name|B
operator|,
name|typename
name|T
operator|=
name|void
operator|>
expr|struct
name|QEnableIf
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|QEnableIf
operator|<
name|true
operator|,
name|T
operator|>
block|{
typedef|typedef
name|T
name|Type
typedef|;
block|}
empty_stmt|;
block|}
end_decl_stmt
begin_expr_stmt
name|QT_END_NAMESPACE
name|QT_END_HEADER
end_expr_stmt
begin_comment
comment|// qDebug and friends
end_comment
begin_include
include|#
directive|include
file|<QtCore/qlogging.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __cplusplus */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* QGLOBAL_H */
end_comment
end_unit
