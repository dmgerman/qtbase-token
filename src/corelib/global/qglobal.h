begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Copyright (C) 2012 Intel Corporation. ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QGLOBAL_H
end_ifndef
begin_define
DECL|macro|QGLOBAL_H
define|#
directive|define
name|QGLOBAL_H
end_define
begin_include
include|#
directive|include
file|<stddef.h>
end_include
begin_define
DECL|macro|QT_VERSION_STR
define|#
directive|define
name|QT_VERSION_STR
value|"5.3.0"
end_define
begin_comment
comment|/*    QT_VERSION is (major<< 16) + (minor<< 8) + patch. */
end_comment
begin_define
DECL|macro|QT_VERSION
define|#
directive|define
name|QT_VERSION
value|0x050300
end_define
begin_comment
comment|/*    can be used like #if (QT_VERSION>= QT_VERSION_CHECK(4, 4, 0)) */
end_comment
begin_define
DECL|macro|QT_VERSION_CHECK
define|#
directive|define
name|QT_VERSION_CHECK
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|,
name|patch
parameter_list|)
value|((major<<16)|(minor<<8)|(patch))
end_define
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_BUILD_MOC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BUILD_QMAKE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BUILD_CONFIGURE
argument_list|)
end_if
begin_include
include|#
directive|include
file|<QtCore/qconfig.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QtCore/qfeatures.h>
end_include
begin_define
DECL|macro|QT_SUPPORTS
define|#
directive|define
name|QT_SUPPORTS
parameter_list|(
name|FEATURE
parameter_list|)
value|(!defined(QT_NO_##FEATURE))
end_define
begin_comment
comment|/* These two macros makes it possible to turn the builtin line expander into a  * string literal. */
end_comment
begin_define
DECL|macro|QT_STRINGIFY2
define|#
directive|define
name|QT_STRINGIFY2
parameter_list|(
name|x
parameter_list|)
value|#x
end_define
begin_define
DECL|macro|QT_STRINGIFY
define|#
directive|define
name|QT_STRINGIFY
parameter_list|(
name|x
parameter_list|)
value|QT_STRINGIFY2(x)
end_define
begin_include
include|#
directive|include
file|<QtCore/qsystemdetection.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qprocessordetection.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qcompilerdetection.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__ELF__
argument_list|)
end_if
begin_define
DECL|macro|Q_OF_ELF
define|#
directive|define
name|Q_OF_ELF
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MACH__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_if
begin_define
DECL|macro|Q_OF_MACH_O
define|#
directive|define
name|Q_OF_MACH_O
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NAMESPACE
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_MOC_RUN
argument_list|)
end_if
begin_comment
comment|/* user namespace */
end_comment
begin_define
DECL|macro|QT_PREPEND_NAMESPACE
define|#
directive|define
name|QT_PREPEND_NAMESPACE
parameter_list|(
name|name
parameter_list|)
value|::name
end_define
begin_define
DECL|macro|QT_USE_NAMESPACE
define|#
directive|define
name|QT_USE_NAMESPACE
end_define
begin_define
DECL|macro|QT_BEGIN_NAMESPACE
define|#
directive|define
name|QT_BEGIN_NAMESPACE
end_define
begin_define
DECL|macro|QT_END_NAMESPACE
define|#
directive|define
name|QT_END_NAMESPACE
end_define
begin_define
DECL|macro|QT_BEGIN_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_BEGIN_INCLUDE_NAMESPACE
end_define
begin_define
DECL|macro|QT_END_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_END_INCLUDE_NAMESPACE
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BEGIN_MOC_NAMESPACE
end_ifndef
begin_define
DECL|macro|QT_BEGIN_MOC_NAMESPACE
define|#
directive|define
name|QT_BEGIN_MOC_NAMESPACE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_END_MOC_NAMESPACE
end_ifndef
begin_define
DECL|macro|QT_END_MOC_NAMESPACE
define|#
directive|define
name|QT_END_MOC_NAMESPACE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QT_FORWARD_DECLARE_CLASS
define|#
directive|define
name|QT_FORWARD_DECLARE_CLASS
parameter_list|(
name|name
parameter_list|)
value|class name;
end_define
begin_define
DECL|macro|QT_FORWARD_DECLARE_STRUCT
define|#
directive|define
name|QT_FORWARD_DECLARE_STRUCT
parameter_list|(
name|name
parameter_list|)
value|struct name;
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE
define|#
directive|define
name|QT_MANGLE_NAMESPACE
parameter_list|(
name|name
parameter_list|)
value|name
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* user namespace */
end_comment
begin_define
DECL|macro|QT_PREPEND_NAMESPACE
define|#
directive|define
name|QT_PREPEND_NAMESPACE
parameter_list|(
name|name
parameter_list|)
value|::QT_NAMESPACE::name
end_define
begin_define
DECL|macro|QT_USE_NAMESPACE
define|#
directive|define
name|QT_USE_NAMESPACE
value|using namespace ::QT_NAMESPACE;
end_define
begin_define
DECL|macro|QT_BEGIN_NAMESPACE
define|#
directive|define
name|QT_BEGIN_NAMESPACE
value|namespace QT_NAMESPACE {
end_define
begin_define
DECL|macro|QT_END_NAMESPACE
define|#
directive|define
name|QT_END_NAMESPACE
value|}
end_define
begin_define
DECL|macro|QT_BEGIN_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_BEGIN_INCLUDE_NAMESPACE
value|}
end_define
begin_define
DECL|macro|QT_END_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_END_INCLUDE_NAMESPACE
value|namespace QT_NAMESPACE {
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BEGIN_MOC_NAMESPACE
end_ifndef
begin_define
DECL|macro|QT_BEGIN_MOC_NAMESPACE
define|#
directive|define
name|QT_BEGIN_MOC_NAMESPACE
value|QT_USE_NAMESPACE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_END_MOC_NAMESPACE
end_ifndef
begin_define
DECL|macro|QT_END_MOC_NAMESPACE
define|#
directive|define
name|QT_END_MOC_NAMESPACE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QT_FORWARD_DECLARE_CLASS
define|#
directive|define
name|QT_FORWARD_DECLARE_CLASS
parameter_list|(
name|name
parameter_list|)
define|\
value|QT_BEGIN_NAMESPACE class name; QT_END_NAMESPACE \     using QT_PREPEND_NAMESPACE(name);
end_define
begin_define
DECL|macro|QT_FORWARD_DECLARE_STRUCT
define|#
directive|define
name|QT_FORWARD_DECLARE_STRUCT
parameter_list|(
name|name
parameter_list|)
define|\
value|QT_BEGIN_NAMESPACE struct name; QT_END_NAMESPACE \     using QT_PREPEND_NAMESPACE(name);
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE0
define|#
directive|define
name|QT_MANGLE_NAMESPACE0
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE1
define|#
directive|define
name|QT_MANGLE_NAMESPACE1
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a##_##b
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE2
define|#
directive|define
name|QT_MANGLE_NAMESPACE2
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|QT_MANGLE_NAMESPACE1(a,b)
end_define
begin_define
DECL|macro|QT_MANGLE_NAMESPACE
define|#
directive|define
name|QT_MANGLE_NAMESPACE
parameter_list|(
name|name
parameter_list|)
value|QT_MANGLE_NAMESPACE2( \         QT_MANGLE_NAMESPACE0(name), QT_MANGLE_NAMESPACE0(QT_NAMESPACE))
end_define
begin_decl_stmt
name|namespace
name|QT_NAMESPACE
block|{}
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_USING_NAMESPACE
end_ifndef
begin_comment
comment|/*     This expands to a "using QT_NAMESPACE" also in _header files_.     It is the only way the feature can be used without too much     pain, but if people _really_ do not want it they can add     DEFINES += QT_NO_USING_NAMESPACE to their .pro files.     */
end_comment
begin_expr_stmt
name|QT_USE_NAMESPACE
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* user namespace */
else|#
directive|else
comment|/* __cplusplus */
define|#
directive|define
name|QT_BEGIN_NAMESPACE
define|#
directive|define
name|QT_END_NAMESPACE
define|#
directive|define
name|QT_USE_NAMESPACE
define|#
directive|define
name|QT_BEGIN_INCLUDE_NAMESPACE
define|#
directive|define
name|QT_END_INCLUDE_NAMESPACE
endif|#
directive|endif
comment|/* __cplusplus */
comment|// ### Qt6: remove me.
DECL|macro|QT_BEGIN_HEADER
define|#
directive|define
name|QT_BEGIN_HEADER
DECL|macro|QT_END_HEADER
define|#
directive|define
name|QT_END_HEADER
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_LARGEFILE_SUPPORT
argument_list|)
DECL|macro|QT_LARGEFILE_SUPPORT
define|#
directive|define
name|QT_LARGEFILE_SUPPORT
value|64
endif|#
directive|endif
name|QT_BEGIN_NAMESPACE
end_expr_stmt
begin_comment
comment|/*    Size-dependent types (architechture-dependent byte order)     Make sure to update QMetaType when changing these typedefs */
end_comment
begin_typedef
DECL|typedef|qint8
typedef|typedef
name|signed
name|char
name|qint8
typedef|;
end_typedef
begin_comment
DECL|typedef|qint8
comment|/* 8 bit signed */
end_comment
begin_typedef
DECL|typedef|quint8
typedef|typedef
name|unsigned
name|char
name|quint8
typedef|;
end_typedef
begin_comment
DECL|typedef|quint8
comment|/* 8 bit unsigned */
end_comment
begin_typedef
DECL|typedef|qint16
typedef|typedef
name|short
name|qint16
typedef|;
end_typedef
begin_comment
DECL|typedef|qint16
comment|/* 16 bit signed */
end_comment
begin_typedef
DECL|typedef|quint16
typedef|typedef
name|unsigned
name|short
name|quint16
typedef|;
end_typedef
begin_comment
DECL|typedef|quint16
comment|/* 16 bit unsigned */
end_comment
begin_typedef
DECL|typedef|qint32
typedef|typedef
name|int
name|qint32
typedef|;
end_typedef
begin_comment
DECL|typedef|qint32
comment|/* 32 bit signed */
end_comment
begin_typedef
DECL|typedef|quint32
typedef|typedef
name|unsigned
name|int
name|quint32
typedef|;
end_typedef
begin_comment
DECL|typedef|quint32
comment|/* 32 bit unsigned */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
end_if
begin_define
DECL|macro|Q_INT64_C
define|#
directive|define
name|Q_INT64_C
parameter_list|(
name|c
parameter_list|)
value|c ## i64
end_define
begin_comment
DECL|macro|Q_INT64_C
comment|/* signed 64 bit constant */
end_comment
begin_define
DECL|macro|Q_UINT64_C
define|#
directive|define
name|Q_UINT64_C
parameter_list|(
name|c
parameter_list|)
value|c ## ui64
end_define
begin_comment
DECL|macro|Q_UINT64_C
comment|/* unsigned 64 bit constant */
end_comment
begin_typedef
DECL|typedef|qint64
typedef|typedef
name|__int64
name|qint64
typedef|;
end_typedef
begin_comment
DECL|typedef|qint64
comment|/* 64 bit signed */
end_comment
begin_typedef
DECL|typedef|quint64
typedef|typedef
name|unsigned
name|__int64
name|quint64
typedef|;
end_typedef
begin_comment
DECL|typedef|quint64
comment|/* 64 bit unsigned */
end_comment
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_INT64_C
define|#
directive|define
name|Q_INT64_C
parameter_list|(
name|c
parameter_list|)
value|static_cast<long long>(c ## LL)
end_define
begin_comment
DECL|macro|Q_INT64_C
comment|/* signed 64 bit constant */
end_comment
begin_define
DECL|macro|Q_UINT64_C
define|#
directive|define
name|Q_UINT64_C
parameter_list|(
name|c
parameter_list|)
value|static_cast<unsigned long long>(c ## ULL)
end_define
begin_comment
DECL|macro|Q_UINT64_C
comment|/* unsigned 64 bit constant */
end_comment
begin_typedef
DECL|typedef|qint64
typedef|typedef
name|long
name|long
name|qint64
typedef|;
end_typedef
begin_comment
DECL|typedef|qint64
comment|/* 64 bit signed */
end_comment
begin_typedef
DECL|typedef|quint64
typedef|typedef
name|unsigned
name|long
name|long
name|quint64
typedef|;
end_typedef
begin_comment
DECL|typedef|quint64
comment|/* 64 bit unsigned */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|qlonglong
typedef|typedef
name|qint64
name|qlonglong
typedef|;
end_typedef
begin_typedef
DECL|typedef|qulonglong
typedef|typedef
name|quint64
name|qulonglong
typedef|;
end_typedef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_POINTER_SIZE
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN64
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
operator|&&
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|)
end_if
begin_define
DECL|macro|QT_POINTER_SIZE
define|#
directive|define
name|QT_POINTER_SIZE
value|8
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
end_elif
begin_define
DECL|macro|QT_POINTER_SIZE
define|#
directive|define
name|QT_POINTER_SIZE
value|4
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
end_elif
begin_define
DECL|macro|QT_POINTER_SIZE
define|#
directive|define
name|QT_POINTER_SIZE
value|4
end_define
begin_comment
DECL|macro|QT_POINTER_SIZE
comment|// ### Add auto-detection to Windows configure
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Useful type definitions for Qt */
end_comment
begin_macro
name|QT_BEGIN_INCLUDE_NAMESPACE
end_macro
begin_typedef
DECL|typedef|uchar
typedef|typedef
name|unsigned
name|char
name|uchar
typedef|;
end_typedef
begin_typedef
DECL|typedef|ushort
typedef|typedef
name|unsigned
name|short
name|ushort
typedef|;
end_typedef
begin_typedef
DECL|typedef|uint
typedef|typedef
name|unsigned
name|int
name|uint
typedef|;
end_typedef
begin_typedef
DECL|typedef|ulong
typedef|typedef
name|unsigned
name|long
name|ulong
typedef|;
end_typedef
begin_macro
name|QT_END_INCLUDE_NAMESPACE
end_macro
begin_comment
comment|// This logic must match the one in qmetatype.h
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_COORD_TYPE
argument_list|)
end_if
begin_typedef
DECL|typedef|qreal
typedef|typedef
name|QT_COORD_TYPE
name|qreal
typedef|;
end_typedef
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_NO_FPU
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_PROCESSOR_ARM
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_elif
begin_typedef
typedef|typedef
name|float
name|qreal
typedef|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_typedef
typedef|typedef
name|double
name|qreal
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEPRECATED
argument_list|)
end_if
begin_undef
DECL|macro|QT_DEPRECATED
undef|#
directive|undef
name|QT_DEPRECATED
end_undef
begin_undef
DECL|macro|QT_DEPRECATED_X
undef|#
directive|undef
name|QT_DEPRECATED_X
end_undef
begin_undef
DECL|macro|QT_DEPRECATED_VARIABLE
undef|#
directive|undef
name|QT_DEPRECATED_VARIABLE
end_undef
begin_undef
DECL|macro|QT_DEPRECATED_CONSTRUCTOR
undef|#
directive|undef
name|QT_DEPRECATED_CONSTRUCTOR
end_undef
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_DEPRECATED_WARNINGS
argument_list|)
end_elif
begin_undef
DECL|macro|QT_DEPRECATED
undef|#
directive|undef
name|QT_DEPRECATED
end_undef
begin_define
DECL|macro|QT_DEPRECATED
define|#
directive|define
name|QT_DEPRECATED
value|Q_DECL_DEPRECATED
end_define
begin_undef
DECL|macro|QT_DEPRECATED_X
undef|#
directive|undef
name|QT_DEPRECATED_X
end_undef
begin_define
DECL|macro|QT_DEPRECATED_X
define|#
directive|define
name|QT_DEPRECATED_X
parameter_list|(
name|text
parameter_list|)
value|Q_DECL_DEPRECATED_X(text)
end_define
begin_undef
DECL|macro|QT_DEPRECATED_VARIABLE
undef|#
directive|undef
name|QT_DEPRECATED_VARIABLE
end_undef
begin_define
DECL|macro|QT_DEPRECATED_VARIABLE
define|#
directive|define
name|QT_DEPRECATED_VARIABLE
value|Q_DECL_VARIABLE_DEPRECATED
end_define
begin_undef
DECL|macro|QT_DEPRECATED_CONSTRUCTOR
undef|#
directive|undef
name|QT_DEPRECATED_CONSTRUCTOR
end_undef
begin_define
DECL|macro|QT_DEPRECATED_CONSTRUCTOR
define|#
directive|define
name|QT_DEPRECATED_CONSTRUCTOR
value|explicit Q_DECL_CONSTRUCTOR_DEPRECATED
end_define
begin_else
else|#
directive|else
end_else
begin_undef
DECL|macro|QT_DEPRECATED
undef|#
directive|undef
name|QT_DEPRECATED
end_undef
begin_define
DECL|macro|QT_DEPRECATED
define|#
directive|define
name|QT_DEPRECATED
end_define
begin_undef
DECL|macro|QT_DEPRECATED_X
undef|#
directive|undef
name|QT_DEPRECATED_X
end_undef
begin_define
DECL|macro|QT_DEPRECATED_X
define|#
directive|define
name|QT_DEPRECATED_X
parameter_list|(
name|text
parameter_list|)
end_define
begin_undef
DECL|macro|QT_DEPRECATED_VARIABLE
undef|#
directive|undef
name|QT_DEPRECATED_VARIABLE
end_undef
begin_define
DECL|macro|QT_DEPRECATED_VARIABLE
define|#
directive|define
name|QT_DEPRECATED_VARIABLE
end_define
begin_undef
DECL|macro|QT_DEPRECATED_CONSTRUCTOR
undef|#
directive|undef
name|QT_DEPRECATED_CONSTRUCTOR
end_undef
begin_define
DECL|macro|QT_DEPRECATED_CONSTRUCTOR
define|#
directive|define
name|QT_DEPRECATED_CONSTRUCTOR
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_DISABLE_DEPRECATED_BEFORE
end_ifndef
begin_define
DECL|macro|QT_DISABLE_DEPRECATED_BEFORE
define|#
directive|define
name|QT_DISABLE_DEPRECATED_BEFORE
value|QT_VERSION_CHECK(5, 0, 0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*     QT_DEPRECATED_SINCE(major, minor) evaluates as true if the Qt version is greater than     the deprecation point specified.      Use it to specify from which version of Qt a function or class has been deprecated      Example:         #if QT_DEPRECATED_SINCE(5,1)             QT_DEPRECATED void deprecatedFunction(); //function deprecated since Qt 5.1         #endif  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_DEPRECATED
end_ifdef
begin_define
DECL|macro|QT_DEPRECATED_SINCE
define|#
directive|define
name|QT_DEPRECATED_SINCE
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
value|(QT_VERSION_CHECK(major, minor, 0)> QT_DISABLE_DEPRECATED_BEFORE)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_DEPRECATED_SINCE
define|#
directive|define
name|QT_DEPRECATED_SINCE
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    The Qt modules' export macros.    The options are:     - defined(QT_STATIC): Qt was built or is being built in static mode     - defined(QT_SHARED): Qt was built or is being built in shared/dynamic mode    If neither was defined, then QT_SHARED is implied. If Qt was compiled in static    mode, QT_STATIC is defined in qconfig.h. In shared mode, QT_STATIC is implied    for the bootstrapped tools. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_BOOTSTRAPPED
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|QT_SHARED
end_ifdef
begin_error
error|#
directive|error
literal|"QT_SHARED and QT_BOOTSTRAPPED together don't make sense. Please fix the build"
end_error
begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|QT_STATIC
argument_list|)
end_elif
begin_define
DECL|macro|QT_STATIC
define|#
directive|define
name|QT_STATIC
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_SHARED
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|QT_STATIC
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|QT_STATIC
end_ifdef
begin_error
error|#
directive|error
literal|"Both QT_SHARED and QT_STATIC defined, please make up your mind"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_SHARED
end_ifndef
begin_define
DECL|macro|QT_SHARED
define|#
directive|define
name|QT_SHARED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_CORE_EXPORT
define|#
directive|define
name|Q_CORE_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CORE_EXPORT
define|#
directive|define
name|Q_CORE_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_GUI_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_GUI_EXPORT
define|#
directive|define
name|Q_GUI_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_GUI_EXPORT
define|#
directive|define
name|Q_GUI_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_WIDGETS_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_WIDGETS_EXPORT
define|#
directive|define
name|Q_WIDGETS_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_WIDGETS_EXPORT
define|#
directive|define
name|Q_WIDGETS_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_NETWORK_LIB
argument_list|)
end_if
begin_define
DECL|macro|Q_NETWORK_EXPORT
define|#
directive|define
name|Q_NETWORK_EXPORT
value|Q_DECL_EXPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_NETWORK_EXPORT
define|#
directive|define
name|Q_NETWORK_EXPORT
value|Q_DECL_IMPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CORE_EXPORT
define|#
directive|define
name|Q_CORE_EXPORT
end_define
begin_define
DECL|macro|Q_GUI_EXPORT
define|#
directive|define
name|Q_GUI_EXPORT
end_define
begin_define
DECL|macro|Q_WIDGETS_EXPORT
define|#
directive|define
name|Q_WIDGETS_EXPORT
end_define
begin_define
DECL|macro|Q_NETWORK_EXPORT
define|#
directive|define
name|Q_NETWORK_EXPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    No, this is not an evil backdoor. QT_BUILD_INTERNAL just exports more symbols    for Qt's internal unit tests. If you want slower loading times and more    symbols that can vanish from version to version, feel free to define QT_BUILD_INTERNAL. */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BUILD_INTERNAL
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_BUILDING_QT
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_SHARED
argument_list|)
end_if
begin_define
DECL|macro|Q_AUTOTEST_EXPORT
define|#
directive|define
name|Q_AUTOTEST_EXPORT
value|Q_DECL_EXPORT
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|QT_BUILD_INTERNAL
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_SHARED
argument_list|)
end_elif
begin_define
DECL|macro|Q_AUTOTEST_EXPORT
define|#
directive|define
name|Q_AUTOTEST_EXPORT
value|Q_DECL_IMPORT
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_AUTOTEST_EXPORT
define|#
directive|define
name|Q_AUTOTEST_EXPORT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Q_INIT_RESOURCE_EXTERN
define|#
directive|define
name|Q_INIT_RESOURCE_EXTERN
parameter_list|(
name|name
parameter_list|)
define|\
value|extern int QT_MANGLE_NAMESPACE(qInitResources_ ## name) ();
end_define
begin_define
DECL|macro|Q_INIT_RESOURCE
define|#
directive|define
name|Q_INIT_RESOURCE
parameter_list|(
name|name
parameter_list|)
define|\
value|do { extern int QT_MANGLE_NAMESPACE(qInitResources_ ## name) ();       \         QT_MANGLE_NAMESPACE(qInitResources_ ## name) (); } while (0)
end_define
begin_define
DECL|macro|Q_CLEANUP_RESOURCE
define|#
directive|define
name|Q_CLEANUP_RESOURCE
parameter_list|(
name|name
parameter_list|)
define|\
value|do { extern int QT_MANGLE_NAMESPACE(qCleanupResources_ ## name) ();    \         QT_MANGLE_NAMESPACE(qCleanupResources_ ## name) (); } while (0)
end_define
begin_comment
comment|/*  * If we're compiling C++ code:  *  - and this is a non-namespace build, declare qVersion as extern "C"  *  - and this is a namespace build, declare it as a regular function  *    (we're already inside QT_BEGIN_NAMESPACE / QT_END_NAMESPACE)  * If we're compiling C code, simply declare the function. If Qt was compiled  * in a namespace, qVersion isn't callable anyway.  */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NAMESPACE
argument_list|)
operator|&&
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_QDOC
argument_list|)
end_if
begin_extern
extern|extern
literal|"C"
endif|#
directive|endif
name|Q_CORE_EXPORT
specifier|const
name|char
operator|*
name|qVersion
argument_list|()
name|Q_DECL_NOTHROW
expr_stmt|;
end_extern
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|Q_CONSTRUCTOR_FUNCTION
end_ifndef
begin_define
DECL|macro|Q_CONSTRUCTOR_FUNCTION0
define|#
directive|define
name|Q_CONSTRUCTOR_FUNCTION0
parameter_list|(
name|AFUNC
parameter_list|)
define|\
value|namespace { \     static const struct AFUNC ## _ctor_class_ { \         inline AFUNC ## _ctor_class_() { AFUNC(); } \     } AFUNC ## _ctor_instance_; \     }
end_define
begin_define
DECL|macro|Q_CONSTRUCTOR_FUNCTION
define|#
directive|define
name|Q_CONSTRUCTOR_FUNCTION
parameter_list|(
name|AFUNC
parameter_list|)
value|Q_CONSTRUCTOR_FUNCTION0(AFUNC)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_DESTRUCTOR_FUNCTION
end_ifndef
begin_define
DECL|macro|Q_DESTRUCTOR_FUNCTION0
define|#
directive|define
name|Q_DESTRUCTOR_FUNCTION0
parameter_list|(
name|AFUNC
parameter_list|)
define|\
value|namespace { \     static const struct AFUNC ## _dtor_class_ { \         inline AFUNC ## _dtor_class_() { } \         inline ~ AFUNC ## _dtor_class_() { AFUNC(); } \     } AFUNC ## _dtor_instance_; \     }
end_define
begin_define
DECL|macro|Q_DESTRUCTOR_FUNCTION
define|#
directive|define
name|Q_DESTRUCTOR_FUNCTION
parameter_list|(
name|AFUNC
parameter_list|)
value|Q_DESTRUCTOR_FUNCTION0(AFUNC)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|namespace
name|QtPrivate
block|{
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|AlignOfHelper
block|{
name|char
name|c
block|;
name|T
name|type
block|;
name|AlignOfHelper
argument_list|()
block|;
operator|~
name|AlignOfHelper
argument_list|()
block|;     }
expr_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|AlignOf_Default
block|{         enum
block|{
name|Value
operator|=
sizeof|sizeof
argument_list|(
name|AlignOfHelper
operator|<
name|T
operator|>
argument_list|)
operator|-
expr|sizeof
operator|(
name|T
operator|)
block|}
block|;     }
expr_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|AlignOf
operator|:
name|AlignOf_Default
operator|<
name|T
operator|>
block|{ }
expr_stmt|;
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|AlignOf
operator|<
name|T
operator|&
operator|>
operator|:
name|AlignOf
operator|<
name|T
operator|>
block|{}
expr_stmt|;
name|template
operator|<
name|size_t
name|N
operator|,
name|class
name|T
operator|>
expr|struct
name|AlignOf
operator|<
name|T
index|[
name|N
index|]
operator|>
operator|:
name|AlignOf
operator|<
name|T
operator|>
block|{}
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_COMPILER_RVALUE_REFS
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|AlignOf
operator|<
name|T
operator|&&
operator|>
operator|:
name|AlignOf
operator|<
name|T
operator|>
block|{}
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_PROCESSOR_X86_32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|AlignOf_WorkaroundForI386Abi
block|{ enum
block|{
name|Value
operator|=
expr|sizeof
operator|(
name|T
operator|)
block|}
block|; }
expr_stmt|;
comment|// x86 ABI weirdness
comment|// Alignment of naked type is 8, but inside struct has alignment 4.
name|template
operator|<
operator|>
expr|struct
name|AlignOf
operator|<
name|double
operator|>
operator|:
name|AlignOf_WorkaroundForI386Abi
operator|<
name|double
operator|>
block|{}
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|AlignOf
operator|<
name|qint64
operator|>
operator|:
name|AlignOf_WorkaroundForI386Abi
operator|<
name|qint64
operator|>
block|{}
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|AlignOf
operator|<
name|quint64
operator|>
operator|:
name|AlignOf_WorkaroundForI386Abi
operator|<
name|quint64
operator|>
block|{}
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_CC_CLANG
comment|// GCC and Clang seem to disagree wrt to alignment of arrays
name|template
operator|<
name|size_t
name|N
operator|>
expr|struct
name|AlignOf
operator|<
name|double
index|[
name|N
index|]
operator|>
operator|:
name|AlignOf_Default
operator|<
name|double
operator|>
block|{}
expr_stmt|;
name|template
operator|<
name|size_t
name|N
operator|>
expr|struct
name|AlignOf
operator|<
name|qint64
index|[
name|N
index|]
operator|>
operator|:
name|AlignOf_Default
operator|<
name|qint64
operator|>
block|{}
expr_stmt|;
name|template
operator|<
name|size_t
name|N
operator|>
expr|struct
name|AlignOf
operator|<
name|quint64
index|[
name|N
index|]
operator|>
operator|:
name|AlignOf_Default
operator|<
name|quint64
operator|>
block|{}
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_decl_stmt
begin_comment
comment|// namespace QtPrivate
end_comment
begin_define
DECL|macro|QT_EMULATED_ALIGNOF
define|#
directive|define
name|QT_EMULATED_ALIGNOF
parameter_list|(
name|T
parameter_list|)
define|\
value|(size_t(QT_PREPEND_NAMESPACE(QtPrivate)::AlignOf<T>::Value))
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|Q_ALIGNOF
end_ifndef
begin_define
DECL|macro|Q_ALIGNOF
define|#
directive|define
name|Q_ALIGNOF
parameter_list|(
name|T
parameter_list|)
value|QT_EMULATED_ALIGNOF(T)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*   quintptr and qptrdiff is guaranteed to be the same size as a pointer, i.e.        sizeof(void *) == sizeof(quintptr)&& sizeof(void *) == sizeof(qptrdiff) */
end_comment
begin_expr_stmt
name|template
operator|<
name|int
operator|>
expr|struct
name|QIntegerForSize
expr_stmt|;
end_expr_stmt
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
name|template
operator|<
operator|>
expr|struct
name|QIntegerForSize
operator|<
literal|1
operator|>
block|{
typedef|typedef
name|quint8
name|Unsigned
typedef|;
end_expr_stmt
begin_typedef
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
typedef|typedef
name|qint8
name|Signed
typedef|;
end_typedef
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
unit|};
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
name|template
operator|<
operator|>
expr|struct
name|QIntegerForSize
operator|<
literal|2
operator|>
block|{
typedef|typedef
name|quint16
name|Unsigned
typedef|;
end_expr_stmt
begin_typedef
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
typedef|typedef
name|qint16
name|Signed
typedef|;
end_typedef
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
unit|};
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
name|template
operator|<
operator|>
expr|struct
name|QIntegerForSize
operator|<
literal|4
operator|>
block|{
typedef|typedef
name|quint32
name|Unsigned
typedef|;
end_expr_stmt
begin_typedef
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
typedef|typedef
name|qint32
name|Signed
typedef|;
end_typedef
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
unit|};
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
name|template
operator|<
operator|>
expr|struct
name|QIntegerForSize
operator|<
literal|8
operator|>
block|{
typedef|typedef
name|quint64
name|Unsigned
typedef|;
end_expr_stmt
begin_typedef
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
typedef|typedef
name|qint64
name|Signed
typedef|;
end_typedef
begin_expr_stmt
DECL|struct|QIntegerForSize
DECL|typedef|Unsigned
DECL|typedef|Signed
unit|};
DECL|function|sizeof
name|template
operator|<
name|class
name|T
operator|>
expr|struct
name|QIntegerForSizeof
operator|:
name|QIntegerForSize
operator|<
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|>
block|{ }
expr_stmt|;
end_expr_stmt
begin_typedef
DECL|typedef|quintptr
typedef|typedef
name|QIntegerForSizeof
operator|<
name|void
operator|*
operator|>
operator|::
name|Unsigned
name|quintptr
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|qptrdiff
typedef|typedef
name|QIntegerForSizeof
operator|<
name|void
operator|*
operator|>
operator|::
name|Signed
name|qptrdiff
expr_stmt|;
end_typedef
begin_typedef
DECL|typedef|qintptr
typedef|typedef
name|qptrdiff
name|qintptr
typedef|;
end_typedef
begin_comment
comment|/* moc compats (signals/slots) */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_MOC_COMPAT
end_ifndef
begin_define
DECL|macro|QT_MOC_COMPAT
define|#
directive|define
name|QT_MOC_COMPAT
end_define
begin_else
else|#
directive|else
end_else
begin_undef
DECL|macro|QT_MOC_COMPAT
undef|#
directive|undef
name|QT_MOC_COMPAT
end_undef
begin_define
DECL|macro|QT_MOC_COMPAT
define|#
directive|define
name|QT_MOC_COMPAT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_ASCII_CAST_WARNINGS
end_ifdef
begin_define
DECL|macro|QT_ASCII_CAST_WARN
define|#
directive|define
name|QT_ASCII_CAST_WARN
value|Q_DECL_DEPRECATED
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_ASCII_CAST_WARN
define|#
directive|define
name|QT_ASCII_CAST_WARN
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
end_if
begin_define
DECL|macro|QT_FASTCALL
define|#
directive|define
name|QT_FASTCALL
value|__attribute__((regparm(3)))
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
end_elif
begin_define
DECL|macro|QT_FASTCALL
define|#
directive|define
name|QT_FASTCALL
value|__fastcall
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_FASTCALL
define|#
directive|define
name|QT_FASTCALL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_FASTCALL
define|#
directive|define
name|QT_FASTCALL
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//defines the type for the WNDPROC on windows
end_comment
begin_comment
comment|//the alignment needs to be forced for sse2 to not crash with mingw
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WIN64
argument_list|)
end_if
begin_define
DECL|macro|QT_ENSURE_STACK_ALIGNED_FOR_SSE
define|#
directive|define
name|QT_ENSURE_STACK_ALIGNED_FOR_SSE
value|__attribute__ ((force_align_arg_pointer))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_ENSURE_STACK_ALIGNED_FOR_SSE
define|#
directive|define
name|QT_ENSURE_STACK_ALIGNED_FOR_SSE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QT_WIN_CALLBACK
define|#
directive|define
name|QT_WIN_CALLBACK
value|CALLBACK QT_ENSURE_STACK_ALIGNED_FOR_SSE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|QNoImplicitBoolCast
typedef|typedef
name|int
name|QNoImplicitBoolCast
typedef|;
end_typedef
begin_comment
comment|/*    Utility macros and inline functions */
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qAbs
name|Q_DECL_CONSTEXPR
specifier|inline
name|T
name|qAbs
argument_list|(
argument|const T&t
argument_list|)
block|{
return|return
name|t
operator|>=
literal|0
operator|?
name|t
operator|:
operator|-
name|t
return|;
block|}
end_expr_stmt
begin_function
DECL|function|qRound
name|Q_DECL_CONSTEXPR
specifier|inline
name|int
name|qRound
parameter_list|(
name|double
name|d
parameter_list|)
block|{
return|return
name|d
operator|>=
literal|0.0
condition|?
name|int
argument_list|(
name|d
operator|+
literal|0.5
argument_list|)
else|:
name|int
argument_list|(
name|d
operator|-
name|double
argument_list|(
name|int
argument_list|(
name|d
operator|-
literal|1
argument_list|)
argument_list|)
operator|+
literal|0.5
argument_list|)
operator|+
name|int
argument_list|(
name|d
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qRound
name|Q_DECL_CONSTEXPR
specifier|inline
name|int
name|qRound
parameter_list|(
name|float
name|d
parameter_list|)
block|{
return|return
name|d
operator|>=
literal|0.0f
condition|?
name|int
argument_list|(
name|d
operator|+
literal|0.5f
argument_list|)
else|:
name|int
argument_list|(
name|d
operator|-
name|float
argument_list|(
name|int
argument_list|(
name|d
operator|-
literal|1
argument_list|)
argument_list|)
operator|+
literal|0.5f
argument_list|)
operator|+
name|int
argument_list|(
name|d
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_QDOC
end_ifdef
begin_comment
comment|/*     Just for documentation generation */
end_comment
begin_function_decl
name|int
name|qRound
parameter_list|(
name|qreal
name|d
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qRound64
name|Q_DECL_CONSTEXPR
specifier|inline
name|qint64
name|qRound64
parameter_list|(
name|double
name|d
parameter_list|)
block|{
return|return
name|d
operator|>=
literal|0.0
condition|?
name|qint64
argument_list|(
name|d
operator|+
literal|0.5
argument_list|)
else|:
name|qint64
argument_list|(
name|d
operator|-
name|double
argument_list|(
name|qint64
argument_list|(
name|d
operator|-
literal|1
argument_list|)
argument_list|)
operator|+
literal|0.5
argument_list|)
operator|+
name|qint64
argument_list|(
name|d
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qRound64
name|Q_DECL_CONSTEXPR
specifier|inline
name|qint64
name|qRound64
parameter_list|(
name|float
name|d
parameter_list|)
block|{
return|return
name|d
operator|>=
literal|0.0f
condition|?
name|qint64
argument_list|(
name|d
operator|+
literal|0.5f
argument_list|)
else|:
name|qint64
argument_list|(
name|d
operator|-
name|float
argument_list|(
name|qint64
argument_list|(
name|d
operator|-
literal|1
argument_list|)
argument_list|)
operator|+
literal|0.5f
argument_list|)
operator|+
name|qint64
argument_list|(
name|d
operator|-
literal|1
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_QDOC
end_ifdef
begin_comment
comment|/*     Just for documentation generation */
end_comment
begin_function_decl
name|qint64
name|qRound64
parameter_list|(
name|qreal
name|d
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qMin
name|Q_DECL_CONSTEXPR
specifier|inline
specifier|const
name|T
operator|&
name|qMin
argument_list|(
argument|const T&a
argument_list|,
argument|const T&b
argument_list|)
block|{
return|return
operator|(
name|a
operator|<
name|b
operator|)
operator|?
name|a
operator|:
name|b
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qMax
name|Q_DECL_CONSTEXPR
specifier|inline
specifier|const
name|T
operator|&
name|qMax
argument_list|(
argument|const T&a
argument_list|,
argument|const T&b
argument_list|)
block|{
return|return
operator|(
name|a
operator|<
name|b
operator|)
operator|?
name|b
operator|:
name|a
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qBound
name|Q_DECL_CONSTEXPR
specifier|inline
specifier|const
name|T
operator|&
name|qBound
argument_list|(
argument|const T&min
argument_list|,
argument|const T&val
argument_list|,
argument|const T&max
argument_list|)
block|{
return|return
name|qMax
argument_list|(
name|min
argument_list|,
name|qMin
argument_list|(
name|max
argument_list|,
name|val
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_DARWIN
end_ifdef
begin_define
DECL|macro|QT_MAC_PLATFORM_SDK_EQUAL_OR_ABOVE
define|#
directive|define
name|QT_MAC_PLATFORM_SDK_EQUAL_OR_ABOVE
parameter_list|(
name|osx
parameter_list|,
name|ios
parameter_list|)
define|\
value|(defined(__MAC_OS_X_VERSION_MAX_ALLOWED)&& __MAC_OS_X_VERSION_MAX_ALLOWED>= osx) || \     (defined(__IPHONE_OS_VERSION_MAX_ALLOWED)&& __IPHONE_OS_VERSION_MAX_ALLOWED>= ios)
end_define
begin_define
DECL|macro|QT_MAC_DEPLOYMENT_TARGET_BELOW
define|#
directive|define
name|QT_MAC_DEPLOYMENT_TARGET_BELOW
parameter_list|(
name|osx
parameter_list|,
name|ios
parameter_list|)
define|\
value|(defined(__MAC_OS_X_VERSION_MIN_REQUIRED)&& osx != __MAC_NA&& __MAC_OS_X_VERSION_MIN_REQUIRED< osx) || \     (defined(__IPHONE_OS_VERSION_MIN_REQUIRED)&& ios != __IPHONE_NA&& __IPHONE_OS_VERSION_MIN_REQUIRED< ios)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Data stream functions are provided by many classes (defined in qdatastream.h) */
end_comment
begin_decl_stmt
DECL|variable|QDataStream
name|class
name|QDataStream
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_VXWORKS
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_CRASHHANDLER
define|#
directive|define
name|QT_NO_CRASHHANDLER
end_define
begin_comment
DECL|macro|QT_NO_CRASHHANDLER
comment|// no popen
end_comment
begin_define
DECL|macro|QT_NO_PROCESS
define|#
directive|define
name|QT_NO_PROCESS
end_define
begin_comment
DECL|macro|QT_NO_PROCESS
comment|// no exec*, no fork
end_comment
begin_define
DECL|macro|QT_NO_SHAREDMEMORY
define|#
directive|define
name|QT_NO_SHAREDMEMORY
end_define
begin_comment
DECL|macro|QT_NO_SHAREDMEMORY
comment|// only POSIX, no SysV and in the end...
end_comment
begin_define
DECL|macro|QT_NO_SYSTEMSEMAPHORE
define|#
directive|define
name|QT_NO_SYSTEMSEMAPHORE
end_define
begin_comment
DECL|macro|QT_NO_SYSTEMSEMAPHORE
comment|// not needed at all in a flat address space
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_PROCESS
define|#
directive|define
name|QT_NO_PROCESS
end_define
begin_define
DECL|macro|QT_NO_FILESYSTEMWATCHER
define|#
directive|define
name|QT_NO_FILESYSTEMWATCHER
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qt_noop
specifier|inline
name|void
name|qt_noop
parameter_list|(
name|void
parameter_list|)
block|{}
end_function
begin_comment
comment|/* These wrap try/catch so we can switch off exceptions later.     Beware - do not use more than one QT_CATCH per QT_TRY, and do not use    the exception instance in the catch block.    If you can't live with those constraints, don't use these macros.    Use the QT_NO_EXCEPTIONS macro to protect your code instead. */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_EXCEPTIONS
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__EXCEPTIONS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_MOC_RUN
argument_list|)
operator|)
end_if
begin_define
DECL|macro|QT_NO_EXCEPTIONS
define|#
directive|define
name|QT_NO_EXCEPTIONS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_EXCEPTIONS
end_ifdef
begin_define
DECL|macro|QT_TRY
define|#
directive|define
name|QT_TRY
value|if (true)
end_define
begin_define
DECL|macro|QT_CATCH
define|#
directive|define
name|QT_CATCH
parameter_list|(
name|A
parameter_list|)
value|else
end_define
begin_define
DECL|macro|QT_THROW
define|#
directive|define
name|QT_THROW
parameter_list|(
name|A
parameter_list|)
value|qt_noop()
end_define
begin_define
DECL|macro|QT_RETHROW
define|#
directive|define
name|QT_RETHROW
value|qt_noop()
end_define
begin_define
DECL|macro|QT_TERMINATE_ON_EXCEPTION
define|#
directive|define
name|QT_TERMINATE_ON_EXCEPTION
parameter_list|(
name|expr
parameter_list|)
value|do { expr; } while (0)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_TRY
define|#
directive|define
name|QT_TRY
value|try
end_define
begin_define
DECL|macro|QT_CATCH
define|#
directive|define
name|QT_CATCH
parameter_list|(
name|A
parameter_list|)
value|catch (A)
end_define
begin_define
DECL|macro|QT_THROW
define|#
directive|define
name|QT_THROW
parameter_list|(
name|A
parameter_list|)
value|throw A
end_define
begin_define
DECL|macro|QT_RETHROW
define|#
directive|define
name|QT_RETHROW
value|throw
end_define
begin_expr_stmt
name|Q_NORETURN
name|Q_CORE_EXPORT
name|void
name|qTerminate
argument_list|()
name|Q_DECL_NOTHROW
expr_stmt|;
end_expr_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_NOEXCEPT
end_ifdef
begin_define
DECL|macro|QT_TERMINATE_ON_EXCEPTION
define|#
directive|define
name|QT_TERMINATE_ON_EXCEPTION
parameter_list|(
name|expr
parameter_list|)
value|do { expr; } while (0)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|QT_TERMINATE_ON_EXCEPTION
define|#
directive|define
name|QT_TERMINATE_ON_EXCEPTION
parameter_list|(
name|expr
parameter_list|)
value|do { try { expr; } catch (...) { qTerminate(); } } while (0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|Q_CORE_EXPORT
name|bool
name|qSharedBuild
argument_list|()
name|Q_DECL_NOTHROW
expr_stmt|;
end_expr_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|Q_OUTOFLINE_TEMPLATE
end_ifndef
begin_define
DECL|macro|Q_OUTOFLINE_TEMPLATE
define|#
directive|define
name|Q_OUTOFLINE_TEMPLATE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_INLINE_TEMPLATE
end_ifndef
begin_define
DECL|macro|Q_INLINE_TEMPLATE
define|#
directive|define
name|Q_INLINE_TEMPLATE
value|inline
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Avoid "unused parameter" warnings */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_if
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qUnused
specifier|inline
name|void
name|qUnused
argument_list|(
argument|T&x
argument_list|)
block|{
operator|(
name|void
operator|)
name|x
block|; }
DECL|macro|Q_UNUSED
define|#
directive|define
name|Q_UNUSED
parameter_list|(
name|x
parameter_list|)
value|qUnused(x);
else|#
directive|else
DECL|macro|Q_UNUSED
define|#
directive|define
name|Q_UNUSED
parameter_list|(
name|x
parameter_list|)
value|(void)x;
endif|#
directive|endif
comment|/*    Debugging and error handling */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
DECL|macro|QT_DEBUG
define|#
directive|define
name|QT_DEBUG
endif|#
directive|endif
ifndef|#
directive|ifndef
name|qPrintable
DECL|macro|qPrintable
define|#
directive|define
name|qPrintable
parameter_list|(
name|string
parameter_list|)
value|QString(string).toLocal8Bit().constData()
endif|#
directive|endif
DECL|variable|QString
name|class
name|QString
expr_stmt|;
end_expr_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|QString
name|qt_error_string
parameter_list|(
name|int
name|errorCode
init|=
operator|-
literal|1
parameter_list|)
function_decl|;
end_function_decl
begin_ifndef
ifndef|#
directive|ifndef
name|Q_CC_MSVC
end_ifndef
begin_decl_stmt
name|Q_NORETURN
endif|#
directive|endif
name|Q_CORE_EXPORT
name|void
name|qt_assert
argument_list|(
specifier|const
name|char
operator|*
name|assertion
argument_list|,
specifier|const
name|char
operator|*
name|file
argument_list|,
name|int
name|line
argument_list|)
name|Q_DECL_NOTHROW
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_ASSERT
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_FORCE_ASSERTS
argument_list|)
end_if
begin_define
DECL|macro|Q_ASSERT
define|#
directive|define
name|Q_ASSERT
parameter_list|(
name|cond
parameter_list|)
value|qt_noop()
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_ASSERT
define|#
directive|define
name|Q_ASSERT
parameter_list|(
name|cond
parameter_list|)
value|((!(cond)) ? qt_assert(#cond,__FILE__,__LINE__) : qt_noop())
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_PAINT_DEBUG
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_PAINT_DEBUG
define|#
directive|define
name|QT_NO_PAINT_DEBUG
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|Q_CC_MSVC
end_ifndef
begin_decl_stmt
name|Q_NORETURN
endif|#
directive|endif
name|Q_CORE_EXPORT
name|void
name|qt_assert_x
argument_list|(
specifier|const
name|char
operator|*
name|where
argument_list|,
specifier|const
name|char
operator|*
name|what
argument_list|,
specifier|const
name|char
operator|*
name|file
argument_list|,
name|int
name|line
argument_list|)
name|Q_DECL_NOTHROW
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_ASSERT_X
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_FORCE_ASSERTS
argument_list|)
end_if
begin_define
DECL|macro|Q_ASSERT_X
define|#
directive|define
name|Q_ASSERT_X
parameter_list|(
name|cond
parameter_list|,
name|where
parameter_list|,
name|what
parameter_list|)
value|qt_noop()
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_ASSERT_X
define|#
directive|define
name|Q_ASSERT_X
parameter_list|(
name|cond
parameter_list|,
name|where
parameter_list|,
name|what
parameter_list|)
value|((!(cond)) ? qt_assert_x(where, what,__FILE__,__LINE__) : qt_noop())
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_COMPILER_STATIC_ASSERT
end_ifdef
begin_define
DECL|macro|Q_STATIC_ASSERT
define|#
directive|define
name|Q_STATIC_ASSERT
parameter_list|(
name|Condition
parameter_list|)
value|static_assert(bool(Condition), #Condition)
end_define
begin_define
DECL|macro|Q_STATIC_ASSERT_X
define|#
directive|define
name|Q_STATIC_ASSERT_X
parameter_list|(
name|Condition
parameter_list|,
name|Message
parameter_list|)
value|static_assert(bool(Condition), Message)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|// Intentionally undefined
end_comment
begin_expr_stmt
DECL|variable|QStaticAssertFailure
name|template
operator|<
name|bool
name|Test
operator|>
name|class
name|QStaticAssertFailure
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|template
operator|<
operator|>
name|class
name|QStaticAssertFailure
operator|<
name|true
operator|>
block|{}
expr_stmt|;
end_expr_stmt
begin_define
DECL|macro|Q_STATIC_ASSERT_PRIVATE_JOIN
define|#
directive|define
name|Q_STATIC_ASSERT_PRIVATE_JOIN
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|Q_STATIC_ASSERT_PRIVATE_JOIN_IMPL(A, B)
end_define
begin_define
DECL|macro|Q_STATIC_ASSERT_PRIVATE_JOIN_IMPL
define|#
directive|define
name|Q_STATIC_ASSERT_PRIVATE_JOIN_IMPL
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|A ## B
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|__COUNTER__
end_ifdef
begin_define
DECL|macro|Q_STATIC_ASSERT
define|#
directive|define
name|Q_STATIC_ASSERT
parameter_list|(
name|Condition
parameter_list|)
define|\
value|enum {Q_STATIC_ASSERT_PRIVATE_JOIN(q_static_assert_result, __COUNTER__) = sizeof(QStaticAssertFailure<!!(Condition)>)}
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_STATIC_ASSERT
define|#
directive|define
name|Q_STATIC_ASSERT
parameter_list|(
name|Condition
parameter_list|)
define|\
value|enum {Q_STATIC_ASSERT_PRIVATE_JOIN(q_static_assert_result, __LINE__) = sizeof(QStaticAssertFailure<!!(Condition)>)}
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __COUNTER__ */
end_comment
begin_define
DECL|macro|Q_STATIC_ASSERT_X
define|#
directive|define
name|Q_STATIC_ASSERT_X
parameter_list|(
name|Condition
parameter_list|,
name|Message
parameter_list|)
value|Q_STATIC_ASSERT(Condition)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qt_check_pointer
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qBadAlloc
parameter_list|()
function_decl|;
end_function_decl
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_EXCEPTIONS
end_ifdef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
end_if
begin_define
DECL|macro|Q_CHECK_PTR
define|#
directive|define
name|Q_CHECK_PTR
parameter_list|(
name|p
parameter_list|)
value|qt_noop()
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CHECK_PTR
define|#
directive|define
name|Q_CHECK_PTR
parameter_list|(
name|p
parameter_list|)
value|do {if(!(p))qt_check_pointer(__FILE__,__LINE__);} while (0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_CHECK_PTR
define|#
directive|define
name|Q_CHECK_PTR
parameter_list|(
name|p
parameter_list|)
value|do { if (!(p)) qBadAlloc(); } while (0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|q_check_ptr
specifier|inline
name|T
operator|*
name|q_check_ptr
argument_list|(
argument|T *p
argument_list|)
block|{
name|Q_CHECK_PTR
argument_list|(
name|p
argument_list|)
block|;
return|return
name|p
return|;
block|}
end_expr_stmt
begin_typedef
DECL|typedef|QFunctionPointer
typedef|typedef
name|void
function_decl|(
modifier|*
name|QFunctionPointer
function_decl|)
parameter_list|()
function_decl|;
end_typedef
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_UNIMPLEMENTED
argument_list|)
end_if
begin_define
DECL|macro|Q_UNIMPLEMENTED
define|#
directive|define
name|Q_UNIMPLEMENTED
parameter_list|()
value|qWarning("%s:%d: %s: Unimplemented code.", __FILE__, __LINE__, Q_FUNC_INFO)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyCompare
argument_list|(
name|double
name|p1
argument_list|,
name|double
name|p2
argument_list|)
name|Q_REQUIRED_RESULT
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qFuzzyCompare
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyCompare
parameter_list|(
name|double
name|p1
parameter_list|,
name|double
name|p2
parameter_list|)
block|{
return|return
operator|(
name|qAbs
argument_list|(
name|p1
operator|-
name|p2
argument_list|)
operator|*
literal|1000000000000.
operator|<=
name|qMin
argument_list|(
name|qAbs
argument_list|(
name|p1
argument_list|)
argument_list|,
name|qAbs
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyCompare
argument_list|(
name|float
name|p1
argument_list|,
name|float
name|p2
argument_list|)
name|Q_REQUIRED_RESULT
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qFuzzyCompare
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyCompare
parameter_list|(
name|float
name|p1
parameter_list|,
name|float
name|p2
parameter_list|)
block|{
return|return
operator|(
name|qAbs
argument_list|(
name|p1
operator|-
name|p2
argument_list|)
operator|*
literal|100000.f
operator|<=
name|qMin
argument_list|(
name|qAbs
argument_list|(
name|p1
argument_list|)
argument_list|,
name|qAbs
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyIsNull
argument_list|(
name|double
name|d
argument_list|)
name|Q_REQUIRED_RESULT
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qFuzzyIsNull
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyIsNull
parameter_list|(
name|double
name|d
parameter_list|)
block|{
return|return
name|qAbs
argument_list|(
name|d
argument_list|)
operator|<=
literal|0.000000000001
return|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_decl_stmt
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyIsNull
argument_list|(
name|float
name|f
argument_list|)
name|Q_REQUIRED_RESULT
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qFuzzyIsNull
name|Q_DECL_CONSTEXPR
specifier|static
specifier|inline
name|bool
name|qFuzzyIsNull
parameter_list|(
name|float
name|f
parameter_list|)
block|{
return|return
name|qAbs
argument_list|(
name|f
argument_list|)
operator|<=
literal|0.00001f
return|;
block|}
end_function
begin_comment
comment|/*    This function tests a double for a null value. It doesn't    check whether the actual value is 0 or close to 0, but whether    it is binary 0, disregarding sign. */
end_comment
begin_decl_stmt
specifier|static
specifier|inline
name|bool
name|qIsNull
argument_list|(
name|double
name|d
argument_list|)
name|Q_REQUIRED_RESULT
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qIsNull
specifier|static
specifier|inline
name|bool
name|qIsNull
parameter_list|(
name|double
name|d
parameter_list|)
block|{
union|union
name|U
block|{
name|double
name|d
decl_stmt|;
name|quint64
name|u
decl_stmt|;
block|}
union|;
name|U
name|val
decl_stmt|;
name|val
operator|.
name|d
operator|=
name|d
expr_stmt|;
return|return
operator|(
name|val
operator|.
name|u
operator|&
name|Q_UINT64_C
argument_list|(
literal|0x7fffffffffffffff
argument_list|)
operator|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*    This function tests a float for a null value. It doesn't    check whether the actual value is 0 or close to 0, but whether    it is binary 0, disregarding sign. */
end_comment
begin_decl_stmt
specifier|static
specifier|inline
name|bool
name|qIsNull
argument_list|(
name|float
name|f
argument_list|)
name|Q_REQUIRED_RESULT
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qIsNull
specifier|static
specifier|inline
name|bool
name|qIsNull
parameter_list|(
name|float
name|f
parameter_list|)
block|{
union|union
name|U
block|{
name|float
name|f
decl_stmt|;
name|quint32
name|u
decl_stmt|;
block|}
union|;
name|U
name|val
decl_stmt|;
name|val
operator|.
name|f
operator|=
name|f
expr_stmt|;
return|return
operator|(
name|val
operator|.
name|u
operator|&
literal|0x7fffffff
operator|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*    Compilers which follow outdated template instantiation rules    require a class to have a comparison operator to exist when    a QList of this type is instantiated. It's not actually    used in the list, though. Hence the dummy implementation.    Just in case other code relies on it we better trigger a warning    mandating a real implementation. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_FULL_TEMPLATE_INSTANTIATION
end_ifdef
begin_define
DECL|macro|Q_DUMMY_COMPARISON_OPERATOR
define|#
directive|define
name|Q_DUMMY_COMPARISON_OPERATOR
parameter_list|(
name|C
parameter_list|)
define|\
value|bool operator==(const C&) const { \         qWarning(#C"::operator==(const "#C"&) was called"); \         return false; \     }
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_DUMMY_COMPARISON_OPERATOR
define|#
directive|define
name|Q_DUMMY_COMPARISON_OPERATOR
parameter_list|(
name|C
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qSwap
specifier|inline
name|void
name|qSwap
argument_list|(
argument|T&value1
argument_list|,
argument|T&value2
argument_list|)
block|{
name|using
name|std
operator|::
name|swap
block|;
name|swap
argument_list|(
name|value1
argument_list|,
name|value2
argument_list|)
block|; }
if|#
directive|if
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|0
argument_list|)
name|Q_CORE_EXPORT
name|QT_DEPRECATED
name|void
operator|*
name|qMalloc
argument_list|(
argument|size_t size
argument_list|)
name|Q_ALLOC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|QT_DEPRECATED
name|void
name|qFree
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|QT_DEPRECATED
name|void
modifier|*
name|qRealloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|Q_ALLOC_SIZE
parameter_list|(
function_decl|2
end_function_decl
begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|QT_DEPRECATED
name|void
modifier|*
name|qMemCopy
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|QT_DEPRECATED
name|void
modifier|*
name|qMemSet
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
name|int
name|c
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qMallocAligned
parameter_list|(
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|)
function_decl|Q_ALLOC_SIZE
parameter_list|(
function_decl|1
end_function_decl
begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|void
modifier|*
name|qReallocAligned
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|alignment
parameter_list|)
function_decl|Q_ALLOC_SIZE
parameter_list|(
function_decl|2
end_function_decl
begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qFreeAligned
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*    Avoid some particularly useless warnings from some stupid compilers.    To get ALL C++ compiler warnings, define QT_CC_WARNINGS or comment out    the line "#define QT_NO_WARNINGS". */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_CC_WARNINGS
argument_list|)
end_if
begin_define
DECL|macro|QT_NO_WARNINGS
define|#
directive|define
name|QT_NO_WARNINGS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_NO_WARNINGS
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4251
name|)
end_pragma
begin_comment
comment|/* class 'A' needs to have dll interface for to be used by clients of class 'B'. */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4244
name|)
end_pragma
begin_comment
comment|/* 'conversion' conversion from 'type1' to 'type2', possible loss of data */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4275
name|)
end_pragma
begin_comment
comment|/* non - DLL-interface classkey 'identifier' used as base for DLL-interface classkey 'identifier' */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4514
name|)
end_pragma
begin_comment
comment|/* unreferenced inline/local function has been removed */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4800
name|)
end_pragma
begin_comment
comment|/* 'type' : forcing value to bool 'true' or 'false' (performance warning) */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4097
name|)
end_pragma
begin_comment
comment|/* typedef-name 'identifier1' used as synonym for class-name 'identifier2' */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4706
name|)
end_pragma
begin_comment
comment|/* assignment within conditional expression */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4786
name|)
end_pragma
begin_comment
comment|/* truncating debug info after 255 characters */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4660
name|)
end_pragma
begin_comment
comment|/* template-class specialization 'identifier' is already instantiated */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4355
name|)
end_pragma
begin_comment
comment|/* 'this' : used in base member initializer list */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4231
name|)
end_pragma
begin_comment
comment|/* nonstandard extension used : 'extern' before template explicit instantiation */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4710
name|)
end_pragma
begin_comment
comment|/* function not inlined */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4530
name|)
end_pragma
begin_comment
comment|/* C++ exception handler used, but unwind semantics are not enabled. Specify -GX */
end_comment
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_CC_BOR
argument_list|)
end_elif
begin_pragma
pragma|#
directive|pragma
name|option
name|-
name|w
name|-
name|inl
end_pragma
begin_pragma
pragma|#
directive|pragma
name|option
name|-
name|w
name|-
name|aus
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|inl
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|pia
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|ccc
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|rch
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warn
name|-
name|sig
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_RVCT
argument_list|)
end_if
begin_comment
comment|/* make use of typeof-extension */
end_comment
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QForeachContainer
block|{
name|public
operator|:
specifier|inline
name|QForeachContainer
argument_list|(
specifier|const
name|T
operator|&
name|t
argument_list|)
operator|:
name|c
argument_list|(
name|t
argument_list|)
block|,
name|brk
argument_list|(
literal|0
argument_list|)
block|,
name|i
argument_list|(
name|c
operator|.
name|begin
argument_list|()
argument_list|)
block|,
name|e
argument_list|(
argument|c.end()
argument_list|)
block|{ }
specifier|const
name|T
name|c
block|;
name|int
name|brk
block|;
name|typename
name|T
operator|::
name|const_iterator
name|i
block|,
name|e
block|; }
expr_stmt|;
end_expr_stmt
begin_define
DECL|macro|Q_FOREACH
define|#
directive|define
name|Q_FOREACH
parameter_list|(
name|variable
parameter_list|,
name|container
parameter_list|)
define|\
value|for (QForeachContainer<__typeof__(container)> _container_(container); \      !_container_.brk&& _container_.i != _container_.e;              \      __extension__  ({ ++_container_.brk; ++_container_.i; }))                       \     for (variable = *_container_.i;; __extension__ ({--_container_.brk; break;}))
end_define
begin_else
else|#
directive|else
end_else
begin_struct
DECL|struct|QForeachContainerBase
struct|struct
name|QForeachContainerBase
block|{}
struct|;
end_struct
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|QForeachContainer
operator|:
name|public
name|QForeachContainerBase
block|{
name|public
operator|:
specifier|inline
name|QForeachContainer
argument_list|(
specifier|const
name|T
operator|&
name|t
argument_list|)
operator|:
name|c
argument_list|(
name|t
argument_list|)
block|,
name|brk
argument_list|(
literal|0
argument_list|)
block|,
name|i
argument_list|(
name|c
operator|.
name|begin
argument_list|()
argument_list|)
block|,
name|e
argument_list|(
argument|c.end()
argument_list|)
block|{}
specifier|const
name|T
name|c
block|;
name|mutable
name|int
name|brk
block|;
name|mutable
name|typename
name|T
operator|::
name|const_iterator
name|i
block|,
name|e
block|;
specifier|inline
name|bool
name|condition
argument_list|()
specifier|const
block|{
return|return
operator|(
operator|!
name|brk
operator|++
operator|&&
name|i
operator|!=
name|e
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
unit|};
DECL|function|qForeachPointer
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
operator|*
name|qForeachPointer
argument_list|(
argument|const T&
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|qForeachContainerNew
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|QForeachContainer
operator|<
name|T
operator|>
name|qForeachContainerNew
argument_list|(
argument|const T& t
argument_list|)
block|{
return|return
name|QForeachContainer
operator|<
name|T
operator|>
operator|(
name|t
operator|)
return|;
block|}
end_expr_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
DECL|function|qForeachContainer
specifier|inline
specifier|const
name|QForeachContainer
operator|<
name|T
operator|>
operator|*
name|qForeachContainer
argument_list|(
argument|const QForeachContainerBase *base
argument_list|,
argument|const T *
argument_list|)
block|{
return|return
name|static_cast
operator|<
specifier|const
name|QForeachContainer
operator|<
name|T
operator|>
operator|*
operator|>
operator|(
name|base
operator|)
return|;
block|}
end_expr_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_DIAB
argument_list|)
end_if
begin_comment
comment|// VxWorks DIAB generates unresolvable symbols, if container is a function call
end_comment
begin_define
DECL|macro|Q_FOREACH
define|#
directive|define
name|Q_FOREACH
parameter_list|(
name|variable
parameter_list|,
name|container
parameter_list|)
define|\
value|if(0){}else                                                                                     \     for (const QForeachContainerBase&_container_ = qForeachContainerNew(container);                \          qForeachContainer(&_container_, (__typeof__(container) *) 0)->condition();       \          ++qForeachContainer(&_container_, (__typeof__(container) *) 0)->i)               \         for (variable = *qForeachContainer(&_container_, (__typeof__(container) *) 0)->i; \              qForeachContainer(&_container_, (__typeof__(container) *) 0)->brk;           \              --qForeachContainer(&_container_, (__typeof__(container) *) 0)->brk)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_FOREACH
define|#
directive|define
name|Q_FOREACH
parameter_list|(
name|variable
parameter_list|,
name|container
parameter_list|)
define|\
value|for (const QForeachContainerBase&_container_ = qForeachContainerNew(container); \          qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->condition();       \          ++qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->i)               \         for (variable = *qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->i; \              qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->brk;           \              --qForeachContainer(&_container_, true ? 0 : qForeachPointer(container))->brk)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// MSVC6 || MIPSpro
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Q_FOREVER
define|#
directive|define
name|Q_FOREVER
value|for(;;)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_KEYWORDS
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|foreach
end_ifndef
begin_define
DECL|macro|foreach
define|#
directive|define
name|foreach
value|Q_FOREACH
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|forever
end_ifndef
begin_define
DECL|macro|forever
define|#
directive|define
name|forever
value|Q_FOREVER
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_expr_stmt
DECL|function|qGetPtrHelper
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
specifier|inline
name|T
operator|*
name|qGetPtrHelper
argument_list|(
argument|T *ptr
argument_list|)
block|{
return|return
name|ptr
return|;
block|}
end_expr_stmt
begin_expr_stmt
DECL|function|qGetPtrHelper
name|template
operator|<
name|typename
name|Wrapper
operator|>
specifier|static
specifier|inline
name|typename
name|Wrapper
operator|::
name|pointer
name|qGetPtrHelper
argument_list|(
argument|const Wrapper&p
argument_list|)
block|{
return|return
name|p
operator|.
name|data
argument_list|()
return|;
block|}
end_expr_stmt
begin_define
DECL|macro|Q_DECLARE_PRIVATE
define|#
directive|define
name|Q_DECLARE_PRIVATE
parameter_list|(
name|Class
parameter_list|)
define|\
value|inline Class##Private* d_func() { return reinterpret_cast<Class##Private *>(qGetPtrHelper(d_ptr)); } \     inline const Class##Private* d_func() const { return reinterpret_cast<const Class##Private *>(qGetPtrHelper(d_ptr)); } \     friend class Class##Private;
end_define
begin_define
DECL|macro|Q_DECLARE_PRIVATE_D
define|#
directive|define
name|Q_DECLARE_PRIVATE_D
parameter_list|(
name|Dptr
parameter_list|,
name|Class
parameter_list|)
define|\
value|inline Class##Private* d_func() { return reinterpret_cast<Class##Private *>(Dptr); } \     inline const Class##Private* d_func() const { return reinterpret_cast<const Class##Private *>(Dptr); } \     friend class Class##Private;
end_define
begin_define
DECL|macro|Q_DECLARE_PUBLIC
define|#
directive|define
name|Q_DECLARE_PUBLIC
parameter_list|(
name|Class
parameter_list|)
define|\
value|inline Class* q_func() { return static_cast<Class *>(q_ptr); } \     inline const Class* q_func() const { return static_cast<const Class *>(q_ptr); } \     friend class Class;
end_define
begin_define
DECL|macro|Q_D
define|#
directive|define
name|Q_D
parameter_list|(
name|Class
parameter_list|)
value|Class##Private * const d = d_func()
end_define
begin_define
DECL|macro|Q_Q
define|#
directive|define
name|Q_Q
parameter_list|(
name|Class
parameter_list|)
value|Class * const q = q_func()
end_define
begin_define
DECL|macro|QT_TR_NOOP
define|#
directive|define
name|QT_TR_NOOP
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|QT_TR_NOOP_UTF8
define|#
directive|define
name|QT_TR_NOOP_UTF8
parameter_list|(
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|QT_TRANSLATE_NOOP
define|#
directive|define
name|QT_TRANSLATE_NOOP
parameter_list|(
name|scope
parameter_list|,
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|QT_TRANSLATE_NOOP_UTF8
define|#
directive|define
name|QT_TRANSLATE_NOOP_UTF8
parameter_list|(
name|scope
parameter_list|,
name|x
parameter_list|)
value|x
end_define
begin_define
DECL|macro|QT_TRANSLATE_NOOP3
define|#
directive|define
name|QT_TRANSLATE_NOOP3
parameter_list|(
name|scope
parameter_list|,
name|x
parameter_list|,
name|comment
parameter_list|)
value|{x, comment}
end_define
begin_define
DECL|macro|QT_TRANSLATE_NOOP3_UTF8
define|#
directive|define
name|QT_TRANSLATE_NOOP3_UTF8
parameter_list|(
name|scope
parameter_list|,
name|x
parameter_list|,
name|comment
parameter_list|)
value|{x, comment}
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TRANSLATION
end_ifndef
begin_comment
comment|// ### This should enclose the NOOPs above
end_comment
begin_comment
comment|// Defined in qcoreapplication.cpp
end_comment
begin_comment
comment|// The better name qTrId() is reserved for an upcoming function which would
end_comment
begin_comment
comment|// return a much more powerful QStringFormatter instead of a QString.
end_comment
begin_function_decl
name|Q_CORE_EXPORT
name|QString
name|qtTrId
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|int
name|n
init|=
operator|-
literal|1
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|QT_TRID_NOOP
define|#
directive|define
name|QT_TRID_NOOP
parameter_list|(
name|id
parameter_list|)
value|id
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TRANSLATION
end_comment
begin_define
DECL|macro|QDOC_PROPERTY
define|#
directive|define
name|QDOC_PROPERTY
parameter_list|(
name|text
parameter_list|)
end_define
begin_comment
comment|/*    When RTTI is not available, define this macro to force any uses of    dynamic_cast to cause a compile failure. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|QT_NO_DYNAMIC_CAST
end_ifdef
begin_define
DECL|macro|dynamic_cast
define|#
directive|define
name|dynamic_cast
value|QT_PREPEND_NAMESPACE(qt_dynamic_cast_check)
end_define
begin_expr_stmt
DECL|variable|T
name|template
operator|<
name|typename
name|T
operator|,
name|typename
name|X
operator|>
DECL|function|qt_dynamic_cast_check
name|T
name|qt_dynamic_cast_check
argument_list|(
argument|X
argument_list|,
argument|T* =
literal|0
argument_list|)
block|{
return|return
name|T
operator|::
name|dynamic_cast_will_always_fail_because_rtti_is_disabled
return|;
block|}
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*    Some classes do not permit copies to be made of an object. These    classes contains a private copy constructor and assignment    operator to disable copying (the compiler gives an error message). */
end_comment
begin_define
DECL|macro|Q_DISABLE_COPY
define|#
directive|define
name|Q_DISABLE_COPY
parameter_list|(
name|Class
parameter_list|)
define|\
value|Class(const Class&) Q_DECL_EQ_DELETE;\     Class&operator=(const Class&) Q_DECL_EQ_DELETE;
end_define
begin_decl_stmt
DECL|variable|QByteArray
name|class
name|QByteArray
decl_stmt|;
end_decl_stmt
begin_function_decl
name|Q_CORE_EXPORT
name|QByteArray
name|qgetenv
parameter_list|(
specifier|const
name|char
modifier|*
name|varName
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|bool
name|qputenv
parameter_list|(
specifier|const
name|char
modifier|*
name|varName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|value
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|bool
name|qunsetenv
parameter_list|(
specifier|const
name|char
modifier|*
name|varName
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
name|Q_CORE_EXPORT
name|bool
name|qEnvironmentVariableIsEmpty
argument_list|(
specifier|const
name|char
operator|*
name|varName
argument_list|)
name|Q_DECL_NOEXCEPT
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|Q_CORE_EXPORT
name|bool
name|qEnvironmentVariableIsSet
argument_list|(
specifier|const
name|char
operator|*
name|varName
argument_list|)
name|Q_DECL_NOEXCEPT
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qIntCast
specifier|inline
name|int
name|qIntCast
parameter_list|(
name|double
name|f
parameter_list|)
block|{
return|return
name|int
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qIntCast
specifier|inline
name|int
name|qIntCast
parameter_list|(
name|float
name|f
parameter_list|)
block|{
return|return
name|int
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*   Reentrant versions of basic rand() functions for random number generation */
end_comment
begin_function_decl
name|Q_CORE_EXPORT
name|void
name|qsrand
parameter_list|(
name|uint
name|seed
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|Q_CORE_EXPORT
name|int
name|qrand
parameter_list|()
function_decl|;
end_function_decl
begin_define
DECL|macro|QT_MODULE
define|#
directive|define
name|QT_MODULE
parameter_list|(
name|x
parameter_list|)
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_QNX
end_ifdef
begin_comment
comment|// QNX doesn't have SYSV style shared memory. Multiprocess QWS apps,
end_comment
begin_comment
comment|// shared fonts and QSystemSemaphore + QSharedMemory are not available
end_comment
begin_define
DECL|macro|QT_NO_SYSTEMSEMAPHORE
define|#
directive|define
name|QT_NO_SYSTEMSEMAPHORE
end_define
begin_define
DECL|macro|QT_NO_SHAREDMEMORY
define|#
directive|define
name|QT_NO_SHAREDMEMORY
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_REDUCE_RELOCATIONS
argument_list|)
operator|&&
name|defined
argument_list|(
name|__ELF__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__PIC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__PIE__
argument_list|)
end_if
begin_error
error|#
directive|error
literal|"You must build your code with position independent code if Qt was built with -reduce-relocations. "
error|\
literal|"Compile your code with -fPIC or -fPIE."
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|namespace
name|QtPrivate
block|{
comment|//like std::enable_if
name|template
operator|<
name|bool
name|B
operator|,
name|typename
name|T
operator|=
name|void
operator|>
expr|struct
name|QEnableIf
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
expr|struct
name|QEnableIf
operator|<
name|true
operator|,
name|T
operator|>
block|{
typedef|typedef
name|T
name|Type
typedef|;
block|}
empty_stmt|;
block|}
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|__OBJC__
end_ifdef
begin_define
DECL|macro|Q_FORWARD_DECLARE_OBJC_CLASS
define|#
directive|define
name|Q_FORWARD_DECLARE_OBJC_CLASS
parameter_list|(
name|classname
parameter_list|)
value|@class classname
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|Q_FORWARD_DECLARE_OBJC_CLASS
define|#
directive|define
name|Q_FORWARD_DECLARE_OBJC_CLASS
parameter_list|(
name|classname
parameter_list|)
value|typedef struct objc_object classname
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Q_FORWARD_DECLARE_CF_TYPE
define|#
directive|define
name|Q_FORWARD_DECLARE_CF_TYPE
parameter_list|(
name|type
parameter_list|)
value|typedef const struct __ ## type * type ## Ref
end_define
begin_define
DECL|macro|Q_FORWARD_DECLARE_MUTABLE_CF_TYPE
define|#
directive|define
name|Q_FORWARD_DECLARE_MUTABLE_CF_TYPE
parameter_list|(
name|type
parameter_list|)
value|typedef struct __ ## type * type ## Ref
end_define
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_comment
comment|// Q_GLOBAL_STATIC
end_comment
begin_include
include|#
directive|include
file|<QtCore/qglobalstatic.h>
end_include
begin_comment
comment|// qDebug and friends
end_comment
begin_include
include|#
directive|include
file|<QtCore/qlogging.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qflags.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qsysinfo.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qtypeinfo.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __cplusplus */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* QGLOBAL_H */
end_comment
end_unit
