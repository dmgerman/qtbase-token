begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Copyright (C) 2014 Olivier Goffart<ogoffart@woboq.com> ** Copyright (C) 2014 Intel Corporation. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qlogging.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qbytearray.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qmutex.h"
end_include
begin_include
include|#
directive|include
file|"qloggingcategory.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_include
include|#
directive|include
file|"qelapsedtimer.h"
end_include
begin_include
include|#
directive|include
file|"qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_include
include|#
directive|include
file|"private/qloggingregistry_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qcoreapplication_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_include
include|#
directive|include
file|<qt_windows.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_USE_SLOG2
end_ifdef
begin_include
include|#
directive|include
file|<slog2.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_ANDROID
end_ifdef
begin_include
include|#
directive|include
file|<android/log.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_JOURNALD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
end_if
begin_define
DECL|macro|SD_JOURNAL_SUPPRESS_LOCATION
define|#
directive|define
name|SD_JOURNAL_SUPPRESS_LOCATION
end_define
begin_include
include|#
directive|include
file|<systemd/sd-journal.h>
end_include
begin_include
include|#
directive|include
file|<syslog.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_SYSLOG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
end_if
begin_include
include|#
directive|include
file|<syslog.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_UNIX
end_ifdef
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<sys/stat.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_include
include|#
directive|include
file|"private/qcore_unix_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|__has_include
end_ifndef
begin_define
DECL|macro|__has_include
define|#
directive|define
name|__has_include
parameter_list|(
name|x
parameter_list|)
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_if
if|#
directive|if
operator|!
name|defined
name|QT_NO_REGULAREXPRESSION
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|__UCLIBC__
end_ifdef
begin_if
if|#
directive|if
name|__UCLIBC_HAS_BACKTRACE__
end_if
begin_define
DECL|macro|QLOGGING_HAVE_BACKTRACE
define|#
directive|define
name|QLOGGING_HAVE_BACKTRACE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__GLIBCXX__
argument_list|)
operator|)
operator|||
operator|(
name|__has_include
argument_list|(
operator|<
name|cxxabi
operator|.
name|h
operator|>
argument_list|)
operator|&&
name|__has_include
argument_list|(
operator|<
name|execinfo
operator|.
name|h
operator|>
argument_list|)
operator|)
end_elif
begin_define
DECL|macro|QLOGGING_HAVE_BACKTRACE
define|#
directive|define
name|QLOGGING_HAVE_BACKTRACE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_SLOG2
argument_list|)
end_if
begin_decl_stmt
specifier|extern
name|char
modifier|*
name|__progname
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_LINUX
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
operator|||
name|__has_include
argument_list|(
operator|<
name|sys
operator|/
name|syscall
operator|.
name|h
operator|>
argument_list|)
operator|)
end_if
begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_gettid
argument_list|)
end_if
begin_define
DECL|macro|SYS_gettid
define|#
directive|define
name|SYS_gettid
value|__NR_gettid
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qt_gettid
specifier|static
name|long
name|qt_gettid
parameter_list|()
block|{
comment|// no error handling
comment|// this syscall has existed since Linux 2.4.11 and cannot fail
return|return
name|syscall
argument_list|(
name|SYS_gettid
argument_list|)
return|;
block|}
end_function
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
end_elif
begin_include
include|#
directive|include
file|<pthread.h>
end_include
begin_function
DECL|function|qt_gettid
specifier|static
name|int
name|qt_gettid
parameter_list|()
block|{
comment|// no error handling: this call cannot fail
name|__uint64_t
name|tid
decl_stmt|;
name|pthread_threadid_np
argument_list|(
name|NULL
argument_list|,
operator|&
name|tid
argument_list|)
expr_stmt|;
return|return
name|tid
return|;
block|}
end_function
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_FREEBSD_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|900031
end_elif
begin_include
include|#
directive|include
file|<pthread_np.h>
end_include
begin_function
DECL|function|qt_gettid
specifier|static
name|int
name|qt_gettid
parameter_list|()
block|{
return|return
name|pthread_getthreadid_np
argument_list|()
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_expr_stmt
DECL|function|qt_gettid
specifier|static
name|QT_PREPEND_NAMESPACE
argument_list|(
argument|qint64
argument_list|)
name|qt_gettid
argument_list|()
block|{
name|QT_USE_NAMESPACE
return|return
name|qintptr
argument_list|(
name|QThread
operator|::
name|currentThreadId
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QLOGGING_HAVE_BACKTRACE
end_ifdef
begin_include
include|#
directive|include
file|<qregularexpression.h>
end_include
begin_include
include|#
directive|include
file|<cxxabi.h>
end_include
begin_include
include|#
directive|include
file|<execinfo.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QT_BOOTSTRAPPED
end_comment
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
name|Q_NORETURN
endif|#
directive|endif
specifier|static
name|void
name|qt_message_fatal
parameter_list|(
name|QtMsgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|qt_message_print
parameter_list|(
name|QtMsgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|isFatal
specifier|static
name|bool
name|isFatal
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|)
block|{
if|if
condition|(
name|msgType
operator|==
name|QtFatalMsg
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|msgType
operator|==
name|QtCriticalMsg
condition|)
block|{
specifier|static
name|bool
name|fatalCriticals
init|=
operator|!
name|qEnvironmentVariableIsEmpty
argument_list|(
literal|"QT_FATAL_CRITICALS"
argument_list|)
decl_stmt|;
return|return
name|fatalCriticals
return|;
block|}
if|if
condition|(
name|msgType
operator|==
name|QtWarningMsg
operator|||
name|msgType
operator|==
name|QtCriticalMsg
condition|)
block|{
specifier|static
name|bool
name|fatalWarnings
init|=
operator|!
name|qEnvironmentVariableIsEmpty
argument_list|(
literal|"QT_FATAL_WARNINGS"
argument_list|)
decl_stmt|;
return|return
name|fatalWarnings
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|willLogToConsole
specifier|static
name|bool
name|willLogToConsole
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
comment|// these systems have no stderr, so always log to the system log
return|return
literal|false
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
return|return
literal|true
return|;
else|#
directive|else
comment|// rules to determine if we'll log preferably to the console:
comment|//  1) if QT_LOGGING_TO_CONSOLE is set, it determines behavior:
comment|//    - if it's set to 0, we will not log to console
comment|//    - if it's set to 1, we will log to console
comment|//  2) otherwise, we will log to console if we have a console window (Windows)
comment|//     or a controlling TTY (Unix). This is done even if stderr was redirected
comment|//     to the blackhole device (NUL or /dev/null).
name|bool
name|ok
init|=
literal|true
decl_stmt|;
name|uint
name|envcontrol
init|=
name|qgetenv
argument_list|(
literal|"QT_LOGGING_TO_CONSOLE"
argument_list|)
operator|.
name|toUInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
return|return
name|envcontrol
return|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
return|return
name|GetConsoleWindow
argument_list|()
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
comment|// if /dev/tty exists, we can only open it if we have a controlling TTY
name|int
name|devtty
init|=
name|qt_safe_open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDONLY
argument_list|)
decl_stmt|;
if|if
condition|(
name|devtty
operator|==
operator|-
literal|1
operator|&&
operator|(
name|errno
operator|==
name|ENOENT
operator|||
name|errno
operator|==
name|EPERM
operator|)
condition|)
block|{
comment|// no /dev/tty, fall back to isatty on stderr
return|return
name|isatty
argument_list|(
name|STDERR_FILENO
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|devtty
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// there is a /dev/tty and we could open it: we have a controlling TTY
name|qt_safe_close
argument_list|(
name|devtty
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// no controlling TTY
return|return
literal|false
return|;
else|#
directive|else
error|#
directive|error
literal|"Not Unix and not Windows?"
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|qt_logging_to_console
name|Q_CORE_EXPORT
name|bool
name|qt_logging_to_console
parameter_list|()
block|{
specifier|static
specifier|const
name|bool
name|logToConsole
init|=
name|willLogToConsole
argument_list|()
decl_stmt|;
return|return
name|logToConsole
return|;
block|}
end_function
begin_comment
comment|/*!     \class QMessageLogContext     \inmodule QtCore     \brief The QMessageLogContext class provides additional information about a log message.     \since 5.0      The class provides information about the source code location a qDebug(), qInfo(), qWarning(),     qCritical() or qFatal() message was generated.      \note By default, this information is recorded only in debug builds. You can overwrite     this explicitly by defining \c QT_MESSAGELOGCONTEXT or \c{QT_NO_MESSAGELOGCONTEXT}.      \sa QMessageLogger, QtMessageHandler, qInstallMessageHandler() */
end_comment
begin_comment
comment|/*!     \class QMessageLogger     \inmodule QtCore     \brief The QMessageLogger class generates log messages.     \since 5.0      QMessageLogger is used to generate messages for the Qt logging framework. Usually one uses     it through qDebug(), qInfo(), qWarning(), qCritical, or qFatal() functions,     which are actually macros: For example qDebug() expands to     QMessageLogger(__FILE__, __LINE__, Q_FUNC_INFO).debug()     for debug builds, and QMessageLogger(0, 0, 0).debug() for release builds.      One example of direct use is to forward errors that stem from a scripting language, e.g. QML:      \snippet code/qlogging/qlogging.cpp 1      \sa QMessageLogContext, qDebug(), qInfo(), qWarning(), qCritical(), qFatal() */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_function
specifier|static
specifier|inline
name|void
name|convert_to_wchar_t_elided
parameter_list|(
name|wchar_t
modifier|*
name|d
parameter_list|,
name|size_t
name|space
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
name|Q_DECL_NOEXCEPT
block|{
name|size_t
name|len
init|=
name|qstrlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|space
condition|)
block|{
specifier|const
name|size_t
name|skip
init|=
name|len
operator|-
name|space
operator|+
literal|4
decl_stmt|;
comment|// 4 for "..." + '\0'
name|s
operator|+=
name|skip
expr_stmt|;
name|len
operator|-=
name|skip
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
operator|*
name|d
operator|++
operator|=
literal|L'
expr|.'
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal */
end_comment
begin_function
name|Q_NEVER_INLINE
DECL|function|qt_message
specifier|static
name|QString
name|qt_message
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|QString
name|buf
init|=
name|QString
operator|::
name|vasprintf
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|qt_message_print
argument_list|(
name|msgType
argument_list|,
name|context
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function
begin_undef
DECL|macro|qDebug
undef|#
directive|undef
name|qDebug
end_undef
begin_comment
comment|/*!     Logs a debug message specified with format \a msg. Additional     parameters, specified by \a msg, may be used.      \sa qDebug() */
end_comment
begin_function
DECL|function|debug
name|void
name|QMessageLogger
operator|::
name|debug
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
specifier|const
name|QString
name|message
init|=
name|qt_message
argument_list|(
name|QtDebugMsg
argument_list|,
name|context
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtDebugMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtDebugMsg
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|qInfo
undef|#
directive|undef
name|qInfo
end_undef
begin_comment
comment|/*!     Logs an informational message specified with format \a msg. Additional     parameters, specified by \a msg, may be used.      \sa qInfo()     \since 5.5 */
end_comment
begin_function
DECL|function|info
name|void
name|QMessageLogger
operator|::
name|info
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
specifier|const
name|QString
name|message
init|=
name|qt_message
argument_list|(
name|QtInfoMsg
argument_list|,
name|context
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtInfoMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtInfoMsg
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \typedef QMessageLogger::CategoryFunction      This is a typedef for a pointer to a function with the following     signature:      \snippet code/qlogging/qlogging.cpp 2      A function which this signature is generated by Q_DECLARE_LOGGING_CATEGORY,     Q_LOGGING_CATEGORY.      \since 5.3 */
end_comment
begin_comment
comment|/*!     Logs a debug message specified with format \a msg for the context \a cat.     Additional parameters, specified by \a msg, may be used.      \since 5.3     \sa qCDebug() */
end_comment
begin_function
DECL|function|debug
name|void
name|QMessageLogger
operator|::
name|debug
parameter_list|(
specifier|const
name|QLoggingCategory
modifier|&
name|cat
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|cat
operator|.
name|isDebugEnabled
argument_list|()
condition|)
return|return;
name|QMessageLogContext
name|ctxt
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|category
operator|=
name|cat
operator|.
name|categoryName
argument_list|()
expr_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
specifier|const
name|QString
name|message
init|=
name|qt_message
argument_list|(
name|QtDebugMsg
argument_list|,
name|ctxt
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtDebugMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtDebugMsg
argument_list|,
name|ctxt
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Logs a debug message specified with format \a msg for the context returned     by \a catFunc. Additional parameters, specified by \a msg, may be used.      \since 5.3     \sa qCDebug() */
end_comment
begin_function
DECL|function|debug
name|void
name|QMessageLogger
operator|::
name|debug
parameter_list|(
name|QMessageLogger
operator|::
name|CategoryFunction
name|catFunc
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
specifier|const
name|QLoggingCategory
modifier|&
name|cat
init|=
call|(
modifier|*
name|catFunc
call|)
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cat
operator|.
name|isDebugEnabled
argument_list|()
condition|)
return|return;
name|QMessageLogContext
name|ctxt
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|category
operator|=
name|cat
operator|.
name|categoryName
argument_list|()
expr_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
specifier|const
name|QString
name|message
init|=
name|qt_message
argument_list|(
name|QtDebugMsg
argument_list|,
name|ctxt
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtDebugMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtDebugMsg
argument_list|,
name|ctxt
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_comment
comment|/*!     Logs a debug message using a QDebug stream      \sa qDebug(), QDebug */
end_comment
begin_function
DECL|function|debug
name|QDebug
name|QMessageLogger
operator|::
name|debug
parameter_list|()
specifier|const
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtDebugMsg
argument_list|)
decl_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_comment
comment|/*!     Logs a debug message into category \a cat using a QDebug stream.      \since 5.3     \sa qCDebug(), QDebug */
end_comment
begin_function
DECL|function|debug
name|QDebug
name|QMessageLogger
operator|::
name|debug
parameter_list|(
specifier|const
name|QLoggingCategory
modifier|&
name|cat
parameter_list|)
specifier|const
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtDebugMsg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cat
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|dbg
operator|.
name|stream
operator|->
name|message_output
operator|=
literal|false
expr_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|category
operator|=
name|cat
operator|.
name|categoryName
argument_list|()
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_comment
comment|/*!     Logs a debug message into category returned by \a catFunc using a QDebug stream.      \since 5.3     \sa qCDebug(), QDebug */
end_comment
begin_function
DECL|function|debug
name|QDebug
name|QMessageLogger
operator|::
name|debug
parameter_list|(
name|QMessageLogger
operator|::
name|CategoryFunction
name|catFunc
parameter_list|)
specifier|const
block|{
return|return
name|debug
argument_list|(
call|(
modifier|*
name|catFunc
call|)
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns a QNoDebug object, which is used to ignore debugging output.      \sa QNoDebug, qDebug() */
end_comment
begin_function
name|QNoDebug
name|QMessageLogger
operator|::
name|noDebug
parameter_list|()
specifier|const
name|Q_DECL_NOTHROW
block|{
return|return
name|QNoDebug
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Logs an informational message specified with format \a msg for the context \a cat.     Additional parameters, specified by \a msg, may be used.      \since 5.5     \sa qCInfo() */
end_comment
begin_function
DECL|function|info
name|void
name|QMessageLogger
operator|::
name|info
parameter_list|(
specifier|const
name|QLoggingCategory
modifier|&
name|cat
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|cat
operator|.
name|isInfoEnabled
argument_list|()
condition|)
return|return;
name|QMessageLogContext
name|ctxt
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|category
operator|=
name|cat
operator|.
name|categoryName
argument_list|()
expr_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
specifier|const
name|QString
name|message
init|=
name|qt_message
argument_list|(
name|QtInfoMsg
argument_list|,
name|ctxt
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtInfoMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtInfoMsg
argument_list|,
name|ctxt
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Logs an informational message specified with format \a msg for the context returned     by \a catFunc. Additional parameters, specified by \a msg, may be used.      \since 5.5     \sa qCInfo() */
end_comment
begin_function
DECL|function|info
name|void
name|QMessageLogger
operator|::
name|info
parameter_list|(
name|QMessageLogger
operator|::
name|CategoryFunction
name|catFunc
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
specifier|const
name|QLoggingCategory
modifier|&
name|cat
init|=
call|(
modifier|*
name|catFunc
call|)
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cat
operator|.
name|isInfoEnabled
argument_list|()
condition|)
return|return;
name|QMessageLogContext
name|ctxt
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|category
operator|=
name|cat
operator|.
name|categoryName
argument_list|()
expr_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
specifier|const
name|QString
name|message
init|=
name|qt_message
argument_list|(
name|QtInfoMsg
argument_list|,
name|ctxt
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtInfoMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtInfoMsg
argument_list|,
name|ctxt
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_comment
comment|/*!     Logs an informational message using a QDebug stream.      \since 5.5     \sa qInfo(), QDebug */
end_comment
begin_function
DECL|function|info
name|QDebug
name|QMessageLogger
operator|::
name|info
parameter_list|()
specifier|const
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtInfoMsg
argument_list|)
decl_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_comment
comment|/*!     Logs an informational message into the category \a cat using a QDebug stream.      \since 5.5     \sa qCInfo(), QDebug */
end_comment
begin_function
DECL|function|info
name|QDebug
name|QMessageLogger
operator|::
name|info
parameter_list|(
specifier|const
name|QLoggingCategory
modifier|&
name|cat
parameter_list|)
specifier|const
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtInfoMsg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cat
operator|.
name|isInfoEnabled
argument_list|()
condition|)
name|dbg
operator|.
name|stream
operator|->
name|message_output
operator|=
literal|false
expr_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|category
operator|=
name|cat
operator|.
name|categoryName
argument_list|()
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_comment
comment|/*!     Logs an informational message into category returned by \a catFunc using a QDebug stream.      \since 5.5     \sa qCInfo(), QDebug */
end_comment
begin_function
DECL|function|info
name|QDebug
name|QMessageLogger
operator|::
name|info
parameter_list|(
name|QMessageLogger
operator|::
name|CategoryFunction
name|catFunc
parameter_list|)
specifier|const
block|{
return|return
name|info
argument_list|(
call|(
modifier|*
name|catFunc
call|)
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|qWarning
undef|#
directive|undef
name|qWarning
end_undef
begin_comment
comment|/*!     Logs a warning message specified with format \a msg. Additional     parameters, specified by \a msg, may be used.      \sa qWarning() */
end_comment
begin_function
DECL|function|warning
name|void
name|QMessageLogger
operator|::
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
specifier|const
name|QString
name|message
init|=
name|qt_message
argument_list|(
name|QtWarningMsg
argument_list|,
name|context
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtWarningMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtWarningMsg
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Logs a warning message specified with format \a msg for the context \a cat.     Additional parameters, specified by \a msg, may be used.      \since 5.3     \sa qCWarning() */
end_comment
begin_function
DECL|function|warning
name|void
name|QMessageLogger
operator|::
name|warning
parameter_list|(
specifier|const
name|QLoggingCategory
modifier|&
name|cat
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|cat
operator|.
name|isWarningEnabled
argument_list|()
condition|)
return|return;
name|QMessageLogContext
name|ctxt
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|category
operator|=
name|cat
operator|.
name|categoryName
argument_list|()
expr_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
specifier|const
name|QString
name|message
init|=
name|qt_message
argument_list|(
name|QtWarningMsg
argument_list|,
name|ctxt
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtWarningMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtWarningMsg
argument_list|,
name|ctxt
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Logs a warning message specified with format \a msg for the context returned     by \a catFunc. Additional parameters, specified by \a msg, may be used.      \since 5.3     \sa qCWarning() */
end_comment
begin_function
DECL|function|warning
name|void
name|QMessageLogger
operator|::
name|warning
parameter_list|(
name|QMessageLogger
operator|::
name|CategoryFunction
name|catFunc
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
specifier|const
name|QLoggingCategory
modifier|&
name|cat
init|=
call|(
modifier|*
name|catFunc
call|)
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cat
operator|.
name|isWarningEnabled
argument_list|()
condition|)
return|return;
name|QMessageLogContext
name|ctxt
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|category
operator|=
name|cat
operator|.
name|categoryName
argument_list|()
expr_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
specifier|const
name|QString
name|message
init|=
name|qt_message
argument_list|(
name|QtWarningMsg
argument_list|,
name|ctxt
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtWarningMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtWarningMsg
argument_list|,
name|ctxt
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_comment
comment|/*!     Logs a warning message using a QDebug stream      \sa qWarning(), QDebug */
end_comment
begin_function
DECL|function|warning
name|QDebug
name|QMessageLogger
operator|::
name|warning
parameter_list|()
specifier|const
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtWarningMsg
argument_list|)
decl_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_comment
comment|/*!     Logs a warning message into category \a cat using a QDebug stream.      \sa qCWarning(), QDebug */
end_comment
begin_function
DECL|function|warning
name|QDebug
name|QMessageLogger
operator|::
name|warning
parameter_list|(
specifier|const
name|QLoggingCategory
modifier|&
name|cat
parameter_list|)
specifier|const
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtWarningMsg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cat
operator|.
name|isWarningEnabled
argument_list|()
condition|)
name|dbg
operator|.
name|stream
operator|->
name|message_output
operator|=
literal|false
expr_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|category
operator|=
name|cat
operator|.
name|categoryName
argument_list|()
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_comment
comment|/*!     Logs a warning message into category returned by \a catFunc using a QDebug stream.      \since 5.3     \sa qCWarning(), QDebug */
end_comment
begin_function
DECL|function|warning
name|QDebug
name|QMessageLogger
operator|::
name|warning
parameter_list|(
name|QMessageLogger
operator|::
name|CategoryFunction
name|catFunc
parameter_list|)
specifier|const
block|{
return|return
name|warning
argument_list|(
call|(
modifier|*
name|catFunc
call|)
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|qCritical
undef|#
directive|undef
name|qCritical
end_undef
begin_comment
comment|/*!     Logs a critical message specified with format \a msg. Additional     parameters, specified by \a msg, may be used.      \sa qCritical() */
end_comment
begin_function
DECL|function|critical
name|void
name|QMessageLogger
operator|::
name|critical
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
specifier|const
name|QString
name|message
init|=
name|qt_message
argument_list|(
name|QtCriticalMsg
argument_list|,
name|context
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtCriticalMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtCriticalMsg
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Logs a critical message specified with format \a msg for the context \a cat.     Additional parameters, specified by \a msg, may be used.      \since 5.3     \sa qCCritical() */
end_comment
begin_function
DECL|function|critical
name|void
name|QMessageLogger
operator|::
name|critical
parameter_list|(
specifier|const
name|QLoggingCategory
modifier|&
name|cat
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|cat
operator|.
name|isCriticalEnabled
argument_list|()
condition|)
return|return;
name|QMessageLogContext
name|ctxt
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|category
operator|=
name|cat
operator|.
name|categoryName
argument_list|()
expr_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
specifier|const
name|QString
name|message
init|=
name|qt_message
argument_list|(
name|QtCriticalMsg
argument_list|,
name|ctxt
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtCriticalMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtCriticalMsg
argument_list|,
name|ctxt
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Logs a critical message specified with format \a msg for the context returned     by \a catFunc. Additional parameters, specified by \a msg, may be used.      \since 5.3     \sa qCCritical() */
end_comment
begin_function
DECL|function|critical
name|void
name|QMessageLogger
operator|::
name|critical
parameter_list|(
name|QMessageLogger
operator|::
name|CategoryFunction
name|catFunc
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
specifier|const
name|QLoggingCategory
modifier|&
name|cat
init|=
call|(
modifier|*
name|catFunc
call|)
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cat
operator|.
name|isCriticalEnabled
argument_list|()
condition|)
return|return;
name|QMessageLogContext
name|ctxt
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|category
operator|=
name|cat
operator|.
name|categoryName
argument_list|()
expr_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
specifier|const
name|QString
name|message
init|=
name|qt_message
argument_list|(
name|QtCriticalMsg
argument_list|,
name|ctxt
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtCriticalMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtCriticalMsg
argument_list|,
name|ctxt
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_comment
comment|/*!     Logs a critical message using a QDebug stream      \sa qCritical(), QDebug */
end_comment
begin_function
DECL|function|critical
name|QDebug
name|QMessageLogger
operator|::
name|critical
parameter_list|()
specifier|const
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtCriticalMsg
argument_list|)
decl_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_comment
comment|/*!     Logs a critical message into category \a cat using a QDebug stream.      \since 5.3     \sa qCCritical(), QDebug */
end_comment
begin_function
DECL|function|critical
name|QDebug
name|QMessageLogger
operator|::
name|critical
parameter_list|(
specifier|const
name|QLoggingCategory
modifier|&
name|cat
parameter_list|)
specifier|const
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtCriticalMsg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cat
operator|.
name|isCriticalEnabled
argument_list|()
condition|)
name|dbg
operator|.
name|stream
operator|->
name|message_output
operator|=
literal|false
expr_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|category
operator|=
name|cat
operator|.
name|categoryName
argument_list|()
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_comment
comment|/*!     Logs a critical message into category returned by \a catFunc using a QDebug stream.      \since 5.3     \sa qCCritical(), QDebug */
end_comment
begin_function
DECL|function|critical
name|QDebug
name|QMessageLogger
operator|::
name|critical
parameter_list|(
name|QMessageLogger
operator|::
name|CategoryFunction
name|catFunc
parameter_list|)
specifier|const
block|{
return|return
name|critical
argument_list|(
call|(
modifier|*
name|catFunc
call|)
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|qFatal
undef|#
directive|undef
name|qFatal
end_undef
begin_comment
comment|/*!     Logs a fatal message specified with format \a msg. Additional     parameters, specified by \a msg, may be used.      \sa qFatal() */
end_comment
begin_function
name|void
name|QMessageLogger
operator|::
name|fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
name|Q_DECL_NOTHROW
block|{
name|QString
name|message
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
name|QT_TERMINATE_ON_EXCEPTION
argument_list|(
name|message
operator|=
name|qt_message
argument_list|(
name|QtFatalMsg
argument_list|,
name|context
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|qt_message_fatal
argument_list|(
name|QtFatalMsg
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qCleanupFuncinfo
name|Q_AUTOTEST_EXPORT
name|QByteArray
name|qCleanupFuncinfo
parameter_list|(
name|QByteArray
name|info
parameter_list|)
block|{
comment|// Strip the function info down to the base function name
comment|// note that this throws away the template definitions,
comment|// the parameter types (overloads) and any const/volatile qualifiers.
if|if
condition|(
name|info
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|info
return|;
name|int
name|pos
decl_stmt|;
comment|// Skip trailing [with XXX] for templates (gcc), but make
comment|// sure to not affect Objective-C message names.
name|pos
operator|=
name|info
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|endsWith
argument_list|(
literal|']'
argument_list|)
operator|&&
operator|!
operator|(
name|info
operator|.
name|startsWith
argument_list|(
literal|'+'
argument_list|)
operator|||
name|info
operator|.
name|startsWith
argument_list|(
literal|'-'
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
operator|--
name|pos
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|'['
condition|)
name|info
operator|.
name|truncate
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|// operator names with '(', ')', '<', '>' in it
specifier|static
specifier|const
name|char
name|operator_call
index|[]
init|=
literal|"operator()"
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_lessThan
index|[]
init|=
literal|"operator<"
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_greaterThan
index|[]
init|=
literal|"operator>"
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_lessThanEqual
index|[]
init|=
literal|"operator<="
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_greaterThanEqual
index|[]
init|=
literal|"operator>="
decl_stmt|;
comment|// canonize operator names
name|info
operator|.
name|replace
argument_list|(
literal|"operator "
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
comment|// remove argument list
forever|forever
block|{
name|int
name|parencount
init|=
literal|0
decl_stmt|;
name|pos
operator|=
name|info
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Don't know how to parse this function name
return|return
name|info
return|;
block|}
comment|// find the beginning of the argument list
operator|--
name|pos
expr_stmt|;
operator|++
name|parencount
expr_stmt|;
while|while
condition|(
name|pos
operator|&&
name|parencount
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|')'
condition|)
operator|++
name|parencount
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|'('
condition|)
operator|--
name|parencount
expr_stmt|;
operator|--
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|parencount
operator|!=
literal|0
condition|)
return|return
name|info
return|;
name|info
operator|.
name|truncate
argument_list|(
operator|++
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_call
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_call
argument_list|)
condition|)
break|break;
comment|// this function returns a pointer to a function
comment|// and we matched the arguments of the return type's parameter list
comment|// try again
name|info
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|info
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|// find the beginning of the function name
name|int
name|parencount
init|=
literal|0
decl_stmt|;
name|int
name|templatecount
init|=
literal|0
decl_stmt|;
operator|--
name|pos
expr_stmt|;
comment|// make sure special characters in operator names are kept
if|if
condition|(
name|pos
operator|>
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
condition|)
block|{
case|case
literal|')'
case|:
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_call
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_call
argument_list|)
operator|+
literal|1
condition|)
name|pos
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_lessThan
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_lessThan
argument_list|)
operator|+
literal|1
condition|)
operator|--
name|pos
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_greaterThan
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_greaterThan
argument_list|)
operator|+
literal|1
condition|)
operator|--
name|pos
expr_stmt|;
break|break;
case|case
literal|'='
case|:
block|{
name|int
name|operatorLength
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_lessThanEqual
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_lessThanEqual
argument_list|)
operator|==
name|pos
operator|-
name|operatorLength
operator|+
literal|1
condition|)
name|pos
operator|-=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_greaterThanEqual
argument_list|)
operator|==
name|pos
operator|-
name|operatorLength
operator|+
literal|1
condition|)
name|pos
operator|-=
literal|2
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
while|while
condition|(
name|pos
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|parencount
operator|<
literal|0
operator|||
name|templatecount
operator|<
literal|0
condition|)
return|return
name|info
return|;
name|char
name|c
init|=
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
operator|++
name|parencount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
operator|--
name|parencount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
operator|++
name|templatecount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
operator|--
name|templatecount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|templatecount
operator|==
literal|0
operator|&&
name|parencount
operator|==
literal|0
condition|)
break|break;
operator|--
name|pos
expr_stmt|;
block|}
name|info
operator|=
name|info
operator|.
name|mid
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// remove trailing '*', '&' that are part of the return argument
while|while
condition|(
operator|(
name|info
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'*'
operator|)
operator|||
operator|(
name|info
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'&'
operator|)
condition|)
name|info
operator|=
name|info
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// we have the full function name now.
comment|// clean up the templates
while|while
condition|(
operator|(
name|pos
operator|=
name|info
operator|.
name|lastIndexOf
argument_list|(
literal|'>'
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|.
name|contains
argument_list|(
literal|'<'
argument_list|)
condition|)
break|break;
comment|// find the matching close
name|int
name|end
init|=
name|pos
decl_stmt|;
name|templatecount
operator|=
literal|1
expr_stmt|;
operator|--
name|pos
expr_stmt|;
while|while
condition|(
name|pos
operator|&&
name|templatecount
condition|)
block|{
name|char
name|c
init|=
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
operator|++
name|templatecount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
operator|--
name|templatecount
expr_stmt|;
operator|--
name|pos
expr_stmt|;
block|}
operator|++
name|pos
expr_stmt|;
name|info
operator|.
name|remove
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
end_function
begin_comment
comment|// tokens as recognized in QT_MESSAGE_PATTERN
end_comment
begin_decl_stmt
DECL|variable|categoryTokenC
specifier|static
specifier|const
name|char
name|categoryTokenC
index|[]
init|=
literal|"%{category}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|typeTokenC
specifier|static
specifier|const
name|char
name|typeTokenC
index|[]
init|=
literal|"%{type}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|messageTokenC
specifier|static
specifier|const
name|char
name|messageTokenC
index|[]
init|=
literal|"%{message}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fileTokenC
specifier|static
specifier|const
name|char
name|fileTokenC
index|[]
init|=
literal|"%{file}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|lineTokenC
specifier|static
specifier|const
name|char
name|lineTokenC
index|[]
init|=
literal|"%{line}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|functionTokenC
specifier|static
specifier|const
name|char
name|functionTokenC
index|[]
init|=
literal|"%{function}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pidTokenC
specifier|static
specifier|const
name|char
name|pidTokenC
index|[]
init|=
literal|"%{pid}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|appnameTokenC
specifier|static
specifier|const
name|char
name|appnameTokenC
index|[]
init|=
literal|"%{appname}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|threadidTokenC
specifier|static
specifier|const
name|char
name|threadidTokenC
index|[]
init|=
literal|"%{threadid}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qthreadptrTokenC
specifier|static
specifier|const
name|char
name|qthreadptrTokenC
index|[]
init|=
literal|"%{qthreadptr}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|timeTokenC
specifier|static
specifier|const
name|char
name|timeTokenC
index|[]
init|=
literal|"%{time"
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|timeTokenC
comment|//not a typo: this command has arguments
end_comment
begin_decl_stmt
DECL|variable|backtraceTokenC
specifier|static
specifier|const
name|char
name|backtraceTokenC
index|[]
init|=
literal|"%{backtrace"
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|backtraceTokenC
comment|//ditto
end_comment
begin_decl_stmt
DECL|variable|ifCategoryTokenC
specifier|static
specifier|const
name|char
name|ifCategoryTokenC
index|[]
init|=
literal|"%{if-category}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ifDebugTokenC
specifier|static
specifier|const
name|char
name|ifDebugTokenC
index|[]
init|=
literal|"%{if-debug}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ifInfoTokenC
specifier|static
specifier|const
name|char
name|ifInfoTokenC
index|[]
init|=
literal|"%{if-info}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ifWarningTokenC
specifier|static
specifier|const
name|char
name|ifWarningTokenC
index|[]
init|=
literal|"%{if-warning}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ifCriticalTokenC
specifier|static
specifier|const
name|char
name|ifCriticalTokenC
index|[]
init|=
literal|"%{if-critical}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ifFatalTokenC
specifier|static
specifier|const
name|char
name|ifFatalTokenC
index|[]
init|=
literal|"%{if-fatal}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|endifTokenC
specifier|static
specifier|const
name|char
name|endifTokenC
index|[]
init|=
literal|"%{endif}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|emptyTokenC
specifier|static
specifier|const
name|char
name|emptyTokenC
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|defaultPattern
specifier|static
specifier|const
name|char
name|defaultPattern
index|[]
init|=
literal|"%{if-category}%{category}: %{endif}%{message}"
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|QMessagePattern
struct|struct
name|QMessagePattern
block|{
name|QMessagePattern
parameter_list|()
constructor_decl|;
name|~
name|QMessagePattern
parameter_list|()
destructor_decl|;
name|void
name|setPattern
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|)
function_decl|;
comment|// 0 terminated arrays of literal tokens / literal or placeholder tokens
DECL|member|literals
specifier|const
name|char
modifier|*
modifier|*
name|literals
decl_stmt|;
DECL|member|tokens
specifier|const
name|char
modifier|*
modifier|*
name|tokens
decl_stmt|;
DECL|member|timeArgs
name|QList
argument_list|<
name|QString
argument_list|>
name|timeArgs
decl_stmt|;
comment|// timeFormats in sequence of %{time
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
DECL|member|timer
name|QElapsedTimer
name|timer
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QLOGGING_HAVE_BACKTRACE
DECL|struct|BacktraceParams
struct|struct
name|BacktraceParams
block|{
DECL|member|backtraceSeparator
name|QString
name|backtraceSeparator
decl_stmt|;
DECL|member|backtraceDepth
name|int
name|backtraceDepth
decl_stmt|;
block|}
struct|;
DECL|member|backtraceArgs
name|QVector
argument_list|<
name|BacktraceParams
argument_list|>
name|backtraceArgs
decl_stmt|;
comment|// backtrace argumens in sequence of %{backtrace
endif|#
directive|endif
DECL|member|fromEnvironment
name|bool
name|fromEnvironment
decl_stmt|;
DECL|member|mutex
specifier|static
name|QBasicMutex
name|mutex
decl_stmt|;
block|}
struct|;
end_struct
begin_ifdef
ifdef|#
directive|ifdef
name|QLOGGING_HAVE_BACKTRACE
end_ifdef
begin_expr_stmt
name|Q_DECLARE_TYPEINFO
argument_list|(
name|QMessagePattern
operator|::
name|BacktraceParams
argument_list|,
name|Q_MOVABLE_TYPE
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|member|mutex
name|QBasicMutex
name|QMessagePattern
operator|::
name|mutex
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QMessagePattern
name|QMessagePattern
operator|::
name|QMessagePattern
parameter_list|()
member_init_list|:
name|literals
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|tokens
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|fromEnvironment
argument_list|(
literal|false
argument_list|)
block|{
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|timer
operator|.
name|start
argument_list|()
expr_stmt|;
endif|#
directive|endif
specifier|const
name|QString
name|envPattern
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"QT_MESSAGE_PATTERN"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|envPattern
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|setPattern
argument_list|(
name|QLatin1String
argument_list|(
name|defaultPattern
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setPattern
argument_list|(
name|envPattern
argument_list|)
expr_stmt|;
name|fromEnvironment
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~QMessagePattern
name|QMessagePattern
operator|::
name|~
name|QMessagePattern
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|literals
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
operator|delete
index|[]
name|literals
index|[
name|i
index|]
expr_stmt|;
operator|delete
index|[]
name|literals
expr_stmt|;
name|literals
operator|=
literal|0
expr_stmt|;
operator|delete
index|[]
name|tokens
expr_stmt|;
name|tokens
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|setPattern
name|void
name|QMessagePattern
operator|::
name|setPattern
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|)
block|{
if|if
condition|(
name|literals
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|literals
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
operator|delete
index|[]
name|literals
index|[
name|i
index|]
expr_stmt|;
operator|delete
index|[]
name|literals
expr_stmt|;
block|}
operator|delete
index|[]
name|tokens
expr_stmt|;
comment|// scanner
name|QList
argument_list|<
name|QString
argument_list|>
name|lexemes
decl_stmt|;
name|QString
name|lexeme
decl_stmt|;
name|bool
name|inPlaceholder
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pattern
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QChar
name|c
init|=
name|pattern
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
operator|)
operator|&&
operator|!
name|inPlaceholder
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|<
name|pattern
operator|.
name|size
argument_list|()
operator|)
operator|&&
name|pattern
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
comment|// beginning of placeholder
if|if
condition|(
operator|!
name|lexeme
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lexemes
operator|.
name|append
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
name|lexeme
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|inPlaceholder
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|lexeme
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
operator|&&
name|inPlaceholder
operator|)
condition|)
block|{
comment|// end of placeholder
name|lexemes
operator|.
name|append
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
name|lexeme
operator|.
name|clear
argument_list|()
expr_stmt|;
name|inPlaceholder
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|lexeme
operator|.
name|isEmpty
argument_list|()
condition|)
name|lexemes
operator|.
name|append
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
comment|// tokenizer
name|QVarLengthArray
argument_list|<
specifier|const
name|char
modifier|*
argument_list|>
name|literalsVar
decl_stmt|;
name|tokens
operator|=
operator|new
specifier|const
name|char
operator|*
index|[
name|lexemes
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
expr_stmt|;
name|tokens
index|[
name|lexemes
operator|.
name|size
argument_list|()
index|]
operator|=
literal|0
expr_stmt|;
name|bool
name|nestedIfError
init|=
literal|false
decl_stmt|;
name|bool
name|inIf
init|=
literal|false
decl_stmt|;
name|QString
name|error
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lexemes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
name|lexeme
init|=
name|lexemes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|lexeme
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"%{"
argument_list|)
argument_list|)
operator|&&
name|lexeme
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
argument_list|)
condition|)
block|{
comment|// placeholder
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|typeTokenC
argument_list|)
condition|)
block|{
name|tokens
index|[
name|i
index|]
operator|=
name|typeTokenC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|categoryTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|categoryTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|messageTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|messageTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|fileTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|fileTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|lineTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|lineTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|functionTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|functionTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|pidTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|pidTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|appnameTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|appnameTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|threadidTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|threadidTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|qthreadptrTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|qthreadptrTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
name|timeTokenC
argument_list|)
argument_list|)
condition|)
block|{
name|tokens
index|[
name|i
index|]
operator|=
name|timeTokenC
expr_stmt|;
name|int
name|spaceIdx
init|=
name|lexeme
operator|.
name|indexOf
argument_list|(
name|QChar
operator|::
name|fromLatin1
argument_list|(
literal|' '
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|spaceIdx
operator|>
literal|0
condition|)
name|timeArgs
operator|.
name|append
argument_list|(
name|lexeme
operator|.
name|mid
argument_list|(
name|spaceIdx
operator|+
literal|1
argument_list|,
name|lexeme
operator|.
name|length
argument_list|()
operator|-
name|spaceIdx
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|timeArgs
operator|.
name|append
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lexeme
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
name|backtraceTokenC
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QLOGGING_HAVE_BACKTRACE
name|tokens
index|[
name|i
index|]
operator|=
name|backtraceTokenC
expr_stmt|;
name|QString
name|backtraceSeparator
init|=
name|QStringLiteral
argument_list|(
literal|"|"
argument_list|)
decl_stmt|;
name|int
name|backtraceDepth
init|=
literal|5
decl_stmt|;
name|QRegularExpression
name|depthRx
argument_list|(
name|QStringLiteral
argument_list|(
literal|" depth=(?|\"([^\"]*)\"|([^ }]*))"
argument_list|)
argument_list|)
decl_stmt|;
name|QRegularExpression
name|separatorRx
argument_list|(
name|QStringLiteral
argument_list|(
literal|" separator=(?|\"([^\"]*)\"|([^ }]*))"
argument_list|)
argument_list|)
decl_stmt|;
name|QRegularExpressionMatch
name|m
init|=
name|depthRx
operator|.
name|match
argument_list|(
name|lexeme
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|hasMatch
argument_list|()
condition|)
block|{
name|int
name|depth
init|=
name|m
operator|.
name|capturedRef
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|depth
operator|<=
literal|0
condition|)
name|error
operator|+=
name|QStringLiteral
argument_list|(
literal|"QT_MESSAGE_PATTERN: %{backtrace} depth must be a number greater than 0\n"
argument_list|)
expr_stmt|;
else|else
name|backtraceDepth
operator|=
name|depth
expr_stmt|;
block|}
name|m
operator|=
name|separatorRx
operator|.
name|match
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|hasMatch
argument_list|()
condition|)
name|backtraceSeparator
operator|=
name|m
operator|.
name|captured
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|BacktraceParams
name|backtraceParams
decl_stmt|;
name|backtraceParams
operator|.
name|backtraceDepth
operator|=
name|backtraceDepth
expr_stmt|;
name|backtraceParams
operator|.
name|backtraceSeparator
operator|=
name|backtraceSeparator
expr_stmt|;
name|backtraceArgs
operator|.
name|append
argument_list|(
name|backtraceParams
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|+=
name|QStringLiteral
argument_list|(
literal|"QT_MESSAGE_PATTERN: %{backtrace} is not supported by this Qt build\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
DECL|macro|IF_TOKEN
define|#
directive|define
name|IF_TOKEN
parameter_list|(
name|LEVEL
parameter_list|)
define|\
value|else if (lexeme == QLatin1String(LEVEL)) { \                 if (inIf) \                     nestedIfError = true; \                 tokens[i] = LEVEL; \                 inIf = true; \             }
name|IF_TOKEN
argument_list|(
argument|ifCategoryTokenC
argument_list|)
name|IF_TOKEN
argument_list|(
argument|ifDebugTokenC
argument_list|)
name|IF_TOKEN
argument_list|(
argument|ifInfoTokenC
argument_list|)
name|IF_TOKEN
argument_list|(
argument|ifWarningTokenC
argument_list|)
name|IF_TOKEN
argument_list|(
argument|ifCriticalTokenC
argument_list|)
name|IF_TOKEN
argument_list|(
argument|ifFatalTokenC
argument_list|)
DECL|macro|IF_TOKEN
undef|#
directive|undef
name|IF_TOKEN
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|endifTokenC
argument_list|)
condition|)
block|{
name|tokens
index|[
name|i
index|]
operator|=
name|endifTokenC
expr_stmt|;
if|if
condition|(
operator|!
name|inIf
operator|&&
operator|!
name|nestedIfError
condition|)
name|error
operator|+=
name|QStringLiteral
argument_list|(
literal|"QT_MESSAGE_PATTERN: %{endif} without an %{if-*}\n"
argument_list|)
expr_stmt|;
name|inIf
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|tokens
index|[
name|i
index|]
operator|=
name|emptyTokenC
expr_stmt|;
name|error
operator|+=
name|QStringLiteral
argument_list|(
literal|"QT_MESSAGE_PATTERN: Unknown placeholder %1\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|literal
init|=
operator|new
name|char
index|[
name|lexeme
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|strncpy
argument_list|(
name|literal
argument_list|,
name|lexeme
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|lexeme
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|literal
index|[
name|lexeme
operator|.
name|size
argument_list|()
index|]
operator|=
literal|'\0'
expr_stmt|;
name|literalsVar
operator|.
name|append
argument_list|(
name|literal
argument_list|)
expr_stmt|;
name|tokens
index|[
name|i
index|]
operator|=
name|literal
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nestedIfError
condition|)
name|error
operator|+=
name|QStringLiteral
argument_list|(
literal|"QT_MESSAGE_PATTERN: %{if-*} cannot be nested\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|inIf
condition|)
name|error
operator|+=
name|QStringLiteral
argument_list|(
literal|"QT_MESSAGE_PATTERN: missing %{endif}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINRT
argument_list|)
name|OutputDebugString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|error
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
if|if
condition|(
operator|!
name|qt_logging_to_console
argument_list|()
condition|)
block|{
name|OutputDebugString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|error
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|error
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|literals
operator|=
operator|new
specifier|const
name|char
operator|*
index|[
name|literalsVar
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
expr_stmt|;
name|literals
index|[
name|literalsVar
operator|.
name|size
argument_list|()
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|literals
argument_list|,
name|literalsVar
operator|.
name|constData
argument_list|()
argument_list|,
name|literalsVar
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_SLOG2
argument_list|)
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|QT_LOG_CODE
end_ifndef
begin_define
DECL|macro|QT_LOG_CODE
define|#
directive|define
name|QT_LOG_CODE
value|9000
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|slog2_default_handler
specifier|static
name|void
name|slog2_default_handler
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
if|if
condition|(
name|slog2_set_default_buffer
argument_list|(
operator|(
name|slog2_buffer_t
operator|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|slog2_buffer_set_config_t
name|buffer_config
decl_stmt|;
name|slog2_buffer_t
name|buffer_handle
decl_stmt|;
name|buffer_config
operator|.
name|buffer_set_name
operator|=
name|__progname
expr_stmt|;
name|buffer_config
operator|.
name|num_buffers
operator|=
literal|1
expr_stmt|;
name|buffer_config
operator|.
name|verbosity_level
operator|=
name|SLOG2_DEBUG1
expr_stmt|;
name|buffer_config
operator|.
name|buffer_config
index|[
literal|0
index|]
operator|.
name|buffer_name
operator|=
literal|"default"
expr_stmt|;
name|buffer_config
operator|.
name|buffer_config
index|[
literal|0
index|]
operator|.
name|num_pages
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|slog2_register
argument_list|(
operator|&
name|buffer_config
argument_list|,
operator|&
name|buffer_handle
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error registering slogger2 buffer!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Set as the default buffer
name|slog2_set_default_buffer
argument_list|(
name|buffer_handle
argument_list|)
expr_stmt|;
block|}
name|int
name|severity
decl_stmt|;
comment|//Determines the severity level
switch|switch
condition|(
name|msgType
condition|)
block|{
case|case
name|QtDebugMsg
case|:
name|severity
operator|=
name|SLOG2_DEBUG1
expr_stmt|;
break|break;
case|case
name|QtInfoMsg
case|:
name|severity
operator|=
name|SLOG2_INFO
expr_stmt|;
break|break;
case|case
name|QtWarningMsg
case|:
name|severity
operator|=
name|SLOG2_NOTICE
expr_stmt|;
break|break;
case|case
name|QtCriticalMsg
case|:
name|severity
operator|=
name|SLOG2_WARNING
expr_stmt|;
break|break;
case|case
name|QtFatalMsg
case|:
name|severity
operator|=
name|SLOG2_ERROR
expr_stmt|;
break|break;
block|}
comment|//writes to the slog2 buffer
name|slog2c
argument_list|(
name|NULL
argument_list|,
name|QT_LOG_CODE
argument_list|,
name|severity
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_USE_SLOG2
end_comment
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QMessagePattern
argument_list|,
argument|qMessagePattern
argument_list|)
end_macro
begin_comment
comment|/*!     \relates<QtGlobal>     \since 5.4      Generates a formatted string out of the \a type, \a context, \a str arguments.      qFormatLogMessage returns a QString that is formatted according to the current message pattern.     It can be used by custom message handlers to format output similar to Qt's default message     handler.      The function is thread-safe.      \sa qInstallMessageHandler(), qSetMessagePattern()  */
end_comment
begin_function
DECL|function|qFormatLogMessage
name|QString
name|qFormatLogMessage
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|QString
name|message
decl_stmt|;
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|QMessagePattern
operator|::
name|mutex
argument_list|)
decl_stmt|;
name|QMessagePattern
modifier|*
name|pattern
init|=
name|qMessagePattern
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
block|{
comment|// after destruction of static QMessagePattern instance
name|message
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
name|bool
name|skip
init|=
literal|false
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
name|int
name|timeArgsIdx
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|QLOGGING_HAVE_BACKTRACE
name|int
name|backtraceArgsIdx
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|// we do not convert file, function, line literals to local encoding due to overhead
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|pattern
operator|->
name|tokens
index|[
name|i
index|]
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|token
init|=
name|pattern
operator|->
name|tokens
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|endifTokenC
condition|)
block|{
name|skip
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip
condition|)
block|{
comment|// we skip adding messages, but we have to iterate over
comment|// timeArgsIdx and backtraceArgsIdx anyway
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
if|if
condition|(
name|token
operator|==
name|timeTokenC
condition|)
name|timeArgsIdx
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|QLOGGING_HAVE_BACKTRACE
elseif|else
if|if
condition|(
name|token
operator|==
name|backtraceTokenC
condition|)
name|backtraceArgsIdx
operator|++
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|messageTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|categoryTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
name|context
operator|.
name|category
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|typeTokenC
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QtDebugMsg
case|:
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"debug"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QtInfoMsg
case|:
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"info"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QtWarningMsg
case|:
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"warning"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QtCriticalMsg
case|:
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"critical"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QtFatalMsg
case|:
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"fatal"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|fileTokenC
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|file
condition|)
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
name|context
operator|.
name|file
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"unknown"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|lineTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|context
operator|.
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|functionTokenC
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|function
condition|)
name|message
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|qCleanupFuncinfo
argument_list|(
name|context
operator|.
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"unknown"
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|pidTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|QCoreApplication
operator|::
name|applicationPid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|appnameTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QCoreApplication
operator|::
name|applicationName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|threadidTokenC
condition|)
block|{
comment|// print the TID as decimal
name|message
operator|.
name|append
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|qt_gettid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|qthreadptrTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"0x"
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|qlonglong
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|->
name|currentThread
argument_list|()
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QLOGGING_HAVE_BACKTRACE
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|backtraceTokenC
condition|)
block|{
name|QMessagePattern
operator|::
name|BacktraceParams
name|backtraceParams
init|=
name|pattern
operator|->
name|backtraceArgs
operator|.
name|at
argument_list|(
name|backtraceArgsIdx
argument_list|)
decl_stmt|;
name|QString
name|backtraceSeparator
init|=
name|backtraceParams
operator|.
name|backtraceSeparator
decl_stmt|;
name|int
name|backtraceDepth
init|=
name|backtraceParams
operator|.
name|backtraceDepth
decl_stmt|;
name|backtraceArgsIdx
operator|++
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|void
modifier|*
argument_list|,
literal|32
argument_list|>
name|buffer
argument_list|(
literal|7
operator|+
name|backtraceDepth
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|backtrace
argument_list|(
name|buffer
operator|.
name|data
argument_list|()
argument_list|,
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|int
name|numberPrinted
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
operator|&&
name|numberPrinted
operator|<
name|backtraceDepth
condition|;
operator|++
name|i
control|)
block|{
name|QScopedPointer
argument_list|<
name|char
modifier|*
argument_list|,
name|QScopedPointerPodDeleter
argument_list|>
name|strings
argument_list|(
name|backtrace_symbols
argument_list|(
name|buffer
operator|.
name|data
argument_list|()
operator|+
name|i
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|trace
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|strings
operator|.
name|data
argument_list|()
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|// The results of backtrace_symbols looks like this:
comment|//    /lib/libc.so.6(__libc_start_main+0xf3) [0x4a937413]
comment|// The offset and function name are optional.
comment|// This regexp tries to extract the librry name (without the path) and the function name.
comment|// This code is protected by QMessagePattern::mutex so it is thread safe on all compilers
specifier|static
name|QRegularExpression
name|rx
argument_list|(
name|QStringLiteral
argument_list|(
literal|"^(?:[^(]*/)?([^(/]+)\\(([^+]*)(?:[\\+[a-f0-9x]*)?\\) \\[[a-f0-9x]*\\]$"
argument_list|)
argument_list|,
name|QRegularExpression
operator|::
name|OptimizeOnFirstUsageOption
argument_list|)
decl_stmt|;
name|QRegularExpressionMatch
name|m
init|=
name|rx
operator|.
name|match
argument_list|(
name|trace
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|hasMatch
argument_list|()
condition|)
block|{
comment|// skip the trace from QtCore that are because of the qDebug itself
name|QString
name|library
init|=
name|m
operator|.
name|captured
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|QString
name|function
init|=
name|m
operator|.
name|captured
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|numberPrinted
operator|&&
name|library
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"Qt5Core"
argument_list|)
argument_list|)
operator|&&
operator|(
name|function
operator|.
name|isEmpty
argument_list|()
operator|||
name|function
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"Message"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|||
name|function
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"QDebug"
argument_list|)
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|function
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"_Z"
argument_list|)
argument_list|)
condition|)
block|{
name|QScopedPointer
argument_list|<
name|char
argument_list|,
name|QScopedPointerPodDeleter
argument_list|>
name|demangled
argument_list|(
name|abi
operator|::
name|__cxa_demangle
argument_list|(
name|function
operator|.
name|toUtf8
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|demangled
condition|)
name|function
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|qCleanupFuncinfo
argument_list|(
name|demangled
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numberPrinted
operator|>
literal|0
condition|)
name|message
operator|.
name|append
argument_list|(
name|backtraceSeparator
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|numberPrinted
operator|==
literal|0
operator|&&
name|context
operator|.
name|function
condition|)
name|message
operator|+=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|qCleanupFuncinfo
argument_list|(
name|context
operator|.
name|function
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|message
operator|+=
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
operator|+
name|library
operator|+
name|QLatin1Char
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
operator|+=
name|function
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|numberPrinted
operator|==
literal|0
condition|)
continue|continue;
name|message
operator|+=
name|backtraceSeparator
operator|+
name|QLatin1String
argument_list|(
literal|"???"
argument_list|)
expr_stmt|;
block|}
name|numberPrinted
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|timeTokenC
condition|)
block|{
name|QString
name|timeFormat
init|=
name|pattern
operator|->
name|timeArgs
operator|.
name|at
argument_list|(
name|timeArgsIdx
argument_list|)
decl_stmt|;
name|timeArgsIdx
operator|++
expr_stmt|;
if|if
condition|(
name|timeFormat
operator|==
name|QLatin1String
argument_list|(
literal|"process"
argument_list|)
condition|)
block|{
name|quint64
name|ms
init|=
name|pattern
operator|->
name|timer
operator|.
name|elapsed
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
name|QString
operator|::
name|asprintf
argument_list|(
literal|"%6d.%03d"
argument_list|,
name|uint
argument_list|(
name|ms
operator|/
literal|1000
argument_list|)
argument_list|,
name|uint
argument_list|(
name|ms
operator|%
literal|1000
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timeFormat
operator|==
name|QLatin1String
argument_list|(
literal|"boot"
argument_list|)
condition|)
block|{
comment|// just print the milliseconds since the elapsed timer reference
comment|// like the Linux kernel does
name|QElapsedTimer
name|now
decl_stmt|;
name|now
operator|.
name|start
argument_list|()
expr_stmt|;
name|uint
name|ms
init|=
name|now
operator|.
name|msecsSinceReference
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
name|QString
operator|::
name|asprintf
argument_list|(
literal|"%6d.%03d"
argument_list|,
name|uint
argument_list|(
name|ms
operator|/
literal|1000
argument_list|)
argument_list|,
name|uint
argument_list|(
name|ms
operator|%
literal|1000
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timeFormat
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
operator|.
name|append
argument_list|(
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|toString
argument_list|(
name|timeFormat
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|ifCategoryTokenC
condition|)
block|{
if|if
condition|(
operator|!
name|context
operator|.
name|category
operator|||
operator|(
name|strcmp
argument_list|(
name|context
operator|.
name|category
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|skip
operator|=
literal|true
expr_stmt|;
DECL|macro|HANDLE_IF_TOKEN
define|#
directive|define
name|HANDLE_IF_TOKEN
parameter_list|(
name|LEVEL
parameter_list|)
define|\
value|} else if (token == if##LEVEL##TokenC) { \             skip = type != Qt##LEVEL##Msg;
name|HANDLE_IF_TOKEN
argument_list|(
argument|Debug
argument_list|)
name|HANDLE_IF_TOKEN
argument_list|(
argument|Info
argument_list|)
name|HANDLE_IF_TOKEN
argument_list|(
argument|Warning
argument_list|)
name|HANDLE_IF_TOKEN
argument_list|(
argument|Critical
argument_list|)
name|HANDLE_IF_TOKEN
argument_list|(
argument|Fatal
argument_list|)
DECL|macro|HANDLE_IF_TOKEN
undef|#
directive|undef
name|HANDLE_IF_TOKEN
block|}
else|else
block|{
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|message
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|0
argument_list|)
end_if
begin_comment
comment|// make sure they're defined to be exported
end_comment
begin_typedef
DECL|typedef|QtMsgHandler
typedef|typedef
name|void
function_decl|(
modifier|*
name|QtMsgHandler
function_decl|)
parameter_list|(
name|QtMsgType
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_typedef
begin_function_decl
name|Q_CORE_EXPORT
name|QtMsgHandler
name|qInstallMsgHandler
parameter_list|(
name|QtMsgHandler
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|static
name|void
name|qDefaultMsgHandler
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|qDefaultMessageHandler
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|buf
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|// pointer to QtMsgHandler debug handler (without context)
end_comment
begin_expr_stmt
DECL|variable|msgHandler
specifier|static
name|QBasicAtomicPointer
operator|<
name|void
argument_list|(
name|QtMsgType
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|>
name|msgHandler
operator|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
name|qDefaultMsgHandler
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|// pointer to QtMessageHandler debug handler (with context)
end_comment
begin_expr_stmt
DECL|variable|messageHandler
specifier|static
name|QBasicAtomicPointer
operator|<
name|void
argument_list|(
name|QtMsgType
argument_list|,
specifier|const
name|QMessageLogContext
operator|&
argument_list|,
specifier|const
name|QString
operator|&
argument_list|)
operator|>
name|messageHandler
operator|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
name|qDefaultMessageHandler
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_JOURNALD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
end_if
begin_function
DECL|function|systemd_default_message_handler
specifier|static
name|void
name|systemd_default_message_handler
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
block|{
name|int
name|priority
init|=
name|LOG_INFO
decl_stmt|;
comment|// Informational
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QtDebugMsg
case|:
name|priority
operator|=
name|LOG_DEBUG
expr_stmt|;
comment|// Debug-level messages
break|break;
case|case
name|QtInfoMsg
case|:
name|priority
operator|=
name|LOG_INFO
expr_stmt|;
comment|// Informational conditions
break|break;
case|case
name|QtWarningMsg
case|:
name|priority
operator|=
name|LOG_WARNING
expr_stmt|;
comment|// Warning conditions
break|break;
case|case
name|QtCriticalMsg
case|:
name|priority
operator|=
name|LOG_CRIT
expr_stmt|;
comment|// Critical conditions
break|break;
case|case
name|QtFatalMsg
case|:
name|priority
operator|=
name|LOG_ALERT
expr_stmt|;
comment|// Action must be taken immediately
break|break;
block|}
name|sd_journal_send
argument_list|(
literal|"MESSAGE=%s"
argument_list|,
name|message
operator|.
name|toUtf8
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
literal|"PRIORITY=%i"
argument_list|,
name|priority
argument_list|,
literal|"CODE_FUNC=%s"
argument_list|,
name|context
operator|.
name|function
condition|?
name|context
operator|.
name|function
else|:
literal|"unknown"
argument_list|,
literal|"CODE_LINE=%d"
argument_list|,
name|context
operator|.
name|line
argument_list|,
literal|"CODE_FILE=%s"
argument_list|,
name|context
operator|.
name|file
condition|?
name|context
operator|.
name|file
else|:
literal|"unknown"
argument_list|,
literal|"QT_CATEGORY=%s"
argument_list|,
name|context
operator|.
name|category
condition|?
name|context
operator|.
name|category
else|:
literal|"unknown"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_USE_SYSLOG
end_ifdef
begin_function
DECL|function|syslog_default_message_handler
specifier|static
name|void
name|syslog_default_message_handler
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|int
name|priority
init|=
name|LOG_INFO
decl_stmt|;
comment|// Informational
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QtDebugMsg
case|:
name|priority
operator|=
name|LOG_DEBUG
expr_stmt|;
comment|// Debug-level messages
break|break;
case|case
name|QtInfoMsg
case|:
name|priority
operator|=
name|LOG_INFO
expr_stmt|;
comment|// Informational conditions
break|break;
case|case
name|QtWarningMsg
case|:
name|priority
operator|=
name|LOG_WARNING
expr_stmt|;
comment|// Warning conditions
break|break;
case|case
name|QtCriticalMsg
case|:
name|priority
operator|=
name|LOG_CRIT
expr_stmt|;
comment|// Critical conditions
break|break;
case|case
name|QtFatalMsg
case|:
name|priority
operator|=
name|LOG_ALERT
expr_stmt|;
comment|// Action must be taken immediately
break|break;
block|}
name|syslog
argument_list|(
name|priority
argument_list|,
literal|"%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_ANDROID
end_ifdef
begin_function
DECL|function|android_default_message_handler
specifier|static
name|void
name|android_default_message_handler
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
block|{
name|android_LogPriority
name|priority
init|=
name|ANDROID_LOG_DEBUG
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QtDebugMsg
case|:
name|priority
operator|=
name|ANDROID_LOG_DEBUG
expr_stmt|;
break|break;
case|case
name|QtInfoMsg
case|:
name|priority
operator|=
name|ANDROID_LOG_INFO
expr_stmt|;
break|break;
case|case
name|QtWarningMsg
case|:
name|priority
operator|=
name|ANDROID_LOG_WARN
expr_stmt|;
break|break;
case|case
name|QtCriticalMsg
case|:
name|priority
operator|=
name|ANDROID_LOG_ERROR
expr_stmt|;
break|break;
case|case
name|QtFatalMsg
case|:
name|priority
operator|=
name|ANDROID_LOG_FATAL
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|__android_log_print
argument_list|(
name|priority
argument_list|,
name|qPrintable
argument_list|(
name|QCoreApplication
operator|::
name|applicationName
argument_list|()
argument_list|)
argument_list|,
literal|"%s:%d (%s): %s\n"
argument_list|,
name|context
operator|.
name|file
argument_list|,
name|context
operator|.
name|line
argument_list|,
name|context
operator|.
name|function
argument_list|,
name|qPrintable
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//Q_OS_ANDROID
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qDefaultMessageHandler
specifier|static
name|void
name|qDefaultMessageHandler
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|buf
parameter_list|)
block|{
name|QString
name|logMessage
init|=
name|qFormatLogMessage
argument_list|(
name|type
argument_list|,
name|context
argument_list|,
name|buf
argument_list|)
decl_stmt|;
comment|// print nothing if message pattern didn't apply / was empty.
comment|// (still print empty lines, e.g. because message itself was empty)
if|if
condition|(
name|logMessage
operator|.
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|qt_logging_to_console
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|logMessage
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
expr_stmt|;
name|OutputDebugString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|logMessage
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
elif|#
directive|elif
name|defined
argument_list|(
name|QT_USE_SLOG2
argument_list|)
name|logMessage
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
expr_stmt|;
name|slog2_default_handler
argument_list|(
name|type
argument_list|,
name|logMessage
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return;
elif|#
directive|elif
name|defined
argument_list|(
name|QT_USE_JOURNALD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
name|systemd_default_message_handler
argument_list|(
name|type
argument_list|,
name|context
argument_list|,
name|logMessage
argument_list|)
expr_stmt|;
return|return;
elif|#
directive|elif
name|defined
argument_list|(
name|QT_USE_SYSLOG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
name|syslog_default_message_handler
argument_list|(
name|type
argument_list|,
name|logMessage
operator|.
name|toUtf8
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
name|android_default_message_handler
argument_list|(
name|type
argument_list|,
name|context
argument_list|,
name|logMessage
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|logMessage
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qDefaultMsgHandler
specifier|static
name|void
name|qDefaultMsgHandler
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|QMessageLogContext
name|emptyContext
decl_stmt|;
name|qDefaultMessageHandler
argument_list|(
name|type
argument_list|,
name|emptyContext
argument_list|,
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_COMPILER_THREAD_LOCAL
argument_list|)
end_if
begin_decl_stmt
DECL|variable|msgHandlerGrabbed
specifier|static
specifier|thread_local
name|bool
name|msgHandlerGrabbed
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|grabMessageHandler
specifier|static
name|bool
name|grabMessageHandler
parameter_list|()
block|{
if|if
condition|(
name|msgHandlerGrabbed
condition|)
return|return
literal|false
return|;
name|msgHandlerGrabbed
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|ungrabMessageHandler
specifier|static
name|void
name|ungrabMessageHandler
parameter_list|()
block|{
name|msgHandlerGrabbed
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|grabMessageHandler
specifier|static
name|bool
name|grabMessageHandler
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|ungrabMessageHandler
specifier|static
name|void
name|ungrabMessageHandler
parameter_list|()
block|{ }
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// (Q_COMPILER_THREAD_LOCAL)
end_comment
begin_function
DECL|function|qt_message_print
specifier|static
name|void
name|qt_message_print
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
comment|// qDebug, qWarning, ... macros do not check whether category is enabled
if|if
condition|(
operator|!
name|context
operator|.
name|category
operator|||
operator|(
name|strcmp
argument_list|(
name|context
operator|.
name|category
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|QLoggingCategory
modifier|*
name|defaultCategory
init|=
name|QLoggingCategory
operator|::
name|defaultCategory
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|defaultCategory
operator|->
name|isEnabled
argument_list|(
name|msgType
argument_list|)
condition|)
return|return;
block|}
block|}
endif|#
directive|endif
comment|// prevent recursion in case the message handler generates messages
comment|// itself, e.g. by using Qt API
if|if
condition|(
name|grabMessageHandler
argument_list|()
condition|)
block|{
comment|// prefer new message handler over the old one
if|if
condition|(
name|msgHandler
operator|.
name|load
argument_list|()
operator|==
name|qDefaultMsgHandler
operator|||
name|messageHandler
operator|.
name|load
argument_list|()
operator|!=
name|qDefaultMessageHandler
condition|)
block|{
operator|(
operator|*
name|messageHandler
operator|.
name|load
argument_list|()
operator|)
operator|(
name|msgType
operator|,
name|context
operator|,
name|message
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|msgHandler
operator|.
name|load
argument_list|()
operator|)
operator|(
name|msgType
operator|,
name|message
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
operator|)
expr_stmt|;
block|}
name|ungrabMessageHandler
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|message
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|qt_message_fatal
specifier|static
name|void
name|qt_message_fatal
parameter_list|(
name|QtMsgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|_CRT_ERROR
argument_list|)
name|wchar_t
name|contextFileL
index|[
literal|256
index|]
decl_stmt|;
comment|// we probably should let the compiler do this for us, by declaring QMessageLogContext::file to
comment|// be const wchar_t * in the first place, but the #ifdefery above is very complex  and we
comment|// wouldn't be able to change it later on...
name|convert_to_wchar_t_elided
argument_list|(
name|contextFileL
argument_list|,
sizeof|sizeof
name|contextFileL
operator|/
sizeof|sizeof
expr|*
name|contextFileL
argument_list|,
name|context
operator|.
name|file
argument_list|)
expr_stmt|;
comment|// get the current report mode
name|int
name|reportMode
init|=
name|_CrtSetReportMode
argument_list|(
name|_CRT_ERROR
argument_list|,
name|_CRTDBG_MODE_WNDW
argument_list|)
decl_stmt|;
name|_CrtSetReportMode
argument_list|(
name|_CRT_ERROR
argument_list|,
name|reportMode
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|_CrtDbgReportW
argument_list|(
name|_CRT_ERROR
argument_list|,
name|contextFileL
argument_list|,
name|context
operator|.
name|line
argument_list|,
name|_CRT_WIDE
argument_list|(
name|QT_VERSION_STR
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|message
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
name|reportMode
operator|&
name|_CRTDBG_MODE_WNDW
operator|)
condition|)
return|return;
comment|// ignore
elseif|else
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
name|_CrtDbgBreak
argument_list|()
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|message
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
operator|)
name|abort
argument_list|()
expr_stmt|;
comment|// trap; generates core dump
else|#
directive|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// goodbye cruel world
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qt_message_output
name|void
name|qt_message_output
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
block|{
name|qt_message_print
argument_list|(
name|msgType
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|msgType
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|msgType
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qErrnoWarning
name|void
name|qErrnoWarning
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
comment|// qt_error_string() will allocate anyway, so we don't have
comment|// to be careful here (like we do in plain qWarning())
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|QString
name|buf
init|=
name|QString
operator|::
name|vasprintf
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1String
argument_list|(
literal|" ("
argument_list|)
operator|+
name|qt_error_string
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|QMessageLogContext
name|context
decl_stmt|;
name|qt_message_output
argument_list|(
name|QtCriticalMsg
argument_list|,
name|context
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qErrnoWarning
name|void
name|qErrnoWarning
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
comment|// qt_error_string() will allocate anyway, so we don't have
comment|// to be careful here (like we do in plain qWarning())
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|QString
name|buf
init|=
name|QString
operator|::
name|vasprintf
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1String
argument_list|(
literal|" ("
argument_list|)
operator|+
name|qt_error_string
argument_list|(
name|code
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|QMessageLogContext
name|context
decl_stmt|;
name|qt_message_output
argument_list|(
name|QtCriticalMsg
argument_list|,
name|context
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \typedef QtMsgHandler     \relates<QtGlobal>     \deprecated      This is a typedef for a pointer to a function with the following     signature:      \snippet code/src_corelib_global_qglobal.cpp 7      This typedef is deprecated, you should use QtMessageHandler instead.     \sa QtMsgType, QtMessageHandler, qInstallMsgHandler(), qInstallMessageHandler() */
end_comment
begin_comment
comment|/*!     \typedef QtMessageHandler     \relates<QtGlobal>     \since 5.0      This is a typedef for a pointer to a function with the following     signature:      \snippet code/src_corelib_global_qglobal.cpp 49      \sa QtMsgType, qInstallMessageHandler() */
end_comment
begin_comment
comment|/*!     \fn QtMessageHandler qInstallMessageHandler(QtMessageHandler handler)     \relates<QtGlobal>     \since 5.0      Installs a Qt message \a handler which has been defined     previously. Returns a pointer to the previous message handler.      The message handler is a function that prints out debug messages,     warnings, critical and fatal error messages. The Qt library (debug     mode) contains hundreds of warning messages that are printed     when internal errors (usually invalid function arguments)     occur. Qt built in release mode also contains such warnings unless     QT_NO_WARNING_OUTPUT and/or QT_NO_DEBUG_OUTPUT have been set during     compilation. If you implement your own message handler, you get total     control of these messages.      The default message handler prints the message to the standard     output under X11 or to the debugger under Windows. If it is a     fatal message, the application aborts immediately.      Only one message handler can be defined, since this is usually     done on an application-wide basis to control debug output.      To restore the message handler, call \c qInstallMessageHandler(0).      Example:      \snippet code/src_corelib_global_qglobal.cpp 23      \sa QtMessageHandler, QtMsgType, qDebug(), qWarning(), qCritical(), qFatal(),     {Debugging Techniques} */
end_comment
begin_comment
comment|/*!     \fn QtMsgHandler qInstallMsgHandler(QtMsgHandler handler)     \relates<QtGlobal>     \deprecated      Installs a Qt message \a handler which has been defined     previously. This method is deprecated, use qInstallMessageHandler     instead.     \sa QtMsgHandler, qInstallMessageHandler() */
end_comment
begin_comment
comment|/*!     \fn void qSetMessagePattern(const QString&pattern)     \relates<QtGlobal>     \since 5.0      \brief Changes the output of the default message handler.      Allows to tweak the output of qDebug(), qInfo(), qWarning(), qCritical(),     and qFatal(). The category logging output of qCDebug(), qCInfo(),     qCWarning(), and qCCritical() is formatted, too.      Following placeholders are supported:      \table     \header \li Placeholder \li Description     \row \li \c %{appname} \li QCoreApplication::applicationName()     \row \li \c %{category} \li Logging category     \row \li \c %{file} \li Path to source file     \row \li \c %{function} \li Function     \row \li \c %{line} \li Line in source file     \row \li \c %{message} \li The actual message     \row \li \c %{pid} \li QCoreApplication::applicationPid()     \row \li \c %{threadid} \li The system-wide ID of current thread (if it can be obtained)     \row \li \c %{qthreadptr} \li A pointer to the current QThread (result of QThread::currentThread())     \row \li \c %{type} \li "debug", "warning", "critical" or "fatal"     \row \li \c %{time process} \li time of the message, in seconds since the process started (the token "process" is literal)     \row \li \c %{time boot} \li the time of the message, in seconds since the system boot if that         can be determined (the token "boot" is literal). If the time since boot could not be obtained,         the output is indeterminate (see QElapsedTimer::msecsSinceReference()).     \row \li \c %{time [format]} \li system time when the message occurred, formatted by         passing the \c format to \l QDateTime::toString(). If the format is         not specified, the format of Qt::ISODate is used.     \row \li \c{%{backtrace [depth=N] [separator="..."]}} \li A backtrace with the number of frames         specified by the optional \c depth parameter (defaults to 5), and separated by the optional         \c separator parameter (defaults to "|").         This expansion is available only on some platforms (currently only platfoms using glibc).         Names are only known for exported functions. If you want to see the name of every function         in your application, use \c{QMAKE_LFLAGS += -rdynamic}.         When reading backtraces, take into account that frames might be missing due to inlining or         tail call optimization.     \endtable      You can also use conditionals on the type of the message using \c %{if-debug}, \c %{if-info}     \c %{if-warning}, \c %{if-critical} or \c %{if-fatal} followed by an \c %{endif}.     What is inside the \c %{if-*} and \c %{endif} will only be printed if the type matches.      Finally, text inside \c %{if-category} ... \c %{endif} is only printed if the category     is not the default one.      Example:     \code     QT_MESSAGE_PATTERN="[%{time yyyyMMdd h:mm:ss.zzz t} %{if-debug}D%{endif}%{if-info}I%{endif}%{if-warning}W%{endif}%{if-critical}C%{endif}%{if-fatal}F%{endif}] %{file}:%{line} - %{message}"     \endcode      The default \a pattern is "%{if-category}%{category}: %{endif}%{message}".      The \a pattern can also be changed at runtime by setting the QT_MESSAGE_PATTERN     environment variable; if both \l qSetMessagePattern() is called and QT_MESSAGE_PATTERN is     set, the environment variable takes precedence.      Custom message handlers can use qFormatLogMessage() to take \a pattern into account.      \sa qInstallMessageHandler(), {Debugging Techniques}, {QLoggingCategory}  */
end_comment
begin_function
DECL|function|qInstallMessageHandler
name|QtMessageHandler
name|qInstallMessageHandler
parameter_list|(
name|QtMessageHandler
name|h
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
condition|)
name|h
operator|=
name|qDefaultMessageHandler
expr_stmt|;
comment|//set 'h' and return old message handler
return|return
name|messageHandler
operator|.
name|fetchAndStoreRelaxed
argument_list|(
name|h
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qInstallMsgHandler
name|QtMsgHandler
name|qInstallMsgHandler
parameter_list|(
name|QtMsgHandler
name|h
parameter_list|)
block|{
if|if
condition|(
operator|!
name|h
condition|)
name|h
operator|=
name|qDefaultMsgHandler
expr_stmt|;
comment|//set 'h' and return old message handler
return|return
name|msgHandler
operator|.
name|fetchAndStoreRelaxed
argument_list|(
name|h
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|qSetMessagePattern
name|void
name|qSetMessagePattern
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|)
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|QMessagePattern
operator|::
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qMessagePattern
argument_list|()
operator|->
name|fromEnvironment
condition|)
name|qMessagePattern
argument_list|()
operator|->
name|setPattern
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Copies context information from \a logContext into this QMessageLogContext     \internal */
end_comment
begin_function
DECL|function|copy
name|void
name|QMessageLogContext
operator|::
name|copy
parameter_list|(
specifier|const
name|QMessageLogContext
modifier|&
name|logContext
parameter_list|)
block|{
name|this
operator|->
name|category
operator|=
name|logContext
operator|.
name|category
expr_stmt|;
name|this
operator|->
name|file
operator|=
name|logContext
operator|.
name|file
expr_stmt|;
name|this
operator|->
name|line
operator|=
name|logContext
operator|.
name|line
expr_stmt|;
name|this
operator|->
name|function
operator|=
name|logContext
operator|.
name|function
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QMessageLogger::QMessageLogger()      Constructs a default QMessageLogger. See the other constructors to specify     context information. */
end_comment
begin_comment
comment|/*!     \fn QMessageLogger::QMessageLogger(const char *file, int line, const char *function)      Constructs a QMessageLogger to record log messages for \a file at \a line     in \a function. The is equivalent to QMessageLogger(file, line, function, "default") */
end_comment
begin_comment
comment|/*!     \fn QMessageLogger::QMessageLogger(const char *file, int line, const char *function, const char *category)      Constructs a QMessageLogger to record \a category messages for \a file at \a line     in \a function. */
end_comment
begin_comment
comment|/*!     \fn void QMessageLogger::noDebug(const char *, ...) const     \internal      Ignores logging output      \sa QNoDebug, qDebug() */
end_comment
begin_comment
comment|/*!     \fn QMessageLogContext::QMessageLogContext()     \internal      Constructs a QMessageLogContext */
end_comment
begin_comment
comment|/*!     \fn QMessageLogContext::QMessageLogContext(const char *fileName, int lineNumber, const char *functionName, const char *categoryName)     \internal      Constructs a QMessageLogContext with for file \a fileName at line     \a lineNumber, in function \a functionName, and category \a categoryName. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
