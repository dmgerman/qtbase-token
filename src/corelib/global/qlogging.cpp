begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qlogging.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qbytearray.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QMessageLogContext     \relates<QtGlobal>     \brief The QMessageLogContext class provides additional information about a log message.     \since 5.0      The class provides information about the source code location a qDebug(), qWarning(),     qCritical() or qFatal() message was generated.      \sa QMessageLogger, QMessageHandler, qInstallMessageHandler() */
comment|/*!     \class QMessageLogger     \relates<QtGlobal>     \brief The QMessageLogger class generates log messages.     \since 5.0      QMessageLogger is used to generate messages for the Qt logging framework. Most of the time     is transparently used through the qDebug(), qWarning(), qCritical, or qFatal() functions,     which are actually macros that expand to QMessageLogger(__FILE__, __LINE__, Q_FUNC_INFO).debug()     et al.      One example of direct use is to forward errors that stem from a scripting language, e.g. QML:      \snippet doc/src/snippets/code/qlogging/qlogging.cpp 1      \sa QMessageLogContext, qDebug(), qWarning(), qCritical(), qFatal() */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_EXCEPTIONS
argument_list|)
comment|/*!     \internal     Uses a local buffer to output the message. Not locale safe + cuts off     everything after character 255, but will work in out of memory situations. */
DECL|function|qEmergencyOut
specifier|static
name|void
name|qEmergencyOut
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|char
name|emergency_buf
index|[
literal|256
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
name|emergency_buf
index|[
literal|255
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|qvsnprintf
argument_list|(
name|emergency_buf
argument_list|,
literal|255
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|QMessageLogContext
name|context
decl_stmt|;
name|qt_message_output
argument_list|(
name|msgType
argument_list|,
name|context
argument_list|,
name|emergency_buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qt_message
specifier|static
name|void
name|qt_message
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_EXCEPTIONS
argument_list|)
if|if
condition|(
name|std
operator|::
name|uncaught_exception
argument_list|()
condition|)
block|{
name|qEmergencyOut
argument_list|(
name|msgType
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|QByteArray
name|buf
decl_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|QT_TRY
block|{
name|buf
operator|=
name|QString
argument_list|()
operator|.
name|vsprintf
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::bad_alloc&
argument_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_EXCEPTIONS
argument_list|)
name|qEmergencyOut
argument_list|(
name|msgType
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|// don't rethrow - we use qWarning and friends in destructors.
return|return;
endif|#
directive|endif
block|}
block|}
name|qt_message_output
argument_list|(
name|msgType
argument_list|,
name|context
argument_list|,
name|buf
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|qDebug
undef|#
directive|undef
name|qDebug
end_undef
begin_comment
comment|/*!     \fn qDebug(const char *message, ...)     \relates<QtGlobal>      Calls the message handler with the debug message \a msg. If no     message handler has been installed, the message is printed to     stderr. Under Windows, the message is sent to the console, if it is a     console application; otherwise, it is sent to the debugger. This     function does nothing if \c QT_NO_DEBUG_OUTPUT was defined     during compilation.      If you pass the function a format string and a list of arguments,     it works in similar way to the C printf() function. The format     should be a Latin-1 string.      Example:      \snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 24      If you include \c<QtDebug>, a more convenient syntax is also     available:      \snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 25      With this syntax, the function returns a QDebug object that is     configured to use the QtDebugMsg message type. It automatically     puts a single space between each item, and outputs a newline at     the end. It supports many C++ and Qt types.      To suppress the output at run-time, install your own message handler     with qInstallMessageHandler().      \sa qWarning(), qCritical(), qFatal(), qInstallMessageHandler(),         {Debugging Techniques} */
end_comment
begin_function
DECL|function|debug
name|void
name|QMessageLogger
operator|::
name|debug
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
name|qt_message
argument_list|(
name|QtDebugMsg
argument_list|,
name|context
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|debug
name|QDebug
name|QMessageLogger
operator|::
name|debug
parameter_list|()
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtDebugMsg
argument_list|)
decl_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|file
operator|=
name|context
operator|.
name|file
expr_stmt|;
name|ctxt
operator|.
name|line
operator|=
name|context
operator|.
name|line
expr_stmt|;
name|ctxt
operator|.
name|function
operator|=
name|context
operator|.
name|function
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_function
DECL|function|noDebug
name|QNoDebug
name|QMessageLogger
operator|::
name|noDebug
parameter_list|()
block|{
return|return
name|QNoDebug
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|qWarning
undef|#
directive|undef
name|qWarning
end_undef
begin_comment
comment|/*!     \fn qWarning(const char *message, ...)     \relates<QtGlobal>      Calls the message handler with the warning message \a msg. If no     message handler has been installed, the message is printed to     stderr. Under Windows, the message is sent to the debugger. This     function does nothing if \c QT_NO_WARNING_OUTPUT was defined     during compilation; it exits if the environment variable \c     QT_FATAL_WARNINGS is defined.      This function takes a format string and a list of arguments,     similar to the C printf() function. The format should be a Latin-1     string.      Example:     \snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 26      If you include<QtDebug>, a more convenient syntax is     also available:      \snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 27      This syntax inserts a space between each item, and     appends a newline at the end.      To suppress the output at runtime, install your own message handler     with qInstallMessageHandler().      \sa qDebug(), qCritical(), qFatal(), qInstallMessageHandler(),         {Debugging Techniques} */
end_comment
begin_function
DECL|function|warning
name|void
name|QMessageLogger
operator|::
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
name|qt_message
argument_list|(
name|QtWarningMsg
argument_list|,
name|context
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|warning
name|QDebug
name|QMessageLogger
operator|::
name|warning
parameter_list|()
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtWarningMsg
argument_list|)
decl_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|file
operator|=
name|context
operator|.
name|file
expr_stmt|;
name|ctxt
operator|.
name|line
operator|=
name|context
operator|.
name|line
expr_stmt|;
name|ctxt
operator|.
name|function
operator|=
name|context
operator|.
name|function
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|qCritical
undef|#
directive|undef
name|qCritical
end_undef
begin_comment
comment|/*!     \fn qCritical(const char *message, ...)     \relates<QtGlobal>      Calls the message handler with the critical message \a msg. If no     message handler has been installed, the message is printed to     stderr. Under Windows, the message is sent to the debugger.      This function takes a format string and a list of arguments,     similar to the C printf() function. The format should be a Latin-1     string.      Example:     \snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 28      If you include<QtDebug>, a more convenient syntax is     also available:      \snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 29      A space is inserted between the items, and a newline is     appended at the end.      To suppress the output at runtime, install your own message handler     with qInstallMessageHandler().      \sa qDebug(), qWarning(), qFatal(), qInstallMessageHandler(),         {Debugging Techniques} */
end_comment
begin_function
DECL|function|critical
name|void
name|QMessageLogger
operator|::
name|critical
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
name|qt_message
argument_list|(
name|QtCriticalMsg
argument_list|,
name|context
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|critical
name|QDebug
name|QMessageLogger
operator|::
name|critical
parameter_list|()
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtCriticalMsg
argument_list|)
decl_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|file
operator|=
name|context
operator|.
name|file
expr_stmt|;
name|ctxt
operator|.
name|line
operator|=
name|context
operator|.
name|line
expr_stmt|;
name|ctxt
operator|.
name|function
operator|=
name|context
operator|.
name|function
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|qFatal
undef|#
directive|undef
name|qFatal
end_undef
begin_comment
comment|/*!     \fn qFatal(const char *message, ...)     \relates<QtGlobal>      Calls the message handler with the fatal message \a msg. If no     message handler has been installed, the message is printed to     stderr. Under Windows, the message is sent to the debugger.      If you are using the \bold{default message handler} this function will     abort on Unix systems to create a core dump. On Windows, for debug builds,     this function will report a _CRT_ERROR enabling you to connect a debugger     to the application.      This function takes a format string and a list of arguments,     similar to the C printf() function.      Example:     \snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 30      To suppress the output at runtime, install your own message handler     with qInstallMessageHandler().      \sa qDebug(), qCritical(), qWarning(), qInstallMessageHandler(),         {Debugging Techniques} */
end_comment
begin_function
DECL|function|fatal
name|void
name|QMessageLogger
operator|::
name|fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
name|qt_message
argument_list|(
name|QtFatalMsg
argument_list|,
name|context
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qCleanupFuncinfo
name|Q_AUTOTEST_EXPORT
name|QByteArray
name|qCleanupFuncinfo
parameter_list|(
name|QByteArray
name|info
parameter_list|)
block|{
comment|// Strip the function info down to the base function name
comment|// note that this throws away the template definitions,
comment|// the parameter types (overloads) and any const/volatile qualifiers.
if|if
condition|(
name|info
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|info
return|;
name|int
name|pos
decl_stmt|;
comment|// skip trailing [with XXX] for templates (gcc)
name|pos
operator|=
name|info
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|endsWith
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
while|while
condition|(
operator|--
name|pos
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|'['
condition|)
name|info
operator|.
name|truncate
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|// operator names with '(', ')', '<', '>' in it
specifier|static
specifier|const
name|char
name|operator_call
index|[]
init|=
literal|"operator()"
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_lessThan
index|[]
init|=
literal|"operator<"
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_greaterThan
index|[]
init|=
literal|"operator>"
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_lessThanEqual
index|[]
init|=
literal|"operator<="
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_greaterThanEqual
index|[]
init|=
literal|"operator>="
decl_stmt|;
comment|// canonize operator names
name|info
operator|.
name|replace
argument_list|(
literal|"operator "
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
comment|// remove argument list
forever|forever
block|{
name|int
name|parencount
init|=
literal|0
decl_stmt|;
name|pos
operator|=
name|info
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Don't know how to parse this function name
return|return
name|info
return|;
block|}
comment|// find the beginning of the argument list
operator|--
name|pos
expr_stmt|;
operator|++
name|parencount
expr_stmt|;
while|while
condition|(
name|pos
operator|&&
name|parencount
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|')'
condition|)
operator|++
name|parencount
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|'('
condition|)
operator|--
name|parencount
expr_stmt|;
operator|--
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|parencount
operator|!=
literal|0
condition|)
return|return
name|info
return|;
name|info
operator|.
name|truncate
argument_list|(
operator|++
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_call
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_call
argument_list|)
condition|)
break|break;
comment|// this function returns a pointer to a function
comment|// and we matched the arguments of the return type's parameter list
comment|// try again
name|info
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|info
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|// find the beginning of the function name
name|int
name|parencount
init|=
literal|0
decl_stmt|;
name|int
name|templatecount
init|=
literal|0
decl_stmt|;
operator|--
name|pos
expr_stmt|;
comment|// make sure special characters in operator names are kept
if|if
condition|(
name|pos
operator|>
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
condition|)
block|{
case|case
literal|')'
case|:
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_call
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_call
argument_list|)
operator|+
literal|1
condition|)
name|pos
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_lessThan
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_lessThan
argument_list|)
operator|+
literal|1
condition|)
operator|--
name|pos
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_greaterThan
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_greaterThan
argument_list|)
operator|+
literal|1
condition|)
operator|--
name|pos
expr_stmt|;
break|break;
case|case
literal|'='
case|:
block|{
name|int
name|operatorLength
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_lessThanEqual
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_lessThanEqual
argument_list|)
operator|==
name|pos
operator|-
name|operatorLength
operator|+
literal|1
condition|)
name|pos
operator|-=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_greaterThanEqual
argument_list|)
operator|==
name|pos
operator|-
name|operatorLength
operator|+
literal|1
condition|)
name|pos
operator|-=
literal|2
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
while|while
condition|(
name|pos
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|parencount
operator|<
literal|0
operator|||
name|templatecount
operator|<
literal|0
condition|)
return|return
name|info
return|;
name|char
name|c
init|=
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
operator|++
name|parencount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
operator|--
name|parencount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
operator|++
name|templatecount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
operator|--
name|templatecount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|templatecount
operator|==
literal|0
operator|&&
name|parencount
operator|==
literal|0
condition|)
break|break;
operator|--
name|pos
expr_stmt|;
block|}
name|info
operator|=
name|info
operator|.
name|mid
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// remove trailing '*', '&' that are part of the return argument
while|while
condition|(
operator|(
name|info
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'*'
operator|)
operator|||
operator|(
name|info
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'&'
operator|)
condition|)
name|info
operator|=
name|info
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// we have the full function name now.
comment|// clean up the templates
while|while
condition|(
operator|(
name|pos
operator|=
name|info
operator|.
name|lastIndexOf
argument_list|(
literal|'>'
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|.
name|contains
argument_list|(
literal|'<'
argument_list|)
condition|)
break|break;
comment|// find the matching close
name|int
name|end
init|=
name|pos
decl_stmt|;
name|templatecount
operator|=
literal|1
expr_stmt|;
operator|--
name|pos
expr_stmt|;
while|while
condition|(
name|pos
operator|&&
name|templatecount
condition|)
block|{
specifier|register
name|char
name|c
init|=
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
operator|++
name|templatecount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
operator|--
name|templatecount
expr_stmt|;
operator|--
name|pos
expr_stmt|;
block|}
operator|++
name|pos
expr_stmt|;
name|info
operator|.
name|remove
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
end_function
begin_comment
comment|// tokens as recognized in QT_MESSAGE_PATTERN
end_comment
begin_decl_stmt
DECL|variable|typeTokenC
specifier|static
specifier|const
name|char
name|typeTokenC
index|[]
init|=
literal|"%{type}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|messageTokenC
specifier|static
specifier|const
name|char
name|messageTokenC
index|[]
init|=
literal|"%{message}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fileTokenC
specifier|static
specifier|const
name|char
name|fileTokenC
index|[]
init|=
literal|"%{file}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|lineTokenC
specifier|static
specifier|const
name|char
name|lineTokenC
index|[]
init|=
literal|"%{line}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|functionTokenC
specifier|static
specifier|const
name|char
name|functionTokenC
index|[]
init|=
literal|"%{function}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pidTokenC
specifier|static
specifier|const
name|char
name|pidTokenC
index|[]
init|=
literal|"%{pid}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|appnameTokenC
specifier|static
specifier|const
name|char
name|appnameTokenC
index|[]
init|=
literal|"%{appname}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|threadidTokenC
specifier|static
specifier|const
name|char
name|threadidTokenC
index|[]
init|=
literal|"%{threadid}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|emptyTokenC
specifier|static
specifier|const
name|char
name|emptyTokenC
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|QMessagePattern
struct|struct
name|QMessagePattern
block|{
name|QMessagePattern
parameter_list|()
constructor_decl|;
name|~
name|QMessagePattern
parameter_list|()
destructor_decl|;
comment|// 0 terminated arrays of literal tokens / literal or placeholder tokens
DECL|member|literals
specifier|const
name|char
modifier|*
modifier|*
name|literals
decl_stmt|;
DECL|member|tokens
specifier|const
name|char
modifier|*
modifier|*
name|tokens
decl_stmt|;
block|}
struct|;
end_struct
begin_constructor
DECL|function|QMessagePattern
name|QMessagePattern
operator|::
name|QMessagePattern
parameter_list|()
block|{
name|QString
name|pattern
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"QT_MESSAGE_PATTERN"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pattern
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|pattern
operator|=
name|QLatin1String
argument_list|(
literal|"%{message}"
argument_list|)
expr_stmt|;
block|}
comment|// scanner
name|QList
argument_list|<
name|QString
argument_list|>
name|lexemes
decl_stmt|;
name|QString
name|lexeme
decl_stmt|;
name|bool
name|inPlaceholder
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pattern
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QChar
name|c
init|=
name|pattern
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
operator|)
operator|&&
operator|!
name|inPlaceholder
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|<
name|pattern
operator|.
name|size
argument_list|()
operator|)
operator|&&
name|pattern
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
comment|// beginning of placeholder
if|if
condition|(
operator|!
name|lexeme
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lexemes
operator|.
name|append
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
name|lexeme
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|inPlaceholder
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|lexeme
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
operator|&&
name|inPlaceholder
operator|)
condition|)
block|{
comment|// end of placeholder
name|lexemes
operator|.
name|append
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
name|lexeme
operator|.
name|clear
argument_list|()
expr_stmt|;
name|inPlaceholder
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|lexeme
operator|.
name|isEmpty
argument_list|()
condition|)
name|lexemes
operator|.
name|append
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
comment|// tokenizer
name|QVarLengthArray
argument_list|<
specifier|const
name|char
modifier|*
argument_list|>
name|literalsVar
decl_stmt|;
name|tokens
operator|=
operator|new
specifier|const
name|char
operator|*
index|[
name|lexemes
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
expr_stmt|;
name|tokens
index|[
name|lexemes
operator|.
name|size
argument_list|()
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lexemes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
name|lexeme
init|=
name|lexemes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|lexeme
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"%{"
argument_list|)
argument_list|)
operator|&&
name|lexeme
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
argument_list|)
condition|)
block|{
comment|// placeholder
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|typeTokenC
argument_list|)
condition|)
block|{
name|tokens
index|[
name|i
index|]
operator|=
name|typeTokenC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|messageTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|messageTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|fileTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|fileTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|lineTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|lineTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|functionTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|functionTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|pidTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|pidTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|appnameTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|appnameTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|threadidTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|threadidTokenC
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"QT_MESSAGE_PATTERN: Unknown placeholder %1\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|lexeme
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|tokens
index|[
name|i
index|]
operator|=
name|emptyTokenC
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|literal
init|=
operator|new
name|char
index|[
name|lexeme
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|strncpy
argument_list|(
name|literal
argument_list|,
name|lexeme
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|lexeme
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|literal
index|[
name|lexeme
operator|.
name|size
argument_list|()
index|]
operator|=
literal|'\0'
expr_stmt|;
name|literalsVar
operator|.
name|append
argument_list|(
name|literal
argument_list|)
expr_stmt|;
name|tokens
index|[
name|i
index|]
operator|=
name|literal
expr_stmt|;
block|}
block|}
name|literals
operator|=
operator|new
specifier|const
name|char
operator|*
index|[
name|literalsVar
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
expr_stmt|;
name|literals
index|[
name|literalsVar
operator|.
name|size
argument_list|()
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|literals
argument_list|,
name|literalsVar
operator|.
name|constData
argument_list|()
argument_list|,
name|literalsVar
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QMessagePattern
name|QMessagePattern
operator|::
name|~
name|QMessagePattern
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|literals
index|[
name|i
index|]
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
operator|delete
index|[]
name|literals
index|[
name|i
index|]
expr_stmt|;
operator|delete
index|[]
name|literals
expr_stmt|;
name|literals
operator|=
literal|0
expr_stmt|;
operator|delete
index|[]
name|tokens
expr_stmt|;
name|tokens
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QMessagePattern
argument_list|,
argument|qMessagePattern
argument_list|)
end_macro
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qMessageFormatString
name|Q_CORE_EXPORT
name|QByteArray
name|qMessageFormatString
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|QByteArray
name|message
decl_stmt|;
name|QMessagePattern
modifier|*
name|pattern
init|=
name|qMessagePattern
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
block|{
comment|// after destruction of static QMessagePattern instance
name|message
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|// we do not convert file, function, line literals to local encoding due to overhead
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|pattern
operator|->
name|tokens
index|[
name|i
index|]
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|token
init|=
name|pattern
operator|->
name|tokens
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|messageTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|typeTokenC
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QtDebugMsg
case|:
name|message
operator|.
name|append
argument_list|(
literal|"debug"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QtWarningMsg
case|:
name|message
operator|.
name|append
argument_list|(
literal|"warning"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QtCriticalMsg
case|:
name|message
operator|.
name|append
argument_list|(
literal|"critical"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QtFatalMsg
case|:
name|message
operator|.
name|append
argument_list|(
literal|"fatal"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|fileTokenC
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|file
condition|)
name|message
operator|.
name|append
argument_list|(
name|context
operator|.
name|file
argument_list|)
expr_stmt|;
else|else
name|message
operator|.
name|append
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|lineTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QByteArray
operator|::
name|number
argument_list|(
name|context
operator|.
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|functionTokenC
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|function
condition|)
name|message
operator|.
name|append
argument_list|(
name|qCleanupFuncinfo
argument_list|(
name|context
operator|.
name|function
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|message
operator|.
name|append
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|pidTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QByteArray
operator|::
name|number
argument_list|(
name|QCoreApplication
operator|::
name|applicationPid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|appnameTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QCoreApplication
operator|::
name|applicationName
argument_list|()
operator|.
name|toUtf8
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|threadidTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
literal|"0x"
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|qlonglong
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|->
name|currentThread
argument_list|()
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|message
operator|.
name|append
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
name|message
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|msgHandler
specifier|static
name|QtMsgHandler
name|msgHandler
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|msgHandler
comment|// pointer to debug handler (without context)
end_comment
begin_decl_stmt
DECL|variable|messageHandler
specifier|static
name|QMessageHandler
name|messageHandler
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|messageHandler
comment|// pointer to debug handler (with context)
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qDefaultMessageHandler
specifier|static
name|void
name|qDefaultMessageHandler
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|QByteArray
name|logMessage
init|=
name|qMessageFormatString
argument_list|(
name|type
argument_list|,
name|context
argument_list|,
name|buf
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|QString
name|fstr
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|logMessage
argument_list|)
decl_stmt|;
name|OutputDebugString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|fstr
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|logMessage
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qDefaultMsgHandler
specifier|static
name|void
name|qDefaultMsgHandler
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|QMessageLogContext
name|emptyContext
decl_stmt|;
name|qDefaultMessageHandler
argument_list|(
name|type
argument_list|,
name|emptyContext
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qt_message_output
name|void
name|qt_message_output
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|msgHandler
condition|)
name|msgHandler
operator|=
name|qDefaultMsgHandler
expr_stmt|;
if|if
condition|(
operator|!
name|messageHandler
condition|)
name|messageHandler
operator|=
name|qDefaultMessageHandler
expr_stmt|;
comment|// prefer new message handler over the old one
if|if
condition|(
name|msgHandler
operator|==
name|qDefaultMsgHandler
operator|||
name|messageHandler
operator|!=
name|qDefaultMessageHandler
condition|)
block|{
call|(
modifier|*
name|messageHandler
call|)
argument_list|(
name|msgType
argument_list|,
name|context
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|msgHandler
call|)
argument_list|(
name|msgType
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msgType
operator|==
name|QtFatalMsg
operator|||
operator|(
name|msgType
operator|==
name|QtWarningMsg
operator|&&
operator|(
operator|!
name|qgetenv
argument_list|(
literal|"QT_FATAL_WARNINGS"
argument_list|)
operator|.
name|isNull
argument_list|()
operator|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|_CRT_ERROR
argument_list|)
comment|// get the current report mode
name|int
name|reportMode
init|=
name|_CrtSetReportMode
argument_list|(
name|_CRT_ERROR
argument_list|,
name|_CRTDBG_MODE_WNDW
argument_list|)
decl_stmt|;
name|_CrtSetReportMode
argument_list|(
name|_CRT_ERROR
argument_list|,
name|reportMode
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|int
name|ret
init|=
name|_CrtDbgReport
argument_list|(
name|_CRT_ERROR
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|QT_VERSION_STR
argument_list|,
name|buf
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|ret
init|=
name|_CrtDbgReportW
argument_list|(
name|_CRT_ERROR
argument_list|,
name|_CRT_WIDE
argument_list|(
name|__FILE__
argument_list|)
argument_list|,
name|__LINE__
argument_list|,
name|_CRT_WIDE
argument_list|(
name|QT_VERSION_STR
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|buf
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|reportMode
operator|&
name|_CRTDBG_MODE_WNDW
condition|)
return|return;
comment|// ignore
elseif|else
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
name|_CrtDbgBreak
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
operator|)
name|abort
argument_list|()
expr_stmt|;
comment|// trap; generates core dump
else|#
directive|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// goodbye cruel world
endif|#
directive|endif
block|}
block|}
end_function
begin_function
DECL|function|qErrnoWarning
name|void
name|qErrnoWarning
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
comment|// qt_error_string() will allocate anyway, so we don't have
comment|// to be careful here (like we do in plain qWarning())
name|QString
name|buf
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|buf
operator|.
name|vsprintf
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|QMessageLogger
argument_list|()
operator|.
name|critical
argument_list|(
literal|"%s (%s)"
argument_list|,
name|buf
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|qt_error_string
argument_list|(
operator|-
literal|1
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qErrnoWarning
name|void
name|qErrnoWarning
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
comment|// qt_error_string() will allocate anyway, so we don't have
comment|// to be careful here (like we do in plain qWarning())
name|QString
name|buf
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|buf
operator|.
name|vsprintf
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|QMessageLogger
argument_list|()
operator|.
name|critical
argument_list|(
literal|"%s (%s)"
argument_list|,
name|buf
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|qt_error_string
argument_list|(
name|code
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
end_if
begin_decl_stmt
specifier|extern
name|bool
name|usingWinMain
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|extern
name|Q_CORE_EXPORT
name|void
name|qWinMsgHandler
parameter_list|(
name|QtMsgType
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|Q_CORE_EXPORT
name|void
name|qWinMessageHandler
parameter_list|(
name|QtMsgType
name|t
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \typedef QtMsgHandler     \relates<QtGlobal>     \deprecated      This is a typedef for a pointer to a function with the following     signature:      \snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 7      This typedef is deprecated, you should use QMessageHandler instead.     \sa QtMsgType, QMessageHandler, qInstallMsgHandler(), qInstallMessageHandler() */
end_comment
begin_comment
comment|/*!     \typedef QMessageHandler     \relates<QtGlobal>     \since 5.0      This is a typedef for a pointer to a function with the following     signature:      \snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 49      \sa QtMsgType, qInstallMessageHandler() */
end_comment
begin_comment
comment|/*!     \fn QMessageHandler qInstallMessageHandler(QMessageHandler handler)     \relates<QtGlobal>     \since 5.0      Installs a Qt message \a handler which has been defined     previously. Returns a pointer to the previous message handler     (which may be 0).      The message handler is a function that prints out debug messages,     warnings, critical and fatal error messages. The Qt library (debug     mode) contains hundreds of warning messages that are printed     when internal errors (usually invalid function arguments)     occur. Qt built in release mode also contains such warnings unless     QT_NO_WARNING_OUTPUT and/or QT_NO_DEBUG_OUTPUT have been set during     compilation. If you implement your own message handler, you get total     control of these messages.      The default message handler prints the message to the standard     output under X11 or to the debugger under Windows. If it is a     fatal message, the application aborts immediately.      Only one message handler can be defined, since this is usually     done on an application-wide basis to control debug output.      To restore the message handler, call \c qInstallMessageHandler(0).      Example:      \snippet doc/src/snippets/code/src_corelib_global_qglobal.cpp 23      \sa qDebug(), qWarning(), qCritical(), qFatal(), QtMsgType,     {Debugging Techniques} */
end_comment
begin_function
DECL|function|qInstallMessageHandler
name|QMessageHandler
name|qInstallMessageHandler
parameter_list|(
name|QMessageHandler
name|h
parameter_list|)
block|{
if|if
condition|(
operator|!
name|messageHandler
condition|)
name|messageHandler
operator|=
name|qDefaultMessageHandler
expr_stmt|;
name|QMessageHandler
name|old
init|=
name|messageHandler
decl_stmt|;
name|messageHandler
operator|=
name|h
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
if|if
condition|(
operator|!
name|messageHandler
operator|&&
name|usingWinMain
condition|)
name|messageHandler
operator|=
name|qWinMessageHandler
expr_stmt|;
endif|#
directive|endif
return|return
name|old
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QtMsgHandler qInstallMsgHandler(QtMsgHandler handler)     \relates<QtGlobal>     \deprecated      Installs a Qt message \a handler which has been defined     previously. This method is deprecated, use qInstallMessageHandler     instead.     \sa QtMsgHandler, qInstallMessageHandler */
end_comment
begin_function
DECL|function|qInstallMsgHandler
name|QtMsgHandler
name|qInstallMsgHandler
parameter_list|(
name|QtMsgHandler
name|h
parameter_list|)
block|{
comment|//if handler is 0, set it to the
comment|//default message handler
if|if
condition|(
operator|!
name|msgHandler
condition|)
name|msgHandler
operator|=
name|qDefaultMsgHandler
expr_stmt|;
name|QtMsgHandler
name|old
init|=
name|msgHandler
decl_stmt|;
name|msgHandler
operator|=
name|h
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
if|if
condition|(
operator|!
name|msgHandler
operator|&&
name|usingWinMain
condition|)
name|msgHandler
operator|=
name|qWinMsgHandler
expr_stmt|;
endif|#
directive|endif
return|return
name|old
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
