begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qlogging.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qbytearray.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QMessageLogContext     \relates<QtGlobal>     \brief The QMessageLogContext class provides additional information about a log message.     \since 5.0      The class provides information about the source code location a qDebug(), qWarning(),     qCritical() or qFatal() message was generated.      \sa QMessageLogger, QMessageHandler, qInstallMessageHandler() */
comment|/*!     \class QMessageLogger     \relates<QtGlobal>     \brief The QMessageLogger class generates log messages.     \since 5.0      QMessageLogger is used to generate messages for the Qt logging framework. Most of the time     is transparently used through the qDebug(), qWarning(), qCritical, or qFatal() functions,     which are actually macros that expand to QMessageLogger(__FILE__, __LINE__, Q_FUNC_INFO).debug()     et al.      One example of direct use is to forward errors that stem from a scripting language, e.g. QML:      \snippet doc/src/snippets/code/qlogging/qlogging.cpp 1      \sa QMessageLogContext, qDebug(), qWarning(), qCritical(), qFatal() */
comment|/*!     \internal */
DECL|function|qCleanupFuncinfo
name|Q_AUTOTEST_EXPORT
name|QByteArray
name|qCleanupFuncinfo
parameter_list|(
name|QByteArray
name|info
parameter_list|)
block|{
comment|// Strip the function info down to the base function name
comment|// note that this throws away the template definitions,
comment|// the parameter types (overloads) and any const/volatile qualifiers.
if|if
condition|(
name|info
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|info
return|;
name|int
name|pos
decl_stmt|;
comment|// skip trailing [with XXX] for templates (gcc)
name|pos
operator|=
name|info
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|endsWith
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
while|while
condition|(
operator|--
name|pos
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|'['
condition|)
name|info
operator|.
name|truncate
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|// operator names with '(', ')', '<', '>' in it
specifier|static
specifier|const
name|char
name|operator_call
index|[]
init|=
literal|"operator()"
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_lessThan
index|[]
init|=
literal|"operator<"
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_greaterThan
index|[]
init|=
literal|"operator>"
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_lessThanEqual
index|[]
init|=
literal|"operator<="
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_greaterThanEqual
index|[]
init|=
literal|"operator>="
decl_stmt|;
comment|// canonize operator names
name|info
operator|.
name|replace
argument_list|(
literal|"operator "
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
comment|// remove argument list
forever|forever
block|{
name|int
name|parencount
init|=
literal|0
decl_stmt|;
name|pos
operator|=
name|info
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Don't know how to parse this function name
return|return
name|info
return|;
block|}
comment|// find the beginning of the argument list
operator|--
name|pos
expr_stmt|;
operator|++
name|parencount
expr_stmt|;
while|while
condition|(
name|pos
operator|&&
name|parencount
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|')'
condition|)
operator|++
name|parencount
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|'('
condition|)
operator|--
name|parencount
expr_stmt|;
operator|--
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|parencount
operator|!=
literal|0
condition|)
return|return
name|info
return|;
name|info
operator|.
name|truncate
argument_list|(
operator|++
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_call
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_call
argument_list|)
condition|)
break|break;
comment|// this function returns a pointer to a function
comment|// and we matched the arguments of the return type's parameter list
comment|// try again
name|info
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|info
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|// find the beginning of the function name
name|int
name|parencount
init|=
literal|0
decl_stmt|;
name|int
name|templatecount
init|=
literal|0
decl_stmt|;
operator|--
name|pos
expr_stmt|;
comment|// make sure special characters in operator names are kept
if|if
condition|(
name|pos
operator|>
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
condition|)
block|{
case|case
literal|')'
case|:
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_call
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_call
argument_list|)
operator|+
literal|1
condition|)
name|pos
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_lessThan
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_lessThan
argument_list|)
operator|+
literal|1
condition|)
operator|--
name|pos
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_greaterThan
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_greaterThan
argument_list|)
operator|+
literal|1
condition|)
operator|--
name|pos
expr_stmt|;
break|break;
case|case
literal|'='
case|:
block|{
name|int
name|operatorLength
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_lessThanEqual
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_lessThanEqual
argument_list|)
operator|==
name|pos
operator|-
name|operatorLength
operator|+
literal|1
condition|)
name|pos
operator|-=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_greaterThanEqual
argument_list|)
operator|==
name|pos
operator|-
name|operatorLength
operator|+
literal|1
condition|)
name|pos
operator|-=
literal|2
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
while|while
condition|(
name|pos
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|parencount
operator|<
literal|0
operator|||
name|templatecount
operator|<
literal|0
condition|)
return|return
name|info
return|;
name|char
name|c
init|=
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
operator|++
name|parencount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
operator|--
name|parencount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
operator|++
name|templatecount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
operator|--
name|templatecount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|templatecount
operator|==
literal|0
operator|&&
name|parencount
operator|==
literal|0
condition|)
break|break;
operator|--
name|pos
expr_stmt|;
block|}
name|info
operator|=
name|info
operator|.
name|mid
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// remove trailing '*', '&' that are part of the return argument
while|while
condition|(
operator|(
name|info
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'*'
operator|)
operator|||
operator|(
name|info
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'&'
operator|)
condition|)
name|info
operator|=
name|info
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// we have the full function name now.
comment|// clean up the templates
while|while
condition|(
operator|(
name|pos
operator|=
name|info
operator|.
name|lastIndexOf
argument_list|(
literal|'>'
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|.
name|contains
argument_list|(
literal|'<'
argument_list|)
condition|)
break|break;
comment|// find the matching close
name|int
name|end
init|=
name|pos
decl_stmt|;
name|templatecount
operator|=
literal|1
expr_stmt|;
operator|--
name|pos
expr_stmt|;
while|while
condition|(
name|pos
operator|&&
name|templatecount
condition|)
block|{
specifier|register
name|char
name|c
init|=
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
operator|++
name|templatecount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
operator|--
name|templatecount
expr_stmt|;
operator|--
name|pos
expr_stmt|;
block|}
operator|++
name|pos
expr_stmt|;
name|info
operator|.
name|remove
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
end_function
begin_comment
comment|// tokens as recognized in QT_MESSAGE_PATTERN
end_comment
begin_decl_stmt
DECL|variable|typeTokenC
specifier|static
specifier|const
name|char
name|typeTokenC
index|[]
init|=
literal|"%{type}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|messageTokenC
specifier|static
specifier|const
name|char
name|messageTokenC
index|[]
init|=
literal|"%{message}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fileTokenC
specifier|static
specifier|const
name|char
name|fileTokenC
index|[]
init|=
literal|"%{file}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|lineTokenC
specifier|static
specifier|const
name|char
name|lineTokenC
index|[]
init|=
literal|"%{line}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|functionTokenC
specifier|static
specifier|const
name|char
name|functionTokenC
index|[]
init|=
literal|"%{function}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|emptyTokenC
specifier|static
specifier|const
name|char
name|emptyTokenC
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|QMessagePattern
struct|struct
name|QMessagePattern
block|{
name|QMessagePattern
parameter_list|()
constructor_decl|;
name|~
name|QMessagePattern
parameter_list|()
destructor_decl|;
comment|// 0 terminated arrays of literal tokens / literal or placeholder tokens
DECL|member|literals
specifier|const
name|char
modifier|*
modifier|*
name|literals
decl_stmt|;
DECL|member|tokens
specifier|const
name|char
modifier|*
modifier|*
name|tokens
decl_stmt|;
block|}
struct|;
end_struct
begin_constructor
DECL|function|QMessagePattern
name|QMessagePattern
operator|::
name|QMessagePattern
parameter_list|()
block|{
name|QString
name|pattern
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"QT_MESSAGE_PATTERN"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pattern
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|pattern
operator|=
name|QLatin1String
argument_list|(
literal|"%{message}"
argument_list|)
expr_stmt|;
block|}
comment|// scanner
name|QList
argument_list|<
name|QString
argument_list|>
name|lexemes
decl_stmt|;
name|QString
name|lexeme
decl_stmt|;
name|bool
name|inPlaceholder
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pattern
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QChar
name|c
init|=
name|pattern
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
operator|)
operator|&&
operator|!
name|inPlaceholder
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|<
name|pattern
operator|.
name|size
argument_list|()
operator|)
operator|&&
name|pattern
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
comment|// beginning of placeholder
if|if
condition|(
operator|!
name|lexeme
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lexemes
operator|.
name|append
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
name|lexeme
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|inPlaceholder
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|lexeme
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
operator|&&
name|inPlaceholder
operator|)
condition|)
block|{
comment|// end of placeholder
name|lexemes
operator|.
name|append
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
name|lexeme
operator|.
name|clear
argument_list|()
expr_stmt|;
name|inPlaceholder
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|lexeme
operator|.
name|isEmpty
argument_list|()
condition|)
name|lexemes
operator|.
name|append
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
comment|// tokenizer
name|QVarLengthArray
argument_list|<
specifier|const
name|char
modifier|*
argument_list|>
name|literalsVar
decl_stmt|;
name|tokens
operator|=
operator|new
specifier|const
name|char
operator|*
index|[
name|lexemes
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
expr_stmt|;
name|tokens
index|[
name|lexemes
operator|.
name|size
argument_list|()
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lexemes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
name|lexeme
init|=
name|lexemes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|lexeme
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"%{"
argument_list|)
argument_list|)
operator|&&
name|lexeme
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
argument_list|)
condition|)
block|{
comment|// placeholder
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|typeTokenC
argument_list|)
condition|)
block|{
name|tokens
index|[
name|i
index|]
operator|=
name|typeTokenC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|messageTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|messageTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|fileTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|fileTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|lineTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|lineTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|functionTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|functionTokenC
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"QT_MESSAGE_PATTERN: Unknown placeholder %1\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|lexeme
argument_list|)
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|tokens
index|[
name|i
index|]
operator|=
name|emptyTokenC
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|literal
init|=
operator|new
name|char
index|[
name|lexeme
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|strncpy
argument_list|(
name|literal
argument_list|,
name|lexeme
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|lexeme
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|literal
index|[
name|lexeme
operator|.
name|size
argument_list|()
index|]
operator|=
literal|'\0'
expr_stmt|;
name|literalsVar
operator|.
name|append
argument_list|(
name|literal
argument_list|)
expr_stmt|;
name|tokens
index|[
name|i
index|]
operator|=
name|literal
expr_stmt|;
block|}
block|}
name|literals
operator|=
operator|new
specifier|const
name|char
operator|*
index|[
name|literalsVar
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
expr_stmt|;
name|literals
index|[
name|literalsVar
operator|.
name|size
argument_list|()
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|literals
argument_list|,
name|literalsVar
operator|.
name|constData
argument_list|()
argument_list|,
name|literalsVar
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QMessagePattern
name|QMessagePattern
operator|::
name|~
name|QMessagePattern
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|literals
index|[
name|i
index|]
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
operator|delete
index|[]
name|literals
index|[
name|i
index|]
expr_stmt|;
operator|delete
index|[]
name|literals
expr_stmt|;
name|literals
operator|=
literal|0
expr_stmt|;
operator|delete
index|[]
name|tokens
expr_stmt|;
name|tokens
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QMessagePattern
argument_list|,
argument|qMessagePattern
argument_list|)
end_macro
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qMessageFormatString
name|Q_CORE_EXPORT
name|QByteArray
name|qMessageFormatString
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|QByteArray
name|message
decl_stmt|;
name|QMessagePattern
modifier|*
name|pattern
init|=
name|qMessagePattern
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
block|{
comment|// after destruction of static QMessagePattern instance
name|message
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|// we do not convert file, function, line literals to local encoding due to overhead
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|pattern
operator|->
name|tokens
index|[
name|i
index|]
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|token
init|=
name|pattern
operator|->
name|tokens
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|messageTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|typeTokenC
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QtDebugMsg
case|:
name|message
operator|.
name|append
argument_list|(
literal|"debug"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QtWarningMsg
case|:
name|message
operator|.
name|append
argument_list|(
literal|"warning"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QtCriticalMsg
case|:
name|message
operator|.
name|append
argument_list|(
literal|"critical"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QtFatalMsg
case|:
name|message
operator|.
name|append
argument_list|(
literal|"fatal"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|fileTokenC
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|file
condition|)
name|message
operator|.
name|append
argument_list|(
name|context
operator|.
name|file
argument_list|)
expr_stmt|;
else|else
name|message
operator|.
name|append
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|lineTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|context
operator|.
name|line
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|functionTokenC
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|function
condition|)
name|message
operator|.
name|append
argument_list|(
name|qCleanupFuncinfo
argument_list|(
name|context
operator|.
name|function
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|message
operator|.
name|append
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
operator|.
name|append
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
name|message
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
