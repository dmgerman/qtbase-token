begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qlogging.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qbytearray.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qmutex.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_include
include|#
directive|include
file|<qt_windows.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_USE_SLOG2
end_ifdef
begin_include
include|#
directive|include
file|<slog2.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
name|Q_NORETURN
endif|#
directive|endif
specifier|static
name|void
name|qt_message_fatal
parameter_list|(
name|QtMsgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|qt_message_print
parameter_list|(
name|QtMsgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|isFatal
specifier|static
name|bool
name|isFatal
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|)
block|{
if|if
condition|(
name|msgType
operator|==
name|QtFatalMsg
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|msgType
operator|==
name|QtWarningMsg
condition|)
block|{
specifier|static
name|bool
name|fatalWarnings
init|=
operator|!
name|qEnvironmentVariableIsEmpty
argument_list|(
literal|"QT_FATAL_WARNINGS"
argument_list|)
decl_stmt|;
return|return
name|fatalWarnings
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \class QMessageLogContext     \inmodule QtCore     \brief The QMessageLogContext class provides additional information about a log message.     \since 5.0      The class provides information about the source code location a qDebug(), qWarning(),     qCritical() or qFatal() message was generated.      \sa QMessageLogger, QtMessageHandler, qInstallMessageHandler() */
end_comment
begin_comment
comment|/*!     \class QMessageLogger     \inmodule QtCore     \brief The QMessageLogger class generates log messages.     \since 5.0      QMessageLogger is used to generate messages for the Qt logging framework. Usually one uses     it through qDebug(), qWarning(), qCritical, or qFatal() functions,     which are actually macros that expand to QMessageLogger(__FILE__, __LINE__, Q_FUNC_INFO).debug()     et al.      One example of direct use is to forward errors that stem from a scripting language, e.g. QML:      \snippet code/qlogging/qlogging.cpp 1      \sa QMessageLogContext, qDebug(), qWarning(), qCritical(), qFatal() */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
end_if
begin_comment
comment|// defined in qcoreapplication_win.cpp
end_comment
begin_decl_stmt
specifier|extern
name|bool
name|usingWinMain
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
specifier|static
specifier|inline
name|void
name|convert_to_wchar_t_elided
parameter_list|(
name|wchar_t
modifier|*
name|d
parameter_list|,
name|size_t
name|space
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
name|Q_DECL_NOEXCEPT
block|{
name|size_t
name|len
init|=
name|qstrlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|space
condition|)
block|{
specifier|const
name|size_t
name|skip
init|=
name|len
operator|-
name|space
operator|+
literal|4
decl_stmt|;
comment|// 4 for "..." + '\0'
name|s
operator|+=
name|skip
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
operator|*
name|d
operator|++
operator|=
literal|L'
expr|.'
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|s
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_EXCEPTIONS
argument_list|)
end_if
begin_comment
comment|/*!     \internal     Uses a local buffer to output the message. Not locale safe + cuts off     everything after character 255, but will work in out of memory situations.     Stop the execution afterwards. */
end_comment
begin_function
specifier|static
name|void
name|qEmergencyOut
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|va_list
name|ap
parameter_list|)
name|Q_DECL_NOEXCEPT
block|{
name|char
name|emergency_buf
index|[
literal|256
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
name|emergency_buf
index|[
sizeof|sizeof
name|emergency_buf
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|_CRT_ERROR
argument_list|)
name|wchar_t
name|emergency_bufL
index|[
sizeof|sizeof
name|emergency_buf
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|msg
condition|)
name|qvsnprintf
argument_list|(
name|emergency_buf
argument_list|,
sizeof|sizeof
name|emergency_buf
operator|-
literal|1
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
ifdef|#
directive|ifdef
name|Q_OS_WINCE
name|convert_to_wchar_t_elided
argument_list|(
name|emergency_bufL
argument_list|,
sizeof|sizeof
name|emergency_buf
argument_list|,
name|emergency_buf
argument_list|)
expr_stmt|;
name|OutputDebugStringW
argument_list|(
name|emergency_bufL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|usingWinMain
condition|)
block|{
name|OutputDebugStringA
argument_list|(
name|emergency_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|emergency_buf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|emergency_buf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|msgType
operator|==
name|QtFatalMsg
operator|||
operator|(
name|msgType
operator|==
name|QtWarningMsg
operator|&&
name|qEnvironmentVariableIsSet
argument_list|(
literal|"QT_FATAL_WARNINGS"
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|_CRT_ERROR
argument_list|)
comment|// get the current report mode
name|int
name|reportMode
init|=
name|_CrtSetReportMode
argument_list|(
name|_CRT_ERROR
argument_list|,
name|_CRTDBG_MODE_WNDW
argument_list|)
decl_stmt|;
name|_CrtSetReportMode
argument_list|(
name|_CRT_ERROR
argument_list|,
name|reportMode
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_WINCE
comment|// otherwise already converted to wchar_t above
name|convert_to_wchar_t_elided
argument_list|(
name|emergency_bufL
argument_list|,
sizeof|sizeof
name|emergency_buf
argument_list|,
name|emergency_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|ret
init|=
name|_CrtDbgReportW
argument_list|(
name|_CRT_ERROR
argument_list|,
name|_CRT_WIDE
argument_list|(
name|__FILE__
argument_list|)
argument_list|,
name|__LINE__
argument_list|,
name|_CRT_WIDE
argument_list|(
name|QT_VERSION_STR
argument_list|)
argument_list|,
name|emergency_bufL
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
name|_CrtDbgBreak
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
operator|)
name|abort
argument_list|()
expr_stmt|;
comment|// trap; generates core dump
else|#
directive|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// goodbye cruel world
endif|#
directive|endif
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qt_message
specifier|static
name|void
name|qt_message
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|va_list
name|ap
parameter_list|,
name|QString
modifier|&
name|buf
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_EXCEPTIONS
argument_list|)
if|if
condition|(
name|std
operator|::
name|uncaught_exception
argument_list|()
condition|)
block|{
name|qEmergencyOut
argument_list|(
name|msgType
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|msg
condition|)
block|{
name|QT_TRY
block|{
name|buf
operator|=
name|QString
argument_list|()
operator|.
name|vsprintf
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::bad_alloc&
argument_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_EXCEPTIONS
argument_list|)
name|qEmergencyOut
argument_list|(
name|msgType
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|// don't rethrow - we use qWarning and friends in destructors.
return|return;
endif|#
directive|endif
block|}
block|}
name|qt_message_print
argument_list|(
name|msgType
argument_list|,
name|context
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|qDebug
undef|#
directive|undef
name|qDebug
end_undef
begin_comment
comment|/*!     Logs a debug message specified with format \a msg. Additional     parameters, specified by \a msg, may be used.      \sa qDebug() */
end_comment
begin_function
DECL|function|debug
name|void
name|QMessageLogger
operator|::
name|debug
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
name|QString
name|message
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
name|qt_message
argument_list|(
name|QtDebugMsg
argument_list|,
name|context
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtDebugMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtDebugMsg
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_comment
comment|/*!     Logs a debug message using a QDebug stream      \sa qDebug(), QDebug */
end_comment
begin_function
DECL|function|debug
name|QDebug
name|QMessageLogger
operator|::
name|debug
parameter_list|()
specifier|const
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtDebugMsg
argument_list|)
decl_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Returns a QNoDebug object, which is used to ignore debugging output.      \sa QNoDebug, qDebug() */
end_comment
begin_function
name|QNoDebug
name|QMessageLogger
operator|::
name|noDebug
parameter_list|()
specifier|const
name|Q_DECL_NOTHROW
block|{
return|return
name|QNoDebug
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|qWarning
undef|#
directive|undef
name|qWarning
end_undef
begin_comment
comment|/*!     Logs a warning message specified with format \a msg. Additional     parameters, specified by \a msg, may be used.      \sa qWarning() */
end_comment
begin_function
DECL|function|warning
name|void
name|QMessageLogger
operator|::
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
name|QString
name|message
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
name|qt_message
argument_list|(
name|QtWarningMsg
argument_list|,
name|context
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtWarningMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtWarningMsg
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_comment
comment|/*!     Logs a debug message using a QDebug stream      \sa qWarning(), QDebug */
end_comment
begin_function
DECL|function|warning
name|QDebug
name|QMessageLogger
operator|::
name|warning
parameter_list|()
specifier|const
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtWarningMsg
argument_list|)
decl_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|qCritical
undef|#
directive|undef
name|qCritical
end_undef
begin_comment
comment|/*!     Logs a critical message specified with format \a msg. Additional     parameters, specified by \a msg, may be used.      \sa qCritical() */
end_comment
begin_function
DECL|function|critical
name|void
name|QMessageLogger
operator|::
name|critical
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
block|{
name|QString
name|message
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
name|qt_message
argument_list|(
name|QtCriticalMsg
argument_list|,
name|context
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|QtCriticalMsg
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|QtCriticalMsg
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_comment
comment|/*!     Logs a critical message using a QDebug stream      \sa qCritical(), QDebug */
end_comment
begin_function
DECL|function|critical
name|QDebug
name|QMessageLogger
operator|::
name|critical
parameter_list|()
specifier|const
block|{
name|QDebug
name|dbg
init|=
name|QDebug
argument_list|(
name|QtCriticalMsg
argument_list|)
decl_stmt|;
name|QMessageLogContext
modifier|&
name|ctxt
init|=
name|dbg
operator|.
name|stream
operator|->
name|context
decl_stmt|;
name|ctxt
operator|.
name|copy
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|dbg
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|qFatal
undef|#
directive|undef
name|qFatal
end_undef
begin_comment
comment|/*!     Logs a fatal message specified with format \a msg. Additional     parameters, specified by \a msg, may be used.      \sa qFatal() */
end_comment
begin_function
name|void
name|QMessageLogger
operator|::
name|fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
specifier|const
name|Q_DECL_NOTHROW
block|{
name|QString
name|message
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|// use variable arg list
name|QT_TERMINATE_ON_EXCEPTION
argument_list|(
name|qt_message
argument_list|(
name|QtFatalMsg
argument_list|,
name|context
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|qt_message_fatal
argument_list|(
name|QtFatalMsg
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qCleanupFuncinfo
name|Q_AUTOTEST_EXPORT
name|QByteArray
name|qCleanupFuncinfo
parameter_list|(
name|QByteArray
name|info
parameter_list|)
block|{
comment|// Strip the function info down to the base function name
comment|// note that this throws away the template definitions,
comment|// the parameter types (overloads) and any const/volatile qualifiers.
if|if
condition|(
name|info
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|info
return|;
name|int
name|pos
decl_stmt|;
comment|// skip trailing [with XXX] for templates (gcc)
name|pos
operator|=
name|info
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|endsWith
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
while|while
condition|(
operator|--
name|pos
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|'['
condition|)
name|info
operator|.
name|truncate
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|// operator names with '(', ')', '<', '>' in it
specifier|static
specifier|const
name|char
name|operator_call
index|[]
init|=
literal|"operator()"
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_lessThan
index|[]
init|=
literal|"operator<"
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_greaterThan
index|[]
init|=
literal|"operator>"
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_lessThanEqual
index|[]
init|=
literal|"operator<="
decl_stmt|;
specifier|static
specifier|const
name|char
name|operator_greaterThanEqual
index|[]
init|=
literal|"operator>="
decl_stmt|;
comment|// canonize operator names
name|info
operator|.
name|replace
argument_list|(
literal|"operator "
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
comment|// remove argument list
forever|forever
block|{
name|int
name|parencount
init|=
literal|0
decl_stmt|;
name|pos
operator|=
name|info
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Don't know how to parse this function name
return|return
name|info
return|;
block|}
comment|// find the beginning of the argument list
operator|--
name|pos
expr_stmt|;
operator|++
name|parencount
expr_stmt|;
while|while
condition|(
name|pos
operator|&&
name|parencount
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|')'
condition|)
operator|++
name|parencount
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|'('
condition|)
operator|--
name|parencount
expr_stmt|;
operator|--
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|parencount
operator|!=
literal|0
condition|)
return|return
name|info
return|;
name|info
operator|.
name|truncate
argument_list|(
operator|++
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_call
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_call
argument_list|)
condition|)
break|break;
comment|// this function returns a pointer to a function
comment|// and we matched the arguments of the return type's parameter list
comment|// try again
name|info
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|info
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|// find the beginning of the function name
name|int
name|parencount
init|=
literal|0
decl_stmt|;
name|int
name|templatecount
init|=
literal|0
decl_stmt|;
operator|--
name|pos
expr_stmt|;
comment|// make sure special characters in operator names are kept
if|if
condition|(
name|pos
operator|>
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
condition|)
block|{
case|case
literal|')'
case|:
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_call
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_call
argument_list|)
operator|+
literal|1
condition|)
name|pos
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_lessThan
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_lessThan
argument_list|)
operator|+
literal|1
condition|)
operator|--
name|pos
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_greaterThan
argument_list|)
operator|==
name|pos
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_greaterThan
argument_list|)
operator|+
literal|1
condition|)
operator|--
name|pos
expr_stmt|;
break|break;
case|case
literal|'='
case|:
block|{
name|int
name|operatorLength
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|operator_lessThanEqual
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_lessThanEqual
argument_list|)
operator|==
name|pos
operator|-
name|operatorLength
operator|+
literal|1
condition|)
name|pos
operator|-=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|.
name|indexOf
argument_list|(
name|operator_greaterThanEqual
argument_list|)
operator|==
name|pos
operator|-
name|operatorLength
operator|+
literal|1
condition|)
name|pos
operator|-=
literal|2
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
while|while
condition|(
name|pos
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|parencount
operator|<
literal|0
operator|||
name|templatecount
operator|<
literal|0
condition|)
return|return
name|info
return|;
name|char
name|c
init|=
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
operator|++
name|parencount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
operator|--
name|parencount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
operator|++
name|templatecount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
operator|--
name|templatecount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|templatecount
operator|==
literal|0
operator|&&
name|parencount
operator|==
literal|0
condition|)
break|break;
operator|--
name|pos
expr_stmt|;
block|}
name|info
operator|=
name|info
operator|.
name|mid
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// remove trailing '*', '&' that are part of the return argument
while|while
condition|(
operator|(
name|info
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'*'
operator|)
operator|||
operator|(
name|info
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|==
literal|'&'
operator|)
condition|)
name|info
operator|=
name|info
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// we have the full function name now.
comment|// clean up the templates
while|while
condition|(
operator|(
name|pos
operator|=
name|info
operator|.
name|lastIndexOf
argument_list|(
literal|'>'
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|.
name|contains
argument_list|(
literal|'<'
argument_list|)
condition|)
break|break;
comment|// find the matching close
name|int
name|end
init|=
name|pos
decl_stmt|;
name|templatecount
operator|=
literal|1
expr_stmt|;
operator|--
name|pos
expr_stmt|;
while|while
condition|(
name|pos
operator|&&
name|templatecount
condition|)
block|{
specifier|register
name|char
name|c
init|=
name|info
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
operator|++
name|templatecount
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
operator|--
name|templatecount
expr_stmt|;
operator|--
name|pos
expr_stmt|;
block|}
operator|++
name|pos
expr_stmt|;
name|info
operator|.
name|remove
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
end_function
begin_comment
comment|// tokens as recognized in QT_MESSAGE_PATTERN
end_comment
begin_decl_stmt
DECL|variable|categoryTokenC
specifier|static
specifier|const
name|char
name|categoryTokenC
index|[]
init|=
literal|"%{category}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|typeTokenC
specifier|static
specifier|const
name|char
name|typeTokenC
index|[]
init|=
literal|"%{type}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|messageTokenC
specifier|static
specifier|const
name|char
name|messageTokenC
index|[]
init|=
literal|"%{message}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fileTokenC
specifier|static
specifier|const
name|char
name|fileTokenC
index|[]
init|=
literal|"%{file}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|lineTokenC
specifier|static
specifier|const
name|char
name|lineTokenC
index|[]
init|=
literal|"%{line}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|functionTokenC
specifier|static
specifier|const
name|char
name|functionTokenC
index|[]
init|=
literal|"%{function}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pidTokenC
specifier|static
specifier|const
name|char
name|pidTokenC
index|[]
init|=
literal|"%{pid}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|appnameTokenC
specifier|static
specifier|const
name|char
name|appnameTokenC
index|[]
init|=
literal|"%{appname}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|threadidTokenC
specifier|static
specifier|const
name|char
name|threadidTokenC
index|[]
init|=
literal|"%{threadid}"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|emptyTokenC
specifier|static
specifier|const
name|char
name|emptyTokenC
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|defaultPattern
specifier|static
specifier|const
name|char
name|defaultPattern
index|[]
init|=
literal|"%{message}"
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|QMessagePattern
struct|struct
name|QMessagePattern
block|{
name|QMessagePattern
parameter_list|()
constructor_decl|;
name|~
name|QMessagePattern
parameter_list|()
destructor_decl|;
name|void
name|setPattern
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|)
function_decl|;
comment|// 0 terminated arrays of literal tokens / literal or placeholder tokens
DECL|member|literals
specifier|const
name|char
modifier|*
modifier|*
name|literals
decl_stmt|;
DECL|member|tokens
specifier|const
name|char
modifier|*
modifier|*
name|tokens
decl_stmt|;
DECL|member|fromEnvironment
name|bool
name|fromEnvironment
decl_stmt|;
DECL|member|mutex
specifier|static
name|QBasicMutex
name|mutex
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|member|mutex
name|QBasicMutex
name|QMessagePattern
operator|::
name|mutex
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QMessagePattern
name|QMessagePattern
operator|::
name|QMessagePattern
parameter_list|()
member_init_list|:
name|literals
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|tokens
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|fromEnvironment
argument_list|(
literal|false
argument_list|)
block|{
specifier|const
name|QString
name|envPattern
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"QT_MESSAGE_PATTERN"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|envPattern
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|setPattern
argument_list|(
name|QLatin1String
argument_list|(
name|defaultPattern
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setPattern
argument_list|(
name|envPattern
argument_list|)
expr_stmt|;
name|fromEnvironment
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~QMessagePattern
name|QMessagePattern
operator|::
name|~
name|QMessagePattern
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|literals
index|[
name|i
index|]
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
operator|delete
index|[]
name|literals
index|[
name|i
index|]
expr_stmt|;
operator|delete
index|[]
name|literals
expr_stmt|;
name|literals
operator|=
literal|0
expr_stmt|;
operator|delete
index|[]
name|tokens
expr_stmt|;
name|tokens
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|setPattern
name|void
name|QMessagePattern
operator|::
name|setPattern
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|)
block|{
operator|delete
index|[]
name|tokens
expr_stmt|;
operator|delete
index|[]
name|literals
expr_stmt|;
comment|// scanner
name|QList
argument_list|<
name|QString
argument_list|>
name|lexemes
decl_stmt|;
name|QString
name|lexeme
decl_stmt|;
name|bool
name|inPlaceholder
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pattern
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QChar
name|c
init|=
name|pattern
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
operator|)
operator|&&
operator|!
name|inPlaceholder
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|<
name|pattern
operator|.
name|size
argument_list|()
operator|)
operator|&&
name|pattern
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
comment|// beginning of placeholder
if|if
condition|(
operator|!
name|lexeme
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lexemes
operator|.
name|append
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
name|lexeme
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|inPlaceholder
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|lexeme
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
operator|&&
name|inPlaceholder
operator|)
condition|)
block|{
comment|// end of placeholder
name|lexemes
operator|.
name|append
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
name|lexeme
operator|.
name|clear
argument_list|()
expr_stmt|;
name|inPlaceholder
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|lexeme
operator|.
name|isEmpty
argument_list|()
condition|)
name|lexemes
operator|.
name|append
argument_list|(
name|lexeme
argument_list|)
expr_stmt|;
comment|// tokenizer
name|QVarLengthArray
argument_list|<
specifier|const
name|char
modifier|*
argument_list|>
name|literalsVar
decl_stmt|;
name|tokens
operator|=
operator|new
specifier|const
name|char
operator|*
index|[
name|lexemes
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
expr_stmt|;
name|tokens
index|[
name|lexemes
operator|.
name|size
argument_list|()
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lexemes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QString
name|lexeme
init|=
name|lexemes
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|lexeme
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"%{"
argument_list|)
argument_list|)
operator|&&
name|lexeme
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
argument_list|)
condition|)
block|{
comment|// placeholder
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|typeTokenC
argument_list|)
condition|)
block|{
name|tokens
index|[
name|i
index|]
operator|=
name|typeTokenC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|categoryTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|categoryTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|messageTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|messageTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|fileTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|fileTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|lineTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|lineTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|functionTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|functionTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|pidTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|pidTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|appnameTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|appnameTokenC
expr_stmt|;
elseif|else
if|if
condition|(
name|lexeme
operator|==
name|QLatin1String
argument_list|(
name|threadidTokenC
argument_list|)
condition|)
name|tokens
index|[
name|i
index|]
operator|=
name|threadidTokenC
expr_stmt|;
else|else
block|{
name|tokens
index|[
name|i
index|]
operator|=
name|emptyTokenC
expr_stmt|;
name|QString
name|error
init|=
name|QStringLiteral
argument_list|(
literal|"QT_MESSAGE_PATTERN: Unknown placeholder %1\n"
argument_list|)
operator|.
name|arg
argument_list|(
name|lexeme
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|OutputDebugString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|error
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
if|if
condition|(
name|usingWinMain
condition|)
block|{
name|OutputDebugString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|error
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|error
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|literal
init|=
operator|new
name|char
index|[
name|lexeme
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|strncpy
argument_list|(
name|literal
argument_list|,
name|lexeme
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|lexeme
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|literal
index|[
name|lexeme
operator|.
name|size
argument_list|()
index|]
operator|=
literal|'\0'
expr_stmt|;
name|literalsVar
operator|.
name|append
argument_list|(
name|literal
argument_list|)
expr_stmt|;
name|tokens
index|[
name|i
index|]
operator|=
name|literal
expr_stmt|;
block|}
block|}
name|literals
operator|=
operator|new
specifier|const
name|char
operator|*
index|[
name|literalsVar
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
expr_stmt|;
name|literals
index|[
name|literalsVar
operator|.
name|size
argument_list|()
index|]
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|literals
argument_list|,
name|literalsVar
operator|.
name|constData
argument_list|()
argument_list|,
name|literalsVar
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_SLOG2
argument_list|)
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|QT_LOG_CODE
end_ifndef
begin_define
DECL|macro|QT_LOG_CODE
define|#
directive|define
name|QT_LOG_CODE
value|9000
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
specifier|extern
name|char
modifier|*
name|__progname
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|slog2_default_handler
specifier|static
name|void
name|slog2_default_handler
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
if|if
condition|(
name|slog2_set_default_buffer
argument_list|(
operator|(
name|slog2_buffer_t
operator|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|slog2_buffer_set_config_t
name|buffer_config
decl_stmt|;
name|slog2_buffer_t
name|buffer_handle
decl_stmt|;
name|buffer_config
operator|.
name|buffer_set_name
operator|=
name|__progname
expr_stmt|;
name|buffer_config
operator|.
name|num_buffers
operator|=
literal|1
expr_stmt|;
name|buffer_config
operator|.
name|verbosity_level
operator|=
name|SLOG2_INFO
expr_stmt|;
name|buffer_config
operator|.
name|buffer_config
index|[
literal|0
index|]
operator|.
name|buffer_name
operator|=
literal|"default"
expr_stmt|;
name|buffer_config
operator|.
name|buffer_config
index|[
literal|0
index|]
operator|.
name|num_pages
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|slog2_register
argument_list|(
operator|&
name|buffer_config
argument_list|,
operator|&
name|buffer_handle
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error registering slogger2 buffer!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Set as the default buffer
name|slog2_set_default_buffer
argument_list|(
name|buffer_handle
argument_list|)
expr_stmt|;
block|}
name|int
name|severity
decl_stmt|;
comment|//Determines the severity level
switch|switch
condition|(
name|msgType
condition|)
block|{
case|case
name|QtDebugMsg
case|:
name|severity
operator|=
name|SLOG2_INFO
expr_stmt|;
break|break;
case|case
name|QtWarningMsg
case|:
name|severity
operator|=
name|SLOG2_NOTICE
expr_stmt|;
break|break;
case|case
name|QtCriticalMsg
case|:
name|severity
operator|=
name|SLOG2_WARNING
expr_stmt|;
break|break;
case|case
name|QtFatalMsg
case|:
name|severity
operator|=
name|SLOG2_ERROR
expr_stmt|;
break|break;
block|}
comment|//writes to the slog2 buffer
name|slog2c
argument_list|(
name|NULL
argument_list|,
name|QT_LOG_CODE
argument_list|,
name|severity
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_USE_SLOG2
end_comment
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QMessagePattern
argument_list|,
argument|qMessagePattern
argument_list|)
end_macro
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qMessageFormatString
name|Q_CORE_EXPORT
name|QString
name|qMessageFormatString
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|QString
name|message
decl_stmt|;
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|QMessagePattern
operator|::
name|mutex
argument_list|)
decl_stmt|;
name|QMessagePattern
modifier|*
name|pattern
init|=
name|qMessagePattern
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
block|{
comment|// after destruction of static QMessagePattern instance
name|message
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|// don't print anything if pattern was empty
if|if
condition|(
name|pattern
operator|->
name|tokens
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
name|message
return|;
comment|// we do not convert file, function, line literals to local encoding due to overhead
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|pattern
operator|->
name|tokens
index|[
name|i
index|]
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|token
init|=
name|pattern
operator|->
name|tokens
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|messageTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|categoryTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
name|context
operator|.
name|category
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|typeTokenC
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QtDebugMsg
case|:
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"debug"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QtWarningMsg
case|:
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"warning"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QtCriticalMsg
case|:
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"critical"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QtFatalMsg
case|:
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"fatal"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|fileTokenC
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|file
condition|)
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
name|context
operator|.
name|file
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"unknown"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|lineTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|context
operator|.
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|functionTokenC
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|function
condition|)
name|message
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|qCleanupFuncinfo
argument_list|(
name|context
operator|.
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"unknown"
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|pidTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|QCoreApplication
operator|::
name|applicationPid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|appnameTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QCoreApplication
operator|::
name|applicationName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|threadidTokenC
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"0x"
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|qlonglong
argument_list|(
name|QThread
operator|::
name|currentThread
argument_list|()
operator|->
name|currentThread
argument_list|()
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|message
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|message
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|0
argument_list|)
end_if
begin_comment
comment|// make sure they're defined to be exported
end_comment
begin_typedef
DECL|typedef|QtMsgHandler
typedef|typedef
name|void
function_decl|(
modifier|*
name|QtMsgHandler
function_decl|)
parameter_list|(
name|QtMsgType
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_typedef
begin_function_decl
name|Q_CORE_EXPORT
name|QtMsgHandler
name|qInstallMsgHandler
parameter_list|(
name|QtMsgHandler
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|msgHandler
specifier|static
name|QtMsgHandler
name|msgHandler
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|msgHandler
comment|// pointer to debug handler (without context)
end_comment
begin_decl_stmt
DECL|variable|messageHandler
specifier|static
name|QtMessageHandler
name|messageHandler
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|messageHandler
comment|// pointer to debug handler (with context)
end_comment
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qDefaultMessageHandler
specifier|static
name|void
name|qDefaultMessageHandler
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|buf
parameter_list|)
block|{
name|QString
name|logMessage
init|=
name|qMessageFormatString
argument_list|(
name|type
argument_list|,
name|context
argument_list|,
name|buf
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_BUILD_CORE_LIB
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
if|if
condition|(
name|usingWinMain
condition|)
endif|#
directive|endif
block|{
name|OutputDebugString
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|logMessage
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|// Q_OS_WIN
if|#
directive|if
name|defined
argument_list|(
name|QT_USE_SLOG2
argument_list|)
name|slog2_default_handler
argument_list|(
name|type
argument_list|,
name|logMessage
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|logMessage
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qDefaultMsgHandler
specifier|static
name|void
name|qDefaultMsgHandler
parameter_list|(
name|QtMsgType
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|QMessageLogContext
name|emptyContext
decl_stmt|;
name|qDefaultMessageHandler
argument_list|(
name|type
argument_list|,
name|emptyContext
argument_list|,
name|QLatin1String
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qt_message_print
specifier|static
name|void
name|qt_message_print
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
block|{
if|if
condition|(
operator|!
name|msgHandler
condition|)
name|msgHandler
operator|=
name|qDefaultMsgHandler
expr_stmt|;
if|if
condition|(
operator|!
name|messageHandler
condition|)
name|messageHandler
operator|=
name|qDefaultMessageHandler
expr_stmt|;
comment|// prefer new message handler over the old one
if|if
condition|(
name|msgHandler
operator|==
name|qDefaultMsgHandler
operator|||
name|messageHandler
operator|!=
name|qDefaultMessageHandler
condition|)
block|{
call|(
modifier|*
name|messageHandler
call|)
argument_list|(
name|msgType
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|msgHandler
call|)
argument_list|(
name|msgType
argument_list|,
name|message
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|qt_message_fatal
specifier|static
name|void
name|qt_message_fatal
parameter_list|(
name|QtMsgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_MSVC
argument_list|)
operator|&&
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|_CRT_ERROR
argument_list|)
name|wchar_t
name|contextFileL
index|[
literal|256
index|]
decl_stmt|;
comment|// we probably should let the compiler do this for us, by
comment|// declaring QMessageLogContext::file to be const wchar_t * in
comment|// the first place, but the #ifdefery above is very complex
comment|// and we wouldn't be able to change it later on...
name|convert_to_wchar_t_elided
argument_list|(
name|contextFileL
argument_list|,
sizeof|sizeof
name|contextFileL
operator|/
sizeof|sizeof
expr|*
name|contextFileL
argument_list|,
name|context
operator|.
name|file
argument_list|)
expr_stmt|;
comment|// get the current report mode
name|int
name|reportMode
init|=
name|_CrtSetReportMode
argument_list|(
name|_CRT_ERROR
argument_list|,
name|_CRTDBG_MODE_WNDW
argument_list|)
decl_stmt|;
name|_CrtSetReportMode
argument_list|(
name|_CRT_ERROR
argument_list|,
name|reportMode
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|_CrtDbgReportW
argument_list|(
name|_CRT_ERROR
argument_list|,
name|contextFileL
argument_list|,
name|context
operator|.
name|line
argument_list|,
name|_CRT_WIDE
argument_list|(
name|QT_VERSION_STR
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|message
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|reportMode
operator|&
name|_CRTDBG_MODE_WNDW
condition|)
return|return;
comment|// ignore
elseif|else
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
name|_CrtDbgBreak
argument_list|()
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|message
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_CC_MINGW
argument_list|)
operator|)
name|abort
argument_list|()
expr_stmt|;
comment|// trap; generates core dump
else|#
directive|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// goodbye cruel world
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|qt_message_output
name|void
name|qt_message_output
parameter_list|(
name|QtMsgType
name|msgType
parameter_list|,
specifier|const
name|QMessageLogContext
modifier|&
name|context
parameter_list|,
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
block|{
name|qt_message_print
argument_list|(
name|msgType
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatal
argument_list|(
name|msgType
argument_list|)
condition|)
name|qt_message_fatal
argument_list|(
name|msgType
argument_list|,
name|context
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qErrnoWarning
name|void
name|qErrnoWarning
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
comment|// qt_error_string() will allocate anyway, so we don't have
comment|// to be careful here (like we do in plain qWarning())
name|QString
name|buf
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|buf
operator|.
name|vsprintf
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1String
argument_list|(
literal|" ("
argument_list|)
operator|+
name|qt_error_string
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|QMessageLogContext
name|context
decl_stmt|;
name|qt_message_output
argument_list|(
name|QtCriticalMsg
argument_list|,
name|context
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qErrnoWarning
name|void
name|qErrnoWarning
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
comment|// qt_error_string() will allocate anyway, so we don't have
comment|// to be careful here (like we do in plain qWarning())
name|QString
name|buf
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|buf
operator|.
name|vsprintf
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|QLatin1String
argument_list|(
literal|" ("
argument_list|)
operator|+
name|qt_error_string
argument_list|(
name|code
argument_list|)
operator|+
name|QLatin1Char
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|QMessageLogContext
name|context
decl_stmt|;
name|qt_message_output
argument_list|(
name|QtCriticalMsg
argument_list|,
name|context
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \typedef QtMsgHandler     \relates<QtGlobal>     \deprecated      This is a typedef for a pointer to a function with the following     signature:      \snippet code/src_corelib_global_qglobal.cpp 7      This typedef is deprecated, you should use QtMessageHandler instead.     \sa QtMsgType, QtMessageHandler, qInstallMsgHandler(), qInstallMessageHandler() */
end_comment
begin_comment
comment|/*!     \typedef QtMessageHandler     \relates<QtGlobal>     \since 5.0      This is a typedef for a pointer to a function with the following     signature:      \snippet code/src_corelib_global_qglobal.cpp 49      \sa QtMsgType, qInstallMessageHandler() */
end_comment
begin_comment
comment|/*!     \fn QtMessageHandler qInstallMessageHandler(QtMessageHandler handler)     \relates<QtGlobal>     \since 5.0      Installs a Qt message \a handler which has been defined     previously. Returns a pointer to the previous message handler     (which may be 0).      The message handler is a function that prints out debug messages,     warnings, critical and fatal error messages. The Qt library (debug     mode) contains hundreds of warning messages that are printed     when internal errors (usually invalid function arguments)     occur. Qt built in release mode also contains such warnings unless     QT_NO_WARNING_OUTPUT and/or QT_NO_DEBUG_OUTPUT have been set during     compilation. If you implement your own message handler, you get total     control of these messages.      The default message handler prints the message to the standard     output under X11 or to the debugger under Windows. If it is a     fatal message, the application aborts immediately.      Only one message handler can be defined, since this is usually     done on an application-wide basis to control debug output.      To restore the message handler, call \c qInstallMessageHandler(0).      Example:      \snippet code/src_corelib_global_qglobal.cpp 23      \sa QtMessageHandler, QtMsgType, qDebug(), qWarning(), qCritical(), qFatal(),     {Debugging Techniques} */
end_comment
begin_comment
comment|/*!     \fn QtMsgHandler qInstallMsgHandler(QtMsgHandler handler)     \relates<QtGlobal>     \deprecated      Installs a Qt message \a handler which has been defined     previously. This method is deprecated, use qInstallMessageHandler     instead.     \sa QtMsgHandler, qInstallMessageHandler() */
end_comment
begin_comment
comment|/*!     \fn void qSetMessagePattern(const QString&pattern)     \relates<QtGlobal>     \since 5.0      \brief Changes the output of the default message handler.      Allows to tweak the output of qDebug(), qWarning(), qCritical() and qFatal().      Following placeholders are supported:      \table     \header \li Placeholder \li Description     \row \li \c %{appname} \li QCoreApplication::applicationName()     \row \li \c %{file} \li Path to source file     \row \li \c %{function} \li Function     \row \li \c %{line} \li Line in source file     \row \li \c %{message} \li The actual message     \row \li \c %{pid} \li QCoreApplication::applicationPid()     \row \li \c %{threadid} \li ID of current thread     \row \li \c %{type} \li "debug", "warning", "critical" or "fatal"     \endtable      The default \a pattern is "%{message}".      The \a pattern can also be changed at runtime by setting the QT_MESSAGE_PATTERN     environment variable; if both qSetMessagePattern() is called and QT_MESSAGE_PATTERN is     set, the environment variable takes precedence.      qSetMessagePattern() has no effect if a custom message handler is installed.      \sa qInstallMessageHandler(), {Debugging Techniques}  */
end_comment
begin_function
DECL|function|qInstallMessageHandler
name|QtMessageHandler
name|qInstallMessageHandler
parameter_list|(
name|QtMessageHandler
name|h
parameter_list|)
block|{
if|if
condition|(
operator|!
name|messageHandler
condition|)
name|messageHandler
operator|=
name|qDefaultMessageHandler
expr_stmt|;
name|QtMessageHandler
name|old
init|=
name|messageHandler
decl_stmt|;
name|messageHandler
operator|=
name|h
expr_stmt|;
return|return
name|old
return|;
block|}
end_function
begin_function
DECL|function|qInstallMsgHandler
name|QtMsgHandler
name|qInstallMsgHandler
parameter_list|(
name|QtMsgHandler
name|h
parameter_list|)
block|{
comment|//if handler is 0, set it to the
comment|//default message handler
if|if
condition|(
operator|!
name|msgHandler
condition|)
name|msgHandler
operator|=
name|qDefaultMsgHandler
expr_stmt|;
name|QtMsgHandler
name|old
init|=
name|msgHandler
decl_stmt|;
name|msgHandler
operator|=
name|h
expr_stmt|;
return|return
name|old
return|;
block|}
end_function
begin_function
DECL|function|qSetMessagePattern
name|void
name|qSetMessagePattern
parameter_list|(
specifier|const
name|QString
modifier|&
name|pattern
parameter_list|)
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|QMessagePattern
operator|::
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qMessagePattern
argument_list|()
operator|->
name|fromEnvironment
condition|)
name|qMessagePattern
argument_list|()
operator|->
name|setPattern
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Copies context information from \a logContext into this QMessageLogContext     \internal */
end_comment
begin_function
DECL|function|copy
name|void
name|QMessageLogContext
operator|::
name|copy
parameter_list|(
specifier|const
name|QMessageLogContext
modifier|&
name|logContext
parameter_list|)
block|{
name|this
operator|->
name|category
operator|=
name|logContext
operator|.
name|category
expr_stmt|;
name|this
operator|->
name|file
operator|=
name|logContext
operator|.
name|file
expr_stmt|;
name|this
operator|->
name|line
operator|=
name|logContext
operator|.
name|line
expr_stmt|;
name|this
operator|->
name|function
operator|=
name|logContext
operator|.
name|function
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QMessageLogger::QMessageLogger()      Constructs a default QMessageLogger. See the other constructors to specify     context information. */
end_comment
begin_comment
comment|/*!     \fn QMessageLogger::QMessageLogger(const char *file, int line, const char *function)      Constructs a QMessageLogger to record log messages for \a file at \a line     in \a function. The is equivalent to QMessageLogger(file, line, function, "default") */
end_comment
begin_comment
comment|/*!     \fn QMessageLogger::QMessageLogger(const char *file, int line, const char *function, const char *category)      Constructs a QMessageLogger to record \a category messages for \a file at \a line     in \a function. */
end_comment
begin_comment
comment|/*!     \fn void QMessageLogger::noDebug(const char *, ...) const     \internal      Ignores logging output      \sa QNoDebug, qDebug() */
end_comment
begin_comment
comment|/*!     \fn QMessageLogContext::QMessageLogContext()     \internal      Constructs a QMessageLogContext */
end_comment
begin_comment
comment|/*!     \fn QMessageLogContext::QMessageLogContext(const char *fileName, int lineNumber, const char *functionName, const char *categoryName)     \internal      Constructs a QMessageLogContext with for file \a fileName at line     \a lineNumber, in function \a functionName, and category \a CategoryName. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
