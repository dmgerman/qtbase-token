begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"QtCore/qxmlstream.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_XMLSTREAM
end_ifndef
begin_include
include|#
directive|include
file|"qxmlutils_p.h"
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<qtextcodec.h>
end_include
begin_include
include|#
directive|include
file|<qstack.h>
end_include
begin_include
include|#
directive|include
file|<qbuffer.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_else
else|#
directive|else
end_else
begin_comment
comment|// This specialization of Q_DECLARE_TR_FUNCTIONS is not in qcoreapplication.h,
end_comment
begin_comment
comment|// because that header depends on QObject being available, which is not the
end_comment
begin_comment
comment|// case for most bootstrapped applications.
end_comment
begin_define
DECL|macro|Q_DECLARE_TR_FUNCTIONS
define|#
directive|define
name|Q_DECLARE_TR_FUNCTIONS
parameter_list|(
name|context
parameter_list|)
define|\
value|public: \     static inline QString tr(const char *sourceText, const char *comment = 0) \         { Q_UNUSED(comment); return QString::fromLatin1(sourceText); } \     static inline QString trUtf8(const char *sourceText, const char *comment = 0) \         { Q_UNUSED(comment); return QString::fromLatin1(sourceText); } \     static inline QString tr(const char *sourceText, const char*, int) \         { return QString::fromLatin1(sourceText); } \     static inline QString trUtf8(const char *sourceText, const char*, int) \         { return QString::fromLatin1(sourceText); } \ private:
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
include|#
directive|include
file|"qxmlstream_p.h"
DECL|enumerator|StreamEOF
name|enum
type|{
name|StreamEOF
init|=
operator|~
literal|0U
end_decl_stmt
begin_comment
unit|};
comment|/*!     \enum QXmlStreamReader::TokenType      This enum specifies the type of token the reader just read.      \value NoToken The reader has not yet read anything.      \value Invalid An error has occurred, reported in error() and     errorString().      \value StartDocument The reader reports the XML version number in     documentVersion(), and the encoding as specified in the XML     document in documentEncoding().  If the document is declared     standalone, isStandaloneDocument() returns \c true; otherwise it     returns \c false.      \value EndDocument The reader reports the end of the document.      \value StartElement The reader reports the start of an element     with namespaceUri() and name(). Empty elements are also reported     as StartElement, followed directly by EndElement. The convenience     function readElementText() can be called to concatenate all     content until the corresponding EndElement. Attributes are     reported in attributes(), namespace declarations in     namespaceDeclarations().      \value EndElement The reader reports the end of an element with     namespaceUri() and name().      \value Characters The reader reports characters in text(). If the     characters are all white-space, isWhitespace() returns \c true. If     the characters stem from a CDATA section, isCDATA() returns \c true.      \value Comment The reader reports a comment in text().      \value DTD The reader reports a DTD in text(), notation     declarations in notationDeclarations(), and entity declarations in     entityDeclarations(). Details of the DTD declaration are reported     in in dtdName(), dtdPublicId(), and dtdSystemId().      \value EntityReference The reader reports an entity reference that     could not be resolved.  The name of the reference is reported in     name(), the replacement text in text().      \value ProcessingInstruction The reader reports a processing     instruction in processingInstructionTarget() and     processingInstructionData(). */
end_comment
begin_comment
comment|/*!     \enum QXmlStreamReader::ReadElementTextBehaviour      This enum specifies the different behaviours of readElementText().      \value ErrorOnUnexpectedElement Raise an UnexpectedElementError and return     what was read so far when a child element is encountered.      \value IncludeChildElements Recursively include the text from child elements.      \value SkipChildElements Skip child elements.      \since 4.6 */
end_comment
begin_comment
comment|/*!     \enum QXmlStreamReader::Error      This enum specifies different error cases      \value NoError No error has occurred.      \value CustomError A custom error has been raised with     raiseError()      \value NotWellFormedError The parser internally raised an error     due to the read XML not being well-formed.      \value PrematureEndOfDocumentError The input stream ended before a     well-formed XML document was parsed. Recovery from this error is     possible if more XML arrives in the stream, either by calling     addData() or by waiting for it to arrive on the device().      \value UnexpectedElementError The parser encountered an element     that was different to those it expected.  */
end_comment
begin_comment
comment|/*!   \class QXmlStreamEntityResolver   \inmodule QtCore   \reentrant   \since 4.4    \brief The QXmlStreamEntityResolver class provides an entity   resolver for a QXmlStreamReader.    \ingroup xml-tools  */
end_comment
begin_comment
comment|/*!   Destroys the entity resolver.  */
end_comment
begin_destructor
DECL|function|~QXmlStreamEntityResolver
name|QXmlStreamEntityResolver
operator|::
name|~
name|QXmlStreamEntityResolver
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!   \internal  This function is a stub for later functionality. */
end_comment
begin_function
DECL|function|resolveEntity
name|QString
name|QXmlStreamEntityResolver
operator|::
name|resolveEntity
parameter_list|(
specifier|const
name|QString
modifier|&
comment|/*publicId*/
parameter_list|,
specifier|const
name|QString
modifier|&
comment|/*systemId*/
parameter_list|)
block|{
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Resolves the undeclared entity \a name and returns its replacement   text. If the entity is also unknown to the entity resolver, it   returns an empty string.    The default implementation always returns an empty string. */
end_comment
begin_function
DECL|function|resolveUndeclaredEntity
name|QString
name|QXmlStreamEntityResolver
operator|::
name|resolveUndeclaredEntity
parameter_list|(
specifier|const
name|QString
modifier|&
comment|/*name*/
parameter_list|)
block|{
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_XMLSTREAMREADER
end_ifndef
begin_function
DECL|function|resolveUndeclaredEntity
name|QString
name|QXmlStreamReaderPrivate
operator|::
name|resolveUndeclaredEntity
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|entityResolver
condition|)
return|return
name|entityResolver
operator|->
name|resolveUndeclaredEntity
argument_list|(
name|name
argument_list|)
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!    \since 4.4     Makes \a resolver the new entityResolver().     The stream reader does \e not take ownership of the resolver. It's    the callers responsibility to ensure that the resolver is valid    during the entire life-time of the stream reader object, or until    another resolver or 0 is set.     \sa entityResolver()  */
end_comment
begin_function
DECL|function|setEntityResolver
name|void
name|QXmlStreamReader
operator|::
name|setEntityResolver
parameter_list|(
name|QXmlStreamEntityResolver
modifier|*
name|resolver
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
name|d
operator|->
name|entityResolver
operator|=
name|resolver
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \since 4.4    Returns the entity resolver, or 0 if there is no entity resolver.    \sa setEntityResolver()  */
end_comment
begin_function
DECL|function|entityResolver
name|QXmlStreamEntityResolver
modifier|*
name|QXmlStreamReader
operator|::
name|entityResolver
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|entityResolver
return|;
block|}
end_function
begin_comment
comment|/*!   \class QXmlStreamReader   \inmodule QtCore   \reentrant   \since 4.3    \brief The QXmlStreamReader class provides a fast parser for reading   well-formed XML via a simple streaming API.     \ingroup xml-tools    QXmlStreamReader is a faster and more convenient replacement for   Qt's own SAX parser (see QXmlSimpleReader). In some cases it might   also be a faster and more convenient alternative for use in   applications that would otherwise use a DOM tree (see QDomDocument).   QXmlStreamReader reads data either from a QIODevice (see   setDevice()), or from a raw QByteArray (see addData()).    Qt provides QXmlStreamWriter for writing XML.    The basic concept of a stream reader is to report an XML document as   a stream of tokens, similar to SAX. The main difference between   QXmlStreamReader and SAX is \e how these XML tokens are reported.   With SAX, the application must provide handlers (callback functions)   that receive so-called XML \e events from the parser at the parser's   convenience.  With QXmlStreamReader, the application code itself   drives the loop and pulls \e tokens from the reader, one after   another, as it needs them. This is done by calling readNext(), where   the reader reads from the input stream until it completes the next   token, at which point it returns the tokenType(). A set of   convenient functions including isStartElement() and text() can then   be used to examine the token to obtain information about what has   been read. The big advantage of this \e pulling approach is the   possibility to build recursive descent parsers with it, meaning you   can split your XML parsing code easily into different methods or   classes. This makes it easy to keep track of the application's own   state when parsing XML.    A typical loop with QXmlStreamReader looks like this:    \snippet code/src_corelib_xml_qxmlstream.cpp 0     QXmlStreamReader is a well-formed XML 1.0 parser that does \e not   include external parsed entities. As long as no error occurs, the   application code can thus be assured that the data provided by the   stream reader satisfies the W3C's criteria for well-formed XML. For   example, you can be certain that all tags are indeed nested and   closed properly, that references to internal entities have been   replaced with the correct replacement text, and that attributes have   been normalized or added according to the internal subset of the   DTD.    If an error occurs while parsing, atEnd() and hasError() return   true, and error() returns the error that occurred. The functions   errorString(), lineNumber(), columnNumber(), and characterOffset()   are for constructing an appropriate error or warning message. To   simplify application code, QXmlStreamReader contains a raiseError()   mechanism that lets you raise custom errors that trigger the same   error handling described.    The \l{QXmlStream Bookmarks Example} illustrates how to use the   recursive descent technique to read an XML bookmark file (XBEL) with   a stream reader.    \section1 Namespaces    QXmlStream understands and resolves XML namespaces. E.g. in case of   a StartElement, namespaceUri() returns the namespace the element is   in, and name() returns the element's \e local name. The combination   of namespaceUri and name uniquely identifies an element. If a   namespace prefix was not declared in the XML entities parsed by the   reader, the namespaceUri is empty.    If you parse XML data that does not utilize namespaces according to   the XML specification or doesn't use namespaces at all, you can use   the element's qualifiedName() instead. A qualified name is the   element's prefix() followed by colon followed by the element's local   name() - exactly like the element appears in the raw XML data. Since   the mapping namespaceUri to prefix is neither unique nor universal,   qualifiedName() should be avoided for namespace-compliant XML data.    In order to parse standalone documents that do use undeclared   namespace prefixes, you can turn off namespace processing completely   with the \l namespaceProcessing property.    \section1 Incremental Parsing    QXmlStreamReader is an incremental parser. It can handle the case   where the document can't be parsed all at once because it arrives in   chunks (e.g. from multiple files, or over a network connection).   When the reader runs out of data before the complete document has   been parsed, it reports a PrematureEndOfDocumentError. When more   data arrives, either because of a call to addData() or because more   data is available through the network device(), the reader recovers   from the PrematureEndOfDocumentError error and continues parsing the   new data with the next call to readNext().    For example, if your application reads data from the network using a   \l{QNetworkAccessManager} {network access manager}, you would issue   a \l{QNetworkRequest} {network request} to the manager and receive a   \l{QNetworkReply} {network reply} in return. Since a QNetworkReply   is a QIODevice, you connect its \l{QIODevice::readyRead()}   {readyRead()} signal to a custom slot, e.g. \c{slotReadyRead()} in   the code snippet shown in the discussion for QNetworkAccessManager.   In this slot, you read all available data with   \l{QIODevice::readAll()} {readAll()} and pass it to the XML   stream reader using addData(). Then you call your custom parsing   function that reads the XML events from the reader.    \section1 Performance and Memory Consumption    QXmlStreamReader is memory-conservative by design, since it doesn't   store the entire XML document tree in memory, but only the current   token at the time it is reported. In addition, QXmlStreamReader   avoids the many small string allocations that it normally takes to   map an XML document to a convenient and Qt-ish API. It does this by   reporting all string data as QStringRef rather than real QString   objects. QStringRef is a thin wrapper around QString substrings that   provides a subset of the QString API without the memory allocation   and reference-counting overhead. Calling   \l{QStringRef::toString()}{toString()} on any of those objects   returns an equivalent real QString object.  */
end_comment
begin_comment
comment|/*!   Constructs a stream reader.    \sa setDevice(), addData()  */
end_comment
begin_constructor
DECL|function|QXmlStreamReader
name|QXmlStreamReader
operator|::
name|QXmlStreamReader
parameter_list|()
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QXmlStreamReaderPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!  Creates a new stream reader that reads from \a device.  \sa setDevice(), clear()  */
end_comment
begin_constructor
DECL|function|QXmlStreamReader
name|QXmlStreamReader
operator|::
name|QXmlStreamReader
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QXmlStreamReaderPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|setDevice
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Creates a new stream reader that reads from \a data.    \sa addData(), clear(), setDevice()  */
end_comment
begin_constructor
DECL|function|QXmlStreamReader
name|QXmlStreamReader
operator|::
name|QXmlStreamReader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QXmlStreamReaderPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
name|d
operator|->
name|dataBuffer
operator|=
name|data
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Creates a new stream reader that reads from \a data.    \sa addData(), clear(), setDevice()  */
end_comment
begin_constructor
DECL|function|QXmlStreamReader
name|QXmlStreamReader
operator|::
name|QXmlStreamReader
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QXmlStreamReaderPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_NO_TEXTCODEC
name|d
operator|->
name|dataBuffer
operator|=
name|data
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|dataBuffer
operator|=
name|d
operator|->
name|codec
operator|->
name|fromUnicode
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|d
operator|->
name|decoder
operator|=
name|d
operator|->
name|codec
operator|->
name|makeDecoder
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|lockEncoding
operator|=
literal|true
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Creates a new stream reader that reads from \a data.    \sa addData(), clear(), setDevice()  */
end_comment
begin_constructor
DECL|function|QXmlStreamReader
name|QXmlStreamReader
operator|::
name|QXmlStreamReader
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QXmlStreamReaderPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
name|d
operator|->
name|dataBuffer
operator|=
name|QByteArray
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Destructs the reader.  */
end_comment
begin_destructor
DECL|function|~QXmlStreamReader
name|QXmlStreamReader
operator|::
name|~
name|QXmlStreamReader
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|deleteDevice
condition|)
operator|delete
name|d
operator|->
name|device
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*! \fn bool QXmlStreamReader::hasError() const     Returns \c true if an error has occurred, otherwise \c false.      \sa errorString(), error()  */
end_comment
begin_comment
comment|/*!     Sets the current device to \a device. Setting the device resets     the stream to its initial state.      \sa device(), clear() */
end_comment
begin_function
DECL|function|setDevice
name|void
name|QXmlStreamReader
operator|::
name|setDevice
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|deleteDevice
condition|)
block|{
operator|delete
name|d
operator|->
name|device
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|false
expr_stmt|;
block|}
name|d
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current device associated with the QXmlStreamReader,     or 0 if no device has been assigned.      \sa setDevice() */
end_comment
begin_function
DECL|function|device
name|QIODevice
modifier|*
name|QXmlStreamReader
operator|::
name|device
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|device
return|;
block|}
end_function
begin_comment
comment|/*!   Adds more \a data for the reader to read. This function does   nothing if the reader has a device().    \sa readNext(), clear()  */
end_comment
begin_function
DECL|function|addData
name|void
name|QXmlStreamReader
operator|::
name|addData
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|device
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXmlStreamReader: addData() with device()"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|dataBuffer
operator|+=
name|data
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Adds more \a data for the reader to read. This function does   nothing if the reader has a device().    \sa readNext(), clear()  */
end_comment
begin_function
DECL|function|addData
name|void
name|QXmlStreamReader
operator|::
name|addData
parameter_list|(
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
name|d
operator|->
name|lockEncoding
operator|=
literal|true
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_NO_TEXTCODEC
name|addData
argument_list|(
name|data
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|addData
argument_list|(
name|d
operator|->
name|codec
operator|->
name|fromUnicode
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!   Adds more \a data for the reader to read. This function does   nothing if the reader has a device().    \sa readNext(), clear()  */
end_comment
begin_function
DECL|function|addData
name|void
name|QXmlStreamReader
operator|::
name|addData
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|addData
argument_list|(
name|QByteArray
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Removes any device() or data from the reader and resets its     internal state to the initial state.      \sa addData()  */
end_comment
begin_function
DECL|function|clear
name|void
name|QXmlStreamReader
operator|::
name|clear
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|device
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|deleteDevice
condition|)
operator|delete
name|d
operator|->
name|device
expr_stmt|;
name|d
operator|->
name|device
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the reader has read until the end of the XML     document, or if an error() has occurred and reading has been     aborted. Otherwise, it returns \c false.      When atEnd() and hasError() return true and error() returns     PrematureEndOfDocumentError, it means the XML has been well-formed     so far, but a complete XML document has not been parsed. The next     chunk of XML can be added with addData(), if the XML is being read     from a QByteArray, or by waiting for more data to arrive if the     XML is being read from a QIODevice. Either way, atEnd() will     return false once more data is available.      \sa hasError(), error(), device(), QIODevice::atEnd()  */
end_comment
begin_function
DECL|function|atEnd
name|bool
name|QXmlStreamReader
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|atEnd
operator|&&
operator|(
operator|(
name|d
operator|->
name|type
operator|==
name|QXmlStreamReader
operator|::
name|Invalid
operator|&&
name|d
operator|->
name|error
operator|==
name|PrematureEndOfDocumentError
operator|)
operator|||
operator|(
name|d
operator|->
name|type
operator|==
name|QXmlStreamReader
operator|::
name|EndDocument
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|device
condition|)
return|return
name|d
operator|->
name|device
operator|->
name|atEnd
argument_list|()
return|;
else|else
return|return
operator|!
name|d
operator|->
name|dataBuffer
operator|.
name|size
argument_list|()
return|;
block|}
return|return
operator|(
name|d
operator|->
name|atEnd
operator|||
name|d
operator|->
name|type
operator|==
name|QXmlStreamReader
operator|::
name|Invalid
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!   Reads the next token and returns its type.    With one exception, once an error() is reported by readNext(),   further reading of the XML stream is not possible. Then atEnd()   returns \c true, hasError() returns \c true, and this function returns   QXmlStreamReader::Invalid.    The exception is when error() returns PrematureEndOfDocumentError.   This error is reported when the end of an otherwise well-formed   chunk of XML is reached, but the chunk doesn't represent a complete   XML document.  In that case, parsing \e can be resumed by calling   addData() to add the next chunk of XML, when the stream is being   read from a QByteArray, or by waiting for more data to arrive when   the stream is being read from a device().    \sa tokenType(), tokenString()  */
end_comment
begin_function
DECL|function|readNext
name|QXmlStreamReader
operator|::
name|TokenType
name|QXmlStreamReader
operator|::
name|readNext
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|type
operator|!=
name|Invalid
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|hasCheckedStartDocument
condition|)
if|if
condition|(
operator|!
name|d
operator|->
name|checkStartDocument
argument_list|()
condition|)
return|return
name|d
operator|->
name|type
return|;
comment|// synthetic StartDocument or error
name|d
operator|->
name|parse
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|atEnd
operator|&&
name|d
operator|->
name|type
operator|!=
name|EndDocument
operator|&&
name|d
operator|->
name|type
operator|!=
name|Invalid
condition|)
name|d
operator|->
name|raiseError
argument_list|(
name|PrematureEndOfDocumentError
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|atEnd
operator|&&
name|d
operator|->
name|type
operator|==
name|EndDocument
condition|)
name|d
operator|->
name|raiseWellFormedError
argument_list|(
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Extra content at end of document."
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|error
operator|==
name|PrematureEndOfDocumentError
condition|)
block|{
comment|// resume error
name|d
operator|->
name|type
operator|=
name|NoToken
expr_stmt|;
name|d
operator|->
name|atEnd
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|token
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|readNext
argument_list|()
return|;
block|}
return|return
name|d
operator|->
name|type
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the type of the current token.    The current token can also be queried with the convenience functions   isStartDocument(), isEndDocument(), isStartElement(),   isEndElement(), isCharacters(), isComment(), isDTD(),   isEntityReference(), and isProcessingInstruction().    \sa tokenString()  */
end_comment
begin_function
DECL|function|tokenType
name|QXmlStreamReader
operator|::
name|TokenType
name|QXmlStreamReader
operator|::
name|tokenType
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|type
return|;
block|}
end_function
begin_comment
comment|/*!   Reads until the next start element within the current element. Returns \c true   when a start element was reached. When the end element was reached, or when   an error occurred, false is returned.    The current element is the element matching the most recently parsed start   element of which a matching end element has not yet been reached. When the   parser has reached the end element, the current element becomes the parent   element.    This is a convenience function for when you're only concerned with parsing   XML elements. The \l{QXmlStream Bookmarks Example} makes extensive use of   this function.    \since 4.6   \sa readNext()  */
end_comment
begin_function
DECL|function|readNextStartElement
name|bool
name|QXmlStreamReader
operator|::
name|readNextStartElement
parameter_list|()
block|{
while|while
condition|(
name|readNext
argument_list|()
operator|!=
name|Invalid
condition|)
block|{
if|if
condition|(
name|isEndElement
argument_list|()
condition|)
return|return
literal|false
return|;
elseif|else
if|if
condition|(
name|isStartElement
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!   Reads until the end of the current element, skipping any child nodes.   This function is useful for skipping unknown elements.    The current element is the element matching the most recently parsed start   element of which a matching end element has not yet been reached. When the   parser has reached the end element, the current element becomes the parent   element.    \since 4.6  */
end_comment
begin_function
DECL|function|skipCurrentElement
name|void
name|QXmlStreamReader
operator|::
name|skipCurrentElement
parameter_list|()
block|{
name|int
name|depth
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|depth
operator|&&
name|readNext
argument_list|()
operator|!=
name|Invalid
condition|)
block|{
if|if
condition|(
name|isEndElement
argument_list|()
condition|)
operator|--
name|depth
expr_stmt|;
elseif|else
if|if
condition|(
name|isStartElement
argument_list|()
condition|)
operator|++
name|depth
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Use the following Perl script to generate the error string index list: ===== PERL SCRIPT ==== print "static const char QXmlStreamReader_tokenTypeString_string[] =\n"; $counter = 0; $i = 0; while (<STDIN>) {     chomp;     print "    \"$_\\0\"\n";     $sizes[$i++] = $counter;     $counter += length 1 + $_; } print "    \"\\0\";\n\nstatic const short QXmlStreamReader_tokenTypeString_indices[] = {\n    "; for ($j = 0; $j< $i; ++$j) {     printf "$sizes[$j], "; } print "0\n};\n"; ===== PERL SCRIPT ====   * The input data is as follows (copied from qxmlstream.h): NoToken Invalid StartDocument EndDocument StartElement EndElement Characters Comment DTD EntityReference ProcessingInstruction */
end_comment
begin_decl_stmt
DECL|variable|QXmlStreamReader_tokenTypeString_string
specifier|static
specifier|const
name|char
name|QXmlStreamReader_tokenTypeString_string
index|[]
init|=
literal|"NoToken\0"
literal|"Invalid\0"
literal|"StartDocument\0"
literal|"EndDocument\0"
literal|"StartElement\0"
literal|"EndElement\0"
literal|"Characters\0"
literal|"Comment\0"
literal|"DTD\0"
literal|"EntityReference\0"
literal|"ProcessingInstruction\0"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|QXmlStreamReader_tokenTypeString_indices
specifier|static
specifier|const
name|short
name|QXmlStreamReader_tokenTypeString_indices
index|[]
init|=
block|{
literal|0
block|,
literal|8
block|,
literal|16
block|,
literal|30
block|,
literal|42
block|,
literal|55
block|,
literal|66
block|,
literal|77
block|,
literal|85
block|,
literal|89
block|,
literal|105
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*!     \property  QXmlStreamReader::namespaceProcessing     The namespace-processing flag of the stream reader      This property controls whether or not the stream reader processes     namespaces. If enabled, the reader processes namespaces, otherwise     it does not.      By default, namespace-processing is enabled. */
end_comment
begin_function
DECL|function|setNamespaceProcessing
name|void
name|QXmlStreamReader
operator|::
name|setNamespaceProcessing
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
name|d
operator|->
name|namespaceProcessing
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_function
DECL|function|namespaceProcessing
name|bool
name|QXmlStreamReader
operator|::
name|namespaceProcessing
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|namespaceProcessing
return|;
block|}
end_function
begin_comment
comment|/*! Returns the reader's current token as string.  \sa tokenType() */
end_comment
begin_function
DECL|function|tokenString
name|QString
name|QXmlStreamReader
operator|::
name|tokenString
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|QLatin1String
argument_list|(
name|QXmlStreamReader_tokenTypeString_string
operator|+
name|QXmlStreamReader_tokenTypeString_indices
index|[
name|d
operator|->
name|type
index|]
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_XMLSTREAMREADER
end_comment
begin_constructor
DECL|function|QXmlStreamPrivateTagStack
name|QXmlStreamPrivateTagStack
operator|::
name|QXmlStreamPrivateTagStack
parameter_list|()
block|{
name|tagStack
operator|.
name|reserve
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|tagStackStringStorage
operator|.
name|reserve
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|tagStackStringStorageSize
operator|=
literal|0
expr_stmt|;
name|NamespaceDeclaration
modifier|&
name|namespaceDeclaration
init|=
name|namespaceDeclarations
operator|.
name|push
argument_list|()
decl_stmt|;
name|namespaceDeclaration
operator|.
name|prefix
operator|=
name|addToStringStorage
argument_list|(
name|QLatin1String
argument_list|(
literal|"xml"
argument_list|)
argument_list|)
expr_stmt|;
name|namespaceDeclaration
operator|.
name|namespaceUri
operator|=
name|addToStringStorage
argument_list|(
name|QLatin1String
argument_list|(
literal|"http://www.w3.org/XML/1998/namespace"
argument_list|)
argument_list|)
expr_stmt|;
name|initialTagStackStringStorageSize
operator|=
name|tagStackStringStorageSize
expr_stmt|;
block|}
end_constructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_XMLSTREAMREADER
end_ifndef
begin_constructor
DECL|function|QXmlStreamReaderPrivate
name|QXmlStreamReaderPrivate
operator|::
name|QXmlStreamReaderPrivate
parameter_list|(
name|QXmlStreamReader
modifier|*
name|q
parameter_list|)
member_init_list|:
name|q_ptr
argument_list|(
name|q
argument_list|)
block|{
name|device
operator|=
literal|0
expr_stmt|;
name|deleteDevice
operator|=
literal|false
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|decoder
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|stack_size
operator|=
literal|64
expr_stmt|;
name|sym_stack
operator|=
literal|0
expr_stmt|;
name|state_stack
operator|=
literal|0
expr_stmt|;
name|reallocateStack
argument_list|()
expr_stmt|;
name|entityResolver
operator|=
literal|0
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
name|entityHash
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"lt"
argument_list|)
argument_list|,
name|Entity
operator|::
name|createLiteral
argument_list|(
name|QLatin1String
argument_list|(
literal|"<"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|entityHash
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"gt"
argument_list|)
argument_list|,
name|Entity
operator|::
name|createLiteral
argument_list|(
name|QLatin1String
argument_list|(
literal|">"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|entityHash
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"amp"
argument_list|)
argument_list|,
name|Entity
operator|::
name|createLiteral
argument_list|(
name|QLatin1String
argument_list|(
literal|"&"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|entityHash
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"apos"
argument_list|)
argument_list|,
name|Entity
operator|::
name|createLiteral
argument_list|(
name|QLatin1String
argument_list|(
literal|"'"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|entityHash
operator|.
name|insert
argument_list|(
name|QLatin1String
argument_list|(
literal|"quot"
argument_list|)
argument_list|,
name|Entity
operator|::
name|createLiteral
argument_list|(
name|QLatin1String
argument_list|(
literal|"\""
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|init
name|void
name|QXmlStreamReaderPrivate
operator|::
name|init
parameter_list|()
block|{
name|scanDtd
operator|=
literal|false
expr_stmt|;
name|token
operator|=
operator|-
literal|1
expr_stmt|;
name|token_char
operator|=
literal|0
expr_stmt|;
name|isEmptyElement
operator|=
literal|false
expr_stmt|;
name|isWhitespace
operator|=
literal|true
expr_stmt|;
name|isCDATA
operator|=
literal|false
expr_stmt|;
name|standalone
operator|=
literal|false
expr_stmt|;
name|tos
operator|=
literal|0
expr_stmt|;
name|resumeReduction
operator|=
literal|0
expr_stmt|;
name|state_stack
index|[
name|tos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|state_stack
index|[
name|tos
index|]
operator|=
literal|0
expr_stmt|;
name|putStack
operator|.
name|clear
argument_list|()
expr_stmt|;
name|putStack
operator|.
name|reserve
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|textBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|textBuffer
operator|.
name|reserve
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|tagStack
operator|.
name|clear
argument_list|()
expr_stmt|;
name|tagsDone
operator|=
literal|false
expr_stmt|;
name|attributes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|attributes
operator|.
name|reserve
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|lineNumber
operator|=
name|lastLineStart
operator|=
name|characterOffset
operator|=
literal|0
expr_stmt|;
name|readBufferPos
operator|=
literal|0
expr_stmt|;
name|nbytesread
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|codec
operator|=
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
literal|106
argument_list|)
expr_stmt|;
comment|// utf8
operator|delete
name|decoder
expr_stmt|;
name|decoder
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|attributeStack
operator|.
name|clear
argument_list|()
expr_stmt|;
name|attributeStack
operator|.
name|reserve
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|entityParser
operator|=
literal|0
expr_stmt|;
name|hasCheckedStartDocument
operator|=
literal|false
expr_stmt|;
name|normalizeLiterals
operator|=
literal|false
expr_stmt|;
name|hasSeenTag
operator|=
literal|false
expr_stmt|;
name|atEnd
operator|=
literal|false
expr_stmt|;
name|inParseEntity
operator|=
literal|false
expr_stmt|;
name|referenceToUnparsedEntityDetected
operator|=
literal|false
expr_stmt|;
name|referenceToParameterEntityDetected
operator|=
literal|false
expr_stmt|;
name|hasExternalDtdSubset
operator|=
literal|false
expr_stmt|;
name|lockEncoding
operator|=
literal|false
expr_stmt|;
name|namespaceProcessing
operator|=
literal|true
expr_stmt|;
name|rawReadBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|dataBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|readBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|tagStackStringStorageSize
operator|=
name|initialTagStackStringStorageSize
expr_stmt|;
name|type
operator|=
name|QXmlStreamReader
operator|::
name|NoToken
expr_stmt|;
name|error
operator|=
name|QXmlStreamReader
operator|::
name|NoError
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   Well-formed requires that we verify entity values. We do this with a   standard parser.  */
end_comment
begin_function
DECL|function|parseEntity
name|void
name|QXmlStreamReaderPrivate
operator|::
name|parseEntity
parameter_list|(
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|entityParser
condition|)
name|entityParser
operator|=
operator|new
name|QXmlStreamReaderPrivate
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
name|entityParser
operator|->
name|init
argument_list|()
expr_stmt|;
name|entityParser
operator|->
name|inParseEntity
operator|=
literal|true
expr_stmt|;
name|entityParser
operator|->
name|readBuffer
operator|=
name|value
expr_stmt|;
name|entityParser
operator|->
name|injectToken
argument_list|(
name|PARSE_ENTITY
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|entityParser
operator|->
name|atEnd
operator|&&
name|entityParser
operator|->
name|type
operator|!=
name|QXmlStreamReader
operator|::
name|Invalid
condition|)
name|entityParser
operator|->
name|parse
argument_list|()
expr_stmt|;
if|if
condition|(
name|entityParser
operator|->
name|type
operator|==
name|QXmlStreamReader
operator|::
name|Invalid
operator|||
name|entityParser
operator|->
name|tagStack
operator|.
name|size
argument_list|()
condition|)
name|raiseWellFormedError
argument_list|(
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Invalid entity value."
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reallocateStack
specifier|inline
name|void
name|QXmlStreamReaderPrivate
operator|::
name|reallocateStack
parameter_list|()
block|{
name|stack_size
operator|<<=
literal|1
expr_stmt|;
name|sym_stack
operator|=
cast|reinterpret_cast
argument_list|<
name|Value
operator|*
argument_list|>
argument_list|(
name|realloc
argument_list|(
name|sym_stack
argument_list|,
name|stack_size
operator|*
sizeof|sizeof
argument_list|(
name|Value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|sym_stack
argument_list|)
expr_stmt|;
name|state_stack
operator|=
cast|reinterpret_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|realloc
argument_list|(
name|state_stack
argument_list|,
name|stack_size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Q_CHECK_PTR
argument_list|(
name|sym_stack
argument_list|)
expr_stmt|;
block|}
end_function
begin_destructor
DECL|function|~QXmlStreamReaderPrivate
name|QXmlStreamReaderPrivate
operator|::
name|~
name|QXmlStreamReaderPrivate
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
operator|delete
name|decoder
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|sym_stack
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state_stack
argument_list|)
expr_stmt|;
operator|delete
name|entityParser
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|filterCarriageReturn
specifier|inline
name|uint
name|QXmlStreamReaderPrivate
operator|::
name|filterCarriageReturn
parameter_list|()
block|{
name|uint
name|peekc
init|=
name|peekChar
argument_list|()
decl_stmt|;
if|if
condition|(
name|peekc
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|putStack
operator|.
name|size
argument_list|()
condition|)
name|putStack
operator|.
name|pop
argument_list|()
expr_stmt|;
else|else
operator|++
name|readBufferPos
expr_stmt|;
return|return
name|peekc
return|;
block|}
if|if
condition|(
name|peekc
operator|==
name|StreamEOF
condition|)
block|{
name|putChar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|'\n'
return|;
block|}
end_function
begin_comment
comment|/*!  \internal  If the end of the file is encountered, ~0 is returned.  */
end_comment
begin_function
DECL|function|getChar
specifier|inline
name|uint
name|QXmlStreamReaderPrivate
operator|::
name|getChar
parameter_list|()
block|{
name|uint
name|c
decl_stmt|;
if|if
condition|(
name|putStack
operator|.
name|size
argument_list|()
condition|)
block|{
name|c
operator|=
name|atEnd
condition|?
name|StreamEOF
else|:
name|putStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|readBufferPos
operator|<
name|readBuffer
operator|.
name|size
argument_list|()
condition|)
name|c
operator|=
name|readBuffer
operator|.
name|at
argument_list|(
name|readBufferPos
operator|++
argument_list|)
operator|.
name|unicode
argument_list|()
expr_stmt|;
else|else
name|c
operator|=
name|getChar_helper
argument_list|()
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|peekChar
specifier|inline
name|uint
name|QXmlStreamReaderPrivate
operator|::
name|peekChar
parameter_list|()
block|{
name|uint
name|c
decl_stmt|;
if|if
condition|(
name|putStack
operator|.
name|size
argument_list|()
condition|)
block|{
name|c
operator|=
name|putStack
operator|.
name|top
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readBufferPos
operator|<
name|readBuffer
operator|.
name|size
argument_list|()
condition|)
block|{
name|c
operator|=
name|readBuffer
operator|.
name|at
argument_list|(
name|readBufferPos
argument_list|)
operator|.
name|unicode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getChar_helper
argument_list|()
operator|)
operator|!=
name|StreamEOF
condition|)
operator|--
name|readBufferPos
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Scans characters until \a str is encountered, and validates the characters   as according to the Char[2] production and do the line-ending normalization.   If any character is invalid, false is returned, otherwise true upon success.    If \a tokenToInject is not less than zero, injectToken() is called with   \a tokenToInject when \a str is found.    If any error occurred, false is returned, otherwise true.   */
end_comment
begin_function
DECL|function|scanUntil
name|bool
name|QXmlStreamReaderPrivate
operator|::
name|scanUntil
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|short
name|tokenToInject
parameter_list|)
block|{
name|int
name|pos
init|=
name|textBuffer
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|oldLineNumber
init|=
name|lineNumber
decl_stmt|;
name|uint
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getChar
argument_list|()
operator|)
operator|!=
name|StreamEOF
condition|)
block|{
comment|/* First, we do the validation& normalization. */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\r'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|filterCarriageReturn
argument_list|()
operator|)
operator|==
literal|0
condition|)
break|break;
comment|// fall through
case|case
literal|'\n'
case|:
operator|++
name|lineNumber
expr_stmt|;
name|lastLineStart
operator|=
name|characterOffset
operator|+
name|readBufferPos
expr_stmt|;
comment|// fall through
case|case
literal|'\t'
case|:
name|textBuffer
operator|+=
name|QChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
name|c
argument_list|<
literal|0x20
operator|||
operator|(
name|c
operator|>
literal|0xFFFD
operator|&&
name|c
operator|<
literal|0x10000
operator|)
operator|||
name|c
argument_list|>
name|QChar
operator|::
name|LastValidCodePoint
condition|)
block|{
name|raiseWellFormedError
argument_list|(
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Invalid XML character."
argument_list|)
argument_list|)
expr_stmt|;
name|lineNumber
operator|=
name|oldLineNumber
expr_stmt|;
return|return
literal|false
return|;
block|}
name|textBuffer
operator|+=
name|QChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Second, attempt to lookup str. */
if|if
condition|(
name|c
operator|==
name|uint
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|tokenToInject
operator|>=
literal|0
condition|)
name|injectToken
argument_list|(
name|tokenToInject
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|scanString
argument_list|(
name|str
operator|+
literal|1
argument_list|,
name|tokenToInject
argument_list|,
literal|false
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
block|}
name|putString
argument_list|(
name|textBuffer
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|textBuffer
operator|.
name|resize
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|lineNumber
operator|=
name|oldLineNumber
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|scanString
name|bool
name|QXmlStreamReaderPrivate
operator|::
name|scanString
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|short
name|tokenToInject
parameter_list|,
name|bool
name|requireSpace
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|str
index|[
name|n
index|]
condition|)
block|{
name|uint
name|c
init|=
name|getChar
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|ushort
argument_list|(
name|str
index|[
name|n
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|StreamEOF
condition|)
name|putChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|putChar
argument_list|(
name|ushort
argument_list|(
name|str
index|[
name|n
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
operator|++
name|n
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|textBuffer
operator|+=
name|QChar
argument_list|(
name|ushort
argument_list|(
name|str
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|requireSpace
condition|)
block|{
name|int
name|s
init|=
name|fastScanSpace
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
name|atEnd
condition|)
block|{
name|int
name|pos
init|=
name|textBuffer
operator|.
name|size
argument_list|()
operator|-
name|n
operator|-
name|s
decl_stmt|;
name|putString
argument_list|(
name|textBuffer
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|textBuffer
operator|.
name|resize
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|tokenToInject
operator|>=
literal|0
condition|)
name|injectToken
argument_list|(
name|tokenToInject
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|scanAfterLangleBang
name|bool
name|QXmlStreamReaderPrivate
operator|::
name|scanAfterLangleBang
parameter_list|()
block|{
switch|switch
condition|(
name|peekChar
argument_list|()
condition|)
block|{
case|case
literal|'['
case|:
return|return
name|scanString
argument_list|(
name|spell
index|[
name|CDATA_START
index|]
argument_list|,
name|CDATA_START
argument_list|,
literal|false
argument_list|)
return|;
case|case
literal|'D'
case|:
return|return
name|scanString
argument_list|(
name|spell
index|[
name|DOCTYPE
index|]
argument_list|,
name|DOCTYPE
argument_list|)
return|;
case|case
literal|'A'
case|:
return|return
name|scanString
argument_list|(
name|spell
index|[
name|ATTLIST
index|]
argument_list|,
name|ATTLIST
argument_list|)
return|;
case|case
literal|'N'
case|:
return|return
name|scanString
argument_list|(
name|spell
index|[
name|NOTATION
index|]
argument_list|,
name|NOTATION
argument_list|)
return|;
case|case
literal|'E'
case|:
if|if
condition|(
name|scanString
argument_list|(
name|spell
index|[
name|ELEMENT
index|]
argument_list|,
name|ELEMENT
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
name|scanString
argument_list|(
name|spell
index|[
name|ENTITY
index|]
argument_list|,
name|ENTITY
argument_list|)
return|;
default|default:
empty_stmt|;
block|}
empty_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|scanPublicOrSystem
name|bool
name|QXmlStreamReaderPrivate
operator|::
name|scanPublicOrSystem
parameter_list|()
block|{
switch|switch
condition|(
name|peekChar
argument_list|()
condition|)
block|{
case|case
literal|'S'
case|:
return|return
name|scanString
argument_list|(
name|spell
index|[
name|SYSTEM
index|]
argument_list|,
name|SYSTEM
argument_list|)
return|;
case|case
literal|'P'
case|:
return|return
name|scanString
argument_list|(
name|spell
index|[
name|PUBLIC
index|]
argument_list|,
name|PUBLIC
argument_list|)
return|;
default|default:
empty_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|scanNData
name|bool
name|QXmlStreamReaderPrivate
operator|::
name|scanNData
parameter_list|()
block|{
if|if
condition|(
name|fastScanSpace
argument_list|()
condition|)
block|{
if|if
condition|(
name|scanString
argument_list|(
name|spell
index|[
name|NDATA
index|]
argument_list|,
name|NDATA
argument_list|)
condition|)
return|return
literal|true
return|;
name|putChar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|scanAfterDefaultDecl
name|bool
name|QXmlStreamReaderPrivate
operator|::
name|scanAfterDefaultDecl
parameter_list|()
block|{
switch|switch
condition|(
name|peekChar
argument_list|()
condition|)
block|{
case|case
literal|'R'
case|:
return|return
name|scanString
argument_list|(
name|spell
index|[
name|REQUIRED
index|]
argument_list|,
name|REQUIRED
argument_list|,
literal|false
argument_list|)
return|;
case|case
literal|'I'
case|:
return|return
name|scanString
argument_list|(
name|spell
index|[
name|IMPLIED
index|]
argument_list|,
name|IMPLIED
argument_list|,
literal|false
argument_list|)
return|;
case|case
literal|'F'
case|:
return|return
name|scanString
argument_list|(
name|spell
index|[
name|FIXED
index|]
argument_list|,
name|FIXED
argument_list|,
literal|false
argument_list|)
return|;
default|default:
empty_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|scanAttType
name|bool
name|QXmlStreamReaderPrivate
operator|::
name|scanAttType
parameter_list|()
block|{
switch|switch
condition|(
name|peekChar
argument_list|()
condition|)
block|{
case|case
literal|'C'
case|:
return|return
name|scanString
argument_list|(
name|spell
index|[
name|CDATA
index|]
argument_list|,
name|CDATA
argument_list|)
return|;
case|case
literal|'I'
case|:
if|if
condition|(
name|scanString
argument_list|(
name|spell
index|[
name|ID
index|]
argument_list|,
name|ID
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|scanString
argument_list|(
name|spell
index|[
name|IDREF
index|]
argument_list|,
name|IDREF
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
name|scanString
argument_list|(
name|spell
index|[
name|IDREFS
index|]
argument_list|,
name|IDREFS
argument_list|)
return|;
case|case
literal|'E'
case|:
if|if
condition|(
name|scanString
argument_list|(
name|spell
index|[
name|ENTITY
index|]
argument_list|,
name|ENTITY
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
name|scanString
argument_list|(
name|spell
index|[
name|ENTITIES
index|]
argument_list|,
name|ENTITIES
argument_list|)
return|;
case|case
literal|'N'
case|:
if|if
condition|(
name|scanString
argument_list|(
name|spell
index|[
name|NOTATION
index|]
argument_list|,
name|NOTATION
argument_list|)
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|scanString
argument_list|(
name|spell
index|[
name|NMTOKEN
index|]
argument_list|,
name|NMTOKEN
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
name|scanString
argument_list|(
name|spell
index|[
name|NMTOKENS
index|]
argument_list|,
name|NMTOKENS
argument_list|)
return|;
default|default:
empty_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!  \internal   Scan strings with quotes or apostrophes surround them. For instance,  attributes, the version and encoding field in the XML prolog and  entity declarations.   If normalizeLiterals is set to true, the function also normalizes  whitespace. It is set to true when the first start tag is  encountered.   */
end_comment
begin_function
DECL|function|fastScanLiteralContent
specifier|inline
name|int
name|QXmlStreamReaderPrivate
operator|::
name|fastScanLiteralContent
parameter_list|()
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|uint
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getChar
argument_list|()
operator|)
operator|!=
name|StreamEOF
condition|)
block|{
switch|switch
condition|(
name|ushort
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
literal|0xfffe
case|:
case|case
literal|0xffff
case|:
case|case
literal|0
case|:
comment|/* The putChar() call is necessary so the parser re-gets              * the character from the input source, when raising an error. */
name|putChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|n
return|;
case|case
literal|'\r'
case|:
if|if
condition|(
name|filterCarriageReturn
argument_list|()
operator|==
literal|0
condition|)
return|return
name|n
return|;
comment|// fall through
case|case
literal|'\n'
case|:
operator|++
name|lineNumber
expr_stmt|;
name|lastLineStart
operator|=
name|characterOffset
operator|+
name|readBufferPos
expr_stmt|;
comment|// fall through
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
if|if
condition|(
name|normalizeLiterals
condition|)
name|textBuffer
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
else|else
name|textBuffer
operator|+=
name|QChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
case|case
literal|'<'
case|:
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
if|if
condition|(
operator|!
operator|(
name|c
operator|&
literal|0xff0000
operator|)
condition|)
block|{
name|putChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
comment|// fall through
default|default:
name|textBuffer
operator|+=
name|QChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
return|return
name|n
return|;
block|}
end_function
begin_function
DECL|function|fastScanSpace
specifier|inline
name|int
name|QXmlStreamReaderPrivate
operator|::
name|fastScanSpace
parameter_list|()
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|uint
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getChar
argument_list|()
operator|)
operator|!=
name|StreamEOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\r'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|filterCarriageReturn
argument_list|()
operator|)
operator|==
literal|0
condition|)
return|return
name|n
return|;
comment|// fall through
case|case
literal|'\n'
case|:
operator|++
name|lineNumber
expr_stmt|;
name|lastLineStart
operator|=
name|characterOffset
operator|+
name|readBufferPos
expr_stmt|;
comment|// fall through
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|textBuffer
operator|+=
name|QChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
default|default:
name|putChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*!   \internal    Used for text nodes essentially. That is, characters appearing   inside elements.  */
end_comment
begin_function
DECL|function|fastScanContentCharList
specifier|inline
name|int
name|QXmlStreamReaderPrivate
operator|::
name|fastScanContentCharList
parameter_list|()
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|uint
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getChar
argument_list|()
operator|)
operator|!=
name|StreamEOF
condition|)
block|{
switch|switch
condition|(
name|ushort
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
literal|0xfffe
case|:
case|case
literal|0xffff
case|:
case|case
literal|0
case|:
name|putChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|n
return|;
case|case
literal|']'
case|:
block|{
name|isWhitespace
operator|=
literal|false
expr_stmt|;
name|int
name|pos
init|=
name|textBuffer
operator|.
name|size
argument_list|()
decl_stmt|;
name|textBuffer
operator|+=
name|QChar
argument_list|(
name|ushort
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getChar
argument_list|()
operator|)
operator|==
literal|']'
condition|)
block|{
name|textBuffer
operator|+=
name|QChar
argument_list|(
name|ushort
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|putString
argument_list|(
name|textBuffer
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|textBuffer
operator|.
name|resize
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
operator|&&
name|textBuffer
operator|.
name|at
argument_list|(
name|textBuffer
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
name|raiseWellFormedError
argument_list|(
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Sequence ']]>' not allowed in content."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|n
return|;
block|}
break|break;
case|case
literal|'\r'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|filterCarriageReturn
argument_list|()
operator|)
operator|==
literal|0
condition|)
return|return
name|n
return|;
comment|// fall through
case|case
literal|'\n'
case|:
operator|++
name|lineNumber
expr_stmt|;
name|lastLineStart
operator|=
name|characterOffset
operator|+
name|readBufferPos
expr_stmt|;
comment|// fall through
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|textBuffer
operator|+=
name|QChar
argument_list|(
name|ushort
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
case|case
literal|'<'
case|:
if|if
condition|(
operator|!
operator|(
name|c
operator|&
literal|0xff0000
operator|)
condition|)
block|{
name|putChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
comment|// fall through
default|default:
if|if
condition|(
name|c
operator|<
literal|0x20
condition|)
block|{
name|putChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
name|isWhitespace
operator|=
literal|false
expr_stmt|;
name|textBuffer
operator|+=
name|QChar
argument_list|(
name|ushort
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
return|return
name|n
return|;
block|}
end_function
begin_function
DECL|function|fastScanName
specifier|inline
name|int
name|QXmlStreamReaderPrivate
operator|::
name|fastScanName
parameter_list|(
name|int
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|uint
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getChar
argument_list|()
operator|)
operator|!=
name|StreamEOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'&'
case|:
case|case
literal|'#'
case|:
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'='
case|:
case|case
literal|'%'
case|:
case|case
literal|'/'
case|:
case|case
literal|';'
case|:
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'^'
case|:
case|case
literal|'|'
case|:
case|case
literal|','
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
name|putChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|&&
operator|*
name|prefix
operator|==
name|n
operator|+
literal|1
condition|)
block|{
operator|*
name|prefix
operator|=
literal|0
expr_stmt|;
name|putChar
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
operator|--
name|n
expr_stmt|;
block|}
return|return
name|n
return|;
case|case
literal|':'
case|:
if|if
condition|(
name|prefix
condition|)
block|{
if|if
condition|(
operator|*
name|prefix
operator|==
literal|0
condition|)
block|{
operator|*
name|prefix
operator|=
name|n
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|// only one colon allowed according to the namespace spec.
name|putChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
else|else
block|{
name|putChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
comment|// fall through
default|default:
name|textBuffer
operator|+=
name|QChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prefix
condition|)
operator|*
name|prefix
operator|=
literal|0
expr_stmt|;
name|int
name|pos
init|=
name|textBuffer
operator|.
name|size
argument_list|()
operator|-
name|n
decl_stmt|;
name|putString
argument_list|(
name|textBuffer
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|textBuffer
operator|.
name|resize
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_enum
DECL|enum|NameChar
DECL|enumerator|NameBeginning
DECL|enumerator|NameNotBeginning
DECL|enumerator|NotName
enum|enum
name|NameChar
block|{
name|NameBeginning
block|,
name|NameNotBeginning
block|,
name|NotName
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|Begi
specifier|static
specifier|const
name|char
name|Begi
init|=
cast|static_cast
argument_list|<
name|char
argument_list|>
argument_list|(
name|NameBeginning
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|NtBg
specifier|static
specifier|const
name|char
name|NtBg
init|=
cast|static_cast
argument_list|<
name|char
argument_list|>
argument_list|(
name|NameNotBeginning
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|NotN
specifier|static
specifier|const
name|char
name|NotN
init|=
cast|static_cast
argument_list|<
name|char
argument_list|>
argument_list|(
name|NotName
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|nameCharTable
specifier|static
specifier|const
name|char
name|nameCharTable
index|[
literal|128
index|]
init|=
block|{
comment|// 0x00
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
comment|// 0x10
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
comment|// 0x20 (0x2D is '-', 0x2E is '.')
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NotN
block|,
comment|// 0x30 (0x30..0x39 are '0'..'9', 0x3A is ':')
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|NtBg
block|,
name|Begi
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
comment|// 0x40 (0x41..0x5A are 'A'..'Z')
name|NotN
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
comment|// 0x50 (0x5F is '_')
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|Begi
block|,
comment|// 0x60 (0x61..0x7A are 'a'..'z')
name|NotN
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
comment|// 0x70
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|Begi
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|,
name|NotN
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|fastDetermineNameChar
specifier|static
specifier|inline
name|NameChar
name|fastDetermineNameChar
parameter_list|(
name|QChar
name|ch
parameter_list|)
block|{
name|ushort
name|uc
init|=
name|ch
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|uc
operator|&
operator|~
literal|0x7f
operator|)
condition|)
comment|// uc< 128
return|return
cast|static_cast
argument_list|<
name|NameChar
argument_list|>
argument_list|(
name|nameCharTable
index|[
name|uc
index|]
argument_list|)
return|;
name|QChar
operator|::
name|Category
name|cat
init|=
name|ch
operator|.
name|category
argument_list|()
decl_stmt|;
comment|// ### some these categories might be slightly wrong
if|if
condition|(
operator|(
name|cat
operator|>=
name|QChar
operator|::
name|Letter_Uppercase
operator|&&
name|cat
operator|<=
name|QChar
operator|::
name|Letter_Other
operator|)
operator|||
name|cat
operator|==
name|QChar
operator|::
name|Number_Letter
condition|)
return|return
name|NameBeginning
return|;
if|if
condition|(
operator|(
name|cat
operator|>=
name|QChar
operator|::
name|Number_DecimalDigit
operator|&&
name|cat
operator|<=
name|QChar
operator|::
name|Number_Other
operator|)
operator|||
operator|(
name|cat
operator|>=
name|QChar
operator|::
name|Mark_NonSpacing
operator|&&
name|cat
operator|<=
name|QChar
operator|::
name|Mark_Enclosing
operator|)
condition|)
return|return
name|NameNotBeginning
return|;
return|return
name|NotName
return|;
block|}
end_function
begin_function
DECL|function|fastScanNMTOKEN
specifier|inline
name|int
name|QXmlStreamReaderPrivate
operator|::
name|fastScanNMTOKEN
parameter_list|()
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|uint
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getChar
argument_list|()
operator|)
operator|!=
name|StreamEOF
condition|)
block|{
if|if
condition|(
name|fastDetermineNameChar
argument_list|(
name|c
argument_list|)
operator|==
name|NotName
condition|)
block|{
name|putChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
else|else
block|{
operator|++
name|n
expr_stmt|;
name|textBuffer
operator|+=
name|QChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|pos
init|=
name|textBuffer
operator|.
name|size
argument_list|()
operator|-
name|n
decl_stmt|;
name|putString
argument_list|(
name|textBuffer
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|textBuffer
operator|.
name|resize
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_function
DECL|function|putString
name|void
name|QXmlStreamReaderPrivate
operator|::
name|putString
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|putStack
operator|.
name|reserve
argument_list|(
name|s
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|s
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
name|from
condition|;
operator|--
name|i
control|)
name|putStack
operator|.
name|rawPush
argument_list|()
operator|=
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|putStringLiteral
name|void
name|QXmlStreamReaderPrivate
operator|::
name|putStringLiteral
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
name|putStack
operator|.
name|reserve
argument_list|(
name|s
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|s
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|putStack
operator|.
name|rawPush
argument_list|()
operator|=
operator|(
operator|(
name|LETTER
operator|<<
literal|16
operator|)
operator||
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
operator|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|putReplacement
name|void
name|QXmlStreamReaderPrivate
operator|::
name|putReplacement
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
name|putStack
operator|.
name|reserve
argument_list|(
name|s
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|s
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|ushort
name|c
init|=
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
condition|)
name|putStack
operator|.
name|rawPush
argument_list|()
operator|=
operator|(
operator|(
name|LETTER
operator|<<
literal|16
operator|)
operator||
name|c
operator|)
expr_stmt|;
else|else
name|putStack
operator|.
name|rawPush
argument_list|()
operator|=
name|c
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|putReplacementInAttributeValue
name|void
name|QXmlStreamReaderPrivate
operator|::
name|putReplacementInAttributeValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
name|putStack
operator|.
name|reserve
argument_list|(
name|s
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|s
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|ushort
name|c
init|=
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'&'
operator|||
name|c
operator|==
literal|';'
condition|)
name|putStack
operator|.
name|rawPush
argument_list|()
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
condition|)
name|putStack
operator|.
name|rawPush
argument_list|()
operator|=
literal|' '
expr_stmt|;
else|else
name|putStack
operator|.
name|rawPush
argument_list|()
operator|=
operator|(
operator|(
name|LETTER
operator|<<
literal|16
operator|)
operator||
name|c
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|getChar_helper
name|uint
name|QXmlStreamReaderPrivate
operator|::
name|getChar_helper
parameter_list|()
block|{
specifier|const
name|int
name|BUFFER_SIZE
init|=
literal|8192
decl_stmt|;
name|characterOffset
operator|+=
name|readBufferPos
expr_stmt|;
name|readBufferPos
operator|=
literal|0
expr_stmt|;
name|readBuffer
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
if|if
condition|(
name|decoder
condition|)
endif|#
directive|endif
name|nbytesread
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|device
condition|)
block|{
name|rawReadBuffer
operator|.
name|resize
argument_list|(
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
name|int
name|nbytesreadOrMinus1
init|=
name|device
operator|->
name|read
argument_list|(
name|rawReadBuffer
operator|.
name|data
argument_list|()
operator|+
name|nbytesread
argument_list|,
name|BUFFER_SIZE
operator|-
name|nbytesread
argument_list|)
decl_stmt|;
name|nbytesread
operator|+=
name|qMax
argument_list|(
name|nbytesreadOrMinus1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nbytesread
condition|)
name|rawReadBuffer
operator|+=
name|dataBuffer
expr_stmt|;
else|else
name|rawReadBuffer
operator|=
name|dataBuffer
expr_stmt|;
name|nbytesread
operator|=
name|rawReadBuffer
operator|.
name|size
argument_list|()
expr_stmt|;
name|dataBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nbytesread
condition|)
block|{
name|atEnd
operator|=
literal|true
expr_stmt|;
return|return
name|StreamEOF
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
if|if
condition|(
operator|!
name|decoder
condition|)
block|{
if|if
condition|(
name|nbytesread
operator|<
literal|4
condition|)
block|{
comment|// the 4 is to cover 0xef 0xbb 0xbf plus
comment|// one extra for the utf8 codec
name|atEnd
operator|=
literal|true
expr_stmt|;
return|return
name|StreamEOF
return|;
block|}
name|int
name|mib
init|=
literal|106
decl_stmt|;
comment|// UTF-8
comment|// look for byte order mark
name|uchar
name|ch1
init|=
name|rawReadBuffer
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|uchar
name|ch2
init|=
name|rawReadBuffer
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|uchar
name|ch3
init|=
name|rawReadBuffer
operator|.
name|at
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|uchar
name|ch4
init|=
name|rawReadBuffer
operator|.
name|at
argument_list|(
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ch1
operator|==
literal|0
operator|&&
name|ch2
operator|==
literal|0
operator|&&
name|ch3
operator|==
literal|0xfe
operator|&&
name|ch4
operator|==
literal|0xff
operator|)
operator|||
operator|(
name|ch1
operator|==
literal|0xff
operator|&&
name|ch2
operator|==
literal|0xfe
operator|&&
name|ch3
operator|==
literal|0
operator|&&
name|ch4
operator|==
literal|0
operator|)
condition|)
name|mib
operator|=
literal|1017
expr_stmt|;
comment|// UTF-32 with byte order mark
elseif|else
if|if
condition|(
name|ch1
operator|==
literal|0x3c
operator|&&
name|ch2
operator|==
literal|0x00
operator|&&
name|ch3
operator|==
literal|0x00
operator|&&
name|ch4
operator|==
literal|0x00
condition|)
name|mib
operator|=
literal|1019
expr_stmt|;
comment|// UTF-32LE
elseif|else
if|if
condition|(
name|ch1
operator|==
literal|0x00
operator|&&
name|ch2
operator|==
literal|0x00
operator|&&
name|ch3
operator|==
literal|0x00
operator|&&
name|ch4
operator|==
literal|0x3c
condition|)
name|mib
operator|=
literal|1018
expr_stmt|;
comment|// UTF-32BE
elseif|else
if|if
condition|(
operator|(
name|ch1
operator|==
literal|0xfe
operator|&&
name|ch2
operator|==
literal|0xff
operator|)
operator|||
operator|(
name|ch1
operator|==
literal|0xff
operator|&&
name|ch2
operator|==
literal|0xfe
operator|)
condition|)
name|mib
operator|=
literal|1015
expr_stmt|;
comment|// UTF-16 with byte order mark
elseif|else
if|if
condition|(
name|ch1
operator|==
literal|0x3c
operator|&&
name|ch2
operator|==
literal|0x00
condition|)
name|mib
operator|=
literal|1014
expr_stmt|;
comment|// UTF-16LE
elseif|else
if|if
condition|(
name|ch1
operator|==
literal|0x00
operator|&&
name|ch2
operator|==
literal|0x3c
condition|)
name|mib
operator|=
literal|1013
expr_stmt|;
comment|// UTF-16BE
name|codec
operator|=
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
name|mib
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|decoder
operator|=
name|codec
operator|->
name|makeDecoder
argument_list|()
expr_stmt|;
block|}
name|decoder
operator|->
name|toUnicode
argument_list|(
operator|&
name|readBuffer
argument_list|,
name|rawReadBuffer
operator|.
name|constData
argument_list|()
argument_list|,
name|nbytesread
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockEncoding
operator|&&
name|decoder
operator|->
name|hasFailure
argument_list|()
condition|)
block|{
name|raiseWellFormedError
argument_list|(
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Encountered incorrectly encoded content."
argument_list|)
argument_list|)
expr_stmt|;
name|readBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|StreamEOF
return|;
block|}
else|#
directive|else
name|readBuffer
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|rawReadBuffer
operator|.
name|data
argument_list|()
argument_list|,
name|nbytesread
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_TEXTCODEC
name|readBuffer
operator|.
name|reserve
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// keep capacity when calling resize() next time
if|if
condition|(
name|readBufferPos
operator|<
name|readBuffer
operator|.
name|size
argument_list|()
condition|)
block|{
name|ushort
name|c
init|=
name|readBuffer
operator|.
name|at
argument_list|(
name|readBufferPos
operator|++
argument_list|)
operator|.
name|unicode
argument_list|()
decl_stmt|;
return|return
name|c
return|;
block|}
name|atEnd
operator|=
literal|true
expr_stmt|;
return|return
name|StreamEOF
return|;
block|}
end_function
begin_function
DECL|function|namespaceForPrefix
name|QStringRef
name|QXmlStreamReaderPrivate
operator|::
name|namespaceForPrefix
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|prefix
parameter_list|)
block|{
for|for
control|(
name|int
name|j
init|=
name|namespaceDeclarations
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
specifier|const
name|NamespaceDeclaration
modifier|&
name|namespaceDeclaration
init|=
name|namespaceDeclarations
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|namespaceDeclaration
operator|.
name|prefix
operator|==
name|prefix
condition|)
block|{
return|return
name|namespaceDeclaration
operator|.
name|namespaceUri
return|;
block|}
block|}
if|#
directive|if
literal|1
if|if
condition|(
name|namespaceProcessing
operator|&&
operator|!
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
name|raiseWellFormedError
argument_list|(
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Namespace prefix '%1' not declared"
argument_list|)
operator|.
name|arg
argument_list|(
name|prefix
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|QStringRef
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*   uses namespaceForPrefix and builds the attribute vector  */
end_comment
begin_function
DECL|function|resolveTag
name|void
name|QXmlStreamReaderPrivate
operator|::
name|resolveTag
parameter_list|()
block|{
name|int
name|n
init|=
name|attributeStack
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|namespaceProcessing
condition|)
block|{
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|dtdAttributes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|a
control|)
block|{
name|DtdAttribute
modifier|&
name|dtdAttribute
init|=
name|dtdAttributes
index|[
name|a
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|dtdAttribute
operator|.
name|isNamespaceAttribute
operator|||
name|dtdAttribute
operator|.
name|defaultValue
operator|.
name|isNull
argument_list|()
operator|||
name|dtdAttribute
operator|.
name|tagName
operator|!=
name|qualifiedName
operator|||
name|dtdAttribute
operator|.
name|attributeQualifiedName
operator|.
name|isNull
argument_list|()
condition|)
continue|continue;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|n
operator|&&
name|symName
argument_list|(
name|attributeStack
index|[
name|i
index|]
operator|.
name|key
argument_list|)
operator|!=
name|dtdAttribute
operator|.
name|attributeQualifiedName
condition|)
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|n
condition|)
continue|continue;
if|if
condition|(
name|dtdAttribute
operator|.
name|attributePrefix
operator|.
name|isEmpty
argument_list|()
operator|&&
name|dtdAttribute
operator|.
name|attributeName
operator|==
name|QLatin1String
argument_list|(
literal|"xmlns"
argument_list|)
condition|)
block|{
name|NamespaceDeclaration
modifier|&
name|namespaceDeclaration
init|=
name|namespaceDeclarations
operator|.
name|push
argument_list|()
decl_stmt|;
name|namespaceDeclaration
operator|.
name|prefix
operator|.
name|clear
argument_list|()
expr_stmt|;
specifier|const
name|QStringRef
name|ns
argument_list|(
name|dtdAttribute
operator|.
name|defaultValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|==
name|QLatin1String
argument_list|(
literal|"http://www.w3.org/2000/xmlns/"
argument_list|)
operator|||
name|ns
operator|==
name|QLatin1String
argument_list|(
literal|"http://www.w3.org/XML/1998/namespace"
argument_list|)
condition|)
name|raiseWellFormedError
argument_list|(
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Illegal namespace declaration."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|namespaceDeclaration
operator|.
name|namespaceUri
operator|=
name|ns
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtdAttribute
operator|.
name|attributePrefix
operator|==
name|QLatin1String
argument_list|(
literal|"xmlns"
argument_list|)
condition|)
block|{
name|NamespaceDeclaration
modifier|&
name|namespaceDeclaration
init|=
name|namespaceDeclarations
operator|.
name|push
argument_list|()
decl_stmt|;
name|QStringRef
name|namespacePrefix
init|=
name|dtdAttribute
operator|.
name|attributeName
decl_stmt|;
name|QStringRef
name|namespaceUri
init|=
name|dtdAttribute
operator|.
name|defaultValue
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|namespacePrefix
operator|==
name|QLatin1String
argument_list|(
literal|"xml"
argument_list|)
operator|)
operator|^
operator|(
name|namespaceUri
operator|==
name|QLatin1String
argument_list|(
literal|"http://www.w3.org/XML/1998/namespace"
argument_list|)
operator|)
operator|)
operator|||
name|namespaceUri
operator|==
name|QLatin1String
argument_list|(
literal|"http://www.w3.org/2000/xmlns/"
argument_list|)
operator|||
name|namespaceUri
operator|.
name|isEmpty
argument_list|()
operator|||
name|namespacePrefix
operator|==
name|QLatin1String
argument_list|(
literal|"xmlns"
argument_list|)
condition|)
name|raiseWellFormedError
argument_list|(
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Illegal namespace declaration."
argument_list|)
argument_list|)
expr_stmt|;
name|namespaceDeclaration
operator|.
name|prefix
operator|=
name|namespacePrefix
expr_stmt|;
name|namespaceDeclaration
operator|.
name|namespaceUri
operator|=
name|namespaceUri
expr_stmt|;
block|}
block|}
block|}
name|tagStack
operator|.
name|top
argument_list|()
operator|.
name|namespaceDeclaration
operator|.
name|namespaceUri
operator|=
name|namespaceUri
operator|=
name|namespaceForPrefix
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|attributes
operator|.
name|resize
argument_list|(
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|QXmlStreamAttribute
modifier|&
name|attribute
init|=
name|attributes
index|[
name|i
index|]
decl_stmt|;
name|Attribute
modifier|&
name|attrib
init|=
name|attributeStack
index|[
name|i
index|]
decl_stmt|;
name|QStringRef
name|prefix
argument_list|(
name|symPrefix
argument_list|(
name|attrib
operator|.
name|key
argument_list|)
argument_list|)
decl_stmt|;
name|QStringRef
name|name
argument_list|(
name|symString
argument_list|(
name|attrib
operator|.
name|key
argument_list|)
argument_list|)
decl_stmt|;
name|QStringRef
name|qualifiedName
argument_list|(
name|symName
argument_list|(
name|attrib
operator|.
name|key
argument_list|)
argument_list|)
decl_stmt|;
name|QStringRef
name|value
argument_list|(
name|symString
argument_list|(
name|attrib
operator|.
name|value
argument_list|)
argument_list|)
decl_stmt|;
name|attribute
operator|.
name|m_name
operator|=
name|QXmlStreamStringRef
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|attribute
operator|.
name|m_qualifiedName
operator|=
name|QXmlStreamStringRef
argument_list|(
name|qualifiedName
argument_list|)
expr_stmt|;
name|attribute
operator|.
name|m_value
operator|=
name|QXmlStreamStringRef
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringRef
name|attributeNamespaceUri
init|=
name|namespaceForPrefix
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
name|attribute
operator|.
name|m_namespaceUri
operator|=
name|QXmlStreamStringRef
argument_list|(
name|attributeNamespaceUri
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|attributes
index|[
name|j
index|]
operator|.
name|name
argument_list|()
operator|==
name|attribute
operator|.
name|name
argument_list|()
operator|&&
name|attributes
index|[
name|j
index|]
operator|.
name|namespaceUri
argument_list|()
operator|==
name|attribute
operator|.
name|namespaceUri
argument_list|()
operator|&&
operator|(
name|namespaceProcessing
operator|||
name|attributes
index|[
name|j
index|]
operator|.
name|qualifiedName
argument_list|()
operator|==
name|attribute
operator|.
name|qualifiedName
argument_list|()
operator|)
condition|)
name|raiseWellFormedError
argument_list|(
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Attribute '%1' redefined."
argument_list|)
operator|.
name|arg
argument_list|(
name|attribute
operator|.
name|qualifiedName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|dtdAttributes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|a
control|)
block|{
name|DtdAttribute
modifier|&
name|dtdAttribute
init|=
name|dtdAttributes
index|[
name|a
index|]
decl_stmt|;
if|if
condition|(
name|dtdAttribute
operator|.
name|isNamespaceAttribute
operator|||
name|dtdAttribute
operator|.
name|defaultValue
operator|.
name|isNull
argument_list|()
operator|||
name|dtdAttribute
operator|.
name|tagName
operator|!=
name|qualifiedName
operator|||
name|dtdAttribute
operator|.
name|attributeQualifiedName
operator|.
name|isNull
argument_list|()
condition|)
continue|continue;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|n
operator|&&
name|symName
argument_list|(
name|attributeStack
index|[
name|i
index|]
operator|.
name|key
argument_list|)
operator|!=
name|dtdAttribute
operator|.
name|attributeQualifiedName
condition|)
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|n
condition|)
continue|continue;
name|QXmlStreamAttribute
name|attribute
decl_stmt|;
name|attribute
operator|.
name|m_name
operator|=
name|QXmlStreamStringRef
argument_list|(
name|dtdAttribute
operator|.
name|attributeName
argument_list|)
expr_stmt|;
name|attribute
operator|.
name|m_qualifiedName
operator|=
name|QXmlStreamStringRef
argument_list|(
name|dtdAttribute
operator|.
name|attributeQualifiedName
argument_list|)
expr_stmt|;
name|attribute
operator|.
name|m_value
operator|=
name|QXmlStreamStringRef
argument_list|(
name|dtdAttribute
operator|.
name|defaultValue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dtdAttribute
operator|.
name|attributePrefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QStringRef
name|attributeNamespaceUri
init|=
name|namespaceForPrefix
argument_list|(
name|dtdAttribute
operator|.
name|attributePrefix
argument_list|)
decl_stmt|;
name|attribute
operator|.
name|m_namespaceUri
operator|=
name|QXmlStreamStringRef
argument_list|(
name|attributeNamespaceUri
argument_list|)
expr_stmt|;
block|}
name|attribute
operator|.
name|m_isDefault
operator|=
literal|true
expr_stmt|;
name|attributes
operator|.
name|append
argument_list|(
name|attribute
argument_list|)
expr_stmt|;
block|}
name|attributeStack
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resolvePublicNamespaces
name|void
name|QXmlStreamReaderPrivate
operator|::
name|resolvePublicNamespaces
parameter_list|()
block|{
specifier|const
name|Tag
modifier|&
name|tag
init|=
name|tagStack
operator|.
name|top
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|namespaceDeclarations
operator|.
name|size
argument_list|()
operator|-
name|tag
operator|.
name|namespaceDeclarationsSize
decl_stmt|;
name|publicNamespaceDeclarations
operator|.
name|resize
argument_list|(
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|NamespaceDeclaration
modifier|&
name|namespaceDeclaration
init|=
name|namespaceDeclarations
operator|.
name|at
argument_list|(
name|tag
operator|.
name|namespaceDeclarationsSize
operator|+
name|i
argument_list|)
decl_stmt|;
name|QXmlStreamNamespaceDeclaration
modifier|&
name|publicNamespaceDeclaration
init|=
name|publicNamespaceDeclarations
index|[
name|i
index|]
decl_stmt|;
name|publicNamespaceDeclaration
operator|.
name|m_prefix
operator|=
name|QXmlStreamStringRef
argument_list|(
name|namespaceDeclaration
operator|.
name|prefix
argument_list|)
expr_stmt|;
name|publicNamespaceDeclaration
operator|.
name|m_namespaceUri
operator|=
name|QXmlStreamStringRef
argument_list|(
name|namespaceDeclaration
operator|.
name|namespaceUri
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|resolveDtd
name|void
name|QXmlStreamReaderPrivate
operator|::
name|resolveDtd
parameter_list|()
block|{
name|publicNotationDeclarations
operator|.
name|resize
argument_list|(
name|notationDeclarations
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|notationDeclarations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QXmlStreamReaderPrivate
operator|::
name|NotationDeclaration
modifier|&
name|notationDeclaration
init|=
name|notationDeclarations
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QXmlStreamNotationDeclaration
modifier|&
name|publicNotationDeclaration
init|=
name|publicNotationDeclarations
index|[
name|i
index|]
decl_stmt|;
name|publicNotationDeclaration
operator|.
name|m_name
operator|=
name|QXmlStreamStringRef
argument_list|(
name|notationDeclaration
operator|.
name|name
argument_list|)
expr_stmt|;
name|publicNotationDeclaration
operator|.
name|m_systemId
operator|=
name|QXmlStreamStringRef
argument_list|(
name|notationDeclaration
operator|.
name|systemId
argument_list|)
expr_stmt|;
name|publicNotationDeclaration
operator|.
name|m_publicId
operator|=
name|QXmlStreamStringRef
argument_list|(
name|notationDeclaration
operator|.
name|publicId
argument_list|)
expr_stmt|;
block|}
name|notationDeclarations
operator|.
name|clear
argument_list|()
expr_stmt|;
name|publicEntityDeclarations
operator|.
name|resize
argument_list|(
name|entityDeclarations
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entityDeclarations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QXmlStreamReaderPrivate
operator|::
name|EntityDeclaration
modifier|&
name|entityDeclaration
init|=
name|entityDeclarations
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QXmlStreamEntityDeclaration
modifier|&
name|publicEntityDeclaration
init|=
name|publicEntityDeclarations
index|[
name|i
index|]
decl_stmt|;
name|publicEntityDeclaration
operator|.
name|m_name
operator|=
name|QXmlStreamStringRef
argument_list|(
name|entityDeclaration
operator|.
name|name
argument_list|)
expr_stmt|;
name|publicEntityDeclaration
operator|.
name|m_notationName
operator|=
name|QXmlStreamStringRef
argument_list|(
name|entityDeclaration
operator|.
name|notationName
argument_list|)
expr_stmt|;
name|publicEntityDeclaration
operator|.
name|m_systemId
operator|=
name|QXmlStreamStringRef
argument_list|(
name|entityDeclaration
operator|.
name|systemId
argument_list|)
expr_stmt|;
name|publicEntityDeclaration
operator|.
name|m_publicId
operator|=
name|QXmlStreamStringRef
argument_list|(
name|entityDeclaration
operator|.
name|publicId
argument_list|)
expr_stmt|;
name|publicEntityDeclaration
operator|.
name|m_value
operator|=
name|QXmlStreamStringRef
argument_list|(
name|entityDeclaration
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
name|entityDeclarations
operator|.
name|clear
argument_list|()
expr_stmt|;
name|parameterEntityHash
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resolveCharRef
name|uint
name|QXmlStreamReaderPrivate
operator|::
name|resolveCharRef
parameter_list|(
name|int
name|symbolIndex
parameter_list|)
block|{
name|bool
name|ok
init|=
literal|true
decl_stmt|;
name|uint
name|s
decl_stmt|;
comment|// ### add toXShort to QStringRef?
if|if
condition|(
name|sym
argument_list|(
name|symbolIndex
argument_list|)
operator|.
name|c
operator|==
literal|'x'
condition|)
name|s
operator|=
name|symString
argument_list|(
name|symbolIndex
argument_list|,
literal|1
argument_list|)
operator|.
name|toUInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|symString
argument_list|(
name|symbolIndex
argument_list|)
operator|.
name|toUInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ok
operator|&=
operator|(
name|s
operator|==
literal|0x9
operator|||
name|s
operator|==
literal|0xa
operator|||
name|s
operator|==
literal|0xd
operator|||
operator|(
name|s
operator|>=
literal|0x20
operator|&&
name|s
operator|<=
literal|0xd7ff
operator|)
operator|||
operator|(
name|s
operator|>=
literal|0xe000
operator|&&
name|s
operator|<=
literal|0xfffd
operator|)
operator|||
operator|(
name|s
operator|>=
literal|0x10000
operator|&&
name|s
operator|<=
name|QChar
operator|::
name|LastValidCodePoint
operator|)
operator|)
expr_stmt|;
return|return
name|ok
condition|?
name|s
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|checkPublicLiteral
name|void
name|QXmlStreamReaderPrivate
operator|::
name|checkPublicLiteral
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|publicId
parameter_list|)
block|{
comment|//#x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
specifier|const
name|ushort
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|publicId
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|uchar
name|c
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|publicId
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|data
index|[
name|i
index|]
operator|<
literal|256
condition|)
switch|switch
condition|(
operator|(
name|c
operator|=
name|data
index|[
name|i
index|]
operator|)
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'-'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'+'
case|:
case|case
literal|','
case|:
case|case
literal|'.'
case|:
case|case
literal|'/'
case|:
case|case
literal|':'
case|:
case|case
literal|'='
case|:
case|case
literal|'?'
case|:
case|case
literal|';'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'#'
case|:
case|case
literal|'@'
case|:
case|case
literal|'$'
case|:
case|case
literal|'_'
case|:
case|case
literal|'%'
case|:
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
continue|continue;
default|default:
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
condition|)
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|raiseWellFormedError
argument_list|(
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Unexpected character '%1' in public id literal."
argument_list|)
operator|.
name|arg
argument_list|(
name|QChar
argument_list|(
name|QLatin1Char
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   Checks whether the document starts with an xml declaration. If it   does, this function returns \c true; otherwise it sets up everything   for a synthetic start document event and returns \c false.  */
end_comment
begin_function
DECL|function|checkStartDocument
name|bool
name|QXmlStreamReaderPrivate
operator|::
name|checkStartDocument
parameter_list|()
block|{
name|hasCheckedStartDocument
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|scanString
argument_list|(
name|spell
index|[
name|XML
index|]
argument_list|,
name|XML
argument_list|)
condition|)
return|return
literal|true
return|;
name|type
operator|=
name|QXmlStreamReader
operator|::
name|StartDocument
expr_stmt|;
if|if
condition|(
name|atEnd
condition|)
block|{
name|hasCheckedStartDocument
operator|=
literal|false
expr_stmt|;
name|raiseError
argument_list|(
name|QXmlStreamReader
operator|::
name|PrematureEndOfDocumentError
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|startDocument
name|void
name|QXmlStreamReaderPrivate
operator|::
name|startDocument
parameter_list|()
block|{
name|QString
name|err
decl_stmt|;
if|if
condition|(
name|documentVersion
operator|!=
name|QLatin1String
argument_list|(
literal|"1.0"
argument_list|)
condition|)
block|{
if|if
condition|(
name|documentVersion
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
condition|)
name|err
operator|=
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Invalid XML version string."
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Unsupported XML version."
argument_list|)
expr_stmt|;
block|}
name|int
name|n
init|=
name|attributeStack
operator|.
name|size
argument_list|()
decl_stmt|;
comment|/* We use this bool to ensure that the pesudo attributes are in the      * proper order:      *      * [23]     XMLDecl     ::=     '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>' */
name|bool
name|hasStandalone
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|err
operator|.
name|isNull
argument_list|()
operator|&&
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|Attribute
modifier|&
name|attrib
init|=
name|attributeStack
index|[
name|i
index|]
decl_stmt|;
name|QStringRef
name|prefix
argument_list|(
name|symPrefix
argument_list|(
name|attrib
operator|.
name|key
argument_list|)
argument_list|)
decl_stmt|;
name|QStringRef
name|key
argument_list|(
name|symString
argument_list|(
name|attrib
operator|.
name|key
argument_list|)
argument_list|)
decl_stmt|;
name|QStringRef
name|value
argument_list|(
name|symString
argument_list|(
name|attrib
operator|.
name|value
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
operator|.
name|isEmpty
argument_list|()
operator|&&
name|key
operator|==
name|QLatin1String
argument_list|(
literal|"encoding"
argument_list|)
condition|)
block|{
specifier|const
name|QString
name|name
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|documentEncoding
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|hasStandalone
condition|)
name|err
operator|=
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"The standalone pseudo attribute must appear after the encoding."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|QXmlUtils
operator|::
name|isEncName
argument_list|(
name|name
argument_list|)
condition|)
name|err
operator|=
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"%1 is an invalid encoding name."
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|QT_NO_TEXTCODEC
name|readBuffer
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|rawReadBuffer
operator|.
name|data
argument_list|()
argument_list|,
name|nbytesread
argument_list|)
expr_stmt|;
else|#
directive|else
name|QTextCodec
modifier|*
specifier|const
name|newCodec
init|=
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|name
operator|.
name|toLatin1
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newCodec
condition|)
name|err
operator|=
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Encoding %1 is unsupported"
argument_list|)
operator|.
name|arg
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|newCodec
operator|!=
name|codec
operator|&&
operator|!
name|lockEncoding
condition|)
block|{
name|codec
operator|=
name|newCodec
expr_stmt|;
operator|delete
name|decoder
expr_stmt|;
name|decoder
operator|=
name|codec
operator|->
name|makeDecoder
argument_list|()
expr_stmt|;
name|decoder
operator|->
name|toUnicode
argument_list|(
operator|&
name|readBuffer
argument_list|,
name|rawReadBuffer
operator|.
name|data
argument_list|()
argument_list|,
name|nbytesread
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_TEXTCODEC
block|}
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|isEmpty
argument_list|()
operator|&&
name|key
operator|==
name|QLatin1String
argument_list|(
literal|"standalone"
argument_list|)
condition|)
block|{
name|hasStandalone
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|QLatin1String
argument_list|(
literal|"yes"
argument_list|)
condition|)
name|standalone
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
name|QLatin1String
argument_list|(
literal|"no"
argument_list|)
condition|)
name|standalone
operator|=
literal|false
expr_stmt|;
else|else
name|err
operator|=
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Standalone accepts only yes or no."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Invalid attribute in XML declaration."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|err
operator|.
name|isNull
argument_list|()
condition|)
name|raiseWellFormedError
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|attributeStack
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|raiseError
name|void
name|QXmlStreamReaderPrivate
operator|::
name|raiseError
parameter_list|(
name|QXmlStreamReader
operator|::
name|Error
name|error
parameter_list|,
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
block|{
name|this
operator|->
name|error
operator|=
name|error
expr_stmt|;
name|errorString
operator|=
name|message
expr_stmt|;
if|if
condition|(
name|errorString
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|QXmlStreamReader
operator|::
name|PrematureEndOfDocumentError
condition|)
name|errorString
operator|=
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Premature end of document."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|==
name|QXmlStreamReader
operator|::
name|CustomError
condition|)
name|errorString
operator|=
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Invalid document."
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|QXmlStreamReader
operator|::
name|Invalid
expr_stmt|;
block|}
end_function
begin_function
DECL|function|raiseWellFormedError
name|void
name|QXmlStreamReaderPrivate
operator|::
name|raiseWellFormedError
parameter_list|(
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
block|{
name|raiseError
argument_list|(
name|QXmlStreamReader
operator|::
name|NotWellFormedError
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseError
name|void
name|QXmlStreamReaderPrivate
operator|::
name|parseError
parameter_list|()
block|{
if|if
condition|(
name|token
operator|==
name|EOF_SYMBOL
condition|)
block|{
name|raiseError
argument_list|(
name|QXmlStreamReader
operator|::
name|PrematureEndOfDocumentError
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|int
name|nmax
init|=
literal|4
decl_stmt|;
name|QString
name|error_message
decl_stmt|;
name|int
name|ers
init|=
name|state_stack
index|[
name|tos
index|]
decl_stmt|;
name|int
name|nexpected
init|=
literal|0
decl_stmt|;
name|int
name|expected
index|[
name|nmax
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|!=
name|ERROR
condition|)
for|for
control|(
name|int
name|tk
init|=
literal|0
init|;
name|tk
operator|<
name|TERMINAL_COUNT
condition|;
operator|++
name|tk
control|)
block|{
name|int
name|k
init|=
name|t_action
argument_list|(
name|ers
argument_list|,
name|tk
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|spell
index|[
name|tk
index|]
condition|)
block|{
if|if
condition|(
name|nexpected
operator|<
name|nmax
condition|)
name|expected
index|[
name|nexpected
operator|++
index|]
operator|=
name|tk
expr_stmt|;
block|}
block|}
name|error_message
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|nexpected
operator|&&
name|nexpected
operator|<
name|nmax
condition|)
block|{
name|bool
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|nexpected
condition|;
operator|++
name|s
control|)
block|{
if|if
condition|(
name|first
condition|)
name|error_message
operator|+=
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Expected "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|==
name|nexpected
operator|-
literal|1
condition|)
name|error_message
operator|+=
name|QLatin1String
argument_list|(
name|nexpected
operator|>
literal|2
condition|?
literal|", or "
else|:
literal|" or "
argument_list|)
expr_stmt|;
else|else
name|error_message
operator|+=
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
name|error_message
operator|+=
name|QLatin1String
argument_list|(
literal|"\'"
argument_list|)
expr_stmt|;
name|error_message
operator|+=
name|QLatin1String
argument_list|(
name|spell
index|[
name|expected
index|[
name|s
index|]
index|]
argument_list|)
expr_stmt|;
name|error_message
operator|+=
name|QLatin1String
argument_list|(
literal|"\'"
argument_list|)
expr_stmt|;
block|}
name|error_message
operator|+=
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|", but got \'"
argument_list|)
expr_stmt|;
name|error_message
operator|+=
name|QLatin1String
argument_list|(
name|spell
index|[
name|token
index|]
argument_list|)
expr_stmt|;
name|error_message
operator|+=
name|QLatin1String
argument_list|(
literal|"\'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error_message
operator|+=
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Unexpected \'"
argument_list|)
expr_stmt|;
name|error_message
operator|+=
name|QLatin1String
argument_list|(
name|spell
index|[
name|token
index|]
argument_list|)
expr_stmt|;
name|error_message
operator|+=
name|QLatin1String
argument_list|(
literal|"\'"
argument_list|)
expr_stmt|;
block|}
name|error_message
operator|+=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|raiseWellFormedError
argument_list|(
name|error_message
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resume
name|void
name|QXmlStreamReaderPrivate
operator|::
name|resume
parameter_list|(
name|int
name|rule
parameter_list|)
block|{
name|resumeReduction
operator|=
name|rule
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|QXmlStreamReader
operator|::
name|NoError
condition|)
name|raiseError
argument_list|(
name|QXmlStreamReader
operator|::
name|PrematureEndOfDocumentError
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! Returns the current line number, starting with 1.  \sa columnNumber(), characterOffset()  */
end_comment
begin_function
DECL|function|lineNumber
name|qint64
name|QXmlStreamReader
operator|::
name|lineNumber
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|lineNumber
operator|+
literal|1
return|;
comment|// in public we start with 1
block|}
end_function
begin_comment
comment|/*! Returns the current column number, starting with 0.  \sa lineNumber(), characterOffset()  */
end_comment
begin_function
DECL|function|columnNumber
name|qint64
name|QXmlStreamReader
operator|::
name|columnNumber
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|characterOffset
operator|-
name|d
operator|->
name|lastLineStart
operator|+
name|d
operator|->
name|readBufferPos
return|;
block|}
end_function
begin_comment
comment|/*! Returns the current character offset, starting with 0.  \sa lineNumber(), columnNumber() */
end_comment
begin_function
DECL|function|characterOffset
name|qint64
name|QXmlStreamReader
operator|::
name|characterOffset
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|characterOffset
operator|+
name|d
operator|->
name|readBufferPos
return|;
block|}
end_function
begin_comment
comment|/*!  Returns the text of \l Characters, \l Comment, \l DTD, or   EntityReference.  */
end_comment
begin_function
DECL|function|text
name|QStringRef
name|QXmlStreamReader
operator|::
name|text
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|text
return|;
block|}
end_function
begin_comment
comment|/*!  If the tokenType() is \l DTD, this function returns the DTD's   notation declarations. Otherwise an empty vector is returned.    The QXmlStreamNotationDeclarations class is defined to be a QVector   of QXmlStreamNotationDeclaration.  */
end_comment
begin_function
DECL|function|notationDeclarations
name|QXmlStreamNotationDeclarations
name|QXmlStreamReader
operator|::
name|notationDeclarations
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|notationDeclarations
operator|.
name|size
argument_list|()
condition|)
cast|const_cast
argument_list|<
name|QXmlStreamReaderPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|resolveDtd
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|publicNotationDeclarations
return|;
block|}
end_function
begin_comment
comment|/*!  If the tokenType() is \l DTD, this function returns the DTD's   unparsed (external) entity declarations. Otherwise an empty vector is returned.    The QXmlStreamEntityDeclarations class is defined to be a QVector   of QXmlStreamEntityDeclaration.  */
end_comment
begin_function
DECL|function|entityDeclarations
name|QXmlStreamEntityDeclarations
name|QXmlStreamReader
operator|::
name|entityDeclarations
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|entityDeclarations
operator|.
name|size
argument_list|()
condition|)
cast|const_cast
argument_list|<
name|QXmlStreamReaderPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|resolveDtd
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|publicEntityDeclarations
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.4    If the tokenType() is \l DTD, this function returns the DTD's   name. Otherwise an empty string is returned.   */
end_comment
begin_function
DECL|function|dtdName
name|QStringRef
name|QXmlStreamReader
operator|::
name|dtdName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QXmlStreamReader
operator|::
name|DTD
condition|)
return|return
name|d
operator|->
name|dtdName
return|;
return|return
name|QStringRef
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.4    If the tokenType() is \l DTD, this function returns the DTD's   public identifier. Otherwise an empty string is returned.   */
end_comment
begin_function
DECL|function|dtdPublicId
name|QStringRef
name|QXmlStreamReader
operator|::
name|dtdPublicId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QXmlStreamReader
operator|::
name|DTD
condition|)
return|return
name|d
operator|->
name|dtdPublicId
return|;
return|return
name|QStringRef
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.4    If the tokenType() is \l DTD, this function returns the DTD's   system identifier. Otherwise an empty string is returned.   */
end_comment
begin_function
DECL|function|dtdSystemId
name|QStringRef
name|QXmlStreamReader
operator|::
name|dtdSystemId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QXmlStreamReader
operator|::
name|DTD
condition|)
return|return
name|d
operator|->
name|dtdSystemId
return|;
return|return
name|QStringRef
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!  If the tokenType() is \l StartElement, this function returns the   element's namespace declarations. Otherwise an empty vector is   returned.    The QXmlStreamNamespaceDeclarations class is defined to be a QVector   of QXmlStreamNamespaceDeclaration.    \sa addExtraNamespaceDeclaration(), addExtraNamespaceDeclarations()  */
end_comment
begin_function
DECL|function|namespaceDeclarations
name|QXmlStreamNamespaceDeclarations
name|QXmlStreamReader
operator|::
name|namespaceDeclarations
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|publicNamespaceDeclarations
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|type
operator|==
name|StartElement
condition|)
cast|const_cast
argument_list|<
name|QXmlStreamReaderPrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
operator|->
name|resolvePublicNamespaces
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|publicNamespaceDeclarations
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.4    Adds an \a extraNamespaceDeclaration. The declaration will be   valid for children of the current element, or - should the function   be called before any elements are read - for the entire XML   document.    \sa namespaceDeclarations(), addExtraNamespaceDeclarations(), setNamespaceProcessing()  */
end_comment
begin_function
DECL|function|addExtraNamespaceDeclaration
name|void
name|QXmlStreamReader
operator|::
name|addExtraNamespaceDeclaration
parameter_list|(
specifier|const
name|QXmlStreamNamespaceDeclaration
modifier|&
name|extraNamespaceDeclaration
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
name|QXmlStreamReaderPrivate
operator|::
name|NamespaceDeclaration
modifier|&
name|namespaceDeclaration
init|=
name|d
operator|->
name|namespaceDeclarations
operator|.
name|push
argument_list|()
decl_stmt|;
name|namespaceDeclaration
operator|.
name|prefix
operator|=
name|d
operator|->
name|addToStringStorage
argument_list|(
name|extraNamespaceDeclaration
operator|.
name|prefix
argument_list|()
argument_list|)
expr_stmt|;
name|namespaceDeclaration
operator|.
name|namespaceUri
operator|=
name|d
operator|->
name|addToStringStorage
argument_list|(
name|extraNamespaceDeclaration
operator|.
name|namespaceUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \since 4.4    Adds a vector of declarations specified by \a extraNamespaceDeclarations.    \sa namespaceDeclarations(), addExtraNamespaceDeclaration()  */
end_comment
begin_function
DECL|function|addExtraNamespaceDeclarations
name|void
name|QXmlStreamReader
operator|::
name|addExtraNamespaceDeclarations
parameter_list|(
specifier|const
name|QXmlStreamNamespaceDeclarations
modifier|&
name|extraNamespaceDeclarations
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|extraNamespaceDeclarations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|addExtraNamespaceDeclaration
argument_list|(
name|extraNamespaceDeclarations
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Convenience function to be called in case a StartElement was   read. Reads until the corresponding EndElement and returns all text   in-between. In case of no error, the current token (see tokenType())   after having called this function is EndElement.    The function concatenates text() when it reads either \l Characters   or EntityReference tokens, but skips ProcessingInstruction and \l   Comment. If the current token is not StartElement, an empty string is   returned.    The \a behaviour defines what happens in case anything else is   read before reaching EndElement. The function can include the text from   child elements (useful for example for HTML), ignore child elements, or   raise an UnexpectedElementError and return what was read so far (default).    \since 4.6  */
end_comment
begin_function
DECL|function|readElementText
name|QString
name|QXmlStreamReader
operator|::
name|readElementText
parameter_list|(
name|ReadElementTextBehaviour
name|behaviour
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|isStartElement
argument_list|()
condition|)
block|{
name|QString
name|result
decl_stmt|;
forever|forever
block|{
switch|switch
condition|(
name|readNext
argument_list|()
condition|)
block|{
case|case
name|Characters
case|:
case|case
name|EntityReference
case|:
name|result
operator|.
name|insert
argument_list|(
name|result
operator|.
name|size
argument_list|()
argument_list|,
name|d
operator|->
name|text
operator|.
name|unicode
argument_list|()
argument_list|,
name|d
operator|->
name|text
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|EndElement
case|:
return|return
name|result
return|;
case|case
name|ProcessingInstruction
case|:
case|case
name|Comment
case|:
break|break;
case|case
name|StartElement
case|:
if|if
condition|(
name|behaviour
operator|==
name|SkipChildElements
condition|)
block|{
name|skipCurrentElement
argument_list|()
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|behaviour
operator|==
name|IncludeChildElements
condition|)
block|{
name|result
operator|+=
name|readElementText
argument_list|(
name|behaviour
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Fall through (for ErrorOnUnexpectedElement)
default|default:
if|if
condition|(
name|d
operator|->
name|error
operator|||
name|behaviour
operator|==
name|ErrorOnUnexpectedElement
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|error
condition|)
name|d
operator|->
name|raiseError
argument_list|(
name|UnexpectedElementError
argument_list|,
name|QXmlStream
operator|::
name|tr
argument_list|(
literal|"Expected character data."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
block|}
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!  Raises a custom error with an optional error \a message.    \sa error(), errorString()  */
end_comment
begin_function
DECL|function|raiseError
name|void
name|QXmlStreamReader
operator|::
name|raiseError
parameter_list|(
specifier|const
name|QString
modifier|&
name|message
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamReader
argument_list|)
expr_stmt|;
name|d
operator|->
name|raiseError
argument_list|(
name|CustomError
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns the error message that was set with raiseError().    \sa error(), lineNumber(), columnNumber(), characterOffset()  */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QXmlStreamReader
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QXmlStreamReader
operator|::
name|Invalid
condition|)
return|return
name|d
operator|->
name|errorString
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!  Returns the type of the current error, or NoError if no error occurred.    \sa errorString(), raiseError()  */
end_comment
begin_function
DECL|function|error
name|QXmlStreamReader
operator|::
name|Error
name|QXmlStreamReader
operator|::
name|error
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QXmlStreamReader
operator|::
name|Invalid
condition|)
return|return
name|d
operator|->
name|error
return|;
return|return
name|NoError
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the target of a ProcessingInstruction.  */
end_comment
begin_function
DECL|function|processingInstructionTarget
name|QStringRef
name|QXmlStreamReader
operator|::
name|processingInstructionTarget
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|processingInstructionTarget
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the data of a ProcessingInstruction.  */
end_comment
begin_function
DECL|function|processingInstructionData
name|QStringRef
name|QXmlStreamReader
operator|::
name|processingInstructionData
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|processingInstructionData
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the local name of a StartElement, EndElement, or an EntityReference.    \sa namespaceUri(), qualifiedName()  */
end_comment
begin_function
DECL|function|name
name|QStringRef
name|QXmlStreamReader
operator|::
name|name
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|name
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the namespaceUri of a StartElement or EndElement.    \sa name(), qualifiedName()  */
end_comment
begin_function
DECL|function|namespaceUri
name|QStringRef
name|QXmlStreamReader
operator|::
name|namespaceUri
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|namespaceUri
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the qualified name of a StartElement or EndElement;    A qualified name is the raw name of an element in the XML data. It   consists of the namespace prefix, followed by colon, followed by the   element's local name. Since the namespace prefix is not unique (the   same prefix can point to different namespaces and different prefixes   can point to the same namespace), you shouldn't use qualifiedName(),   but the resolved namespaceUri() and the attribute's local name().     \sa name(), prefix(), namespaceUri()  */
end_comment
begin_function
DECL|function|qualifiedName
name|QStringRef
name|QXmlStreamReader
operator|::
name|qualifiedName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|qualifiedName
return|;
block|}
end_function
begin_comment
comment|/*!   \since 4.4    Returns the prefix of a StartElement or EndElement.    \sa name(), qualifiedName() */
end_comment
begin_function
DECL|function|prefix
name|QStringRef
name|QXmlStreamReader
operator|::
name|prefix
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|prefix
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the attributes of a StartElement.  */
end_comment
begin_function
DECL|function|attributes
name|QXmlStreamAttributes
name|QXmlStreamReader
operator|::
name|attributes
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|attributes
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_XMLSTREAMREADER
end_comment
begin_comment
comment|/*!     \class QXmlStreamAttribute     \inmodule QtCore     \since 4.3     \reentrant     \brief The QXmlStreamAttribute class represents a single XML attribute      \ingroup xml-tools      An attribute consists of an optionally empty namespaceUri(), a     name(), a value(), and an isDefault() attribute.      The raw XML attribute name is returned as qualifiedName(). */
end_comment
begin_comment
comment|/*!   Creates an empty attribute.  */
end_comment
begin_constructor
DECL|function|QXmlStreamAttribute
name|QXmlStreamAttribute
operator|::
name|QXmlStreamAttribute
parameter_list|()
block|{
name|m_isDefault
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Destructs an attribute.  */
end_comment
begin_destructor
DECL|function|~QXmlStreamAttribute
name|QXmlStreamAttribute
operator|::
name|~
name|QXmlStreamAttribute
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!  Constructs an attribute in the namespace described with \a   namespaceUri with \a name and value \a value.  */
end_comment
begin_constructor
DECL|function|QXmlStreamAttribute
name|QXmlStreamAttribute
operator|::
name|QXmlStreamAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|m_namespaceUri
operator|=
name|QXmlStreamStringRef
argument_list|(
name|QStringRef
argument_list|(
operator|&
name|namespaceUri
argument_list|)
argument_list|)
expr_stmt|;
name|m_name
operator|=
name|m_qualifiedName
operator|=
name|QXmlStreamStringRef
argument_list|(
name|QStringRef
argument_list|(
operator|&
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|m_value
operator|=
name|QXmlStreamStringRef
argument_list|(
name|QStringRef
argument_list|(
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|m_namespaceUri
operator|=
name|QXmlStreamStringRef
argument_list|(
name|QStringRef
argument_list|(
operator|&
name|namespaceUri
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an attribute with qualified name \a qualifiedName and value \a value.  */
end_comment
begin_constructor
DECL|function|QXmlStreamAttribute
name|QXmlStreamAttribute
operator|::
name|QXmlStreamAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|qualifiedName
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|int
name|colon
init|=
name|qualifiedName
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
name|m_name
operator|=
name|QXmlStreamStringRef
argument_list|(
name|QStringRef
argument_list|(
operator|&
name|qualifiedName
argument_list|,
name|colon
operator|+
literal|1
argument_list|,
name|qualifiedName
operator|.
name|size
argument_list|()
operator|-
operator|(
name|colon
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|m_qualifiedName
operator|=
name|QXmlStreamStringRef
argument_list|(
name|QStringRef
argument_list|(
operator|&
name|qualifiedName
argument_list|)
argument_list|)
expr_stmt|;
name|m_value
operator|=
name|QXmlStreamStringRef
argument_list|(
name|QStringRef
argument_list|(
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \fn QStringRef QXmlStreamAttribute::namespaceUri() const     Returns the attribute's resolved namespaceUri, or an empty string    reference if the attribute does not have a defined namespace.  */
end_comment
begin_comment
comment|/*! \fn QStringRef QXmlStreamAttribute::name() const    Returns the attribute's local name.  */
end_comment
begin_comment
comment|/*! \fn QStringRef QXmlStreamAttribute::qualifiedName() const    Returns the attribute's qualified name.     A qualified name is the raw name of an attribute in the XML    data. It consists of the namespace prefix(), followed by colon,    followed by the attribute's local name(). Since the namespace prefix    is not unique (the same prefix can point to different namespaces    and different prefixes can point to the same namespace), you    shouldn't use qualifiedName(), but the resolved namespaceUri() and    the attribute's local name().  */
end_comment
begin_comment
comment|/*!    \fn QStringRef QXmlStreamAttribute::prefix() const    \since 4.4    Returns the attribute's namespace prefix.     \sa name(), qualifiedName()  */
end_comment
begin_comment
comment|/*! \fn QStringRef QXmlStreamAttribute::value() const    Returns the attribute's value.  */
end_comment
begin_comment
comment|/*! \fn bool QXmlStreamAttribute::isDefault() const     Returns \c true if the parser added this attribute with a default    value following an ATTLIST declaration in the DTD; otherwise    returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool QXmlStreamAttribute::operator==(const QXmlStreamAttribute&other) const      Compares this attribute with \a other and returns \c true if they are     equal; otherwise returns \c false.  */
end_comment
begin_comment
comment|/*! \fn bool QXmlStreamAttribute::operator!=(const QXmlStreamAttribute&other) const      Compares this attribute with \a other and returns \c true if they are     not equal; otherwise returns \c false.  */
end_comment
begin_comment
comment|/*!   Creates a copy of \a other.  */
end_comment
begin_constructor
DECL|function|QXmlStreamAttribute
name|QXmlStreamAttribute
operator|::
name|QXmlStreamAttribute
parameter_list|(
specifier|const
name|QXmlStreamAttribute
modifier|&
name|other
parameter_list|)
block|{
operator|*
name|this
operator|=
name|other
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Assigns \a other to this attribute.  */
end_comment
begin_function
DECL|function|operator =
name|QXmlStreamAttribute
modifier|&
name|QXmlStreamAttribute
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QXmlStreamAttribute
modifier|&
name|other
parameter_list|)
block|{
name|m_name
operator|=
name|other
operator|.
name|m_name
expr_stmt|;
name|m_namespaceUri
operator|=
name|other
operator|.
name|m_namespaceUri
expr_stmt|;
name|m_qualifiedName
operator|=
name|other
operator|.
name|m_qualifiedName
expr_stmt|;
name|m_value
operator|=
name|other
operator|.
name|m_value
expr_stmt|;
name|m_isDefault
operator|=
name|other
operator|.
name|m_isDefault
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \class QXmlStreamAttributes     \inmodule QtCore     \since 4.3     \reentrant     \brief The QXmlStreamAttributes class represents a vector of QXmlStreamAttribute.      Attributes are returned by a QXmlStreamReader in     \l{QXmlStreamReader::attributes()} {attributes()} when the reader     reports a \l {QXmlStreamReader::StartElement}{start element}. The     class can also be used with a QXmlStreamWriter as an argument to     \l {QXmlStreamWriter::writeAttributes()}{writeAttributes()}.      The convenience function value() loops over the vector and returns     an attribute value for a given namespaceUri and an attribute's     name.      New attributes can be added with append().      \ingroup xml-tools */
end_comment
begin_comment
comment|/*!     \fn QXmlStreamAttributes::QXmlStreamAttributes()      A constructor for QXmlStreamAttributes. */
end_comment
begin_comment
comment|/*!     \typedef QXmlStreamNotationDeclarations     \relates QXmlStreamNotationDeclaration      Synonym for QVector<QXmlStreamNotationDeclaration>. */
end_comment
begin_comment
comment|/*!     \class QXmlStreamNotationDeclaration     \inmodule QtCore     \since 4.3     \reentrant     \brief The QXmlStreamNotationDeclaration class represents a DTD notation declaration.      \ingroup xml-tools      An notation declaration consists of a name(), a systemId(), and a publicId(). */
end_comment
begin_comment
comment|/*!   Creates an empty notation declaration. */
end_comment
begin_constructor
DECL|function|QXmlStreamNotationDeclaration
name|QXmlStreamNotationDeclaration
operator|::
name|QXmlStreamNotationDeclaration
parameter_list|()
block|{ }
end_constructor
begin_comment
comment|/*!   Creates a copy of \a other.  */
end_comment
begin_constructor
DECL|function|QXmlStreamNotationDeclaration
name|QXmlStreamNotationDeclaration
operator|::
name|QXmlStreamNotationDeclaration
parameter_list|(
specifier|const
name|QXmlStreamNotationDeclaration
modifier|&
name|other
parameter_list|)
block|{
operator|*
name|this
operator|=
name|other
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Assigns \a other to this notation declaration.  */
end_comment
begin_function
DECL|function|operator =
name|QXmlStreamNotationDeclaration
modifier|&
name|QXmlStreamNotationDeclaration
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QXmlStreamNotationDeclaration
modifier|&
name|other
parameter_list|)
block|{
name|m_name
operator|=
name|other
operator|.
name|m_name
expr_stmt|;
name|m_systemId
operator|=
name|other
operator|.
name|m_systemId
expr_stmt|;
name|m_publicId
operator|=
name|other
operator|.
name|m_publicId
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*! Destructs this notation declaration. */
end_comment
begin_destructor
DECL|function|~QXmlStreamNotationDeclaration
name|QXmlStreamNotationDeclaration
operator|::
name|~
name|QXmlStreamNotationDeclaration
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*! \fn QStringRef QXmlStreamNotationDeclaration::name() const  Returns the notation name. */
end_comment
begin_comment
comment|/*! \fn QStringRef QXmlStreamNotationDeclaration::systemId() const  Returns the system identifier. */
end_comment
begin_comment
comment|/*! \fn QStringRef QXmlStreamNotationDeclaration::publicId() const  Returns the public identifier. */
end_comment
begin_comment
comment|/*! \fn inline bool QXmlStreamNotationDeclaration::operator==(const QXmlStreamNotationDeclaration&other) const      Compares this notation declaration with \a other and returns \c true     if they are equal; otherwise returns \c false.  */
end_comment
begin_comment
comment|/*! \fn inline bool QXmlStreamNotationDeclaration::operator!=(const QXmlStreamNotationDeclaration&other) const      Compares this notation declaration with \a other and returns \c true     if they are not equal; otherwise returns \c false.  */
end_comment
begin_comment
comment|/*!     \typedef QXmlStreamNamespaceDeclarations     \relates QXmlStreamNamespaceDeclaration      Synonym for QVector<QXmlStreamNamespaceDeclaration>. */
end_comment
begin_comment
comment|/*!     \class QXmlStreamNamespaceDeclaration     \inmodule QtCore     \since 4.3     \reentrant     \brief The QXmlStreamNamespaceDeclaration class represents a namespace declaration.      \ingroup xml-tools      An namespace declaration consists of a prefix() and a namespaceUri(). */
end_comment
begin_comment
comment|/*! \fn inline bool QXmlStreamNamespaceDeclaration::operator==(const QXmlStreamNamespaceDeclaration&other) const      Compares this namespace declaration with \a other and returns \c true     if they are equal; otherwise returns \c false.  */
end_comment
begin_comment
comment|/*! \fn inline bool QXmlStreamNamespaceDeclaration::operator!=(const QXmlStreamNamespaceDeclaration&other) const      Compares this namespace declaration with \a other and returns \c true     if they are not equal; otherwise returns \c false.  */
end_comment
begin_comment
comment|/*!   Creates an empty namespace declaration. */
end_comment
begin_constructor
DECL|function|QXmlStreamNamespaceDeclaration
name|QXmlStreamNamespaceDeclaration
operator|::
name|QXmlStreamNamespaceDeclaration
parameter_list|()
block|{ }
end_constructor
begin_comment
comment|/*!   \since 4.4    Creates a namespace declaration with \a prefix and \a namespaceUri. */
end_comment
begin_constructor
DECL|function|QXmlStreamNamespaceDeclaration
name|QXmlStreamNamespaceDeclaration
operator|::
name|QXmlStreamNamespaceDeclaration
parameter_list|(
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|,
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|)
block|{
name|m_prefix
operator|=
name|prefix
expr_stmt|;
name|m_namespaceUri
operator|=
name|namespaceUri
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Creates a copy of \a other.  */
end_comment
begin_constructor
DECL|function|QXmlStreamNamespaceDeclaration
name|QXmlStreamNamespaceDeclaration
operator|::
name|QXmlStreamNamespaceDeclaration
parameter_list|(
specifier|const
name|QXmlStreamNamespaceDeclaration
modifier|&
name|other
parameter_list|)
block|{
operator|*
name|this
operator|=
name|other
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Assigns \a other to this namespace declaration.  */
end_comment
begin_function
DECL|function|operator =
name|QXmlStreamNamespaceDeclaration
modifier|&
name|QXmlStreamNamespaceDeclaration
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QXmlStreamNamespaceDeclaration
modifier|&
name|other
parameter_list|)
block|{
name|m_prefix
operator|=
name|other
operator|.
name|m_prefix
expr_stmt|;
name|m_namespaceUri
operator|=
name|other
operator|.
name|m_namespaceUri
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*! Destructs this namespace declaration. */
end_comment
begin_destructor
DECL|function|~QXmlStreamNamespaceDeclaration
name|QXmlStreamNamespaceDeclaration
operator|::
name|~
name|QXmlStreamNamespaceDeclaration
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*! \fn QStringRef QXmlStreamNamespaceDeclaration::prefix() const  Returns the prefix. */
end_comment
begin_comment
comment|/*! \fn QStringRef QXmlStreamNamespaceDeclaration::namespaceUri() const  Returns the namespaceUri. */
end_comment
begin_comment
comment|/*!     \typedef QXmlStreamEntityDeclarations     \relates QXmlStreamEntityDeclaration      Synonym for QVector<QXmlStreamEntityDeclaration>. */
end_comment
begin_comment
comment|/*!     \class QXmlStreamStringRef     \inmodule QtCore     \since 4.3     \internal */
end_comment
begin_comment
comment|/*!     \class QXmlStreamEntityDeclaration     \inmodule QtCore     \since 4.3     \reentrant     \brief The QXmlStreamEntityDeclaration class represents a DTD entity declaration.      \ingroup xml-tools      An entity declaration consists of a name(), a notationName(), a     systemId(), a publicId(), and a value(). */
end_comment
begin_comment
comment|/*!   Creates an empty entity declaration. */
end_comment
begin_constructor
DECL|function|QXmlStreamEntityDeclaration
name|QXmlStreamEntityDeclaration
operator|::
name|QXmlStreamEntityDeclaration
parameter_list|()
block|{ }
end_constructor
begin_comment
comment|/*!   Creates a copy of \a other.  */
end_comment
begin_constructor
DECL|function|QXmlStreamEntityDeclaration
name|QXmlStreamEntityDeclaration
operator|::
name|QXmlStreamEntityDeclaration
parameter_list|(
specifier|const
name|QXmlStreamEntityDeclaration
modifier|&
name|other
parameter_list|)
block|{
operator|*
name|this
operator|=
name|other
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Assigns \a other to this entity declaration.  */
end_comment
begin_function
DECL|function|operator =
name|QXmlStreamEntityDeclaration
modifier|&
name|QXmlStreamEntityDeclaration
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QXmlStreamEntityDeclaration
modifier|&
name|other
parameter_list|)
block|{
name|m_name
operator|=
name|other
operator|.
name|m_name
expr_stmt|;
name|m_notationName
operator|=
name|other
operator|.
name|m_notationName
expr_stmt|;
name|m_systemId
operator|=
name|other
operator|.
name|m_systemId
expr_stmt|;
name|m_publicId
operator|=
name|other
operator|.
name|m_publicId
expr_stmt|;
name|m_value
operator|=
name|other
operator|.
name|m_value
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!   Destructs this entity declaration. */
end_comment
begin_destructor
DECL|function|~QXmlStreamEntityDeclaration
name|QXmlStreamEntityDeclaration
operator|::
name|~
name|QXmlStreamEntityDeclaration
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*! \fn QXmlStreamStringRef::swap(QXmlStreamStringRef&other)     \since 5.6      Swaps this string reference's contents with \a other.     This function is very fast and never fails. */
end_comment
begin_comment
comment|/*! \fn QStringRef QXmlStreamEntityDeclaration::name() const  Returns the entity name. */
end_comment
begin_comment
comment|/*! \fn QStringRef QXmlStreamEntityDeclaration::notationName() const  Returns the notation name. */
end_comment
begin_comment
comment|/*! \fn QStringRef QXmlStreamEntityDeclaration::systemId() const  Returns the system identifier. */
end_comment
begin_comment
comment|/*! \fn QStringRef QXmlStreamEntityDeclaration::publicId() const  Returns the public identifier. */
end_comment
begin_comment
comment|/*! \fn QStringRef QXmlStreamEntityDeclaration::value() const  Returns the entity's value. */
end_comment
begin_comment
comment|/*! \fn bool QXmlStreamEntityDeclaration::operator==(const QXmlStreamEntityDeclaration&other) const      Compares this entity declaration with \a other and returns \c true if     they are equal; otherwise returns \c false.  */
end_comment
begin_comment
comment|/*! \fn bool QXmlStreamEntityDeclaration::operator!=(const QXmlStreamEntityDeclaration&other) const      Compares this entity declaration with \a other and returns \c true if     they are not equal; otherwise returns \c false.  */
end_comment
begin_comment
comment|/*!  Returns the value of the attribute \a name in the namespace   described with \a namespaceUri, or an empty string reference if the   attribute is not defined. The \a namespaceUri can be empty.  */
end_comment
begin_function
DECL|function|value
name|QStringRef
name|QXmlStreamAttributes
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QXmlStreamAttribute
modifier|&
name|attribute
init|=
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|attribute
operator|.
name|name
argument_list|()
operator|==
name|name
operator|&&
name|attribute
operator|.
name|namespaceUri
argument_list|()
operator|==
name|namespaceUri
condition|)
return|return
name|attribute
operator|.
name|value
argument_list|()
return|;
block|}
return|return
name|QStringRef
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!\overload   Returns the value of the attribute \a name in the namespace   described with \a namespaceUri, or an empty string reference if the   attribute is not defined. The \a namespaceUri can be empty.  */
end_comment
begin_function
DECL|function|value
name|QStringRef
name|QXmlStreamAttributes
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|,
name|QLatin1String
name|name
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QXmlStreamAttribute
modifier|&
name|attribute
init|=
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|attribute
operator|.
name|name
argument_list|()
operator|==
name|name
operator|&&
name|attribute
operator|.
name|namespaceUri
argument_list|()
operator|==
name|namespaceUri
condition|)
return|return
name|attribute
operator|.
name|value
argument_list|()
return|;
block|}
return|return
name|QStringRef
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!\overload   Returns the value of the attribute \a name in the namespace   described with \a namespaceUri, or an empty string reference if the   attribute is not defined. The \a namespaceUri can be empty.  */
end_comment
begin_function
DECL|function|value
name|QStringRef
name|QXmlStreamAttributes
operator|::
name|value
parameter_list|(
name|QLatin1String
name|namespaceUri
parameter_list|,
name|QLatin1String
name|name
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QXmlStreamAttribute
modifier|&
name|attribute
init|=
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|attribute
operator|.
name|name
argument_list|()
operator|==
name|name
operator|&&
name|attribute
operator|.
name|namespaceUri
argument_list|()
operator|==
name|namespaceUri
condition|)
return|return
name|attribute
operator|.
name|value
argument_list|()
return|;
block|}
return|return
name|QStringRef
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!\overload    Returns the value of the attribute with qualified name \a   qualifiedName , or an empty string reference if the attribute is not   defined. A qualified name is the raw name of an attribute in the XML   data. It consists of the namespace prefix, followed by colon,   followed by the attribute's local name. Since the namespace prefix   is not unique (the same prefix can point to different namespaces and   different prefixes can point to the same namespace), you shouldn't   use qualified names, but a resolved namespaceUri and the attribute's   local name.  */
end_comment
begin_function
DECL|function|value
name|QStringRef
name|QXmlStreamAttributes
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|qualifiedName
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QXmlStreamAttribute
modifier|&
name|attribute
init|=
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|attribute
operator|.
name|qualifiedName
argument_list|()
operator|==
name|qualifiedName
condition|)
return|return
name|attribute
operator|.
name|value
argument_list|()
return|;
block|}
return|return
name|QStringRef
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!\overload    Returns the value of the attribute with qualified name \a   qualifiedName , or an empty string reference if the attribute is not   defined. A qualified name is the raw name of an attribute in the XML   data. It consists of the namespace prefix, followed by colon,   followed by the attribute's local name. Since the namespace prefix   is not unique (the same prefix can point to different namespaces and   different prefixes can point to the same namespace), you shouldn't   use qualified names, but a resolved namespaceUri and the attribute's   local name.  */
end_comment
begin_function
DECL|function|value
name|QStringRef
name|QXmlStreamAttributes
operator|::
name|value
parameter_list|(
name|QLatin1String
name|qualifiedName
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QXmlStreamAttribute
modifier|&
name|attribute
init|=
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|attribute
operator|.
name|qualifiedName
argument_list|()
operator|==
name|qualifiedName
condition|)
return|return
name|attribute
operator|.
name|value
argument_list|()
return|;
block|}
return|return
name|QStringRef
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!Appends a new attribute with \a name in the namespace   described with \a namespaceUri, and value \a value. The \a   namespaceUri can be empty.  */
end_comment
begin_function
DECL|function|append
name|void
name|QXmlStreamAttributes
operator|::
name|append
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|append
argument_list|(
name|QXmlStreamAttribute
argument_list|(
name|namespaceUri
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\overload   Appends a new attribute with qualified name \a qualifiedName and   value \a value.  */
end_comment
begin_function
DECL|function|append
name|void
name|QXmlStreamAttributes
operator|::
name|append
parameter_list|(
specifier|const
name|QString
modifier|&
name|qualifiedName
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|append
argument_list|(
name|QXmlStreamAttribute
argument_list|(
name|qualifiedName
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_XMLSTREAMREADER
end_ifndef
begin_comment
comment|/*! \fn bool QXmlStreamReader::isStartDocument() const   Returns \c true if tokenType() equals \l StartDocument; otherwise returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool QXmlStreamReader::isEndDocument() const   Returns \c true if tokenType() equals \l EndDocument; otherwise returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool QXmlStreamReader::isStartElement() const   Returns \c true if tokenType() equals \l StartElement; otherwise returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool QXmlStreamReader::isEndElement() const   Returns \c true if tokenType() equals \l EndElement; otherwise returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool QXmlStreamReader::isCharacters() const   Returns \c true if tokenType() equals \l Characters; otherwise returns \c false.    \sa isWhitespace(), isCDATA() */
end_comment
begin_comment
comment|/*! \fn bool QXmlStreamReader::isComment() const   Returns \c true if tokenType() equals \l Comment; otherwise returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool QXmlStreamReader::isDTD() const   Returns \c true if tokenType() equals \l DTD; otherwise returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool QXmlStreamReader::isEntityReference() const   Returns \c true if tokenType() equals \l EntityReference; otherwise returns \c false. */
end_comment
begin_comment
comment|/*! \fn bool QXmlStreamReader::isProcessingInstruction() const   Returns \c true if tokenType() equals \l ProcessingInstruction; otherwise returns \c false. */
end_comment
begin_comment
comment|/*!  Returns \c true if the reader reports characters that only consist   of white-space; otherwise returns \c false.    \sa isCharacters(), text() */
end_comment
begin_function
DECL|function|isWhitespace
name|bool
name|QXmlStreamReader
operator|::
name|isWhitespace
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|type
operator|==
name|QXmlStreamReader
operator|::
name|Characters
operator|&&
name|d
operator|->
name|isWhitespace
return|;
block|}
end_function
begin_comment
comment|/*!  Returns \c true if the reader reports characters that stem from a   CDATA section; otherwise returns \c false.    \sa isCharacters(), text() */
end_comment
begin_function
DECL|function|isCDATA
name|bool
name|QXmlStreamReader
operator|::
name|isCDATA
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|type
operator|==
name|QXmlStreamReader
operator|::
name|Characters
operator|&&
name|d
operator|->
name|isCDATA
return|;
block|}
end_function
begin_comment
comment|/*!   Returns \c true if this document has been declared standalone in the   XML declaration; otherwise returns \c false.    If no XML declaration has been parsed, this function returns \c false.  */
end_comment
begin_function
DECL|function|isStandaloneDocument
name|bool
name|QXmlStreamReader
operator|::
name|isStandaloneDocument
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|standalone
return|;
block|}
end_function
begin_comment
comment|/*!      \since 4.4       If the tokenType() is \l StartDocument, this function returns the      version string as specified in the XML declaration.      Otherwise an empty string is returned.  */
end_comment
begin_function
DECL|function|documentVersion
name|QStringRef
name|QXmlStreamReader
operator|::
name|documentVersion
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QXmlStreamReader
operator|::
name|StartDocument
condition|)
return|return
name|d
operator|->
name|documentVersion
return|;
return|return
name|QStringRef
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!      \since 4.4       If the tokenType() is \l StartDocument, this function returns the      encoding string as specified in the XML declaration.      Otherwise an empty string is returned.  */
end_comment
begin_function
DECL|function|documentEncoding
name|QStringRef
name|QXmlStreamReader
operator|::
name|documentEncoding
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamReader
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|QXmlStreamReader
operator|::
name|StartDocument
condition|)
return|return
name|d
operator|->
name|documentEncoding
return|;
return|return
name|QStringRef
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_XMLSTREAMREADER
end_comment
begin_comment
comment|/*!   \class QXmlStreamWriter   \inmodule QtCore   \since 4.3   \reentrant    \brief The QXmlStreamWriter class provides an XML writer with a   simple streaming API.    \ingroup xml-tools    QXmlStreamWriter is the counterpart to QXmlStreamReader for writing   XML. Like its related class, it operates on a QIODevice specified   with setDevice(). The API is simple and straightforward: for every   XML token or event you want to write, the writer provides a   specialized function.    You start a document with writeStartDocument() and end it with   writeEndDocument(). This will implicitly close all remaining open   tags.    Element tags are opened with writeStartElement() followed by   writeAttribute() or writeAttributes(), element content, and then   writeEndElement(). A shorter form writeEmptyElement() can be used   to write empty elements, followed by writeAttributes().    Element content consists of either characters, entity references or   nested elements. It is written with writeCharacters(), which also   takes care of escaping all forbidden characters and character   sequences, writeEntityReference(), or subsequent calls to   writeStartElement(). A convenience method writeTextElement() can be   used for writing terminal elements that contain nothing but text.    The following abridged code snippet shows the basic use of the class   to write formatted XML with indentation:    \snippet qxmlstreamwriter/main.cpp start stream   \dots   \snippet qxmlstreamwriter/main.cpp write element   \dots   \snippet qxmlstreamwriter/main.cpp finish stream    QXmlStreamWriter takes care of prefixing namespaces, all you have to   do is specify the \c namespaceUri when writing elements or   attributes. If you must conform to certain prefixes, you can force   the writer to use them by declaring the namespaces manually with   either writeNamespace() or writeDefaultNamespace(). Alternatively,   you can bypass the stream writer's namespace support and use   overloaded methods that take a qualified name instead. The namespace   \e http://www.w3.org/XML/1998/namespace is implicit and mapped to the   prefix \e xml.    The stream writer can automatically format the generated XML data by   adding line-breaks and indentation to empty sections between   elements, making the XML data more readable for humans and easier to   work with for most source code management systems. The feature can   be turned on with the \l autoFormatting property, and customized   with the \l autoFormattingIndent property.    Other functions are writeCDATA(), writeComment(),   writeProcessingInstruction(), and writeDTD(). Chaining of XML   streams is supported with writeCurrentToken().    By default, QXmlStreamWriter encodes XML in UTF-8. Different   encodings can be enforced using setCodec().    If an error occurs while writing to the underlying device, hasError()   starts returning true and subsequent writes are ignored.    The \l{QXmlStream Bookmarks Example} illustrates how to use a   stream writer to write an XML bookmark file (XBEL) that   was previously read in by a QXmlStreamReader.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_XMLSTREAMWRITER
end_ifndef
begin_class
DECL|class|QXmlStreamWriterPrivate
class|class
name|QXmlStreamWriterPrivate
super|:
specifier|public
name|QXmlStreamPrivateTagStack
block|{
DECL|member|q_ptr
name|QXmlStreamWriter
modifier|*
name|q_ptr
decl_stmt|;
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QXmlStreamWriter
parameter_list|)
specifier|public
private|:
name|QXmlStreamWriterPrivate
parameter_list|(
name|QXmlStreamWriter
modifier|*
name|q
parameter_list|)
constructor_decl|;
DECL|function|~QXmlStreamWriterPrivate
name|~
name|QXmlStreamWriterPrivate
parameter_list|()
block|{
if|if
condition|(
name|deleteDevice
condition|)
operator|delete
name|device
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
operator|delete
name|encoder
expr_stmt|;
endif|#
directive|endif
block|}
name|void
name|write
parameter_list|(
specifier|const
name|QStringRef
modifier|&
parameter_list|)
function_decl|;
name|void
name|write
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
function_decl|;
name|void
name|writeEscaped
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|,
name|bool
name|escapeWhitespace
init|=
literal|false
parameter_list|)
function_decl|;
name|void
name|write
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
DECL|function|write
template|template
parameter_list|<
name|int
name|N
parameter_list|>
name|void
name|write
argument_list|(
specifier|const
name|char
argument_list|(
operator|&
name|s
argument_list|)
index|[
name|N
index|]
argument_list|)
argument_list|{
name|write
argument_list|(
name|s
argument_list|,
name|N
operator|-
literal|1
argument_list|)
argument_list|; }
name|bool
name|finishStartElement
argument_list|(
name|bool
name|contents
operator|=
literal|true
argument_list|)
decl_stmt|;
name|void
name|writeStartElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
function_decl|;
DECL|member|device
name|QIODevice
modifier|*
name|device
decl_stmt|;
DECL|member|stringDevice
name|QString
modifier|*
name|stringDevice
decl_stmt|;
name|uint
name|deleteDevice
range|:
literal|1
decl_stmt|;
name|uint
name|inStartElement
range|:
literal|1
decl_stmt|;
name|uint
name|inEmptyElement
range|:
literal|1
decl_stmt|;
name|uint
name|lastWasStartElement
range|:
literal|1
decl_stmt|;
name|uint
name|wroteSomething
range|:
literal|1
decl_stmt|;
name|uint
name|hasError
range|:
literal|1
decl_stmt|;
name|uint
name|autoFormatting
range|:
literal|1
decl_stmt|;
name|uint
name|isCodecASCIICompatible
range|:
literal|1
decl_stmt|;
DECL|member|autoFormattingIndent
name|QByteArray
name|autoFormattingIndent
decl_stmt|;
DECL|member|emptyNamespace
name|NamespaceDeclaration
name|emptyNamespace
decl_stmt|;
DECL|member|lastNamespaceDeclaration
name|int
name|lastNamespaceDeclaration
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
DECL|member|codec
name|QTextCodec
modifier|*
name|codec
decl_stmt|;
DECL|member|encoder
name|QTextEncoder
modifier|*
name|encoder
decl_stmt|;
endif|#
directive|endif
name|void
name|checkIfASCIICompatibleCodec
parameter_list|()
function_decl|;
name|NamespaceDeclaration
modifier|&
name|findNamespace
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|,
name|bool
name|writeDeclaration
init|=
literal|false
parameter_list|,
name|bool
name|noDefault
init|=
literal|false
parameter_list|)
function_decl|;
name|void
name|writeNamespaceDeclaration
parameter_list|(
specifier|const
name|NamespaceDeclaration
modifier|&
name|namespaceDeclaration
parameter_list|)
function_decl|;
DECL|member|namespacePrefixCount
name|int
name|namespacePrefixCount
decl_stmt|;
name|void
name|indent
parameter_list|(
name|int
name|level
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_constructor
DECL|function|QXmlStreamWriterPrivate
name|QXmlStreamWriterPrivate
operator|::
name|QXmlStreamWriterPrivate
parameter_list|(
name|QXmlStreamWriter
modifier|*
name|q
parameter_list|)
member_init_list|:
name|autoFormattingIndent
argument_list|(
literal|4
argument_list|,
literal|' '
argument_list|)
block|{
name|q_ptr
operator|=
name|q
expr_stmt|;
name|device
operator|=
literal|0
expr_stmt|;
name|stringDevice
operator|=
literal|0
expr_stmt|;
name|deleteDevice
operator|=
literal|false
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|codec
operator|=
name|QTextCodec
operator|::
name|codecForMib
argument_list|(
literal|106
argument_list|)
expr_stmt|;
comment|// utf8
name|encoder
operator|=
name|codec
operator|->
name|makeEncoder
argument_list|(
name|QTextCodec
operator|::
name|IgnoreHeader
argument_list|)
expr_stmt|;
comment|// no byte order mark for utf8
endif|#
directive|endif
name|checkIfASCIICompatibleCodec
argument_list|()
expr_stmt|;
name|inStartElement
operator|=
name|inEmptyElement
operator|=
literal|false
expr_stmt|;
name|wroteSomething
operator|=
literal|false
expr_stmt|;
name|hasError
operator|=
literal|false
expr_stmt|;
name|lastWasStartElement
operator|=
literal|false
expr_stmt|;
name|lastNamespaceDeclaration
operator|=
literal|1
expr_stmt|;
name|autoFormatting
operator|=
literal|false
expr_stmt|;
name|namespacePrefixCount
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|checkIfASCIICompatibleCodec
name|void
name|QXmlStreamWriterPrivate
operator|::
name|checkIfASCIICompatibleCodec
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
name|Q_ASSERT
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
comment|// assumes ASCII-compatibility for all 8-bit encodings
name|QChar
name|space
init|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
specifier|const
name|QByteArray
name|bytes
init|=
name|encoder
operator|->
name|fromUnicode
argument_list|(
operator|&
name|space
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|isCodecASCIICompatible
operator|=
operator|(
name|bytes
operator|.
name|count
argument_list|()
operator|==
literal|1
operator|)
expr_stmt|;
else|#
directive|else
name|isCodecASCIICompatible
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|write
name|void
name|QXmlStreamWriterPrivate
operator|::
name|write
parameter_list|(
specifier|const
name|QStringRef
modifier|&
name|s
parameter_list|)
block|{
if|if
condition|(
name|device
condition|)
block|{
if|if
condition|(
name|hasError
condition|)
return|return;
ifdef|#
directive|ifdef
name|QT_NO_TEXTCODEC
name|QByteArray
name|bytes
init|=
name|s
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
else|#
directive|else
name|QByteArray
name|bytes
init|=
name|encoder
operator|->
name|fromUnicode
argument_list|(
name|s
operator|.
name|constData
argument_list|()
argument_list|,
name|s
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|device
operator|->
name|write
argument_list|(
name|bytes
argument_list|)
operator|!=
name|bytes
operator|.
name|size
argument_list|()
condition|)
name|hasError
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stringDevice
condition|)
name|s
operator|.
name|appendTo
argument_list|(
name|stringDevice
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QXmlStreamWriter: No device"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|write
name|void
name|QXmlStreamWriterPrivate
operator|::
name|write
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|)
block|{
if|if
condition|(
name|device
condition|)
block|{
if|if
condition|(
name|hasError
condition|)
return|return;
ifdef|#
directive|ifdef
name|QT_NO_TEXTCODEC
name|QByteArray
name|bytes
init|=
name|s
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
else|#
directive|else
name|QByteArray
name|bytes
init|=
name|encoder
operator|->
name|fromUnicode
argument_list|(
name|s
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|device
operator|->
name|write
argument_list|(
name|bytes
argument_list|)
operator|!=
name|bytes
operator|.
name|size
argument_list|()
condition|)
name|hasError
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stringDevice
condition|)
name|stringDevice
operator|->
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|(
literal|"QXmlStreamWriter: No device"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|writeEscaped
name|void
name|QXmlStreamWriterPrivate
operator|::
name|writeEscaped
parameter_list|(
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|bool
name|escapeWhitespace
parameter_list|)
block|{
name|QString
name|escaped
decl_stmt|;
name|escaped
operator|.
name|reserve
argument_list|(
name|s
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QChar
name|c
init|=
name|s
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|unicode
argument_list|()
operator|==
literal|'<'
condition|)
name|escaped
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"&lt;"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|.
name|unicode
argument_list|()
operator|==
literal|'>'
condition|)
name|escaped
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"&gt;"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|.
name|unicode
argument_list|()
operator|==
literal|'&'
condition|)
name|escaped
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"&amp;"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|.
name|unicode
argument_list|()
operator|==
literal|'\"'
condition|)
name|escaped
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"&quot;"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|escapeWhitespace
operator|&&
name|c
operator|.
name|isSpace
argument_list|()
condition|)
block|{
if|if
condition|(
name|c
operator|.
name|unicode
argument_list|()
operator|==
literal|'\n'
condition|)
name|escaped
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"&#10;"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|.
name|unicode
argument_list|()
operator|==
literal|'\r'
condition|)
name|escaped
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"&#13;"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|.
name|unicode
argument_list|()
operator|==
literal|'\t'
condition|)
name|escaped
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|"&#9;"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|escaped
operator|+=
name|c
expr_stmt|;
block|}
else|else
block|{
name|escaped
operator|+=
name|QChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|write
argument_list|(
name|escaped
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Converts from ASCII to output encoding
end_comment
begin_function
DECL|function|write
name|void
name|QXmlStreamWriterPrivate
operator|::
name|write
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|device
condition|)
block|{
if|if
condition|(
name|hasError
condition|)
return|return;
if|if
condition|(
name|isCodecASCIICompatible
condition|)
block|{
if|if
condition|(
name|device
operator|->
name|write
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
name|hasError
operator|=
literal|true
expr_stmt|;
return|return;
block|}
block|}
name|write
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|writeNamespaceDeclaration
name|void
name|QXmlStreamWriterPrivate
operator|::
name|writeNamespaceDeclaration
parameter_list|(
specifier|const
name|NamespaceDeclaration
modifier|&
name|namespaceDeclaration
parameter_list|)
block|{
if|if
condition|(
name|namespaceDeclaration
operator|.
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|write
argument_list|(
literal|" xmlns=\""
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|namespaceDeclaration
operator|.
name|namespaceUri
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write
argument_list|(
literal|" xmlns:"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|namespaceDeclaration
operator|.
name|prefix
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|"=\""
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|namespaceDeclaration
operator|.
name|namespaceUri
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|finishStartElement
name|bool
name|QXmlStreamWriterPrivate
operator|::
name|finishStartElement
parameter_list|(
name|bool
name|contents
parameter_list|)
block|{
name|bool
name|hadSomethingWritten
init|=
name|wroteSomething
decl_stmt|;
name|wroteSomething
operator|=
name|contents
expr_stmt|;
if|if
condition|(
operator|!
name|inStartElement
condition|)
return|return
name|hadSomethingWritten
return|;
if|if
condition|(
name|inEmptyElement
condition|)
block|{
name|write
argument_list|(
literal|"/>"
argument_list|)
expr_stmt|;
name|QXmlStreamWriterPrivate
operator|::
name|Tag
modifier|&
name|tag
init|=
name|tagStack_pop
argument_list|()
decl_stmt|;
name|lastNamespaceDeclaration
operator|=
name|tag
operator|.
name|namespaceDeclarationsSize
expr_stmt|;
name|lastWasStartElement
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|write
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
name|inStartElement
operator|=
name|inEmptyElement
operator|=
literal|false
expr_stmt|;
name|lastNamespaceDeclaration
operator|=
name|namespaceDeclarations
operator|.
name|size
argument_list|()
expr_stmt|;
return|return
name|hadSomethingWritten
return|;
block|}
end_function
begin_function
DECL|function|findNamespace
name|QXmlStreamPrivateTagStack
operator|::
name|NamespaceDeclaration
modifier|&
name|QXmlStreamWriterPrivate
operator|::
name|findNamespace
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|,
name|bool
name|writeDeclaration
parameter_list|,
name|bool
name|noDefault
parameter_list|)
block|{
for|for
control|(
name|int
name|j
init|=
name|namespaceDeclarations
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|NamespaceDeclaration
modifier|&
name|namespaceDeclaration
init|=
name|namespaceDeclarations
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|namespaceDeclaration
operator|.
name|namespaceUri
operator|==
name|namespaceUri
condition|)
block|{
if|if
condition|(
operator|!
name|noDefault
operator|||
operator|!
name|namespaceDeclaration
operator|.
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|namespaceDeclaration
return|;
block|}
block|}
if|if
condition|(
name|namespaceUri
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|emptyNamespace
return|;
name|NamespaceDeclaration
modifier|&
name|namespaceDeclaration
init|=
name|namespaceDeclarations
operator|.
name|push
argument_list|()
decl_stmt|;
if|if
condition|(
name|namespaceUri
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|namespaceDeclaration
operator|.
name|prefix
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QString
name|s
decl_stmt|;
name|int
name|n
init|=
operator|++
name|namespacePrefixCount
decl_stmt|;
forever|forever
block|{
name|s
operator|=
name|QLatin1Char
argument_list|(
literal|'n'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|n
operator|++
argument_list|)
expr_stmt|;
name|int
name|j
init|=
name|namespaceDeclarations
operator|.
name|size
argument_list|()
operator|-
literal|2
decl_stmt|;
while|while
condition|(
name|j
operator|>=
literal|0
operator|&&
name|namespaceDeclarations
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|prefix
operator|!=
name|s
condition|)
operator|--
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
break|break;
block|}
name|namespaceDeclaration
operator|.
name|prefix
operator|=
name|addToStringStorage
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|namespaceDeclaration
operator|.
name|namespaceUri
operator|=
name|addToStringStorage
argument_list|(
name|namespaceUri
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeDeclaration
condition|)
name|writeNamespaceDeclaration
argument_list|(
name|namespaceDeclaration
argument_list|)
expr_stmt|;
return|return
name|namespaceDeclaration
return|;
block|}
end_function
begin_function
DECL|function|indent
name|void
name|QXmlStreamWriterPrivate
operator|::
name|indent
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|level
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|write
argument_list|(
name|autoFormattingIndent
operator|.
name|constData
argument_list|()
argument_list|,
name|autoFormattingIndent
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Constructs a stream writer.    \sa setDevice()  */
end_comment
begin_constructor
DECL|function|QXmlStreamWriter
name|QXmlStreamWriter
operator|::
name|QXmlStreamWriter
parameter_list|()
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QXmlStreamWriterPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Constructs a stream writer that writes into \a device;  */
end_comment
begin_constructor
DECL|function|QXmlStreamWriter
name|QXmlStreamWriter
operator|::
name|QXmlStreamWriter
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QXmlStreamWriterPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|=
name|device
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!  Constructs a stream writer that writes into \a array. This is the   same as creating an xml writer that operates on a QBuffer device   which in turn operates on \a array.  */
end_comment
begin_constructor
DECL|function|QXmlStreamWriter
name|QXmlStreamWriter
operator|::
name|QXmlStreamWriter
parameter_list|(
name|QByteArray
modifier|*
name|array
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QXmlStreamWriterPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|=
operator|new
name|QBuffer
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|d
operator|->
name|device
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|true
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!  Constructs a stream writer that writes into \a string.  */
end_comment
begin_constructor
DECL|function|QXmlStreamWriter
name|QXmlStreamWriter
operator|::
name|QXmlStreamWriter
parameter_list|(
name|QString
modifier|*
name|string
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QXmlStreamWriterPrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|d
operator|->
name|stringDevice
operator|=
name|string
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destructor. */
end_comment
begin_destructor
DECL|function|~QXmlStreamWriter
name|QXmlStreamWriter
operator|::
name|~
name|QXmlStreamWriter
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Sets the current device to \a device. If you want the stream to     write into a QByteArray, you can create a QBuffer device.      \sa device() */
end_comment
begin_function
DECL|function|setDevice
name|void
name|QXmlStreamWriter
operator|::
name|setDevice
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|==
name|d
operator|->
name|device
condition|)
return|return;
name|d
operator|->
name|stringDevice
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|deleteDevice
condition|)
block|{
operator|delete
name|d
operator|->
name|device
expr_stmt|;
name|d
operator|->
name|deleteDevice
operator|=
literal|false
expr_stmt|;
block|}
name|d
operator|->
name|device
operator|=
name|device
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current device associated with the QXmlStreamWriter,     or 0 if no device has been assigned.      \sa setDevice() */
end_comment
begin_function
DECL|function|device
name|QIODevice
modifier|*
name|QXmlStreamWriter
operator|::
name|device
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|device
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TEXTCODEC
end_ifndef
begin_comment
comment|/*!     Sets the codec for this stream to \a codec. The codec is used for     encoding any data that is written. By default, QXmlStreamWriter     uses UTF-8.      The encoding information is stored in the initial xml tag which     gets written when you call writeStartDocument(). Call this     function before calling writeStartDocument().      \sa codec() */
end_comment
begin_function
DECL|function|setCodec
name|void
name|QXmlStreamWriter
operator|::
name|setCodec
parameter_list|(
name|QTextCodec
modifier|*
name|codec
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
condition|)
block|{
name|d
operator|->
name|codec
operator|=
name|codec
expr_stmt|;
operator|delete
name|d
operator|->
name|encoder
expr_stmt|;
name|d
operator|->
name|encoder
operator|=
name|codec
operator|->
name|makeEncoder
argument_list|(
name|QTextCodec
operator|::
name|IgnoreHeader
argument_list|)
expr_stmt|;
comment|// no byte order mark for utf8
name|d
operator|->
name|checkIfASCIICompatibleCodec
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Sets the codec for this stream to the QTextCodec for the encoding     specified by \a codecName. Common values for \c codecName include     "ISO 8859-1", "UTF-8", and "UTF-16". If the encoding isn't     recognized, nothing happens.      \sa QTextCodec::codecForName() */
end_comment
begin_function
DECL|function|setCodec
name|void
name|QXmlStreamWriter
operator|::
name|setCodec
parameter_list|(
specifier|const
name|char
modifier|*
name|codecName
parameter_list|)
block|{
name|setCodec
argument_list|(
name|QTextCodec
operator|::
name|codecForName
argument_list|(
name|codecName
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the codec that is currently assigned to the stream.      \sa setCodec() */
end_comment
begin_function
DECL|function|codec
name|QTextCodec
modifier|*
name|QXmlStreamWriter
operator|::
name|codec
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|codec
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TEXTCODEC
end_comment
begin_comment
comment|/*!     \property  QXmlStreamWriter::autoFormatting     \since 4.4     The auto-formatting flag of the stream writer      This property controls whether or not the stream writer     automatically formats the generated XML data. If enabled, the     writer automatically adds line-breaks and indentation to empty     sections between elements (ignorable whitespace). The main purpose     of auto-formatting is to split the data into several lines, and to     increase readability for a human reader. The indentation depth can     be controlled through the \l autoFormattingIndent property.      By default, auto-formatting is disabled. */
end_comment
begin_comment
comment|/*!  \since 4.4   Enables auto formatting if \a enable is \c true, otherwise  disables it.   The default value is \c false.  */
end_comment
begin_function
DECL|function|setAutoFormatting
name|void
name|QXmlStreamWriter
operator|::
name|setAutoFormatting
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoFormatting
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  \since 4.4   Returns \c true if auto formattting is enabled, otherwise \c false.  */
end_comment
begin_function
DECL|function|autoFormatting
name|bool
name|QXmlStreamWriter
operator|::
name|autoFormatting
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoFormatting
return|;
block|}
end_function
begin_comment
comment|/*!     \property QXmlStreamWriter::autoFormattingIndent     \since 4.4      \brief the number of spaces or tabs used for indentation when     auto-formatting is enabled.  Positive numbers indicate spaces,     negative numbers tabs.      The default indentation is 4.      \sa autoFormatting */
end_comment
begin_function
DECL|function|setAutoFormattingIndent
name|void
name|QXmlStreamWriter
operator|::
name|setAutoFormattingIndent
parameter_list|(
name|int
name|spacesOrTabs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|d
operator|->
name|autoFormattingIndent
operator|=
name|QByteArray
argument_list|(
name|qAbs
argument_list|(
name|spacesOrTabs
argument_list|)
argument_list|,
name|spacesOrTabs
operator|>=
literal|0
condition|?
literal|' '
else|:
literal|'\t'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|autoFormattingIndent
name|int
name|QXmlStreamWriter
operator|::
name|autoFormattingIndent
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|autoFormattingIndent
operator|.
name|count
argument_list|(
literal|' '
argument_list|)
operator|-
name|d
operator|->
name|autoFormattingIndent
operator|.
name|count
argument_list|(
literal|'\t'
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the stream failed to write to the underlying device.      The error status is never reset. Writes happening after the error     occurred are ignored, even if the error condition is cleared.  */
end_comment
begin_function
DECL|function|hasError
name|bool
name|QXmlStreamWriter
operator|::
name|hasError
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|hasError
return|;
block|}
end_function
begin_comment
comment|/*!   \overload   Writes an attribute with \a qualifiedName and \a value.     This function can only be called after writeStartElement() before   any content is written, or after writeEmptyElement().  */
end_comment
begin_function
DECL|function|writeAttribute
name|void
name|QXmlStreamWriter
operator|::
name|writeAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|qualifiedName
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|inStartElement
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|qualifiedName
operator|.
name|count
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
operator|<=
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
name|qualifiedName
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"=\""
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeEscaped
argument_list|(
name|value
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Writes an attribute with \a name and \a value, prefixed for   the specified \a namespaceUri. If the namespace has not been   declared yet, QXmlStreamWriter will generate a namespace declaration   for it.    This function can only be called after writeStartElement() before   any content is written, or after writeEmptyElement().  */
end_comment
begin_function
DECL|function|writeAttribute
name|void
name|QXmlStreamWriter
operator|::
name|writeAttribute
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|inStartElement
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|name
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QXmlStreamWriterPrivate
operator|::
name|NamespaceDeclaration
modifier|&
name|namespaceDeclaration
init|=
name|d
operator|->
name|findNamespace
argument_list|(
name|namespaceUri
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|namespaceDeclaration
operator|.
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|write
argument_list|(
name|namespaceDeclaration
operator|.
name|prefix
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|write
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"=\""
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeEscaped
argument_list|(
name|value
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \overload    Writes the \a attribute.    This function can only be called after writeStartElement() before   any content is written, or after writeEmptyElement().  */
end_comment
begin_function
DECL|function|writeAttribute
name|void
name|QXmlStreamWriter
operator|::
name|writeAttribute
parameter_list|(
specifier|const
name|QXmlStreamAttribute
modifier|&
name|attribute
parameter_list|)
block|{
if|if
condition|(
name|attribute
operator|.
name|namespaceUri
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|writeAttribute
argument_list|(
name|attribute
operator|.
name|qualifiedName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|attribute
operator|.
name|value
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|writeAttribute
argument_list|(
name|attribute
operator|.
name|namespaceUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|attribute
operator|.
name|name
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|attribute
operator|.
name|value
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Writes the attribute vector \a attributes. If a namespace   referenced in an attribute not been declared yet, QXmlStreamWriter   will generate a namespace declaration for it.    This function can only be called after writeStartElement() before   any content is written, or after writeEmptyElement().    \sa writeAttribute(), writeNamespace()  */
end_comment
begin_function
DECL|function|writeAttributes
name|void
name|QXmlStreamWriter
operator|::
name|writeAttributes
parameter_list|(
specifier|const
name|QXmlStreamAttributes
modifier|&
name|attributes
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|inStartElement
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attributes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|writeAttribute
argument_list|(
name|attributes
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Writes \a text as CDATA section. If \a text contains the   forbidden character sequence "]]>", it is split into different CDATA   sections.    This function mainly exists for completeness. Normally you should   not need use it, because writeCharacters() automatically escapes all   non-content characters.  */
end_comment
begin_function
DECL|function|writeCDATA
name|void
name|QXmlStreamWriter
operator|::
name|writeCDATA
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|d
operator|->
name|finishStartElement
argument_list|()
expr_stmt|;
name|QString
name|copy
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|copy
operator|.
name|replace
argument_list|(
name|QLatin1String
argument_list|(
literal|"]]>"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"]]]]><![CDATA[>"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"<![CDATA["
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"]]>"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Writes \a text. The characters "<", "&", and "\"" are escaped as entity   references "&lt;", "&amp;, and "&quot;". To avoid the forbidden sequence   "]]>", ">" is also escaped as "&gt;".    \sa writeEntityReference()  */
end_comment
begin_function
DECL|function|writeCharacters
name|void
name|QXmlStreamWriter
operator|::
name|writeCharacters
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|d
operator|->
name|finishStartElement
argument_list|()
expr_stmt|;
name|d
operator|->
name|writeEscaped
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Writes \a text as XML comment, where \a text must not contain the      forbidden sequence "--" or end with "-". Note that XML does not      provide any way to escape "-" in a comment.  */
end_comment
begin_function
DECL|function|writeComment
name|void
name|QXmlStreamWriter
operator|::
name|writeComment
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|text
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"--"
argument_list|)
argument_list|)
operator|&&
operator|!
name|text
operator|.
name|endsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|finishStartElement
argument_list|(
literal|false
argument_list|)
operator|&&
name|d
operator|->
name|autoFormatting
condition|)
name|d
operator|->
name|indent
argument_list|(
name|d
operator|->
name|tagStack
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"<!--"
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"-->"
argument_list|)
expr_stmt|;
name|d
operator|->
name|inStartElement
operator|=
name|d
operator|->
name|lastWasStartElement
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Writes a DTD section. The \a dtd represents the entire   doctypedecl production from the XML 1.0 specification.  */
end_comment
begin_function
DECL|function|writeDTD
name|void
name|QXmlStreamWriter
operator|::
name|writeDTD
parameter_list|(
specifier|const
name|QString
modifier|&
name|dtd
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|d
operator|->
name|finishStartElement
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|autoFormatting
condition|)
name|d
operator|->
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
name|dtd
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|autoFormatting
condition|)
name|d
operator|->
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  \overload   Writes an empty element with qualified name \a qualifiedName.   Subsequent calls to writeAttribute() will add attributes to this element. */
end_comment
begin_function
DECL|function|writeEmptyElement
name|void
name|QXmlStreamWriter
operator|::
name|writeEmptyElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|qualifiedName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|qualifiedName
operator|.
name|count
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
operator|<=
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeStartElement
argument_list|(
name|QString
argument_list|()
argument_list|,
name|qualifiedName
argument_list|)
expr_stmt|;
name|d
operator|->
name|inEmptyElement
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Writes an empty element with \a name, prefixed for the specified   \a namespaceUri. If the namespace has not been declared,   QXmlStreamWriter will generate a namespace declaration for it.   Subsequent calls to writeAttribute() will add attributes to this element.    \sa writeNamespace()  */
end_comment
begin_function
DECL|function|writeEmptyElement
name|void
name|QXmlStreamWriter
operator|::
name|writeEmptyElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|name
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeStartElement
argument_list|(
name|namespaceUri
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|d
operator|->
name|inEmptyElement
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\overload   Writes a text element with \a qualifiedName and \a text.     This is a convenience function equivalent to:   \snippet code/src_corelib_xml_qxmlstream.cpp 1  */
end_comment
begin_function
DECL|function|writeTextElement
name|void
name|QXmlStreamWriter
operator|::
name|writeTextElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|qualifiedName
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|writeStartElement
argument_list|(
name|qualifiedName
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|writeEndElement
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Writes a text element with \a name, prefixed for the specified \a      namespaceUri, and \a text. If the namespace has not been      declared, QXmlStreamWriter will generate a namespace declaration      for it.     This is a convenience function equivalent to:   \snippet code/src_corelib_xml_qxmlstream.cpp 2  */
end_comment
begin_function
DECL|function|writeTextElement
name|void
name|QXmlStreamWriter
operator|::
name|writeTextElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|writeStartElement
argument_list|(
name|namespaceUri
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|writeCharacters
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|writeEndElement
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Closes all remaining open start elements and writes a newline.    \sa writeStartDocument()  */
end_comment
begin_function
DECL|function|writeEndDocument
name|void
name|QXmlStreamWriter
operator|::
name|writeEndDocument
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|tagStack
operator|.
name|size
argument_list|()
condition|)
name|writeEndElement
argument_list|()
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Closes the previous start element.    \sa writeStartElement()  */
end_comment
begin_function
DECL|function|writeEndElement
name|void
name|QXmlStreamWriter
operator|::
name|writeEndElement
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tagStack
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// shortcut: if nothing was written, close as empty tag
if|if
condition|(
name|d
operator|->
name|inStartElement
operator|&&
operator|!
name|d
operator|->
name|inEmptyElement
condition|)
block|{
name|d
operator|->
name|write
argument_list|(
literal|"/>"
argument_list|)
expr_stmt|;
name|d
operator|->
name|lastWasStartElement
operator|=
name|d
operator|->
name|inStartElement
operator|=
literal|false
expr_stmt|;
name|QXmlStreamWriterPrivate
operator|::
name|Tag
modifier|&
name|tag
init|=
name|d
operator|->
name|tagStack_pop
argument_list|()
decl_stmt|;
name|d
operator|->
name|lastNamespaceDeclaration
operator|=
name|tag
operator|.
name|namespaceDeclarationsSize
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|finishStartElement
argument_list|(
literal|false
argument_list|)
operator|&&
operator|!
name|d
operator|->
name|lastWasStartElement
operator|&&
name|d
operator|->
name|autoFormatting
condition|)
name|d
operator|->
name|indent
argument_list|(
name|d
operator|->
name|tagStack
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tagStack
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|d
operator|->
name|lastWasStartElement
operator|=
literal|false
expr_stmt|;
name|QXmlStreamWriterPrivate
operator|::
name|Tag
modifier|&
name|tag
init|=
name|d
operator|->
name|tagStack_pop
argument_list|()
decl_stmt|;
name|d
operator|->
name|lastNamespaceDeclaration
operator|=
name|tag
operator|.
name|namespaceDeclarationsSize
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"</"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag
operator|.
name|namespaceDeclaration
operator|.
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|write
argument_list|(
name|tag
operator|.
name|namespaceDeclaration
operator|.
name|prefix
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|write
argument_list|(
name|tag
operator|.
name|name
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Writes the entity reference \a name to the stream, as "&\a{name};".  */
end_comment
begin_function
DECL|function|writeEntityReference
name|void
name|QXmlStreamWriter
operator|::
name|writeEntityReference
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|d
operator|->
name|finishStartElement
argument_list|()
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Writes a namespace declaration for \a namespaceUri with \a   prefix. If \a prefix is empty, QXmlStreamWriter assigns a unique   prefix consisting of the letter 'n' followed by a number.    If writeStartElement() or writeEmptyElement() was called, the   declaration applies to the current element; otherwise it applies to   the next child element.    Note that the prefix \e xml is both predefined and reserved for   \e http://www.w3.org/XML/1998/namespace, which in turn cannot be   bound to any other prefix. The prefix \e xmlns and its URI   \e http://www.w3.org/2000/xmlns/ are used for the namespace mechanism   itself and thus completely forbidden in declarations.   */
end_comment
begin_function
DECL|function|writeNamespace
name|void
name|QXmlStreamWriter
operator|::
name|writeNamespace
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|,
specifier|const
name|QString
modifier|&
name|prefix
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|namespaceUri
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|prefix
operator|!=
name|QLatin1String
argument_list|(
literal|"xmlns"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|findNamespace
argument_list|(
name|namespaceUri
argument_list|,
name|d
operator|->
name|inStartElement
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_ASSERT
argument_list|(
operator|!
operator|(
operator|(
name|prefix
operator|==
name|QLatin1String
argument_list|(
literal|"xml"
argument_list|)
operator|)
operator|^
operator|(
name|namespaceUri
operator|==
name|QLatin1String
argument_list|(
literal|"http://www.w3.org/XML/1998/namespace"
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|namespaceUri
operator|!=
name|QLatin1String
argument_list|(
literal|"http://www.w3.org/2000/xmlns/"
argument_list|)
argument_list|)
expr_stmt|;
name|QXmlStreamWriterPrivate
operator|::
name|NamespaceDeclaration
modifier|&
name|namespaceDeclaration
init|=
name|d
operator|->
name|namespaceDeclarations
operator|.
name|push
argument_list|()
decl_stmt|;
name|namespaceDeclaration
operator|.
name|prefix
operator|=
name|d
operator|->
name|addToStringStorage
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|namespaceDeclaration
operator|.
name|namespaceUri
operator|=
name|d
operator|->
name|addToStringStorage
argument_list|(
name|namespaceUri
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|inStartElement
condition|)
name|d
operator|->
name|writeNamespaceDeclaration
argument_list|(
name|namespaceDeclaration
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! Writes a default namespace declaration for \a namespaceUri.    If writeStartElement() or writeEmptyElement() was called, the   declaration applies to the current element; otherwise it applies to   the next child element.    Note that the namespaces \e http://www.w3.org/XML/1998/namespace   (bound to \e xmlns) and \e http://www.w3.org/2000/xmlns/ (bound to   \e xml) by definition cannot be declared as default.  */
end_comment
begin_function
DECL|function|writeDefaultNamespace
name|void
name|QXmlStreamWriter
operator|::
name|writeDefaultNamespace
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|namespaceUri
operator|!=
name|QLatin1String
argument_list|(
literal|"http://www.w3.org/XML/1998/namespace"
argument_list|)
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|namespaceUri
operator|!=
name|QLatin1String
argument_list|(
literal|"http://www.w3.org/2000/xmlns/"
argument_list|)
argument_list|)
expr_stmt|;
name|QXmlStreamWriterPrivate
operator|::
name|NamespaceDeclaration
modifier|&
name|namespaceDeclaration
init|=
name|d
operator|->
name|namespaceDeclarations
operator|.
name|push
argument_list|()
decl_stmt|;
name|namespaceDeclaration
operator|.
name|prefix
operator|.
name|clear
argument_list|()
expr_stmt|;
name|namespaceDeclaration
operator|.
name|namespaceUri
operator|=
name|d
operator|->
name|addToStringStorage
argument_list|(
name|namespaceUri
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|inStartElement
condition|)
name|d
operator|->
name|writeNamespaceDeclaration
argument_list|(
name|namespaceDeclaration
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Writes an XML processing instruction with \a target and \a data,   where \a data must not contain the sequence "?>".  */
end_comment
begin_function
DECL|function|writeProcessingInstruction
name|void
name|QXmlStreamWriter
operator|::
name|writeProcessingInstruction
parameter_list|(
specifier|const
name|QString
modifier|&
name|target
parameter_list|,
specifier|const
name|QString
modifier|&
name|data
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|data
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"?>"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|finishStartElement
argument_list|(
literal|false
argument_list|)
operator|&&
name|d
operator|->
name|autoFormatting
condition|)
name|d
operator|->
name|indent
argument_list|(
name|d
operator|->
name|tagStack
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"<?"
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|d
operator|->
name|write
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|write
argument_list|(
literal|"?>"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\overload    Writes a document start with XML version number "1.0". This also   writes the encoding information.    \sa writeEndDocument(), setCodec()   \since 4.5  */
end_comment
begin_function
DECL|function|writeStartDocument
name|void
name|QXmlStreamWriter
operator|::
name|writeStartDocument
parameter_list|()
block|{
name|writeStartDocument
argument_list|(
name|QLatin1String
argument_list|(
literal|"1.0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Writes a document start with the XML version number \a version.    \sa writeEndDocument()  */
end_comment
begin_function
DECL|function|writeStartDocument
name|void
name|QXmlStreamWriter
operator|::
name|writeStartDocument
parameter_list|(
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|d
operator|->
name|finishStartElement
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"<?xml version=\""
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|device
condition|)
block|{
comment|// stringDevice does not get any encoding
name|d
operator|->
name|write
argument_list|(
literal|"\" encoding=\""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_NO_TEXTCODEC
name|d
operator|->
name|write
argument_list|(
literal|"iso-8859-1"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|const
name|QByteArray
name|name
init|=
name|d
operator|->
name|codec
operator|->
name|name
argument_list|()
decl_stmt|;
name|d
operator|->
name|write
argument_list|(
name|name
operator|.
name|constData
argument_list|()
argument_list|,
name|name
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|d
operator|->
name|write
argument_list|(
literal|"\"?>"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Writes a document start with the XML version number \a version   and a standalone attribute \a standalone.    \sa writeEndDocument()   \since 4.5  */
end_comment
begin_function
DECL|function|writeStartDocument
name|void
name|QXmlStreamWriter
operator|::
name|writeStartDocument
parameter_list|(
specifier|const
name|QString
modifier|&
name|version
parameter_list|,
name|bool
name|standalone
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|d
operator|->
name|finishStartElement
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
literal|"<?xml version=\""
argument_list|)
expr_stmt|;
name|d
operator|->
name|write
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|device
condition|)
block|{
comment|// stringDevice does not get any encoding
name|d
operator|->
name|write
argument_list|(
literal|"\" encoding=\""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_NO_TEXTCODEC
name|d
operator|->
name|write
argument_list|(
literal|"iso-8859-1"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|const
name|QByteArray
name|name
init|=
name|d
operator|->
name|codec
operator|->
name|name
argument_list|()
decl_stmt|;
name|d
operator|->
name|write
argument_list|(
name|name
operator|.
name|constData
argument_list|()
argument_list|,
name|name
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|standalone
condition|)
name|d
operator|->
name|write
argument_list|(
literal|"\" standalone=\"yes\"?>"
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|write
argument_list|(
literal|"\" standalone=\"no\"?>"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!\overload     Writes a start element with \a qualifiedName. Subsequent calls to    writeAttribute() will add attributes to this element.     \sa writeEndElement(), writeEmptyElement()  */
end_comment
begin_function
DECL|function|writeStartElement
name|void
name|QXmlStreamWriter
operator|::
name|writeStartElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|qualifiedName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|qualifiedName
operator|.
name|count
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
operator|<=
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeStartElement
argument_list|(
name|QString
argument_list|()
argument_list|,
name|qualifiedName
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!  Writes a start element with \a name, prefixed for the specified   \a namespaceUri. If the namespace has not been declared yet,   QXmlStreamWriter will generate a namespace declaration for   it. Subsequent calls to writeAttribute() will add attributes to this   element.    \sa writeNamespace(), writeEndElement(), writeEmptyElement()  */
end_comment
begin_function
DECL|function|writeStartElement
name|void
name|QXmlStreamWriter
operator|::
name|writeStartElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QXmlStreamWriter
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|name
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeStartElement
argument_list|(
name|namespaceUri
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|writeStartElement
name|void
name|QXmlStreamWriterPrivate
operator|::
name|writeStartElement
parameter_list|(
specifier|const
name|QString
modifier|&
name|namespaceUri
parameter_list|,
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|finishStartElement
argument_list|(
literal|false
argument_list|)
operator|&&
name|autoFormatting
condition|)
name|indent
argument_list|(
name|tagStack
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Tag
modifier|&
name|tag
init|=
name|tagStack_push
argument_list|()
decl_stmt|;
name|tag
operator|.
name|name
operator|=
name|addToStringStorage
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|tag
operator|.
name|namespaceDeclaration
operator|=
name|findNamespace
argument_list|(
name|namespaceUri
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag
operator|.
name|namespaceDeclaration
operator|.
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|write
argument_list|(
name|tag
operator|.
name|namespaceDeclaration
operator|.
name|prefix
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
name|write
argument_list|(
name|tag
operator|.
name|name
argument_list|)
expr_stmt|;
name|inStartElement
operator|=
name|lastWasStartElement
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|lastNamespaceDeclaration
init|;
name|i
operator|<
name|namespaceDeclarations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|writeNamespaceDeclaration
argument_list|(
name|namespaceDeclarations
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tag
operator|.
name|namespaceDeclarationsSize
operator|=
name|lastNamespaceDeclaration
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_XMLSTREAMREADER
end_ifndef
begin_comment
comment|/*!  Writes the current state of the \a reader. All possible valid   states are supported.    The purpose of this function is to support chained processing of XML data.    \sa QXmlStreamReader::tokenType()  */
end_comment
begin_function
DECL|function|writeCurrentToken
name|void
name|QXmlStreamWriter
operator|::
name|writeCurrentToken
parameter_list|(
specifier|const
name|QXmlStreamReader
modifier|&
name|reader
parameter_list|)
block|{
switch|switch
condition|(
name|reader
operator|.
name|tokenType
argument_list|()
condition|)
block|{
case|case
name|QXmlStreamReader
operator|::
name|NoToken
case|:
break|break;
case|case
name|QXmlStreamReader
operator|::
name|StartDocument
case|:
name|writeStartDocument
argument_list|()
expr_stmt|;
break|break;
case|case
name|QXmlStreamReader
operator|::
name|EndDocument
case|:
name|writeEndDocument
argument_list|()
expr_stmt|;
break|break;
case|case
name|QXmlStreamReader
operator|::
name|StartElement
case|:
block|{
name|QXmlStreamNamespaceDeclarations
name|namespaceDeclarations
init|=
name|reader
operator|.
name|namespaceDeclarations
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|namespaceDeclarations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QXmlStreamNamespaceDeclaration
modifier|&
name|namespaceDeclaration
init|=
name|namespaceDeclarations
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|writeNamespace
argument_list|(
name|namespaceDeclaration
operator|.
name|namespaceUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|namespaceDeclaration
operator|.
name|prefix
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writeStartElement
argument_list|(
name|reader
operator|.
name|namespaceUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|reader
operator|.
name|name
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|writeAttributes
argument_list|(
name|reader
operator|.
name|attributes
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QXmlStreamReader
operator|::
name|EndElement
case|:
name|writeEndElement
argument_list|()
expr_stmt|;
break|break;
case|case
name|QXmlStreamReader
operator|::
name|Characters
case|:
if|if
condition|(
name|reader
operator|.
name|isCDATA
argument_list|()
condition|)
name|writeCDATA
argument_list|(
name|reader
operator|.
name|text
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|writeCharacters
argument_list|(
name|reader
operator|.
name|text
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QXmlStreamReader
operator|::
name|Comment
case|:
name|writeComment
argument_list|(
name|reader
operator|.
name|text
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QXmlStreamReader
operator|::
name|DTD
case|:
name|writeDTD
argument_list|(
name|reader
operator|.
name|text
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QXmlStreamReader
operator|::
name|EntityReference
case|:
name|writeEntityReference
argument_list|(
name|reader
operator|.
name|name
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QXmlStreamReader
operator|::
name|ProcessingInstruction
case|:
name|writeProcessingInstruction
argument_list|(
name|reader
operator|.
name|processingInstructionTarget
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|reader
operator|.
name|processingInstructionData
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Q_ASSERT
argument_list|(
name|reader
operator|.
name|tokenType
argument_list|()
operator|!=
name|QXmlStreamReader
operator|::
name|Invalid
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"QXmlStreamWriter: writeCurrentToken() with invalid state."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!  \fn bool QXmlStreamAttributes::hasAttribute(const QString&qualifiedName) const  \since 4.5   Returns \c true if this QXmlStreamAttributes has an attribute whose  qualified name is \a qualifiedName; otherwise returns \c false.   Note that this is not namespace aware. For instance, if this  QXmlStreamAttributes contains an attribute whose lexical name is "xlink:href"  this doesn't tell that an attribute named \c href in the XLink namespace is  present, since the \c xlink prefix can be bound to any namespace. Use the  overload that takes a namespace URI and a local name as parameter, for  namespace aware code. */
end_comment
begin_comment
comment|/*!  \fn bool QXmlStreamAttributes::hasAttribute(QLatin1String qualifiedName) const  \overload  \since 4.5 */
end_comment
begin_comment
comment|/*!  \fn bool QXmlStreamAttributes::hasAttribute(const QString&namespaceUri,                                              const QString&name) const  \overload  \since 4.5   Returns \c true if this QXmlStreamAttributes has an attribute whose  namespace URI and name correspond to \a namespaceUri and \a name;  otherwise returns \c false. */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_XMLSTREAMREADER
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_XMLSTREAMWRITER
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_XMLSTREAM
end_comment
end_unit
