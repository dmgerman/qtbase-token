begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"quuid.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qendian.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_include
include|#
directive|include
file|"qcryptographichash.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
specifier|template
type|<class
name|Char
operator|,
name|class
name|Integral
decl_stmt|> void _q_toHex(Char *&dst
DECL|function|_q_toHex
operator|,
decl_stmt|Integral value
end_function
begin_block
unit|)
block|{
specifier|static
specifier|const
name|char
name|digits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|value
operator|=
name|qToBigEndian
argument_list|(
name|value
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|value
argument_list|)
decl_stmt|;
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|Integral
argument_list|)
condition|;
operator|++
name|i
operator|,
name|dst
operator|+=
literal|2
control|)
block|{
name|uint
name|j
init|=
operator|(
name|p
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
decl_stmt|;
name|dst
index|[
literal|0
index|]
operator|=
name|Char
argument_list|(
name|digits
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
name|p
index|[
name|i
index|]
operator|&
literal|0xf
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
name|Char
argument_list|(
name|digits
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_function
template|template
parameter_list|<
name|class
name|Char
parameter_list|,
name|class
name|Integral
parameter_list|>
DECL|function|_q_fromHex
name|bool
name|_q_fromHex
parameter_list|(
specifier|const
name|Char
modifier|*
modifier|&
name|src
parameter_list|,
name|Integral
modifier|&
name|value
parameter_list|)
block|{
name|value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|Integral
argument_list|)
operator|*
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|int
name|ch
init|=
operator|*
name|src
operator|++
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|tmp
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
name|tmp
operator|=
name|ch
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
name|tmp
operator|=
name|ch
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
return|return
literal|false
return|;
name|value
operator|=
name|value
operator|*
literal|16
operator|+
name|tmp
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_decl_stmt
template|template
parameter_list|<
name|class
name|Char
parameter_list|>
DECL|function|_q_uuidToHex
name|void
name|_q_uuidToHex
argument_list|(
name|Char
operator|*
operator|&
name|dst
argument_list|,
specifier|const
name|uint
operator|&
name|d1
argument_list|,
specifier|const
name|ushort
operator|&
name|d2
argument_list|,
specifier|const
name|ushort
operator|&
name|d3
argument_list|,
specifier|const
name|uchar
argument_list|(
operator|&
name|d4
argument_list|)
index|[
literal|8
index|]
argument_list|)
argument_list|{
operator|*
name|dst
operator|++
operator|=
name|Char
argument_list|(
literal|'{'
argument_list|)
argument_list|;
name|_q_toHex
argument_list|(
name|dst
argument_list|,
name|d1
argument_list|)
argument_list|;
operator|*
name|dst
operator|++
operator|=
name|Char
argument_list|(
literal|'-'
argument_list|)
argument_list|;
name|_q_toHex
argument_list|(
name|dst
argument_list|,
name|d2
argument_list|)
argument_list|;
operator|*
name|dst
operator|++
operator|=
name|Char
argument_list|(
literal|'-'
argument_list|)
argument_list|;
name|_q_toHex
argument_list|(
name|dst
argument_list|,
name|d3
argument_list|)
argument_list|;
operator|*
name|dst
operator|++
operator|=
name|Char
argument_list|(
literal|'-'
argument_list|)
argument_list|;     for
operator|(
name|int
name|i
operator|=
literal|0
expr|;
name|i
operator|<
literal|2
expr|;
name|i
operator|++
operator|)
name|_q_toHex
argument_list|(
name|dst
argument_list|,
name|d4
index|[
name|i
index|]
argument_list|)
argument_list|;
operator|*
name|dst
operator|++
operator|=
name|Char
argument_list|(
literal|'-'
argument_list|)
argument_list|;     for
operator|(
name|int
name|i
operator|=
literal|2
expr|;
name|i
operator|<
literal|8
expr|;
name|i
operator|++
operator|)
name|_q_toHex
argument_list|(
name|dst
argument_list|,
name|d4
index|[
name|i
index|]
argument_list|)
argument_list|;
operator|*
name|dst
operator|=
name|Char
argument_list|(
literal|'}'
argument_list|)
argument_list|; }
decl|template
decl|<
name|class
name|Char
decl|>
DECL|function|_q_uuidFromHex
name|bool
name|_q_uuidFromHex
argument_list|(
specifier|const
name|Char
operator|*
operator|&
name|src
argument_list|,
name|uint
operator|&
name|d1
argument_list|,
name|ushort
operator|&
name|d2
argument_list|,
name|ushort
operator|&
name|d3
argument_list|,
name|uchar
argument_list|(
operator|&
name|d4
argument_list|)
index|[
literal|8
index|]
argument_list|)
argument_list|{     if
operator|(
operator|*
name|src
operator|==
name|Char
argument_list|(
literal|'{'
argument_list|)
operator|)
name|src
operator|++
argument_list|;     if
operator|(
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d1
argument_list|)
operator|||
operator|*
name|src
operator|++
operator|!=
name|Char
argument_list|(
literal|'-'
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d2
argument_list|)
operator|||
operator|*
name|src
operator|++
operator|!=
name|Char
argument_list|(
literal|'-'
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d3
argument_list|)
operator|||
operator|*
name|src
operator|++
operator|!=
name|Char
argument_list|(
literal|'-'
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|1
index|]
argument_list|)
operator|||
operator|*
name|src
operator|++
operator|!=
name|Char
argument_list|(
literal|'-'
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|3
index|]
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|4
index|]
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|5
index|]
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|6
index|]
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|7
index|]
argument_list|)
operator|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
end_decl_stmt
begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_function
unit|static
DECL|function|createFromName
name|QUuid
name|createFromName
parameter_list|(
specifier|const
name|QUuid
modifier|&
name|ns
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|baseData
parameter_list|,
name|QCryptographicHash
operator|::
name|Algorithm
name|algorithm
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|QByteArray
name|hashResult
decl_stmt|;
comment|// create a scope so later resize won't reallocate
block|{
name|QCryptographicHash
name|hash
argument_list|(
name|algorithm
argument_list|)
decl_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|ns
operator|.
name|toRfc4122
argument_list|()
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|baseData
argument_list|)
expr_stmt|;
name|hashResult
operator|=
name|hash
operator|.
name|result
argument_list|()
expr_stmt|;
block|}
name|hashResult
operator|.
name|resize
argument_list|(
literal|16
argument_list|)
expr_stmt|;
comment|// Sha1 will be too long
name|QUuid
name|result
init|=
name|QUuid
operator|::
name|fromRfc4122
argument_list|(
name|hashResult
argument_list|)
decl_stmt|;
name|result
operator|.
name|data3
operator|&=
literal|0x0FFF
expr_stmt|;
name|result
operator|.
name|data3
operator||=
operator|(
name|version
operator|<<
literal|12
operator|)
expr_stmt|;
name|result
operator|.
name|data4
index|[
literal|0
index|]
operator|&=
literal|0x3F
expr_stmt|;
name|result
operator|.
name|data4
index|[
literal|0
index|]
operator||=
literal|0x80
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \class QUuid     \inmodule QtCore     \brief The QUuid class stores a Universally Unique Identifier (UUID).      \reentrant      Using \e{U}niversally \e{U}nique \e{ID}entifiers (UUID) is a     standard way to uniquely identify entities in a distributed     computing environment. A UUID is a 16-byte (128-bit) number     generated by some algorithm that is meant to guarantee that the     UUID will be unique in the distributed computing environment where     it is used. The acronym GUID is often used instead, \e{G}lobally     \e{U}nique \e{ID}entifiers, but it refers to the same thing.      \target Variant field     Actually, the GUID is one \e{variant} of UUID. Multiple variants     are in use. Each UUID contains a bit field that specifies which     type (variant) of UUID it is. Call variant() to discover which     type of UUID an instance of QUuid contains. It extracts the three     most significant bits of byte 8 of the 16 bytes. In QUuid, byte 8     is \c{QUuid::data4[0]}. If you create instances of QUuid using the     constructor that accepts all the numeric values as parameters, use     the following table to set the three most significant bits of     parameter \c{b1}, which becomes \c{QUuid::data4[0]} and contains     the variant field in its three most significant bits. In the     table, 'x' means \e {don't care}.      \table     \header     \li msb0     \li msb1     \li msb2     \li Variant      \row     \li 0     \li x     \li x     \li NCS (Network Computing System)      \row     \li 1     \li 0     \li x     \li DCE (Distributed Computing Environment)      \row     \li 1     \li 1     \li 0     \li Microsoft (GUID)      \row     \li 1     \li 1     \li 1     \li Reserved for future expansion      \endtable      \target Version field     If variant() returns QUuid::DCE, the UUID also contains a     \e{version} field in the four most significant bits of     \c{QUuid::data3}, and you can call version() to discover which     version your QUuid contains. If you create instances of QUuid     using the constructor that accepts all the numeric values as     parameters, use the following table to set the four most     significant bits of parameter \c{w2}, which becomes     \c{QUuid::data3} and contains the version field in its four most     significant bits.      \table     \header     \li msb0     \li msb1     \li msb2     \li msb3     \li Version      \row     \li 0     \li 0     \li 0     \li 1     \li Time      \row     \li 0     \li 0     \li 1     \li 0     \li Embedded POSIX      \row     \li 0     \li 0     \li 1     \li 1     \li Md5(Name)      \row     \li 0     \li 1     \li 0     \li 0     \li Random      \row     \li 0     \li 1     \li 0     \li 1     \li Sha1      \endtable      The field layouts for the DCE versions listed in the table above     are specified in the \l{http://www.ietf.org/rfc/rfc4122.txt}     {Network Working Group UUID Specification}.      Most platforms provide a tool for generating new UUIDs, e.g. \c     uuidgen and \c guidgen. You can also use createUuid().  UUIDs     generated by createUuid() are of the random type.  Their     QUuid::Version bits are set to QUuid::Random, and their     QUuid::Variant bits are set to QUuid::DCE. The rest of the UUID is     composed of random numbers. Theoretically, this means there is a     small chance that a UUID generated by createUuid() will not be     unique. But it is     \l{http://en.wikipedia.org/wiki/Universally_Unique_Identifier#Random_UUID_probability_of_duplicates}     {a \e{very} small chance}.      UUIDs can be constructed from numeric values or from strings, or     using the static createUuid() function. They can be converted to a     string with toString(). UUIDs have a variant() and a version(),     and null UUIDs return true from isNull(). */
end_comment
begin_comment
comment|/*!     \fn QUuid::QUuid(const GUID&guid)      Casts a Windows \a guid to a Qt QUuid.      \warning This function is only for Windows platforms. */
end_comment
begin_comment
comment|/*!     \fn QUuid&QUuid::operator=(const GUID&guid)      Assigns a Windows \a guid to a Qt QUuid.      \warning This function is only for Windows platforms. */
end_comment
begin_comment
comment|/*!     \fn QUuid::operator GUID() const      Returns a Windows GUID from a QUuid.      \warning This function is only for Windows platforms. */
end_comment
begin_comment
comment|/*!     \fn QUuid::QUuid()      Creates the null UUID. toString() will output the null UUID     as "{00000000-0000-0000-0000-000000000000}". */
end_comment
begin_comment
comment|/*!     \fn QUuid::QUuid(uint l, ushort w1, ushort w2, uchar b1, uchar b2, uchar b3, uchar b4, uchar b5, uchar b6, uchar b7, uchar b8)      Creates a UUID with the value specified by the parameters, \a l,     \a w1, \a w2, \a b1, \a b2, \a b3, \a b4, \a b5, \a b6, \a b7, \a     b8.      Example:     \snippet code/src_corelib_plugin_quuid.cpp 0 */
end_comment
begin_comment
comment|/*!   Creates a QUuid object from the string \a text, which must be   formatted as five hex fields separated by '-', e.g.,   "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" where 'x' is a hex   digit. The curly braces shown here are optional, but it is normal to   include them. If the conversion fails, a null UUID is created.  See   toString() for an explanation of how the five hex fields map to the   public data members in QUuid.      \sa toString(), QUuid() */
end_comment
begin_constructor
DECL|function|QUuid
name|QUuid
operator|::
name|QUuid
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
if|if
condition|(
name|text
operator|.
name|length
argument_list|()
operator|<
literal|36
condition|)
block|{
operator|*
name|this
operator|=
name|QUuid
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|const
name|ushort
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|text
operator|.
name|unicode
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
literal|'{'
operator|&&
name|text
operator|.
name|length
argument_list|()
operator|<
literal|37
condition|)
block|{
operator|*
name|this
operator|=
name|QUuid
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|_q_uuidFromHex
argument_list|(
name|data
argument_list|,
name|data1
argument_list|,
name|data2
argument_list|,
name|data3
argument_list|,
name|data4
argument_list|)
condition|)
block|{
operator|*
name|this
operator|=
name|QUuid
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QUuid
name|QUuid
operator|::
name|QUuid
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|)
block|{
if|if
condition|(
operator|!
name|text
condition|)
block|{
operator|*
name|this
operator|=
name|QUuid
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|_q_uuidFromHex
argument_list|(
name|text
argument_list|,
name|data1
argument_list|,
name|data2
argument_list|,
name|data3
argument_list|,
name|data4
argument_list|)
condition|)
block|{
operator|*
name|this
operator|=
name|QUuid
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
end_constructor
begin_comment
comment|/*!   Creates a QUuid object from the QByteArray \a text, which must be   formatted as five hex fields separated by '-', e.g.,   "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" where 'x' is a hex   digit. The curly braces shown here are optional, but it is normal to   include them. If the conversion fails, a null UUID is created.  See   toByteArray() for an explanation of how the five hex fields map to the   public data members in QUuid.      \since 4.8      \sa toByteArray(), QUuid() */
end_comment
begin_constructor
DECL|function|QUuid
name|QUuid
operator|::
name|QUuid
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|text
parameter_list|)
block|{
if|if
condition|(
name|text
operator|.
name|length
argument_list|()
operator|<
literal|36
condition|)
block|{
operator|*
name|this
operator|=
name|QUuid
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|const
name|char
modifier|*
name|data
init|=
name|text
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
literal|'{'
operator|&&
name|text
operator|.
name|length
argument_list|()
operator|<
literal|37
condition|)
block|{
operator|*
name|this
operator|=
name|QUuid
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|_q_uuidFromHex
argument_list|(
name|data
argument_list|,
name|data1
argument_list|,
name|data2
argument_list|,
name|data3
argument_list|,
name|data4
argument_list|)
condition|)
block|{
operator|*
name|this
operator|=
name|QUuid
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
end_constructor
begin_comment
comment|/*!   \since 5.0   \fn QUuid QUuid::createUuidV3(const QUuid&ns, const QByteArray&baseData);    This function returns a new UUID with variant QUuid::DCE and version QUuid::Md5.   \a ns is the namespace and \a baseData is the basic data as described by RFC 4122.    \sa variant(), version(), createUuidV5() */
end_comment
begin_comment
comment|/*!   \since 5.0   \fn QUuid QUuid::createUuidV3(const QUuid&ns, const QString&baseData);    This function returns a new UUID with variant QUuid::DCE and version QUuid::Md5.   \a ns is the namespace and \a baseData is the basic data as described by RFC 4122.    \sa variant(), version(), createUuidV5() */
end_comment
begin_comment
comment|/*!   \since 5.0   \fn QUuid QUuid::createUuidV5(const QUuid&ns, const QByteArray&baseData);    This function returns a new UUID with variant QUuid::DCE and version QUuid::Sha1.   \a ns is the namespace and \a baseData is the basic data as described by RFC 4122.    \sa variant(), version(), createUuidV3() */
end_comment
begin_comment
comment|/*!   \since 5.0   \fn QUuid QUuid::createUuidV5(const QUuid&ns, const QString&baseData);    This function returns a new UUID with variant QUuid::DCE and version QUuid::Sha1.   \a ns is the namespace and \a baseData is the basic data as described by RFC 4122.    \sa variant(), version(), createUuidV3() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
end_ifndef
begin_function
DECL|function|createUuidV3
name|QUuid
name|QUuid
operator|::
name|createUuidV3
parameter_list|(
specifier|const
name|QUuid
modifier|&
name|ns
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|baseData
parameter_list|)
block|{
return|return
name|createFromName
argument_list|(
name|ns
argument_list|,
name|baseData
argument_list|,
name|QCryptographicHash
operator|::
name|Md5
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|createUuidV5
name|QUuid
name|QUuid
operator|::
name|createUuidV5
parameter_list|(
specifier|const
name|QUuid
modifier|&
name|ns
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|baseData
parameter_list|)
block|{
return|return
name|createFromName
argument_list|(
name|ns
argument_list|,
name|baseData
argument_list|,
name|QCryptographicHash
operator|::
name|Sha1
argument_list|,
literal|5
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   Creates a QUuid object from the binary representation of the UUID, as   specified by RFC 4122 section 4.1.2. See toRfc4122() for a further   explanation of the order of \a bytes required.    The byte array accepted is NOT a human readable format.    If the conversion fails, a null UUID is created.      \since 4.8      \sa toRfc4122(), QUuid() */
end_comment
begin_function
DECL|function|fromRfc4122
name|QUuid
name|QUuid
operator|::
name|fromRfc4122
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|.
name|isEmpty
argument_list|()
operator|||
name|bytes
operator|.
name|length
argument_list|()
operator|!=
literal|16
condition|)
return|return
name|QUuid
argument_list|()
return|;
name|uint
name|d1
decl_stmt|;
name|ushort
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|uchar
name|d4
index|[
literal|8
index|]
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|bytes
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|d1
operator|=
name|qFromBigEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
expr_stmt|;
name|d2
operator|=
name|qFromBigEndian
argument_list|<
name|quint16
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|quint16
argument_list|)
expr_stmt|;
name|d3
operator|=
name|qFromBigEndian
argument_list|<
name|quint16
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|quint16
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
name|d4
index|[
name|i
index|]
operator|=
operator|*
operator|(
name|data
operator|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
block|}
return|return
name|QUuid
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|,
name|d3
argument_list|,
name|d4
index|[
literal|0
index|]
argument_list|,
name|d4
index|[
literal|1
index|]
argument_list|,
name|d4
index|[
literal|2
index|]
argument_list|,
name|d4
index|[
literal|3
index|]
argument_list|,
name|d4
index|[
literal|4
index|]
argument_list|,
name|d4
index|[
literal|5
index|]
argument_list|,
name|d4
index|[
literal|6
index|]
argument_list|,
name|d4
index|[
literal|7
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QUuid::operator==(const QUuid&other) const      Returns true if this QUuid and the \a other QUuid are identical;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QUuid::operator!=(const QUuid&other) const      Returns true if this QUuid and the \a other QUuid are different;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     Returns the string representation of this QUuid. The string is     formatted as five hex fields separated by '-' and enclosed in     curly braces, i.e., "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" where     'x' is a hex digit.  From left to right, the five hex fields are     obtained from the four public data members in QUuid as follows:      \table     \header     \li Field #     \li Source      \row     \li 1     \li data1      \row     \li 2     \li data2      \row     \li 3     \li data3      \row     \li 4     \li data4[0] .. data4[1]      \row     \li 5     \li data4[2] .. data4[7]      \endtable */
end_comment
begin_function
DECL|function|toString
name|QString
name|QUuid
operator|::
name|toString
parameter_list|()
specifier|const
block|{
name|QString
name|result
argument_list|(
literal|38
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|ushort
modifier|*
name|data
init|=
operator|(
name|ushort
operator|*
operator|)
name|result
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|_q_uuidToHex
argument_list|(
name|data
argument_list|,
name|data1
argument_list|,
name|data2
argument_list|,
name|data3
argument_list|,
name|data4
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the binary representation of this QUuid. The byte array is     formatted as five hex fields separated by '-' and enclosed in     curly braces, i.e., "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" where     'x' is a hex digit.  From left to right, the five hex fields are     obtained from the four public data members in QUuid as follows:      \table     \header     \li Field #     \li Source      \row     \li 1     \li data1      \row     \li 2     \li data2      \row     \li 3     \li data3      \row     \li 4     \li data4[0] .. data4[1]      \row     \li 5     \li data4[2] .. data4[7]      \endtable      \since 4.8 */
end_comment
begin_function
DECL|function|toByteArray
name|QByteArray
name|QUuid
operator|::
name|toByteArray
parameter_list|()
specifier|const
block|{
name|QByteArray
name|result
argument_list|(
literal|38
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|result
operator|.
name|data
argument_list|()
decl_stmt|;
name|_q_uuidToHex
argument_list|(
name|data
argument_list|,
name|data1
argument_list|,
name|data2
argument_list|,
name|data3
argument_list|,
name|data4
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the binary representation of this QUuid. The byte array is in big     endian format, and formatted according to RFC 4122, section 4.1.2 -     "Layout and byte order".      The order is as follows:      \table     \header     \li Field #     \li Source      \row     \li 1     \li data1      \row     \li 2     \li data2      \row     \li 3     \li data3      \row     \li 4     \li data4[0] .. data4[7]      \endtable      \since 4.8 */
end_comment
begin_function
DECL|function|toRfc4122
name|QByteArray
name|QUuid
operator|::
name|toRfc4122
parameter_list|()
specifier|const
block|{
comment|// we know how many bytes a UUID has, I hope :)
name|QByteArray
name|bytes
argument_list|(
literal|16
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|bytes
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|qToBigEndian
argument_list|(
name|data1
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
expr_stmt|;
name|qToBigEndian
argument_list|(
name|data2
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|quint16
argument_list|)
expr_stmt|;
name|qToBigEndian
argument_list|(
name|data3
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|quint16
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
operator|*
operator|(
name|data
operator|)
operator|=
name|data4
index|[
name|i
index|]
expr_stmt|;
name|data
operator|++
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \relates QUuid     Writes the UUID \a id to the data stream \a s. */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QUuid
modifier|&
name|id
parameter_list|)
block|{
name|QByteArray
name|bytes
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|byteOrder
argument_list|()
operator|==
name|QDataStream
operator|::
name|BigEndian
condition|)
block|{
name|bytes
operator|=
name|id
operator|.
name|toRfc4122
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// we know how many bytes a UUID has, I hope :)
name|bytes
operator|=
name|QByteArray
argument_list|(
literal|16
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
name|bytes
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|qToLittleEndian
argument_list|(
name|id
operator|.
name|data1
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
expr_stmt|;
name|qToLittleEndian
argument_list|(
name|id
operator|.
name|data2
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|quint16
argument_list|)
expr_stmt|;
name|qToLittleEndian
argument_list|(
name|id
operator|.
name|data3
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|quint16
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
operator|*
operator|(
name|data
operator|)
operator|=
name|id
operator|.
name|data4
index|[
name|i
index|]
expr_stmt|;
name|data
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|.
name|writeRawData
argument_list|(
name|bytes
operator|.
name|data
argument_list|()
argument_list|,
literal|16
argument_list|)
operator|!=
literal|16
condition|)
block|{
name|s
operator|.
name|setStatus
argument_list|(
name|QDataStream
operator|::
name|WriteFailed
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QUuid     Reads a UUID from the stream \a s into \a id. */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QUuid
modifier|&
name|id
parameter_list|)
block|{
name|QByteArray
name|bytes
argument_list|(
literal|16
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|readRawData
argument_list|(
name|bytes
operator|.
name|data
argument_list|()
argument_list|,
literal|16
argument_list|)
operator|!=
literal|16
condition|)
block|{
name|s
operator|.
name|setStatus
argument_list|(
name|QDataStream
operator|::
name|ReadPastEnd
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
name|s
operator|.
name|byteOrder
argument_list|()
operator|==
name|QDataStream
operator|::
name|BigEndian
condition|)
block|{
name|id
operator|=
name|QUuid
operator|::
name|fromRfc4122
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|uchar
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|uchar
operator|*
argument_list|>
argument_list|(
name|bytes
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|id
operator|.
name|data1
operator|=
name|qFromLittleEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
expr_stmt|;
name|id
operator|.
name|data2
operator|=
name|qFromLittleEndian
argument_list|<
name|quint16
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|quint16
argument_list|)
expr_stmt|;
name|id
operator|.
name|data3
operator|=
name|qFromLittleEndian
argument_list|<
name|quint16
argument_list|>
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|quint16
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
name|id
operator|.
name|data4
index|[
name|i
index|]
operator|=
operator|*
operator|(
name|data
operator|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*!     Returns true if this is the null UUID     {00000000-0000-0000-0000-000000000000}; otherwise returns false. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QUuid
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
name|data4
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|5
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|6
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|7
index|]
operator|==
literal|0
operator|&&
name|data1
operator|==
literal|0
operator|&&
name|data2
operator|==
literal|0
operator|&&
name|data3
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QUuid::Variant      This enum defines the values used in the \l{Variant field}     {variant field} of the UUID. The value in the variant field     determines the layout of the 128-bit value.      \value VarUnknown Variant is unknown     \value NCS Reserved for NCS (Network Computing System) backward compatibility     \value DCE Distributed Computing Environment, the scheme used by QUuid     \value Microsoft Reserved for Microsoft backward compatibility (GUID)     \value Reserved Reserved for future definition */
end_comment
begin_comment
comment|/*!     \enum QUuid::Version      This enum defines the values used in the \l{Version field}     {version field} of the UUID. The version field is meaningful     only if the value in the \l{Variant field} {variant field}     is QUuid::DCE.      \value VerUnknown Version is unknown     \value Time Time-based, by using timestamp, clock sequence, and     MAC network card address (if available) for the node sections     \value EmbeddedPOSIX DCE Security version, with embedded POSIX UUIDs     \value Name Name-based, by using values from a name for all sections     \value Md5 Alias for Name     \value Random Random-based, by using random numbers for all sections     \value Sha1 */
end_comment
begin_comment
comment|/*!     \fn QUuid::Variant QUuid::variant() const      Returns the value in the \l{Variant field} {variant field} of the     UUID. If the return value is QUuid::DCE, call version() to see     which layout it uses. The null UUID is considered to be of an     unknown variant.      \sa version() */
end_comment
begin_function
DECL|function|variant
name|QUuid
operator|::
name|Variant
name|QUuid
operator|::
name|variant
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|VarUnknown
return|;
comment|// Check the 3 MSB of data4[0]
if|if
condition|(
operator|(
name|data4
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0x00
condition|)
return|return
name|NCS
return|;
elseif|else
if|if
condition|(
operator|(
name|data4
index|[
literal|0
index|]
operator|&
literal|0xC0
operator|)
operator|==
literal|0x80
condition|)
return|return
name|DCE
return|;
elseif|else
if|if
condition|(
operator|(
name|data4
index|[
literal|0
index|]
operator|&
literal|0xE0
operator|)
operator|==
literal|0xC0
condition|)
return|return
name|Microsoft
return|;
elseif|else
if|if
condition|(
operator|(
name|data4
index|[
literal|0
index|]
operator|&
literal|0xE0
operator|)
operator|==
literal|0xE0
condition|)
return|return
name|Reserved
return|;
return|return
name|VarUnknown
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QUuid::Version QUuid::version() const      Returns the \l{Version field} {version field} of the UUID, if the     UUID's \l{Variant field} {variant field} is QUuid::DCE. Otherwise     it returns QUuid::VerUnknown.      \sa variant() */
end_comment
begin_function
DECL|function|version
name|QUuid
operator|::
name|Version
name|QUuid
operator|::
name|version
parameter_list|()
specifier|const
block|{
comment|// Check the 4 MSB of data3
name|Version
name|ver
init|=
call|(
name|Version
call|)
argument_list|(
name|data3
operator|>>
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNull
argument_list|()
operator|||
operator|(
name|variant
argument_list|()
operator|!=
name|DCE
operator|)
operator|||
name|ver
argument_list|<
name|Time
operator|||
name|ver
argument_list|>
name|Sha1
condition|)
return|return
name|VerUnknown
return|;
return|return
name|ver
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QUuid::operator<(const QUuid&other) const      Returns true if this QUuid has the same \l{Variant field}     {variant field} as the \a other QUuid and is lexicographically     \e{before} the \a other QUuid. If the \a other QUuid has a     different variant field, the return value is determined by     comparing the two \l{QUuid::Variant} {variants}.      \sa variant() */
end_comment
begin_define
DECL|macro|ISLESS
define|#
directive|define
name|ISLESS
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
value|if (f1!=f2) return (f1<f2);
end_define
begin_function
DECL|function|operator <
name|bool
name|QUuid
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QUuid
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|variant
argument_list|()
operator|!=
name|other
operator|.
name|variant
argument_list|()
condition|)
return|return
name|variant
argument_list|()
operator|<
name|other
operator|.
name|variant
argument_list|()
return|;
name|ISLESS
argument_list|(
name|data1
argument_list|,
name|other
operator|.
name|data1
argument_list|)
expr_stmt|;
name|ISLESS
argument_list|(
name|data2
argument_list|,
name|other
operator|.
name|data2
argument_list|)
expr_stmt|;
name|ISLESS
argument_list|(
name|data3
argument_list|,
name|other
operator|.
name|data3
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
block|{
name|ISLESS
argument_list|(
name|data4
index|[
name|n
index|]
argument_list|,
name|other
operator|.
name|data4
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QUuid::operator>(const QUuid&other) const      Returns true if this QUuid has the same \l{Variant field}     {variant field} as the \a other QUuid and is lexicographically     \e{after} the \a other QUuid. If the \a other QUuid has a     different variant field, the return value is determined by     comparing the two \l{QUuid::Variant} {variants}.      \sa variant() */
end_comment
begin_define
DECL|macro|ISMORE
define|#
directive|define
name|ISMORE
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
value|if (f1!=f2) return (f1>f2);
end_define
begin_function
DECL|function|operator >
name|bool
name|QUuid
operator|::
name|operator
name|>
parameter_list|(
specifier|const
name|QUuid
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|variant
argument_list|()
operator|!=
name|other
operator|.
name|variant
argument_list|()
condition|)
return|return
name|variant
argument_list|()
operator|>
name|other
operator|.
name|variant
argument_list|()
return|;
name|ISMORE
argument_list|(
name|data1
argument_list|,
name|other
operator|.
name|data1
argument_list|)
expr_stmt|;
name|ISMORE
argument_list|(
name|data2
argument_list|,
name|other
operator|.
name|data2
argument_list|)
expr_stmt|;
name|ISMORE
argument_list|(
name|data3
argument_list|,
name|other
operator|.
name|data3
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
block|{
name|ISMORE
argument_list|(
name|data4
index|[
name|n
index|]
argument_list|,
name|other
operator|.
name|data4
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QUuid QUuid::createUuid()      On any platform other than Windows, this function returns a new     UUID with variant QUuid::DCE and version QUuid::Random.  If     the /dev/urandom device exists, then the numbers used to construct     the UUID will be of cryptographic quality, which will make the UUID     unique.  Otherwise, the numbers of the UUID will be obtained from     the local pseudo-random number generator (qrand(), which is seeded     by qsrand()) which is usually not of cryptograhic quality, which     means that the UUID can't be guaranteed to be unique.      On a Windows platform, a GUID is generated, which almost certainly     \e{will} be unique, on this or any other system, networked or not.      \sa variant(), version() */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
end_if
begin_function
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<objbase.h>
comment|// For CoCreateGuid
name|QT_END_INCLUDE_NAMESPACE
DECL|function|createUuid
name|QUuid
name|QUuid
operator|::
name|createUuid
parameter_list|()
block|{
name|GUID
name|guid
decl_stmt|;
name|CoCreateGuid
argument_list|(
operator|&
name|guid
argument_list|)
expr_stmt|;
name|QUuid
name|result
init|=
name|guid
decl_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|// !Q_OS_WIN32
end_comment
begin_function_decl
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|"qdatetime.h"
include|#
directive|include
file|"qfile.h"
include|#
directive|include
file|"qthreadstorage.h"
include|#
directive|include
file|<stdlib.h>
comment|// for RAND_MAX
name|QT_END_INCLUDE_NAMESPACE
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|Q_GLOBAL_STATIC
parameter_list|(
name|QThreadStorage
argument_list|<
name|QFile
modifier|*
argument_list|>
parameter_list|,
name|devUrandomStorage
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|createUuid
name|QUuid
name|QUuid
operator|::
name|createUuid
parameter_list|()
block|{
name|QUuid
name|result
decl_stmt|;
name|uint
modifier|*
name|data
init|=
operator|&
operator|(
name|result
operator|.
name|data1
operator|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|QFile
modifier|*
name|devUrandom
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
name|devUrandom
operator|=
name|devUrandomStorage
argument_list|()
operator|->
name|localData
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|devUrandom
condition|)
block|{
name|devUrandom
operator|=
operator|new
name|QFile
argument_list|(
name|QLatin1String
argument_list|(
literal|"/dev/urandom"
argument_list|)
argument_list|)
expr_stmt|;
name|devUrandom
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
operator||
name|QIODevice
operator|::
name|Unbuffered
argument_list|)
expr_stmt|;
name|devUrandomStorage
argument_list|()
operator|->
name|setLocalData
argument_list|(
name|devUrandom
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|QFile
name|file
argument_list|(
name|QLatin1String
argument_list|(
literal|"/dev/urandom"
argument_list|)
argument_list|)
decl_stmt|;
name|devUrandom
operator|=
operator|&
name|file
expr_stmt|;
name|devUrandom
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
operator||
name|QIODevice
operator|::
name|Unbuffered
argument_list|)
expr_stmt|;
endif|#
directive|endif
enum|enum
block|{
name|AmountToRead
init|=
literal|4
operator|*
expr|sizeof
operator|(
name|uint
operator|)
block|}
enum|;
if|if
condition|(
name|devUrandom
operator|->
name|isOpen
argument_list|()
operator|&&
name|devUrandom
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|AmountToRead
argument_list|)
operator|==
name|AmountToRead
condition|)
block|{
comment|// we got what we wanted, nothing more to do
empty_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
specifier|static
specifier|const
name|int
name|intbits
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|8
decl_stmt|;
specifier|static
name|int
name|randbits
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|randbits
condition|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|int
name|max
init|=
name|RAND_MAX
decl_stmt|;
do|do
block|{
operator|++
name|r
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|max
operator|=
name|max
operator|>>
literal|1
operator|)
condition|)
do|;
name|randbits
operator|=
name|r
expr_stmt|;
block|}
comment|// Seed the PRNG once per thread with a combination of current time, a
comment|// stack address and a serial counter (since thread stack addresses are
comment|// re-used).
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
specifier|static
name|QThreadStorage
argument_list|<
name|int
modifier|*
argument_list|>
name|uuidseed
decl_stmt|;
if|if
condition|(
operator|!
name|uuidseed
operator|.
name|hasLocalData
argument_list|()
condition|)
block|{
name|int
modifier|*
name|pseed
init|=
operator|new
name|int
decl_stmt|;
specifier|static
name|QBasicAtomicInt
name|serial
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|qsrand
argument_list|(
operator|*
name|pseed
operator|=
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|toTime_t
argument_list|()
operator|+
name|quintptr
argument_list|(
operator|&
name|pseed
argument_list|)
operator|+
name|serial
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|uuidseed
operator|.
name|setLocalData
argument_list|(
name|pseed
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
specifier|static
name|bool
name|seeded
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|seeded
condition|)
name|qsrand
argument_list|(
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|toTime_t
argument_list|()
operator|+
name|quintptr
argument_list|(
operator|&
name|seeded
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|chunks
init|=
literal|16
operator|/
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
decl_stmt|;
while|while
condition|(
name|chunks
operator|--
condition|)
block|{
name|uint
name|randNumber
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|filled
init|=
literal|0
init|;
name|filled
operator|<
name|intbits
condition|;
name|filled
operator|+=
name|randbits
control|)
name|randNumber
operator||=
name|qrand
argument_list|()
operator|<<
name|filled
expr_stmt|;
operator|*
operator|(
name|data
operator|+
name|chunks
operator|)
operator|=
name|randNumber
expr_stmt|;
block|}
block|}
name|result
operator|.
name|data4
index|[
literal|0
index|]
operator|=
operator|(
name|result
operator|.
name|data4
index|[
literal|0
index|]
operator|&
literal|0x3F
operator|)
operator||
literal|0x80
expr_stmt|;
comment|// UV_DCE
name|result
operator|.
name|data3
operator|=
operator|(
name|result
operator|.
name|data3
operator|&
literal|0x0FFF
operator|)
operator||
literal|0x4000
expr_stmt|;
comment|// UV_Random
return|return
name|result
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !Q_OS_WIN32
end_comment
begin_comment
comment|/*!     \fn bool QUuid::operator==(const GUID&guid) const      Returns true if this UUID is equal to the Windows GUID \a guid;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QUuid::operator!=(const GUID&guid) const      Returns true if this UUID is not equal to the Windows GUID \a     guid; otherwise returns false. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_comment
comment|/*!     \relates QUuid     Writes the UUID \a id to the output stream for debugging information \a dbg. */
end_comment
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|dbg
parameter_list|,
specifier|const
name|QUuid
modifier|&
name|id
parameter_list|)
block|{
name|dbg
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QUuid("
operator|<<
name|id
operator|.
name|toString
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|dbg
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 5.0     \relates QUuid     Returns a hash of the UUID \a uuid, using \a seed to seed the calculation. */
end_comment
begin_function
name|uint
name|qHash
parameter_list|(
specifier|const
name|QUuid
modifier|&
name|uuid
parameter_list|,
name|uint
name|seed
parameter_list|)
name|Q_DECL_NOTHROW
block|{
return|return
name|uuid
operator|.
name|data1
operator|^
name|uuid
operator|.
name|data2
operator|^
operator|(
name|uuid
operator|.
name|data3
operator|<<
literal|16
operator|)
operator|^
operator|(
operator|(
name|uuid
operator|.
name|data4
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|uuid
operator|.
name|data4
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|uuid
operator|.
name|data4
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|uuid
operator|.
name|data4
index|[
literal|3
index|]
operator|)
operator|^
operator|(
operator|(
name|uuid
operator|.
name|data4
index|[
literal|4
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|uuid
operator|.
name|data4
index|[
literal|5
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|uuid
operator|.
name|data4
index|[
literal|6
index|]
operator|<<
literal|8
operator|)
operator||
name|uuid
operator|.
name|data4
index|[
literal|7
index|]
operator|)
operator|^
name|seed
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
