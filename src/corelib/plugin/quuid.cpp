begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"quuid.h"
end_include
begin_include
include|#
directive|include
file|"qdatastream.h"
end_include
begin_include
include|#
directive|include
file|"qendian.h"
end_include
begin_function
name|QT_BEGIN_NAMESPACE
ifndef|#
directive|ifndef
name|QT_NO_QUUID_STRING
specifier|template
type|<class
name|Char
operator|,
name|class
name|Integral
decl_stmt|> void _q_toHex(Char *&dst
DECL|function|_q_toHex
operator|,
decl_stmt|Integral value
end_function
begin_block
unit|)
block|{
specifier|static
specifier|const
name|char
name|digits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|value
operator|=
name|qToBigEndian
argument_list|(
name|value
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|value
argument_list|)
decl_stmt|;
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|Integral
argument_list|)
condition|;
operator|++
name|i
operator|,
name|dst
operator|+=
literal|2
control|)
block|{
name|uint
name|j
init|=
operator|(
name|p
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
decl_stmt|;
name|dst
index|[
literal|0
index|]
operator|=
name|Char
argument_list|(
name|digits
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
name|p
index|[
name|i
index|]
operator|&
literal|0xf
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
name|Char
argument_list|(
name|digits
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_function
template|template
parameter_list|<
name|class
name|Char
parameter_list|,
name|class
name|Integral
parameter_list|>
DECL|function|_q_fromHex
name|bool
name|_q_fromHex
parameter_list|(
specifier|const
name|Char
modifier|*
modifier|&
name|src
parameter_list|,
name|Integral
modifier|&
name|value
parameter_list|)
block|{
name|value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|Integral
argument_list|)
operator|*
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|int
name|ch
init|=
operator|*
name|src
operator|++
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|tmp
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
name|tmp
operator|=
name|ch
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
name|tmp
operator|=
name|ch
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
return|return
literal|false
return|;
name|value
operator|=
name|value
operator|*
literal|16
operator|+
name|tmp
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_decl_stmt
template|template
parameter_list|<
name|class
name|Char
parameter_list|>
DECL|function|_q_uuidToHex
name|void
name|_q_uuidToHex
argument_list|(
name|Char
operator|*
operator|&
name|dst
argument_list|,
specifier|const
name|uint
operator|&
name|d1
argument_list|,
specifier|const
name|ushort
operator|&
name|d2
argument_list|,
specifier|const
name|ushort
operator|&
name|d3
argument_list|,
specifier|const
name|uchar
argument_list|(
operator|&
name|d4
argument_list|)
index|[
literal|8
index|]
argument_list|)
argument_list|{
operator|*
name|dst
operator|++
operator|=
name|Char
argument_list|(
literal|'{'
argument_list|)
argument_list|;
name|_q_toHex
argument_list|(
name|dst
argument_list|,
name|d1
argument_list|)
argument_list|;
operator|*
name|dst
operator|++
operator|=
name|Char
argument_list|(
literal|'-'
argument_list|)
argument_list|;
name|_q_toHex
argument_list|(
name|dst
argument_list|,
name|d2
argument_list|)
argument_list|;
operator|*
name|dst
operator|++
operator|=
name|Char
argument_list|(
literal|'-'
argument_list|)
argument_list|;
name|_q_toHex
argument_list|(
name|dst
argument_list|,
name|d3
argument_list|)
argument_list|;
operator|*
name|dst
operator|++
operator|=
name|Char
argument_list|(
literal|'-'
argument_list|)
argument_list|;     for
operator|(
name|int
name|i
operator|=
literal|0
expr|;
name|i
operator|<
literal|2
expr|;
name|i
operator|++
operator|)
name|_q_toHex
argument_list|(
name|dst
argument_list|,
name|d4
index|[
name|i
index|]
argument_list|)
argument_list|;
operator|*
name|dst
operator|++
operator|=
name|Char
argument_list|(
literal|'-'
argument_list|)
argument_list|;     for
operator|(
name|int
name|i
operator|=
literal|2
expr|;
name|i
operator|<
literal|8
expr|;
name|i
operator|++
operator|)
name|_q_toHex
argument_list|(
name|dst
argument_list|,
name|d4
index|[
name|i
index|]
argument_list|)
argument_list|;
operator|*
name|dst
operator|=
name|Char
argument_list|(
literal|'}'
argument_list|)
argument_list|; }
decl|template
decl|<
name|class
name|Char
decl|>
DECL|function|_q_uuidFromHex
name|bool
name|_q_uuidFromHex
argument_list|(
specifier|const
name|Char
operator|*
operator|&
name|src
argument_list|,
name|uint
operator|&
name|d1
argument_list|,
name|ushort
operator|&
name|d2
argument_list|,
name|ushort
operator|&
name|d3
argument_list|,
name|uchar
argument_list|(
operator|&
name|d4
argument_list|)
index|[
literal|8
index|]
argument_list|)
argument_list|{     if
operator|(
operator|*
name|src
operator|==
name|Char
argument_list|(
literal|'{'
argument_list|)
operator|)
name|src
operator|++
argument_list|;     if
operator|(
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d1
argument_list|)
operator|||
operator|*
name|src
operator|++
operator|!=
name|Char
argument_list|(
literal|'-'
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d2
argument_list|)
operator|||
operator|*
name|src
operator|++
operator|!=
name|Char
argument_list|(
literal|'-'
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d3
argument_list|)
operator|||
operator|*
name|src
operator|++
operator|!=
name|Char
argument_list|(
literal|'-'
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|1
index|]
argument_list|)
operator|||
operator|*
name|src
operator|++
operator|!=
name|Char
argument_list|(
literal|'-'
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|3
index|]
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|4
index|]
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|5
index|]
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|6
index|]
argument_list|)
operator|||
operator|!
name|_q_fromHex
argument_list|(
name|src
argument_list|,
name|d4
index|[
literal|7
index|]
argument_list|)
operator|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
end_decl_stmt
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \class QUuid     \brief The QUuid class stores a Universally Unique Identifier (UUID).      \reentrant      Using \e{U}niversally \e{U}nique \e{ID}entifiers (UUID) is a     standard way to uniquely identify entities in a distributed     computing environment. A UUID is a 16-byte (128-bit) number     generated by some algorithm that is meant to guarantee that the     UUID will be unique in the distributed computing environment where     it is used. The acronym GUID is often used instead, \e{G}lobally     \e{U}nique \e{ID}entifiers, but it refers to the same thing.      \target Variant field     Actually, the GUID is one \e{variant} of UUID. Multiple variants     are in use. Each UUID contains a bit field that specifies which     type (variant) of UUID it is. Call variant() to discover which     type of UUID an instance of QUuid contains. It extracts the three     most signifcant bits of byte 8 of the 16 bytes. In QUuid, byte 8     is \c{QUuid::data4[0]}. If you create instances of QUuid using the     constructor that accepts all the numeric values as parameters, use     the following table to set the three most significant bits of     parameter \c{b1}, which becomes \c{QUuid::data4[0]} and contains     the variant field in its three most significant bits. In the     table, 'x' means \e {don't care}.      \table     \header     \o msb0     \o msb1     \o msb2     \o Variant       \row     \o 0     \o x     \o x     \o NCS (Network Computing System)      \row     \o 1     \o 0     \o x     \o DCE (Distributed Computing Environment)      \row     \o 1     \o 1     \o 0     \o Microsoft (GUID)      \row     \o 1     \o 1     \o 1     \o Reserved for future expansion      \endtable      \target Version field     If variant() returns QUuid::DCE, the UUID also contains a     \e{version} field in the four most significant bits of     \c{QUuid::data3}, and you can call version() to discover which     version your QUuid contains. If you create instances of QUuid     using the constructor that accepts all the numeric values as     parameters, use the following table to set the four most     significant bits of parameter \c{w2}, which becomes     \c{QUuid::data3} and contains the version field in its four most     significant bits.      \table     \header     \o msb0     \o msb1     \o msb2     \o msb3     \o Version      \row     \o 0     \o 0     \o 0     \o 1     \o Time      \row     \o 0     \o 0     \o 1     \o 0     \o Embedded POSIX      \row     \o 0     \o 0     \o 1     \o 1     \o Name      \row     \o 0     \o 1     \o 0     \o 0     \o Random      \endtable      The field layouts for the DCE versions listed in the table above     are specified in the \l{http://www.ietf.org/rfc/rfc4122.txt}     {Network Working Group UUID Specification}.          Most platforms provide a tool for generating new UUIDs, e.g. \c     uuidgen and \c guidgen. You can also use createUuid().  UUIDs     generated by createUuid() are of the random type.  Their     QUuid::Version bits are set to QUuid::Random, and their     QUuid::Variant bits are set to QUuid::DCE. The rest of the UUID is     composed of random numbers. Theoretically, this means there is a     small chance that a UUID generated by createUuid() will not be     unique. But it is     \l{http://en.wikipedia.org/wiki/Universally_Unique_Identifier#Random_UUID_probability_of_duplicates}     {a \e{very} small chance}.      UUIDs can be constructed from numeric values or from strings, or     using the static createUuid() function. They can be converted to a     string with toString(). UUIDs have a variant() and a version(),     and null UUIDs return true from isNull(). */
end_comment
begin_comment
comment|/*!     \fn QUuid::QUuid(const GUID&guid)      Casts a Windows \a guid to a Qt QUuid.      \warning This function is only for Windows platforms. */
end_comment
begin_comment
comment|/*!     \fn QUuid&QUuid::operator=(const GUID&guid)      Assigns a Windows \a guid to a Qt QUuid.      \warning This function is only for Windows platforms. */
end_comment
begin_comment
comment|/*!     \fn QUuid::operator GUID() const      Returns a Windows GUID from a QUuid.      \warning This function is only for Windows platforms. */
end_comment
begin_comment
comment|/*!     \fn QUuid::QUuid()      Creates the null UUID. toString() will output the null UUID     as "{00000000-0000-0000-0000-000000000000}". */
end_comment
begin_comment
comment|/*!     \fn QUuid::QUuid(uint l, ushort w1, ushort w2, uchar b1, uchar b2, uchar b3, uchar b4, uchar b5, uchar b6, uchar b7, uchar b8)      Creates a UUID with the value specified by the parameters, \a l,     \a w1, \a w2, \a b1, \a b2, \a b3, \a b4, \a b5, \a b6, \a b7, \a     b8.      Example:     \snippet doc/src/snippets/code/src_corelib_plugin_quuid.cpp 0 */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_QUUID_STRING
end_ifndef
begin_comment
comment|/*!   Creates a QUuid object from the string \a text, which must be   formatted as five hex fields separated by '-', e.g.,   "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" where 'x' is a hex   digit. The curly braces shown here are optional, but it is normal to   include them. If the conversion fails, a null UUID is created.  See   toString() for an explanation of how the five hex fields map to the   public data members in QUuid.      \sa toString(), QUuid() */
end_comment
begin_expr_stmt
unit|QUuid
DECL|function|QUuid
operator|::
name|QUuid
operator|(
specifier|const
name|QString
operator|&
name|text
operator|)
block|{
if|if
condition|(
name|text
operator|.
name|length
argument_list|()
operator|<
literal|36
condition|)
block|{
operator|*
name|this
operator|=
name|QUuid
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|const
name|ushort
operator|*
name|data
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|ushort
operator|*
argument_list|>
argument_list|(
name|text
operator|.
name|unicode
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
operator|*
name|data
operator|==
literal|'{'
operator|&&
name|text
operator|.
name|length
argument_list|()
operator|<
literal|37
condition|)
block|{
operator|*
name|this
operator|=
name|QUuid
argument_list|()
expr_stmt|;
return|return;
block|}
end_if
begin_if
if|if
condition|(
operator|!
name|_q_uuidFromHex
argument_list|(
name|data
argument_list|,
name|data1
argument_list|,
name|data2
argument_list|,
name|data3
argument_list|,
name|data4
argument_list|)
condition|)
block|{
operator|*
name|this
operator|=
name|QUuid
argument_list|()
expr_stmt|;
return|return;
block|}
end_if
begin_comment
unit|}
comment|/*!     \internal */
end_comment
begin_expr_stmt
unit|QUuid
DECL|function|QUuid
operator|::
name|QUuid
operator|(
specifier|const
name|char
operator|*
name|text
operator|)
block|{
operator|*
name|this
operator|=
name|QUuid
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|text
argument_list|)
argument_list|)
block|; }
endif|#
directive|endif
comment|/*!     \fn bool QUuid::operator==(const QUuid&other) const      Returns true if this QUuid and the \a other QUuid are identical;     otherwise returns false. */
comment|/*!     \fn bool QUuid::operator!=(const QUuid&other) const      Returns true if this QUuid and the \a other QUuid are different;     otherwise returns false. */
ifndef|#
directive|ifndef
name|QT_NO_QUUID_STRING
comment|/*!     \fn QUuid::operator QString() const      Returns the string representation of the uuid.      \sa toString() */
comment|/*!     Returns the string representation of this QUuid. The string is     formatted as five hex fields separated by '-' and enclosed in     curly braces, i.e., "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" where     'x' is a hex digit.  From left to right, the five hex fields are     obtained from the four public data members in QUuid as follows:      \table     \header     \o Field #     \o Source          \row     \o 1     \o data1          \row     \o 2     \o data2          \row     \o 3     \o data3          \row     \o 4     \o data4[0] .. data4[1]          \row     \o 5     \o data4[2] .. data4[7]      \endtable */
DECL|function|toString
name|QString
name|QUuid
operator|::
name|toString
operator|(
operator|)
specifier|const
block|{
name|QString
name|result
argument_list|(
literal|38
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
block|;
name|ushort
operator|*
name|data
operator|=
operator|(
name|ushort
operator|*
operator|)
name|result
operator|.
name|unicode
argument_list|()
block|;
name|_q_uuidToHex
argument_list|(
name|data
argument_list|,
name|data1
argument_list|,
name|data2
argument_list|,
name|data3
argument_list|,
name|data4
argument_list|)
block|;
return|return
name|result
return|;
block|}
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*!     \relates QUuid     Writes the UUID \a id to the data stream \a s. */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QUuid
modifier|&
name|id
parameter_list|)
block|{
name|s
operator|<<
operator|(
name|quint32
operator|)
name|id
operator|.
name|data1
expr_stmt|;
name|s
operator|<<
operator|(
name|quint16
operator|)
name|id
operator|.
name|data2
expr_stmt|;
name|s
operator|<<
operator|(
name|quint16
operator|)
name|id
operator|.
name|data3
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|s
operator|<<
operator|(
name|quint8
operator|)
name|id
operator|.
name|data4
index|[
name|i
index|]
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_comment
comment|/*!     \relates QUuid     Reads a UUID from the stream \a s into \a id. */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QUuid
modifier|&
name|id
parameter_list|)
block|{
name|quint32
name|u32
decl_stmt|;
name|quint16
name|u16
decl_stmt|;
name|quint8
name|u8
decl_stmt|;
name|s
operator|>>
name|u32
expr_stmt|;
name|id
operator|.
name|data1
operator|=
name|u32
expr_stmt|;
name|s
operator|>>
name|u16
expr_stmt|;
name|id
operator|.
name|data2
operator|=
name|u16
expr_stmt|;
name|s
operator|>>
name|u16
expr_stmt|;
name|id
operator|.
name|data3
operator|=
name|u16
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|>>
name|u8
expr_stmt|;
name|id
operator|.
name|data4
index|[
name|i
index|]
operator|=
name|u8
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_DATASTREAM
end_comment
begin_comment
comment|/*!     Returns true if this is the null UUID     {00000000-0000-0000-0000-000000000000}; otherwise returns false. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QUuid
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
name|data4
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|5
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|6
index|]
operator|==
literal|0
operator|&&
name|data4
index|[
literal|7
index|]
operator|==
literal|0
operator|&&
name|data1
operator|==
literal|0
operator|&&
name|data2
operator|==
literal|0
operator|&&
name|data3
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QUuid::Variant      This enum defines the values used in the \l{Variant field}     {variant field} of the UUID. The value in the variant field     determines the layout of the 128-bit value.      \value VarUnknown Variant is unknown     \value NCS Reserved for NCS (Network Computing System) backward compatibility     \value DCE Distributed Computing Environment, the scheme used by QUuid     \value Microsoft Reserved for Microsoft backward compatibility (GUID)     \value Reserved Reserved for future definition */
end_comment
begin_comment
comment|/*!     \enum QUuid::Version      This enum defines the values used in the \l{Version field}     {version field} of the UUID. The version field is meaningful     only if the value in the \l{Variant field} {variant field}     is QUuid::DCE.      \value VerUnknown Version is unknown     \value Time Time-based, by using timestamp, clock sequence, and     MAC network card address (if available) for the node sections     \value EmbeddedPOSIX DCE Security version, with embedded POSIX UUIDs     \value Name Name-based, by using values from a name for all sections     \value Random Random-based, by using random numbers for all sections */
end_comment
begin_comment
comment|/*!     \fn QUuid::Variant QUuid::variant() const      Returns the value in the \l{Variant field} {variant field} of the     UUID. If the return value is QUuid::DCE, call version() to see     which layout it uses. The null UUID is considered to be of an     unknown variant.      \sa version() */
end_comment
begin_function
DECL|function|variant
name|QUuid
operator|::
name|Variant
name|QUuid
operator|::
name|variant
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return
name|VarUnknown
return|;
comment|// Check the 3 MSB of data4[0]
if|if
condition|(
operator|(
name|data4
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0x00
condition|)
return|return
name|NCS
return|;
elseif|else
if|if
condition|(
operator|(
name|data4
index|[
literal|0
index|]
operator|&
literal|0xC0
operator|)
operator|==
literal|0x80
condition|)
return|return
name|DCE
return|;
elseif|else
if|if
condition|(
operator|(
name|data4
index|[
literal|0
index|]
operator|&
literal|0xE0
operator|)
operator|==
literal|0xC0
condition|)
return|return
name|Microsoft
return|;
elseif|else
if|if
condition|(
operator|(
name|data4
index|[
literal|0
index|]
operator|&
literal|0xE0
operator|)
operator|==
literal|0xE0
condition|)
return|return
name|Reserved
return|;
return|return
name|VarUnknown
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QUuid::Version QUuid::version() const      Returns the \l{Version field} {version field} of the UUID, if the     UUID's \l{Variant field} {variant field} is QUuid::DCE. Otherwise     it returns QUuid::VerUnknown.      \sa variant() */
end_comment
begin_function
DECL|function|version
name|QUuid
operator|::
name|Version
name|QUuid
operator|::
name|version
parameter_list|()
specifier|const
block|{
comment|// Check the 4 MSB of data3
name|Version
name|ver
init|=
call|(
name|Version
call|)
argument_list|(
name|data3
operator|>>
literal|12
argument_list|)
decl_stmt|;
if|if
condition|(
name|isNull
argument_list|()
operator|||
operator|(
name|variant
argument_list|()
operator|!=
name|DCE
operator|)
operator|||
name|ver
argument_list|<
name|Time
operator|||
name|ver
argument_list|>
name|Random
condition|)
return|return
name|VerUnknown
return|;
return|return
name|ver
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QUuid::operator<(const QUuid&other) const      Returns true if this QUuid has the same \l{Variant field}     {variant field} as the \a other QUuid and is lexicographically     \e{before} the \a other QUuid. If the \a other QUuid has a     different variant field, the return value is determined by     comparing the two \l{QUuid::Variant} {variants}.      \sa variant() */
end_comment
begin_define
DECL|macro|ISLESS
define|#
directive|define
name|ISLESS
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
value|if (f1!=f2) return (f1<f2);
end_define
begin_function
DECL|function|operator <
name|bool
name|QUuid
operator|::
name|operator
name|<
parameter_list|(
specifier|const
name|QUuid
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|variant
argument_list|()
operator|!=
name|other
operator|.
name|variant
argument_list|()
condition|)
return|return
name|variant
argument_list|()
operator|<
name|other
operator|.
name|variant
argument_list|()
return|;
name|ISLESS
argument_list|(
name|data1
argument_list|,
name|other
operator|.
name|data1
argument_list|)
expr_stmt|;
name|ISLESS
argument_list|(
name|data2
argument_list|,
name|other
operator|.
name|data2
argument_list|)
expr_stmt|;
name|ISLESS
argument_list|(
name|data3
argument_list|,
name|other
operator|.
name|data3
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
block|{
name|ISLESS
argument_list|(
name|data4
index|[
name|n
index|]
argument_list|,
name|other
operator|.
name|data4
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QUuid::operator>(const QUuid&other) const      Returns true if this QUuid has the same \l{Variant field}     {variant field} as the \a other QUuid and is lexicographically     \e{after} the \a other QUuid. If the \a other QUuid has a     different variant field, the return value is determined by     comparing the two \l{QUuid::Variant} {variants}.      \sa variant() */
end_comment
begin_define
DECL|macro|ISMORE
define|#
directive|define
name|ISMORE
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
value|if (f1!=f2) return (f1>f2);
end_define
begin_function
DECL|function|operator >
name|bool
name|QUuid
operator|::
name|operator
name|>
parameter_list|(
specifier|const
name|QUuid
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|variant
argument_list|()
operator|!=
name|other
operator|.
name|variant
argument_list|()
condition|)
return|return
name|variant
argument_list|()
operator|>
name|other
operator|.
name|variant
argument_list|()
return|;
name|ISMORE
argument_list|(
name|data1
argument_list|,
name|other
operator|.
name|data1
argument_list|)
expr_stmt|;
name|ISMORE
argument_list|(
name|data2
argument_list|,
name|other
operator|.
name|data2
argument_list|)
expr_stmt|;
name|ISMORE
argument_list|(
name|data3
argument_list|,
name|other
operator|.
name|data3
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
block|{
name|ISMORE
argument_list|(
name|data4
index|[
name|n
index|]
argument_list|,
name|other
operator|.
name|data4
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QUuid QUuid::createUuid()      On any platform other than Windows, this function returns a new     UUID with variant QUuid::DCE and version QUuid::Random.  If     the /dev/urandom device exists, then the numbers used to construct     the UUID will be of cryptographic quality, which will make the UUID     unique.  Otherwise, the numbers of the UUID will be obtained from     the local pseudo-random number generator (qrand(), which is seeded     by qsrand()) which is usually not of cryptograhic quality, which     means that the UUID can't be guaranteed to be unique.      On a Windows platform, a GUID is generated, which almost certainly     \e{will} be unique, on this or any other system, networked or not.      \sa variant(), version() */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_MWERKS
argument_list|)
end_if
begin_function
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<objbase.h>
comment|// For CoCreateGuid
name|QT_END_INCLUDE_NAMESPACE
DECL|function|createUuid
name|QUuid
name|QUuid
operator|::
name|createUuid
parameter_list|()
block|{
name|GUID
name|guid
decl_stmt|;
name|CoCreateGuid
argument_list|(
operator|&
name|guid
argument_list|)
expr_stmt|;
name|QUuid
name|result
init|=
name|guid
decl_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|// !Q_OS_WIN32
end_comment
begin_function_decl
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|"qdatetime.h"
include|#
directive|include
file|"qfile.h"
include|#
directive|include
file|"qthreadstorage.h"
include|#
directive|include
file|<stdlib.h>
comment|// for RAND_MAX
name|QT_END_INCLUDE_NAMESPACE
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|Q_GLOBAL_STATIC
parameter_list|(
name|QThreadStorage
argument_list|<
name|QFile
modifier|*
argument_list|>
parameter_list|,
name|devUrandomStorage
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|createUuid
name|QUuid
name|QUuid
operator|::
name|createUuid
parameter_list|()
block|{
name|QUuid
name|result
decl_stmt|;
name|uint
modifier|*
name|data
init|=
operator|&
operator|(
name|result
operator|.
name|data1
operator|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|QFile
modifier|*
name|devUrandom
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_BOOTSTRAPPED
argument_list|)
name|devUrandom
operator|=
name|devUrandomStorage
argument_list|()
operator|->
name|localData
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|devUrandom
condition|)
block|{
name|devUrandom
operator|=
operator|new
name|QFile
argument_list|(
name|QLatin1String
argument_list|(
literal|"/dev/urandom"
argument_list|)
argument_list|)
expr_stmt|;
name|devUrandom
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
operator||
name|QIODevice
operator|::
name|Unbuffered
argument_list|)
expr_stmt|;
name|devUrandomStorage
argument_list|()
operator|->
name|setLocalData
argument_list|(
name|devUrandom
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|QFile
name|file
argument_list|(
name|QLatin1String
argument_list|(
literal|"/dev/urandom"
argument_list|)
argument_list|)
decl_stmt|;
name|devUrandom
operator|=
operator|&
name|file
expr_stmt|;
name|devUrandom
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
operator||
name|QIODevice
operator|::
name|Unbuffered
argument_list|)
expr_stmt|;
endif|#
directive|endif
enum|enum
block|{
name|AmountToRead
init|=
literal|4
operator|*
expr|sizeof
operator|(
name|uint
operator|)
block|}
enum|;
if|if
condition|(
name|devUrandom
operator|->
name|isOpen
argument_list|()
operator|&&
name|devUrandom
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|AmountToRead
argument_list|)
operator|==
name|AmountToRead
condition|)
block|{
comment|// we got what we wanted, nothing more to do
empty_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
specifier|static
specifier|const
name|int
name|intbits
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|8
decl_stmt|;
specifier|static
name|int
name|randbits
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|randbits
condition|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|int
name|max
init|=
name|RAND_MAX
decl_stmt|;
do|do
block|{
operator|++
name|r
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|max
operator|=
name|max
operator|>>
literal|1
operator|)
condition|)
do|;
name|randbits
operator|=
name|r
expr_stmt|;
block|}
comment|// Seed the PRNG once per thread with a combination of current time, a
comment|// stack address and a serial counter (since thread stack addresses are
comment|// re-used).
ifndef|#
directive|ifndef
name|QT_BOOTSTRAPPED
specifier|static
name|QThreadStorage
argument_list|<
name|int
modifier|*
argument_list|>
name|uuidseed
decl_stmt|;
if|if
condition|(
operator|!
name|uuidseed
operator|.
name|hasLocalData
argument_list|()
condition|)
block|{
name|int
modifier|*
name|pseed
init|=
operator|new
name|int
decl_stmt|;
specifier|static
name|QBasicAtomicInt
name|serial
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|qsrand
argument_list|(
operator|*
name|pseed
operator|=
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|toTime_t
argument_list|()
operator|+
name|quintptr
argument_list|(
operator|&
name|pseed
argument_list|)
operator|+
name|serial
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|uuidseed
operator|.
name|setLocalData
argument_list|(
name|pseed
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
specifier|static
name|bool
name|seeded
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|seeded
condition|)
name|qsrand
argument_list|(
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|toTime_t
argument_list|()
operator|+
name|quintptr
argument_list|(
operator|&
name|seeded
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|chunks
init|=
literal|16
operator|/
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
decl_stmt|;
while|while
condition|(
name|chunks
operator|--
condition|)
block|{
name|uint
name|randNumber
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|filled
init|=
literal|0
init|;
name|filled
operator|<
name|intbits
condition|;
name|filled
operator|+=
name|randbits
control|)
name|randNumber
operator||=
name|qrand
argument_list|()
operator|<<
name|filled
expr_stmt|;
operator|*
operator|(
name|data
operator|+
name|chunks
operator|)
operator|=
name|randNumber
expr_stmt|;
block|}
block|}
name|result
operator|.
name|data4
index|[
literal|0
index|]
operator|=
operator|(
name|result
operator|.
name|data4
index|[
literal|0
index|]
operator|&
literal|0x3F
operator|)
operator||
literal|0x80
expr_stmt|;
comment|// UV_DCE
name|result
operator|.
name|data3
operator|=
operator|(
name|result
operator|.
name|data3
operator|&
literal|0x0FFF
operator|)
operator||
literal|0x4000
expr_stmt|;
comment|// UV_Random
return|return
name|result
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !Q_OS_WIN32
end_comment
begin_comment
comment|/*!     \fn bool QUuid::operator==(const GUID&guid) const      Returns true if this UUID is equal to the Windows GUID \a guid;     otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QUuid::operator!=(const GUID&guid) const      Returns true if this UUID is not equal to the Windows GUID \a     guid; otherwise returns false. */
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
