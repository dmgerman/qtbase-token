begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qlibrary.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
end_ifndef
begin_include
include|#
directive|include
file|"qlibrary_p.h"
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qmutex.h>
end_include
begin_include
include|#
directive|include
file|<qmap.h>
end_include
begin_include
include|#
directive|include
file|<qsettings.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_MAC
end_ifdef
begin_include
include|#
directive|include
file|<private/qcore_mac_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|NO_ERRNO_H
end_ifndef
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// NO_ERROR_H
end_comment
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qvector.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|"qelfparser_p.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
ifdef|#
directive|ifdef
name|QT_NO_DEBUG
DECL|macro|QLIBRARY_AS_DEBUG
define|#
directive|define
name|QLIBRARY_AS_DEBUG
value|false
else|#
directive|else
define|#
directive|define
name|QLIBRARY_AS_DEBUG
value|true
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
comment|// We don't use separate debug and release libs on UNIX, so we want
comment|// to allow loading plugins, regardless of how they were built.
DECL|macro|QT_NO_DEBUG_PLUGIN_CHECK
define|#
directive|define
name|QT_NO_DEBUG_PLUGIN_CHECK
endif|#
directive|endif
name|Q_GLOBAL_STATIC
argument_list|(
name|QMutex
argument_list|,
name|qt_library_mutex
argument_list|)
comment|/*!     \class QLibrary     \reentrant     \brief The QLibrary class loads shared libraries at runtime.       \ingroup plugins      An instance of a QLibrary object operates on a single shared     object file (which we call a "library", but is also known as a     "DLL"). A QLibrary provides access to the functionality in the     library in a platform independent way. You can either pass a file     name in the constructor, or set it explicitly with setFileName().     When loading the library, QLibrary searches in all the     system-specific library locations (e.g. \c LD_LIBRARY_PATH on     Unix), unless the file name has an absolute path. If the file     cannot be found, QLibrary tries the name with different     platform-specific file suffixes, like ".so" on Unix, ".dylib" on     the Mac, or ".dll" on Windows and Symbian. This makes it possible     to specify shared libraries that are only identified by their     basename (i.e. without their suffix), so the same code will work     on different operating systems.      The most important functions are load() to dynamically load the     library file, isLoaded() to check whether loading was successful,     and resolve() to resolve a symbol in the library. The resolve()     function implicitly tries to load the library if it has not been     loaded yet. Multiple instances of QLibrary can be used to access     the same physical library. Once loaded, libraries remain in memory     until the application terminates. You can attempt to unload a     library using unload(), but if other instances of QLibrary are     using the same library, the call will fail, and unloading will     only happen when every instance has called unload().      A typical use of QLibrary is to resolve an exported symbol in a     library, and to call the C function that this symbol represents.     This is called "explicit linking" in contrast to "implicit     linking", which is done by the link step in the build process when     linking an executable against a library.      Note: In Symbian resolving symbols using their names is supported     only if the library is built as STDDLL. Otherwise ordinals must     be used. Also, in Symbian the path of the library is ignored and     system default library location is always used.      The following code snippet loads a library, resolves the symbol     "mysymbol", and calls the function if everything succeeded. If     something goes wrong, e.g. the library file does not exist or the     symbol is not defined, the function pointer will be 0 and won't be     called.      \snippet doc/src/snippets/code/src_corelib_plugin_qlibrary.cpp 0      The symbol must be exported as a C function from the library for     resolve() to work. This means that the function must be wrapped in     an \c{extern "C"} block if the library is compiled with a C++     compiler. On Windows, this also requires the use of a \c dllexport     macro; see resolve() for the details of how this is done. For     convenience, there is a static resolve() function which you can     use if you just want to call a function in a library without     explicitly loading the library first:      \snippet doc/src/snippets/code/src_corelib_plugin_qlibrary.cpp 1      \sa QPluginLoader */
comment|/*!     \enum QLibrary::LoadHint      This enum describes the possible hints that can be used to change the way     libraries are handled when they are loaded. These values indicate how     symbols are resolved when libraries are loaded, and are specified using     the setLoadHints() function.      \value ResolveAllSymbolsHint     Causes all symbols in a library to be resolved when it is loaded, not     simply when resolve() is called.     \value ExportExternalSymbolsHint     Exports unresolved and external symbols in the library so that they can be     resolved in other dynamically-loaded libraries loaded later.     \value LoadArchiveMemberHint     Allows the file name of the library to specify a particular object file     within an archive file.     If this hint is given, the filename of the library consists of     a path, which is a reference to an archive file, followed by     a reference to the archive member.      \sa loadHints */
ifndef|#
directive|ifndef
name|QT_NO_PLUGIN_CHECK
decl|struct
DECL|struct|qt_token_info
name|qt_token_info
argument_list|{
DECL|function|qt_token_info
name|qt_token_info
argument_list|(
argument|const char *f
argument_list|,
argument|const ulong fc
argument_list|)
operator|:
name|fields
argument_list|(
name|f
argument_list|)
argument_list|,
name|field_count
argument_list|(
name|fc
argument_list|)
argument_list|,
name|results
argument_list|(
name|fc
argument_list|)
argument_list|,
name|lengths
argument_list|(
argument|fc
argument_list|)
block|{
name|results
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
block|;
name|lengths
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
block|;     }
DECL|member|fields
specifier|const
name|char
operator|*
name|fields
argument_list|;
DECL|member|field_count
specifier|const
name|ulong
name|field_count
argument_list|;
DECL|member|results
name|QVector
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
name|results
argument_list|;
DECL|member|lengths
name|QVector
argument_list|<
name|ulong
argument_list|>
name|lengths
argument_list|; }
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*   return values:        1 parse ok        0 eos       -1 parse error */
end_comment
begin_function
DECL|function|qt_tokenize
specifier|static
name|int
name|qt_tokenize
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|ulong
name|s_len
parameter_list|,
name|ulong
modifier|*
name|advance
parameter_list|,
name|qt_token_info
modifier|&
name|token_info
parameter_list|)
block|{
name|ulong
name|pos
init|=
literal|0
decl_stmt|,
name|field
init|=
literal|0
decl_stmt|,
name|fieldlen
init|=
literal|0
decl_stmt|;
name|char
name|current
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
operator|*
name|advance
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|current
operator|=
name|s
index|[
name|pos
index|]
expr_stmt|;
comment|// next char
operator|++
name|pos
expr_stmt|;
operator|++
name|fieldlen
expr_stmt|;
operator|++
operator|*
name|advance
expr_stmt|;
if|if
condition|(
operator|!
name|current
operator|||
name|pos
operator|==
name|s_len
operator|+
literal|1
condition|)
block|{
comment|// save result
name|token_info
operator|.
name|results
index|[
operator|(
name|int
operator|)
name|field
index|]
operator|=
name|s
expr_stmt|;
name|token_info
operator|.
name|lengths
index|[
operator|(
name|int
operator|)
name|field
index|]
operator|=
name|fieldlen
operator|-
literal|1
expr_stmt|;
comment|// end of string
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|current
operator|==
name|token_info
operator|.
name|fields
index|[
name|field
index|]
condition|)
block|{
comment|// save result
name|token_info
operator|.
name|results
index|[
operator|(
name|int
operator|)
name|field
index|]
operator|=
name|s
expr_stmt|;
name|token_info
operator|.
name|lengths
index|[
operator|(
name|int
operator|)
name|field
index|]
operator|=
name|fieldlen
operator|-
literal|1
expr_stmt|;
comment|// end of field
name|fieldlen
operator|=
literal|0
expr_stmt|;
operator|++
name|field
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|token_info
operator|.
name|field_count
operator|-
literal|1
condition|)
block|{
comment|// parse ok
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|==
name|token_info
operator|.
name|field_count
condition|)
block|{
comment|// done parsing
break|break;
block|}
comment|// reset string and its length
name|s
operator|=
name|s
operator|+
name|pos
expr_stmt|;
name|s_len
operator|-=
name|pos
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*   returns true if the string s was correctly parsed, false otherwise. */
end_comment
begin_function
DECL|function|qt_parse_pattern
specifier|static
name|bool
name|qt_parse_pattern
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|uint
modifier|*
name|version
parameter_list|,
name|bool
modifier|*
name|debug
parameter_list|,
name|QByteArray
modifier|*
name|key
parameter_list|)
block|{
name|bool
name|ret
init|=
literal|true
decl_stmt|;
name|qt_token_info
name|pinfo
argument_list|(
literal|"=\n"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|int
name|parse
decl_stmt|;
name|ulong
name|at
init|=
literal|0
decl_stmt|,
name|advance
decl_stmt|,
name|parselen
init|=
name|qstrlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
do|do
block|{
name|parse
operator|=
name|qt_tokenize
argument_list|(
name|s
operator|+
name|at
argument_list|,
name|parselen
argument_list|,
operator|&
name|advance
argument_list|,
name|pinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse
operator|==
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|at
operator|+=
name|advance
expr_stmt|;
name|parselen
operator|-=
name|advance
expr_stmt|;
if|if
condition|(
name|qstrncmp
argument_list|(
literal|"version"
argument_list|,
name|pinfo
operator|.
name|results
index|[
literal|0
index|]
argument_list|,
name|pinfo
operator|.
name|lengths
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// parse version string
name|qt_token_info
name|pinfo2
argument_list|(
literal|"..-"
argument_list|,
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|qt_tokenize
argument_list|(
name|pinfo
operator|.
name|results
index|[
literal|1
index|]
argument_list|,
name|pinfo
operator|.
name|lengths
index|[
literal|1
index|]
argument_list|,
operator|&
name|advance
argument_list|,
name|pinfo2
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|QByteArray
name|m
argument_list|(
name|pinfo2
operator|.
name|results
index|[
literal|0
index|]
argument_list|,
name|pinfo2
operator|.
name|lengths
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|QByteArray
name|n
argument_list|(
name|pinfo2
operator|.
name|results
index|[
literal|1
index|]
argument_list|,
name|pinfo2
operator|.
name|lengths
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|QByteArray
name|p
argument_list|(
name|pinfo2
operator|.
name|results
index|[
literal|2
index|]
argument_list|,
name|pinfo2
operator|.
name|lengths
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
operator|*
name|version
operator|=
operator|(
name|m
operator|.
name|toUInt
argument_list|()
operator|<<
literal|16
operator|)
operator||
operator|(
name|n
operator|.
name|toUInt
argument_list|()
operator|<<
literal|8
operator|)
operator||
name|p
operator|.
name|toUInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|qstrncmp
argument_list|(
literal|"debug"
argument_list|,
name|pinfo
operator|.
name|results
index|[
literal|0
index|]
argument_list|,
name|pinfo
operator|.
name|lengths
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|debug
operator|=
name|qstrncmp
argument_list|(
literal|"true"
argument_list|,
name|pinfo
operator|.
name|results
index|[
literal|1
index|]
argument_list|,
name|pinfo
operator|.
name|lengths
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qstrncmp
argument_list|(
literal|"buildkey"
argument_list|,
name|pinfo
operator|.
name|results
index|[
literal|0
index|]
argument_list|,
name|pinfo
operator|.
name|lengths
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// save buildkey
operator|*
name|key
operator|=
name|QByteArray
argument_list|(
name|pinfo
operator|.
name|results
index|[
literal|1
index|]
argument_list|,
name|pinfo
operator|.
name|lengths
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|parse
operator|==
literal|1
operator|&&
name|parselen
operator|>
literal|0
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_PLUGIN_CHECK
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_PLUGIN_CHECK
argument_list|)
end_if
begin_function
DECL|function|qt_find_pattern
specifier|static
name|long
name|qt_find_pattern
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|ulong
name|s_len
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|ulong
name|p_len
parameter_list|)
block|{
comment|/*       we search from the end of the file because on the supported       systems, the read-only data/text segments are placed at the end       of the file.  HOWEVER, when building with debugging enabled, all       the debug symbols are placed AFTER the data/text segments.        what does this mean?  when building in release mode, the search       is fast because the data we are looking for is at the end of the       file... when building in debug mode, the search is slower       because we have to skip over all the debugging symbols first     */
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|pattern
operator|||
name|p_len
operator|>
name|s_len
condition|)
return|return
operator|-
literal|1
return|;
name|ulong
name|i
decl_stmt|,
name|hs
init|=
literal|0
decl_stmt|,
name|hp
init|=
literal|0
decl_stmt|,
name|delta
init|=
name|s_len
operator|-
name|p_len
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_len
condition|;
operator|++
name|i
control|)
block|{
name|hs
operator|+=
name|s
index|[
name|delta
operator|+
name|i
index|]
expr_stmt|;
name|hp
operator|+=
name|pattern
index|[
name|i
index|]
expr_stmt|;
block|}
name|i
operator|=
name|delta
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|hs
operator|==
name|hp
operator|&&
name|qstrncmp
argument_list|(
name|s
operator|+
name|i
argument_list|,
name|pattern
argument_list|,
name|p_len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
operator|--
name|i
expr_stmt|;
name|hs
operator|-=
name|s
index|[
name|i
operator|+
name|p_len
index|]
expr_stmt|;
name|hs
operator|+=
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*   This opens the specified library, mmaps it into memory, and searches   for the QT_PLUGIN_VERIFICATION_DATA.  The advantage of this approach is that   we can get the verification data without have to actually load the library.   This lets us detect mismatches more safely.    Returns false if version/key information is not present, or if the                 information could not be read.   Returns  true if version/key information is present and successfully read. */
end_comment
begin_function
DECL|function|qt_unix_query
specifier|static
name|bool
name|qt_unix_query
parameter_list|(
specifier|const
name|QString
modifier|&
name|library
parameter_list|,
name|uint
modifier|*
name|version
parameter_list|,
name|bool
modifier|*
name|debug
parameter_list|,
name|QByteArray
modifier|*
name|key
parameter_list|,
name|QLibraryPrivate
modifier|*
name|lib
init|=
literal|0
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|library
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
if|if
condition|(
name|lib
condition|)
name|lib
operator|->
name|errorString
operator|=
name|file
operator|.
name|errorString
argument_list|()
expr_stmt|;
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"%s: %s"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|QFile
operator|::
name|encodeName
argument_list|(
name|library
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|QByteArray
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|filedata
init|=
literal|0
decl_stmt|;
name|ulong
name|fdlen
init|=
name|file
operator|.
name|size
argument_list|()
decl_stmt|;
name|filedata
operator|=
operator|(
name|char
operator|*
operator|)
name|file
operator|.
name|map
argument_list|(
literal|0
argument_list|,
name|fdlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|filedata
operator|==
literal|0
condition|)
block|{
comment|// try reading the data into memory instead
name|data
operator|=
name|file
operator|.
name|readAll
argument_list|()
expr_stmt|;
name|filedata
operator|=
name|data
operator|.
name|constData
argument_list|()
expr_stmt|;
name|fdlen
operator|=
name|data
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|/*        ELF binaries on GNU, have .qplugin sections.     */
name|long
name|pos
init|=
literal|0
decl_stmt|;
specifier|const
name|char
name|pattern
index|[]
init|=
literal|"pattern=QT_PLUGIN_VERIFICATION_DATA"
decl_stmt|;
specifier|const
name|ulong
name|plen
init|=
name|qstrlen
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OF_ELF
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
name|int
name|r
init|=
name|QElfParser
argument_list|()
operator|.
name|parse
argument_list|(
name|filedata
argument_list|,
name|fdlen
argument_list|,
name|library
argument_list|,
name|lib
argument_list|,
operator|&
name|pos
argument_list|,
operator|&
name|fdlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|QElfParser
operator|::
name|NoQtSection
condition|)
block|{
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
block|{
comment|// find inside .rodata
name|long
name|rel
init|=
name|qt_find_pattern
argument_list|(
name|filedata
operator|+
name|pos
argument_list|,
name|fdlen
argument_list|,
name|pattern
argument_list|,
name|plen
argument_list|)
decl_stmt|;
if|if
condition|(
name|rel
operator|<
literal|0
condition|)
block|{
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|+=
name|rel
expr_stmt|;
block|}
block|}
else|else
block|{
name|pos
operator|=
name|qt_find_pattern
argument_list|(
name|filedata
argument_list|,
name|fdlen
argument_list|,
name|pattern
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r
operator|!=
name|QElfParser
operator|::
name|Ok
condition|)
block|{
if|if
condition|(
name|lib
operator|&&
name|qt_debug_component
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QElfParser: %s"
argument_list|,
name|qPrintable
argument_list|(
name|lib
operator|->
name|errorString
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
else|#
directive|else
name|pos
operator|=
name|qt_find_pattern
argument_list|(
name|filedata
argument_list|,
name|fdlen
argument_list|,
name|pattern
argument_list|,
name|plen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// defined(Q_OF_ELF)&& defined(Q_CC_GNU)
name|bool
name|ret
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
name|ret
operator|=
name|qt_parse_pattern
argument_list|(
name|filedata
operator|+
name|pos
argument_list|,
name|version
argument_list|,
name|debug
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|lib
condition|)
name|lib
operator|->
name|errorString
operator|=
name|QLibrary
operator|::
name|tr
argument_list|(
literal|"Plugin verification data mismatch in '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|library
argument_list|)
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_OS_UNIX&& !Q_OS_MAC&& !defined(Q_OS_SYMBIAN)&& !defined(QT_NO_PLUGIN_CHECK)
end_comment
begin_typedef
DECL|typedef|LibraryMap
typedef|typedef
name|QMap
argument_list|<
name|QString
argument_list|,
name|QLibraryPrivate
modifier|*
argument_list|>
name|LibraryMap
typedef|;
end_typedef
begin_struct
DECL|struct|LibraryData
struct|struct
name|LibraryData
block|{
DECL|function|LibraryData
name|LibraryData
parameter_list|()
member_init_list|:
name|settings
argument_list|(
literal|0
argument_list|)
block|{ }
DECL|function|~LibraryData
name|~
name|LibraryData
parameter_list|()
block|{
operator|delete
name|settings
expr_stmt|;
block|}
DECL|member|settings
name|QSettings
modifier|*
name|settings
decl_stmt|;
DECL|member|libraryMap
name|LibraryMap
name|libraryMap
decl_stmt|;
DECL|member|loadedLibs
name|QSet
argument_list|<
name|QLibraryPrivate
modifier|*
argument_list|>
name|loadedLibs
decl_stmt|;
block|}
struct|;
end_struct
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|LibraryData
argument_list|,
argument|libraryData
argument_list|)
end_macro
begin_function
DECL|function|libraryMap
specifier|static
name|LibraryMap
modifier|*
name|libraryMap
parameter_list|()
block|{
name|LibraryData
modifier|*
name|data
init|=
name|libraryData
argument_list|()
decl_stmt|;
return|return
name|data
condition|?
operator|&
name|data
operator|->
name|libraryMap
else|:
literal|0
return|;
block|}
end_function
begin_constructor
DECL|function|QLibraryPrivate
name|QLibraryPrivate
operator|::
name|QLibraryPrivate
parameter_list|(
specifier|const
name|QString
modifier|&
name|canonicalFileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
member_init_list|:
name|pHnd
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|fileName
argument_list|(
name|canonicalFileName
argument_list|)
member_init_list|,
name|fullVersion
argument_list|(
name|version
argument_list|)
member_init_list|,
name|instance
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|qt_version
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|libraryRefCount
argument_list|(
literal|1
argument_list|)
member_init_list|,
name|libraryUnloadCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pluginState
argument_list|(
name|MightBeAPlugin
argument_list|)
block|{
name|libraryMap
argument_list|()
operator|->
name|insert
argument_list|(
name|canonicalFileName
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|findOrCreate
name|QLibraryPrivate
modifier|*
name|QLibraryPrivate
operator|::
name|findOrCreate
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
name|qt_library_mutex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|QLibraryPrivate
modifier|*
name|lib
init|=
name|libraryMap
argument_list|()
operator|->
name|value
argument_list|(
name|fileName
argument_list|)
condition|)
block|{
name|lib
operator|->
name|libraryRefCount
operator|.
name|ref
argument_list|()
expr_stmt|;
return|return
name|lib
return|;
block|}
return|return
operator|new
name|QLibraryPrivate
argument_list|(
name|fileName
argument_list|,
name|version
argument_list|)
return|;
block|}
end_function
begin_destructor
DECL|function|~QLibraryPrivate
name|QLibraryPrivate
operator|::
name|~
name|QLibraryPrivate
parameter_list|()
block|{
name|LibraryMap
modifier|*
specifier|const
name|map
init|=
name|libraryMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|map
condition|)
block|{
name|QLibraryPrivate
modifier|*
name|that
init|=
name|map
operator|->
name|take
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|this
operator|==
name|that
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|that
argument_list|)
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|resolve
name|void
modifier|*
name|QLibraryPrivate
operator|::
name|resolve
parameter_list|(
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pHnd
condition|)
return|return
literal|0
return|;
return|return
name|resolve_sys
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|load
name|bool
name|QLibraryPrivate
operator|::
name|load
parameter_list|()
block|{
name|libraryUnloadCount
operator|.
name|ref
argument_list|()
expr_stmt|;
if|if
condition|(
name|pHnd
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|bool
name|ret
init|=
name|load_sys
argument_list|()
decl_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|//when loading a library we add a reference to it so that the QLibraryPrivate won't get deleted
comment|//this allows to unload the library at a later time
if|if
condition|(
name|LibraryData
modifier|*
name|lib
init|=
name|libraryData
argument_list|()
condition|)
block|{
name|lib
operator|->
name|loadedLibs
operator|+=
name|this
expr_stmt|;
name|libraryRefCount
operator|.
name|ref
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|unload
name|bool
name|QLibraryPrivate
operator|::
name|unload
parameter_list|()
block|{
if|if
condition|(
operator|!
name|pHnd
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|libraryUnloadCount
operator|.
name|deref
argument_list|()
condition|)
block|{
comment|// only unload if ALL QLibrary instance wanted to
operator|delete
name|inst
operator|.
name|data
argument_list|()
expr_stmt|;
if|if
condition|(
name|unload_sys
argument_list|()
condition|)
block|{
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QLibraryPrivate::unload succeeded on"
operator|<<
name|fileName
expr_stmt|;
comment|//when the library is unloaded, we release the reference on it so that 'this'
comment|//can get deleted
if|if
condition|(
name|LibraryData
modifier|*
name|lib
init|=
name|libraryData
argument_list|()
condition|)
block|{
if|if
condition|(
name|lib
operator|->
name|loadedLibs
operator|.
name|remove
argument_list|(
name|this
argument_list|)
condition|)
name|libraryRefCount
operator|.
name|deref
argument_list|()
expr_stmt|;
block|}
name|pHnd
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|pHnd
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|release
name|void
name|QLibraryPrivate
operator|::
name|release
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
name|qt_library_mutex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|libraryRefCount
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|this
expr_stmt|;
block|}
end_function
begin_function
DECL|function|loadPlugin
name|bool
name|QLibraryPrivate
operator|::
name|loadPlugin
parameter_list|()
block|{
if|if
condition|(
name|instance
condition|)
block|{
name|libraryUnloadCount
operator|.
name|ref
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|pluginState
operator|==
name|IsNotAPlugin
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|load
argument_list|()
condition|)
block|{
name|instance
operator|=
operator|(
name|QtPluginInstanceFunction
operator|)
name|resolve
argument_list|(
literal|"qt_plugin_instance"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
if|if
condition|(
operator|!
name|instance
condition|)
block|{
comment|// If resolving with function name failed (i.e. not STDDLL),
comment|// try resolving using known ordinal, which for
comment|// qt_plugin_instance function is always "2".
name|instance
operator|=
operator|(
name|QtPluginInstanceFunction
operator|)
name|resolve
argument_list|(
literal|"2"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|instance
return|;
block|}
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QLibraryPrivate::loadPlugin failed on"
operator|<<
name|fileName
operator|<<
literal|":"
operator|<<
name|errorString
expr_stmt|;
name|pluginState
operator|=
name|IsNotAPlugin
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if \a fileName has a valid suffix for a loadable     library; otherwise returns false.      \table     \header \i Platform \i Valid suffixes     \row \i Windows     \i \c .dll, \c .DLL     \row \i Unix/Linux  \i \c .so     \row \i AIX  \i \c .a     \row \i HP-UX       \i \c .sl, \c .so (HP-UXi)     \row \i Mac OS X    \i \c .dylib, \c .bundle, \c .so     \row \i Symbian     \i \c .dll     \endtable      Trailing versioning numbers on Unix are ignored.  */
end_comment
begin_function
DECL|function|isLibrary
name|bool
name|QLibrary
operator|::
name|isLibrary
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
return|return
name|fileName
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|".dll"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
comment|// Plugin stubs are also considered libraries in Symbian.
return|return
operator|(
name|fileName
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|".dll"
argument_list|)
argument_list|)
operator|||
name|fileName
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|".qtplugin"
argument_list|)
argument_list|)
operator|)
return|;
else|#
directive|else
name|QString
name|completeSuffix
init|=
name|QFileInfo
argument_list|(
name|fileName
argument_list|)
operator|.
name|completeSuffix
argument_list|()
decl_stmt|;
if|if
condition|(
name|completeSuffix
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QStringList
name|suffixes
init|=
name|completeSuffix
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
comment|// On Mac, libs look like libmylib.1.0.0.dylib
specifier|const
name|QString
name|lastSuffix
init|=
name|suffixes
operator|.
name|at
argument_list|(
name|suffixes
operator|.
name|count
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|firstSuffix
init|=
name|suffixes
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|bool
name|valid
init|=
operator|(
name|lastSuffix
operator|==
name|QLatin1String
argument_list|(
literal|"dylib"
argument_list|)
operator|||
name|firstSuffix
operator|==
name|QLatin1String
argument_list|(
literal|"so"
argument_list|)
operator|||
name|firstSuffix
operator|==
name|QLatin1String
argument_list|(
literal|"bundle"
argument_list|)
operator|)
decl_stmt|;
return|return
name|valid
return|;
else|#
directive|else
comment|// Generic Unix
name|QStringList
name|validSuffixList
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
comment|/*     See "HP-UX Linker and Libraries User's Guide", section "Link-time Differences between PA-RISC and IPF":     "In PA-RISC (PA-32 and PA-64) shared libraries are suffixed with .sl. In IPF (32-bit and 64-bit),     the shared libraries are suffixed with .so. For compatibility, the IPF linker also supports the .sl suffix."  */
name|validSuffixList
operator|<<
name|QLatin1String
argument_list|(
literal|"sl"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|__ia64
name|validSuffixList
operator|<<
name|QLatin1String
argument_list|(
literal|"so"
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_AIX
argument_list|)
name|validSuffixList
operator|<<
name|QLatin1String
argument_list|(
literal|"a"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"so"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|validSuffixList
operator|<<
name|QLatin1String
argument_list|(
literal|"so"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Examples of valid library names:
comment|//  libfoo.so
comment|//  libfoo.so.0
comment|//  libfoo.so.0.3
comment|//  libfoo-0.3.so
comment|//  libfoo-0.3.so.0.3.0
name|int
name|suffix
decl_stmt|;
name|int
name|suffixPos
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|suffix
operator|=
literal|0
init|;
name|suffix
operator|<
name|validSuffixList
operator|.
name|count
argument_list|()
operator|&&
name|suffixPos
operator|==
operator|-
literal|1
condition|;
operator|++
name|suffix
control|)
name|suffixPos
operator|=
name|suffixes
operator|.
name|indexOf
argument_list|(
name|validSuffixList
operator|.
name|at
argument_list|(
name|suffix
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|valid
init|=
name|suffixPos
operator|!=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|suffixPos
operator|+
literal|1
init|;
name|i
operator|<
name|suffixes
operator|.
name|count
argument_list|()
operator|&&
name|valid
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|!=
name|suffixPos
condition|)
name|suffixes
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|valid
argument_list|)
expr_stmt|;
return|return
name|valid
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
operator|&&
operator|!
name|defined
argument_list|(
name|Q_CC_INTEL
argument_list|)
end_if
begin_define
DECL|macro|QT_USE_MS_STD_EXCEPTION
define|#
directive|define
name|QT_USE_MS_STD_EXCEPTION
value|1
end_define
begin_function
DECL|function|qt_try_versioninfo
specifier|const
name|char
modifier|*
name|qt_try_versioninfo
parameter_list|(
name|void
modifier|*
name|pfn
parameter_list|,
name|bool
modifier|*
name|exceptionThrown
parameter_list|)
block|{
operator|*
name|exceptionThrown
operator|=
literal|false
expr_stmt|;
specifier|const
name|char
modifier|*
name|szData
init|=
literal|0
decl_stmt|;
typedef|typedef
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|VerificationFunction
function_decl|)
parameter_list|()
function_decl|;
name|VerificationFunction
name|func
init|=
cast|reinterpret_cast
argument_list|<
name|VerificationFunction
argument_list|>
argument_list|(
name|pfn
argument_list|)
decl_stmt|;
name|__try
block|{
if|if
condition|(
name|func
condition|)
name|szData
operator|=
name|func
argument_list|()
expr_stmt|;
block|}
name|__except
argument_list|(
argument|EXCEPTION_EXECUTE_HANDLER
argument_list|)
block|{
operator|*
name|exceptionThrown
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|szData
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_CC_BOR
end_ifdef
begin_typedef
DECL|typedef|QtPluginQueryVerificationDataFunction
typedef|typedef
specifier|const
name|char
modifier|*
name|__stdcall
function_decl|(
modifier|*
name|QtPluginQueryVerificationDataFunction
function_decl|)
parameter_list|()
function_decl|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_typedef
DECL|typedef|QtPluginQueryVerificationDataFunction
typedef|typedef
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|QtPluginQueryVerificationDataFunction
function_decl|)
parameter_list|()
function_decl|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qt_get_verificationdata
name|bool
name|qt_get_verificationdata
parameter_list|(
name|QtPluginQueryVerificationDataFunction
name|pfn
parameter_list|,
name|uint
modifier|*
name|qt_version
parameter_list|,
name|bool
modifier|*
name|debug
parameter_list|,
name|QByteArray
modifier|*
name|key
parameter_list|,
name|bool
modifier|*
name|exceptionThrown
parameter_list|)
block|{
operator|*
name|exceptionThrown
operator|=
literal|false
expr_stmt|;
specifier|const
name|char
modifier|*
name|szData
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pfn
condition|)
return|return
literal|false
return|;
ifdef|#
directive|ifdef
name|QT_USE_MS_STD_EXCEPTION
name|szData
operator|=
name|qt_try_versioninfo
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pfn
argument_list|,
name|exceptionThrown
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|exceptionThrown
condition|)
return|return
literal|false
return|;
else|#
directive|else
name|szData
operator|=
name|pfn
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|qt_parse_pattern
argument_list|(
name|szData
argument_list|,
name|qt_version
argument_list|,
name|debug
argument_list|,
name|key
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isPlugin
name|bool
name|QLibraryPrivate
operator|::
name|isPlugin
parameter_list|(
name|QSettings
modifier|*
name|settings
parameter_list|)
block|{
name|errorString
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|pluginState
operator|!=
name|MightBeAPlugin
condition|)
return|return
name|pluginState
operator|==
name|IsAPlugin
return|;
ifndef|#
directive|ifndef
name|QT_NO_PLUGIN_CHECK
name|bool
name|debug
init|=
operator|!
name|QLIBRARY_AS_DEBUG
decl_stmt|;
name|QByteArray
name|key
decl_stmt|;
name|bool
name|success
init|=
literal|false
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
if|if
condition|(
name|fileName
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|".debug"
argument_list|)
argument_list|)
condition|)
block|{
comment|// refuse to load a file that ends in .debug
comment|// these are the debug symbols from the libraries
comment|// the problem is that they are valid shared library files
comment|// and dlopen is known to crash while opening them
comment|// pretend we didn't see the file
name|errorString
operator|=
name|QLibrary
operator|::
name|tr
argument_list|(
literal|"The shared library was not found."
argument_list|)
expr_stmt|;
name|pluginState
operator|=
name|IsNotAPlugin
expr_stmt|;
return|return
literal|false
return|;
block|}
endif|#
directive|endif
name|QFileInfo
name|fileinfo
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
name|lastModified
operator|=
name|fileinfo
operator|.
name|lastModified
argument_list|()
operator|.
name|toString
argument_list|(
name|Qt
operator|::
name|ISODate
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QString
name|regkey
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"Qt Plugin Cache %1.%2.%3/%4"
argument_list|)
operator|.
name|arg
argument_list|(
operator|(
name|QT_VERSION
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
argument_list|)
operator|.
name|arg
argument_list|(
operator|(
name|QT_VERSION
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
operator|.
name|arg
argument_list|(
name|QLIBRARY_AS_DEBUG
condition|?
name|QLatin1String
argument_list|(
literal|"debug"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"false"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_WS_MAC
comment|// On Mac, add the application arch to the reg key in order to
comment|// cache plugin information separately for each arch. This prevents
comment|// Qt from wrongly caching plugin load failures when the archs
comment|// don't match.
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
name|regkey
operator|+=
name|QLatin1String
argument_list|(
literal|"-x86_64"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__i386__
argument_list|)
name|regkey
operator|+=
name|QLatin1String
argument_list|(
literal|"-i386"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__ppc64__
argument_list|)
name|regkey
operator|+=
name|QLatin1String
argument_list|(
literal|"-ppc64"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__ppc__
argument_list|)
name|regkey
operator|+=
name|QLatin1String
argument_list|(
literal|"-ppc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|// Q_WS_MAC
name|QStringList
name|reg
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SETTINGS
if|if
condition|(
operator|!
name|settings
condition|)
block|{
name|settings
operator|=
name|libraryData
argument_list|()
operator|->
name|settings
expr_stmt|;
if|if
condition|(
operator|!
name|settings
condition|)
block|{
name|settings
operator|=
operator|new
name|QSettings
argument_list|(
name|QSettings
operator|::
name|UserScope
argument_list|,
name|QLatin1String
argument_list|(
literal|"Trolltech"
argument_list|)
argument_list|)
expr_stmt|;
name|libraryData
argument_list|()
operator|->
name|settings
operator|=
name|settings
expr_stmt|;
block|}
block|}
name|reg
operator|=
name|settings
operator|->
name|value
argument_list|(
name|regkey
argument_list|)
operator|.
name|toStringList
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|reg
operator|.
name|count
argument_list|()
operator|==
literal|4
operator|&&
name|lastModified
operator|==
name|reg
operator|.
name|at
argument_list|(
literal|3
argument_list|)
condition|)
block|{
name|qt_version
operator|=
name|reg
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toUInt
argument_list|(
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|debug
operator|=
name|bool
argument_list|(
name|reg
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|=
name|reg
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|success
operator|=
name|qt_version
operator|!=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
if|if
condition|(
operator|!
name|pHnd
condition|)
block|{
comment|// use unix shortcut to avoid loading the library
name|success
operator|=
name|qt_unix_query
argument_list|(
name|fileName
argument_list|,
operator|&
name|qt_version
argument_list|,
operator|&
name|debug
argument_list|,
operator|&
name|key
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|bool
name|retryLoadLibrary
init|=
literal|false
decl_stmt|;
comment|// Only used on Windows with MS compiler.(false in other cases)
do|do
block|{
name|bool
name|temporary_load
init|=
literal|false
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|HMODULE
name|hTempModule
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pHnd
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|DWORD
name|dwFlags
init|=
operator|(
name|retryLoadLibrary
operator|)
condition|?
literal|0
else|:
name|DONT_RESOLVE_DLL_REFERENCES
decl_stmt|;
comment|//avoid 'Bad Image' message box
name|UINT
name|oldmode
init|=
name|SetErrorMode
argument_list|(
name|SEM_FAILCRITICALERRORS
operator||
name|SEM_NOOPENFILEERRORBOX
argument_list|)
decl_stmt|;
name|hTempModule
operator|=
operator|::
name|LoadLibraryEx
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|fileName
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dwFlags
argument_list|)
expr_stmt|;
name|SetErrorMode
argument_list|(
name|oldmode
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
comment|//Guard against accidentally trying to load non-plugin libraries by making sure the stub exists
if|if
condition|(
name|fileinfo
operator|.
name|exists
argument_list|()
condition|)
endif|#
directive|endif
name|temporary_load
operator|=
name|load_sys
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|QtPluginQueryVerificationDataFunction
name|qtPluginQueryVerificationDataFunction
init|=
name|hTempModule
condition|?
operator|(
name|QtPluginQueryVerificationDataFunction
operator|)
ifdef|#
directive|ifdef
name|Q_OS_WINCE
operator|::
name|GetProcAddress
argument_list|(
name|hTempModule
argument_list|,
literal|L"qt_plugin_query_verification_data"
argument_list|)
else|#
directive|else
operator|::
name|GetProcAddress
argument_list|(
name|hTempModule
argument_list|,
literal|"qt_plugin_query_verification_data"
argument_list|)
endif|#
directive|endif
else|:
operator|(
name|QtPluginQueryVerificationDataFunction
operator|)
name|resolve
argument_list|(
literal|"qt_plugin_query_verification_data"
argument_list|)
decl_stmt|;
else|#
directive|else
name|QtPluginQueryVerificationDataFunction
name|qtPluginQueryVerificationDataFunction
init|=
name|NULL
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
if|if
condition|(
name|temporary_load
condition|)
block|{
name|qtPluginQueryVerificationDataFunction
operator|=
operator|(
name|QtPluginQueryVerificationDataFunction
operator|)
name|resolve
argument_list|(
literal|"qt_plugin_query_verification_data"
argument_list|)
expr_stmt|;
comment|// If resolving with function name failed (i.e. not STDDLL), try resolving using known ordinal
if|if
condition|(
operator|!
name|qtPluginQueryVerificationDataFunction
condition|)
name|qtPluginQueryVerificationDataFunction
operator|=
operator|(
name|QtPluginQueryVerificationDataFunction
operator|)
name|resolve
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|qtPluginQueryVerificationDataFunction
operator|=
operator|(
name|QtPluginQueryVerificationDataFunction
operator|)
name|resolve
argument_list|(
literal|"qt_plugin_query_verification_data"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|bool
name|exceptionThrown
init|=
literal|false
decl_stmt|;
name|bool
name|ret
init|=
name|qt_get_verificationdata
argument_list|(
name|qtPluginQueryVerificationDataFunction
argument_list|,
operator|&
name|qt_version
argument_list|,
operator|&
name|debug
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|exceptionThrown
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|exceptionThrown
condition|)
block|{
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|qt_version
operator|=
literal|0
expr_stmt|;
name|key
operator|=
literal|"unknown"
expr_stmt|;
if|if
condition|(
name|temporary_load
condition|)
name|unload_sys
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
literal|true
expr_stmt|;
block|}
name|retryLoadLibrary
operator|=
literal|false
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QT_USE_MS_STD_EXCEPTION
else|else
block|{
comment|// An exception was thrown when calling qt_plugin_query_verification_data().
comment|// This usually happens when plugin is compiled with the /clr compiler flag,
comment|//& will only work if the dependencies are loaded& DLLMain() is called.
comment|// LoadLibrary() will do this, try once with this& if it fails dont load.
name|retryLoadLibrary
operator|=
operator|!
name|retryLoadLibrary
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
name|hTempModule
condition|)
block|{
name|BOOL
name|ok
init|=
operator|::
name|FreeLibrary
argument_list|(
name|hTempModule
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|hTempModule
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
do|while
condition|(
name|retryLoadLibrary
condition|)
do|;
comment|// Will be 'false' in all cases other than when an
comment|// exception is thrown(will happen only when using a MS compiler)
block|}
comment|// Qt 4.5 compatibility: stl doesn't affect binary compatibility
name|key
operator|.
name|replace
argument_list|(
literal|" no-stl"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SETTINGS
name|QStringList
name|queried
decl_stmt|;
name|queried
operator|<<
name|QString
operator|::
name|number
argument_list|(
name|qt_version
argument_list|,
literal|16
argument_list|)
operator|<<
name|QString
operator|::
name|number
argument_list|(
operator|(
name|int
operator|)
name|debug
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
name|key
argument_list|)
operator|<<
name|lastModified
expr_stmt|;
name|settings
operator|->
name|setValue
argument_list|(
name|regkey
argument_list|,
name|queried
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|errorString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
name|errorString
operator|=
name|QLibrary
operator|::
name|tr
argument_list|(
literal|"The shared library was not found."
argument_list|)
expr_stmt|;
else|else
name|errorString
operator|=
name|QLibrary
operator|::
name|tr
argument_list|(
literal|"The file '%1' is not a valid Qt plugin."
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|pluginState
operator|=
name|IsNotAPlugin
expr_stmt|;
comment|// be pessimistic
if|if
condition|(
operator|(
name|qt_version
operator|&
literal|0x00ff00
operator|)
operator|>
operator|(
name|QT_VERSION
operator|&
literal|0x00ff00
operator|)
operator|||
operator|(
name|qt_version
operator|&
literal|0xff0000
operator|)
operator|!=
operator|(
name|QT_VERSION
operator|&
literal|0xff0000
operator|)
condition|)
block|{
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"In %s:\n"
literal|"  Plugin uses incompatible Qt library (%d.%d.%d) [%s]"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|QFile
operator|::
name|encodeName
argument_list|(
name|fileName
argument_list|)
argument_list|,
operator|(
name|qt_version
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
argument_list|,
operator|(
name|qt_version
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|,
name|qt_version
operator|&
literal|0xff
argument_list|,
name|debug
condition|?
literal|"debug"
else|:
literal|"release"
argument_list|)
expr_stmt|;
block|}
name|errorString
operator|=
name|QLibrary
operator|::
name|tr
argument_list|(
literal|"The plugin '%1' uses incompatible Qt library. (%2.%3.%4) [%5]"
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
operator|.
name|arg
argument_list|(
operator|(
name|qt_version
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
argument_list|)
operator|.
name|arg
argument_list|(
operator|(
name|qt_version
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
operator|.
name|arg
argument_list|(
name|qt_version
operator|&
literal|0xff
argument_list|)
operator|.
name|arg
argument_list|(
name|debug
condition|?
name|QLatin1String
argument_list|(
literal|"debug"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"release"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|!=
name|QT_BUILD_KEY
comment|// we may have some compatibility keys, try them too:
ifdef|#
directive|ifdef
name|QT_BUILD_KEY_COMPAT
operator|&&
name|key
operator|!=
name|QT_BUILD_KEY_COMPAT
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_BUILD_KEY_COMPAT2
operator|&&
name|key
operator|!=
name|QT_BUILD_KEY_COMPAT2
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_BUILD_KEY_COMPAT3
operator|&&
name|key
operator|!=
name|QT_BUILD_KEY_COMPAT3
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"In %s:\n"
literal|"  Plugin uses incompatible Qt library\n"
literal|"  expected build key \"%s\", got \"%s\""
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|QFile
operator|::
name|encodeName
argument_list|(
name|fileName
argument_list|)
argument_list|,
name|QT_BUILD_KEY
argument_list|,
name|key
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"<null>"
else|:
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|)
expr_stmt|;
block|}
name|errorString
operator|=
name|QLibrary
operator|::
name|tr
argument_list|(
literal|"The plugin '%1' uses incompatible Qt library."
literal|" Expected build key \"%2\", got \"%3\""
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
operator|.
name|arg
argument_list|(
name|QLatin1String
argument_list|(
name|QT_BUILD_KEY
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|key
operator|.
name|isEmpty
argument_list|()
condition|?
name|QLatin1String
argument_list|(
literal|"<null>"
argument_list|)
else|:
name|QLatin1String
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_PLUGIN_CHECK
block|}
elseif|else
if|if
condition|(
name|debug
operator|!=
name|QLIBRARY_AS_DEBUG
condition|)
block|{
comment|//don't issue a qWarning since we will hopefully find a non-debug? --Sam
name|errorString
operator|=
name|QLibrary
operator|::
name|tr
argument_list|(
literal|"The plugin '%1' uses incompatible Qt library."
literal|" (Cannot mix debug and release libraries.)"
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|pluginState
operator|=
name|IsAPlugin
expr_stmt|;
block|}
return|return
name|pluginState
operator|==
name|IsAPlugin
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|settings
argument_list|)
expr_stmt|;
return|return
name|pluginState
operator|==
name|MightBeAPlugin
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     Loads the library and returns true if the library was loaded     successfully; otherwise returns false. Since resolve() always     calls this function before resolving any symbols it is not     necessary to call it explicitly. In some situations you might want     the library loaded in advance, in which case you would use this     function.      \sa unload() */
end_comment
begin_function
DECL|function|load
name|bool
name|QLibrary
operator|::
name|load
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|did_load
condition|)
return|return
name|d
operator|->
name|pHnd
return|;
name|did_load
operator|=
literal|true
expr_stmt|;
return|return
name|d
operator|->
name|load
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Unloads the library and returns true if the library could be     unloaded; otherwise returns false.      This happens automatically on application termination, so you     shouldn't normally need to call this function.      If other instances of QLibrary are using the same library, the     call will fail, and unloading will only happen when every instance     has called unload().      Note that on Mac OS X 10.3 (Panther), dynamic libraries cannot be unloaded.      \sa resolve(), load() */
end_comment
begin_function
DECL|function|unload
name|bool
name|QLibrary
operator|::
name|unload
parameter_list|()
block|{
if|if
condition|(
name|did_load
condition|)
block|{
name|did_load
operator|=
literal|false
expr_stmt|;
return|return
name|d
operator|->
name|unload
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the library is loaded; otherwise returns false.      \sa load()  */
end_comment
begin_function
DECL|function|isLoaded
name|bool
name|QLibrary
operator|::
name|isLoaded
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|&&
name|d
operator|->
name|pHnd
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a library with the given \a parent.  */
end_comment
begin_constructor
DECL|function|QLibrary
name|QLibrary
operator|::
name|QLibrary
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|d
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|did_load
argument_list|(
literal|false
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a library object with the given \a parent that will     load the library specified by \a fileName.      We recommend omitting the file's suffix in \a fileName, since     QLibrary will automatically look for the file with the appropriate     suffix in accordance with the platform, e.g. ".so" on Unix,     ".dylib" on Mac OS X, and ".dll" on Windows. (See \l{fileName}.)      Note: In Symbian the path portion of the \a fileName is ignored.  */
end_comment
begin_constructor
DECL|function|QLibrary
name|QLibrary
operator|::
name|QLibrary
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|d
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|did_load
argument_list|(
literal|false
argument_list|)
block|{
name|setFileName
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a library object with the given \a parent that will     load the library specified by \a fileName and major version number \a verNum.     Currently, the version number is ignored on Windows and Symbian.      We recommend omitting the file's suffix in \a fileName, since     QLibrary will automatically look for the file with the appropriate     suffix in accordance with the platform, e.g. ".so" on Unix,     ".dylib" on Mac OS X, and ".dll" on Windows. (See \l{fileName}.)      Note: In Symbian the path portion of the \a fileName is ignored. */
end_comment
begin_constructor
DECL|function|QLibrary
name|QLibrary
operator|::
name|QLibrary
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|int
name|verNum
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|d
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|did_load
argument_list|(
literal|false
argument_list|)
block|{
name|setFileNameAndVersion
argument_list|(
name|fileName
argument_list|,
name|verNum
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a library object with the given \a parent that will     load the library specified by \a fileName and full version number \a version.     Currently, the version number is ignored on Windows and Symbian.      We recommend omitting the file's suffix in \a fileName, since     QLibrary will automatically look for the file with the appropriate     suffix in accordance with the platform, e.g. ".so" on Unix,     ".dylib" on Mac OS X, and ".dll" on Windows. (See \l{fileName}.)      Note: In Symbian the path portion of the \a fileName is ignored.  */
end_comment
begin_constructor
DECL|function|QLibrary
name|QLibrary
operator|::
name|QLibrary
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|d
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|did_load
argument_list|(
literal|false
argument_list|)
block|{
name|setFileNameAndVersion
argument_list|(
name|fileName
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QLibrary object.      Unless unload() was called explicitly, the library stays in memory     until the application terminates.      \sa isLoaded(), unload() */
end_comment
begin_destructor
DECL|function|~QLibrary
name|QLibrary
operator|::
name|~
name|QLibrary
parameter_list|()
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \property QLibrary::fileName     \brief the file name of the library      We recommend omitting the file's suffix in the file name, since     QLibrary will automatically look for the file with the appropriate     suffix (see isLibrary()).      When loading the library, QLibrary searches in all system-specific     library locations (e.g. \c LD_LIBRARY_PATH on Unix), unless the     file name has an absolute path. After loading the library     successfully, fileName() returns the fully-qualified file name of     the library, including the full path to the library if one was given     in the constructor or passed to setFileName().      For example, after successfully loading the "GL" library on Unix     platforms, fileName() will return "libGL.so". If the file name was     originally passed as "/usr/lib/libGL", fileName() will return     "/usr/lib/libGL.so".      Note: In Symbian the path portion of the \a fileName is ignored. */
end_comment
begin_function
DECL|function|setFileName
name|void
name|QLibrary
operator|::
name|setFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QLibrary
operator|::
name|LoadHints
name|lh
decl_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|lh
operator|=
name|d
operator|->
name|loadHints
expr_stmt|;
name|d
operator|->
name|release
argument_list|()
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
name|did_load
operator|=
literal|false
expr_stmt|;
block|}
name|d
operator|=
name|QLibraryPrivate
operator|::
name|findOrCreate
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|d
operator|->
name|loadHints
operator|=
name|lh
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fileName
name|QString
name|QLibrary
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|qualifiedFileName
operator|.
name|isEmpty
argument_list|()
condition|?
name|d
operator|->
name|fileName
else|:
name|d
operator|->
name|qualifiedFileName
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QLibrary::setFileNameAndVersion(const QString&fileName, int versionNumber)      Sets the fileName property and major version number to \a fileName     and \a versionNumber respectively.     The \a versionNumber is ignored on Windows and Symbian.      Note: In Symbian the path portion of the \a fileName is ignored.      \sa setFileName() */
end_comment
begin_function
DECL|function|setFileNameAndVersion
name|void
name|QLibrary
operator|::
name|setFileNameAndVersion
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|int
name|verNum
parameter_list|)
block|{
name|QLibrary
operator|::
name|LoadHints
name|lh
decl_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|lh
operator|=
name|d
operator|->
name|loadHints
expr_stmt|;
name|d
operator|->
name|release
argument_list|()
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
name|did_load
operator|=
literal|false
expr_stmt|;
block|}
name|d
operator|=
name|QLibraryPrivate
operator|::
name|findOrCreate
argument_list|(
name|fileName
argument_list|,
name|verNum
operator|>=
literal|0
condition|?
name|QString
operator|::
name|number
argument_list|(
name|verNum
argument_list|)
else|:
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|loadHints
operator|=
name|lh
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the fileName property and full version number to \a fileName     and \a version respectively.     The \a version parameter is ignored on Windows and Symbian.      Note: In Symbian the path portion of the \a fileName is ignored.      \sa setFileName() */
end_comment
begin_function
DECL|function|setFileNameAndVersion
name|void
name|QLibrary
operator|::
name|setFileNameAndVersion
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
block|{
name|QLibrary
operator|::
name|LoadHints
name|lh
decl_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|lh
operator|=
name|d
operator|->
name|loadHints
expr_stmt|;
name|d
operator|->
name|release
argument_list|()
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
name|did_load
operator|=
literal|false
expr_stmt|;
block|}
name|d
operator|=
name|QLibraryPrivate
operator|::
name|findOrCreate
argument_list|(
name|fileName
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|d
operator|->
name|loadHints
operator|=
name|lh
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the address of the exported symbol \a symbol. The library is     loaded if necessary. The function returns 0 if the symbol could     not be resolved or if the library could not be loaded.      Example:     \snippet doc/src/snippets/code/src_corelib_plugin_qlibrary.cpp 2      The symbol must be exported as a C function from the library. This     means that the function must be wrapped in an \c{extern "C"} if     the library is compiled with a C++ compiler. On Windows you must     also explicitly export the function from the DLL using the     \c{__declspec(dllexport)} compiler directive, for example:      \snippet doc/src/snippets/code/src_corelib_plugin_qlibrary.cpp 3      with \c MY_EXPORT defined as      \snippet doc/src/snippets/code/src_corelib_plugin_qlibrary.cpp 4      Note: In Symbian resolving with symbol names works only if the loaded     library was built as STDDLL. Otherwise, the ordinals must be used. */
end_comment
begin_function
DECL|function|resolve
name|void
modifier|*
name|QLibrary
operator|::
name|resolve
parameter_list|(
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isLoaded
argument_list|()
operator|&&
operator|!
name|load
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|resolve
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Loads the library \a fileName and returns the address of the     exported symbol \a symbol. Note that \a fileName should not     include the platform-specific file suffix; (see \l{fileName}). The     library remains loaded until the application exits.      The function returns 0 if the symbol could not be resolved or if     the library could not be loaded.      Note: In Symbian resolving with symbol names works only if the loaded     library was built as STDDLL. Otherwise, the ordinals must be used.      \sa resolve() */
end_comment
begin_function
DECL|function|resolve
name|void
modifier|*
name|QLibrary
operator|::
name|resolve
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
name|QLibrary
name|library
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
return|return
name|library
operator|.
name|resolve
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Loads the library \a fileName with major version number \a verNum and     returns the address of the exported symbol \a symbol.     Note that \a fileName should not include the platform-specific file suffix;     (see \l{fileName}). The library remains loaded until the application exits.     \a verNum is ignored on Windows.      The function returns 0 if the symbol could not be resolved or if     the library could not be loaded.      Note: In Symbian resolving with symbol names works only if the loaded     library was built as STDDLL. Otherwise, the ordinals must be used.      \sa resolve() */
end_comment
begin_function
DECL|function|resolve
name|void
modifier|*
name|QLibrary
operator|::
name|resolve
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|int
name|verNum
parameter_list|,
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
name|QLibrary
name|library
argument_list|(
name|fileName
argument_list|,
name|verNum
argument_list|)
decl_stmt|;
return|return
name|library
operator|.
name|resolve
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.4      Loads the library \a fileName with full version number \a version and     returns the address of the exported symbol \a symbol.     Note that \a fileName should not include the platform-specific file suffix;     (see \l{fileName}). The library remains loaded until the application exits.     \a version is ignored on Windows.      The function returns 0 if the symbol could not be resolved or if     the library could not be loaded.      Note: In Symbian resolving with symbol names works only if the loaded     library was built as STDDLL. Otherwise, the ordinals must be used.      \sa resolve() */
end_comment
begin_function
DECL|function|resolve
name|void
modifier|*
name|QLibrary
operator|::
name|resolve
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|,
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
name|QLibrary
name|library
argument_list|(
name|fileName
argument_list|,
name|version
argument_list|)
decl_stmt|;
return|return
name|library
operator|.
name|resolve
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn QString QLibrary::library() const      Use fileName() instead. */
end_comment
begin_comment
comment|/*!     \fn void QLibrary::setAutoUnload( bool b )      Use load(), isLoaded(), and unload() as necessary instead. */
end_comment
begin_comment
comment|/*!     \since 4.2      Returns a text string with the description of the last error that occurred.     Currently, errorString will only be set if load(), unload() or resolve() for some reason fails. */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QLibrary
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
return|return
operator|(
operator|!
name|d
operator|||
name|d
operator|->
name|errorString
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
name|tr
argument_list|(
literal|"Unknown error"
argument_list|)
else|:
name|d
operator|->
name|errorString
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLibrary::loadHints     \brief Give the load() function some hints on how it should behave.      You can give some hints on how the symbols are resolved. Usually,     the symbols are not resolved at load time, but resolved lazily,     (that is, when resolve() is called). If you set the loadHint to     ResolveAllSymbolsHint, then all symbols will be resolved at load time     if the platform supports it.      Setting ExportExternalSymbolsHint will make the external symbols in the     library available for resolution in subsequent loaded libraries.      If LoadArchiveMemberHint is set, the file name     is composed of two components: A path which is a reference to an     archive file followed by the second component which is the reference to     the archive member. For instance, the fileName \c libGL.a(shr_64.o) will refer     to the library \c shr_64.o in the archive file named \c libGL.a. This     is only supported on the AIX platform.      The interpretation of the load hints is platform dependent, and if     you use it you are probably making some assumptions on which platform     you are compiling for, so use them only if you understand the consequences     of them.      By default, none of these flags are set, so libraries will be loaded with     lazy symbol resolution, and will not export external symbols for resolution     in other dynamically-loaded libraries. */
end_comment
begin_function
DECL|function|setLoadHints
name|void
name|QLibrary
operator|::
name|setLoadHints
parameter_list|(
name|LoadHints
name|hints
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|d
operator|=
name|QLibraryPrivate
operator|::
name|findOrCreate
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
comment|// ugly, but we need a d-ptr
name|d
operator|->
name|errorString
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|loadHints
operator|=
name|hints
expr_stmt|;
block|}
end_function
begin_function
DECL|function|loadHints
name|QLibrary
operator|::
name|LoadHints
name|QLibrary
operator|::
name|loadHints
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|loadHints
else|:
operator|(
name|QLibrary
operator|::
name|LoadHints
operator|)
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Internal, for debugging */
end_comment
begin_function
DECL|function|qt_debug_component
name|bool
name|qt_debug_component
parameter_list|()
block|{
specifier|static
name|int
name|debug_env
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|debug_env
operator|==
operator|-
literal|1
condition|)
name|debug_env
operator|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qgetenv
argument_list|)
argument_list|(
literal|"QT_DEBUG_PLUGINS"
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
return|return
name|debug_env
operator|!=
literal|0
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_LIBRARY
end_comment
end_unit
