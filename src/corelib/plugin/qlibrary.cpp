begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Copyright (C) 2013 Intel Corporation ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qlibrary.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
end_ifndef
begin_include
include|#
directive|include
file|"qlibrary_p.h"
end_include
begin_include
include|#
directive|include
file|<qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<qfile.h>
end_include
begin_include
include|#
directive|include
file|<qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<qmutex.h>
end_include
begin_include
include|#
directive|include
file|<qmap.h>
end_include
begin_include
include|#
directive|include
file|<private/qcoreapplication_p.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_MAC
end_ifdef
begin_include
include|#
directive|include
file|<private/qcore_mac_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|NO_ERRNO_H
end_ifndef
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// NO_ERROR_H
end_comment
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qvector.h>
end_include
begin_include
include|#
directive|include
file|<qdir.h>
end_include
begin_include
include|#
directive|include
file|<qendian.h>
end_include
begin_include
include|#
directive|include
file|<qjsondocument.h>
end_include
begin_include
include|#
directive|include
file|<qjsonvalue.h>
end_include
begin_include
include|#
directive|include
file|"qelfparser_p.h"
end_include
begin_include
include|#
directive|include
file|"qmachparser_p.h"
end_include
begin_function
name|QT_BEGIN_NAMESPACE
ifdef|#
directive|ifdef
name|QT_NO_DEBUG
DECL|macro|QLIBRARY_AS_DEBUG
define|#
directive|define
name|QLIBRARY_AS_DEBUG
value|false
else|#
directive|else
define|#
directive|define
name|QLIBRARY_AS_DEBUG
value|true
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
comment|// We don't use separate debug and release libs on UNIX, so we want
comment|// to allow loading plugins, regardless of how they were built.
DECL|macro|QT_NO_DEBUG_PLUGIN_CHECK
define|#
directive|define
name|QT_NO_DEBUG_PLUGIN_CHECK
endif|#
directive|endif
comment|/*!     \class QLibrary     \inmodule QtCore     \reentrant     \brief The QLibrary class loads shared libraries at runtime.       \ingroup plugins      An instance of a QLibrary object operates on a single shared     object file (which we call a "library", but is also known as a     "DLL"). A QLibrary provides access to the functionality in the     library in a platform independent way. You can either pass a file     name in the constructor, or set it explicitly with setFileName().     When loading the library, QLibrary searches in all the     system-specific library locations (e.g. \c LD_LIBRARY_PATH on     Unix), unless the file name has an absolute path.      If the file name is an absolute path then an attempt is made to     load this path first. If the file cannot be found, QLibrary tries     the name with different platform-specific file prefixes, like     "lib" on Unix and Mac, and suffixes, like ".so" on Unix, ".dylib"     on the Mac, or ".dll" on Windows.      If the file path is not absolute then QLibrary modifies the search     order to try the system-specific prefixes and suffixes first,     followed by the file path specified.      This makes it possible to specify shared libraries that are only     identified by their basename (i.e. without their suffix), so the     same code will work on different operating systems yet still     minimise the number of attempts to find the library.      The most important functions are load() to dynamically load the     library file, isLoaded() to check whether loading was successful,     and resolve() to resolve a symbol in the library. The resolve()     function implicitly tries to load the library if it has not been     loaded yet. Multiple instances of QLibrary can be used to access     the same physical library. Once loaded, libraries remain in memory     until the application terminates. You can attempt to unload a     library using unload(), but if other instances of QLibrary are     using the same library, the call will fail, and unloading will     only happen when every instance has called unload().      A typical use of QLibrary is to resolve an exported symbol in a     library, and to call the C function that this symbol represents.     This is called "explicit linking" in contrast to "implicit     linking", which is done by the link step in the build process when     linking an executable against a library.      The following code snippet loads a library, resolves the symbol     "mysymbol", and calls the function if everything succeeded. If     something goes wrong, e.g. the library file does not exist or the     symbol is not defined, the function pointer will be 0 and won't be     called.      \snippet code/src_corelib_plugin_qlibrary.cpp 0      The symbol must be exported as a C function from the library for     resolve() to work. This means that the function must be wrapped in     an \c{extern "C"} block if the library is compiled with a C++     compiler. On Windows, this also requires the use of a \c dllexport     macro; see resolve() for the details of how this is done. For     convenience, there is a static resolve() function which you can     use if you just want to call a function in a library without     explicitly loading the library first:      \snippet code/src_corelib_plugin_qlibrary.cpp 1      \sa QPluginLoader */
comment|/*!     \enum QLibrary::LoadHint      This enum describes the possible hints that can be used to change the way     libraries are handled when they are loaded. These values indicate how     symbols are resolved when libraries are loaded, and are specified using     the setLoadHints() function.      \value ResolveAllSymbolsHint     Causes all symbols in a library to be resolved when it is loaded, not     simply when resolve() is called.     \value ExportExternalSymbolsHint     Exports unresolved and external symbols in the library so that they can be     resolved in other dynamically-loaded libraries loaded later.     \value LoadArchiveMemberHint     Allows the file name of the library to specify a particular object file     within an archive file.     If this hint is given, the filename of the library consists of     a path, which is a reference to an archive file, followed by     a reference to the archive member.     \value PreventUnloadHint     Prevents the library from being unloaded from the address space if close()     is called. The library's static variables are not reinitialized if open()     is called at a later time.      \sa loadHints */
DECL|function|qt_find_pattern
specifier|static
name|long
name|qt_find_pattern
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|ulong
name|s_len
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|ulong
name|p_len
parameter_list|)
block|{
comment|/*       we search from the end of the file because on the supported       systems, the read-only data/text segments are placed at the end       of the file.  HOWEVER, when building with debugging enabled, all       the debug symbols are placed AFTER the data/text segments.        what does this mean?  when building in release mode, the search       is fast because the data we are looking for is at the end of the       file... when building in debug mode, the search is slower       because we have to skip over all the debugging symbols first     */
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|pattern
operator|||
name|p_len
operator|>
name|s_len
condition|)
return|return
operator|-
literal|1
return|;
name|ulong
name|i
decl_stmt|,
name|hs
init|=
literal|0
decl_stmt|,
name|hp
init|=
literal|0
decl_stmt|,
name|delta
init|=
name|s_len
operator|-
name|p_len
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_len
condition|;
operator|++
name|i
control|)
block|{
name|hs
operator|+=
name|s
index|[
name|delta
operator|+
name|i
index|]
expr_stmt|;
name|hp
operator|+=
name|pattern
index|[
name|i
index|]
expr_stmt|;
block|}
name|i
operator|=
name|delta
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|hs
operator|==
name|hp
operator|&&
name|qstrncmp
argument_list|(
name|s
operator|+
name|i
argument_list|,
name|pattern
argument_list|,
name|p_len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
operator|--
name|i
expr_stmt|;
name|hs
operator|-=
name|s
index|[
name|i
operator|+
name|p_len
index|]
expr_stmt|;
name|hs
operator|+=
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*   This opens the specified library, mmaps it into memory, and searches   for the QT_PLUGIN_VERIFICATION_DATA.  The advantage of this approach is that   we can get the verification data without have to actually load the library.   This lets us detect mismatches more safely.    Returns false if version information is not present, or if the                 information could not be read.   Returns  true if version information is present and successfully read. */
end_comment
begin_function
DECL|function|findPatternUnloaded
specifier|static
name|bool
name|findPatternUnloaded
parameter_list|(
specifier|const
name|QString
modifier|&
name|library
parameter_list|,
name|QLibraryPrivate
modifier|*
name|lib
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|library
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
if|if
condition|(
name|lib
condition|)
name|lib
operator|->
name|errorString
operator|=
name|file
operator|.
name|errorString
argument_list|()
expr_stmt|;
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"%s: %s"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|QFile
operator|::
name|encodeName
argument_list|(
name|library
argument_list|)
argument_list|,
name|qPrintable
argument_list|(
name|qt_error_string
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|QByteArray
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|filedata
init|=
literal|0
decl_stmt|;
name|ulong
name|fdlen
init|=
name|file
operator|.
name|size
argument_list|()
decl_stmt|;
name|filedata
operator|=
operator|(
name|char
operator|*
operator|)
name|file
operator|.
name|map
argument_list|(
literal|0
argument_list|,
name|fdlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|filedata
operator|==
literal|0
condition|)
block|{
comment|// try reading the data into memory instead
name|data
operator|=
name|file
operator|.
name|readAll
argument_list|()
expr_stmt|;
name|filedata
operator|=
name|data
operator|.
name|constData
argument_list|()
expr_stmt|;
name|fdlen
operator|=
name|data
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|/*        ELF and Mach-O binaries with GCC have .qplugin sections.     */
name|bool
name|hasMetaData
init|=
literal|false
decl_stmt|;
name|long
name|pos
init|=
literal|0
decl_stmt|;
specifier|const
name|char
name|pattern
index|[]
init|=
literal|"QTMETADATA  "
decl_stmt|;
specifier|const
name|ulong
name|plen
init|=
name|qstrlen
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OF_ELF
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
name|int
name|r
init|=
name|QElfParser
argument_list|()
operator|.
name|parse
argument_list|(
name|filedata
argument_list|,
name|fdlen
argument_list|,
name|library
argument_list|,
name|lib
argument_list|,
operator|&
name|pos
argument_list|,
operator|&
name|fdlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|QElfParser
operator|::
name|Corrupt
operator|||
name|r
operator|==
name|QElfParser
operator|::
name|NotElf
condition|)
block|{
if|if
condition|(
name|lib
operator|&&
name|qt_debug_component
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QElfParser: %s"
argument_list|,
name|qPrintable
argument_list|(
name|lib
operator|->
name|errorString
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|QElfParser
operator|::
name|QtMetaDataSection
condition|)
block|{
name|long
name|rel
init|=
name|qt_find_pattern
argument_list|(
name|filedata
operator|+
name|pos
argument_list|,
name|fdlen
argument_list|,
name|pattern
argument_list|,
name|plen
argument_list|)
decl_stmt|;
if|if
condition|(
name|rel
operator|<
literal|0
condition|)
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|pos
operator|+=
name|rel
expr_stmt|;
name|hasMetaData
operator|=
literal|true
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OF_MACH_O
argument_list|)
block|{
name|QString
name|errorString
decl_stmt|;
name|int
name|r
init|=
name|QMachOParser
operator|::
name|parse
argument_list|(
name|filedata
argument_list|,
name|fdlen
argument_list|,
name|library
argument_list|,
operator|&
name|errorString
argument_list|,
operator|&
name|pos
argument_list|,
operator|&
name|fdlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|QMachOParser
operator|::
name|NotSuitable
condition|)
block|{
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"QMachOParser: %s"
argument_list|,
name|qPrintable
argument_list|(
name|errorString
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lib
condition|)
name|lib
operator|->
name|errorString
operator|=
name|errorString
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// even if the metadata section was not found, the Mach-O parser will
comment|// at least return the boundaries of the right architecture
name|long
name|rel
init|=
name|qt_find_pattern
argument_list|(
name|filedata
operator|+
name|pos
argument_list|,
name|fdlen
argument_list|,
name|pattern
argument_list|,
name|plen
argument_list|)
decl_stmt|;
if|if
condition|(
name|rel
operator|<
literal|0
condition|)
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|pos
operator|+=
name|rel
expr_stmt|;
name|hasMetaData
operator|=
literal|true
expr_stmt|;
block|}
else|#
directive|else
name|pos
operator|=
name|qt_find_pattern
argument_list|(
name|filedata
argument_list|,
name|fdlen
argument_list|,
name|pattern
argument_list|,
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|hasMetaData
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
comment|// defined(Q_OF_ELF)&& defined(Q_CC_GNU)
name|bool
name|ret
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|hasMetaData
condition|)
block|{
specifier|const
name|char
modifier|*
name|data
init|=
name|filedata
operator|+
name|pos
decl_stmt|;
name|QJsonDocument
name|doc
init|=
name|QLibraryPrivate
operator|::
name|fromRawMetaData
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|lib
operator|->
name|metaData
operator|=
name|doc
operator|.
name|object
argument_list|()
expr_stmt|;
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
name|qWarning
argument_list|(
literal|"Found metadata in lib %s, metadata=\n%s\n"
argument_list|,
name|library
operator|.
name|toLocal8Bit
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|doc
operator|.
name|toJson
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|!
name|doc
operator|.
name|isNull
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ret
operator|&&
name|lib
condition|)
name|lib
operator|->
name|errorString
operator|=
name|QLibrary
operator|::
name|tr
argument_list|(
literal|"Plugin verification data mismatch in '%1'"
argument_list|)
operator|.
name|arg
argument_list|(
name|library
argument_list|)
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|installCoverageTool
specifier|static
name|void
name|installCoverageTool
parameter_list|(
name|QLibraryPrivate
modifier|*
name|libPrivate
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__COVERAGESCANNER__
comment|/*       __COVERAGESCANNER__ is defined when Qt has been instrumented for code       coverage by TestCocoon. CoverageScanner is the name of the tool that       generates the code instrumentation.       This code is required here when code coverage analysis with TestCocoon       is enabled in order to allow the loading application to register the plugin       and then store its execution report. The execution report gathers information       about each part of the plugin's code that has been used when       the plugin was loaded by the launching application.       The execution report for the plugin will go to the same execution report       as the one defined for the application loading it.     */
name|int
name|ret
init|=
name|__coveragescanner_register_library
argument_list|(
name|libPrivate
operator|->
name|fileName
operator|.
name|toLocal8Bit
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
block|{
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|qDebug
argument_list|(
literal|"%s: coverage data for %s registered"
argument_list|,
name|Q_FUNC_INFO
argument_list|,
name|qPrintable
argument_list|(
name|libPrivate
operator|->
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"%s: could not register %s: error %d; coverage data may be incomplete"
argument_list|,
name|Q_FUNC_INFO
argument_list|,
name|qPrintable
argument_list|(
name|libPrivate
operator|->
name|fileName
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|libPrivate
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_class
DECL|class|QLibraryStore
class|class
name|QLibraryStore
block|{
public|public:
specifier|inline
name|~
name|QLibraryStore
parameter_list|()
destructor_decl|;
specifier|static
specifier|inline
name|QLibraryPrivate
modifier|*
name|findOrCreate
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
function_decl|;
specifier|static
specifier|inline
name|void
name|releaseLibrary
parameter_list|(
name|QLibraryPrivate
modifier|*
name|lib
parameter_list|)
function_decl|;
specifier|static
specifier|inline
name|void
name|cleanup
parameter_list|()
function_decl|;
private|private:
specifier|static
specifier|inline
name|QLibraryStore
modifier|*
name|instance
parameter_list|()
function_decl|;
comment|// all members and instance() are protected by qt_library_mutex
DECL|typedef|LibraryMap
typedef|typedef
name|QMap
argument_list|<
name|QString
argument_list|,
name|QLibraryPrivate
modifier|*
argument_list|>
name|LibraryMap
typedef|;
DECL|member|libraryMap
name|LibraryMap
name|libraryMap
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|variable|qt_library_mutex
specifier|static
name|QBasicMutex
name|qt_library_mutex
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|qt_library_data
specifier|static
name|QLibraryStore
modifier|*
name|qt_library_data
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_destructor
DECL|function|~QLibraryStore
name|QLibraryStore
operator|::
name|~
name|QLibraryStore
parameter_list|()
block|{
name|qt_library_data
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|cleanup
specifier|inline
name|void
name|QLibraryStore
operator|::
name|cleanup
parameter_list|()
block|{
name|QLibraryStore
modifier|*
name|data
init|=
name|qt_library_data
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return;
comment|// find any libraries that are still loaded but have a no one attached to them
name|LibraryMap
operator|::
name|Iterator
name|it
init|=
name|data
operator|->
name|libraryMap
operator|.
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|data
operator|->
name|libraryMap
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|QLibraryPrivate
modifier|*
name|lib
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|lib
operator|->
name|libraryRefCount
operator|.
name|load
argument_list|()
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|lib
operator|->
name|libraryUnloadCount
operator|.
name|load
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|lib
operator|->
name|pHnd
argument_list|)
expr_stmt|;
name|lib
operator|->
name|libraryUnloadCount
operator|.
name|store
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__GLIBC__
comment|// glibc has a bug in unloading from global destructors
comment|// see https://bugzilla.novell.com/show_bug.cgi?id=622977
comment|// and http://sourceware.org/bugzilla/show_bug.cgi?id=11941
name|lib
operator|->
name|unload
argument_list|(
name|QLibraryPrivate
operator|::
name|NoUnloadSys
argument_list|)
expr_stmt|;
else|#
directive|else
name|lib
operator|->
name|unload
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
operator|delete
name|lib
expr_stmt|;
name|it
operator|.
name|value
argument_list|()
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
block|{
comment|// dump all objects that remain
foreach|foreach
control|(
name|QLibraryPrivate
modifier|*
name|lib
decl|,
name|data
operator|->
name|libraryMap
control|)
block|{
if|if
condition|(
name|lib
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"On QtCore unload,"
operator|<<
name|lib
operator|->
name|fileName
operator|<<
literal|"was leaked, with"
operator|<<
name|lib
operator|->
name|libraryRefCount
operator|.
name|load
argument_list|()
operator|<<
literal|"users"
expr_stmt|;
block|}
block|}
operator|delete
name|data
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qlibraryCleanup
specifier|static
name|void
name|qlibraryCleanup
parameter_list|()
block|{
name|QLibraryStore
operator|::
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_function
begin_macro
name|Q_DESTRUCTOR_FUNCTION
argument_list|(
argument|qlibraryCleanup
argument_list|)
end_macro
begin_comment
comment|// must be called with a locked mutex
end_comment
begin_function
DECL|function|instance
name|QLibraryStore
modifier|*
name|QLibraryStore
operator|::
name|instance
parameter_list|()
block|{
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
operator|!
name|qt_library_data
argument_list|)
condition|)
name|qt_library_data
operator|=
operator|new
name|QLibraryStore
expr_stmt|;
return|return
name|qt_library_data
return|;
block|}
end_function
begin_function
DECL|function|findOrCreate
specifier|inline
name|QLibraryPrivate
modifier|*
name|QLibraryStore
operator|::
name|findOrCreate
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|qt_library_mutex
argument_list|)
decl_stmt|;
name|QLibraryStore
modifier|*
name|data
init|=
name|instance
argument_list|()
decl_stmt|;
comment|// check if this library is already loaded
name|QLibraryPrivate
modifier|*
name|lib
init|=
name|data
operator|->
name|libraryMap
operator|.
name|value
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lib
condition|)
name|lib
operator|=
operator|new
name|QLibraryPrivate
argument_list|(
name|fileName
argument_list|,
name|version
argument_list|)
expr_stmt|;
comment|// track this library
name|data
operator|->
name|libraryMap
operator|.
name|insert
argument_list|(
name|fileName
argument_list|,
name|lib
argument_list|)
expr_stmt|;
name|lib
operator|->
name|libraryRefCount
operator|.
name|ref
argument_list|()
expr_stmt|;
return|return
name|lib
return|;
block|}
end_function
begin_function
DECL|function|releaseLibrary
specifier|inline
name|void
name|QLibraryStore
operator|::
name|releaseLibrary
parameter_list|(
name|QLibraryPrivate
modifier|*
name|lib
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|qt_library_mutex
argument_list|)
decl_stmt|;
name|QLibraryStore
modifier|*
name|data
init|=
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
name|lib
operator|->
name|libraryRefCount
operator|.
name|deref
argument_list|()
condition|)
block|{
comment|// still in use
return|return;
block|}
comment|// no one else is using
name|Q_ASSERT
argument_list|(
name|lib
operator|->
name|libraryUnloadCount
operator|.
name|load
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|QLibraryPrivate
modifier|*
name|that
init|=
name|data
operator|->
name|libraryMap
operator|.
name|take
argument_list|(
name|lib
operator|->
name|fileName
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|lib
operator|==
name|that
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|that
argument_list|)
expr_stmt|;
operator|delete
name|lib
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QLibraryPrivate
name|QLibraryPrivate
operator|::
name|QLibraryPrivate
parameter_list|(
specifier|const
name|QString
modifier|&
name|canonicalFileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
member_init_list|:
name|pHnd
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|fileName
argument_list|(
name|canonicalFileName
argument_list|)
member_init_list|,
name|fullVersion
argument_list|(
name|version
argument_list|)
member_init_list|,
name|instance
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|loadHints
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|libraryRefCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|libraryUnloadCount
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pluginState
argument_list|(
name|MightBeAPlugin
argument_list|)
block|{ }
end_constructor
begin_function
DECL|function|findOrCreate
name|QLibraryPrivate
modifier|*
name|QLibraryPrivate
operator|::
name|findOrCreate
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
block|{
return|return
name|QLibraryStore
operator|::
name|findOrCreate
argument_list|(
name|fileName
argument_list|,
name|version
argument_list|)
return|;
block|}
end_function
begin_destructor
DECL|function|~QLibraryPrivate
name|QLibraryPrivate
operator|::
name|~
name|QLibraryPrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|resolve
name|QFunctionPointer
name|QLibraryPrivate
operator|::
name|resolve
parameter_list|(
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pHnd
condition|)
return|return
literal|0
return|;
return|return
name|resolve_sys
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|load
name|bool
name|QLibraryPrivate
operator|::
name|load
parameter_list|()
block|{
if|if
condition|(
name|pHnd
condition|)
block|{
name|libraryUnloadCount
operator|.
name|ref
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|bool
name|ret
init|=
name|load_sys
argument_list|()
decl_stmt|;
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"loaded library"
operator|<<
name|fileName
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|//when loading a library we add a reference to it so that the QLibraryPrivate won't get deleted
comment|//this allows to unload the library at a later time
name|libraryUnloadCount
operator|.
name|ref
argument_list|()
expr_stmt|;
name|libraryRefCount
operator|.
name|ref
argument_list|()
expr_stmt|;
name|installCoverageTool
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|unload
name|bool
name|QLibraryPrivate
operator|::
name|unload
parameter_list|(
name|UnloadFlag
name|flag
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pHnd
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|libraryUnloadCount
operator|.
name|load
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|libraryUnloadCount
operator|.
name|deref
argument_list|()
condition|)
block|{
comment|// only unload if ALL QLibrary instance wanted to
operator|delete
name|inst
operator|.
name|data
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|NoUnloadSys
operator|||
name|unload_sys
argument_list|()
condition|)
block|{
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QLibraryPrivate::unload succeeded on"
operator|<<
name|fileName
operator|<<
operator|(
name|flag
operator|==
name|NoUnloadSys
condition|?
literal|"(faked)"
else|:
literal|""
operator|)
expr_stmt|;
comment|//when the library is unloaded, we release the reference on it so that 'this'
comment|//can get deleted
name|libraryRefCount
operator|.
name|deref
argument_list|()
expr_stmt|;
name|pHnd
operator|=
literal|0
expr_stmt|;
name|instance
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|pHnd
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|release
name|void
name|QLibraryPrivate
operator|::
name|release
parameter_list|()
block|{
name|QLibraryStore
operator|::
name|releaseLibrary
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|loadPlugin
name|bool
name|QLibraryPrivate
operator|::
name|loadPlugin
parameter_list|()
block|{
if|if
condition|(
name|instance
condition|)
block|{
name|libraryUnloadCount
operator|.
name|ref
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|pluginState
operator|==
name|IsNotAPlugin
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|load
argument_list|()
condition|)
block|{
name|instance
operator|=
operator|(
name|QtPluginInstanceFunction
operator|)
name|resolve
argument_list|(
literal|"qt_plugin_instance"
argument_list|)
expr_stmt|;
return|return
name|instance
return|;
block|}
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QLibraryPrivate::loadPlugin failed on"
operator|<<
name|fileName
operator|<<
literal|":"
operator|<<
name|errorString
expr_stmt|;
name|pluginState
operator|=
name|IsNotAPlugin
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if \a fileName has a valid suffix for a loadable     library; otherwise returns false.      \table     \header \li Platform \li Valid suffixes     \row \li Windows     \li \c .dll, \c .DLL     \row \li Unix/Linux  \li \c .so     \row \li AIX  \li \c .a     \row \li HP-UX       \li \c .sl, \c .so (HP-UXi)     \row \li Mac OS X    \li \c .dylib, \c .bundle, \c .so     \endtable      Trailing versioning numbers on Unix are ignored.  */
end_comment
begin_function
DECL|function|isLibrary
name|bool
name|QLibrary
operator|::
name|isLibrary
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
return|return
name|fileName
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|".dll"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
return|;
else|#
directive|else
name|QString
name|completeSuffix
init|=
name|QFileInfo
argument_list|(
name|fileName
argument_list|)
operator|.
name|completeSuffix
argument_list|()
decl_stmt|;
if|if
condition|(
name|completeSuffix
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QStringList
name|suffixes
init|=
name|completeSuffix
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_DARWIN
argument_list|)
comment|// On Mac, libs look like libmylib.1.0.0.dylib
specifier|const
name|QString
name|lastSuffix
init|=
name|suffixes
operator|.
name|at
argument_list|(
name|suffixes
operator|.
name|count
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|firstSuffix
init|=
name|suffixes
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|bool
name|valid
init|=
operator|(
name|lastSuffix
operator|==
name|QLatin1String
argument_list|(
literal|"dylib"
argument_list|)
operator|||
name|firstSuffix
operator|==
name|QLatin1String
argument_list|(
literal|"so"
argument_list|)
operator|||
name|firstSuffix
operator|==
name|QLatin1String
argument_list|(
literal|"bundle"
argument_list|)
operator|)
decl_stmt|;
return|return
name|valid
return|;
else|#
directive|else
comment|// Generic Unix
name|QStringList
name|validSuffixList
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_HPUX
argument_list|)
comment|/*     See "HP-UX Linker and Libraries User's Guide", section "Link-time Differences between PA-RISC and IPF":     "In PA-RISC (PA-32 and PA-64) shared libraries are suffixed with .sl. In IPF (32-bit and 64-bit),     the shared libraries are suffixed with .so. For compatibility, the IPF linker also supports the .sl suffix."  */
name|validSuffixList
operator|<<
name|QLatin1String
argument_list|(
literal|"sl"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|__ia64
name|validSuffixList
operator|<<
name|QLatin1String
argument_list|(
literal|"so"
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_AIX
argument_list|)
name|validSuffixList
operator|<<
name|QLatin1String
argument_list|(
literal|"a"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"so"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|validSuffixList
operator|<<
name|QLatin1String
argument_list|(
literal|"so"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Examples of valid library names:
comment|//  libfoo.so
comment|//  libfoo.so.0
comment|//  libfoo.so.0.3
comment|//  libfoo-0.3.so
comment|//  libfoo-0.3.so.0.3.0
name|int
name|suffix
decl_stmt|;
name|int
name|suffixPos
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|suffix
operator|=
literal|0
init|;
name|suffix
operator|<
name|validSuffixList
operator|.
name|count
argument_list|()
operator|&&
name|suffixPos
operator|==
operator|-
literal|1
condition|;
operator|++
name|suffix
control|)
name|suffixPos
operator|=
name|suffixes
operator|.
name|indexOf
argument_list|(
name|validSuffixList
operator|.
name|at
argument_list|(
name|suffix
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|valid
init|=
name|suffixPos
operator|!=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|suffixPos
operator|+
literal|1
init|;
name|i
operator|<
name|suffixes
operator|.
name|count
argument_list|()
operator|&&
name|valid
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|!=
name|suffixPos
condition|)
name|suffixes
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toInt
argument_list|(
operator|&
name|valid
argument_list|)
expr_stmt|;
return|return
name|valid
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_typedef
DECL|typedef|QtPluginQueryVerificationDataFunction
typedef|typedef
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|QtPluginQueryVerificationDataFunction
function_decl|)
parameter_list|()
function_decl|;
end_typedef
begin_function
DECL|function|qt_get_metadata
specifier|static
name|bool
name|qt_get_metadata
parameter_list|(
name|QtPluginQueryVerificationDataFunction
name|pfn
parameter_list|,
name|QLibraryPrivate
modifier|*
name|priv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|szData
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pfn
condition|)
return|return
literal|false
return|;
name|szData
operator|=
name|pfn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|szData
condition|)
return|return
literal|false
return|;
name|QJsonDocument
name|doc
init|=
name|QLibraryPrivate
operator|::
name|fromRawMetaData
argument_list|(
name|szData
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
name|priv
operator|->
name|metaData
operator|=
name|doc
operator|.
name|object
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|isPlugin
name|bool
name|QLibraryPrivate
operator|::
name|isPlugin
parameter_list|()
block|{
if|if
condition|(
name|pluginState
operator|==
name|MightBeAPlugin
condition|)
name|updatePluginState
argument_list|()
expr_stmt|;
return|return
name|pluginState
operator|==
name|IsAPlugin
return|;
block|}
end_function
begin_function
DECL|function|updatePluginState
name|void
name|QLibraryPrivate
operator|::
name|updatePluginState
parameter_list|()
block|{
name|errorString
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|pluginState
operator|!=
name|MightBeAPlugin
condition|)
return|return;
name|bool
name|success
init|=
literal|false
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
if|if
condition|(
name|fileName
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|".debug"
argument_list|)
argument_list|)
condition|)
block|{
comment|// refuse to load a file that ends in .debug
comment|// these are the debug symbols from the libraries
comment|// the problem is that they are valid shared library files
comment|// and dlopen is known to crash while opening them
comment|// pretend we didn't see the file
name|errorString
operator|=
name|QLibrary
operator|::
name|tr
argument_list|(
literal|"The shared library was not found."
argument_list|)
expr_stmt|;
name|pluginState
operator|=
name|IsNotAPlugin
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|pHnd
condition|)
block|{
comment|// scan for the plugin metadata without loading
name|success
operator|=
name|findPatternUnloaded
argument_list|(
name|fileName
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// library is already loaded (probably via QLibrary)
comment|// simply get the target function and call it.
name|QtPluginQueryVerificationDataFunction
name|getMetaData
init|=
name|NULL
decl_stmt|;
name|getMetaData
operator|=
operator|(
name|QtPluginQueryVerificationDataFunction
operator|)
name|resolve
argument_list|(
literal|"qt_plugin_query_metadata"
argument_list|)
expr_stmt|;
name|success
operator|=
name|qt_get_metadata
argument_list|(
name|getMetaData
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|errorString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|fileName
operator|.
name|isEmpty
argument_list|()
condition|)
name|errorString
operator|=
name|QLibrary
operator|::
name|tr
argument_list|(
literal|"The shared library was not found."
argument_list|)
expr_stmt|;
else|else
name|errorString
operator|=
name|QLibrary
operator|::
name|tr
argument_list|(
literal|"The file '%1' is not a valid Qt plugin."
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
name|pluginState
operator|=
name|IsNotAPlugin
expr_stmt|;
return|return;
block|}
name|pluginState
operator|=
name|IsNotAPlugin
expr_stmt|;
comment|// be pessimistic
name|uint
name|qt_version
init|=
operator|(
name|uint
operator|)
name|metaData
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"version"
argument_list|)
argument_list|)
operator|.
name|toDouble
argument_list|()
decl_stmt|;
name|bool
name|debug
init|=
name|metaData
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"debug"
argument_list|)
argument_list|)
operator|.
name|toBool
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|qt_version
operator|&
literal|0x00ff00
operator|)
operator|>
operator|(
name|QT_VERSION
operator|&
literal|0x00ff00
operator|)
operator|||
operator|(
name|qt_version
operator|&
literal|0xff0000
operator|)
operator|!=
operator|(
name|QT_VERSION
operator|&
literal|0xff0000
operator|)
condition|)
block|{
if|if
condition|(
name|qt_debug_component
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"In %s:\n"
literal|"  Plugin uses incompatible Qt library (%d.%d.%d) [%s]"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|QFile
operator|::
name|encodeName
argument_list|(
name|fileName
argument_list|)
argument_list|,
operator|(
name|qt_version
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
argument_list|,
operator|(
name|qt_version
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|,
name|qt_version
operator|&
literal|0xff
argument_list|,
name|debug
condition|?
literal|"debug"
else|:
literal|"release"
argument_list|)
expr_stmt|;
block|}
name|errorString
operator|=
name|QLibrary
operator|::
name|tr
argument_list|(
literal|"The plugin '%1' uses incompatible Qt library. (%2.%3.%4) [%5]"
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
operator|.
name|arg
argument_list|(
operator|(
name|qt_version
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
argument_list|)
operator|.
name|arg
argument_list|(
operator|(
name|qt_version
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
operator|.
name|arg
argument_list|(
name|qt_version
operator|&
literal|0xff
argument_list|)
operator|.
name|arg
argument_list|(
name|debug
condition|?
name|QLatin1String
argument_list|(
literal|"debug"
argument_list|)
else|:
name|QLatin1String
argument_list|(
literal|"release"
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_PLUGIN_CHECK
block|}
elseif|else
if|if
condition|(
name|debug
operator|!=
name|QLIBRARY_AS_DEBUG
condition|)
block|{
comment|//don't issue a qWarning since we will hopefully find a non-debug? --Sam
name|errorString
operator|=
name|QLibrary
operator|::
name|tr
argument_list|(
literal|"The plugin '%1' uses incompatible Qt library."
literal|" (Cannot mix debug and release libraries.)"
argument_list|)
operator|.
name|arg
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|pluginState
operator|=
name|IsAPlugin
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Loads the library and returns true if the library was loaded     successfully; otherwise returns false. Since resolve() always     calls this function before resolving any symbols it is not     necessary to call it explicitly. In some situations you might want     the library loaded in advance, in which case you would use this     function.      \sa unload() */
end_comment
begin_function
DECL|function|load
name|bool
name|QLibrary
operator|::
name|load
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|did_load
condition|)
return|return
name|d
operator|->
name|pHnd
return|;
name|did_load
operator|=
literal|true
expr_stmt|;
return|return
name|d
operator|->
name|load
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Unloads the library and returns true if the library could be     unloaded; otherwise returns false.      This happens automatically on application termination, so you     shouldn't normally need to call this function.      If other instances of QLibrary are using the same library, the     call will fail, and unloading will only happen when every instance     has called unload().      Note that on Mac OS X 10.3 (Panther), dynamic libraries cannot be unloaded.      \sa resolve(), load() */
end_comment
begin_function
DECL|function|unload
name|bool
name|QLibrary
operator|::
name|unload
parameter_list|()
block|{
if|if
condition|(
name|did_load
condition|)
block|{
name|did_load
operator|=
literal|false
expr_stmt|;
return|return
name|d
operator|->
name|unload
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the library is loaded; otherwise returns false.      \sa load()  */
end_comment
begin_function
DECL|function|isLoaded
name|bool
name|QLibrary
operator|::
name|isLoaded
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|&&
name|d
operator|->
name|pHnd
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a library with the given \a parent.  */
end_comment
begin_constructor
DECL|function|QLibrary
name|QLibrary
operator|::
name|QLibrary
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|d
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|did_load
argument_list|(
literal|false
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a library object with the given \a parent that will     load the library specified by \a fileName.      We recommend omitting the file's suffix in \a fileName, since     QLibrary will automatically look for the file with the appropriate     suffix in accordance with the platform, e.g. ".so" on Unix,     ".dylib" on Mac OS X, and ".dll" on Windows. (See \l{fileName}.)  */
end_comment
begin_constructor
DECL|function|QLibrary
name|QLibrary
operator|::
name|QLibrary
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|d
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|did_load
argument_list|(
literal|false
argument_list|)
block|{
name|setFileName
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a library object with the given \a parent that will     load the library specified by \a fileName and major version number \a verNum.     Currently, the version number is ignored on Windows.      We recommend omitting the file's suffix in \a fileName, since     QLibrary will automatically look for the file with the appropriate     suffix in accordance with the platform, e.g. ".so" on Unix,     ".dylib" on Mac OS X, and ".dll" on Windows. (See \l{fileName}.) */
end_comment
begin_constructor
DECL|function|QLibrary
name|QLibrary
operator|::
name|QLibrary
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|int
name|verNum
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|d
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|did_load
argument_list|(
literal|false
argument_list|)
block|{
name|setFileNameAndVersion
argument_list|(
name|fileName
argument_list|,
name|verNum
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a library object with the given \a parent that will     load the library specified by \a fileName and full version number \a version.     Currently, the version number is ignored on Windows.      We recommend omitting the file's suffix in \a fileName, since     QLibrary will automatically look for the file with the appropriate     suffix in accordance with the platform, e.g. ".so" on Unix,     ".dylib" on Mac OS X, and ".dll" on Windows. (See \l{fileName}.)  */
end_comment
begin_constructor
DECL|function|QLibrary
name|QLibrary
operator|::
name|QLibrary
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|d
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|did_load
argument_list|(
literal|false
argument_list|)
block|{
name|setFileNameAndVersion
argument_list|(
name|fileName
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QLibrary object.      Unless unload() was called explicitly, the library stays in memory     until the application terminates.      \sa isLoaded(), unload() */
end_comment
begin_destructor
DECL|function|~QLibrary
name|QLibrary
operator|::
name|~
name|QLibrary
parameter_list|()
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|release
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \property QLibrary::fileName     \brief the file name of the library      We recommend omitting the file's suffix in the file name, since     QLibrary will automatically look for the file with the appropriate     suffix (see isLibrary()).      When loading the library, QLibrary searches in all system-specific     library locations (e.g. \c LD_LIBRARY_PATH on Unix), unless the     file name has an absolute path. After loading the library     successfully, fileName() returns the fully-qualified file name of     the library, including the full path to the library if one was given     in the constructor or passed to setFileName().      For example, after successfully loading the "GL" library on Unix     platforms, fileName() will return "libGL.so". If the file name was     originally passed as "/usr/lib/libGL", fileName() will return     "/usr/lib/libGL.so". */
end_comment
begin_function
DECL|function|setFileName
name|void
name|QLibrary
operator|::
name|setFileName
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|)
block|{
name|QLibrary
operator|::
name|LoadHints
name|lh
decl_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|lh
operator|=
name|d
operator|->
name|loadHints
expr_stmt|;
name|d
operator|->
name|release
argument_list|()
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
name|did_load
operator|=
literal|false
expr_stmt|;
block|}
name|d
operator|=
name|QLibraryPrivate
operator|::
name|findOrCreate
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|d
operator|->
name|loadHints
operator|=
name|lh
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fileName
name|QString
name|QLibrary
operator|::
name|fileName
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
condition|)
return|return
name|d
operator|->
name|qualifiedFileName
operator|.
name|isEmpty
argument_list|()
condition|?
name|d
operator|->
name|fileName
else|:
name|d
operator|->
name|qualifiedFileName
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QLibrary::setFileNameAndVersion(const QString&fileName, int versionNumber)      Sets the fileName property and major version number to \a fileName     and \a versionNumber respectively.     The \a versionNumber is ignored on Windows.      \sa setFileName() */
end_comment
begin_function
DECL|function|setFileNameAndVersion
name|void
name|QLibrary
operator|::
name|setFileNameAndVersion
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|int
name|verNum
parameter_list|)
block|{
name|QLibrary
operator|::
name|LoadHints
name|lh
decl_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|lh
operator|=
name|d
operator|->
name|loadHints
expr_stmt|;
name|d
operator|->
name|release
argument_list|()
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
name|did_load
operator|=
literal|false
expr_stmt|;
block|}
name|d
operator|=
name|QLibraryPrivate
operator|::
name|findOrCreate
argument_list|(
name|fileName
argument_list|,
name|verNum
operator|>=
literal|0
condition|?
name|QString
operator|::
name|number
argument_list|(
name|verNum
argument_list|)
else|:
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|loadHints
operator|=
name|lh
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the fileName property and full version number to \a fileName     and \a version respectively.     The \a version parameter is ignored on Windows.      \sa setFileName() */
end_comment
begin_function
DECL|function|setFileNameAndVersion
name|void
name|QLibrary
operator|::
name|setFileNameAndVersion
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|)
block|{
name|QLibrary
operator|::
name|LoadHints
name|lh
decl_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|lh
operator|=
name|d
operator|->
name|loadHints
expr_stmt|;
name|d
operator|->
name|release
argument_list|()
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
name|did_load
operator|=
literal|false
expr_stmt|;
block|}
name|d
operator|=
name|QLibraryPrivate
operator|::
name|findOrCreate
argument_list|(
name|fileName
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|d
operator|->
name|loadHints
operator|=
name|lh
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the address of the exported symbol \a symbol. The library is     loaded if necessary. The function returns 0 if the symbol could     not be resolved or if the library could not be loaded.      Example:     \snippet code/src_corelib_plugin_qlibrary.cpp 2      The symbol must be exported as a C function from the library. This     means that the function must be wrapped in an \c{extern "C"} if     the library is compiled with a C++ compiler. On Windows you must     also explicitly export the function from the DLL using the     \c{__declspec(dllexport)} compiler directive, for example:      \snippet code/src_corelib_plugin_qlibrary.cpp 3      with \c MY_EXPORT defined as      \snippet code/src_corelib_plugin_qlibrary.cpp 4 */
end_comment
begin_function
DECL|function|resolve
name|QFunctionPointer
name|QLibrary
operator|::
name|resolve
parameter_list|(
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isLoaded
argument_list|()
operator|&&
operator|!
name|load
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|resolve
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Loads the library \a fileName and returns the address of the     exported symbol \a symbol. Note that \a fileName should not     include the platform-specific file suffix; (see \l{fileName}). The     library remains loaded until the application exits.      The function returns 0 if the symbol could not be resolved or if     the library could not be loaded.      \sa resolve() */
end_comment
begin_function
DECL|function|resolve
name|QFunctionPointer
name|QLibrary
operator|::
name|resolve
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
name|QLibrary
name|library
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
return|return
name|library
operator|.
name|resolve
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Loads the library \a fileName with major version number \a verNum and     returns the address of the exported symbol \a symbol.     Note that \a fileName should not include the platform-specific file suffix;     (see \l{fileName}). The library remains loaded until the application exits.     \a verNum is ignored on Windows.      The function returns 0 if the symbol could not be resolved or if     the library could not be loaded.      \sa resolve() */
end_comment
begin_function
DECL|function|resolve
name|QFunctionPointer
name|QLibrary
operator|::
name|resolve
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|int
name|verNum
parameter_list|,
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
name|QLibrary
name|library
argument_list|(
name|fileName
argument_list|,
name|verNum
argument_list|)
decl_stmt|;
return|return
name|library
operator|.
name|resolve
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.4      Loads the library \a fileName with full version number \a version and     returns the address of the exported symbol \a symbol.     Note that \a fileName should not include the platform-specific file suffix;     (see \l{fileName}). The library remains loaded until the application exits.     \a version is ignored on Windows.      The function returns 0 if the symbol could not be resolved or if     the library could not be loaded.      \sa resolve() */
end_comment
begin_function
DECL|function|resolve
name|QFunctionPointer
name|QLibrary
operator|::
name|resolve
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
specifier|const
name|QString
modifier|&
name|version
parameter_list|,
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
name|QLibrary
name|library
argument_list|(
name|fileName
argument_list|,
name|version
argument_list|)
decl_stmt|;
return|return
name|library
operator|.
name|resolve
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.2      Returns a text string with the description of the last error that occurred.     Currently, errorString will only be set if load(), unload() or resolve() for some reason fails. */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QLibrary
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
return|return
operator|(
operator|!
name|d
operator|||
name|d
operator|->
name|errorString
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
name|tr
argument_list|(
literal|"Unknown error"
argument_list|)
else|:
name|d
operator|->
name|errorString
return|;
block|}
end_function
begin_comment
comment|/*!     \property QLibrary::loadHints     \brief Give the load() function some hints on how it should behave.      You can give some hints on how the symbols are resolved. Usually,     the symbols are not resolved at load time, but resolved lazily,     (that is, when resolve() is called). If you set the loadHint to     ResolveAllSymbolsHint, then all symbols will be resolved at load time     if the platform supports it.      Setting ExportExternalSymbolsHint will make the external symbols in the     library available for resolution in subsequent loaded libraries.      If LoadArchiveMemberHint is set, the file name     is composed of two components: A path which is a reference to an     archive file followed by the second component which is the reference to     the archive member. For instance, the fileName \c libGL.a(shr_64.o) will refer     to the library \c shr_64.o in the archive file named \c libGL.a. This     is only supported on the AIX platform.      Setting PreventUnloadHint will only apply on Unix platforms.      The interpretation of the load hints is platform dependent, and if     you use it you are probably making some assumptions on which platform     you are compiling for, so use them only if you understand the consequences     of them.      By default, none of these flags are set, so libraries will be loaded with     lazy symbol resolution, and will not export external symbols for resolution     in other dynamically-loaded libraries. */
end_comment
begin_function
DECL|function|setLoadHints
name|void
name|QLibrary
operator|::
name|setLoadHints
parameter_list|(
name|LoadHints
name|hints
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|d
operator|=
name|QLibraryPrivate
operator|::
name|findOrCreate
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
comment|// ugly, but we need a d-ptr
name|d
operator|->
name|errorString
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|loadHints
operator|=
name|hints
expr_stmt|;
block|}
end_function
begin_function
DECL|function|loadHints
name|QLibrary
operator|::
name|LoadHints
name|QLibrary
operator|::
name|loadHints
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|loadHints
else|:
operator|(
name|QLibrary
operator|::
name|LoadHints
operator|)
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Internal, for debugging */
end_comment
begin_function
DECL|function|qt_debug_component
name|bool
name|qt_debug_component
parameter_list|()
block|{
specifier|static
name|int
name|debug_env
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|debug_env
operator|==
operator|-
literal|1
condition|)
name|debug_env
operator|=
name|QT_PREPEND_NAMESPACE
argument_list|(
name|qgetenv
argument_list|)
argument_list|(
literal|"QT_DEBUG_PLUGINS"
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
return|return
name|debug_env
operator|!=
literal|0
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_LIBRARY
end_comment
end_unit
