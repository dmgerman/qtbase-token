begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"complexwidgets.h"
end_include
begin_include
include|#
directive|include
file|<qaccessible.h>
end_include
begin_include
include|#
directive|include
file|<qapplication.h>
end_include
begin_include
include|#
directive|include
file|<qabstractbutton.h>
end_include
begin_include
include|#
directive|include
file|<qevent.h>
end_include
begin_include
include|#
directive|include
file|<qheaderview.h>
end_include
begin_include
include|#
directive|include
file|<qtabbar.h>
end_include
begin_include
include|#
directive|include
file|<qcombobox.h>
end_include
begin_include
include|#
directive|include
file|<qlistview.h>
end_include
begin_include
include|#
directive|include
file|<qtableview.h>
end_include
begin_include
include|#
directive|include
file|<qlineedit.h>
end_include
begin_include
include|#
directive|include
file|<qstyle.h>
end_include
begin_include
include|#
directive|include
file|<qstyleoption.h>
end_include
begin_include
include|#
directive|include
file|<qtooltip.h>
end_include
begin_include
include|#
directive|include
file|<qwhatsthis.h>
end_include
begin_include
include|#
directive|include
file|<qtreeview.h>
end_include
begin_include
include|#
directive|include
file|<private/qtabbar_p.h>
end_include
begin_include
include|#
directive|include
file|<QAbstractScrollArea>
end_include
begin_include
include|#
directive|include
file|<QScrollArea>
end_include
begin_include
include|#
directive|include
file|<QScrollBar>
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ACCESSIBILITY
end_ifndef
begin_function_decl
name|QT_BEGIN_NAMESPACE
name|QString
name|Q_GUI_EXPORT
name|qt_accStripAmp
parameter_list|(
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
literal|0
end_if
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_ITEMVIEWS
end_ifndef
begin_comment
comment|/* The MSDN article "Exposing Data Tables through Microsoft Active Accessibility" explains how data tables should be exposed. Url: http://msdn2.microsoft.com/en-us/library/ms971325.aspx Basically, the model is like this:  ROLE_SYSTEM_TABLE   |- ROLE_SYSTEM_ROW   |  |- ROLE_SYSTEM_ROWHEADER   |  |- ROLE_SYSTEM_COLUMNHEADER   |  |- ROLE_SYSTEM_COLUMNHEADER   |  |- ROLE_SYSTEM_COLUMNHEADER   |     '- ..   |- ROLE_SYSTEM_ROW   |  |- ROLE_SYSTEM_ROWHEADER   |  |- ROLE_SYSTEM_CELL   |  |- ROLE_SYSTEM_CELL   |  |- ROLE_SYSTEM_CELL   |   '- ..   |- ROLE_SYSTEM_ROW   |  |- ROLE_SYSTEM_ROWHEADER   |  |- ROLE_SYSTEM_CELL   |  |- ROLE_SYSTEM_CELL   |  |- ROLE_SYSTEM_CELL   |   '- ..    '- ..  The headers of QTreeView is also represented like this. */
end_comment
begin_ifndef
unit|QAccessibleItemRow::QAccessibleItemRow(QAbstractItemView *aView, const QModelIndex&index, bool isHeader)     : row(index), view(aView), m_header(isHeader) { }  QHeaderView *QAccessibleItemRow::horizontalHeader() const {     QHeaderView *header = 0;     if (m_header) {         if (false) {
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_endif
unit|} else if (const QTableView *tv = qobject_cast<const QTableView*>(view)) {             header = tv->horizontalHeader();
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TREEVIEW
end_ifndef
begin_endif
unit|} else if (const QTreeView *tv = qobject_cast<const QTreeView*>(view)) {             header = tv->header();
endif|#
directive|endif
end_endif
begin_ifndef
unit|}     }     return header; }  QHeaderView *QAccessibleItemRow::verticalHeader() const {     QHeaderView *header = 0;
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_endif
unit|if (const QTableView *tv = qobject_cast<const QTableView*>(view))         header = tv->verticalHeader();
endif|#
directive|endif
end_endif
begin_comment
unit|return header; }  int QAccessibleItemRow::logicalFromChild(QHeaderView *header, int child) const {     int logical = -1;     if (header->sectionsHidden()) {         int kid = 0;         for (int i = 0; i< header->count(); ++i) {             if (!header->isSectionHidden(i))                 ++kid;             if (kid == child) {                 logical = i;                 break;             }         }     } else {         logical = child - 1;     }     return logical; }  QRect QAccessibleItemRow::rect(int child) const {     QRect r;     if (view&& view->isVisible()) {         if (QHeaderView *header = horizontalHeader()) {             if (!child) {                 r = header->rect();             } else {                 if (QHeaderView *vheader = verticalHeader()) {                     if (child == 1) {                         int w = vheader->width();                         int h = header->height();                         r.setRect(0, 0, w, h);                     }                     --child;                 }                 if (child) {                     int logical = logicalFromChild(header, child);                     int w = header->sectionSize(logical);                     r.setRect(header->sectionViewportPosition(logical), 0, w, header->height());                     r.translate(header->mapTo(view, QPoint(0, 0)));                 }             }         } else if (row.isValid()) {             if (!child) {                 QModelIndex parent = row.parent();                 const int colCount = row.model()->columnCount(parent);                 for (int i = 0; i< colCount; ++i)                     r |= view->visualRect(row.model()->index(row.row(), i, parent));                 r.translate(view->viewport()->mapTo(view, QPoint(0,0)));                  if (const QHeaderView *vheader = verticalHeader()) {
comment|// include the section of the vertical header
end_comment
begin_comment
unit|QRect re;                     int logicalRow = row.row();                     int h = vheader->sectionSize(logicalRow);                     re.setRect(0, vheader->sectionViewportPosition(logicalRow), vheader->width(), h);                     re.translate(vheader->mapTo(view, QPoint(0, 0)));                     r |= re;                 }             } else {                 if (QHeaderView *vheader = verticalHeader()) {                     if (child == 1) {                         int logicalRow = row.row();                         int h = vheader->sectionSize(logicalRow);                         r.setRect(0, vheader->sectionViewportPosition(logicalRow), vheader->width(), h);                         r.translate(vheader->mapTo(view, QPoint(0, 0)));                     }                     --child;                 }                 if (child) {                     r = view->visualRect(childIndex(child));                     r.translate(view->viewport()->mapTo(view, QPoint(0,0)));                 }             }         }     }     if (!r.isNull())         r.translate(view->mapToGlobal(QPoint(0, 0)));      return r; }  int QAccessibleItemRow::treeLevel() const {     int level = 0;     QModelIndex idx = row;     while (idx.isValid()) {         idx = idx.parent();         ++level;     }     return level; }  QString QAccessibleItemRow::text_helper(int child) const {     QString value;     if (m_header) {         if (!child)             return QString();         if (verticalHeader()) {             if (child == 1)                 return QString();             --child;         }         QHeaderView *header = horizontalHeader();         int logical = logicalFromChild(header, child);         value = view->model()->headerData(logical, Qt::Horizontal, Qt::AccessibleTextRole).toString();         if (value.isEmpty())             value = view->model()->headerData(logical, Qt::Horizontal).toString();         return value;     } else {         if (!child) {
comment|// for one-column views (i.e. QListView)
end_comment
begin_ifndef
unit|if (children().count()>= 1)                 child = 1;             else                 return QString();         }         if (verticalHeader()) {             if (child == 1) {                 int logical = row.row();                 value = view->model()->headerData(logical, Qt::Vertical, Qt::AccessibleTextRole).toString();                 if (value.isEmpty())                     value = view->model()->headerData(logical, Qt::Vertical).toString();                 return value;             } else {                 --child;             }         }     }     if (value.isEmpty()) {         QModelIndex idx = childIndex(child);         if (idx.isValid()) {             value = idx.model()->data(idx, Qt::AccessibleTextRole).toString();             if (value.isEmpty())                 value = idx.model()->data(idx, Qt::DisplayRole).toString();         }     }     return value; }  QString QAccessibleItemRow::text(QAccessible::Text t, int child) const {     QString value;     if (t == Name) {         value = text_helper(child);     } else if (t == Value) {
ifndef|#
directive|ifndef
name|QT_NO_TREEVIEW
end_ifndef
begin_endif
unit|if (qobject_cast<const QTreeView*>(view)) {             if (child == 0)                 value = QString::number(treeLevel());         } else
endif|#
directive|endif
end_endif
begin_ifndef
unit|{             value = text_helper(child);         }     } else if (t == Description) {
ifndef|#
directive|ifndef
name|QT_NO_TREEVIEW
end_ifndef
begin_comment
unit|if (child == 0&& qobject_cast<const QTreeView*>(view)) {
comment|// We store the tree coordinates of the current item in the description.
end_comment
begin_comment
comment|// This enables some screen readers to report where the focus is
end_comment
begin_comment
comment|// in a tree view. (works in JAWS). Also, Firefox does the same thing.
end_comment
begin_comment
comment|// For instance the description "L2, 4 of 25 with 24" means
end_comment
begin_comment
comment|// "L2": Tree Level 2
end_comment
begin_comment
comment|// "4 of 25": We are item 4 out of in total 25 other siblings
end_comment
begin_comment
comment|// "with 24": We have 24 children. (JAWS does not read this number)
end_comment
begin_comment
comment|// level
end_comment
begin_comment
unit|int level = treeLevel();              QAbstractItemModel *m = view->model();
comment|// totalSiblings and itemIndex
end_comment
begin_comment
unit|QModelIndex parent = row.parent();             int rowCount = m->rowCount(parent);             int itemIndex = -1;             int totalSiblings = 0;             for (int i = 0 ; i< rowCount; ++i) {                 QModelIndex sibling = row.sibling(i, 0);                 if (!view->isIndexHidden(sibling))                     ++totalSiblings;                 if (row == sibling)                     itemIndex = totalSiblings;             }             int totalChildren = m->rowCount(row);
comment|// JAWS does not report child count, so we do
end_comment
begin_comment
comment|// this simple and efficient.
end_comment
begin_comment
comment|// (don't check if they are all visible).
end_comment
begin_endif
unit|value = QString::fromAscii("L%1, %2 of %3 with %4").arg(level).arg(itemIndex).arg(totalSiblings).arg(totalChildren);         } else
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TREEVIEW
end_comment
begin_comment
unit|{             if (!m_header) {                 if (child == 0&& children().count()>= 1)                     child = 1;                 if (verticalHeader()) {                     if (child == 1) {                         value = view->model()->headerData(row.row(), Qt::Vertical).toString();                     }                     --child;                 }                 if (child) {                     QModelIndex idx = childIndex(child);                     value = idx.model()->data(idx, Qt::AccessibleDescriptionRole).toString();                 }              }         }     }     return value; }  void QAccessibleItemRow::setText(QAccessible::Text t, int child, const QString&text) {     if (m_header) {         if (child)             view->model()->setHeaderData(child - 1, Qt::Horizontal, text);
comment|// child == 0 means the cell to the left of the horizontal header, which is empty!?
end_comment
begin_ifndef
unit|} else {         if (!child) {             if (children().count() == 1)                 child = 1;             else                 return;         }          if (verticalHeader()) {             if (child == 1) {                 view->model()->setHeaderData(row.row(), Qt::Vertical, text);                 return;             }             --child;         }         QModelIndex idx = childIndex(child);         if (!idx.isValid())             return;          switch (t) {         case Description:             const_cast<QAbstractItemModel *>(idx.model())->setData(idx, text,                                              Qt::AccessibleDescriptionRole);             break;         case Value:             const_cast<QAbstractItemModel *>(idx.model())->setData(idx, text, Qt::EditRole);             break;         default:             break;         }     } }  QModelIndex QAccessibleItemRow::childIndex(int child) const {     QList<QModelIndex> kids = children();     Q_ASSERT(child>= 1&& child<= kids.count());     return kids.at(child - 1); }  QList<QModelIndex> QAccessibleItemRow::children() const {     QList<QModelIndex> kids;     for (int i = 0; i< row.model()->columnCount(row.parent()); ++i) {         QModelIndex idx = row.model()->index(row.row(), i, row.parent());         if (!view->isIndexHidden(idx)) {             kids<< idx;         }     }     return kids; }  bool QAccessibleItemRow::isValid() const {     return m_header ? true : row.isValid(); }  QObject *QAccessibleItemRow::object() const {     return 0; }  int QAccessibleItemRow::childCount() const {     int count = 0;     if (QHeaderView *header = horizontalHeader()) {         count = header->count() - header->hiddenSectionCount();     } else {         count = children().count();     }
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_endif
unit|if (qobject_cast<const QTableView*>(view)) {         if (verticalHeader())             ++count;     }
endif|#
directive|endif
end_endif
begin_comment
unit|return count; }  int QAccessibleItemRow::indexOfChild(const QAccessibleInterface *iface) const {     if (!iface || iface->role() != Row)         return -1;
comment|//### meaningless code?
end_comment
begin_comment
unit|QList<QModelIndex> kids = children();     QModelIndex idx = static_cast<const QAccessibleItemRow *>(iface)->row;     if (!idx.isValid())         return -1;     return kids.indexOf(idx) + 1; }  QAccessible::Relation QAccessibleItemRow::relationTo(int child, const QAccessibleInterface *other,         int otherChild) const {     if (!child&& !otherChild&& other->object() == view)         return Child;     if (!child&& !otherChild&& other == this)         return Self;     if (!child&& otherChild&& other == this)         return Ancestor;     if (child&& otherChild&& other == this)         return Sibling;     return Unrelated; }  int QAccessibleItemRow::childAt(int x, int y) const {     if (!view || !view->isVisible())         return -1;      for (int i = childCount(); i>= 0; --i) {         if (rect(i).contains(x, y))             return i;     }     return -1; }  QAbstractItemView::CursorAction QAccessibleItemRow::toCursorAction(                                            QAccessible::Relation rel) {     switch (rel) {     case QAccessible::Up:         return QAbstractItemView::MoveUp;     case QAccessible::Down:         return QAbstractItemView::MoveDown;     case QAccessible::Left:         return QAbstractItemView::MoveLeft;     case QAccessible::Right:         return QAbstractItemView::MoveRight;     default:         Q_ASSERT(false);     }
comment|// should never be reached.
end_comment
begin_comment
unit|return QAbstractItemView::MoveRight; }  QAccessibleInterface *QAccessibleItemRow::parent() const {     return new QAccessibleItemView(view->viewport()); }  QAccessibleInterface *QAccessibleItemRow::child(int) const {
comment|// FIXME? port to IA2 table2.
end_comment
begin_comment
unit|return 0; }  int QAccessibleItemRow::navigate(RelationFlag relation, int index,                                  QAccessibleInterface **iface) const {     *iface = 0;     if (!view)         return -1;      switch (relation) {     case Ancestor:         *iface = parent();         return *iface ? 0 : -1;     case Child: {         if (!index)             return -1;         if (index< 1&& index> childCount())             return -1;          return index;}     case Sibling:         if (index) {             QAccessibleInterface *ifaceParent = parent();             if (ifaceParent) {                 *iface = ifaceParent->child(index - 1);                 delete ifaceParent;                 return *iface ? 0 : -1;             }         }         return -1;     case Up:     case Down:     case Left:     case Right: {
comment|// This is in the "not so nice" category. In order to find out which item
end_comment
begin_comment
comment|// is geometrically around, we have to set the current index, navigate
end_comment
begin_comment
comment|// and restore the index as well as the old selection
end_comment
begin_ifndef
unit|view->setUpdatesEnabled(false);         const QModelIndex oldIdx = view->currentIndex();         QList<QModelIndex> kids = children();         const QModelIndex currentIndex = index ? kids.at(index - 1) : QModelIndex(row);         const QItemSelection oldSelection = view->selectionModel()->selection();         view->setCurrentIndex(currentIndex);         const QModelIndex idx = view->moveCursor(toCursorAction(relation), Qt::NoModifier);         view->setCurrentIndex(oldIdx);         view->selectionModel()->select(oldSelection, QItemSelectionModel::ClearAndSelect);         view->setUpdatesEnabled(true);         if (!idx.isValid())             return -1;          if (idx.parent() != row.parent() || idx.row() != row.row())             *iface = new QAccessibleItemRow(view, idx);         return index ? kids.indexOf(idx) + 1 : 0; }     default:         break;     }      return -1; }  QAccessible::Role QAccessibleItemRow::role(int child) const {     if (false) {
ifndef|#
directive|ifndef
name|QT_NO_TREEVIEW
end_ifndef
begin_endif
unit|} else if (qobject_cast<const QTreeView*>(view)) {         if (horizontalHeader()) {             if (!child)                 return Row;             return ColumnHeader;         }         return TreeItem;
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LISTVIEW
end_ifndef
begin_endif
unit|} else if (qobject_cast<const QListView*>(view)) {         return ListItem;
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_endif
unit|} else if (qobject_cast<const QTableView *>(view)) {         if (!child)             return Row;         if (child == 1) {             if (verticalHeader())                 return RowHeader;         }         if (m_header)             return ColumnHeader;
endif|#
directive|endif
end_endif
begin_comment
unit|}     return Cell; }  QAccessible::State QAccessibleItemRow::state(int child) const {     State st = Normal;      if (!view)         return st;      QAccessibleInterface *parentIface = parent();     QRect globalRect;     if (parentIface) {         globalRect = parentIface->rect(0);         delete parentIface;     }     if (!globalRect.intersects(rect(child)))         st |= Invisible;      if (!horizontalHeader()) {         if (!(st& Invisible)) {             if (child) {                 if (QHeaderView *vheader = verticalHeader() ) {                     if (child == 1) {                         if (!vheader->isVisible())                             st |= Invisible;                     }                     --child;                 }                 if (child) {                     QModelIndex idx = childIndex(child);                     if (!idx.isValid())                         return st;                      if (view->selectionModel()->isSelected(idx))                         st |= Selected;                     if (view->selectionModel()->currentIndex() == idx)                         st |= Focused;                     if (idx.model()->data(idx, Qt::CheckStateRole).toInt() == Qt::Checked)                         st |= Checked;                      Qt::ItemFlags flags = idx.flags();                     if (flags& Qt::ItemIsSelectable) {                         st |= Selectable;                         if (view->selectionMode() == QAbstractItemView::MultiSelection)                             st |= MultiSelectable;                         if (view->selectionMode() == QAbstractItemView::ExtendedSelection)                             st |= ExtSelectable;                     }                 }             } else {                 Qt::ItemFlags flags = row.flags();                 if (flags& Qt::ItemIsSelectable) {                     st |= Selectable;                     st |= Focusable;                 }                 if (view->selectionModel()->isRowSelected(row.row(), row.parent()))                     st |= Selected;                 if (view->selectionModel()->currentIndex().row() == row.row())                     st |= Focused;             }         }     }      return st; }  int QAccessibleItemRow::userActionCount(int) const {     return 0; }  QString QAccessibleItemRow::actionText(int, Text, int) const {     return QString(); }  static QItemSelection rowAt(const QModelIndex&idx) {     return QItemSelection(idx.sibling(idx.row(), 0),                 idx.sibling(idx.row(), idx.model()->columnCount(idx.parent()))); }  bool QAccessibleItemRow::doAction(int action, int child, const QVariantList&
comment|/*params*/
end_comment
begin_ifndef
unit|) {     if (!view)         return false;      if (verticalHeader())         --child;      QModelIndex idx = child ? childIndex(child) : QModelIndex(row);     if (!idx.isValid())         return false;      QItemSelectionModel::SelectionFlags command = QItemSelectionModel::NoUpdate;      switch  (action) {     case SetFocus:         view->setCurrentIndex(idx);         return true;     case ExtendSelection:         if (!child)             return false;         view->selectionModel()->select(QItemSelection(view->currentIndex(), idx),                     QItemSelectionModel::SelectCurrent);         return true;     case Select:         command = QItemSelectionModel::ClearAndSelect;         break;     case ClearSelection:         command = QItemSelectionModel::Clear;         break;     case RemoveSelection:         command = QItemSelectionModel::Deselect;         break;     case AddToSelection:         command = QItemSelectionModel::SelectCurrent;         break;     }     if (command == QItemSelectionModel::NoUpdate)         return false;      if (child)         view->selectionModel()->select(idx, command);     else         view->selectionModel()->select(rowAt(row), command);     return true; }  class ModelIndexIterator { public:     ModelIndexIterator(QAbstractItemView *view, const QModelIndex&start = QModelIndex()) : m_view(view)     {
ifndef|#
directive|ifndef
name|QT_NO_LISTVIEW
end_ifndef
begin_endif
unit|list = qobject_cast<QListView*>(m_view);
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TREEVIEW
end_ifndef
begin_endif
unit|tree = qobject_cast<QTreeView*>(m_view);
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_endif
unit|table = qobject_cast<QTableView*>(m_view);
endif|#
directive|endif
end_endif
begin_ifndef
unit|if (start.isValid()) {             m_current = start;         } else if (m_view&& m_view->model()) {             m_current = view->rootIndex().isValid() ?                          view->rootIndex().child(0,0) : view->model()->index(0, 0);         }     }      bool next(int count = 1) {         for (int i = 0; i< count; ++i) {             do {                 if (m_current.isValid()) {                     const QAbstractItemModel *m = m_current.model();
ifndef|#
directive|ifndef
name|QT_NO_TREEVIEW
end_ifndef
begin_endif
unit|if (tree&& m_current.model()->hasChildren(m_current)&& tree->isExpanded(m_current)) {                         m_current = m_current.child(0, 0);                     } else
endif|#
directive|endif
end_endif
begin_comment
unit|{                         int row = m_current.row();                         QModelIndex par = m_current.parent();
comment|// Go up to the parent if we reach the end of the rows
end_comment
begin_comment
comment|// If m_curent becomses invalid, stop going up.
end_comment
begin_ifndef
unit|while (row + 1>= m->rowCount(par)) {                             m_current = par;                             if (m_current.isValid()) {                                 row = m_current.row();                                 par = m_current.parent();                             } else {                                 row = 0;                                 par = QModelIndex();                                 break;                             }                         }                          if (m_current.isValid())                             m_current = m_current.sibling(row + 1, 0);                     }                 }             } while (isHidden());         }         return m_current.isValid();     }      bool isHidden() const {         if (false) {
ifndef|#
directive|ifndef
name|QT_NO_LISTVIEW
end_ifndef
begin_endif
unit|} else if (list) {             return list->isRowHidden(m_current.row());
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TREEVIEW
end_ifndef
begin_endif
unit|} else if (tree) {             return tree->isRowHidden(m_current.row(), m_current.parent());
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_endif
unit|} else if (table) {             return table->isRowHidden(m_current.row());
endif|#
directive|endif
end_endif
begin_ifndef
unit|}         return false;     }      QModelIndex current() const {         return m_current;     }  private:     QModelIndex m_current;     QAbstractItemView *m_view;
ifndef|#
directive|ifndef
name|QT_NO_TREEVIEW
end_ifndef
begin_endif
unit|QTreeView *tree;
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LISTVIEW
end_ifndef
begin_endif
unit|QListView *list;
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_endif
unit|QTableView *table;
endif|#
directive|endif
end_endif
begin_ifndef
unit|};  QAccessibleItemView::QAccessibleItemView(QWidget *w)     : QAccessibleAbstractScrollArea(w->objectName() == QLatin1String("qt_scrollarea_viewport") ? w->parentWidget() : w) {     atVP = w->objectName() == QLatin1String("qt_scrollarea_viewport");  }   QHeaderView *QAccessibleItemView::horizontalHeader() const {     QHeaderView *header = 0;     if (false) {
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_endif
unit|} else if (const QTableView *tv = qobject_cast<const QTableView*>(itemView())) {         header = tv->horizontalHeader();
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TREEVIEW
end_ifndef
begin_endif
unit|} else if (const QTreeView *tv = qobject_cast<const QTreeView*>(itemView())) {         header = tv->header();
endif|#
directive|endif
end_endif
begin_ifndef
unit|}     return header; }  QHeaderView *QAccessibleItemView::verticalHeader() const {     QHeaderView *header = 0;     if (false) {
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_endif
unit|} else if (const QTableView *tv = qobject_cast<const QTableView*>(itemView())) {         header = tv->verticalHeader();
endif|#
directive|endif
end_endif
begin_ifndef
unit|}     return header; }   bool QAccessibleItemView::isValidChildRole(QAccessible::Role role) const {     if (atViewport()) {         if (false) {
ifndef|#
directive|ifndef
name|QT_NO_TREEVIEW
end_ifndef
begin_endif
unit|} else if (qobject_cast<const QTreeView*>(itemView())) {             return (role == TreeItem || role == Row);
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LISTVIEW
end_ifndef
begin_endif
unit|} else if (qobject_cast<const QListView*>(itemView())) {             return (role == ListItem);
endif|#
directive|endif
end_endif
begin_comment
unit|}
comment|// TableView
end_comment
begin_ifndef
unit|return role == Row;     } else {         if (false) {
ifndef|#
directive|ifndef
name|QT_NO_TREEVIEW
end_ifndef
begin_endif
unit|} else if (qobject_cast<const QTreeView*>(itemView())) {             return (role == Tree);
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LISTVIEW
end_ifndef
begin_endif
unit|} else if (qobject_cast<const QListView*>(itemView())) {             return (role == List);
endif|#
directive|endif
end_endif
begin_comment
unit|}
comment|// TableView
end_comment
begin_comment
unit|return (role == Table);     } }  QObject *QAccessibleItemView::object() const {     QObject *view = QAccessibleAbstractScrollArea::object();     Q_ASSERT(qobject_cast<const QAbstractItemView *>(view));     if (atViewport())         view = qobject_cast<const QAbstractItemView *>(view)->viewport();     return view; }  QAbstractItemView *QAccessibleItemView::itemView() const {     return qobject_cast<QAbstractItemView *>(QAccessibleAbstractScrollArea::object()); }  int QAccessibleItemView::indexOfChild(const QAccessibleInterface *iface) const {     if (atViewport()) {         if (!iface || !isValidChildRole(iface->role(0)))             return -1;          int entry = -1;
comment|// ### This will fail if a row is hidden.
end_comment
begin_ifndef
unit|const QAccessibleItemRow *ifRow = static_cast<const QAccessibleItemRow *>(iface);         if (ifRow->horizontalHeader())             return 1;          QModelIndex idx = ifRow->row;         if (!idx.isValid())             return -1;          entry = entryFromIndex(idx);         if (horizontalHeader())             ++entry;          return entry;      } else {         return QAccessibleAbstractScrollArea::indexOfChild(iface);     } }  QModelIndex QAccessibleItemView::childIndex(int child) const {     if (!atViewport())         return QModelIndex();     ModelIndexIterator it(itemView());     it.next(child - 1);     return it.current(); }  int QAccessibleItemView::entryFromIndex(const QModelIndex&index) const {     int entry = -1;     if (false) {
ifndef|#
directive|ifndef
name|QT_NO_TREEVIEW
end_ifndef
begin_endif
unit|} else if (QTreeView *tree = qobject_cast<QTreeView*>(itemView())) {         entry = tree->visualIndex(index) + 1;
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LISTVIEW
end_ifndef
begin_endif
unit|} else if (QListView *list = qobject_cast<QListView*>(itemView())) {         entry = list->visualIndex(index) + 1;
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_endif
unit|} else if (QTableView *table = qobject_cast<QTableView*>(itemView())) {         entry = table->visualIndex(index) + 1;
endif|#
directive|endif
end_endif
begin_comment
unit|}     return entry; }  int QAccessibleItemView::childCount() const {     if (atViewport()) {         if (itemView()->model() == 0)             return 0;         QAbstractItemModel *m = itemView()->model();         QModelIndex idx = m->index(0,0);         if (!idx.isValid())             return 0;         ModelIndexIterator it(itemView());         int count = 1;         while (it.next()) {             ++count;         }         if (horizontalHeader())             ++count;          return count;     } else {         return QAccessibleAbstractScrollArea::childCount();     } }  QString QAccessibleItemView::text(QAccessible::Text t, int child) const {     if (atViewport()) {         if (!child)             return QAccessibleAbstractScrollArea::text(t, child);          QAccessibleItemRow item(itemView(), childIndex(child));         if (item.isValid()) {             return item.text(t, 1);         } else {             return QString();         }     } else {         return QAccessibleAbstractScrollArea::text(t, child);     } }  void QAccessibleItemView::setText(QAccessible::Text t, int child, const QString&text) {     if (atViewport()) {         if (!child) {             QAccessibleAbstractScrollArea::setText(t, child, text);             return;         }          QAccessibleItemRow item(itemView(), childIndex(child));         item.setText(t, 1, text);     } else {         QAccessibleAbstractScrollArea::setText(t, child, text);     } }  QRect QAccessibleItemView::rect(int childIndex) const {     if (atViewport()) {         QRect r;         if (!childIndex) {
comment|// Make sure that the rect *include* the vertical and horizontal headers, while
end_comment
begin_comment
comment|// not including the potential vertical and horizontal scrollbars.
end_comment
begin_comment
unit|QAbstractItemView *w = itemView();              int vscrollWidth = 0;             const QScrollBar *sb = w->verticalScrollBar();             if (sb&& sb->isVisible())                 vscrollWidth = sb->width();              int hscrollHeight = 0;             sb = w->horizontalScrollBar();             if (sb&& sb->isVisible())                 hscrollHeight = sb->height();              QPoint globalPos = w->mapToGlobal(QPoint(0,0));             r = w->rect().translated(globalPos);             if (w->isRightToLeft()) {                 r.adjust(vscrollWidth, 0, 0, -hscrollHeight);             } else {                 r.adjust(0, 0, -vscrollWidth, -hscrollHeight);             }         } else {             QAccessibleInterface *iface = child(childIndex - 1);             if (iface) {                 r = iface->rect(0);                 delete iface;             }         }         return r;     } else {         QRect r = QAccessibleAbstractScrollArea::rect(childIndex);         if (childIndex == 1) {
comment|// include the potential vertical and horizontal headers
end_comment
begin_ifndef
unit|const QHeaderView *header = verticalHeader();             int headerWidth = (header&& header->isVisible()) ? header->width() : 0;             header = horizontalHeader();             int headerHeight= (header&& header->isVisible()) ? header->height() : 0;             if (itemView()->isRightToLeft()) {                 r.adjust(0, -headerHeight, headerWidth, 0);             } else {                 r.adjust(-headerWidth, -headerHeight, 0, 0);             }         }         return r;     } }  int QAccessibleItemView::childAt(int x, int y) const {     if (atViewport()) {         QPoint p(x, y);         for (int i = childCount(); i>= 0; --i) {             if (rect(i).contains(p))                 return i;         }         return -1;     } else {         return QAccessibleAbstractScrollArea::childAt(x, y);     } }  QAccessible::Role QAccessibleItemView::role(int child) const {     if ((!atViewport()&& child) || (atViewport()&& child == 0)) {         QAbstractItemView *view = itemView();
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_endif
unit|if (qobject_cast<QTableView *>(view))             return Table;
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_LISTVIEW
end_ifndef
begin_endif
unit|if (qobject_cast<QListView *>(view))             return List;
endif|#
directive|endif
end_endif
begin_comment
unit|return Tree;     }     if (atViewport()) {         if (child)             return Row;     }      return QAccessibleAbstractScrollArea::role(child); }  QAccessible::State QAccessibleItemView::state(int child) const {     State st = Normal;      if (itemView() == 0)         return State(Unavailable);      bool queryViewPort = (atViewport()&& child == 0) || (!atViewport()&& child == 1);     if (queryViewPort) {         if (itemView()->selectionMode() != QAbstractItemView::NoSelection) {             st |= Selectable;             st |= Focusable;         }     } else if (atViewport()) {
comment|// children of viewport
end_comment
begin_comment
unit|if (horizontalHeader())             --child;         if (child) {             QAccessibleItemRow item(itemView(), childIndex(child));             st |= item.state(0);         }     } else if (!atViewport()&& child != 1) {         st = QAccessibleAbstractScrollArea::state(child);     }     return st; }  bool QAccessibleItemView::isValid() const {     if (atViewport())         return QAccessibleWidget::isValid();     else         return QAccessibleAbstractScrollArea::isValid(); }  int QAccessibleItemView::navigate(RelationFlag relation, int index,                                   QAccessibleInterface **iface) const {     if (atViewport()) {         if (relation == Ancestor&& index == 1) {             *iface = new QAccessibleItemView(itemView());             return 0;         } else if (relation == Child&& index>= 1) {             if (horizontalHeader()) {                 if (index == 1) {                     *iface = new QAccessibleItemRow(itemView(), QModelIndex(), true);                     return 0;                 }                 --index;             }
comment|//###JAS hidden rows..
end_comment
begin_comment
unit|QModelIndex idx = childIndex(index);             if (idx.isValid()) {                 *iface = new QAccessibleItemRow(itemView(), idx);                 return 0;             }         } else if (relation == Sibling&& index>= 1) {             QAccessibleInterface *parent = new QAccessibleItemView(itemView());             return parent->navigate(Child, index, iface);         }         *iface = 0;         return -1;     } else {         return QAccessibleAbstractScrollArea::navigate(relation, index, iface);     } }
comment|/* returns the model index for a given row and column */
end_comment
begin_comment
unit|QModelIndex QAccessibleItemView::index(int row, int column) const {     return itemView()->model()->index(row, column); }  QAccessibleInterface *QAccessibleItemView::accessibleAt(int row, int column) {     QWidget *indexWidget = itemView()->indexWidget(index(row, column));     return QAccessible::queryAccessibleInterface(indexWidget); }
comment|/* We don't have a concept of a "caption" in Qt's standard widgets */
end_comment
begin_comment
unit|QAccessibleInterface *QAccessibleItemView::caption() {     return 0; }
comment|/* childIndex is row * columnCount + columnIndex */
end_comment
begin_comment
unit|int QAccessibleItemView::childIndex(int rowIndex, int columnIndex) {     return rowIndex * itemView()->model()->columnCount() + columnIndex; }
comment|/* Return the header data as column description */
end_comment
begin_comment
unit|QString QAccessibleItemView::columnDescription(int column) {     return itemView()->model()->headerData(column, Qt::Horizontal).toString(); }
comment|/* We don't support column spanning atm */
end_comment
begin_comment
unit|int QAccessibleItemView::columnSpan(int
comment|/* row */
end_comment
begin_comment
unit|, int
comment|/* column */
end_comment
begin_comment
unit|) {     return 1; }
comment|/* Return the horizontal header view */
end_comment
begin_ifndef
unit|QAccessibleInterface *QAccessibleItemView::columnHeader() {
ifndef|#
directive|ifndef
name|QT_NO_TREEVIEW
end_ifndef
begin_endif
unit|if (QTreeView *tree = qobject_cast<QTreeView *>(itemView()))         return QAccessible::queryAccessibleInterface(tree->header());
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_endif
unit|if (QTableView *table = qobject_cast<QTableView *>(itemView()))         return QAccessible::queryAccessibleInterface(table->horizontalHeader());
endif|#
directive|endif
end_endif
begin_comment
unit|return 0; }  int QAccessibleItemView::columnIndex(int childIndex) {     int columnCount = itemView()->model()->columnCount();     if (!columnCount)         return 0;      return childIndex % columnCount; }  int QAccessibleItemView::columnCount() {     return itemView()->model()->columnCount(); }  int QAccessibleItemView::rowCount() {     return itemView()->model()->rowCount(); }  int QAccessibleItemView::selectedColumnCount() {     return itemView()->selectionModel()->selectedColumns().count(); }  int QAccessibleItemView::selectedRowCount() {     return itemView()->selectionModel()->selectedRows().count(); }  QString QAccessibleItemView::rowDescription(int row) {     return itemView()->model()->headerData(row, Qt::Vertical).toString(); }
comment|/* We don't support row spanning */
end_comment
begin_comment
unit|int QAccessibleItemView::rowSpan(int
comment|/*row*/
end_comment
begin_comment
unit|, int
comment|/*column*/
end_comment
begin_ifndef
unit|) {     return 1; }  QAccessibleInterface *QAccessibleItemView::rowHeader() {
ifndef|#
directive|ifndef
name|QT_NO_TABLEVIEW
end_ifndef
begin_endif
unit|if (QTableView *table = qobject_cast<QTableView *>(itemView()))         return QAccessible::queryAccessibleInterface(table->verticalHeader());
endif|#
directive|endif
end_endif
begin_comment
unit|return 0; }  int QAccessibleItemView::rowIndex(int childIndex) {     int columnCount = itemView()->model()->columnCount();     if (!columnCount)         return 0;      return int(childIndex / columnCount); }  int QAccessibleItemView::selectedRows(int maxRows, QList<int> *rows) {     Q_ASSERT(rows);      const QModelIndexList selRows = itemView()->selectionModel()->selectedRows();     int maxCount = qMin(selRows.count(), maxRows);      for (int i = 0; i< maxCount; ++i)         rows->append(selRows.at(i).row());      return maxCount; }  int QAccessibleItemView::selectedColumns(int maxColumns, QList<int> *columns) {     Q_ASSERT(columns);      const QModelIndexList selColumns = itemView()->selectionModel()->selectedColumns();     int maxCount = qMin(selColumns.count(), maxColumns);      for (int i = 0; i< maxCount; ++i)         columns->append(selColumns.at(i).row());      return maxCount; }
comment|/* Qt widgets don't have a concept of a summary */
end_comment
begin_comment
unit|QAccessibleInterface *QAccessibleItemView::summary() {     return 0; }  bool QAccessibleItemView::isColumnSelected(int column) {     return itemView()->selectionModel()->isColumnSelected(column, QModelIndex()); }  bool QAccessibleItemView::isRowSelected(int row) {     return itemView()->selectionModel()->isRowSelected(row, QModelIndex()); }  bool QAccessibleItemView::isSelected(int row, int column) {     return itemView()->selectionModel()->isSelected(index(row, column)); }  void QAccessibleItemView::selectRow(int row) {     QItemSelectionModel *s = itemView()->selectionModel();     s->select(index(row, 0), QItemSelectionModel::Select | QItemSelectionModel::Rows); }  void QAccessibleItemView::selectColumn(int column) {     QItemSelectionModel *s = itemView()->selectionModel();     s->select(index(0, column), QItemSelectionModel::Select | QItemSelectionModel::Columns); }  void QAccessibleItemView::unselectRow(int row) {     QItemSelectionModel *s = itemView()->selectionModel();     s->select(index(row, 0), QItemSelectionModel::Deselect | QItemSelectionModel::Rows); }  void QAccessibleItemView::unselectColumn(int column) {     QItemSelectionModel *s = itemView()->selectionModel();     s->select(index(0, column), QItemSelectionModel::Deselect | QItemSelectionModel::Columns); }  void QAccessibleItemView::cellAtIndex(int index, int *row, int *column, int *rSpan,                                       int *cSpan, bool *isSelect) {     *row = rowIndex(index);     *column = columnIndex(index);     *rSpan = rowSpan(*row, *column);     *cSpan = columnSpan(*row, *column);     *isSelect = isSelected(*row, *column); }
comment|/*!   \class QAccessibleHeader   \brief The QAccessibleHeader class implements the QAccessibleInterface for header widgets.   \internal    \ingroup accessibility */
end_comment
begin_comment
comment|/*!   Constructs a QAccessibleHeader object for \a w. */
end_comment
begin_comment
unit|QAccessibleHeader::QAccessibleHeader(QWidget *w) : QAccessibleWidget(w) {     Q_ASSERT(header());     addControllingSignal(QLatin1String("sectionClicked(int)")); }
comment|/*! Returns the QHeaderView. */
end_comment
begin_endif
unit|QHeaderView *QAccessibleHeader::header() const {     return qobject_cast<QHeaderView*>(object()); }  QRect QAccessibleHeader::rect(int child) const {     if (!child)         return QAccessibleWidget::rect(0);      QHeaderView *h = header();     QPoint zero = h->mapToGlobal(QPoint(0, 0));     int sectionSize = h->sectionSize(child - 1);     int sectionPos = h->sectionPosition(child - 1);     return h->orientation() == Qt::Horizontal         ? QRect(zero.x() + sectionPos, zero.y(), sectionSize, h->height())         : QRect(zero.x(), zero.y() + sectionPos, h->width(), sectionSize); }  int QAccessibleHeader::childCount() const {     return header()->count(); }  QString QAccessibleHeader::text(QAccessible::Text t, int child) const {     QString str;      if (child> 0&& child<= childCount()) {         switch (t) {         case Name:             str = header()->model()->headerData(child - 1, header()->orientation()).toString();             break;         case Description: {             QAccessibleEvent event(QEvent::AccessibilityDescription, child);             if (QApplication::sendEvent(widget(),&event))                 str = event.value();             break; }         case Help: {             QAccessibleEvent event(QEvent::AccessibilityHelp, child);             if (QApplication::sendEvent(widget(),&event))                 str = event.value();             break; }         default:             break;         }     }     if (str.isEmpty())         str = QAccessibleWidget::text(t, child);     return str; }  QAccessible::Role QAccessibleHeader::role(int) const {     return (header()->orientation() == Qt::Horizontal) ? ColumnHeader : RowHeader; }  QAccessible::State QAccessibleHeader::state(int child) const {     State state = QAccessibleWidget::state(child);      if (child) {         int section = child - 1;         if (header()->isSectionHidden(section))             state |= Invisible;         if (header()->resizeMode(section) != QHeaderView::Custom)             state |= Sizeable;     } else {         if (header()->isMovable())             state |= Movable;     }     if (!header()->isClickable())         state |= Unavailable;     return state; }
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_ITEMVIEWS
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// 0
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABBAR
end_ifndef
begin_comment
comment|/*!   \class QAccessibleTabBar   \brief The QAccessibleTabBar class implements the QAccessibleInterface for tab bars.   \internal    \ingroup accessibility */
end_comment
begin_class
DECL|class|QAccessibleTabButton
class|class
name|QAccessibleTabButton
super|:
specifier|public
name|QAccessibleInterface
super|,
specifier|public
name|QAccessibleActionInterface
block|{
public|public:
DECL|function|QAccessibleTabButton
name|QAccessibleTabButton
parameter_list|(
name|QTabBar
modifier|*
name|parent
parameter_list|,
name|int
name|index
parameter_list|)
member_init_list|:
name|m_parent
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|m_index
argument_list|(
name|index
argument_list|)
block|{}
DECL|function|interface_cast
name|void
modifier|*
name|interface_cast
parameter_list|(
name|QAccessible
operator|::
name|InterfaceType
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
name|QAccessible
operator|::
name|ActionInterface
condition|)
block|{
return|return
cast|static_cast
argument_list|<
name|QAccessibleActionInterface
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
DECL|function|object
name|QObject
modifier|*
name|object
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
DECL|function|role
name|QAccessible
operator|::
name|Role
name|role
parameter_list|()
specifier|const
block|{
return|return
name|QAccessible
operator|::
name|PageTab
return|;
block|}
DECL|function|state
name|QAccessible
operator|::
name|State
name|state
parameter_list|()
specifier|const
block|{
name|QAccessibleInterface
modifier|*
name|parentInterface
init|=
name|parent
argument_list|()
decl_stmt|;
name|QAccessible
operator|::
name|State
name|state
init|=
name|parentInterface
operator|->
name|state
argument_list|()
decl_stmt|;
operator|delete
name|parentInterface
expr_stmt|;
return|return
name|state
return|;
block|}
DECL|function|rect
name|QRect
name|rect
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QRect
argument_list|()
return|;
name|QPoint
name|tp
init|=
name|m_parent
operator|->
name|mapToGlobal
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|QRect
name|rec
init|=
name|m_parent
operator|->
name|tabRect
argument_list|(
name|m_index
argument_list|)
decl_stmt|;
name|rec
operator|=
name|QRect
argument_list|(
name|tp
operator|.
name|x
argument_list|()
operator|+
name|rec
operator|.
name|x
argument_list|()
argument_list|,
name|tp
operator|.
name|y
argument_list|()
operator|+
name|rec
operator|.
name|y
argument_list|()
argument_list|,
name|rec
operator|.
name|width
argument_list|()
argument_list|,
name|rec
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rec
return|;
block|}
DECL|function|isValid
name|bool
name|isValid
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
comment|// (!m_parent.isNull())&& m_parent->count()> m_index; }
DECL|function|childAt
name|int
name|childAt
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
specifier|const
block|{
return|return
literal|0
return|;
block|}
DECL|function|childCount
name|int
name|childCount
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
DECL|function|indexOfChild
name|int
name|indexOfChild
parameter_list|(
specifier|const
name|QAccessibleInterface
modifier|*
parameter_list|)
specifier|const
block|{
return|return
operator|-
literal|1
return|;
block|}
DECL|function|text
name|QString
name|text
parameter_list|(
name|QAccessible
operator|::
name|Text
parameter_list|)
specifier|const
block|{
return|return
name|qt_accStripAmp
argument_list|(
name|m_parent
operator|->
name|tabText
argument_list|(
name|m_index
argument_list|)
argument_list|)
return|;
block|}
DECL|function|setText
name|void
name|setText
parameter_list|(
name|QAccessible
operator|::
name|Text
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
block|{}
DECL|function|parent
name|QAccessibleInterface
modifier|*
name|parent
parameter_list|()
specifier|const
block|{
return|return
name|QAccessible
operator|::
name|queryAccessibleInterface
argument_list|(
name|m_parent
argument_list|)
return|;
block|}
DECL|function|child
name|QAccessibleInterface
modifier|*
name|child
parameter_list|(
name|int
parameter_list|)
specifier|const
block|{
return|return
literal|0
return|;
block|}
DECL|function|navigate
name|int
name|navigate
parameter_list|(
name|QAccessible
operator|::
name|RelationFlag
name|relation
parameter_list|,
name|int
name|index
parameter_list|,
name|QAccessibleInterface
modifier|*
modifier|*
name|iface
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|relation
operator|==
name|QAccessible
operator|::
name|Ancestor
operator|&&
name|index
operator|==
literal|1
condition|)
block|{
operator|*
name|iface
operator|=
name|parent
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|function|relationTo
name|QAccessible
operator|::
name|Relation
name|relationTo
parameter_list|(
specifier|const
name|QAccessibleInterface
modifier|*
parameter_list|)
specifier|const
block|{
return|return
name|QAccessible
operator|::
name|Unrelated
return|;
block|}
comment|// action interface
DECL|function|actionNames
name|QStringList
name|actionNames
parameter_list|()
specifier|const
block|{
return|return
name|QStringList
argument_list|(
name|pressAction
argument_list|()
argument_list|)
return|;
block|}
DECL|function|doAction
name|void
name|doAction
parameter_list|(
specifier|const
name|QString
modifier|&
name|actionName
parameter_list|)
block|{
if|if
condition|(
name|actionName
operator|==
name|pressAction
argument_list|()
condition|)
name|m_parent
operator|->
name|setCurrentIndex
argument_list|(
name|m_index
argument_list|)
expr_stmt|;
block|}
DECL|function|keyBindingsForAction
name|QStringList
name|keyBindingsForAction
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
specifier|const
block|{
return|return
name|QStringList
argument_list|()
return|;
block|}
private|private:
DECL|member|m_parent
name|QPointer
argument_list|<
name|QTabBar
argument_list|>
name|m_parent
decl_stmt|;
DECL|member|m_index
name|int
name|m_index
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/*!   Constructs a QAccessibleTabBar object for \a w. */
end_comment
begin_constructor
DECL|function|QAccessibleTabBar
name|QAccessibleTabBar
operator|::
name|QAccessibleTabBar
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
member_init_list|:
name|QAccessibleWidget
argument_list|(
name|w
argument_list|,
name|QAccessible
operator|::
name|PageTabList
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|tabBar
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! Returns the QTabBar. */
end_comment
begin_function
DECL|function|tabBar
name|QTabBar
modifier|*
name|QAccessibleTabBar
operator|::
name|tabBar
parameter_list|()
specifier|const
block|{
return|return
name|qobject_cast
argument_list|<
name|QTabBar
operator|*
argument_list|>
argument_list|(
name|object
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|navigate
name|int
name|QAccessibleTabBar
operator|::
name|navigate
parameter_list|(
name|QAccessible
operator|::
name|RelationFlag
name|rel
parameter_list|,
name|int
name|entry
parameter_list|,
name|QAccessibleInterface
modifier|*
modifier|*
name|target
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|rel
operator|==
name|QAccessible
operator|::
name|Child
condition|)
block|{
operator|*
name|target
operator|=
name|child
argument_list|(
name|entry
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|target
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
return|return
name|QAccessibleWidget
operator|::
name|navigate
argument_list|(
name|rel
argument_list|,
name|entry
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|child
name|QAccessibleInterface
modifier|*
name|QAccessibleTabBar
operator|::
name|child
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
comment|// first the tabs, then 2 buttons
if|if
condition|(
name|index
operator|<
name|tabBar
argument_list|()
operator|->
name|count
argument_list|()
condition|)
block|{
name|QAccessibleTabButton
modifier|*
name|button
init|=
operator|new
name|QAccessibleTabButton
argument_list|(
name|tabBar
argument_list|()
argument_list|,
name|index
argument_list|)
decl_stmt|;
return|return
name|button
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|>=
name|tabBar
argument_list|()
operator|->
name|count
argument_list|()
condition|)
block|{
comment|// left button
if|if
condition|(
name|index
operator|-
name|tabBar
argument_list|()
operator|->
name|count
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|QAccessible
operator|::
name|queryAccessibleInterface
argument_list|(
name|tabBar
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|leftB
argument_list|)
return|;
block|}
comment|// right button
if|if
condition|(
name|index
operator|-
name|tabBar
argument_list|()
operator|->
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|QAccessible
operator|::
name|queryAccessibleInterface
argument_list|(
name|tabBar
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|rightB
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|indexOfChild
name|int
name|QAccessibleTabBar
operator|::
name|indexOfChild
parameter_list|(
specifier|const
name|QAccessibleInterface
modifier|*
name|child
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|child
operator|->
name|object
argument_list|()
operator|&&
name|child
operator|->
name|object
argument_list|()
operator|==
name|tabBar
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|leftB
condition|)
return|return
name|tabBar
argument_list|()
operator|->
name|count
argument_list|()
operator|+
literal|1
return|;
comment|// fixme - one based
if|if
condition|(
name|child
operator|->
name|object
argument_list|()
operator|&&
name|child
operator|->
name|object
argument_list|()
operator|==
name|tabBar
argument_list|()
operator|->
name|d_func
argument_list|()
operator|->
name|rightB
condition|)
return|return
name|tabBar
argument_list|()
operator|->
name|count
argument_list|()
operator|+
literal|2
return|;
comment|// fixme - one based
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|childCount
name|int
name|QAccessibleTabBar
operator|::
name|childCount
parameter_list|()
specifier|const
block|{
comment|// tabs + scroll buttons
return|return
name|tabBar
argument_list|()
operator|->
name|count
argument_list|()
operator|+
literal|2
return|;
block|}
end_function
begin_function
DECL|function|text
name|QString
name|QAccessibleTabBar
operator|::
name|text
parameter_list|(
name|QAccessible
operator|::
name|Text
name|t
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|t
operator|==
name|QAccessible
operator|::
name|Name
condition|)
block|{
return|return
name|qt_accStripAmp
argument_list|(
name|tabBar
argument_list|()
operator|->
name|tabText
argument_list|(
name|tabBar
argument_list|()
operator|->
name|currentIndex
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Selects the item with index \a child if \a on is true; otherwise     unselects it. If \a extend is true and the selection mode is not     \c Single and there is an existing selection, the selection is     extended to include all the items from the existing selection up     to and including the item with index \a child. Returns true if a     selection was made or extended; otherwise returns false.      \sa selection() clearSelection() */
end_comment
begin_function
DECL|function|setSelected
name|bool
name|QAccessibleTabBar
operator|::
name|setSelected
parameter_list|(
name|int
name|child
parameter_list|,
name|bool
name|on
parameter_list|,
name|bool
name|extend
parameter_list|)
block|{
if|if
condition|(
operator|!
name|child
operator|||
operator|!
name|on
operator|||
name|extend
operator|||
name|child
operator|>
name|tabBar
argument_list|()
operator|->
name|count
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|tabBar
argument_list|()
operator|->
name|isTabEnabled
argument_list|(
name|child
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|false
return|;
name|tabBar
argument_list|()
operator|->
name|setCurrentIndex
argument_list|(
name|child
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a (possibly empty) list of indexes of the items selected     in the list box.      \sa setSelected() clearSelection() */
end_comment
begin_function
DECL|function|selection
name|QVector
argument_list|<
name|int
argument_list|>
name|QAccessibleTabBar
operator|::
name|selection
parameter_list|()
specifier|const
block|{
name|QVector
argument_list|<
name|int
argument_list|>
name|array
decl_stmt|;
if|if
condition|(
name|tabBar
argument_list|()
operator|->
name|currentIndex
argument_list|()
operator|!=
operator|-
literal|1
condition|)
name|array
operator|+=
name|tabBar
argument_list|()
operator|->
name|currentIndex
argument_list|()
operator|+
literal|1
expr_stmt|;
return|return
name|array
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TABBAR
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COMBOBOX
end_ifndef
begin_comment
comment|/*!   \class QAccessibleComboBox   \brief The QAccessibleComboBox class implements the QAccessibleInterface for editable and read-only combo boxes.   \internal    \ingroup accessibility */
end_comment
begin_comment
comment|/*!   Constructs a QAccessibleComboBox object for \a w. */
end_comment
begin_constructor
DECL|function|QAccessibleComboBox
name|QAccessibleComboBox
operator|::
name|QAccessibleComboBox
parameter_list|(
name|QWidget
modifier|*
name|w
parameter_list|)
member_init_list|:
name|QAccessibleWidget
argument_list|(
name|w
argument_list|,
name|QAccessible
operator|::
name|ComboBox
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|comboBox
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!   Returns the combobox. */
end_comment
begin_function
DECL|function|comboBox
name|QComboBox
modifier|*
name|QAccessibleComboBox
operator|::
name|comboBox
parameter_list|()
specifier|const
block|{
return|return
name|qobject_cast
argument_list|<
name|QComboBox
operator|*
argument_list|>
argument_list|(
name|object
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|child
name|QAccessibleInterface
modifier|*
name|QAccessibleComboBox
operator|::
name|child
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|QAbstractItemView
modifier|*
name|view
init|=
name|comboBox
argument_list|()
operator|->
name|view
argument_list|()
decl_stmt|;
comment|//QWidget *parent = view ? view->parentWidget() : 0;
return|return
name|QAccessible
operator|::
name|queryAccessibleInterface
argument_list|(
name|view
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|==
literal|1
operator|&&
name|comboBox
argument_list|()
operator|->
name|isEditable
argument_list|()
condition|)
block|{
return|return
name|QAccessible
operator|::
name|queryAccessibleInterface
argument_list|(
name|comboBox
argument_list|()
operator|->
name|lineEdit
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|childCount
name|int
name|QAccessibleComboBox
operator|::
name|childCount
parameter_list|()
specifier|const
block|{
comment|// list and text edit
return|return
name|comboBox
argument_list|()
operator|->
name|isEditable
argument_list|()
condition|?
literal|2
else|:
literal|1
return|;
block|}
end_function
begin_function
DECL|function|childAt
name|int
name|QAccessibleComboBox
operator|::
name|childAt
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|comboBox
argument_list|()
operator|->
name|isEditable
argument_list|()
operator|&&
name|comboBox
argument_list|()
operator|->
name|lineEdit
argument_list|()
operator|->
name|rect
argument_list|()
operator|.
name|contains
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|indexOfChild
name|int
name|QAccessibleComboBox
operator|::
name|indexOfChild
parameter_list|(
specifier|const
name|QAccessibleInterface
modifier|*
name|child
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|comboBox
argument_list|()
operator|->
name|view
argument_list|()
operator|==
name|child
operator|->
name|object
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|comboBox
argument_list|()
operator|->
name|isEditable
argument_list|()
operator|&&
name|comboBox
argument_list|()
operator|->
name|lineEdit
argument_list|()
operator|==
name|child
operator|->
name|object
argument_list|()
condition|)
return|return
literal|1
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|text
name|QString
name|QAccessibleComboBox
operator|::
name|text
parameter_list|(
name|QAccessible
operator|::
name|Text
name|t
parameter_list|)
specifier|const
block|{
name|QString
name|str
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|QAccessible
operator|::
name|Name
case|:
ifndef|#
directive|ifndef
name|Q_OS_UNIX
comment|// on Linux we use relations for this, name is text (fall through to Value)
name|str
operator|=
name|QAccessibleWidget
operator|::
name|text
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|QAccessible
operator|::
name|Value
case|:
if|if
condition|(
name|comboBox
argument_list|()
operator|->
name|isEditable
argument_list|()
condition|)
name|str
operator|=
name|comboBox
argument_list|()
operator|->
name|lineEdit
argument_list|()
operator|->
name|text
argument_list|()
expr_stmt|;
else|else
name|str
operator|=
name|comboBox
argument_list|()
operator|->
name|currentText
argument_list|()
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|QT_NO_SHORTCUT
case|case
name|QAccessible
operator|::
name|Accelerator
case|:
name|str
operator|=
operator|(
name|QString
operator|)
name|QKeySequence
argument_list|(
name|Qt
operator|::
name|Key_Down
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
if|if
condition|(
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
name|str
operator|=
name|QAccessibleWidget
operator|::
name|text
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function
begin_function
DECL|function|actionNames
name|QStringList
name|QAccessibleComboBox
operator|::
name|actionNames
parameter_list|()
specifier|const
block|{
return|return
name|QStringList
argument_list|(
name|showMenuAction
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|localizedActionDescription
name|QString
name|QAccessibleComboBox
operator|::
name|localizedActionDescription
parameter_list|(
specifier|const
name|QString
modifier|&
name|actionName
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|actionName
operator|==
name|showMenuAction
argument_list|()
condition|)
return|return
name|QComboBox
operator|::
name|tr
argument_list|(
literal|"Open the combo box selection popup"
argument_list|)
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|doAction
name|void
name|QAccessibleComboBox
operator|::
name|doAction
parameter_list|(
specifier|const
name|QString
modifier|&
name|actionName
parameter_list|)
block|{
if|if
condition|(
name|actionName
operator|==
name|showMenuAction
argument_list|()
condition|)
block|{
if|if
condition|(
name|comboBox
argument_list|()
operator|->
name|view
argument_list|()
operator|->
name|isVisible
argument_list|()
condition|)
block|{
name|comboBox
argument_list|()
operator|->
name|hidePopup
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|comboBox
argument_list|()
operator|->
name|showPopup
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|keyBindingsForAction
name|QStringList
name|QAccessibleComboBox
operator|::
name|keyBindingsForAction
parameter_list|(
specifier|const
name|QString
modifier|&
comment|/*actionName*/
parameter_list|)
specifier|const
block|{
return|return
name|QStringList
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_COMBOBOX
end_comment
begin_function
DECL|function|removeInvisibleWidgetsFromList
specifier|static
specifier|inline
name|void
name|removeInvisibleWidgetsFromList
parameter_list|(
name|QWidgetList
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
operator|!
name|list
operator|||
name|list
operator|->
name|isEmpty
argument_list|()
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QWidget
modifier|*
name|widget
init|=
name|list
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|widget
operator|->
name|isVisible
argument_list|()
condition|)
name|list
operator|->
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SCROLLAREA
end_ifndef
begin_comment
comment|// ======================= QAccessibleAbstractScrollArea =======================
end_comment
begin_constructor
DECL|function|QAccessibleAbstractScrollArea
name|QAccessibleAbstractScrollArea
operator|::
name|QAccessibleAbstractScrollArea
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
member_init_list|:
name|QAccessibleWidget
argument_list|(
name|widget
argument_list|,
name|QAccessible
operator|::
name|Client
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|qobject_cast
argument_list|<
name|QAbstractScrollArea
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|invokeMethod
name|QVariant
name|QAccessibleAbstractScrollArea
operator|::
name|invokeMethod
parameter_list|(
name|QAccessible
operator|::
name|Method
parameter_list|,
name|int
parameter_list|,
specifier|const
name|QVariantList
modifier|&
parameter_list|)
block|{
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|child
name|QAccessibleInterface
modifier|*
name|QAccessibleAbstractScrollArea
operator|::
name|child
parameter_list|(
name|int
name|index
parameter_list|)
specifier|const
block|{
return|return
name|QAccessible
operator|::
name|queryAccessibleInterface
argument_list|(
name|accessibleChildren
argument_list|()
operator|.
name|at
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|childCount
name|int
name|QAccessibleAbstractScrollArea
operator|::
name|childCount
parameter_list|()
specifier|const
block|{
return|return
name|accessibleChildren
argument_list|()
operator|.
name|count
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|indexOfChild
name|int
name|QAccessibleAbstractScrollArea
operator|::
name|indexOfChild
parameter_list|(
specifier|const
name|QAccessibleInterface
modifier|*
name|child
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|child
operator|||
operator|!
name|child
operator|->
name|object
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|index
init|=
name|accessibleChildren
argument_list|()
operator|.
name|indexOf
argument_list|(
name|qobject_cast
argument_list|<
name|QWidget
operator|*
argument_list|>
argument_list|(
name|child
operator|->
name|object
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
return|return
operator|++
name|index
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|isValid
name|bool
name|QAccessibleAbstractScrollArea
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|QAccessibleWidget
operator|::
name|isValid
argument_list|()
operator|&&
name|abstractScrollArea
argument_list|()
operator|&&
name|abstractScrollArea
argument_list|()
operator|->
name|viewport
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|navigate
name|int
name|QAccessibleAbstractScrollArea
operator|::
name|navigate
parameter_list|(
name|QAccessible
operator|::
name|RelationFlag
name|relation
parameter_list|,
name|int
name|entry
parameter_list|,
name|QAccessibleInterface
modifier|*
modifier|*
name|target
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|target
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|target
operator|=
literal|0
expr_stmt|;
name|QWidget
modifier|*
name|targetWidget
init|=
literal|0
decl_stmt|;
name|QWidget
modifier|*
name|entryWidget
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|relation
operator|==
name|QAccessible
operator|::
name|Child
operator|||
name|relation
operator|==
name|QAccessible
operator|::
name|Left
operator|||
name|relation
operator|==
name|QAccessible
operator|::
name|Up
operator|||
name|relation
operator|==
name|QAccessible
operator|::
name|Right
operator|||
name|relation
operator|==
name|QAccessible
operator|::
name|Down
condition|)
block|{
name|QWidgetList
name|children
init|=
name|accessibleChildren
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
argument_list|<
literal|0
operator|||
name|entry
argument_list|>
name|children
operator|.
name|count
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|entry
operator|==
name|Self
condition|)
name|entryWidget
operator|=
name|abstractScrollArea
argument_list|()
expr_stmt|;
else|else
name|entryWidget
operator|=
name|children
operator|.
name|at
argument_list|(
name|entry
operator|-
literal|1
argument_list|)
expr_stmt|;
name|AbstractScrollAreaElement
name|entryElement
init|=
name|elementType
argument_list|(
name|entryWidget
argument_list|)
decl_stmt|;
comment|// Not one of the most beautiful switches I've ever seen, but I believe it has
comment|// to be like this since each case need special handling.
comment|// It might be possible to make it more general, but I'll leave that as an exercise
comment|// to the reader. :-)
switch|switch
condition|(
name|relation
condition|)
block|{
case|case
name|QAccessible
operator|::
name|Child
case|:
if|if
condition|(
name|entry
operator|>
literal|0
condition|)
block|{
operator|*
name|target
operator|=
name|child
argument_list|(
name|entry
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|*
name|target
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
case|case
name|QAccessible
operator|::
name|Left
case|:
if|if
condition|(
name|entry
operator|<
literal|1
condition|)
break|break;
switch|switch
condition|(
name|entryElement
condition|)
block|{
case|case
name|Viewport
case|:
if|if
condition|(
operator|!
name|isLeftToRight
argument_list|()
condition|)
name|targetWidget
operator|=
name|abstractScrollArea
argument_list|()
operator|->
name|verticalScrollBar
argument_list|()
expr_stmt|;
break|break;
case|case
name|HorizontalContainer
case|:
if|if
condition|(
operator|!
name|isLeftToRight
argument_list|()
condition|)
name|targetWidget
operator|=
name|abstractScrollArea
argument_list|()
operator|->
name|cornerWidget
argument_list|()
expr_stmt|;
break|break;
case|case
name|VerticalContainer
case|:
if|if
condition|(
name|isLeftToRight
argument_list|()
condition|)
name|targetWidget
operator|=
name|abstractScrollArea
argument_list|()
operator|->
name|viewport
argument_list|()
expr_stmt|;
break|break;
case|case
name|CornerWidget
case|:
if|if
condition|(
name|isLeftToRight
argument_list|()
condition|)
name|targetWidget
operator|=
name|abstractScrollArea
argument_list|()
operator|->
name|horizontalScrollBar
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|QAccessible
operator|::
name|Right
case|:
if|if
condition|(
name|entry
operator|<
literal|1
condition|)
break|break;
switch|switch
condition|(
name|entryElement
condition|)
block|{
case|case
name|Viewport
case|:
if|if
condition|(
name|isLeftToRight
argument_list|()
condition|)
name|targetWidget
operator|=
name|abstractScrollArea
argument_list|()
operator|->
name|verticalScrollBar
argument_list|()
expr_stmt|;
break|break;
case|case
name|HorizontalContainer
case|:
name|targetWidget
operator|=
name|abstractScrollArea
argument_list|()
operator|->
name|cornerWidget
argument_list|()
expr_stmt|;
break|break;
case|case
name|VerticalContainer
case|:
if|if
condition|(
operator|!
name|isLeftToRight
argument_list|()
condition|)
name|targetWidget
operator|=
name|abstractScrollArea
argument_list|()
operator|->
name|viewport
argument_list|()
expr_stmt|;
break|break;
case|case
name|CornerWidget
case|:
if|if
condition|(
operator|!
name|isLeftToRight
argument_list|()
condition|)
name|targetWidget
operator|=
name|abstractScrollArea
argument_list|()
operator|->
name|horizontalScrollBar
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|QAccessible
operator|::
name|Up
case|:
if|if
condition|(
name|entry
operator|<
literal|1
condition|)
break|break;
switch|switch
condition|(
name|entryElement
condition|)
block|{
case|case
name|HorizontalContainer
case|:
name|targetWidget
operator|=
name|abstractScrollArea
argument_list|()
operator|->
name|viewport
argument_list|()
expr_stmt|;
break|break;
case|case
name|CornerWidget
case|:
name|targetWidget
operator|=
name|abstractScrollArea
argument_list|()
operator|->
name|verticalScrollBar
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|QAccessible
operator|::
name|Down
case|:
if|if
condition|(
name|entry
operator|<
literal|1
condition|)
break|break;
switch|switch
condition|(
name|entryElement
condition|)
block|{
case|case
name|Viewport
case|:
name|targetWidget
operator|=
name|abstractScrollArea
argument_list|()
operator|->
name|horizontalScrollBar
argument_list|()
expr_stmt|;
break|break;
case|case
name|VerticalContainer
case|:
name|targetWidget
operator|=
name|abstractScrollArea
argument_list|()
operator|->
name|cornerWidget
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
return|return
name|QAccessibleWidget
operator|::
name|navigate
argument_list|(
name|relation
argument_list|,
name|entry
argument_list|,
name|target
argument_list|)
return|;
block|}
if|if
condition|(
name|qobject_cast
argument_list|<
specifier|const
name|QScrollBar
operator|*
argument_list|>
argument_list|(
name|targetWidget
argument_list|)
condition|)
name|targetWidget
operator|=
name|targetWidget
operator|->
name|parentWidget
argument_list|()
expr_stmt|;
operator|*
name|target
operator|=
name|QAccessible
operator|::
name|queryAccessibleInterface
argument_list|(
name|targetWidget
argument_list|)
expr_stmt|;
return|return
operator|*
name|target
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|//int QAccessibleAbstractScrollArea::childAt(int x, int y) const
end_comment
begin_comment
comment|//{
end_comment
begin_comment
comment|//    if (!abstractScrollArea()->isVisible())
end_comment
begin_comment
comment|//        return -1;
end_comment
begin_comment
comment|//#if 0
end_comment
begin_comment
comment|//    const QRect globalSelfGeometry = rect(Self);
end_comment
begin_comment
comment|//    if (!globalSelfGeometry.isValid() || !globalSelfGeometry.contains(QPoint(x, y)))
end_comment
begin_comment
comment|//        return -1;
end_comment
begin_comment
comment|//    const QWidgetList children = accessibleChildren();
end_comment
begin_comment
comment|//    for (int i = 0; i< children.count(); ++i) {
end_comment
begin_comment
comment|//        const QWidget *child = children.at(i);
end_comment
begin_comment
comment|//        const QRect globalChildGeometry = QRect(child->mapToGlobal(QPoint(0, 0)), child->size());
end_comment
begin_comment
comment|//        if (globalChildGeometry.contains(QPoint(x, y))) {
end_comment
begin_comment
comment|//            return ++i;
end_comment
begin_comment
comment|//        }
end_comment
begin_comment
comment|//    }
end_comment
begin_comment
comment|//    return 0;
end_comment
begin_comment
comment|//#else
end_comment
begin_comment
comment|//    for (int i = childCount(); i>= 0; --i) {
end_comment
begin_comment
comment|//        if (rect().contains(x, y))
end_comment
begin_comment
comment|//            return i;
end_comment
begin_comment
comment|//    }
end_comment
begin_comment
comment|//    return -1;
end_comment
begin_comment
comment|//#endif
end_comment
begin_comment
comment|//}
end_comment
begin_function
DECL|function|abstractScrollArea
name|QAbstractScrollArea
modifier|*
name|QAccessibleAbstractScrollArea
operator|::
name|abstractScrollArea
parameter_list|()
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
name|QAbstractScrollArea
operator|*
argument_list|>
argument_list|(
name|object
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|accessibleChildren
name|QWidgetList
name|QAccessibleAbstractScrollArea
operator|::
name|accessibleChildren
parameter_list|()
specifier|const
block|{
name|QWidgetList
name|children
decl_stmt|;
comment|// Viewport.
name|QWidget
modifier|*
name|viewport
init|=
name|abstractScrollArea
argument_list|()
operator|->
name|viewport
argument_list|()
decl_stmt|;
if|if
condition|(
name|viewport
condition|)
name|children
operator|.
name|append
argument_list|(
name|viewport
argument_list|)
expr_stmt|;
comment|// Horizontal scrollBar container.
name|QScrollBar
modifier|*
name|horizontalScrollBar
init|=
name|abstractScrollArea
argument_list|()
operator|->
name|horizontalScrollBar
argument_list|()
decl_stmt|;
if|if
condition|(
name|horizontalScrollBar
operator|&&
name|horizontalScrollBar
operator|->
name|isVisible
argument_list|()
condition|)
block|{
name|children
operator|.
name|append
argument_list|(
name|horizontalScrollBar
operator|->
name|parentWidget
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Vertical scrollBar container.
name|QScrollBar
modifier|*
name|verticalScrollBar
init|=
name|abstractScrollArea
argument_list|()
operator|->
name|verticalScrollBar
argument_list|()
decl_stmt|;
if|if
condition|(
name|verticalScrollBar
operator|&&
name|verticalScrollBar
operator|->
name|isVisible
argument_list|()
condition|)
block|{
name|children
operator|.
name|append
argument_list|(
name|verticalScrollBar
operator|->
name|parentWidget
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// CornerWidget.
name|QWidget
modifier|*
name|cornerWidget
init|=
name|abstractScrollArea
argument_list|()
operator|->
name|cornerWidget
argument_list|()
decl_stmt|;
if|if
condition|(
name|cornerWidget
operator|&&
name|cornerWidget
operator|->
name|isVisible
argument_list|()
condition|)
name|children
operator|.
name|append
argument_list|(
name|cornerWidget
argument_list|)
expr_stmt|;
return|return
name|children
return|;
block|}
end_function
begin_function
name|QAccessibleAbstractScrollArea
operator|::
name|AbstractScrollAreaElement
DECL|function|elementType
name|QAccessibleAbstractScrollArea
operator|::
name|elementType
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|widget
condition|)
return|return
name|Undefined
return|;
if|if
condition|(
name|widget
operator|==
name|abstractScrollArea
argument_list|()
condition|)
return|return
name|Self
return|;
if|if
condition|(
name|widget
operator|==
name|abstractScrollArea
argument_list|()
operator|->
name|viewport
argument_list|()
condition|)
return|return
name|Viewport
return|;
if|if
condition|(
name|widget
operator|->
name|objectName
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"qt_scrollarea_hcontainer"
argument_list|)
condition|)
return|return
name|HorizontalContainer
return|;
if|if
condition|(
name|widget
operator|->
name|objectName
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"qt_scrollarea_vcontainer"
argument_list|)
condition|)
return|return
name|VerticalContainer
return|;
if|if
condition|(
name|widget
operator|==
name|abstractScrollArea
argument_list|()
operator|->
name|cornerWidget
argument_list|()
condition|)
return|return
name|CornerWidget
return|;
return|return
name|Undefined
return|;
block|}
end_function
begin_function
DECL|function|isLeftToRight
name|bool
name|QAccessibleAbstractScrollArea
operator|::
name|isLeftToRight
parameter_list|()
specifier|const
block|{
return|return
name|abstractScrollArea
argument_list|()
operator|->
name|isLeftToRight
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// ======================= QAccessibleScrollArea ===========================
end_comment
begin_constructor
DECL|function|QAccessibleScrollArea
name|QAccessibleScrollArea
operator|::
name|QAccessibleScrollArea
parameter_list|(
name|QWidget
modifier|*
name|widget
parameter_list|)
member_init_list|:
name|QAccessibleAbstractScrollArea
argument_list|(
name|widget
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|qobject_cast
argument_list|<
name|QScrollArea
operator|*
argument_list|>
argument_list|(
name|widget
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_SCROLLAREA
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_ACCESSIBILITY
end_comment
end_unit
