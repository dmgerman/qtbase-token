begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qmeegolivepixmapdata.h"
end_include
begin_include
include|#
directive|include
file|"qmeegorasterpixmapdata.h"
end_include
begin_include
include|#
directive|include
file|<private/qimage_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qwindowsurface_gl_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qeglcontext_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qgraphicssystem_runtime_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qpixmap_x11_p.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_decl_stmt
DECL|variable|all_live_pixmaps
specifier|static
name|QMeeGoLivePixmapDataList
name|all_live_pixmaps
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|lock_attribs
specifier|static
name|EGLint
name|lock_attribs
index|[]
init|=
block|{
name|EGL_MAP_PRESERVE_PIXELS_KHR
block|,
name|EGL_TRUE
block|,
name|EGL_LOCK_USAGE_HINT_KHR
block|,
name|EGL_READ_SURFACE_BIT_KHR
operator||
name|EGL_WRITE_SURFACE_BIT_KHR
block|,
name|EGL_NONE
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|preserved_attribs
specifier|static
name|EGLint
name|preserved_attribs
index|[]
init|=
block|{
name|EGL_IMAGE_PRESERVED_KHR
block|,
name|EGL_TRUE
block|,
name|EGL_NONE
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|// as copied from qwindowsurface.cpp
end_comment
begin_function
DECL|function|qt_scrollRectInImage
name|void
name|qt_scrollRectInImage
parameter_list|(
name|QImage
modifier|&
name|img
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|)
block|{
comment|// make sure we don't detach
name|uchar
modifier|*
name|mem
init|=
cast|const_cast
argument_list|<
name|uchar
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
specifier|const
name|QImage
operator|&
argument_list|>
argument_list|(
name|img
argument_list|)
operator|.
name|bits
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|lineskip
init|=
name|img
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
name|int
name|depth
init|=
name|img
operator|.
name|depth
argument_list|()
operator|>>
literal|3
decl_stmt|;
specifier|const
name|QRect
name|imageRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QRect
name|r
init|=
name|rect
operator|&
name|imageRect
operator|&
name|imageRect
operator|.
name|translated
argument_list|(
operator|-
name|offset
argument_list|)
decl_stmt|;
specifier|const
name|QPoint
name|p
init|=
name|rect
operator|.
name|topLeft
argument_list|()
operator|+
name|offset
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
specifier|const
name|uchar
modifier|*
name|src
decl_stmt|;
name|uchar
modifier|*
name|dest
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|top
argument_list|()
operator|<
name|p
operator|.
name|y
argument_list|()
condition|)
block|{
name|src
operator|=
name|mem
operator|+
name|r
operator|.
name|bottom
argument_list|()
operator|*
name|lineskip
operator|+
name|r
operator|.
name|left
argument_list|()
operator|*
name|depth
expr_stmt|;
name|dest
operator|=
name|mem
operator|+
operator|(
name|p
operator|.
name|y
argument_list|()
operator|+
name|r
operator|.
name|height
argument_list|()
operator|-
literal|1
operator|)
operator|*
name|lineskip
operator|+
name|p
operator|.
name|x
argument_list|()
operator|*
name|depth
expr_stmt|;
name|lineskip
operator|=
operator|-
name|lineskip
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
name|mem
operator|+
name|r
operator|.
name|top
argument_list|()
operator|*
name|lineskip
operator|+
name|r
operator|.
name|left
argument_list|()
operator|*
name|depth
expr_stmt|;
name|dest
operator|=
name|mem
operator|+
name|p
operator|.
name|y
argument_list|()
operator|*
name|lineskip
operator|+
name|p
operator|.
name|x
argument_list|()
operator|*
name|depth
expr_stmt|;
block|}
specifier|const
name|int
name|w
init|=
name|r
operator|.
name|width
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|r
operator|.
name|height
argument_list|()
decl_stmt|;
specifier|const
name|int
name|bytes
init|=
name|w
operator|*
name|depth
decl_stmt|;
comment|// overlapping segments?
if|if
condition|(
name|offset
operator|.
name|y
argument_list|()
operator|==
literal|0
operator|&&
name|qAbs
argument_list|(
name|offset
operator|.
name|x
argument_list|()
argument_list|)
operator|<
name|w
condition|)
block|{
do|do
block|{
operator|::
name|memmove
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|lineskip
expr_stmt|;
name|src
operator|+=
name|lineskip
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|h
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
operator|::
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|lineskip
expr_stmt|;
name|src
operator|+=
name|lineskip
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|h
condition|)
do|;
block|}
block|}
end_function
begin_comment
comment|/* Public */
end_comment
begin_constructor
DECL|function|QMeeGoLivePixmapData
name|QMeeGoLivePixmapData
operator|::
name|QMeeGoLivePixmapData
parameter_list|(
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|QImage
operator|::
name|Format
name|format
parameter_list|)
member_init_list|:
name|QGLPixmapData
argument_list|(
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
block|{
name|QImage
name|image
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|format
argument_list|)
decl_stmt|;
name|QX11PixmapData
modifier|*
name|pmd
init|=
operator|new
name|QX11PixmapData
argument_list|(
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
decl_stmt|;
name|pmd
operator|->
name|fromImage
argument_list|(
name|image
argument_list|,
name|Qt
operator|::
name|NoOpaqueDetection
argument_list|)
expr_stmt|;
name|backingX11Pixmap
operator|=
operator|new
name|QPixmap
argument_list|(
name|pmd
argument_list|)
expr_stmt|;
name|initializeThroughEGLImage
argument_list|()
expr_stmt|;
name|pos
operator|=
name|all_live_pixmaps
operator|.
name|insert
argument_list|(
name|all_live_pixmaps
operator|.
name|begin
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QMeeGoLivePixmapData
name|QMeeGoLivePixmapData
operator|::
name|QMeeGoLivePixmapData
parameter_list|(
name|Qt
operator|::
name|HANDLE
name|h
parameter_list|)
member_init_list|:
name|QGLPixmapData
argument_list|(
name|QPixmapData
operator|::
name|PixmapType
argument_list|)
block|{
name|backingX11Pixmap
operator|=
operator|new
name|QPixmap
argument_list|(
name|QPixmap
operator|::
name|fromX11Pixmap
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|initializeThroughEGLImage
argument_list|()
expr_stmt|;
name|pos
operator|=
name|all_live_pixmaps
operator|.
name|insert
argument_list|(
name|all_live_pixmaps
operator|.
name|begin
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QMeeGoLivePixmapData
name|QMeeGoLivePixmapData
operator|::
name|~
name|QMeeGoLivePixmapData
parameter_list|()
block|{
operator|delete
name|backingX11Pixmap
expr_stmt|;
name|all_live_pixmaps
operator|.
name|erase
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|initializeThroughEGLImage
name|void
name|QMeeGoLivePixmapData
operator|::
name|initializeThroughEGLImage
parameter_list|()
block|{
if|if
condition|(
name|texture
argument_list|()
operator|->
name|id
operator|!=
literal|0
condition|)
return|return;
name|QGLShareContextScope
name|ctx
argument_list|(
name|qt_gl_share_widget
argument_list|()
operator|->
name|context
argument_list|()
argument_list|)
decl_stmt|;
name|QMeeGoExtensions
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
name|EGLImageKHR
name|eglImage
init|=
name|EGL_NO_IMAGE_KHR
decl_stmt|;
name|GLuint
name|newTextureId
init|=
literal|0
decl_stmt|;
name|eglImage
operator|=
name|QEgl
operator|::
name|eglCreateImageKHR
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|EGL_NO_CONTEXT
argument_list|,
name|EGL_NATIVE_PIXMAP_KHR
argument_list|,
operator|(
name|EGLClientBuffer
operator|)
name|backingX11Pixmap
operator|->
name|handle
argument_list|()
argument_list|,
name|preserved_attribs
argument_list|)
expr_stmt|;
if|if
condition|(
name|eglImage
operator|==
name|EGL_NO_IMAGE_KHR
condition|)
block|{
name|qWarning
argument_list|(
literal|"eglCreateImageKHR failed (live texture)!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|glGenTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|newTextureId
argument_list|)
expr_stmt|;
name|glBindTexture
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
name|newTextureId
argument_list|)
expr_stmt|;
name|glEGLImageTargetTexture2DOES
argument_list|(
name|GL_TEXTURE_2D
argument_list|,
operator|(
name|EGLImageKHR
operator|)
name|eglImage
argument_list|)
expr_stmt|;
if|if
condition|(
name|glGetError
argument_list|()
operator|==
name|GL_NO_ERROR
condition|)
block|{
name|resize
argument_list|(
name|backingX11Pixmap
operator|->
name|width
argument_list|()
argument_list|,
name|backingX11Pixmap
operator|->
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|texture
argument_list|()
operator|->
name|id
operator|=
name|newTextureId
expr_stmt|;
name|texture
argument_list|()
operator|->
name|options
operator|&=
operator|~
name|QGLContext
operator|::
name|InvertedYBindOption
expr_stmt|;
name|m_hasAlpha
operator|=
name|backingX11Pixmap
operator|->
name|hasAlphaChannel
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Failed to create a texture from an egl image (live texture)!"
argument_list|)
expr_stmt|;
name|glDeleteTextures
argument_list|(
literal|1
argument_list|,
operator|&
name|newTextureId
argument_list|)
expr_stmt|;
block|}
name|QEgl
operator|::
name|eglDestroyImageKHR
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|eglImage
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|createCompatiblePixmapData
name|QPixmapData
modifier|*
name|QMeeGoLivePixmapData
operator|::
name|createCompatiblePixmapData
parameter_list|()
specifier|const
block|{
name|qWarning
argument_list|(
literal|"Create compatible called on live pixmap! Expect fail soon..."
argument_list|)
expr_stmt|;
return|return
operator|new
name|QMeeGoRasterPixmapData
argument_list|(
name|pixelType
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|lock
name|QImage
modifier|*
name|QMeeGoLivePixmapData
operator|::
name|lock
parameter_list|(
name|EGLSyncKHR
name|fenceSync
parameter_list|)
block|{
name|QGLShareContextScope
name|ctx
argument_list|(
name|qt_gl_share_widget
argument_list|()
operator|->
name|context
argument_list|()
argument_list|)
decl_stmt|;
name|QMeeGoExtensions
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|fenceSync
condition|)
block|{
name|QMeeGoExtensions
operator|::
name|eglClientWaitSyncKHR
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|fenceSync
argument_list|,
name|EGL_SYNC_FLUSH_COMMANDS_BIT_KHR
argument_list|,
name|EGL_FOREVER_KHR
argument_list|)
expr_stmt|;
block|}
name|void
modifier|*
name|data
init|=
literal|0
decl_stmt|;
name|int
name|pitch
init|=
literal|0
decl_stmt|;
name|int
name|surfaceWidth
init|=
literal|0
decl_stmt|;
name|int
name|surfaceHeight
init|=
literal|0
decl_stmt|;
name|EGLSurface
name|surface
init|=
literal|0
decl_stmt|;
name|QImage
operator|::
name|Format
name|format
decl_stmt|;
name|lockedImage
operator|=
name|QImage
argument_list|()
expr_stmt|;
name|surface
operator|=
name|getSurfaceForBackingPixmap
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|QMeeGoExtensions
operator|::
name|eglLockSurfaceKHR
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|surface
argument_list|,
name|lock_attribs
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Failed to lock surface (live texture)!"
argument_list|)
expr_stmt|;
return|return
operator|&
name|lockedImage
return|;
block|}
name|eglQuerySurface
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|surface
argument_list|,
name|EGL_BITMAP_POINTER_KHR
argument_list|,
operator|(
name|EGLint
operator|*
operator|)
operator|&
name|data
argument_list|)
expr_stmt|;
name|eglQuerySurface
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|surface
argument_list|,
name|EGL_BITMAP_PITCH_KHR
argument_list|,
operator|(
name|EGLint
operator|*
operator|)
operator|&
name|pitch
argument_list|)
expr_stmt|;
name|eglQuerySurface
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|surface
argument_list|,
name|EGL_WIDTH
argument_list|,
operator|(
name|EGLint
operator|*
operator|)
operator|&
name|surfaceWidth
argument_list|)
expr_stmt|;
name|eglQuerySurface
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|surface
argument_list|,
name|EGL_HEIGHT
argument_list|,
operator|(
name|EGLint
operator|*
operator|)
operator|&
name|surfaceHeight
argument_list|)
expr_stmt|;
comment|// Ok, here we know we just support those two formats. Real solution would be:
comment|// query also the format.
if|if
condition|(
name|backingX11Pixmap
operator|->
name|depth
argument_list|()
operator|>
literal|16
condition|)
name|format
operator|=
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
expr_stmt|;
else|else
name|format
operator|=
name|QImage
operator|::
name|Format_RGB16
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
operator|||
name|pitch
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"Failed to query the live texture!"
argument_list|)
expr_stmt|;
return|return
operator|&
name|lockedImage
return|;
block|}
if|if
condition|(
name|width
argument_list|()
operator|!=
name|surfaceWidth
operator|||
name|height
argument_list|()
operator|!=
name|surfaceHeight
condition|)
block|{
name|qWarning
argument_list|(
literal|"Live texture dimensions don't match!"
argument_list|)
expr_stmt|;
name|QMeeGoExtensions
operator|::
name|eglUnlockSurfaceKHR
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|surface
argument_list|)
expr_stmt|;
return|return
operator|&
name|lockedImage
return|;
block|}
name|lockedImage
operator|=
name|QImage
argument_list|(
operator|(
name|uchar
operator|*
operator|)
name|data
argument_list|,
name|width
argument_list|()
argument_list|,
name|height
argument_list|()
argument_list|,
name|pitch
argument_list|,
name|format
argument_list|)
expr_stmt|;
return|return
operator|&
name|lockedImage
return|;
block|}
end_function
begin_function
DECL|function|release
name|bool
name|QMeeGoLivePixmapData
operator|::
name|release
parameter_list|(
name|QImage
modifier|*
comment|/*img*/
parameter_list|)
block|{
name|QGLShareContextScope
name|ctx
argument_list|(
name|qt_gl_share_widget
argument_list|()
operator|->
name|context
argument_list|()
argument_list|)
decl_stmt|;
name|QMeeGoExtensions
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|QMeeGoExtensions
operator|::
name|eglUnlockSurfaceKHR
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
name|getSurfaceForBackingPixmap
argument_list|()
argument_list|)
condition|)
block|{
name|lockedImage
operator|=
name|QImage
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|lockedImage
operator|=
name|QImage
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_function
begin_function
DECL|function|handle
name|Qt
operator|::
name|HANDLE
name|QMeeGoLivePixmapData
operator|::
name|handle
parameter_list|()
block|{
return|return
name|backingX11Pixmap
operator|->
name|handle
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|scroll
name|bool
name|QMeeGoLivePixmapData
operator|::
name|scroll
parameter_list|(
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|lock
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lockedImage
operator|.
name|isNull
argument_list|()
condition|)
name|qt_scrollRectInImage
argument_list|(
name|lockedImage
argument_list|,
name|rect
argument_list|,
name|QPoint
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|&
name|lockedImage
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|getSurfaceForBackingPixmap
name|EGLSurface
name|QMeeGoLivePixmapData
operator|::
name|getSurfaceForBackingPixmap
parameter_list|()
block|{
name|initializeThroughEGLImage
argument_list|()
expr_stmt|;
comment|// This code is a crative remix of the stuff that can be found in the
comment|// Qt's TFP implementation in /src/opengl/qgl_x11egl.cpp ::bindiTextureFromNativePixmap
name|QX11PixmapData
modifier|*
name|pixmapData
init|=
cast|static_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|backingX11Pixmap
operator|->
name|data_ptr
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|pixmapData
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|X11Class
argument_list|)
expr_stmt|;
name|bool
name|hasAlpha
init|=
name|pixmapData
operator|->
name|hasAlphaChannel
argument_list|()
decl_stmt|;
if|if
condition|(
name|pixmapData
operator|->
name|gl_surface
operator|&&
name|hasAlpha
operator|==
operator|(
name|pixmapData
operator|->
name|flags
operator|&
name|QX11PixmapData
operator|::
name|GlSurfaceCreatedWithAlpha
operator|)
condition|)
return|return
name|pixmapData
operator|->
name|gl_surface
return|;
comment|// Check to see if the surface is still valid
if|if
condition|(
name|pixmapData
operator|->
name|gl_surface
operator|&&
name|hasAlpha
operator|!=
operator|(
operator|(
name|pixmapData
operator|->
name|flags
operator|&
name|QX11PixmapData
operator|::
name|GlSurfaceCreatedWithAlpha
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
comment|// Surface is invalid!
name|destroySurfaceForPixmapData
argument_list|(
name|pixmapData
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pixmapData
operator|->
name|gl_surface
operator|==
literal|0
condition|)
block|{
name|EGLConfig
name|config
init|=
name|QEgl
operator|::
name|defaultConfig
argument_list|(
name|QInternal
operator|::
name|Pixmap
argument_list|,
name|QEgl
operator|::
name|OpenGL
argument_list|,
name|hasAlpha
condition|?
name|QEgl
operator|::
name|Translucent
else|:
name|QEgl
operator|::
name|NoOptions
argument_list|)
decl_stmt|;
name|pixmapData
operator|->
name|gl_surface
operator|=
operator|(
name|void
operator|*
operator|)
name|QEgl
operator|::
name|createSurface
argument_list|(
name|backingX11Pixmap
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasAlpha
condition|)
name|pixmapData
operator|->
name|flags
operator||=
name|QX11PixmapData
operator|::
name|GlSurfaceCreatedWithAlpha
expr_stmt|;
else|else
name|pixmapData
operator|->
name|flags
operator|&=
operator|~
name|QX11PixmapData
operator|::
name|GlSurfaceCreatedWithAlpha
expr_stmt|;
if|if
condition|(
name|pixmapData
operator|->
name|gl_surface
operator|==
operator|(
name|void
operator|*
operator|)
name|EGL_NO_SURFACE
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|pixmapData
operator|->
name|gl_surface
return|;
block|}
end_function
begin_function
DECL|function|destroySurfaceForPixmapData
name|void
name|QMeeGoLivePixmapData
operator|::
name|destroySurfaceForPixmapData
parameter_list|(
name|QPixmapData
modifier|*
name|pmd
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|pmd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|X11Class
argument_list|)
expr_stmt|;
name|QX11PixmapData
modifier|*
name|pixmapData
init|=
cast|static_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|pmd
argument_list|)
decl_stmt|;
if|if
condition|(
name|pixmapData
operator|->
name|gl_surface
condition|)
block|{
name|eglDestroySurface
argument_list|(
name|QEgl
operator|::
name|display
argument_list|()
argument_list|,
operator|(
name|EGLSurface
operator|)
name|pixmapData
operator|->
name|gl_surface
argument_list|)
expr_stmt|;
name|pixmapData
operator|->
name|gl_surface
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|invalidateSurfaces
name|void
name|QMeeGoLivePixmapData
operator|::
name|invalidateSurfaces
parameter_list|()
block|{
foreach|foreach
control|(
name|QMeeGoLivePixmapData
modifier|*
name|data
decl|,
name|all_live_pixmaps
control|)
block|{
name|QX11PixmapData
modifier|*
name|pixmapData
init|=
cast|static_cast
argument_list|<
name|QX11PixmapData
operator|*
argument_list|>
argument_list|(
name|data
operator|->
name|backingX11Pixmap
operator|->
name|data_ptr
argument_list|()
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
operator|*
name|data
operator|->
name|texture
argument_list|()
operator|=
name|QGLTexture
argument_list|()
expr_stmt|;
name|pixmapData
operator|->
name|gl_surface
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
end_unit
