begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qtablegenerator.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/QByteArray>
end_include
begin_include
include|#
directive|include
file|<QtCore/QTextCodec>
end_include
begin_include
include|#
directive|include
file|<QtCore/QDebug>
end_include
begin_include
include|#
directive|include
file|<QtCore/QDir>
end_include
begin_include
include|#
directive|include
file|<QtCore/QStringList>
end_include
begin_include
include|#
directive|include
file|<QtCore/QString>
end_include
begin_include
include|#
directive|include
file|<QtCore/QSaveFile>
end_include
begin_include
include|#
directive|include
file|<QtCore/QStandardPaths>
end_include
begin_include
include|#
directive|include
file|<private/qcore_unix_p.h>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|<xkbcommon/xkbcommon.h>
end_include
begin_include
include|#
directive|include
file|<locale.h>
end_include
begin_comment
comment|// LC_CTYPE
end_comment
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|// strchr, strncmp, etc.
end_comment
begin_include
include|#
directive|include
file|<strings.h>
end_include
begin_comment
comment|// strncasecmp
end_comment
begin_include
include|#
directive|include
file|<clocale>
end_include
begin_comment
comment|// LC_CTYPE
end_comment
begin_decl_stmt
DECL|variable|SupportedCacheVersion
specifier|static
specifier|const
name|quint32
name|SupportedCacheVersion
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*     In short on how and why the "Compose" file is cached:      The "Compose" file is large, for en_US it's likely located at:     /usr/share/X11/locale/en_US.UTF-8/Compose     and it has about 6000 string lines.     Q(Gui)Applications parse this file each time they're created. On modern CPUs     it incurs a 4-10 ms startup penalty of each Qt gui app, on older CPUs -     tens of ms or more.     Since the "Compose" file (almost) never changes using a pre-parsed     cache file instead of the "Compose" file is a good idea to improve Qt5     application startup time by about 5+ ms (or tens of ms on older CPUs).      The cache file contains the contents of the QComposeCacheFileHeader struct at the     beginning followed by the pre-parsed contents of the "Compose" file.      struct QComposeCacheFileHeader stores     (a) The cache version - in the unlikely event that some day one might need     to break compatibility.     (b) The (cache) file size.     (c) The lastModified field tracks if anything changed since the last time     the cache file was saved.     If anything did change then we read the compose file and save (cache) it     in binary/pre-parsed format, which should happen extremely rarely if at all. */
end_comment
begin_struct
DECL|struct|QComposeCacheFileHeader
struct|struct
name|QComposeCacheFileHeader
block|{
DECL|member|cacheVersion
name|quint32
name|cacheVersion
decl_stmt|;
comment|// The compiler will add 4 padding bytes anyway.
comment|// Reserve them explicitly to possibly use in the future.
DECL|member|reserved
name|quint32
name|reserved
decl_stmt|;
DECL|member|fileSize
name|quint64
name|fileSize
decl_stmt|;
DECL|member|lastModified
name|qint64
name|lastModified
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|// localHostName() copied from qtbase/src/corelib/io/qlockfile_unix.cpp
end_comment
begin_function
DECL|function|localHostName
specifier|static
name|QByteArray
name|localHostName
parameter_list|()
block|{
name|QByteArray
name|hostName
argument_list|(
literal|512
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|hostName
operator|.
name|data
argument_list|()
argument_list|,
name|hostName
operator|.
name|size
argument_list|()
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|QByteArray
argument_list|()
return|;
name|hostName
operator|.
name|truncate
argument_list|(
name|strlen
argument_list|(
name|hostName
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|hostName
return|;
block|}
end_function
begin_comment
comment|/*     Reads metadata about the Compose file. Later used to determine if the     compose cache should be updated. The fileSize field will be zero on failure. */
end_comment
begin_function
DECL|function|readFileMetadata
specifier|static
name|QComposeCacheFileHeader
name|readFileMetadata
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|QComposeCacheFileHeader
name|info
decl_stmt|;
name|info
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|fileSize
operator|=
literal|0
expr_stmt|;
specifier|const
name|QByteArray
name|pathBytes
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|QT_STATBUF
name|st
decl_stmt|;
if|if
condition|(
name|QT_STAT
argument_list|(
name|pathBytes
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|info
return|;
name|info
operator|.
name|lastModified
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|info
operator|.
name|fileSize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
return|return
name|info
return|;
block|}
end_function
begin_function
DECL|function|getCacheFilePath
specifier|static
specifier|const
name|QString
name|getCacheFilePath
parameter_list|()
block|{
name|QFile
name|machineIdFile
argument_list|(
literal|"/var/lib/dbus/machine-id"
argument_list|)
decl_stmt|;
name|QString
name|machineId
decl_stmt|;
if|if
condition|(
name|machineIdFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|machineIdFile
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
name|machineId
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|machineIdFile
operator|.
name|readAll
argument_list|()
operator|.
name|trimmed
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|machineId
operator|.
name|isEmpty
argument_list|()
condition|)
name|machineId
operator|=
name|localHostName
argument_list|()
expr_stmt|;
specifier|const
name|QString
name|dirPath
init|=
name|QStandardPaths
operator|::
name|writableLocation
argument_list|(
name|QStandardPaths
operator|::
name|GenericCacheLocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|QSysInfo
operator|::
name|ByteOrder
operator|==
name|QSysInfo
operator|::
name|BigEndian
condition|)
return|return
name|dirPath
operator|+
name|QLatin1String
argument_list|(
literal|"/qt_compose_cache_big_endian_"
argument_list|)
operator|+
name|machineId
return|;
return|return
name|dirPath
operator|+
name|QLatin1String
argument_list|(
literal|"/qt_compose_cache_little_endian_"
argument_list|)
operator|+
name|machineId
return|;
block|}
end_function
begin_comment
comment|// Returns empty vector on failure
end_comment
begin_function
DECL|function|loadCache
specifier|static
name|QVector
argument_list|<
name|QComposeTableElement
argument_list|>
name|loadCache
parameter_list|(
specifier|const
name|QComposeCacheFileHeader
modifier|&
name|composeInfo
parameter_list|)
block|{
name|QVector
argument_list|<
name|QComposeTableElement
argument_list|>
name|vec
decl_stmt|;
specifier|const
name|QString
name|cacheFilePath
init|=
name|getCacheFilePath
argument_list|()
decl_stmt|;
name|QFile
name|inputFile
argument_list|(
name|cacheFilePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inputFile
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
return|return
name|vec
return|;
name|QComposeCacheFileHeader
name|cacheInfo
decl_stmt|;
comment|// use a "buffer" variable to make the line after this one more readable.
name|char
modifier|*
name|buffer
init|=
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|cacheInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputFile
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|cacheInfo
argument_list|)
operator|!=
sizeof|sizeof
name|cacheInfo
condition|)
return|return
name|vec
return|;
if|if
condition|(
name|cacheInfo
operator|.
name|fileSize
operator|==
literal|0
condition|)
return|return
name|vec
return|;
comment|// using "!=" just in case someone replaced with a backup that existed before
if|if
condition|(
name|cacheInfo
operator|.
name|lastModified
operator|!=
name|composeInfo
operator|.
name|lastModified
condition|)
return|return
name|vec
return|;
if|if
condition|(
name|cacheInfo
operator|.
name|cacheVersion
operator|!=
name|SupportedCacheVersion
condition|)
return|return
name|vec
return|;
specifier|const
name|QByteArray
name|pathBytes
init|=
name|QFile
operator|::
name|encodeName
argument_list|(
name|cacheFilePath
argument_list|)
decl_stmt|;
name|QT_STATBUF
name|st
decl_stmt|;
if|if
condition|(
name|QT_STAT
argument_list|(
name|pathBytes
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|vec
return|;
specifier|const
name|off_t
name|fileSize
init|=
name|st
operator|.
name|st_size
decl_stmt|;
if|if
condition|(
name|fileSize
operator|>
literal|1024
operator|*
literal|1024
operator|*
literal|5
condition|)
block|{
comment|// The cache file size is usually about 150KB, so if its size is over
comment|// say 5MB then somebody inflated the file, abort.
return|return
name|vec
return|;
block|}
specifier|const
name|off_t
name|bufferSize
init|=
name|fileSize
operator|-
operator|(
sizeof|sizeof
name|cacheInfo
operator|)
decl_stmt|;
specifier|const
name|size_t
name|elemSize
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|QComposeTableElement
argument_list|)
decl_stmt|;
specifier|const
name|int
name|elemCount
init|=
name|bufferSize
operator|/
name|elemSize
decl_stmt|;
specifier|const
name|QByteArray
name|ba
init|=
name|inputFile
operator|.
name|read
argument_list|(
name|bufferSize
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
init|=
name|ba
operator|.
name|data
argument_list|()
decl_stmt|;
comment|// Since we know the number of the (many) elements and their size in
comment|// advance calling vector.reserve(..) seems reasonable.
name|vec
operator|.
name|reserve
argument_list|(
name|elemCount
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|elemCount
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|QComposeTableElement
modifier|*
name|elem
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|QComposeTableElement
operator|*
argument_list|>
argument_list|(
name|data
operator|+
operator|(
name|i
operator|*
name|elemSize
operator|)
argument_list|)
decl_stmt|;
name|vec
operator|.
name|push_back
argument_list|(
operator|*
name|elem
argument_list|)
expr_stmt|;
block|}
return|return
name|vec
return|;
block|}
end_function
begin_comment
comment|// Returns true on success, false otherwise.
end_comment
begin_function
DECL|function|saveCache
specifier|static
name|bool
name|saveCache
parameter_list|(
specifier|const
name|QComposeCacheFileHeader
modifier|&
name|info
parameter_list|,
specifier|const
name|QVector
argument_list|<
name|QComposeTableElement
argument_list|>
modifier|&
name|vec
parameter_list|)
block|{
specifier|const
name|QString
name|filePath
init|=
name|getCacheFilePath
argument_list|()
decl_stmt|;
name|QSaveFile
name|outputFile
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|outputFile
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
condition|)
return|return
literal|false
return|;
specifier|const
name|char
modifier|*
name|data
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|outputFile
operator|.
name|write
argument_list|(
name|data
argument_list|,
sizeof|sizeof
name|info
argument_list|)
operator|!=
sizeof|sizeof
name|info
condition|)
return|return
literal|false
return|;
name|data
operator|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|vec
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
specifier|const
name|qint64
name|size
init|=
name|vec
operator|.
name|size
argument_list|()
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|QComposeTableElement
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|outputFile
operator|.
name|write
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
return|return
literal|false
return|;
return|return
name|outputFile
operator|.
name|commit
argument_list|()
return|;
block|}
end_function
begin_constructor
DECL|function|TableGenerator
name|TableGenerator
operator|::
name|TableGenerator
parameter_list|()
member_init_list|:
name|m_state
argument_list|(
name|NoErrors
argument_list|)
member_init_list|,
name|m_systemComposeDir
argument_list|(
name|QString
argument_list|()
argument_list|)
block|{
name|initPossibleLocations
argument_list|()
expr_stmt|;
name|QString
name|composeFilePath
init|=
name|findComposeFile
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_GENERATOR
comment|// don't use cache when in debug mode.
if|if
condition|(
operator|!
name|composeFilePath
operator|.
name|isEmpty
argument_list|()
condition|)
name|qDebug
argument_list|()
operator|<<
literal|"Using Compose file from: "
operator|<<
name|composeFilePath
expr_stmt|;
else|#
directive|else
name|QComposeCacheFileHeader
name|fileInfo
init|=
name|readFileMetadata
argument_list|(
name|composeFilePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileInfo
operator|.
name|fileSize
operator|!=
literal|0
condition|)
name|m_composeTable
operator|=
name|loadCache
argument_list|(
name|fileInfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m_composeTable
operator|.
name|isEmpty
argument_list|()
operator|&&
name|cleanState
argument_list|()
condition|)
block|{
if|if
condition|(
name|composeFilePath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|m_state
operator|=
name|MissingComposeFile
expr_stmt|;
block|}
else|else
block|{
name|QFile
name|composeFile
argument_list|(
name|composeFilePath
argument_list|)
decl_stmt|;
name|composeFile
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|parseComposeFile
argument_list|(
operator|&
name|composeFile
argument_list|)
expr_stmt|;
name|orderComposeTable
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_composeTable
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|m_state
operator|=
name|EmptyTable
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG_GENERATOR
comment|// don't save cache when in debug mode
block|}
else|else
block|{
name|fileInfo
operator|.
name|cacheVersion
operator|=
name|SupportedCacheVersion
expr_stmt|;
name|saveCache
argument_list|(
name|fileInfo
argument_list|,
name|m_composeTable
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_GENERATOR
name|printComposeTable
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_constructor
begin_function
DECL|function|initPossibleLocations
name|void
name|TableGenerator
operator|::
name|initPossibleLocations
parameter_list|()
block|{
comment|// Compose files come as a part of Xlib library. Xlib doesn't provide
comment|// a mechanism how to retrieve the location of these files reliably, since it was
comment|// never meant for external software to parse compose tables directly. Best we
comment|// can do is to hardcode search paths. To add an extra system path use
comment|// the QTCOMPOSE environment variable
if|if
condition|(
name|qEnvironmentVariableIsSet
argument_list|(
literal|"QTCOMPOSE"
argument_list|)
condition|)
name|m_possibleLocations
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"QTCOMPOSE"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|m_possibleLocations
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"/usr/share/X11/locale"
argument_list|)
argument_list|)
expr_stmt|;
name|m_possibleLocations
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"/usr/local/share/X11/locale"
argument_list|)
argument_list|)
expr_stmt|;
name|m_possibleLocations
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"/usr/lib/X11/locale"
argument_list|)
argument_list|)
expr_stmt|;
name|m_possibleLocations
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"/usr/local/lib/X11/locale"
argument_list|)
argument_list|)
expr_stmt|;
name|m_possibleLocations
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
name|X11_PREFIX
literal|"/share/X11/locale"
argument_list|)
argument_list|)
expr_stmt|;
name|m_possibleLocations
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
name|X11_PREFIX
literal|"/lib/X11/locale"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|findComposeFile
name|QString
name|TableGenerator
operator|::
name|findComposeFile
parameter_list|()
block|{
comment|// check if XCOMPOSEFILE points to a Compose file
if|if
condition|(
name|qEnvironmentVariableIsSet
argument_list|(
literal|"XCOMPOSEFILE"
argument_list|)
condition|)
block|{
specifier|const
name|QString
name|path
init|=
name|QFile
operator|::
name|decodeName
argument_list|(
name|qgetenv
argument_list|(
literal|"XCOMPOSEFILE"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|path
return|;
else|else
name|qWarning
argument_list|(
literal|"$XCOMPOSEFILE doesn't point to an existing file"
argument_list|)
expr_stmt|;
block|}
comment|// check if userâs home directory has a file named .XCompose
if|if
condition|(
name|cleanState
argument_list|()
condition|)
block|{
name|QString
name|path
init|=
name|qgetenv
argument_list|(
literal|"HOME"
argument_list|)
operator|+
name|QStringLiteral
argument_list|(
literal|"/.XCompose"
argument_list|)
decl_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|path
return|;
block|}
comment|// check for the system provided compose files
if|if
condition|(
name|cleanState
argument_list|()
condition|)
block|{
name|QString
name|table
init|=
name|composeTableForLocale
argument_list|()
decl_stmt|;
if|if
condition|(
name|cleanState
argument_list|()
condition|)
block|{
if|if
condition|(
name|table
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// no table mappings for the system's locale in the compose.dir
name|m_state
operator|=
name|UnsupportedLocale
expr_stmt|;
else|else
block|{
name|QString
name|path
init|=
name|QDir
argument_list|(
name|systemComposeDir
argument_list|()
argument_list|)
operator|.
name|filePath
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|path
return|;
block|}
block|}
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|composeTableForLocale
name|QString
name|TableGenerator
operator|::
name|composeTableForLocale
parameter_list|()
block|{
name|QByteArray
name|loc
init|=
name|locale
argument_list|()
operator|.
name|toUpper
argument_list|()
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
name|QString
name|table
init|=
name|readLocaleMappings
argument_list|(
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|.
name|isEmpty
argument_list|()
condition|)
name|table
operator|=
name|readLocaleMappings
argument_list|(
name|readLocaleAliases
argument_list|(
name|loc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
end_function
begin_function
DECL|function|findSystemComposeDir
name|bool
name|TableGenerator
operator|::
name|findSystemComposeDir
parameter_list|()
block|{
name|bool
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_possibleLocations
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|path
init|=
name|m_possibleLocations
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|QFile
operator|::
name|exists
argument_list|(
name|path
operator|+
name|QLatin1String
argument_list|(
literal|"/compose.dir"
argument_list|)
argument_list|)
condition|)
block|{
name|m_systemComposeDir
operator|=
name|path
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|// should we ask to report this in the qt bug tracker?
name|m_state
operator|=
name|UnknownSystemComposeDir
expr_stmt|;
name|qWarning
argument_list|(
literal|"Qt Warning: Could not find a location of the system's Compose files. "
literal|"Consider setting the QTCOMPOSE environment variable."
argument_list|)
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_function
begin_function
DECL|function|systemComposeDir
name|QString
name|TableGenerator
operator|::
name|systemComposeDir
parameter_list|()
block|{
if|if
condition|(
name|m_systemComposeDir
operator|.
name|isNull
argument_list|()
operator|&&
operator|!
name|findSystemComposeDir
argument_list|()
condition|)
block|{
return|return
name|QLatin1String
argument_list|(
literal|"$QTCOMPOSE"
argument_list|)
return|;
block|}
return|return
name|m_systemComposeDir
return|;
block|}
end_function
begin_function
DECL|function|locale
name|QString
name|TableGenerator
operator|::
name|locale
parameter_list|()
specifier|const
block|{
name|char
modifier|*
name|name
init|=
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
return|return
name|QLatin1String
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|readLocaleMappings
name|QString
name|TableGenerator
operator|::
name|readLocaleMappings
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|locale
parameter_list|)
block|{
name|QString
name|file
decl_stmt|;
if|if
condition|(
name|locale
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|file
return|;
name|QFile
name|mappings
argument_list|(
name|systemComposeDir
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|"/compose.dir"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|mappings
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
specifier|const
name|int
name|localeNameLength
init|=
name|locale
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|localeData
init|=
name|locale
operator|.
name|constData
argument_list|()
decl_stmt|;
name|char
name|l
index|[
literal|1024
index|]
decl_stmt|;
comment|// formating of compose.dir has some inconsistencies
while|while
condition|(
operator|!
name|mappings
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|int
name|read
init|=
name|mappings
operator|.
name|readLine
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|<=
literal|0
condition|)
break|break;
name|char
modifier|*
name|line
init|=
name|l
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|>=
literal|'a'
operator|&&
operator|*
name|line
operator|<=
literal|'z'
condition|)
block|{
comment|// file name
while|while
condition|(
operator|*
name|line
operator|&&
operator|*
name|line
operator|!=
literal|':'
operator|&&
operator|*
name|line
operator|!=
literal|' '
operator|&&
operator|*
name|line
operator|!=
literal|'\t'
condition|)
operator|++
name|line
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
continue|continue;
specifier|const
name|char
modifier|*
specifier|const
name|composeFileNameEnd
init|=
name|line
decl_stmt|;
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|line
expr_stmt|;
comment|// locale name
while|while
condition|(
operator|*
name|line
operator|&&
operator|(
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
name|line
operator|==
literal|'\t'
operator|)
condition|)
operator|++
name|line
expr_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|lc
init|=
name|line
decl_stmt|;
while|while
condition|(
operator|*
name|line
operator|&&
operator|*
name|line
operator|!=
literal|' '
operator|&&
operator|*
name|line
operator|!=
literal|'\t'
operator|&&
operator|*
name|line
operator|!=
literal|'\n'
condition|)
operator|++
name|line
expr_stmt|;
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|localeNameLength
operator|==
operator|(
name|line
operator|-
name|lc
operator|)
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|lc
argument_list|,
name|localeData
argument_list|,
name|line
operator|-
name|lc
argument_list|)
condition|)
block|{
name|file
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|l
argument_list|,
name|composeFileNameEnd
operator|-
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|mappings
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|file
return|;
block|}
end_function
begin_function
DECL|function|readLocaleAliases
name|QByteArray
name|TableGenerator
operator|::
name|readLocaleAliases
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|locale
parameter_list|)
block|{
name|QFile
name|aliases
argument_list|(
name|systemComposeDir
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|"/locale.alias"
argument_list|)
argument_list|)
decl_stmt|;
name|QByteArray
name|fullLocaleName
decl_stmt|;
if|if
condition|(
name|aliases
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|aliases
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|char
name|l
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|read
init|=
name|aliases
operator|.
name|readLine
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|l
decl_stmt|;
if|if
condition|(
name|read
operator|&&
operator|(
operator|(
operator|*
name|line
operator|>=
literal|'a'
operator|&&
operator|*
name|line
operator|<=
literal|'z'
operator|)
operator|||
operator|(
operator|*
name|line
operator|>=
literal|'A'
operator|&&
operator|*
name|line
operator|<=
literal|'Z'
operator|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|alias
init|=
name|line
decl_stmt|;
while|while
condition|(
operator|*
name|line
operator|&&
operator|*
name|line
operator|!=
literal|':'
operator|&&
operator|*
name|line
operator|!=
literal|' '
operator|&&
operator|*
name|line
operator|!=
literal|'\t'
condition|)
operator|++
name|line
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
continue|continue;
operator|*
name|line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|locale
operator|.
name|size
argument_list|()
operator|==
operator|(
name|line
operator|-
name|alias
operator|)
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|alias
argument_list|,
name|locale
operator|.
name|constData
argument_list|()
argument_list|,
name|line
operator|-
name|alias
argument_list|)
condition|)
block|{
comment|// found a match for alias, read the real locale name
operator|++
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|line
operator|&&
operator|(
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
name|line
operator|==
literal|'\t'
operator|)
condition|)
operator|++
name|line
expr_stmt|;
specifier|const
name|char
modifier|*
name|fullName
init|=
name|line
decl_stmt|;
while|while
condition|(
operator|*
name|line
operator|&&
operator|*
name|line
operator|!=
literal|' '
operator|&&
operator|*
name|line
operator|!=
literal|'\t'
operator|&&
operator|*
name|line
operator|!=
literal|'\n'
condition|)
operator|++
name|line
expr_stmt|;
operator|*
name|line
operator|=
literal|0
expr_stmt|;
name|fullLocaleName
operator|=
name|fullName
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_GENERATOR
name|qDebug
argument_list|()
operator|<<
literal|"Alias for: "
operator|<<
name|alias
operator|<<
literal|"is: "
operator|<<
name|fullLocaleName
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
block|}
name|aliases
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|fullLocaleName
return|;
block|}
end_function
begin_function
DECL|function|processFile
name|bool
name|TableGenerator
operator|::
name|processFile
parameter_list|(
specifier|const
name|QString
modifier|&
name|composeFileName
parameter_list|)
block|{
name|QFile
name|composeFile
argument_list|(
name|composeFileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|composeFile
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|parseComposeFile
argument_list|(
operator|&
name|composeFile
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|qWarning
argument_list|()
operator|<<
name|QString
argument_list|(
name|QLatin1String
argument_list|(
literal|"Qt Warning: Compose file: \"%1\" can't be found"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|composeFile
operator|.
name|fileName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_destructor
DECL|function|~TableGenerator
name|TableGenerator
operator|::
name|~
name|TableGenerator
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|composeTable
name|QVector
argument_list|<
name|QComposeTableElement
argument_list|>
name|TableGenerator
operator|::
name|composeTable
parameter_list|()
specifier|const
block|{
return|return
name|m_composeTable
return|;
block|}
end_function
begin_function
DECL|function|parseComposeFile
name|void
name|TableGenerator
operator|::
name|parseComposeFile
parameter_list|(
name|QFile
modifier|*
name|composeFile
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_GENERATOR
name|qDebug
argument_list|()
operator|<<
literal|"TableGenerator::parseComposeFile: "
operator|<<
name|composeFile
operator|->
name|fileName
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|;
while|while
condition|(
operator|!
name|composeFile
operator|->
name|atEnd
argument_list|()
condition|)
block|{
name|composeFile
operator|->
name|readLine
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'<'
condition|)
name|parseKeySequence
argument_list|(
name|line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"include"
argument_list|,
literal|7
argument_list|)
condition|)
name|parseIncludeInstruction
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|composeFile
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseIncludeInstruction
name|void
name|TableGenerator
operator|::
name|parseIncludeInstruction
parameter_list|(
name|QString
name|line
parameter_list|)
block|{
comment|// Parse something that looks like:
comment|// include "/usr/share/X11/locale/en_US.UTF-8/Compose"
name|QString
name|quote
init|=
name|QStringLiteral
argument_list|(
literal|"\""
argument_list|)
decl_stmt|;
name|line
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|line
operator|.
name|indexOf
argument_list|(
name|quote
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|line
operator|.
name|chop
argument_list|(
name|line
operator|.
name|length
argument_list|()
operator|-
name|line
operator|.
name|indexOf
argument_list|(
name|quote
argument_list|)
argument_list|)
expr_stmt|;
comment|// expand substitutions if present
name|line
operator|.
name|replace
argument_list|(
name|QLatin1String
argument_list|(
literal|"%H"
argument_list|)
argument_list|,
name|QString
argument_list|(
name|qgetenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
name|QLatin1String
argument_list|(
literal|"%L"
argument_list|)
argument_list|,
name|systemComposeDir
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
operator|+
name|composeTableForLocale
argument_list|()
argument_list|)
expr_stmt|;
name|line
operator|.
name|replace
argument_list|(
name|QLatin1String
argument_list|(
literal|"%S"
argument_list|)
argument_list|,
name|systemComposeDir
argument_list|()
argument_list|)
expr_stmt|;
name|processFile
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|keysymToUtf8
name|ushort
name|TableGenerator
operator|::
name|keysymToUtf8
parameter_list|(
name|quint32
name|sym
parameter_list|)
block|{
name|QByteArray
name|chars
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|chars
operator|.
name|resize
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|xkb_keysym_to_utf8
argument_list|(
name|sym
argument_list|,
name|chars
operator|.
name|data
argument_list|()
argument_list|,
name|chars
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
operator|-
literal|1
condition|)
name|qWarning
argument_list|(
literal|"TableGenerator::keysymToUtf8 - buffer too small"
argument_list|)
expr_stmt|;
name|chars
operator|.
name|resize
argument_list|(
name|bytes
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_GENERATOR
name|QTextCodec
modifier|*
name|codec
init|=
name|QTextCodec
operator|::
name|codecForLocale
argument_list|()
decl_stmt|;
name|qDebug
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"keysym - 0x%1 : utf8 - %2"
argument_list|)
operator|.
name|arg
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|sym
argument_list|,
literal|16
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|codec
operator|->
name|toUnicode
argument_list|(
name|chars
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|QString
operator|::
name|fromUtf8
argument_list|(
name|chars
argument_list|)
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|unicode
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|fromBase8
specifier|static
specifier|inline
name|int
name|fromBase8
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
name|s
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|<=
literal|'0'
operator|&&
operator|*
name|s
operator|>=
literal|'7'
condition|)
return|return
literal|0
return|;
name|result
operator|*=
literal|8
expr_stmt|;
name|result
operator|+=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|fromBase16
specifier|static
specifier|inline
name|int
name|fromBase16
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
name|s
operator|!=
name|end
condition|)
block|{
name|result
operator|*=
literal|16
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'9'
condition|)
name|result
operator|+=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|>=
literal|'a'
operator|&&
operator|*
name|s
operator|<=
literal|'f'
condition|)
name|result
operator|+=
operator|*
name|s
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|>=
literal|'A'
operator|&&
operator|*
name|s
operator|<=
literal|'F'
condition|)
name|result
operator|+=
operator|*
name|s
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
return|return
literal|0
return|;
operator|++
name|s
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|parseKeySequence
name|void
name|TableGenerator
operator|::
name|parseKeySequence
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
comment|// we are interested in the lines with the following format:
comment|//<Multi_key><numbersign><S> : "â¬"   U266c # BEAMED SIXTEENTH NOTE
name|char
modifier|*
name|keysEnd
init|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|keysEnd
condition|)
return|return;
name|QComposeTableElement
name|elem
decl_stmt|;
comment|// find the composed value - strings may be direct text encoded in the locale
comment|// for which the compose file is to be used, or an escaped octal or hexadecimal
comment|// character code. Octal codes are specified as "\123" and hexadecimal codes as "\0x123a".
name|char
modifier|*
name|composeValue
init|=
name|strchr
argument_list|(
name|keysEnd
argument_list|,
literal|'"'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|composeValue
condition|)
return|return;
operator|++
name|composeValue
expr_stmt|;
name|char
modifier|*
name|composeValueEnd
init|=
name|strchr
argument_list|(
name|composeValue
argument_list|,
literal|'"'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|composeValueEnd
condition|)
return|return;
comment|// if composed value is a quotation mark adjust the end pointer
if|if
condition|(
name|composeValueEnd
index|[
literal|1
index|]
operator|==
literal|'"'
condition|)
operator|++
name|composeValueEnd
expr_stmt|;
if|if
condition|(
operator|*
name|composeValue
operator|==
literal|'\\'
operator|&&
name|composeValue
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|composeValue
index|[
literal|1
index|]
operator|<=
literal|'9'
condition|)
block|{
comment|// handle octal and hex code values
name|char
name|detectBase
init|=
name|composeValue
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|detectBase
operator|==
literal|'x'
condition|)
block|{
comment|// hexadecimal character code
name|elem
operator|.
name|value
operator|=
name|keysymToUtf8
argument_list|(
name|fromBase16
argument_list|(
name|composeValue
operator|+
literal|3
argument_list|,
name|composeValueEnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// octal character code
name|elem
operator|.
name|value
operator|=
name|keysymToUtf8
argument_list|(
name|fromBase8
argument_list|(
name|composeValue
operator|+
literal|1
argument_list|,
name|composeValueEnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// handle direct text encoded in the locale
if|if
condition|(
operator|*
name|composeValue
operator|==
literal|'\\'
condition|)
operator|++
name|composeValue
expr_stmt|;
name|elem
operator|.
name|value
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|composeValue
argument_list|,
name|composeValueEnd
operator|-
name|composeValue
argument_list|)
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|unicode
argument_list|()
expr_stmt|;
operator|++
name|composeValue
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_GENERATOR
comment|// find the comment
name|elem
operator|.
name|comment
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|composeValueEnd
operator|+
literal|1
argument_list|)
operator|.
name|trimmed
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// find the key sequence and convert to X11 keysym
name|char
modifier|*
name|k
init|=
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|kend
init|=
name|keysEnd
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|QT_KEYSEQUENCE_MAX_LEN
condition|;
name|i
operator|++
control|)
block|{
comment|// find the next pair of angle brackets and get the contents within
while|while
condition|(
name|k
operator|<
name|kend
operator|&&
operator|*
name|k
operator|!=
literal|'<'
condition|)
operator|++
name|k
expr_stmt|;
name|char
modifier|*
name|sym
init|=
operator|++
name|k
decl_stmt|;
while|while
condition|(
name|k
operator|<
name|kend
operator|&&
operator|*
name|k
operator|!=
literal|'>'
condition|)
operator|++
name|k
expr_stmt|;
operator|*
name|k
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|kend
condition|)
block|{
name|elem
operator|.
name|keys
index|[
name|i
index|]
operator|=
name|xkb_keysym_from_name
argument_list|(
name|sym
argument_list|,
operator|(
name|xkb_keysym_flags
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|.
name|keys
index|[
name|i
index|]
operator|==
name|XKB_KEY_NoSymbol
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sym
argument_list|,
literal|"dead_inverted_breve"
argument_list|)
condition|)
name|elem
operator|.
name|keys
index|[
name|i
index|]
operator|=
name|XKB_KEY_dead_invertedbreve
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sym
argument_list|,
literal|"dead_double_grave"
argument_list|)
condition|)
name|elem
operator|.
name|keys
index|[
name|i
index|]
operator|=
name|XKB_KEY_dead_doublegrave
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_GENERATOR
else|else
name|qWarning
argument_list|()
operator|<<
name|QString
argument_list|(
literal|"Qt Warning - invalid keysym: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|sym
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|elem
operator|.
name|keys
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|m_composeTable
operator|.
name|append
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|printComposeTable
name|void
name|TableGenerator
operator|::
name|printComposeTable
parameter_list|()
specifier|const
block|{
ifdef|#
directive|ifdef
name|DEBUG_GENERATOR
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
if|if
condition|(
name|m_composeTable
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QDebug
name|ds
init|=
name|qDebug
argument_list|()
operator|<<
literal|"output:\n"
decl_stmt|;
name|ds
operator|.
name|nospace
argument_list|()
expr_stmt|;
specifier|const
name|int
name|tableSize
init|=
name|m_composeTable
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableSize
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QComposeTableElement
modifier|&
name|elem
init|=
name|m_composeTable
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ds
operator|<<
literal|"{ {"
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|QT_KEYSEQUENCE_MAX_LEN
condition|;
name|j
operator|++
control|)
block|{
name|ds
operator|<<
name|hex
operator|<<
name|showbase
operator|<<
name|elem
operator|.
name|keys
index|[
name|j
index|]
operator|<<
literal|", "
expr_stmt|;
block|}
name|ds
operator|<<
literal|"}, "
operator|<<
name|hex
operator|<<
name|showbase
operator|<<
name|elem
operator|.
name|value
operator|<<
literal|", \"\" }, // "
operator|<<
name|elem
operator|.
name|comment
operator|<<
literal|" \n"
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|orderComposeTable
name|void
name|TableGenerator
operator|::
name|orderComposeTable
parameter_list|()
block|{
comment|// Stable-sorting to ensure that the item that appeared before the other in the
comment|// original container will still appear first after the sort. This property is
comment|// needed to handle the cases when user re-defines already defined key sequence
name|std
operator|::
name|stable_sort
argument_list|(
name|m_composeTable
operator|.
name|begin
argument_list|()
argument_list|,
name|m_composeTable
operator|.
name|end
argument_list|()
argument_list|,
name|Compare
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
