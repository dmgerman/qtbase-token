begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Robin Burchell<robin.burchell@viroteck.net> ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia. For licensing terms and ** conditions see http://qt.digia.com/licensing. For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights. These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtEndian>
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_include
include|#
directive|include
file|<QLoggingCategory>
end_include
begin_include
include|#
directive|include
file|"qoscbundle_p.h"
end_include
begin_include
include|#
directive|include
file|"qtuio_p.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|Q_LOGGING_CATEGORY
argument_list|(
name|lcTuioBundle
argument_list|,
literal|"qt.qpa.tuio.bundle"
argument_list|)
comment|// TUIO packets are transmitted using the OSC protocol, located at:
comment|//   http://opensoundcontrol.org/specification
comment|// Snippets of this specification have been pasted into the source as a means of
comment|// easily communicating requirements.
DECL|function|QOscBundle
name|QOscBundle
operator|::
name|QOscBundle
argument_list|(
specifier|const
name|QByteArray
operator|&
name|data
argument_list|)
range|:
name|m_isValid
argument_list|(
literal|false
argument_list|)
decl_stmt|,
name|m_immediate
argument_list|(
literal|false
argument_list|)
decl_stmt|,
name|m_timeEpoch
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|m_timePico
argument_list|(
literal|0
argument_list|)
argument_list|{
comment|// 8  16 24 32 40 48 56 64
comment|// #  b  u  n  d  l  e  \0
comment|// 23 62 75 6e 64 6c 65 00 // OSC string bundle identifier
comment|// 00 00 00 00 00 00 00 01 // osc time-tag, "immediately"
comment|// 00 00 00 30 // element length
comment|//      => message or bundle(s), preceded by length each time
name|qCDebug
argument_list|(
name|lcTuioBundle
argument_list|)
operator|<<
name|data
operator|.
name|toHex
argument_list|()
argument_list|;
name|quint32
name|parsedBytes
operator|=
literal|0
argument_list|;
comment|// "An OSC Bundle consists of the OSC-string "#bundle""
name|QByteArray
name|identifier
argument_list|;     if
operator|(
operator|!
name|qt_readOscString
argument_list|(
name|data
argument_list|,
name|identifier
argument_list|,
name|parsedBytes
argument_list|)
operator|||
name|identifier
operator|!=
literal|"#bundle"
operator|)
return|return;
end_decl_stmt
begin_comment
comment|// "followed by an OSC Time
end_comment
begin_comment
comment|// Tag, followed by zero or more OSC Bundle Elements. The OSC-timetag is a
end_comment
begin_comment
comment|// 64-bit fixed point time tag whose semantics are described below."
end_comment
begin_if
if|if
condition|(
name|parsedBytes
operator|>
operator|(
name|quint32
operator|)
name|data
operator|.
name|size
argument_list|()
operator|||
name|data
operator|.
name|size
argument_list|()
operator|-
name|parsedBytes
operator|<
sizeof|sizeof
argument_list|(
name|quint64
argument_list|)
condition|)
return|return;
end_if
begin_comment
comment|// "Time tags are represented by a 64 bit fixed point number. The first 32
end_comment
begin_comment
comment|// bits specify the number of seconds since midnight on January 1,  1900,
end_comment
begin_comment
comment|// and the last 32 bits specify fractional parts of a second to a precision
end_comment
begin_comment
comment|// of about 200 picoseconds. This is the representation used by Internet NTP
end_comment
begin_comment
comment|// timestamps."
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// (editor's note: one may wonder how a 64bit big-endian number can also be
end_comment
begin_comment
comment|// two 32bit numbers, without specifying in which order they occur or
end_comment
begin_comment
comment|// anything, and one may indeed continue to wonder.)
end_comment
begin_decl_stmt
name|quint32
name|oscTimeEpoch
init|=
name|qFromBigEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|data
operator|.
name|constData
argument_list|()
operator|+
name|parsedBytes
argument_list|)
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|parsedBytes
operator|+=
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|quint32
name|oscTimePico
init|=
name|qFromBigEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|data
operator|.
name|constData
argument_list|()
operator|+
name|parsedBytes
argument_list|)
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|parsedBytes
operator|+=
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|bool
name|isImmediate
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|oscTimeEpoch
operator|==
literal|0
operator|&&
name|oscTimePico
operator|==
literal|1
condition|)
block|{
comment|// "The time tag value consisting of 63 zero bits followed by a
comment|// one in the least signifigant bit is a special case meaning
comment|// "immediately.""
name|isImmediate
operator|=
literal|true
expr_stmt|;
block|}
end_if
begin_while
while|while
condition|(
name|parsedBytes
operator|<
operator|(
name|quint32
operator|)
name|data
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// "An OSC Bundle Element consists of its size and its contents. The size is an
comment|// int32 representing the number of 8-bit bytes in the contents, and will
comment|// always be a multiple of 4."
comment|//
comment|// in practice, a bundle can contain multiple bundles or messages,
comment|// though, and each is prefixed by a size.
if|if
condition|(
name|data
operator|.
name|size
argument_list|()
operator|-
name|parsedBytes
operator|<
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
condition|)
return|return;
name|quint32
name|size
init|=
name|qFromBigEndian
argument_list|<
name|quint32
argument_list|>
argument_list|(
operator|(
specifier|const
name|uchar
operator|*
operator|)
name|data
operator|.
name|constData
argument_list|()
operator|+
name|parsedBytes
argument_list|)
decl_stmt|;
name|parsedBytes
operator|+=
sizeof|sizeof
argument_list|(
name|quint32
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|size
argument_list|()
operator|-
name|parsedBytes
operator|<
name|size
condition|)
return|return;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|// empty bundle; these are valid, but should they be allowed? the
comment|// spec is unclear on this...
name|qWarning
argument_list|()
operator|<<
literal|"Empty bundle?"
expr_stmt|;
name|m_isValid
operator|=
literal|true
expr_stmt|;
name|m_immediate
operator|=
name|isImmediate
expr_stmt|;
name|m_timeEpoch
operator|=
name|oscTimeEpoch
expr_stmt|;
name|m_timePico
operator|=
name|oscTimePico
expr_stmt|;
return|return;
block|}
comment|// "The contents are either an OSC Message or an OSC Bundle.
comment|// Note this recursive definition: bundle may contain bundles."
name|QByteArray
name|subdata
init|=
name|data
operator|.
name|mid
argument_list|(
name|parsedBytes
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|parsedBytes
operator|+=
name|size
expr_stmt|;
comment|// "The contents of an OSC packet must be either an OSC Message or an OSC Bundle.
comment|// The first byte of the packet's contents unambiguously distinguishes between
comment|// these two alternatives."
comment|//
comment|// we're not dealing with a packet here, but the same trick works just
comment|// the same.
name|QByteArray
name|bundleIdentifier
init|=
name|QByteArray
argument_list|(
literal|"#bundle\0"
argument_list|,
literal|8
argument_list|)
decl_stmt|;
if|if
condition|(
name|subdata
operator|.
name|startsWith
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
comment|// starts with / => address pattern => start of a message
name|QOscMessage
name|subMessage
parameter_list|(
name|subdata
parameter_list|)
function_decl|;
if|if
condition|(
name|subMessage
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|m_isValid
operator|=
literal|true
expr_stmt|;
name|m_immediate
operator|=
name|isImmediate
expr_stmt|;
name|m_timeEpoch
operator|=
name|oscTimeEpoch
expr_stmt|;
name|m_timePico
operator|=
name|oscTimePico
expr_stmt|;
name|m_messages
operator|.
name|append
argument_list|(
name|subMessage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Invalid sub-message"
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|subdata
operator|.
name|startsWith
argument_list|(
name|bundleIdentifier
argument_list|)
condition|)
block|{
comment|// bundle identifier start => bundle
name|QOscBundle
name|subBundle
parameter_list|(
name|subdata
parameter_list|)
function_decl|;
if|if
condition|(
name|subBundle
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|m_isValid
operator|=
literal|true
expr_stmt|;
name|m_immediate
operator|=
name|isImmediate
expr_stmt|;
name|m_timeEpoch
operator|=
name|oscTimeEpoch
expr_stmt|;
name|m_timePico
operator|=
name|oscTimePico
expr_stmt|;
name|m_bundles
operator|.
name|append
argument_list|(
name|subBundle
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Malformed sub-data!"
expr_stmt|;
return|return;
block|}
block|}
end_while
begin_macro
unit|}   bool
DECL|function|isValid
name|QOscBundle
end_macro
begin_expr_stmt
DECL|function|isValid
operator|::
name|isValid
operator|(
operator|)
specifier|const
block|{
return|return
name|m_isValid
return|;
block|}
end_expr_stmt
begin_function
DECL|function|bundles
name|QList
argument_list|<
name|QOscBundle
argument_list|>
name|QOscBundle
operator|::
name|bundles
parameter_list|()
specifier|const
block|{
return|return
name|m_bundles
return|;
block|}
end_function
begin_function
DECL|function|messages
name|QList
argument_list|<
name|QOscMessage
argument_list|>
name|QOscBundle
operator|::
name|messages
parameter_list|()
specifier|const
block|{
return|return
name|m_messages
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
