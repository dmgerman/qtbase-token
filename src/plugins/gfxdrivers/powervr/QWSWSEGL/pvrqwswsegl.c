begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<GLES/eglplatform.h>
end_include
begin_include
include|#
directive|include
file|<wsegl.h>
end_include
begin_include
include|#
directive|include
file|<pvr2d.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<sys/mman.h>
end_include
begin_include
include|#
directive|include
file|"pvrqwsdrawable_p.h"
end_include
begin_define
DECL|macro|WSEGL_UNUSED
define|#
directive|define
name|WSEGL_UNUSED
parameter_list|(
name|x
parameter_list|)
value|(void)x;
end_define
begin_comment
comment|// If the PVR2D version is not specified, then assume MBX-style headers.
end_comment
begin_comment
comment|// If the version is defined, then we assume that we have SGX-style headers.
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PVR2D_REV_MAJOR
argument_list|)
end_if
begin_define
DECL|macro|WSEGL_CAP_WINDOWS_USE_HW_SYNC
define|#
directive|define
name|WSEGL_CAP_WINDOWS_USE_HW_SYNC
value|WSEGL_CAP_WINDOWS_USE_MBX_SYNC
end_define
begin_define
DECL|macro|WSEGL_CAP_PIXMAPS_USE_HW_SYNC
define|#
directive|define
name|WSEGL_CAP_PIXMAPS_USE_HW_SYNC
value|WSEGL_CAP_PIXMAPS_USE_MBX_SYNC
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Capability information for the display */
end_comment
begin_decl_stmt
DECL|variable|wseglDisplayCaps
specifier|static
name|WSEGLCaps
specifier|const
name|wseglDisplayCaps
index|[]
init|=
block|{
block|{
name|WSEGL_CAP_WINDOWS_USE_HW_SYNC
block|,
literal|1
block|}
block|,
block|{
name|WSEGL_CAP_PIXMAPS_USE_HW_SYNC
block|,
literal|1
block|}
block|,
block|{
name|WSEGL_NO_CAPS
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Configuration information for the display */
end_comment
begin_decl_stmt
DECL|variable|wseglDisplayConfigs
specifier|static
name|WSEGLConfig
name|wseglDisplayConfigs
index|[]
init|=
block|{
block|{
name|WSEGL_DRAWABLE_WINDOW
block|,
name|WSEGL_PIXELFORMAT_565
block|,
name|WSEGL_FALSE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|WSEGL_OPAQUE
block|,
literal|0
block|}
block|,
block|{
name|WSEGL_DRAWABLE_PIXMAP
block|,
name|WSEGL_PIXELFORMAT_565
block|,
name|WSEGL_FALSE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|WSEGL_OPAQUE
block|,
literal|0
block|}
block|,
block|{
name|WSEGL_NO_DRAWABLE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Determine if nativeDisplay is a valid display handle */
end_comment
begin_function
DECL|function|wseglIsDisplayValid
specifier|static
name|WSEGLError
name|wseglIsDisplayValid
parameter_list|(
name|NativeDisplayType
name|nativeDisplay
parameter_list|)
block|{
comment|/* We only have the default display in this system */
if|if
condition|(
name|nativeDisplay
operator|==
name|WSEGL_DEFAULT_DISPLAY
condition|)
return|return
name|WSEGL_SUCCESS
return|;
else|else
return|return
name|WSEGL_BAD_NATIVE_DISPLAY
return|;
block|}
end_function
begin_comment
comment|/* Initialize a native display for use with WSEGL */
end_comment
begin_function
DECL|function|wseglInitializeDisplay
specifier|static
name|WSEGLError
name|wseglInitializeDisplay
parameter_list|(
name|NativeDisplayType
name|nativeDisplay
parameter_list|,
name|WSEGLDisplayHandle
modifier|*
name|display
parameter_list|,
specifier|const
name|WSEGLCaps
modifier|*
modifier|*
name|caps
parameter_list|,
name|WSEGLConfig
modifier|*
modifier|*
name|configs
parameter_list|)
block|{
name|WSEGLPixelFormat
name|pixelFormat
decl_stmt|;
comment|/* Bail out if the native display is incorrect */
if|if
condition|(
name|nativeDisplay
operator|!=
name|WSEGL_DEFAULT_DISPLAY
condition|)
return|return
name|WSEGL_CANNOT_INITIALISE
return|;
comment|/* Open the PVR/QWS display, which will initialize the framebuffer */
if|if
condition|(
operator|!
name|pvrQwsDisplayOpen
argument_list|()
condition|)
return|return
name|WSEGL_CANNOT_INITIALISE
return|;
comment|/* Convert the PVR2D pixel format into a WSEGL pixel format */
switch|switch
condition|(
name|pvrQwsDisplay
operator|.
name|screens
index|[
literal|0
index|]
operator|.
name|pixelFormat
condition|)
block|{
case|case
name|PVR2D_RGB565
case|:
name|pixelFormat
operator|=
name|WSEGL_PIXELFORMAT_565
expr_stmt|;
break|break;
case|case
name|PVR2D_ARGB4444
case|:
name|pixelFormat
operator|=
name|WSEGL_PIXELFORMAT_4444
expr_stmt|;
break|break;
case|case
name|PVR2D_ARGB8888
case|:
name|pixelFormat
operator|=
name|WSEGL_PIXELFORMAT_8888
expr_stmt|;
break|break;
default|default:
name|pvrQwsDisplayClose
argument_list|()
expr_stmt|;
return|return
name|WSEGL_CANNOT_INITIALISE
return|;
block|}
name|wseglDisplayConfigs
index|[
literal|0
index|]
operator|.
name|ePixelFormat
operator|=
name|pixelFormat
expr_stmt|;
name|wseglDisplayConfigs
index|[
literal|1
index|]
operator|.
name|ePixelFormat
operator|=
name|pixelFormat
expr_stmt|;
comment|/* The display has been initialized */
operator|*
name|display
operator|=
operator|(
name|WSEGLDisplayHandle
operator|)
operator|&
name|pvrQwsDisplay
expr_stmt|;
operator|*
name|caps
operator|=
name|wseglDisplayCaps
expr_stmt|;
operator|*
name|configs
operator|=
name|wseglDisplayConfigs
expr_stmt|;
return|return
name|WSEGL_SUCCESS
return|;
block|}
end_function
begin_comment
comment|/* Close the WSEGL display */
end_comment
begin_function
DECL|function|wseglCloseDisplay
specifier|static
name|WSEGLError
name|wseglCloseDisplay
parameter_list|(
name|WSEGLDisplayHandle
name|display
parameter_list|)
block|{
if|if
condition|(
name|display
operator|==
operator|(
name|WSEGLDisplayHandle
operator|)
operator|&
name|pvrQwsDisplay
condition|)
name|pvrQwsDisplayClose
argument_list|()
expr_stmt|;
return|return
name|WSEGL_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|wseglRotationValue
specifier|static
name|WSEGLRotationAngle
name|wseglRotationValue
parameter_list|(
name|int
name|degrees
parameter_list|)
block|{
switch|switch
condition|(
name|degrees
condition|)
block|{
case|case
literal|90
case|:
return|return
name|WSEGL_ROTATE_90
return|;
case|case
literal|180
case|:
return|return
name|WSEGL_ROTATE_180
return|;
case|case
literal|270
case|:
return|return
name|WSEGL_ROTATE_270
return|;
default|default:
return|return
name|WSEGL_ROTATE_0
return|;
block|}
block|}
end_function
begin_comment
comment|/* Create the WSEGL drawable version of a native window */
end_comment
begin_function
DECL|function|wseglCreateWindowDrawable
specifier|static
name|WSEGLError
name|wseglCreateWindowDrawable
parameter_list|(
name|WSEGLDisplayHandle
name|display
parameter_list|,
name|WSEGLConfig
modifier|*
name|config
parameter_list|,
name|WSEGLDrawableHandle
modifier|*
name|drawable
parameter_list|,
name|NativeWindowType
name|nativeWindow
parameter_list|,
name|WSEGLRotationAngle
modifier|*
name|rotationAngle
parameter_list|)
block|{
name|PvrQwsDrawable
modifier|*
name|draw
decl_stmt|;
name|WSEGL_UNUSED
argument_list|(
name|display
argument_list|)
expr_stmt|;
name|WSEGL_UNUSED
argument_list|(
name|config
argument_list|)
expr_stmt|;
comment|/* Check for special handles that indicate framebuffer screens */
if|if
condition|(
name|nativeWindow
operator|>=
operator|(
name|NativeWindowType
operator|)
literal|0
operator|&&
name|nativeWindow
operator|<
operator|(
name|NativeWindowType
operator|)
name|PVRQWS_MAX_SCREENS
condition|)
block|{
name|PvrQwsDrawable
modifier|*
name|screen
init|=
name|pvrQwsScreenWindow
argument_list|(
operator|(
name|int
operator|)
name|nativeWindow
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|screen
condition|)
return|return
name|WSEGL_OUT_OF_MEMORY
return|;
operator|*
name|drawable
operator|=
operator|(
name|WSEGLDrawableHandle
operator|)
name|screen
expr_stmt|;
if|if
condition|(
operator|!
name|pvrQwsAllocBuffers
argument_list|(
name|screen
argument_list|)
condition|)
return|return
name|WSEGL_OUT_OF_MEMORY
return|;
operator|*
name|rotationAngle
operator|=
name|wseglRotationValue
argument_list|(
name|screen
operator|->
name|rotationAngle
argument_list|)
expr_stmt|;
return|return
name|WSEGL_SUCCESS
return|;
block|}
comment|/* The native window is the winId - fetch the underlying drawable */
name|draw
operator|=
name|pvrQwsFetchWindow
argument_list|(
operator|(
name|long
operator|)
name|nativeWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|draw
condition|)
return|return
name|WSEGL_BAD_DRAWABLE
return|;
comment|/* The drawable is ready to go */
operator|*
name|drawable
operator|=
operator|(
name|WSEGLDrawableHandle
operator|)
name|draw
expr_stmt|;
operator|*
name|rotationAngle
operator|=
name|wseglRotationValue
argument_list|(
name|draw
operator|->
name|rotationAngle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pvrQwsAllocBuffers
argument_list|(
name|draw
argument_list|)
condition|)
return|return
name|WSEGL_OUT_OF_MEMORY
return|;
return|return
name|WSEGL_SUCCESS
return|;
block|}
end_function
begin_comment
comment|/* Create the WSEGL drawable version of a native pixmap */
end_comment
begin_function
DECL|function|wseglCreatePixmapDrawable
specifier|static
name|WSEGLError
name|wseglCreatePixmapDrawable
parameter_list|(
name|WSEGLDisplayHandle
name|display
parameter_list|,
name|WSEGLConfig
modifier|*
name|config
parameter_list|,
name|WSEGLDrawableHandle
modifier|*
name|drawable
parameter_list|,
name|NativePixmapType
name|nativePixmap
parameter_list|,
name|WSEGLRotationAngle
modifier|*
name|rotationAngle
parameter_list|)
block|{
name|WSEGL_UNUSED
argument_list|(
name|display
argument_list|)
expr_stmt|;
name|WSEGL_UNUSED
argument_list|(
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nativePixmap
condition|)
return|return
name|WSEGL_BAD_NATIVE_PIXMAP
return|;
if|if
condition|(
operator|!
name|pvrQwsAllocBuffers
argument_list|(
operator|(
name|PvrQwsDrawable
operator|*
operator|)
name|nativePixmap
argument_list|)
condition|)
return|return
name|WSEGL_OUT_OF_MEMORY
return|;
operator|*
name|drawable
operator|=
operator|(
name|WSEGLDrawableHandle
operator|)
name|nativePixmap
expr_stmt|;
operator|*
name|rotationAngle
operator|=
name|WSEGL_ROTATE_0
expr_stmt|;
return|return
name|WSEGL_SUCCESS
return|;
block|}
end_function
begin_comment
comment|/* Delete a specific drawable */
end_comment
begin_function
DECL|function|wseglDeleteDrawable
specifier|static
name|WSEGLError
name|wseglDeleteDrawable
parameter_list|(
name|WSEGLDrawableHandle
name|_drawable
parameter_list|)
block|{
name|PvrQwsDrawable
modifier|*
name|drawable
init|=
operator|(
name|PvrQwsDrawable
operator|*
operator|)
name|_drawable
decl_stmt|;
if|if
condition|(
operator|!
name|drawable
operator|||
name|drawable
operator|->
name|type
operator|==
name|PvrQwsScreen
condition|)
return|return
name|WSEGL_SUCCESS
return|;
if|if
condition|(
name|pvrQwsDisplay
operator|.
name|numFlipBuffers
operator|==
literal|0
condition|)
name|pvrQwsFreeBuffers
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvrQwsReleaseWindow
argument_list|(
name|drawable
argument_list|)
condition|)
name|pvrQwsDestroyDrawable
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
return|return
name|WSEGL_SUCCESS
return|;
block|}
end_function
begin_comment
comment|/* Swap the contents of a drawable to the screen */
end_comment
begin_function
DECL|function|wseglSwapDrawable
specifier|static
name|WSEGLError
name|wseglSwapDrawable
parameter_list|(
name|WSEGLDrawableHandle
name|_drawable
parameter_list|,
name|unsigned
name|long
name|data
parameter_list|)
block|{
name|WSEGL_UNUSED
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|PvrQwsDrawable
modifier|*
name|drawable
init|=
operator|(
name|PvrQwsDrawable
operator|*
operator|)
name|_drawable
decl_stmt|;
if|if
condition|(
name|drawable
operator|->
name|type
operator|!=
name|PvrQwsPixmap
operator|&&
operator|!
name|pvrQwsSwapBuffers
argument_list|(
name|drawable
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|WSEGL_BAD_DRAWABLE
return|;
else|else
return|return
name|WSEGL_SUCCESS
return|;
block|}
end_function
begin_comment
comment|/* Set the swap interval of a window drawable */
end_comment
begin_function
DECL|function|wseglSwapControlInterval
specifier|static
name|WSEGLError
name|wseglSwapControlInterval
parameter_list|(
name|WSEGLDrawableHandle
name|drawable
parameter_list|,
name|unsigned
name|long
name|interval
parameter_list|)
block|{
name|WSEGL_UNUSED
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvrQwsDisplay
operator|.
name|flipChain
condition|)
block|{
name|PVR2DSetPresentFlipProperties
argument_list|(
name|pvrQwsDisplay
operator|.
name|context
argument_list|,
name|pvrQwsDisplay
operator|.
name|flipChain
argument_list|,
name|PVR2D_PRESENT_PROPERTY_INTERVAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|interval
argument_list|)
expr_stmt|;
block|}
return|return
name|WSEGL_SUCCESS
return|;
block|}
end_function
begin_comment
comment|/* Flush native rendering requests on a drawable */
end_comment
begin_function
DECL|function|wseglWaitNative
specifier|static
name|WSEGLError
name|wseglWaitNative
parameter_list|(
name|WSEGLDrawableHandle
name|drawable
parameter_list|,
name|unsigned
name|long
name|engine
parameter_list|)
block|{
name|WSEGL_UNUSED
argument_list|(
name|drawable
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|==
name|WSEGL_DEFAULT_NATIVE_ENGINE
condition|)
return|return
name|WSEGL_SUCCESS
return|;
else|else
return|return
name|WSEGL_BAD_NATIVE_ENGINE
return|;
block|}
end_function
begin_comment
comment|/* Copy color data from a drawable to a native pixmap */
end_comment
begin_function
DECL|function|wseglCopyFromDrawable
specifier|static
name|WSEGLError
name|wseglCopyFromDrawable
parameter_list|(
name|WSEGLDrawableHandle
name|_drawable
parameter_list|,
name|NativePixmapType
name|nativePixmap
parameter_list|)
block|{
name|PvrQwsDrawable
modifier|*
name|drawable
init|=
operator|(
name|PvrQwsDrawable
operator|*
operator|)
name|_drawable
decl_stmt|;
name|PvrQwsDrawable
modifier|*
name|pixmap
init|=
operator|(
name|PvrQwsDrawable
operator|*
operator|)
name|nativePixmap
decl_stmt|;
name|PVR2DBLTINFO
name|blit
decl_stmt|;
if|if
condition|(
operator|!
name|drawable
operator|||
operator|!
name|drawable
operator|->
name|backBuffersValid
condition|)
return|return
name|WSEGL_BAD_NATIVE_WINDOW
return|;
if|if
condition|(
operator|!
name|pixmap
operator|||
operator|!
name|pixmap
operator|->
name|backBuffersValid
condition|)
return|return
name|WSEGL_BAD_NATIVE_PIXMAP
return|;
name|memset
argument_list|(
operator|&
name|blit
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|blit
argument_list|)
argument_list|)
expr_stmt|;
name|blit
operator|.
name|CopyCode
operator|=
name|PVR2DROPcopy
expr_stmt|;
name|blit
operator|.
name|BlitFlags
operator|=
name|PVR2D_BLIT_DISABLE_ALL
expr_stmt|;
name|blit
operator|.
name|pSrcMemInfo
operator|=
name|drawable
operator|->
name|backBuffers
index|[
name|drawable
operator|->
name|currentBackBuffer
index|]
expr_stmt|;
name|blit
operator|.
name|SrcStride
operator|=
name|drawable
operator|->
name|strideBytes
expr_stmt|;
name|blit
operator|.
name|SrcX
operator|=
literal|0
expr_stmt|;
name|blit
operator|.
name|SrcY
operator|=
literal|0
expr_stmt|;
name|blit
operator|.
name|SizeX
operator|=
name|drawable
operator|->
name|rect
operator|.
name|width
expr_stmt|;
name|blit
operator|.
name|SizeY
operator|=
name|drawable
operator|->
name|rect
operator|.
name|height
expr_stmt|;
name|blit
operator|.
name|SrcFormat
operator|=
name|drawable
operator|->
name|pixelFormat
expr_stmt|;
name|blit
operator|.
name|pDstMemInfo
operator|=
name|pixmap
operator|->
name|backBuffers
index|[
name|pixmap
operator|->
name|currentBackBuffer
index|]
expr_stmt|;
name|blit
operator|.
name|DstStride
operator|=
name|pixmap
operator|->
name|strideBytes
expr_stmt|;
name|blit
operator|.
name|DstX
operator|=
literal|0
expr_stmt|;
name|blit
operator|.
name|DstY
operator|=
literal|0
expr_stmt|;
name|blit
operator|.
name|DSizeX
operator|=
name|pixmap
operator|->
name|rect
operator|.
name|width
expr_stmt|;
name|blit
operator|.
name|DSizeY
operator|=
name|pixmap
operator|->
name|rect
operator|.
name|height
expr_stmt|;
name|blit
operator|.
name|DstFormat
operator|=
name|pixmap
operator|->
name|pixelFormat
expr_stmt|;
name|PVR2DBlt
argument_list|(
name|pvrQwsDisplay
operator|.
name|context
argument_list|,
operator|&
name|blit
argument_list|)
expr_stmt|;
name|PVR2DQueryBlitsComplete
argument_list|(
name|pvrQwsDisplay
operator|.
name|context
argument_list|,
name|pixmap
operator|->
name|backBuffers
index|[
name|pixmap
operator|->
name|currentBackBuffer
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|WSEGL_SUCCESS
return|;
block|}
end_function
begin_comment
comment|/* Copy color data from a PBuffer to a native pixmap */
end_comment
begin_function
DECL|function|wseglCopyFromPBuffer
specifier|static
name|WSEGLError
name|wseglCopyFromPBuffer
parameter_list|(
name|void
modifier|*
name|address
parameter_list|,
name|unsigned
name|long
name|width
parameter_list|,
name|unsigned
name|long
name|height
parameter_list|,
name|unsigned
name|long
name|stride
parameter_list|,
name|WSEGLPixelFormat
name|format
parameter_list|,
name|NativePixmapType
name|nativePixmap
parameter_list|)
block|{
name|PvrQwsDrawable
modifier|*
name|pixmap
init|=
operator|(
name|PvrQwsDrawable
operator|*
operator|)
name|nativePixmap
decl_stmt|;
name|PVR2DFORMAT
name|pixelFormat
decl_stmt|;
if|if
condition|(
operator|!
name|pixmap
condition|)
return|return
name|WSEGL_BAD_NATIVE_PIXMAP
return|;
comment|/* We can only copy under certain conditions */
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|WSEGL_PIXELFORMAT_565
case|:
name|pixelFormat
operator|=
name|PVR2D_RGB565
expr_stmt|;
break|break;
case|case
name|WSEGL_PIXELFORMAT_4444
case|:
name|pixelFormat
operator|=
name|PVR2D_ARGB4444
expr_stmt|;
break|break;
case|case
name|WSEGL_PIXELFORMAT_8888
case|:
name|pixelFormat
operator|=
name|PVR2D_ARGB8888
expr_stmt|;
break|break;
default|default:
return|return
name|WSEGL_BAD_CONFIG
return|;
block|}
if|if
condition|(
name|width
operator|>
call|(
name|unsigned
name|long
call|)
argument_list|(
name|pixmap
operator|->
name|rect
operator|.
name|width
argument_list|)
operator|||
name|height
operator|>
call|(
name|unsigned
name|long
call|)
argument_list|(
name|pixmap
operator|->
name|rect
operator|.
name|height
argument_list|)
operator|||
name|pixelFormat
operator|!=
name|pixmap
operator|->
name|pixelFormat
condition|)
block|{
return|return
name|WSEGL_BAD_CONFIG
return|;
block|}
comment|/* We'd like to use PVR2DBlt to do this, but there is no easy way        to map the virtual "address" into physical space to be able        to use the hardware assist.  Use memcpy to do the work instead.        Note: PBuffer's are upside down, so we copy from the bottom up */
name|char
modifier|*
name|srcaddr
init|=
operator|(
name|char
operator|*
operator|)
name|address
decl_stmt|;
name|char
modifier|*
name|dstaddr
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|pixmap
operator|->
name|backBuffers
index|[
name|pixmap
operator|->
name|currentBackBuffer
index|]
operator|->
name|pBase
operator|)
decl_stmt|;
name|int
name|dststride
init|=
name|pixmap
operator|->
name|strideBytes
decl_stmt|;
name|int
name|srcwidth
init|=
operator|(
operator|(
name|int
operator|)
name|width
operator|)
operator|*
name|pvrQwsDisplay
operator|.
name|screens
index|[
literal|0
index|]
operator|.
name|bytesPerPixel
decl_stmt|;
name|srcaddr
operator|+=
name|height
operator|*
name|stride
expr_stmt|;
while|while
condition|(
name|height
operator|>
literal|0
condition|)
block|{
name|srcaddr
operator|-=
operator|(
name|int
operator|)
name|stride
expr_stmt|;
name|memcpy
argument_list|(
name|dstaddr
argument_list|,
name|srcaddr
argument_list|,
name|srcwidth
argument_list|)
expr_stmt|;
name|dstaddr
operator|+=
name|dststride
expr_stmt|;
operator|--
name|height
expr_stmt|;
block|}
return|return
name|WSEGL_SUCCESS
return|;
block|}
end_function
begin_comment
comment|/* Return the parameters of a drawable that are needed by the EGL layer */
end_comment
begin_function
DECL|function|wseglGetDrawableParameters
specifier|static
name|WSEGLError
name|wseglGetDrawableParameters
parameter_list|(
name|WSEGLDrawableHandle
name|_drawable
parameter_list|,
name|WSEGLDrawableParams
modifier|*
name|sourceParams
parameter_list|,
name|WSEGLDrawableParams
modifier|*
name|renderParams
parameter_list|)
block|{
name|PvrQwsDrawable
modifier|*
name|drawable
init|=
operator|(
name|PvrQwsDrawable
operator|*
operator|)
name|_drawable
decl_stmt|;
name|PVR2DMEMINFO
modifier|*
name|source
decl_stmt|,
modifier|*
name|render
decl_stmt|;
name|WSEGLPixelFormat
name|pixelFormat
decl_stmt|;
if|if
condition|(
operator|!
name|pvrQwsGetBuffers
argument_list|(
name|drawable
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|render
argument_list|)
condition|)
return|return
name|WSEGL_BAD_DRAWABLE
return|;
switch|switch
condition|(
name|drawable
operator|->
name|pixelFormat
condition|)
block|{
case|case
name|PVR2D_RGB565
case|:
default|default:
name|pixelFormat
operator|=
name|WSEGL_PIXELFORMAT_565
expr_stmt|;
break|break;
case|case
name|PVR2D_ARGB4444
case|:
name|pixelFormat
operator|=
name|WSEGL_PIXELFORMAT_4444
expr_stmt|;
break|break;
case|case
name|PVR2D_ARGB8888
case|:
name|pixelFormat
operator|=
name|WSEGL_PIXELFORMAT_8888
expr_stmt|;
break|break;
block|}
name|sourceParams
operator|->
name|ui32Width
operator|=
name|drawable
operator|->
name|rect
operator|.
name|width
expr_stmt|;
name|sourceParams
operator|->
name|ui32Height
operator|=
name|drawable
operator|->
name|rect
operator|.
name|height
expr_stmt|;
name|sourceParams
operator|->
name|ui32Stride
operator|=
name|drawable
operator|->
name|stridePixels
expr_stmt|;
name|sourceParams
operator|->
name|ePixelFormat
operator|=
name|pixelFormat
expr_stmt|;
name|sourceParams
operator|->
name|pvLinearAddress
operator|=
name|source
operator|->
name|pBase
expr_stmt|;
name|sourceParams
operator|->
name|ui32HWAddress
operator|=
name|source
operator|->
name|ui32DevAddr
expr_stmt|;
name|sourceParams
operator|->
name|hPrivateData
operator|=
name|source
operator|->
name|hPrivateData
expr_stmt|;
name|renderParams
operator|->
name|ui32Width
operator|=
name|drawable
operator|->
name|rect
operator|.
name|width
expr_stmt|;
name|renderParams
operator|->
name|ui32Height
operator|=
name|drawable
operator|->
name|rect
operator|.
name|height
expr_stmt|;
name|renderParams
operator|->
name|ui32Stride
operator|=
name|drawable
operator|->
name|stridePixels
expr_stmt|;
name|renderParams
operator|->
name|ePixelFormat
operator|=
name|pixelFormat
expr_stmt|;
name|renderParams
operator|->
name|pvLinearAddress
operator|=
name|render
operator|->
name|pBase
expr_stmt|;
name|renderParams
operator|->
name|ui32HWAddress
operator|=
name|render
operator|->
name|ui32DevAddr
expr_stmt|;
name|renderParams
operator|->
name|hPrivateData
operator|=
name|render
operator|->
name|hPrivateData
expr_stmt|;
return|return
name|WSEGL_SUCCESS
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|wseglFunctions
specifier|static
name|WSEGL_FunctionTable
specifier|const
name|wseglFunctions
init|=
block|{
name|WSEGL_VERSION
block|,
name|wseglIsDisplayValid
block|,
name|wseglInitializeDisplay
block|,
name|wseglCloseDisplay
block|,
name|wseglCreateWindowDrawable
block|,
name|wseglCreatePixmapDrawable
block|,
name|wseglDeleteDrawable
block|,
name|wseglSwapDrawable
block|,
name|wseglSwapControlInterval
block|,
name|wseglWaitNative
block|,
name|wseglCopyFromDrawable
block|,
name|wseglCopyFromPBuffer
block|,
name|wseglGetDrawableParameters
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Return the table of WSEGL functions to the EGL implementation */
end_comment
begin_function
DECL|function|WSEGL_GetFunctionTablePointer
specifier|const
name|WSEGL_FunctionTable
modifier|*
name|WSEGL_GetFunctionTablePointer
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|wseglFunctions
return|;
block|}
end_function
end_unit
