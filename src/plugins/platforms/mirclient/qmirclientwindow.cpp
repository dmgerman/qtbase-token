begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014-2015 Canonical, Ltd. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|// Local
end_comment
begin_include
include|#
directive|include
file|"qmirclientwindow.h"
end_include
begin_include
include|#
directive|include
file|"qmirclientclipboard.h"
end_include
begin_include
include|#
directive|include
file|"qmirclientinput.h"
end_include
begin_include
include|#
directive|include
file|"qmirclientscreen.h"
end_include
begin_include
include|#
directive|include
file|"qmirclientlogging.h"
end_include
begin_include
include|#
directive|include
file|<mir_toolkit/mir_client_library.h>
end_include
begin_comment
comment|// Qt
end_comment
begin_include
include|#
directive|include
file|<qpa/qwindowsysteminterface.h>
end_include
begin_include
include|#
directive|include
file|<QMutexLocker>
end_include
begin_include
include|#
directive|include
file|<QSize>
end_include
begin_include
include|#
directive|include
file|<QtMath>
end_include
begin_comment
comment|// Platform API
end_comment
begin_include
include|#
directive|include
file|<ubuntu/application/instance.h>
end_include
begin_include
include|#
directive|include
file|<EGL/egl.h>
end_include
begin_namespace
namespace|namespace
block|{
comment|// FIXME: this used to be defined by platform-api, but it's been removed in v3. Change ubuntu-keyboard to use
comment|// a different enum for window roles.
DECL|enum|UAUiWindowRole
enum|enum
name|UAUiWindowRole
block|{
DECL|enumerator|U_MAIN_ROLE
name|U_MAIN_ROLE
init|=
literal|1
block|,
DECL|enumerator|U_DASH_ROLE
name|U_DASH_ROLE
block|,
DECL|enumerator|U_INDICATOR_ROLE
name|U_INDICATOR_ROLE
block|,
DECL|enumerator|U_NOTIFICATIONS_ROLE
name|U_NOTIFICATIONS_ROLE
block|,
DECL|enumerator|U_GREETER_ROLE
name|U_GREETER_ROLE
block|,
DECL|enumerator|U_LAUNCHER_ROLE
name|U_LAUNCHER_ROLE
block|,
DECL|enumerator|U_ON_SCREEN_KEYBOARD_ROLE
name|U_ON_SCREEN_KEYBOARD_ROLE
block|,
DECL|enumerator|U_SHUTDOWN_DIALOG_ROLE
name|U_SHUTDOWN_DIALOG_ROLE
block|, }
enum|;
DECL|struct|MirSpecDeleter
struct|struct
name|MirSpecDeleter
block|{
DECL|function|operator ()
name|void
name|operator
name|()
parameter_list|(
name|MirSurfaceSpec
modifier|*
name|spec
parameter_list|)
block|{
name|mir_surface_spec_release
argument_list|(
name|spec
argument_list|)
expr_stmt|;
block|}
block|}
struct|;
using|using
name|Spec
init|=
name|std
operator|::
name|unique_ptr
argument_list|<
name|MirSurfaceSpec
argument_list|,
name|MirSpecDeleter
argument_list|>
using|;
DECL|function|nativeWindowFor
name|EGLNativeWindowType
name|nativeWindowFor
parameter_list|(
name|MirSurface
modifier|*
name|surf
parameter_list|)
block|{
name|auto
name|stream
init|=
name|mir_surface_get_buffer_stream
argument_list|(
name|surf
argument_list|)
decl_stmt|;
return|return
cast|reinterpret_cast
argument_list|<
name|EGLNativeWindowType
argument_list|>
argument_list|(
name|mir_buffer_stream_get_egl_native_window
argument_list|(
name|stream
argument_list|)
argument_list|)
return|;
block|}
DECL|function|qtWindowStateToMirSurfaceState
name|MirSurfaceState
name|qtWindowStateToMirSurfaceState
parameter_list|(
name|Qt
operator|::
name|WindowState
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Qt
operator|::
name|WindowNoState
case|:
return|return
name|mir_surface_state_restored
return|;
case|case
name|Qt
operator|::
name|WindowFullScreen
case|:
return|return
name|mir_surface_state_fullscreen
return|;
case|case
name|Qt
operator|::
name|WindowMaximized
case|:
return|return
name|mir_surface_state_maximized
return|;
case|case
name|Qt
operator|::
name|WindowMinimized
case|:
return|return
name|mir_surface_state_minimized
return|;
default|default:
name|LOG
argument_list|(
literal|"Unexpected Qt::WindowState: %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
name|mir_surface_state_restored
return|;
block|}
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
DECL|function|qtWindowStateToStr
specifier|const
name|char
modifier|*
name|qtWindowStateToStr
parameter_list|(
name|Qt
operator|::
name|WindowState
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Qt
operator|::
name|WindowNoState
case|:
return|return
literal|"NoState"
return|;
case|case
name|Qt
operator|::
name|WindowFullScreen
case|:
return|return
literal|"FullScreen"
return|;
case|case
name|Qt
operator|::
name|WindowMaximized
case|:
return|return
literal|"Maximized"
return|;
case|case
name|Qt
operator|::
name|WindowMinimized
case|:
return|return
literal|"Minimized"
return|;
default|default:
return|return
literal|"!?"
return|;
block|}
block|}
endif|#
directive|endif
DECL|function|makeId
name|WId
name|makeId
parameter_list|()
block|{
specifier|static
name|int
name|id
init|=
literal|1
decl_stmt|;
return|return
name|id
operator|++
return|;
block|}
DECL|function|defaultPixelFormatFor
name|MirPixelFormat
name|defaultPixelFormatFor
parameter_list|(
name|MirConnection
modifier|*
name|connection
parameter_list|)
block|{
name|MirPixelFormat
name|format
decl_stmt|;
name|unsigned
name|int
name|nformats
decl_stmt|;
name|mir_connection_get_available_surface_formats
argument_list|(
name|connection
argument_list|,
operator|&
name|format
argument_list|,
literal|1
argument_list|,
operator|&
name|nformats
argument_list|)
expr_stmt|;
return|return
name|format
return|;
block|}
DECL|function|roleFor
name|UAUiWindowRole
name|roleFor
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|)
block|{
name|QVariant
name|roleVariant
init|=
name|window
operator|->
name|property
argument_list|(
literal|"role"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|roleVariant
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|U_MAIN_ROLE
return|;
name|uint
name|role
init|=
name|roleVariant
operator|.
name|toUInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|role
argument_list|<
name|U_MAIN_ROLE
operator|||
name|role
argument_list|>
name|U_SHUTDOWN_DIALOG_ROLE
condition|)
return|return
name|U_MAIN_ROLE
return|;
return|return
cast|static_cast
argument_list|<
name|UAUiWindowRole
argument_list|>
argument_list|(
name|role
argument_list|)
return|;
block|}
DECL|function|transientParentFor
name|QMirClientWindow
modifier|*
name|transientParentFor
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|)
block|{
name|QWindow
modifier|*
name|parent
init|=
name|window
operator|->
name|transientParent
argument_list|()
decl_stmt|;
return|return
name|parent
condition|?
cast|static_cast
argument_list|<
name|QMirClientWindow
operator|*
argument_list|>
argument_list|(
name|parent
operator|->
name|handle
argument_list|()
argument_list|)
else|:
literal|nullptr
return|;
block|}
DECL|function|makeSurfaceSpec
name|Spec
name|makeSurfaceSpec
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
name|QMirClientInput
modifier|*
name|input
parameter_list|,
name|MirConnection
modifier|*
name|connection
parameter_list|)
block|{
specifier|const
specifier|auto
name|geom
init|=
name|window
operator|->
name|geometry
argument_list|()
decl_stmt|;
specifier|const
name|int
name|width
init|=
name|geom
operator|.
name|width
argument_list|()
operator|>
literal|0
condition|?
name|geom
operator|.
name|width
argument_list|()
else|:
literal|1
decl_stmt|;
specifier|const
name|int
name|height
init|=
name|geom
operator|.
name|height
argument_list|()
operator|>
literal|0
condition|?
name|geom
operator|.
name|height
argument_list|()
else|:
literal|1
decl_stmt|;
specifier|const
specifier|auto
name|pixelFormat
init|=
name|defaultPixelFormatFor
argument_list|(
name|connection
argument_list|)
decl_stmt|;
if|if
condition|(
name|U_ON_SCREEN_KEYBOARD_ROLE
operator|==
name|roleFor
argument_list|(
name|window
argument_list|)
condition|)
block|{
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] makeSurfaceSpec(window=%p) - creating input method surface (width=%d, height=%d"
argument_list|,
name|window
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
return|return
name|Spec
block|{
name|mir_connection_create_spec_for_input_method
argument_list|(
argument|connection
argument_list|,
argument|width
argument_list|,
argument|height
argument_list|,
argument|pixelFormat
argument_list|)
block|}
return|;
block|}
specifier|const
name|Qt
operator|::
name|WindowType
name|type
init|=
name|window
operator|->
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|Qt
operator|::
name|Popup
condition|)
block|{
name|auto
name|parent
init|=
name|transientParentFor
argument_list|(
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|nullptr
condition|)
block|{
comment|//NOTE: We cannot have a parentless popup -
comment|//try using the last surface to receive input as that will most likely be
comment|//the one that caused this popup to be created
name|parent
operator|=
name|input
operator|->
name|lastFocusedWindow
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|parent
condition|)
block|{
name|auto
name|pos
init|=
name|geom
operator|.
name|topLeft
argument_list|()
decl_stmt|;
name|pos
operator|-=
name|parent
operator|->
name|geometry
argument_list|()
operator|.
name|topLeft
argument_list|()
expr_stmt|;
name|MirRectangle
name|location
argument_list|{
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|}
decl_stmt|;
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] makeSurfaceSpec(window=%p) - creating menu surface(width:%d, height:%d)"
argument_list|,
name|window
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
return|return
name|Spec
block|{
name|mir_connection_create_spec_for_menu
argument_list|(
argument|connection
argument_list|,
argument|width
argument_list|,
argument|height
argument_list|,
argument|pixelFormat
argument_list|,
argument|parent->mirSurface()
argument_list|,
argument|&location
argument_list|,
argument|mir_edge_attachment_any
argument_list|)
block|}
return|;
block|}
else|else
block|{
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] makeSurfaceSpec(window=%p) - cannot create a menu without a parent!"
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|Qt
operator|::
name|Dialog
condition|)
block|{
name|auto
name|parent
init|=
name|transientParentFor
argument_list|(
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
comment|// Modal dialog
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] makeSurfaceSpec(window=%p) - creating modal dialog (width=%d, height=%d"
argument_list|,
name|window
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
return|return
name|Spec
block|{
name|mir_connection_create_spec_for_modal_dialog
argument_list|(
argument|connection
argument_list|,
argument|width
argument_list|,
argument|height
argument_list|,
argument|pixelFormat
argument_list|,
argument|parent->mirSurface()
argument_list|)
block|}
return|;
block|}
else|else
block|{
comment|// TODO: do Qt parentless dialogs have the same semantics as mir?
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] makeSurfaceSpec(window=%p) - creating parentless dialog (width=%d, height=%d)"
argument_list|,
name|window
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
return|return
name|Spec
block|{
name|mir_connection_create_spec_for_dialog
argument_list|(
argument|connection
argument_list|,
argument|width
argument_list|,
argument|height
argument_list|,
argument|pixelFormat
argument_list|)
block|}
return|;
block|}
block|}
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] makeSurfaceSpec(window=%p) - creating normal surface(type=0x%x, width=%d, height=%d)"
argument_list|,
name|window
argument_list|,
name|type
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
return|return
name|Spec
block|{
name|mir_connection_create_spec_for_normal_surface
argument_list|(
argument|connection
argument_list|,
argument|width
argument_list|,
argument|height
argument_list|,
argument|pixelFormat
argument_list|)
block|}
return|;
block|}
DECL|function|setSizingConstraints
name|void
name|setSizingConstraints
parameter_list|(
name|MirSurfaceSpec
modifier|*
name|spec
parameter_list|,
specifier|const
name|QSize
modifier|&
name|minSize
parameter_list|,
specifier|const
name|QSize
modifier|&
name|maxSize
parameter_list|,
specifier|const
name|QSize
modifier|&
name|increment
parameter_list|)
block|{
name|mir_surface_spec_set_min_width
argument_list|(
name|spec
argument_list|,
name|minSize
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|mir_surface_spec_set_min_height
argument_list|(
name|spec
argument_list|,
name|minSize
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxSize
operator|.
name|width
argument_list|()
operator|>=
name|minSize
operator|.
name|width
argument_list|()
condition|)
block|{
name|mir_surface_spec_set_max_width
argument_list|(
name|spec
argument_list|,
name|maxSize
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxSize
operator|.
name|height
argument_list|()
operator|>=
name|minSize
operator|.
name|height
argument_list|()
condition|)
block|{
name|mir_surface_spec_set_max_height
argument_list|(
name|spec
argument_list|,
name|maxSize
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|increment
operator|.
name|width
argument_list|()
operator|>
literal|0
condition|)
block|{
name|mir_surface_spec_set_width_increment
argument_list|(
name|spec
argument_list|,
name|increment
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|increment
operator|.
name|height
argument_list|()
operator|>
literal|0
condition|)
block|{
name|mir_surface_spec_set_height_increment
argument_list|(
name|spec
argument_list|,
name|increment
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|createMirSurface
name|MirSurface
modifier|*
name|createMirSurface
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
name|QMirClientScreen
modifier|*
name|screen
parameter_list|,
name|QMirClientInput
modifier|*
name|input
parameter_list|,
name|MirConnection
modifier|*
name|connection
parameter_list|)
block|{
name|auto
name|spec
init|=
name|makeSurfaceSpec
argument_list|(
name|window
argument_list|,
name|input
argument_list|,
name|connection
argument_list|)
decl_stmt|;
specifier|const
specifier|auto
name|title
init|=
name|window
operator|->
name|title
argument_list|()
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
name|mir_surface_spec_set_name
argument_list|(
name|spec
operator|.
name|get
argument_list|()
argument_list|,
name|title
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|setSizingConstraints
argument_list|(
name|spec
operator|.
name|get
argument_list|()
argument_list|,
name|window
operator|->
name|minimumSize
argument_list|()
argument_list|,
name|window
operator|->
name|maximumSize
argument_list|()
argument_list|,
name|window
operator|->
name|sizeIncrement
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|windowState
argument_list|()
operator|==
name|Qt
operator|::
name|WindowFullScreen
condition|)
block|{
name|mir_surface_spec_set_fullscreen_on_output
argument_list|(
name|spec
operator|.
name|get
argument_list|()
argument_list|,
name|screen
operator|->
name|mirOutputId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|auto
name|surface
init|=
name|mir_surface_create_sync
argument_list|(
name|spec
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|mir_surface_is_valid
argument_list|(
name|surface
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|surface
return|;
block|}
comment|// FIXME - in order to work around https://bugs.launchpad.net/mir/+bug/1346633
comment|// we need to guess the panel height (3GU)
DECL|function|panelHeight
name|int
name|panelHeight
parameter_list|()
block|{
if|if
condition|(
name|qEnvironmentVariableIsSet
argument_list|(
literal|"QT_MIRCLIENT_IGNORE_PANEL"
argument_list|)
condition|)
return|return
literal|0
return|;
specifier|const
name|int
name|defaultGridUnit
init|=
literal|8
decl_stmt|;
name|int
name|gridUnit
init|=
name|defaultGridUnit
decl_stmt|;
name|QByteArray
name|gridUnitString
init|=
name|qgetenv
argument_list|(
literal|"GRID_UNIT_PX"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|gridUnitString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bool
name|ok
decl_stmt|;
name|gridUnit
operator|=
name|gridUnitString
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|gridUnit
operator|=
name|defaultGridUnit
expr_stmt|;
block|}
block|}
return|return
name|gridUnit
operator|*
literal|3
return|;
block|}
block|}
end_namespace
begin_comment
comment|//namespace
end_comment
begin_class
DECL|class|QMirClientSurface
class|class
name|QMirClientSurface
block|{
public|public:
DECL|function|QMirClientSurface
name|QMirClientSurface
parameter_list|(
name|QMirClientWindow
modifier|*
name|platformWindow
parameter_list|,
name|QMirClientScreen
modifier|*
name|screen
parameter_list|,
name|QMirClientInput
modifier|*
name|input
parameter_list|,
name|MirConnection
modifier|*
name|connection
parameter_list|)
member_init_list|:
name|mWindow
argument_list|(
name|platformWindow
operator|->
name|window
argument_list|()
argument_list|)
member_init_list|,
name|mPlatformWindow
argument_list|(
name|platformWindow
argument_list|)
member_init_list|,
name|mInput
argument_list|(
name|input
argument_list|)
member_init_list|,
name|mConnection
argument_list|(
name|connection
argument_list|)
member_init_list|,
name|mMirSurface
argument_list|(
name|createMirSurface
argument_list|(
name|mWindow
argument_list|,
name|screen
argument_list|,
name|input
argument_list|,
name|connection
argument_list|)
argument_list|)
member_init_list|,
name|mEglDisplay
argument_list|(
name|screen
operator|->
name|eglDisplay
argument_list|()
argument_list|)
member_init_list|,
name|mEglSurface
argument_list|(
name|eglCreateWindowSurface
argument_list|(
name|mEglDisplay
argument_list|,
name|screen
operator|->
name|eglConfig
argument_list|()
argument_list|,
name|nativeWindowFor
argument_list|(
name|mMirSurface
argument_list|)
argument_list|,
literal|nullptr
argument_list|)
argument_list|)
member_init_list|,
name|mVisible
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mNeedsRepaint
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mParented
argument_list|(
name|mWindow
operator|->
name|transientParent
argument_list|()
operator|||
name|mWindow
operator|->
name|parent
argument_list|()
argument_list|)
member_init_list|,
name|mWindowState
argument_list|(
name|mWindow
operator|->
name|windowState
argument_list|()
argument_list|)
block|{
name|mir_surface_set_event_handler
argument_list|(
name|mMirSurface
argument_list|,
name|surfaceEventCallback
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// Window manager can give us a final size different from what we asked for
comment|// so let's check what we ended up getting
name|MirSurfaceParameters
name|parameters
decl_stmt|;
name|mir_surface_get_parameters
argument_list|(
name|mMirSurface
argument_list|,
operator|&
name|parameters
argument_list|)
expr_stmt|;
name|auto
name|geom
init|=
name|mWindow
operator|->
name|geometry
argument_list|()
decl_stmt|;
name|geom
operator|.
name|setWidth
argument_list|(
name|parameters
operator|.
name|width
argument_list|)
expr_stmt|;
name|geom
operator|.
name|setHeight
argument_list|(
name|parameters
operator|.
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|mWindowState
operator|==
name|Qt
operator|::
name|WindowFullScreen
condition|)
block|{
name|geom
operator|.
name|setY
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|geom
operator|.
name|setY
argument_list|(
name|panelHeight
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Assume that the buffer size matches the surface size at creation time
name|mBufferSize
operator|=
name|geom
operator|.
name|size
argument_list|()
expr_stmt|;
name|platformWindow
operator|->
name|QPlatformWindow
operator|::
name|setGeometry
argument_list|(
name|geom
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleGeometryChange
argument_list|(
name|mWindow
argument_list|,
name|geom
argument_list|)
expr_stmt|;
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] created surface at (%d, %d) with size (%d, %d), title '%s', role: '%d'\n"
argument_list|,
name|geom
operator|.
name|x
argument_list|()
argument_list|,
name|geom
operator|.
name|y
argument_list|()
argument_list|,
name|geom
operator|.
name|width
argument_list|()
argument_list|,
name|geom
operator|.
name|height
argument_list|()
argument_list|,
name|mWindow
operator|->
name|title
argument_list|()
operator|.
name|toUtf8
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|roleFor
argument_list|(
name|mWindow
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|~QMirClientSurface
name|~
name|QMirClientSurface
parameter_list|()
block|{
if|if
condition|(
name|mEglSurface
operator|!=
name|EGL_NO_SURFACE
condition|)
name|eglDestroySurface
argument_list|(
name|mEglDisplay
argument_list|,
name|mEglSurface
argument_list|)
expr_stmt|;
if|if
condition|(
name|mMirSurface
condition|)
name|mir_surface_release_sync
argument_list|(
name|mMirSurface
argument_list|)
expr_stmt|;
block|}
name|QMirClientSurface
parameter_list|(
name|QMirClientSurface
specifier|const
modifier|&
parameter_list|)
constructor_decl|=
specifier|delete
constructor_decl|;
name|QMirClientSurface
modifier|&
name|operator
name|=
parameter_list|(
name|QMirClientSurface
specifier|const
modifier|&
parameter_list|)
function_decl|=
specifier|delete
function_decl|;
name|void
name|resize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|newSize
parameter_list|)
function_decl|;
name|void
name|setState
parameter_list|(
name|Qt
operator|::
name|WindowState
name|newState
parameter_list|)
function_decl|;
name|void
name|setVisible
parameter_list|(
name|bool
name|state
parameter_list|)
function_decl|;
name|void
name|updateTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
function_decl|;
name|void
name|setSizingConstraints
parameter_list|(
specifier|const
name|QSize
modifier|&
name|minSize
parameter_list|,
specifier|const
name|QSize
modifier|&
name|maxSize
parameter_list|,
specifier|const
name|QSize
modifier|&
name|increment
parameter_list|)
function_decl|;
name|void
name|onSwapBuffersDone
parameter_list|()
function_decl|;
name|void
name|handleSurfaceResized
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
function_decl|;
name|int
name|needsRepaint
parameter_list|()
specifier|const
function_decl|;
DECL|function|eglSurface
name|EGLSurface
name|eglSurface
parameter_list|()
specifier|const
block|{
return|return
name|mEglSurface
return|;
block|}
DECL|function|mirSurface
name|MirSurface
modifier|*
name|mirSurface
parameter_list|()
specifier|const
block|{
return|return
name|mMirSurface
return|;
block|}
private|private:
specifier|static
name|void
name|surfaceEventCallback
parameter_list|(
name|MirSurface
modifier|*
name|surface
parameter_list|,
specifier|const
name|MirEvent
modifier|*
name|event
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
name|void
name|postEvent
parameter_list|(
specifier|const
name|MirEvent
modifier|*
name|event
parameter_list|)
function_decl|;
name|void
name|updateSurface
parameter_list|()
function_decl|;
DECL|member|mWindow
name|QWindow
modifier|*
specifier|const
name|mWindow
decl_stmt|;
DECL|member|mPlatformWindow
name|QMirClientWindow
modifier|*
specifier|const
name|mPlatformWindow
decl_stmt|;
DECL|member|mInput
name|QMirClientInput
modifier|*
specifier|const
name|mInput
decl_stmt|;
DECL|member|mConnection
name|MirConnection
modifier|*
specifier|const
name|mConnection
decl_stmt|;
DECL|member|mMirSurface
name|MirSurface
modifier|*
specifier|const
name|mMirSurface
decl_stmt|;
DECL|member|mEglDisplay
specifier|const
name|EGLDisplay
name|mEglDisplay
decl_stmt|;
DECL|member|mEglSurface
specifier|const
name|EGLSurface
name|mEglSurface
decl_stmt|;
DECL|member|mVisible
name|bool
name|mVisible
decl_stmt|;
DECL|member|mNeedsRepaint
name|bool
name|mNeedsRepaint
decl_stmt|;
DECL|member|mParented
name|bool
name|mParented
decl_stmt|;
DECL|member|mWindowState
name|Qt
operator|::
name|WindowState
name|mWindowState
decl_stmt|;
DECL|member|mBufferSize
name|QSize
name|mBufferSize
decl_stmt|;
DECL|member|mTargetSizeMutex
name|QMutex
name|mTargetSizeMutex
decl_stmt|;
DECL|member|mTargetSize
name|QSize
name|mTargetSize
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|resize
name|void
name|QMirClientSurface
operator|::
name|resize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] resize(window=%p, width=%d, height=%d)"
argument_list|,
name|mWindow
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mWindowState
operator|==
name|Qt
operator|::
name|WindowFullScreen
operator|||
name|mWindowState
operator|==
name|Qt
operator|::
name|WindowMaximized
condition|)
block|{
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] resize(window=%p) - not resizing, window is maximized or fullscreen"
argument_list|,
name|mWindow
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] resize(window=%p) - not resizing, size is empty"
argument_list|,
name|mWindow
argument_list|)
expr_stmt|;
return|return;
block|}
name|Spec
name|spec
argument_list|{
name|mir_connection_create_spec_for_changes
argument_list|(
argument|mConnection
argument_list|)
argument_list|}
decl_stmt|;
name|mir_surface_spec_set_width
argument_list|(
name|spec
operator|.
name|get
argument_list|()
argument_list|,
name|size
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|mir_surface_spec_set_height
argument_list|(
name|spec
operator|.
name|get
argument_list|()
argument_list|,
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|mir_surface_apply_spec
argument_list|(
name|mMirSurface
argument_list|,
name|spec
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setState
name|void
name|QMirClientSurface
operator|::
name|setState
parameter_list|(
name|Qt
operator|::
name|WindowState
name|newState
parameter_list|)
block|{
name|mir_wait_for
argument_list|(
name|mir_surface_set_state
argument_list|(
name|mMirSurface
argument_list|,
name|qtWindowStateToMirSurfaceState
argument_list|(
name|newState
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mWindowState
operator|=
name|newState
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setVisible
name|void
name|QMirClientSurface
operator|::
name|setVisible
parameter_list|(
name|bool
name|visible
parameter_list|)
block|{
if|if
condition|(
name|mVisible
operator|==
name|visible
condition|)
return|return;
name|mVisible
operator|=
name|visible
expr_stmt|;
if|if
condition|(
name|mVisible
condition|)
name|updateSurface
argument_list|()
expr_stmt|;
comment|// TODO: Use the new mir_surface_state_hidden state instead of mir_surface_state_minimized.
comment|//       Will have to change qtmir and unity8 for that.
specifier|const
specifier|auto
name|newState
init|=
name|visible
condition|?
name|qtWindowStateToMirSurfaceState
argument_list|(
name|mWindowState
argument_list|)
else|:
name|mir_surface_state_minimized
decl_stmt|;
name|mir_wait_for
argument_list|(
name|mir_surface_set_state
argument_list|(
name|mMirSurface
argument_list|,
name|newState
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateTitle
name|void
name|QMirClientSurface
operator|::
name|updateTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|newTitle
parameter_list|)
block|{
specifier|const
specifier|auto
name|title
init|=
name|newTitle
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
name|Spec
name|spec
argument_list|{
name|mir_connection_create_spec_for_changes
argument_list|(
argument|mConnection
argument_list|)
argument_list|}
decl_stmt|;
name|mir_surface_spec_set_name
argument_list|(
name|spec
operator|.
name|get
argument_list|()
argument_list|,
name|title
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|mir_surface_apply_spec
argument_list|(
name|mMirSurface
argument_list|,
name|spec
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setSizingConstraints
name|void
name|QMirClientSurface
operator|::
name|setSizingConstraints
parameter_list|(
specifier|const
name|QSize
modifier|&
name|minSize
parameter_list|,
specifier|const
name|QSize
modifier|&
name|maxSize
parameter_list|,
specifier|const
name|QSize
modifier|&
name|increment
parameter_list|)
block|{
name|Spec
name|spec
argument_list|{
name|mir_connection_create_spec_for_changes
argument_list|(
argument|mConnection
argument_list|)
argument_list|}
decl_stmt|;
operator|::
name|setSizingConstraints
argument_list|(
name|spec
operator|.
name|get
argument_list|()
argument_list|,
name|minSize
argument_list|,
name|maxSize
argument_list|,
name|increment
argument_list|)
expr_stmt|;
name|mir_surface_apply_spec
argument_list|(
name|mMirSurface
argument_list|,
name|spec
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleSurfaceResized
name|void
name|QMirClientSurface
operator|::
name|handleSurfaceResized
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mTargetSizeMutex
argument_list|)
decl_stmt|;
comment|// mir's resize event is mainly a signal that we need to redraw our content. We use the
comment|// width/height as identifiers to figure out if this is the latest surface resize event
comment|// that has posted, discarding any old ones. This avoids issuing too many redraw events.
comment|// see TODO in postEvent as the ideal way we should handle this.
comment|// The actual buffer size may or may have not changed at this point, so let the rendering
comment|// thread drive the window geometry updates.
name|mNeedsRepaint
operator|=
name|mTargetSize
operator|.
name|width
argument_list|()
operator|==
name|width
operator|&&
name|mTargetSize
operator|.
name|height
argument_list|()
operator|==
name|height
expr_stmt|;
block|}
end_function
begin_function
DECL|function|needsRepaint
name|int
name|QMirClientSurface
operator|::
name|needsRepaint
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|mNeedsRepaint
condition|)
block|{
if|if
condition|(
name|mTargetSize
operator|!=
name|mBufferSize
condition|)
block|{
comment|//If the buffer hasn't changed yet, we need at least two redraws,
comment|//once to get the new buffer size and propagate the geometry changes
comment|//and the second to redraw the content at the new size
return|return
literal|2
return|;
block|}
else|else
block|{
comment|// The buffer size has already been updated so we only need one redraw
comment|// to render at the new size
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|onSwapBuffersDone
name|void
name|QMirClientSurface
operator|::
name|onSwapBuffersDone
parameter_list|()
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_DEBUG
argument_list|)
specifier|static
name|int
name|sFrameNumber
init|=
literal|0
decl_stmt|;
operator|++
name|sFrameNumber
expr_stmt|;
endif|#
directive|endif
name|EGLint
name|eglSurfaceWidth
init|=
operator|-
literal|1
decl_stmt|;
name|EGLint
name|eglSurfaceHeight
init|=
operator|-
literal|1
decl_stmt|;
name|eglQuerySurface
argument_list|(
name|mEglDisplay
argument_list|,
name|mEglSurface
argument_list|,
name|EGL_WIDTH
argument_list|,
operator|&
name|eglSurfaceWidth
argument_list|)
expr_stmt|;
name|eglQuerySurface
argument_list|(
name|mEglDisplay
argument_list|,
name|mEglSurface
argument_list|,
name|EGL_HEIGHT
argument_list|,
operator|&
name|eglSurfaceHeight
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|validSize
init|=
name|eglSurfaceWidth
operator|>
literal|0
operator|&&
name|eglSurfaceHeight
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|validSize
operator|&&
operator|(
name|mBufferSize
operator|.
name|width
argument_list|()
operator|!=
name|eglSurfaceWidth
operator|||
name|mBufferSize
operator|.
name|height
argument_list|()
operator|!=
name|eglSurfaceHeight
operator|)
condition|)
block|{
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] onSwapBuffersDone(window=%p) [%d] - size changed (%d, %d) => (%d, %d)"
argument_list|,
name|mWindow
argument_list|,
name|sFrameNumber
argument_list|,
name|mBufferSize
operator|.
name|width
argument_list|()
argument_list|,
name|mBufferSize
operator|.
name|height
argument_list|()
argument_list|,
name|eglSurfaceWidth
argument_list|,
name|eglSurfaceHeight
argument_list|)
expr_stmt|;
name|mBufferSize
operator|.
name|rwidth
argument_list|()
operator|=
name|eglSurfaceWidth
expr_stmt|;
name|mBufferSize
operator|.
name|rheight
argument_list|()
operator|=
name|eglSurfaceHeight
expr_stmt|;
name|QRect
name|newGeometry
init|=
name|mPlatformWindow
operator|->
name|geometry
argument_list|()
decl_stmt|;
name|newGeometry
operator|.
name|setSize
argument_list|(
name|mBufferSize
argument_list|)
expr_stmt|;
name|mPlatformWindow
operator|->
name|QPlatformWindow
operator|::
name|setGeometry
argument_list|(
name|newGeometry
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleGeometryChange
argument_list|(
name|mWindow
argument_list|,
name|newGeometry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|DLOG("[ubuntumirclient QPA] onSwapBuffersDone(window=%p) [%d] - buffer size (%d,%d)",                mWindow, sFrameNumber, mBufferSize.width(), mBufferSize.height());
endif|#
directive|endif
block|}
block|}
end_function
begin_function
DECL|function|surfaceEventCallback
name|void
name|QMirClientSurface
operator|::
name|surfaceEventCallback
parameter_list|(
name|MirSurface
modifier|*
name|surface
parameter_list|,
specifier|const
name|MirEvent
modifier|*
name|event
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|surface
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|context
operator|!=
literal|nullptr
argument_list|)
expr_stmt|;
name|auto
name|s
init|=
cast|static_cast
argument_list|<
name|QMirClientSurface
operator|*
argument_list|>
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|s
operator|->
name|postEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|postEvent
name|void
name|QMirClientSurface
operator|::
name|postEvent
parameter_list|(
specifier|const
name|MirEvent
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|mir_event_type_resize
operator|==
name|mir_event_get_type
argument_list|(
name|event
argument_list|)
condition|)
block|{
comment|// TODO: The current event queue just accumulates all resize events;
comment|// It would be nicer if we could update just one event if that event has not been dispatched.
comment|// As a workaround, we use the width/height as an identifier of this latest event
comment|// so the event handler (handleSurfaceResized) can discard/ignore old ones.
specifier|const
specifier|auto
name|resizeEvent
init|=
name|mir_event_get_resize_event
argument_list|(
name|event
argument_list|)
decl_stmt|;
specifier|const
specifier|auto
name|width
init|=
name|mir_resize_event_get_width
argument_list|(
name|resizeEvent
argument_list|)
decl_stmt|;
specifier|const
specifier|auto
name|height
init|=
name|mir_resize_event_get_height
argument_list|(
name|resizeEvent
argument_list|)
decl_stmt|;
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] resizeEvent(window=%p, width=%d, height=%d)"
argument_list|,
name|mWindow
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mTargetSizeMutex
argument_list|)
decl_stmt|;
name|mTargetSize
operator|.
name|rwidth
argument_list|()
operator|=
name|width
expr_stmt|;
name|mTargetSize
operator|.
name|rheight
argument_list|()
operator|=
name|height
expr_stmt|;
block|}
name|mInput
operator|->
name|postEvent
argument_list|(
name|mPlatformWindow
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateSurface
name|void
name|QMirClientSurface
operator|::
name|updateSurface
parameter_list|()
block|{
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] updateSurface(window=%p)"
argument_list|,
name|mWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mParented
operator|&&
name|mWindow
operator|->
name|type
argument_list|()
operator|==
name|Qt
operator|::
name|Dialog
condition|)
block|{
comment|// The dialog may have been parented after creation time
comment|// so morph it into a modal dialog
name|auto
name|parent
init|=
name|transientParentFor
argument_list|(
name|mWindow
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] updateSurface(window=%p) dialog now parented"
argument_list|,
name|mWindow
argument_list|)
expr_stmt|;
name|mParented
operator|=
literal|true
expr_stmt|;
name|Spec
name|spec
argument_list|{
name|mir_connection_create_spec_for_changes
argument_list|(
argument|mConnection
argument_list|)
argument_list|}
decl_stmt|;
name|mir_surface_spec_set_parent
argument_list|(
name|spec
operator|.
name|get
argument_list|()
argument_list|,
name|parent
operator|->
name|mirSurface
argument_list|()
argument_list|)
expr_stmt|;
name|mir_surface_apply_spec
argument_list|(
name|mMirSurface
argument_list|,
name|spec
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_constructor
DECL|function|QMirClientWindow
name|QMirClientWindow
operator|::
name|QMirClientWindow
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|,
specifier|const
name|QSharedPointer
argument_list|<
name|QMirClientClipboard
argument_list|>
modifier|&
name|clipboard
parameter_list|,
name|QMirClientScreen
modifier|*
name|screen
parameter_list|,
name|QMirClientInput
modifier|*
name|input
parameter_list|,
name|MirConnection
modifier|*
name|connection
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
literal|nullptr
argument_list|)
member_init_list|,
name|QPlatformWindow
argument_list|(
name|w
argument_list|)
member_init_list|,
name|mId
argument_list|(
name|makeId
argument_list|()
argument_list|)
member_init_list|,
name|mClipboard
argument_list|(
name|clipboard
argument_list|)
member_init_list|,
name|mSurface
argument_list|(
operator|new
name|QMirClientSurface
block|{
name|this
block|,
name|screen
block|,
name|input
block|,
name|connection
block|}
argument_list|)
block|{
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] QMirClientWindow(window=%p, screen=%p, input=%p, surf=%p)"
argument_list|,
name|w
argument_list|,
name|screen
argument_list|,
name|input
argument_list|,
name|mSurface
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QMirClientWindow
name|QMirClientWindow
operator|::
name|~
name|QMirClientWindow
parameter_list|()
block|{
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] ~QMirClientWindow(window=%p)"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|handleSurfaceResized
name|void
name|QMirClientWindow
operator|::
name|handleSurfaceResized
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mMutex
argument_list|)
decl_stmt|;
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] handleSurfaceResize(window=%p, width=%d, height=%d)"
argument_list|,
name|window
argument_list|()
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|mSurface
operator|->
name|handleSurfaceResized
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|// This resize event could have occurred just after the last buffer swap for this window.
comment|// This means the client may still be holding a buffer with the older size. The first redraw call
comment|// will then render at the old size. After swapping the client now will get a new buffer with the
comment|// updated size but it still needs re-rendering so another redraw may be needed.
comment|// A mir API to drop the currently held buffer would help here, so that we wouldn't have to redraw twice
specifier|auto
specifier|const
name|numRepaints
init|=
name|mSurface
operator|->
name|needsRepaint
argument_list|()
decl_stmt|;
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] handleSurfaceResize(window=%p) redraw %d times"
argument_list|,
name|window
argument_list|()
argument_list|,
name|numRepaints
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRepaints
condition|;
name|i
operator|++
control|)
block|{
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] handleSurfaceResize(window=%p) repainting width=%d, height=%d"
argument_list|,
name|window
argument_list|()
argument_list|,
name|geometry
argument_list|()
operator|.
name|size
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|geometry
argument_list|()
operator|.
name|size
argument_list|()
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleExposeEvent
argument_list|(
name|window
argument_list|()
argument_list|,
name|QRect
argument_list|(
name|QPoint
argument_list|()
argument_list|,
name|geometry
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|handleSurfaceFocused
name|void
name|QMirClientWindow
operator|::
name|handleSurfaceFocused
parameter_list|()
block|{
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] handleSurfaceFocused(window=%p)"
argument_list|,
name|window
argument_list|()
argument_list|)
expr_stmt|;
comment|// System clipboard contents might have changed while this window was unfocused and without
comment|// this process getting notified about it because it might have been suspended (due to
comment|// application lifecycle policies), thus unable to listen to any changes notified through
comment|// D-Bus.
comment|// Therefore let's ensure we are up to date with the system clipboard now that we are getting
comment|// focused again.
name|mClipboard
operator|->
name|requestDBusClipboardContents
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setWindowState
name|void
name|QMirClientWindow
operator|::
name|setWindowState
parameter_list|(
name|Qt
operator|::
name|WindowState
name|state
parameter_list|)
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mMutex
argument_list|)
decl_stmt|;
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] setWindowState(window=%p, %s)"
argument_list|,
name|this
argument_list|,
name|qtWindowStateToStr
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|mSurface
operator|->
name|setState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|updatePanelHeightHack
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     FIXME: Mir does not let clients know the position of their windows in the virtual     desktop space. So we have this ugly hack that assumes a phone situation where the     window is always on the top-left corner, right below the indicators panel if not     in fullscreen.  */
end_comment
begin_function
DECL|function|updatePanelHeightHack
name|void
name|QMirClientWindow
operator|::
name|updatePanelHeightHack
parameter_list|(
name|Qt
operator|::
name|WindowState
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
name|Qt
operator|::
name|WindowFullScreen
operator|&&
name|geometry
argument_list|()
operator|.
name|y
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|QRect
name|newGeometry
init|=
name|geometry
argument_list|()
decl_stmt|;
name|newGeometry
operator|.
name|setY
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QPlatformWindow
operator|::
name|setGeometry
argument_list|(
name|newGeometry
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleGeometryChange
argument_list|(
name|window
argument_list|()
argument_list|,
name|newGeometry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|geometry
argument_list|()
operator|.
name|y
argument_list|()
operator|==
literal|0
condition|)
block|{
name|QRect
name|newGeometry
init|=
name|geometry
argument_list|()
decl_stmt|;
name|newGeometry
operator|.
name|setY
argument_list|(
name|panelHeight
argument_list|()
argument_list|)
expr_stmt|;
name|QPlatformWindow
operator|::
name|setGeometry
argument_list|(
name|newGeometry
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleGeometryChange
argument_list|(
name|window
argument_list|()
argument_list|,
name|newGeometry
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setGeometry
name|void
name|QMirClientWindow
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mMutex
argument_list|)
decl_stmt|;
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] setGeometry (window=%p, x=%d, y=%d, width=%d, height=%d)"
argument_list|,
name|window
argument_list|()
argument_list|,
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|rect
operator|.
name|y
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
comment|//NOTE: mir surfaces cannot be moved by the client so ignore the topLeft coordinates
specifier|const
specifier|auto
name|newSize
init|=
name|rect
operator|.
name|size
argument_list|()
decl_stmt|;
name|auto
name|newGeometry
init|=
name|geometry
argument_list|()
decl_stmt|;
name|newGeometry
operator|.
name|setSize
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
name|QPlatformWindow
operator|::
name|setGeometry
argument_list|(
name|newGeometry
argument_list|)
expr_stmt|;
name|mSurface
operator|->
name|resize
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setVisible
name|void
name|QMirClientWindow
operator|::
name|setVisible
parameter_list|(
name|bool
name|visible
parameter_list|)
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mMutex
argument_list|)
decl_stmt|;
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] setVisible (window=%p, visible=%s)"
argument_list|,
name|window
argument_list|()
argument_list|,
name|visible
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|mSurface
operator|->
name|setVisible
argument_list|(
name|visible
argument_list|)
expr_stmt|;
specifier|const
name|QRect
modifier|&
name|exposeRect
init|=
name|visible
condition|?
name|QRect
argument_list|(
name|QPoint
argument_list|()
argument_list|,
name|geometry
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
else|:
name|QRect
argument_list|()
decl_stmt|;
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleExposeEvent
argument_list|(
name|window
argument_list|()
argument_list|,
name|exposeRect
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|flushWindowSystemEvents
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setWindowTitle
name|void
name|QMirClientWindow
operator|::
name|setWindowTitle
parameter_list|(
specifier|const
name|QString
modifier|&
name|title
parameter_list|)
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mMutex
argument_list|)
decl_stmt|;
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] setWindowTitle(window=%p) title=%s)"
argument_list|,
name|window
argument_list|()
argument_list|,
name|title
operator|.
name|toUtf8
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|mSurface
operator|->
name|updateTitle
argument_list|(
name|title
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|propagateSizeHints
name|void
name|QMirClientWindow
operator|::
name|propagateSizeHints
parameter_list|()
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mMutex
argument_list|)
decl_stmt|;
specifier|const
specifier|auto
name|win
init|=
name|window
argument_list|()
decl_stmt|;
name|DLOG
argument_list|(
literal|"[ubuntumirclient QPA] propagateSizeHints(window=%p) min(%d,%d), max(%d,%d) increment(%d, %d)"
argument_list|,
name|win
argument_list|,
name|win
operator|->
name|minimumSize
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|win
operator|->
name|minimumSize
argument_list|()
operator|.
name|height
argument_list|()
argument_list|,
name|win
operator|->
name|maximumSize
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|win
operator|->
name|maximumSize
argument_list|()
operator|.
name|height
argument_list|()
argument_list|,
name|win
operator|->
name|sizeIncrement
argument_list|()
operator|.
name|width
argument_list|()
argument_list|,
name|win
operator|->
name|sizeIncrement
argument_list|()
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|mSurface
operator|->
name|setSizingConstraints
argument_list|(
name|win
operator|->
name|minimumSize
argument_list|()
argument_list|,
name|win
operator|->
name|maximumSize
argument_list|()
argument_list|,
name|win
operator|->
name|sizeIncrement
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|eglSurface
name|void
modifier|*
name|QMirClientWindow
operator|::
name|eglSurface
parameter_list|()
specifier|const
block|{
return|return
name|mSurface
operator|->
name|eglSurface
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|mirSurface
name|MirSurface
modifier|*
name|QMirClientWindow
operator|::
name|mirSurface
parameter_list|()
specifier|const
block|{
return|return
name|mSurface
operator|->
name|mirSurface
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|winId
name|WId
name|QMirClientWindow
operator|::
name|winId
parameter_list|()
specifier|const
block|{
return|return
name|mId
return|;
block|}
end_function
begin_function
DECL|function|onSwapBuffersDone
name|void
name|QMirClientWindow
operator|::
name|onSwapBuffersDone
parameter_list|()
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mMutex
argument_list|)
decl_stmt|;
name|mSurface
operator|->
name|onSwapBuffersDone
argument_list|()
expr_stmt|;
block|}
end_function
end_unit
