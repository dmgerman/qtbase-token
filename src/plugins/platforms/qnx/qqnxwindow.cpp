begin_unit
begin_comment
comment|/*************************************************************************** ** ** Copyright (C) 2011 - 2013 BlackBerry Limited. All rights reserved. ** Contact: http://www.qt-project.org/legal ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qqnxglobal.h"
end_include
begin_include
include|#
directive|include
file|"qqnxwindow.h"
end_include
begin_include
include|#
directive|include
file|"qqnxintegration.h"
end_include
begin_include
include|#
directive|include
file|"qqnxscreen.h"
end_include
begin_include
include|#
directive|include
file|"qqnxlgmon.h"
end_include
begin_include
include|#
directive|include
file|<QUuid>
end_include
begin_include
include|#
directive|include
file|<QtGui/QWindow>
end_include
begin_include
include|#
directive|include
file|<qpa/qwindowsysteminterface.h>
end_include
begin_include
include|#
directive|include
file|"private/qguiapplication_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/QDebug>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
end_if
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|Q_OS_BLACKBERRY_TABLET
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qqnxnavigatorcover.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<sys/pps.h>
end_include
begin_include
include|#
directive|include
file|<bps/navigator.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QQNXWINDOW_DEBUG
argument_list|)
end_if
begin_define
DECL|macro|qWindowDebug
define|#
directive|define
name|qWindowDebug
value|qDebug
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|qWindowDebug
define|#
directive|define
name|qWindowDebug
value|QT_NO_QDEBUG_MACRO
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QQnxWindow     \brief The QQnxWindow is the base class of the various classes used as instances of     QPlatformWindow in the QNX QPA plugin.      The standard properties and methods available in Qt are not a perfect match for the     features provided by the QNX screen service. While for the majority of applications     the default behavior suffices, some circumstances require greater control over the     interaction with screen.      \section1 Window types      The QNX QPA plugin can operate in two modes, with or without a root window. The     selection of mode is made via the \e rootwindow and \e no-rootwindow options to the     plugin. The default mode is rootwindow for BlackBerry builds and no-rootwindow for     non-BlackBerry builds.      Windows with parents are always created as child windows, the difference in the modes     is in the treatment of parentless windows. In no-rootwindow mode, these windows are     created as application windows while in rootwindow mode, the first window on a screen     is created as an application window while subsequent windows are created as child     windows. The only exception to this is any window of type Qt::Desktop or Qt::CoverWindow;     these are created as application windows, but will never become the root window,     even if they are the first window created.      It is also possible to create a parentless child window. These may be useful to     create windows that are parented by windows from other processes. To do this, you     attach a dynamic property \e qnxInitialWindowGroup to the QWindow though this must be done     prior to the platform window class (this class) being created which typically happens     when the window is made visible. When the window is created in QML, it is acceptable     to have the \e visible property hardcoded to true so long as the qnxInitialWindowGroup     is also set.      \section1 Joining Window Groups      Window groups may be joined in a number of ways, some are automatic based on     predefined rules though an application is also able to provide explicit control.      A QWindow that has a parent will join its parent's window group. When rootwindow mode     is in effect, all but the first parentless window on a screen will be child windows     and join the window group of the first parentless window, the root window.      If a QWindow has a valid dynamic property called \e qnxInitialWindowGroup at the time the     QQnxWindow is created, the window will be created as a child window and, if the     qnxInitialWindowGroup property is a non-empty string, an attempt will be made to join that     window group. This has an effect only when the QQnxWindow is created, subsequent     changes to this property are ignored. Setting the property to an empty string     provides a means to create 'top level' child windows without automatically joining     any group. Typically when this property is used \e qnxWindowId should be used as well     so that the process that owns the window group being joined has some means to     identify the window.      At any point following the creation of the QQnxWindow object, an application can     change the window group it has joined. This is done by using the \e     setWindowProperty function of the native interface to set the \e qnxWindowGroup property     to the desired value, for example:      \code     QQuickView *view = new QQuickView(parent);     view->create();     QGuiApplication::platformNativeInterface()->setWindowProperty(view->handle(), "qnxWindowGroup",                                                                   group);     \endcode      To leave the current window group, one passes a null value for the property value,     for example:      \code     QQuickView *view = new QQuickView(parent);     view->create();     QGuiApplication::platformNativeInterface()->setWindowProperty(view->handle(), "qnxWindowGroup",                                                                   QVariant());     \endcode      \section1 Window Id      The screen window id string property can be set on a window by assigning the desired     value to a dynamic property \e qnxWindowId on the QWindow prior to the QQnxWindow having     been created. This is often wanted when one joins a window group belonging to a     different process.  */
end_comment
begin_constructor
DECL|function|QQnxWindow
name|QQnxWindow
operator|::
name|QQnxWindow
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
name|screen_context_t
name|context
parameter_list|,
name|bool
name|needRootWindow
parameter_list|)
member_init_list|:
name|QPlatformWindow
argument_list|(
name|window
argument_list|)
member_init_list|,
name|m_screenContext
argument_list|(
name|context
argument_list|)
member_init_list|,
name|m_window
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_screen
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_parentWindow
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_visible
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_exposed
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|m_windowState
argument_list|(
name|Qt
operator|::
name|WindowNoState
argument_list|)
member_init_list|,
name|m_mmRendererWindow
argument_list|(
literal|0
argument_list|)
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"window ="
operator|<<
name|window
operator|<<
literal|", size ="
operator|<<
name|window
operator|->
name|size
argument_list|()
expr_stmt|;
name|QQnxScreen
modifier|*
name|platformScreen
init|=
cast|static_cast
argument_list|<
name|QQnxScreen
operator|*
argument_list|>
argument_list|(
name|window
operator|->
name|screen
argument_list|()
operator|->
name|handle
argument_list|()
argument_list|)
decl_stmt|;
comment|// If a qnxInitialWindowGroup property is set on the window we'll take this as an
comment|// indication that we want to create a child window and join that window group.
specifier|const
name|QVariant
name|windowGroup
init|=
name|window
operator|->
name|property
argument_list|(
literal|"qnxInitialWindowGroup"
argument_list|)
decl_stmt|;
if|if
condition|(
name|window
operator|->
name|type
argument_list|()
operator|==
name|Qt
operator|::
name|CoverWindow
operator|||
name|window
operator|->
name|type
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
condition|)
block|{
comment|// Cover windows have to be top level to be accessible to window delegate (i.e. navigator)
comment|// Desktop windows also need to be toplevel because they are not
comment|// supposed to be part of the window hierarchy tree
name|m_isTopLevel
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parent
argument_list|()
operator|||
name|windowGroup
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// If we have a parent we are a child window.  Sometimes we have to be a child even if we
comment|// don't have a parent e.g. our parent might be in a different process.
name|m_isTopLevel
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// We're parentless.  If we're not using a root window, we'll always be a top-level window
comment|// otherwise only the first window is.
name|m_isTopLevel
operator|=
operator|!
name|needRootWindow
operator|||
operator|!
name|platformScreen
operator|->
name|rootWindow
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|m_isTopLevel
condition|)
block|{
name|Q_SCREEN_CRITICALERROR
argument_list|(
name|screen_create_window
argument_list|(
operator|&
name|m_window
argument_list|,
name|m_screenContext
argument_list|)
argument_list|,
literal|"Could not create top level window"
argument_list|)
expr_stmt|;
comment|// Creates an application window
if|if
condition|(
name|window
operator|->
name|type
argument_list|()
operator|!=
name|Qt
operator|::
name|CoverWindow
operator|&&
name|window
operator|->
name|type
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
condition|)
block|{
if|if
condition|(
name|needRootWindow
condition|)
name|platformScreen
operator|->
name|setRootWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_create_window_type
argument_list|(
operator|&
name|m_window
argument_list|,
name|m_screenContext
argument_list|,
name|SCREEN_CHILD_WINDOW
argument_list|)
argument_list|,
literal|"Could not create child window"
argument_list|)
expr_stmt|;
block|}
name|createWindowGroup
argument_list|()
expr_stmt|;
comment|// If the window has a qnxWindowId property, set this as the string id property. This generally
comment|// needs to be done prior to joining any group as it might be used by the owner of the
comment|// group to identify the window.
specifier|const
name|QVariant
name|windowId
init|=
name|window
operator|->
name|property
argument_list|(
literal|"qnxWindowId"
argument_list|)
decl_stmt|;
if|if
condition|(
name|windowId
operator|.
name|isValid
argument_list|()
operator|&&
name|windowId
operator|.
name|canConvert
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
condition|)
block|{
name|QByteArray
name|id
init|=
name|windowId
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_cv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_ID_STRING
argument_list|,
name|id
operator|.
name|size
argument_list|()
argument_list|,
name|id
argument_list|)
argument_list|,
literal|"Failed to set id"
argument_list|)
expr_stmt|;
block|}
comment|// If a window group has been provided join it now. If it's an empty string that's OK too,
comment|// it'll cause us not to join a group (the app will presumably join at some future time).
if|if
condition|(
name|windowGroup
operator|.
name|isValid
argument_list|()
operator|&&
name|windowGroup
operator|.
name|canConvert
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
condition|)
name|joinWindowGroup
argument_list|(
name|windowGroup
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QQnxWindow
name|QQnxWindow
operator|::
name|~
name|QQnxWindow
parameter_list|()
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"window ="
operator|<<
name|window
argument_list|()
expr_stmt|;
comment|// Qt should have already deleted the children before deleting the parent.
name|Q_ASSERT
argument_list|(
name|m_childWindows
operator|.
name|size
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// Remove from plugin's window mapper
name|QQnxIntegration
operator|::
name|removeWindow
argument_list|(
name|m_window
argument_list|)
expr_stmt|;
comment|// Remove from parent's Hierarchy.
name|removeFromParent
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_screen
condition|)
name|m_screen
operator|->
name|updateHierarchy
argument_list|()
expr_stmt|;
comment|// Cleanup QNX window and its buffers
name|screen_destroy_window
argument_list|(
name|m_window
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|setGeometry
name|void
name|QQnxWindow
operator|::
name|setGeometry
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|QRect
name|newGeometry
init|=
name|rect
decl_stmt|;
if|if
condition|(
name|shouldMakeFullScreen
argument_list|()
condition|)
name|newGeometry
operator|=
name|screen
argument_list|()
operator|->
name|geometry
argument_list|()
expr_stmt|;
name|setGeometryHelper
argument_list|(
name|newGeometry
argument_list|)
expr_stmt|;
if|if
condition|(
name|isExposed
argument_list|()
condition|)
name|QWindowSystemInterface
operator|::
name|handleExposeEvent
argument_list|(
name|window
argument_list|()
argument_list|,
name|newGeometry
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setGeometryHelper
name|void
name|QQnxWindow
operator|::
name|setGeometryHelper
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"window ="
operator|<<
name|window
argument_list|()
operator|<<
literal|", ("
operator|<<
name|rect
operator|.
name|x
argument_list|()
operator|<<
literal|","
operator|<<
name|rect
operator|.
name|y
argument_list|()
operator|<<
literal|","
operator|<<
name|rect
operator|.
name|width
argument_list|()
operator|<<
literal|","
operator|<<
name|rect
operator|.
name|height
argument_list|()
operator|<<
literal|")"
expr_stmt|;
comment|// Call base class method
name|QPlatformWindow
operator|::
name|setGeometry
argument_list|(
name|rect
argument_list|)
expr_stmt|;
comment|// Set window geometry equal to widget geometry
name|int
name|val
index|[
literal|2
index|]
decl_stmt|;
name|val
index|[
literal|0
index|]
operator|=
name|rect
operator|.
name|x
argument_list|()
expr_stmt|;
name|val
index|[
literal|1
index|]
operator|=
name|rect
operator|.
name|y
argument_list|()
expr_stmt|;
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_iv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_POSITION
argument_list|,
name|val
argument_list|)
argument_list|,
literal|"Failed to set window position"
argument_list|)
expr_stmt|;
name|val
index|[
literal|0
index|]
operator|=
name|rect
operator|.
name|width
argument_list|()
expr_stmt|;
name|val
index|[
literal|1
index|]
operator|=
name|rect
operator|.
name|height
argument_list|()
expr_stmt|;
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_iv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_SIZE
argument_list|,
name|val
argument_list|)
argument_list|,
literal|"Failed to set window size"
argument_list|)
expr_stmt|;
comment|// Set viewport size equal to window size
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_iv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_SOURCE_SIZE
argument_list|,
name|val
argument_list|)
argument_list|,
literal|"Failed to set window source size"
argument_list|)
expr_stmt|;
name|screen_flush_context
argument_list|(
name|m_screenContext
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleGeometryChange
argument_list|(
name|window
argument_list|()
argument_list|,
name|rect
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setVisible
name|void
name|QQnxWindow
operator|::
name|setVisible
parameter_list|(
name|bool
name|visible
parameter_list|)
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"window ="
operator|<<
name|window
argument_list|()
operator|<<
literal|"visible ="
operator|<<
name|visible
expr_stmt|;
if|if
condition|(
name|m_visible
operator|==
name|visible
condition|)
return|return;
comment|// The first time through we join a window group if appropriate.
if|if
condition|(
name|m_parentGroupName
operator|.
name|isNull
argument_list|()
operator|&&
operator|!
name|m_isTopLevel
condition|)
block|{
name|joinWindowGroup
argument_list|(
name|parent
argument_list|()
condition|?
cast|static_cast
argument_list|<
name|QQnxWindow
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|()
argument_list|)
operator|->
name|groupName
argument_list|()
else|:
name|QByteArray
argument_list|(
name|m_screen
operator|->
name|windowGroupName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|m_visible
operator|=
name|visible
expr_stmt|;
name|QQnxWindow
modifier|*
name|root
init|=
name|this
decl_stmt|;
while|while
condition|(
name|root
operator|->
name|m_parentWindow
condition|)
name|root
operator|=
name|root
operator|->
name|m_parentWindow
expr_stmt|;
name|root
operator|->
name|updateVisibility
argument_list|(
name|root
operator|->
name|m_visible
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleExposeEvent
argument_list|(
name|window
argument_list|()
argument_list|,
name|window
argument_list|()
operator|->
name|geometry
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|visible
condition|)
block|{
name|applyWindowState
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Flush the context, otherwise it won't disappear immediately
name|screen_flush_context
argument_list|(
name|m_screenContext
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|updateVisibility
name|void
name|QQnxWindow
operator|::
name|updateVisibility
parameter_list|(
name|bool
name|parentVisible
parameter_list|)
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"parentVisible ="
operator|<<
name|parentVisible
operator|<<
literal|"window ="
operator|<<
name|window
argument_list|()
expr_stmt|;
comment|// Set window visibility
name|int
name|val
init|=
operator|(
name|m_visible
operator|&&
name|parentVisible
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_iv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_VISIBLE
argument_list|,
operator|&
name|val
argument_list|)
argument_list|,
literal|"Failed to set window visibility"
argument_list|)
expr_stmt|;
name|Q_FOREACH
argument_list|(
argument|QQnxWindow *childWindow
argument_list|,
argument|m_childWindows
argument_list|)
name|childWindow
operator|->
name|updateVisibility
argument_list|(
name|m_visible
operator|&&
name|parentVisible
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setOpacity
name|void
name|QQnxWindow
operator|::
name|setOpacity
parameter_list|(
name|qreal
name|level
parameter_list|)
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"window ="
operator|<<
name|window
argument_list|()
operator|<<
literal|"opacity ="
operator|<<
name|level
expr_stmt|;
comment|// Set window global alpha
name|int
name|val
init|=
call|(
name|int
call|)
argument_list|(
name|level
operator|*
literal|255
argument_list|)
decl_stmt|;
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_iv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_GLOBAL_ALPHA
argument_list|,
operator|&
name|val
argument_list|)
argument_list|,
literal|"Failed to set global alpha"
argument_list|)
expr_stmt|;
name|screen_flush_context
argument_list|(
name|m_screenContext
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setExposed
name|void
name|QQnxWindow
operator|::
name|setExposed
parameter_list|(
name|bool
name|exposed
parameter_list|)
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"window ="
operator|<<
name|window
argument_list|()
operator|<<
literal|"expose ="
operator|<<
name|exposed
expr_stmt|;
if|if
condition|(
name|m_exposed
operator|!=
name|exposed
condition|)
block|{
name|m_exposed
operator|=
name|exposed
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleExposeEvent
argument_list|(
name|window
argument_list|()
argument_list|,
name|window
argument_list|()
operator|->
name|geometry
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|isExposed
name|bool
name|QQnxWindow
operator|::
name|isExposed
parameter_list|()
specifier|const
block|{
return|return
name|m_visible
operator|&&
name|m_exposed
return|;
block|}
end_function
begin_function
DECL|function|setBufferSize
name|void
name|QQnxWindow
operator|::
name|setBufferSize
parameter_list|(
specifier|const
name|QSize
modifier|&
name|size
parameter_list|)
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"window ="
operator|<<
name|window
argument_list|()
operator|<<
literal|"size ="
operator|<<
name|size
expr_stmt|;
comment|// libscreen fails when creating empty buffers
specifier|const
name|QSize
name|nonEmptySize
init|=
name|size
operator|.
name|isEmpty
argument_list|()
condition|?
name|QSize
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
else|:
name|size
decl_stmt|;
name|int
name|format
init|=
name|pixelFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|nonEmptySize
operator|==
name|m_bufferSize
operator|||
name|format
operator|==
operator|-
literal|1
condition|)
return|return;
name|Q_SCREEN_CRITICALERROR
argument_list|(
name|screen_set_window_property_iv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_FORMAT
argument_list|,
operator|&
name|format
argument_list|)
argument_list|,
literal|"Failed to set window format"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_bufferSize
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|// destroy buffers first, if resized
name|Q_SCREEN_CRITICALERROR
argument_list|(
name|screen_destroy_window_buffers
argument_list|(
name|m_window
argument_list|)
argument_list|,
literal|"Failed to destroy window buffers"
argument_list|)
expr_stmt|;
block|}
name|int
name|val
index|[
literal|2
index|]
init|=
block|{
name|nonEmptySize
operator|.
name|width
argument_list|()
block|,
name|nonEmptySize
operator|.
name|height
argument_list|()
block|}
decl_stmt|;
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_iv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_BUFFER_SIZE
argument_list|,
name|val
argument_list|)
argument_list|,
literal|"Failed to set window buffer size"
argument_list|)
expr_stmt|;
name|Q_SCREEN_CRITICALERROR
argument_list|(
name|screen_create_window_buffers
argument_list|(
name|m_window
argument_list|,
name|MAX_BUFFER_COUNT
argument_list|)
argument_list|,
literal|"Failed to create window buffers"
argument_list|)
expr_stmt|;
comment|// check if there are any buffers available
name|int
name|bufferCount
init|=
literal|0
decl_stmt|;
name|Q_SCREEN_CRITICALERROR
argument_list|(
name|screen_get_window_property_iv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_RENDER_BUFFER_COUNT
argument_list|,
operator|&
name|bufferCount
argument_list|)
argument_list|,
literal|"Failed to query render buffer count"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufferCount
operator|!=
name|MAX_BUFFER_COUNT
condition|)
block|{
name|qFatal
argument_list|(
literal|"QQnxWindow: invalid buffer count. Expected = %d, got = %d."
argument_list|,
name|MAX_BUFFER_COUNT
argument_list|,
name|bufferCount
argument_list|)
expr_stmt|;
block|}
comment|// Set the transparency. According to QNX technical support, setting the window
comment|// transparency property should always be done *after* creating the window
comment|// buffers in order to guarantee the property is paid attention to.
if|if
condition|(
name|window
argument_list|()
operator|->
name|requestedFormat
argument_list|()
operator|.
name|alphaBufferSize
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// To avoid overhead in the composition manager, disable blending
comment|// when the underlying window buffer doesn't have an alpha channel.
name|val
index|[
literal|0
index|]
operator|=
name|SCREEN_TRANSPARENCY_NONE
expr_stmt|;
block|}
else|else
block|{
comment|// Normal alpha blending. This doesn't commit us to translucency; the
comment|// normal backfill during the painting will contain a fully opaque
comment|// alpha channel unless the user explicitly intervenes to make something
comment|// transparent.
name|val
index|[
literal|0
index|]
operator|=
name|SCREEN_TRANSPARENCY_SOURCE_OVER
expr_stmt|;
block|}
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_iv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_TRANSPARENCY
argument_list|,
name|val
argument_list|)
argument_list|,
literal|"Failed to set window transparency"
argument_list|)
expr_stmt|;
comment|// Cache new buffer size
name|m_bufferSize
operator|=
name|nonEmptySize
expr_stmt|;
name|resetBuffers
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setScreen
name|void
name|QQnxWindow
operator|::
name|setScreen
parameter_list|(
name|QQnxScreen
modifier|*
name|platformScreen
parameter_list|)
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"window ="
operator|<<
name|window
argument_list|()
operator|<<
literal|"platformScreen ="
operator|<<
name|platformScreen
expr_stmt|;
if|if
condition|(
name|platformScreen
operator|==
literal|0
condition|)
block|{
comment|// The screen has been destroyed
name|m_screen
operator|=
literal|0
expr_stmt|;
name|Q_FOREACH
argument_list|(
argument|QQnxWindow *childWindow
argument_list|,
argument|m_childWindows
argument_list|)
block|{
name|childWindow
operator|->
name|setScreen
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|m_screen
operator|==
name|platformScreen
condition|)
return|return;
if|if
condition|(
name|m_screen
condition|)
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"Moving window to different screen"
expr_stmt|;
name|m_screen
operator|->
name|removeWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|QQnxIntegration
operator|::
name|options
argument_list|()
operator|&
name|QQnxIntegration
operator|::
name|RootWindow
operator|)
condition|)
block|{
name|screen_leave_window_group
argument_list|(
name|m_window
argument_list|)
expr_stmt|;
block|}
block|}
name|m_screen
operator|=
name|platformScreen
expr_stmt|;
if|if
condition|(
operator|!
name|m_parentWindow
condition|)
block|{
name|platformScreen
operator|->
name|addWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m_isTopLevel
condition|)
block|{
comment|// Move window to proper screen/display
name|screen_display_t
name|display
init|=
name|platformScreen
operator|->
name|nativeDisplay
argument_list|()
decl_stmt|;
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_pv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_DISPLAY
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|display
argument_list|)
argument_list|,
literal|"Failed to set window display"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Q_FOREACH
argument_list|(
argument|QQnxWindow *childWindow
argument_list|,
argument|m_childWindows
argument_list|)
block|{
comment|// Only subwindows and tooltips need necessarily be moved to another display with the window.
if|if
condition|(
name|window
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Qt
operator|::
name|SubWindow
operator|||
name|window
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Qt
operator|::
name|ToolTip
condition|)
name|childWindow
operator|->
name|setScreen
argument_list|(
name|platformScreen
argument_list|)
expr_stmt|;
block|}
block|}
name|m_screen
operator|->
name|updateHierarchy
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|removeFromParent
name|void
name|QQnxWindow
operator|::
name|removeFromParent
parameter_list|()
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"window ="
operator|<<
name|window
argument_list|()
expr_stmt|;
comment|// Remove from old Hierarchy position
if|if
condition|(
name|m_parentWindow
condition|)
block|{
if|if
condition|(
name|m_parentWindow
operator|->
name|m_childWindows
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
condition|)
name|m_parentWindow
operator|=
literal|0
expr_stmt|;
else|else
name|qFatal
argument_list|(
literal|"QQnxWindow: Window Hierarchy broken; window has parent, but parent hasn't got child."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_screen
condition|)
block|{
name|m_screen
operator|->
name|removeWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setParent
name|void
name|QQnxWindow
operator|::
name|setParent
parameter_list|(
specifier|const
name|QPlatformWindow
modifier|*
name|window
parameter_list|)
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"window ="
operator|<<
name|this
operator|->
name|window
argument_list|()
operator|<<
literal|"platformWindow ="
operator|<<
name|window
expr_stmt|;
comment|// Cast away the const, we need to modify the hierarchy.
name|QQnxWindow
modifier|*
specifier|const
name|newParent
init|=
cast|static_cast
argument_list|<
name|QQnxWindow
operator|*
argument_list|>
argument_list|(
cast|const_cast
argument_list|<
name|QPlatformWindow
operator|*
argument_list|>
argument_list|(
name|window
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|newParent
operator|==
name|m_parentWindow
condition|)
return|return;
if|if
condition|(
name|screen
argument_list|()
operator|->
name|rootWindow
argument_list|()
operator|==
name|this
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Application window cannot be reparented"
expr_stmt|;
return|return;
block|}
name|removeFromParent
argument_list|()
expr_stmt|;
name|m_parentWindow
operator|=
name|newParent
expr_stmt|;
comment|// Add to new hierarchy position.
if|if
condition|(
name|m_parentWindow
condition|)
block|{
if|if
condition|(
name|m_parentWindow
operator|->
name|m_screen
operator|!=
name|m_screen
condition|)
name|setScreen
argument_list|(
name|m_parentWindow
operator|->
name|m_screen
argument_list|)
expr_stmt|;
name|m_parentWindow
operator|->
name|m_childWindows
operator|.
name|push_back
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|joinWindowGroup
argument_list|(
name|m_parentWindow
operator|->
name|groupName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_screen
operator|->
name|addWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|joinWindowGroup
argument_list|(
name|QByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|m_screen
operator|->
name|updateHierarchy
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|raise
name|void
name|QQnxWindow
operator|::
name|raise
parameter_list|()
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"window ="
operator|<<
name|window
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_parentWindow
condition|)
block|{
name|m_parentWindow
operator|->
name|m_childWindows
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|m_parentWindow
operator|->
name|m_childWindows
operator|.
name|push_back
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_screen
operator|->
name|raiseWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|m_screen
operator|->
name|updateHierarchy
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lower
name|void
name|QQnxWindow
operator|::
name|lower
parameter_list|()
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"window ="
operator|<<
name|window
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_parentWindow
condition|)
block|{
name|m_parentWindow
operator|->
name|m_childWindows
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|m_parentWindow
operator|->
name|m_childWindows
operator|.
name|push_front
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_screen
operator|->
name|lowerWindow
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|m_screen
operator|->
name|updateHierarchy
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|requestActivateWindow
name|void
name|QQnxWindow
operator|::
name|requestActivateWindow
parameter_list|()
block|{
name|QQnxWindow
modifier|*
name|focusWindow
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|QGuiApplication
operator|::
name|focusWindow
argument_list|()
condition|)
name|focusWindow
operator|=
cast|static_cast
argument_list|<
name|QQnxWindow
operator|*
argument_list|>
argument_list|(
name|QGuiApplication
operator|::
name|focusWindow
argument_list|()
operator|->
name|handle
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|focusWindow
operator|==
name|this
condition|)
return|return;
if|if
condition|(
name|screen
argument_list|()
operator|->
name|rootWindow
argument_list|()
operator|==
name|this
operator|||
operator|(
name|focusWindow
operator|&&
name|findWindow
argument_list|(
name|focusWindow
operator|->
name|nativeHandle
argument_list|()
argument_list|)
operator|)
condition|)
block|{
comment|// If the focus window is a child, we can just set the focus of our own window
comment|// group to our window handle
name|setFocus
argument_list|(
name|nativeHandle
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// In order to receive focus the parent's window group has to give focus to the
comment|// child. If we have several hierarchy layers, we have to do that several times
name|QQnxWindow
modifier|*
name|currentWindow
init|=
name|this
decl_stmt|;
name|QList
argument_list|<
name|QQnxWindow
modifier|*
argument_list|>
name|windowList
decl_stmt|;
while|while
condition|(
name|currentWindow
condition|)
block|{
name|windowList
operator|.
name|prepend
argument_list|(
name|currentWindow
argument_list|)
expr_stmt|;
comment|// If we find the focus window, we don't have to go further
if|if
condition|(
name|currentWindow
operator|==
name|focusWindow
condition|)
break|break;
if|if
condition|(
name|currentWindow
operator|->
name|parent
argument_list|()
condition|)
block|{
name|currentWindow
operator|=
cast|static_cast
argument_list|<
name|QQnxWindow
operator|*
argument_list|>
argument_list|(
name|currentWindow
operator|->
name|parent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|screen
argument_list|()
operator|->
name|rootWindow
argument_list|()
operator|&&
name|screen
argument_list|()
operator|->
name|rootWindow
argument_list|()
operator|->
name|m_windowGroupName
operator|==
name|currentWindow
operator|->
name|m_parentGroupName
condition|)
block|{
name|currentWindow
operator|=
name|screen
argument_list|()
operator|->
name|rootWindow
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|currentWindow
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// We have to apply the focus from parent to child windows
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|windowList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|windowList
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|->
name|setFocus
argument_list|(
name|windowList
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|nativeHandle
argument_list|()
argument_list|)
expr_stmt|;
name|windowList
operator|.
name|last
argument_list|()
operator|->
name|setFocus
argument_list|(
name|windowList
operator|.
name|last
argument_list|()
operator|->
name|nativeHandle
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|screen_flush_context
argument_list|(
name|m_screenContext
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setFocus
name|void
name|QQnxWindow
operator|::
name|setFocus
parameter_list|(
name|screen_window_t
name|newFocusWindow
parameter_list|)
block|{
name|screen_group_t
name|screenGroup
init|=
literal|0
decl_stmt|;
name|screen_get_window_property_pv
argument_list|(
name|nativeHandle
argument_list|()
argument_list|,
name|SCREEN_PROPERTY_GROUP
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|screenGroup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|screenGroup
condition|)
block|{
name|screen_set_group_property_pv
argument_list|(
name|screenGroup
argument_list|,
name|SCREEN_PROPERTY_KEYBOARD_FOCUS
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|*
operator|*
argument_list|>
argument_list|(
operator|&
name|newFocusWindow
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setWindowState
name|void
name|QQnxWindow
operator|::
name|setWindowState
parameter_list|(
name|Qt
operator|::
name|WindowState
name|state
parameter_list|)
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"state ="
operator|<<
name|state
expr_stmt|;
comment|// Prevent two calls with Qt::WindowFullScreen from changing m_unmaximizedGeometry
if|if
condition|(
name|m_windowState
operator|==
name|state
condition|)
return|return;
name|m_windowState
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|m_visible
condition|)
name|applyWindowState
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|propagateSizeHints
name|void
name|QQnxWindow
operator|::
name|propagateSizeHints
parameter_list|()
block|{
comment|// nothing to do; silence base class warning
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|": ignored"
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setMMRendererWindowName
name|void
name|QQnxWindow
operator|::
name|setMMRendererWindowName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|m_mmRendererWindowName
operator|=
name|name
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setMMRendererWindow
name|void
name|QQnxWindow
operator|::
name|setMMRendererWindow
parameter_list|(
name|screen_window_t
name|handle
parameter_list|)
block|{
name|m_mmRendererWindow
operator|=
name|handle
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clearMMRendererWindow
name|void
name|QQnxWindow
operator|::
name|clearMMRendererWindow
parameter_list|()
block|{
name|m_mmRendererWindowName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_mmRendererWindow
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|findWindow
name|QQnxWindow
modifier|*
name|QQnxWindow
operator|::
name|findWindow
parameter_list|(
name|screen_window_t
name|windowHandle
parameter_list|)
block|{
if|if
condition|(
name|m_window
operator|==
name|windowHandle
condition|)
return|return
name|this
return|;
name|Q_FOREACH
argument_list|(
argument|QQnxWindow *window
argument_list|,
argument|m_childWindows
argument_list|)
block|{
name|QQnxWindow
modifier|*
specifier|const
name|result
init|=
name|window
operator|->
name|findWindow
argument_list|(
name|windowHandle
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|minimize
name|void
name|QQnxWindow
operator|::
name|minimize
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_BLACKBERRY_TABLET
argument_list|)
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
expr_stmt|;
name|pps_encoder_t
name|encoder
decl_stmt|;
name|pps_encoder_initialize
argument_list|(
operator|&
name|encoder
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|pps_encoder_add_string
argument_list|(
operator|&
name|encoder
argument_list|,
literal|"msg"
argument_list|,
literal|"minimizeWindow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|navigator_raw_write
argument_list|(
name|pps_encoder_buffer
argument_list|(
operator|&
name|encoder
argument_list|)
argument_list|,
name|pps_encoder_length
argument_list|(
operator|&
name|encoder
argument_list|)
argument_list|)
operator|!=
name|BPS_SUCCESS
condition|)
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"navigator_raw_write failed:"
operator|<<
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
name|pps_encoder_cleanup
argument_list|(
operator|&
name|encoder
argument_list|)
expr_stmt|;
else|#
directive|else
name|qWarning
argument_list|(
literal|"Qt::WindowMinimized is not supported by this OS version"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|setRotation
name|void
name|QQnxWindow
operator|::
name|setRotation
parameter_list|(
name|int
name|rotation
parameter_list|)
block|{
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"angle ="
operator|<<
name|rotation
expr_stmt|;
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_iv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_ROTATION
argument_list|,
operator|&
name|rotation
argument_list|)
argument_list|,
literal|"Failed to set window rotation"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initWindow
name|void
name|QQnxWindow
operator|::
name|initWindow
parameter_list|()
block|{
comment|// Alpha channel is always pre-multiplied if present
name|int
name|val
init|=
name|SCREEN_PRE_MULTIPLIED_ALPHA
decl_stmt|;
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_iv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_ALPHA_MODE
argument_list|,
operator|&
name|val
argument_list|)
argument_list|,
literal|"Failed to set alpha mode"
argument_list|)
expr_stmt|;
comment|// Set the window swap interval
name|val
operator|=
literal|1
expr_stmt|;
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_iv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_SWAP_INTERVAL
argument_list|,
operator|&
name|val
argument_list|)
argument_list|,
literal|"Failed to set swap interval"
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
argument_list|()
operator|->
name|flags
argument_list|()
operator|&
name|Qt
operator|::
name|WindowDoesNotAcceptFocus
condition|)
block|{
name|val
operator|=
name|SCREEN_SENSITIVITY_NO_FOCUS
expr_stmt|;
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_iv
argument_list|(
name|m_window
argument_list|,
name|SCREEN_PROPERTY_SENSITIVITY
argument_list|,
operator|&
name|val
argument_list|)
argument_list|,
literal|"Failed to set window sensitivity"
argument_list|)
expr_stmt|;
block|}
name|QQnxScreen
modifier|*
name|platformScreen
init|=
cast|static_cast
argument_list|<
name|QQnxScreen
operator|*
argument_list|>
argument_list|(
name|window
argument_list|()
operator|->
name|screen
argument_list|()
operator|->
name|handle
argument_list|()
argument_list|)
decl_stmt|;
name|setScreen
argument_list|(
name|platformScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|Qt
operator|::
name|CoverWindow
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_BLACKBERRY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_BLACKBERRY_TABLET
argument_list|)
if|if
condition|(
name|platformScreen
operator|->
name|rootWindow
argument_list|()
condition|)
block|{
name|screen_set_window_property_pv
argument_list|(
name|m_screen
operator|->
name|rootWindow
argument_list|()
operator|->
name|nativeHandle
argument_list|()
argument_list|,
name|SCREEN_PROPERTY_ALTERNATE_WINDOW
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|m_window
argument_list|)
expr_stmt|;
name|m_cover
operator|.
name|reset
argument_list|(
operator|new
name|QQnxNavigatorCover
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"No root window for cover window"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m_exposed
operator|=
literal|false
expr_stmt|;
block|}
comment|// Add window to plugin's window mapper
name|QQnxIntegration
operator|::
name|addWindow
argument_list|(
name|m_window
argument_list|,
name|window
argument_list|()
argument_list|)
expr_stmt|;
comment|// Qt never calls these setters after creating the window, so we need to do that ourselves here
name|setWindowState
argument_list|(
name|window
argument_list|()
operator|->
name|windowState
argument_list|()
argument_list|)
expr_stmt|;
name|setOpacity
argument_list|(
name|window
argument_list|()
operator|->
name|opacity
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
argument_list|()
operator|->
name|parent
argument_list|()
operator|&&
name|window
argument_list|()
operator|->
name|parent
argument_list|()
operator|->
name|handle
argument_list|()
condition|)
name|setParent
argument_list|(
name|window
argument_list|()
operator|->
name|parent
argument_list|()
operator|->
name|handle
argument_list|()
argument_list|)
expr_stmt|;
name|setGeometryHelper
argument_list|(
name|shouldMakeFullScreen
argument_list|()
condition|?
name|screen
argument_list|()
operator|->
name|geometry
argument_list|()
else|:
name|window
argument_list|()
operator|->
name|geometry
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|createWindowGroup
name|void
name|QQnxWindow
operator|::
name|createWindowGroup
parameter_list|()
block|{
comment|// Generate a random window group name
name|m_windowGroupName
operator|=
name|QUuid
operator|::
name|createUuid
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
comment|// Create window group so child windows can be parented by container window
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_create_window_group
argument_list|(
name|m_window
argument_list|,
name|m_windowGroupName
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|,
literal|"Failed to create window group"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|joinWindowGroup
name|void
name|QQnxWindow
operator|::
name|joinWindowGroup
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|groupName
parameter_list|)
block|{
name|bool
name|changed
init|=
literal|false
decl_stmt|;
name|qWindowDebug
argument_list|()
operator|<<
name|Q_FUNC_INFO
operator|<<
literal|"group:"
operator|<<
name|groupName
expr_stmt|;
if|if
condition|(
operator|!
name|groupName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|groupName
operator|!=
name|m_parentGroupName
condition|)
block|{
name|screen_join_window_group
argument_list|(
name|m_window
argument_list|,
name|groupName
argument_list|)
expr_stmt|;
name|m_parentGroupName
operator|=
name|groupName
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|m_parentGroupName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|screen_leave_window_group
argument_list|(
name|m_window
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
block|}
comment|// By setting to an empty string we'll stop setVisible from trying to
comment|// change our group, we want that to happen only if joinWindowGroup has
comment|// never been called.  This allows windows to be created that are not initially
comment|// part of any group.
name|m_parentGroupName
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
name|screen_flush_context
argument_list|(
name|m_screenContext
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateZorder
name|void
name|QQnxWindow
operator|::
name|updateZorder
parameter_list|(
name|int
modifier|&
name|topZorder
parameter_list|)
block|{
name|updateZorder
argument_list|(
name|m_window
argument_list|,
name|topZorder
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_mmRendererWindow
condition|)
name|updateZorder
argument_list|(
name|m_mmRendererWindow
argument_list|,
name|topZorder
argument_list|)
expr_stmt|;
name|Q_FOREACH
argument_list|(
argument|QQnxWindow *childWindow
argument_list|,
argument|m_childWindows
argument_list|)
name|childWindow
operator|->
name|updateZorder
argument_list|(
name|topZorder
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateZorder
name|void
name|QQnxWindow
operator|::
name|updateZorder
parameter_list|(
name|screen_window_t
name|window
parameter_list|,
name|int
modifier|&
name|topZorder
parameter_list|)
block|{
name|Q_SCREEN_CHECKERROR
argument_list|(
name|screen_set_window_property_iv
argument_list|(
name|window
argument_list|,
name|SCREEN_PROPERTY_ZORDER
argument_list|,
operator|&
name|topZorder
argument_list|)
argument_list|,
literal|"Failed to set window z-order"
argument_list|)
expr_stmt|;
name|topZorder
operator|++
expr_stmt|;
block|}
end_function
begin_function
DECL|function|applyWindowState
name|void
name|QQnxWindow
operator|::
name|applyWindowState
parameter_list|()
block|{
switch|switch
condition|(
name|m_windowState
condition|)
block|{
comment|// WindowActive is not an accepted parameter according to the docs
case|case
name|Qt
operator|::
name|WindowActive
case|:
return|return;
case|case
name|Qt
operator|::
name|WindowMinimized
case|:
name|minimize
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_unmaximizedGeometry
operator|.
name|isValid
argument_list|()
condition|)
name|setGeometry
argument_list|(
name|m_unmaximizedGeometry
argument_list|)
expr_stmt|;
else|else
name|setGeometry
argument_list|(
name|m_screen
operator|->
name|geometry
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|WindowMaximized
case|:
case|case
name|Qt
operator|::
name|WindowFullScreen
case|:
name|m_unmaximizedGeometry
operator|=
name|geometry
argument_list|()
expr_stmt|;
name|setGeometry
argument_list|(
name|m_windowState
operator|==
name|Qt
operator|::
name|WindowMaximized
condition|?
name|m_screen
operator|->
name|availableGeometry
argument_list|()
else|:
name|m_screen
operator|->
name|geometry
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Qt
operator|::
name|WindowNoState
case|:
if|if
condition|(
name|m_unmaximizedGeometry
operator|.
name|isValid
argument_list|()
condition|)
name|setGeometry
argument_list|(
name|m_unmaximizedGeometry
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|windowPosted
name|void
name|QQnxWindow
operator|::
name|windowPosted
parameter_list|()
block|{
if|if
condition|(
name|m_cover
condition|)
name|m_cover
operator|->
name|updateCover
argument_list|()
expr_stmt|;
name|qqnxLgmonFramePosted
argument_list|(
name|m_cover
argument_list|)
expr_stmt|;
comment|// for performance measurements
block|}
end_function
begin_function
DECL|function|shouldMakeFullScreen
name|bool
name|QQnxWindow
operator|::
name|shouldMakeFullScreen
parameter_list|()
specifier|const
block|{
return|return
operator|(
operator|(
name|screen
argument_list|()
operator|->
name|rootWindow
argument_list|()
operator|==
name|this
operator|)
operator|&&
operator|(
name|QQnxIntegration
operator|::
name|options
argument_list|()
operator|&
name|QQnxIntegration
operator|::
name|FullScreenApplication
operator|)
operator|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
