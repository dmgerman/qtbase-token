begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qxcbclipboard.h"
end_include
begin_include
include|#
directive|include
file|"qxcbconnection.h"
end_include
begin_include
include|#
directive|include
file|"qxcbscreen.h"
end_include
begin_include
include|#
directive|include
file|"qxcbmime.h"
end_include
begin_include
include|#
directive|include
file|<private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<QElapsedTimer>
end_include
begin_include
include|#
directive|include
file|<QtCore/QDebug>
end_include
begin_define
DECL|macro|class
define|#
directive|define
name|class
value|class_name
end_define
begin_comment
DECL|macro|class
comment|// Workaround XCB-ICCCM 3.8 breakage
end_comment
begin_include
include|#
directive|include
file|<xcb/xcb_icccm.h>
end_include
begin_undef
DECL|macro|class
undef|#
directive|undef
name|class
end_undef
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
end_ifndef
begin_class
DECL|class|QXcbClipboardMime
class|class
name|QXcbClipboardMime
super|:
specifier|public
name|QXcbMime
block|{
name|Q_OBJECT
public|public:
DECL|function|QXcbClipboardMime
name|QXcbClipboardMime
parameter_list|(
name|QClipboard
operator|::
name|Mode
name|mode
parameter_list|,
name|QXcbClipboard
modifier|*
name|clipboard
parameter_list|)
member_init_list|:
name|QXcbMime
argument_list|()
member_init_list|,
name|m_clipboard
argument_list|(
name|clipboard
argument_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QClipboard
operator|::
name|Selection
case|:
name|modeAtom
operator|=
name|XCB_ATOM_PRIMARY
expr_stmt|;
break|break;
case|case
name|QClipboard
operator|::
name|Clipboard
case|:
name|modeAtom
operator|=
name|m_clipboard
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIPBOARD
argument_list|)
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QXcbClipboardMime: Internal error: Unsupported clipboard mode"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
DECL|function|reset
name|void
name|reset
parameter_list|()
block|{
name|formatList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|function|isEmpty
name|bool
name|isEmpty
parameter_list|()
specifier|const
block|{
return|return
name|m_clipboard
operator|->
name|getSelectionOwner
argument_list|(
name|modeAtom
argument_list|)
operator|==
name|XCB_NONE
return|;
block|}
protected|protected:
name|QStringList
name|formats_sys
parameter_list|()
specifier|const
name|Q_DECL_OVERRIDE
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
name|QStringList
argument_list|()
return|;
if|if
condition|(
operator|!
name|formatList
operator|.
name|count
argument_list|()
condition|)
block|{
name|QXcbClipboardMime
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QXcbClipboardMime
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|// get the list of targets from the current clipboard owner - we do this
comment|// once so that multiple calls to this function don't require multiple
comment|// server round trips...
name|that
operator|->
name|format_atoms
operator|=
name|m_clipboard
operator|->
name|getDataInFormat
argument_list|(
name|modeAtom
argument_list|,
name|m_clipboard
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|TARGETS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_atoms
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|const
name|xcb_atom_t
modifier|*
name|targets
init|=
operator|(
specifier|const
name|xcb_atom_t
operator|*
operator|)
name|format_atoms
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|format_atoms
operator|.
name|size
argument_list|()
operator|/
sizeof|sizeof
argument_list|(
name|xcb_atom_t
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|targets
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|QString
name|format
init|=
name|mimeAtomToString
argument_list|(
name|m_clipboard
operator|->
name|connection
argument_list|()
argument_list|,
name|targets
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|formatList
operator|.
name|contains
argument_list|(
name|format
argument_list|)
condition|)
name|that
operator|->
name|formatList
operator|.
name|append
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|formatList
return|;
block|}
name|bool
name|hasFormat_sys
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
name|Q_DECL_OVERRIDE
block|{
name|QStringList
name|list
init|=
name|formats
argument_list|()
decl_stmt|;
return|return
name|list
operator|.
name|contains
argument_list|(
name|format
argument_list|)
return|;
block|}
name|QVariant
name|retrieveData_sys
parameter_list|(
specifier|const
name|QString
modifier|&
name|fmt
parameter_list|,
name|QVariant
operator|::
name|Type
name|requestedType
parameter_list|)
specifier|const
name|Q_DECL_OVERRIDE
block|{
if|if
condition|(
name|fmt
operator|.
name|isEmpty
argument_list|()
operator|||
name|isEmpty
argument_list|()
condition|)
return|return
name|QByteArray
argument_list|()
return|;
operator|(
name|void
operator|)
name|formats
argument_list|()
expr_stmt|;
comment|// trigger update of format list
name|QVector
argument_list|<
name|xcb_atom_t
argument_list|>
name|atoms
decl_stmt|;
specifier|const
name|xcb_atom_t
modifier|*
name|targets
init|=
operator|(
specifier|const
name|xcb_atom_t
operator|*
operator|)
name|format_atoms
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|format_atoms
operator|.
name|size
argument_list|()
operator|/
sizeof|sizeof
argument_list|(
name|xcb_atom_t
argument_list|)
decl_stmt|;
name|atoms
operator|.
name|reserve
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
name|atoms
operator|.
name|append
argument_list|(
name|targets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|QByteArray
name|encoding
decl_stmt|;
name|xcb_atom_t
name|fmtatom
init|=
name|mimeAtomForFormat
argument_list|(
name|m_clipboard
operator|->
name|connection
argument_list|()
argument_list|,
name|fmt
argument_list|,
name|requestedType
argument_list|,
name|atoms
argument_list|,
operator|&
name|encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|fmtatom
operator|==
literal|0
condition|)
return|return
name|QVariant
argument_list|()
return|;
return|return
name|mimeConvertToFormat
argument_list|(
name|m_clipboard
operator|->
name|connection
argument_list|()
argument_list|,
name|fmtatom
argument_list|,
name|m_clipboard
operator|->
name|getDataInFormat
argument_list|(
name|modeAtom
argument_list|,
name|fmtatom
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|requestedType
argument_list|,
name|encoding
argument_list|)
return|;
block|}
private|private:
DECL|member|modeAtom
name|xcb_atom_t
name|modeAtom
decl_stmt|;
DECL|member|m_clipboard
name|QXcbClipboard
modifier|*
name|m_clipboard
decl_stmt|;
DECL|member|formatList
name|QStringList
name|formatList
decl_stmt|;
DECL|member|format_atoms
name|QByteArray
name|format_atoms
decl_stmt|;
block|}
class|;
end_class
begin_class_decl
class_decl|class
name|INCRTransaction
class_decl|;
end_class_decl
begin_typedef
DECL|typedef|TransactionMap
typedef|typedef
name|QMap
argument_list|<
name|xcb_window_t
argument_list|,
name|INCRTransaction
modifier|*
argument_list|>
name|TransactionMap
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|transactions
specifier|static
name|TransactionMap
modifier|*
name|transactions
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
comment|//#define INCR_DEBUG
end_comment
begin_class
DECL|class|INCRTransaction
class|class
name|INCRTransaction
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
DECL|function|INCRTransaction
name|INCRTransaction
parameter_list|(
name|QXcbConnection
modifier|*
name|c
parameter_list|,
name|xcb_window_t
name|w
parameter_list|,
name|xcb_atom_t
name|p
parameter_list|,
name|QByteArray
name|d
parameter_list|,
name|uint
name|i
parameter_list|,
name|xcb_atom_t
name|t
parameter_list|,
name|int
name|f
parameter_list|,
name|int
name|to
parameter_list|)
member_init_list|:
name|conn
argument_list|(
name|c
argument_list|)
member_init_list|,
name|win
argument_list|(
name|w
argument_list|)
member_init_list|,
name|property
argument_list|(
name|p
argument_list|)
member_init_list|,
name|data
argument_list|(
name|d
argument_list|)
member_init_list|,
name|increment
argument_list|(
name|i
argument_list|)
member_init_list|,
name|target
argument_list|(
name|t
argument_list|)
member_init_list|,
name|format
argument_list|(
name|f
argument_list|)
member_init_list|,
name|timeout
argument_list|(
name|to
argument_list|)
member_init_list|,
name|offset
argument_list|(
literal|0
argument_list|)
block|{
specifier|const
name|quint32
name|values
index|[]
init|=
block|{
name|XCB_EVENT_MASK_PROPERTY_CHANGE
block|}
decl_stmt|;
name|xcb_change_window_attributes
argument_list|(
name|conn
operator|->
name|xcb_connection
argument_list|()
argument_list|,
name|win
argument_list|,
name|XCB_CW_EVENT_MASK
argument_list|,
name|values
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|transactions
condition|)
block|{
ifdef|#
directive|ifdef
name|INCR_DEBUG
name|qDebug
argument_list|(
literal|"INCRTransaction: creating the TransactionMap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|transactions
operator|=
operator|new
name|TransactionMap
expr_stmt|;
name|conn
operator|->
name|clipboard
argument_list|()
operator|->
name|setProcessIncr
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|transactions
operator|->
name|insert
argument_list|(
name|win
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|abort_timer
operator|=
name|startTimer
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
DECL|function|~INCRTransaction
name|~
name|INCRTransaction
parameter_list|()
block|{
if|if
condition|(
name|abort_timer
condition|)
name|killTimer
argument_list|(
name|abort_timer
argument_list|)
expr_stmt|;
name|abort_timer
operator|=
literal|0
expr_stmt|;
name|transactions
operator|->
name|remove
argument_list|(
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|transactions
operator|->
name|isEmpty
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|INCR_DEBUG
name|qDebug
argument_list|(
literal|"INCRTransaction: no more INCR transactions left in the TransactionMap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|delete
name|transactions
expr_stmt|;
name|transactions
operator|=
literal|0
expr_stmt|;
name|conn
operator|->
name|clipboard
argument_list|()
operator|->
name|setProcessIncr
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|updateIncrProperty
name|void
name|updateIncrProperty
parameter_list|(
name|xcb_property_notify_event_t
modifier|*
name|event
parameter_list|,
name|bool
modifier|&
name|accepted
parameter_list|)
block|{
name|xcb_connection_t
modifier|*
name|c
init|=
name|conn
operator|->
name|xcb_connection
argument_list|()
decl_stmt|;
if|if
condition|(
name|event
operator|->
name|atom
operator|==
name|property
operator|&&
name|event
operator|->
name|state
operator|==
name|XCB_PROPERTY_DELETE
condition|)
block|{
name|accepted
operator|=
literal|true
expr_stmt|;
comment|// restart the timer
if|if
condition|(
name|abort_timer
condition|)
name|killTimer
argument_list|(
name|abort_timer
argument_list|)
expr_stmt|;
name|abort_timer
operator|=
name|startTimer
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|unsigned
name|int
name|bytes_left
init|=
name|data
operator|.
name|size
argument_list|()
operator|-
name|offset
decl_stmt|;
if|if
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|bytes_to_send
init|=
name|qMin
argument_list|(
name|increment
argument_list|,
name|bytes_left
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|INCR_DEBUG
name|qDebug
argument_list|(
literal|"INCRTransaction: sending %d bytes, %d remaining (INCR transaction %p)"
argument_list|,
name|bytes_to_send
argument_list|,
name|bytes_left
operator|-
name|bytes_to_send
argument_list|,
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|dataSize
init|=
name|bytes_to_send
operator|/
operator|(
name|format
operator|/
literal|8
operator|)
decl_stmt|;
name|xcb_change_property
argument_list|(
name|c
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|win
argument_list|,
name|property
argument_list|,
name|target
argument_list|,
name|format
argument_list|,
name|dataSize
argument_list|,
name|data
operator|.
name|constData
argument_list|()
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|bytes_to_send
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INCR_DEBUG
name|qDebug
argument_list|(
literal|"INCRTransaction: INCR transaction %p completed"
argument_list|,
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xcb_change_property
argument_list|(
name|c
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|win
argument_list|,
name|property
argument_list|,
name|target
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
specifier|const
name|quint32
name|values
index|[]
init|=
block|{
name|XCB_EVENT_MASK_NO_EVENT
block|}
decl_stmt|;
name|xcb_change_window_attributes
argument_list|(
name|conn
operator|->
name|xcb_connection
argument_list|()
argument_list|,
name|win
argument_list|,
name|XCB_CW_EVENT_MASK
argument_list|,
name|values
argument_list|)
expr_stmt|;
comment|// self destroy
operator|delete
name|this
expr_stmt|;
block|}
block|}
block|}
protected|protected:
name|void
name|timerEvent
parameter_list|(
name|QTimerEvent
modifier|*
name|ev
parameter_list|)
name|Q_DECL_OVERRIDE
block|{
if|if
condition|(
name|ev
operator|->
name|timerId
argument_list|()
operator|==
name|abort_timer
condition|)
block|{
comment|// this can happen when the X client we are sending data
comment|// to decides to exit (normally or abnormally)
ifdef|#
directive|ifdef
name|INCR_DEBUG
name|qDebug
argument_list|(
literal|"INCRTransaction: Timed out while sending data to %p"
argument_list|,
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|delete
name|this
expr_stmt|;
block|}
block|}
private|private:
DECL|member|conn
name|QXcbConnection
modifier|*
name|conn
decl_stmt|;
DECL|member|win
name|xcb_window_t
name|win
decl_stmt|;
DECL|member|property
name|xcb_atom_t
name|property
decl_stmt|;
DECL|member|data
name|QByteArray
name|data
decl_stmt|;
DECL|member|increment
name|uint
name|increment
decl_stmt|;
DECL|member|target
name|xcb_atom_t
name|target
decl_stmt|;
DECL|member|format
name|int
name|format
decl_stmt|;
DECL|member|timeout
name|int
name|timeout
decl_stmt|;
DECL|member|offset
name|uint
name|offset
decl_stmt|;
DECL|member|abort_timer
name|int
name|abort_timer
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|member|clipboard_timeout
specifier|const
name|int
name|QXcbClipboard
operator|::
name|clipboard_timeout
init|=
literal|5000
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QXcbClipboard
name|QXcbClipboard
operator|::
name|QXcbClipboard
parameter_list|(
name|QXcbConnection
modifier|*
name|c
parameter_list|)
member_init_list|:
name|QXcbObject
argument_list|(
name|c
argument_list|)
member_init_list|,
name|QPlatformClipboard
argument_list|()
member_init_list|,
name|m_requestor
argument_list|(
name|XCB_NONE
argument_list|)
member_init_list|,
name|m_owner
argument_list|(
name|XCB_NONE
argument_list|)
member_init_list|,
name|m_incr_active
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_clipboard_closing
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_incr_receive_time
argument_list|(
literal|0
argument_list|)
block|{
name|Q_ASSERT
argument_list|(
name|QClipboard
operator|::
name|Clipboard
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|QClipboard
operator|::
name|Selection
operator|==
literal|1
argument_list|)
expr_stmt|;
name|m_xClipboard
index|[
name|QClipboard
operator|::
name|Clipboard
index|]
operator|=
literal|0
expr_stmt|;
name|m_xClipboard
index|[
name|QClipboard
operator|::
name|Selection
index|]
operator|=
literal|0
expr_stmt|;
name|m_clientClipboard
index|[
name|QClipboard
operator|::
name|Clipboard
index|]
operator|=
literal|0
expr_stmt|;
name|m_clientClipboard
index|[
name|QClipboard
operator|::
name|Selection
index|]
operator|=
literal|0
expr_stmt|;
name|m_timestamp
index|[
name|QClipboard
operator|::
name|Clipboard
index|]
operator|=
name|XCB_CURRENT_TIME
expr_stmt|;
name|m_timestamp
index|[
name|QClipboard
operator|::
name|Selection
index|]
operator|=
name|XCB_CURRENT_TIME
expr_stmt|;
name|m_owner
operator|=
name|connection
argument_list|()
operator|->
name|getQtSelectionOwner
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|QByteArray
name|ba
argument_list|(
literal|"Qt clipboard window"
argument_list|)
decl_stmt|;
name|Q_XCB_CALL
argument_list|(
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|m_owner
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_NET_WM_NAME
argument_list|)
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|UTF8_STRING
argument_list|)
argument_list|,
literal|8
argument_list|,
name|ba
operator|.
name|length
argument_list|()
argument_list|,
name|ba
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|connection
argument_list|()
operator|->
name|hasXFixes
argument_list|()
condition|)
block|{
specifier|const
name|uint32_t
name|mask
init|=
name|XCB_XFIXES_SELECTION_EVENT_MASK_SET_SELECTION_OWNER
operator||
name|XCB_XFIXES_SELECTION_EVENT_MASK_SELECTION_WINDOW_DESTROY
operator||
name|XCB_XFIXES_SELECTION_EVENT_MASK_SELECTION_CLIENT_CLOSE
decl_stmt|;
name|Q_XCB_CALL
argument_list|(
name|xcb_xfixes_select_selection_input_checked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|m_owner
argument_list|,
name|XCB_ATOM_PRIMARY
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|Q_XCB_CALL
argument_list|(
name|xcb_xfixes_select_selection_input_checked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|m_owner
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIPBOARD
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~QXcbClipboard
name|QXcbClipboard
operator|::
name|~
name|QXcbClipboard
parameter_list|()
block|{
name|m_clipboard_closing
operator|=
literal|true
expr_stmt|;
comment|// Transfer the clipboard content to the clipboard manager if we own a selection
if|if
condition|(
name|m_timestamp
index|[
name|QClipboard
operator|::
name|Clipboard
index|]
operator|!=
name|XCB_CURRENT_TIME
operator|||
name|m_timestamp
index|[
name|QClipboard
operator|::
name|Selection
index|]
operator|!=
name|XCB_CURRENT_TIME
condition|)
block|{
comment|// First we check if there is a clipboard manager.
name|xcb_get_selection_owner_cookie_t
name|cookie
init|=
name|xcb_get_selection_owner
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIPBOARD_MANAGER
argument_list|)
argument_list|)
decl_stmt|;
name|xcb_get_selection_owner_reply_t
modifier|*
name|reply
init|=
name|xcb_get_selection_owner_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|cookie
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
operator|&&
name|reply
operator|->
name|owner
operator|!=
name|XCB_NONE
condition|)
block|{
comment|// we delete the property so the manager saves all TARGETS.
name|xcb_delete_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|m_owner
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_QT_SELECTION
argument_list|)
argument_list|)
expr_stmt|;
name|xcb_convert_selection
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|m_owner
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIPBOARD_MANAGER
argument_list|)
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|SAVE_TARGETS
argument_list|)
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_QT_SELECTION
argument_list|)
argument_list|,
name|connection
argument_list|()
operator|->
name|time
argument_list|()
argument_list|)
expr_stmt|;
name|connection
argument_list|()
operator|->
name|sync
argument_list|()
expr_stmt|;
comment|// waiting until the clipboard manager fetches the content.
if|if
condition|(
operator|!
name|waitForClipboardEvent
argument_list|(
name|m_owner
argument_list|,
name|XCB_SELECTION_NOTIFY
argument_list|,
name|clipboard_timeout
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbClipboard: Unable to receive an event from the "
literal|"clipboard manager in a reasonable time"
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|incrTransactionPeeker
name|void
name|QXcbClipboard
operator|::
name|incrTransactionPeeker
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|ge
parameter_list|,
name|bool
modifier|&
name|accepted
parameter_list|)
block|{
name|uint
name|response_type
init|=
name|ge
operator|->
name|response_type
operator|&
operator|~
literal|0x80
decl_stmt|;
if|if
condition|(
name|response_type
operator|==
name|XCB_PROPERTY_NOTIFY
condition|)
block|{
name|xcb_property_notify_event_t
modifier|*
name|event
init|=
operator|(
name|xcb_property_notify_event_t
operator|*
operator|)
name|ge
decl_stmt|;
name|TransactionMap
operator|::
name|Iterator
name|it
init|=
name|transactions
operator|->
name|find
argument_list|(
name|event
operator|->
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|transactions
operator|->
name|end
argument_list|()
condition|)
block|{
operator|(
operator|*
name|it
operator|)
operator|->
name|updateIncrProperty
argument_list|(
name|event
argument_list|,
name|accepted
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|getSelectionOwner
name|xcb_window_t
name|QXcbClipboard
operator|::
name|getSelectionOwner
parameter_list|(
name|xcb_atom_t
name|atom
parameter_list|)
specifier|const
block|{
return|return
name|connection
argument_list|()
operator|->
name|getSelectionOwner
argument_list|(
name|atom
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|atomForMode
name|xcb_atom_t
name|QXcbClipboard
operator|::
name|atomForMode
parameter_list|(
name|QClipboard
operator|::
name|Mode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mode
operator|==
name|QClipboard
operator|::
name|Clipboard
condition|)
return|return
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIPBOARD
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|QClipboard
operator|::
name|Selection
condition|)
return|return
name|XCB_ATOM_PRIMARY
return|;
return|return
name|XCB_NONE
return|;
block|}
end_function
begin_function
DECL|function|modeForAtom
name|QClipboard
operator|::
name|Mode
name|QXcbClipboard
operator|::
name|modeForAtom
parameter_list|(
name|xcb_atom_t
name|a
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|a
operator|==
name|XCB_ATOM_PRIMARY
condition|)
return|return
name|QClipboard
operator|::
name|Selection
return|;
if|if
condition|(
name|a
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIPBOARD
argument_list|)
condition|)
return|return
name|QClipboard
operator|::
name|Clipboard
return|;
comment|// not supported enum value, used to detect errors
return|return
name|QClipboard
operator|::
name|FindBuffer
return|;
block|}
end_function
begin_function
DECL|function|mimeData
name|QMimeData
modifier|*
name|QXcbClipboard
operator|::
name|mimeData
parameter_list|(
name|QClipboard
operator|::
name|Mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|>
name|QClipboard
operator|::
name|Selection
condition|)
return|return
literal|0
return|;
name|xcb_window_t
name|clipboardOwner
init|=
name|getSelectionOwner
argument_list|(
name|atomForMode
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|clipboardOwner
operator|==
name|owner
argument_list|()
condition|)
block|{
return|return
name|m_clientClipboard
index|[
name|mode
index|]
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|m_xClipboard
index|[
name|mode
index|]
condition|)
name|m_xClipboard
index|[
name|mode
index|]
operator|=
operator|new
name|QXcbClipboardMime
argument_list|(
name|mode
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return
name|m_xClipboard
index|[
name|mode
index|]
return|;
block|}
block|}
end_function
begin_function
DECL|function|setMimeData
name|void
name|QXcbClipboard
operator|::
name|setMimeData
parameter_list|(
name|QMimeData
modifier|*
name|data
parameter_list|,
name|QClipboard
operator|::
name|Mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|>
name|QClipboard
operator|::
name|Selection
condition|)
return|return;
name|QXcbClipboardMime
modifier|*
name|xClipboard
init|=
literal|0
decl_stmt|;
comment|// verify if there is data to be cleared on global X Clipboard.
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|xClipboard
operator|=
name|qobject_cast
argument_list|<
name|QXcbClipboardMime
operator|*
argument_list|>
argument_list|(
name|mimeData
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xClipboard
condition|)
block|{
if|if
condition|(
name|xClipboard
operator|->
name|isEmpty
argument_list|()
condition|)
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|xClipboard
operator|&&
operator|(
name|m_clientClipboard
index|[
name|mode
index|]
operator|==
name|data
operator|)
condition|)
return|return;
name|xcb_atom_t
name|modeAtom
init|=
name|atomForMode
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|xcb_window_t
name|newOwner
init|=
name|XCB_NONE
decl_stmt|;
if|if
condition|(
name|m_clientClipboard
index|[
name|mode
index|]
condition|)
block|{
if|if
condition|(
name|m_clientClipboard
index|[
name|QClipboard
operator|::
name|Clipboard
index|]
operator|!=
name|m_clientClipboard
index|[
name|QClipboard
operator|::
name|Selection
index|]
condition|)
operator|delete
name|m_clientClipboard
index|[
name|mode
index|]
expr_stmt|;
name|m_clientClipboard
index|[
name|mode
index|]
operator|=
literal|0
expr_stmt|;
name|m_timestamp
index|[
name|mode
index|]
operator|=
name|XCB_CURRENT_TIME
expr_stmt|;
block|}
if|if
condition|(
name|connection
argument_list|()
operator|->
name|time
argument_list|()
operator|==
name|XCB_CURRENT_TIME
condition|)
name|connection
argument_list|()
operator|->
name|setTime
argument_list|(
name|connection
argument_list|()
operator|->
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
name|newOwner
operator|=
name|owner
argument_list|()
expr_stmt|;
name|m_clientClipboard
index|[
name|mode
index|]
operator|=
name|data
expr_stmt|;
name|m_timestamp
index|[
name|mode
index|]
operator|=
name|connection
argument_list|()
operator|->
name|time
argument_list|()
expr_stmt|;
block|}
name|xcb_set_selection_owner
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|newOwner
argument_list|,
name|modeAtom
argument_list|,
name|connection
argument_list|()
operator|->
name|time
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getSelectionOwner
argument_list|(
name|modeAtom
argument_list|)
operator|!=
name|newOwner
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbClipboard::setMimeData: Cannot set X11 selection owner"
argument_list|)
expr_stmt|;
block|}
name|emitChanged
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|supportsMode
name|bool
name|QXcbClipboard
operator|::
name|supportsMode
parameter_list|(
name|QClipboard
operator|::
name|Mode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mode
operator|<=
name|QClipboard
operator|::
name|Selection
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|ownsMode
name|bool
name|QXcbClipboard
operator|::
name|ownsMode
parameter_list|(
name|QClipboard
operator|::
name|Mode
name|mode
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|m_owner
operator|==
name|XCB_NONE
operator|||
name|mode
operator|>
name|QClipboard
operator|::
name|Selection
condition|)
return|return
literal|false
return|;
name|Q_ASSERT
argument_list|(
name|m_timestamp
index|[
name|mode
index|]
operator|==
name|XCB_CURRENT_TIME
operator|||
name|getSelectionOwner
argument_list|(
name|atomForMode
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|==
name|m_owner
argument_list|)
expr_stmt|;
return|return
name|m_timestamp
index|[
name|mode
index|]
operator|!=
name|XCB_CURRENT_TIME
return|;
block|}
end_function
begin_function
DECL|function|screen
name|QXcbScreen
modifier|*
name|QXcbClipboard
operator|::
name|screen
parameter_list|()
specifier|const
block|{
return|return
name|connection
argument_list|()
operator|->
name|primaryScreen
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|requestor
name|xcb_window_t
name|QXcbClipboard
operator|::
name|requestor
parameter_list|()
specifier|const
block|{
name|QXcbScreen
modifier|*
name|platformScreen
init|=
name|screen
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|m_requestor
operator|&&
name|platformScreen
condition|)
block|{
specifier|const
name|int
name|x
init|=
literal|0
decl_stmt|,
name|y
init|=
literal|0
decl_stmt|,
name|w
init|=
literal|3
decl_stmt|,
name|h
init|=
literal|3
decl_stmt|;
name|QXcbClipboard
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QXcbClipboard
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|xcb_window_t
name|window
init|=
name|xcb_generate_id
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
decl_stmt|;
name|Q_XCB_CALL
argument_list|(
name|xcb_create_window
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_COPY_FROM_PARENT
argument_list|,
comment|// depth -- same as root
name|window
argument_list|,
comment|// window id
name|platformScreen
operator|->
name|screen
argument_list|()
operator|->
name|root
argument_list|,
comment|// parent window id
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|,
comment|// border width
name|XCB_WINDOW_CLASS_INPUT_OUTPUT
argument_list|,
comment|// window class
name|platformScreen
operator|->
name|screen
argument_list|()
operator|->
name|root_visual
argument_list|,
comment|// visual
literal|0
argument_list|,
comment|// value mask
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// value list
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|QByteArray
name|ba
argument_list|(
literal|"Qt clipboard requestor window"
argument_list|)
decl_stmt|;
name|Q_XCB_CALL
argument_list|(
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|window
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_NET_WM_NAME
argument_list|)
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|UTF8_STRING
argument_list|)
argument_list|,
literal|8
argument_list|,
name|ba
operator|.
name|length
argument_list|()
argument_list|,
name|ba
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uint32_t
name|mask
init|=
name|XCB_EVENT_MASK_PROPERTY_CHANGE
decl_stmt|;
name|xcb_change_window_attributes
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|window
argument_list|,
name|XCB_CW_EVENT_MASK
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|that
operator|->
name|setRequestor
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
return|return
name|m_requestor
return|;
block|}
end_function
begin_function
DECL|function|setRequestor
name|void
name|QXcbClipboard
operator|::
name|setRequestor
parameter_list|(
name|xcb_window_t
name|window
parameter_list|)
block|{
if|if
condition|(
name|m_requestor
operator|!=
name|XCB_NONE
condition|)
block|{
name|xcb_destroy_window
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|m_requestor
argument_list|)
expr_stmt|;
block|}
name|m_requestor
operator|=
name|window
expr_stmt|;
block|}
end_function
begin_function
DECL|function|owner
name|xcb_window_t
name|QXcbClipboard
operator|::
name|owner
parameter_list|()
specifier|const
block|{
return|return
name|m_owner
return|;
block|}
end_function
begin_function
DECL|function|sendTargetsSelection
name|xcb_atom_t
name|QXcbClipboard
operator|::
name|sendTargetsSelection
parameter_list|(
name|QMimeData
modifier|*
name|d
parameter_list|,
name|xcb_window_t
name|window
parameter_list|,
name|xcb_atom_t
name|property
parameter_list|)
block|{
name|QVector
argument_list|<
name|xcb_atom_t
argument_list|>
name|types
decl_stmt|;
name|QStringList
name|formats
init|=
name|QInternalMimeData
operator|::
name|formatsHelper
argument_list|(
name|d
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|formats
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QVector
argument_list|<
name|xcb_atom_t
argument_list|>
name|atoms
init|=
name|QXcbMime
operator|::
name|mimeAtomsForFormat
argument_list|(
name|connection
argument_list|()
argument_list|,
name|formats
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|atoms
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
name|types
operator|.
name|contains
argument_list|(
name|atoms
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
name|types
operator|.
name|append
argument_list|(
name|atoms
operator|.
name|at
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|types
operator|.
name|append
argument_list|(
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|TARGETS
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|append
argument_list|(
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|MULTIPLE
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|append
argument_list|(
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|TIMESTAMP
argument_list|)
argument_list|)
expr_stmt|;
name|types
operator|.
name|append
argument_list|(
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|SAVE_TARGETS
argument_list|)
argument_list|)
expr_stmt|;
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|window
argument_list|,
name|property
argument_list|,
name|XCB_ATOM_ATOM
argument_list|,
literal|32
argument_list|,
name|types
operator|.
name|size
argument_list|()
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|types
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|property
return|;
block|}
end_function
begin_function
DECL|function|sendSelection
name|xcb_atom_t
name|QXcbClipboard
operator|::
name|sendSelection
parameter_list|(
name|QMimeData
modifier|*
name|d
parameter_list|,
name|xcb_atom_t
name|target
parameter_list|,
name|xcb_window_t
name|window
parameter_list|,
name|xcb_atom_t
name|property
parameter_list|)
block|{
name|xcb_atom_t
name|atomFormat
init|=
name|target
decl_stmt|;
name|int
name|dataFormat
init|=
literal|0
decl_stmt|;
name|QByteArray
name|data
decl_stmt|;
name|QString
name|fmt
init|=
name|QXcbMime
operator|::
name|mimeAtomToString
argument_list|(
name|connection
argument_list|()
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|fmt
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Not a MIME type we have
comment|//        qDebug()<< "QClipboard: send_selection(): converting to type"<< connection()->atomName(target)<< "is not supported";
return|return
name|XCB_NONE
return|;
block|}
comment|//    qDebug()<< "QClipboard: send_selection(): converting to type"<< fmt;
if|if
condition|(
name|QXcbMime
operator|::
name|mimeDataForAtom
argument_list|(
name|connection
argument_list|()
argument_list|,
name|target
argument_list|,
name|d
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|atomFormat
argument_list|,
operator|&
name|dataFormat
argument_list|)
condition|)
block|{
comment|// don't allow INCR transfers when using MULTIPLE or to
comment|// Motif clients (since Motif doesn't support INCR)
specifier|static
name|xcb_atom_t
name|motif_clip_temporary
init|=
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIP_TEMPORARY
argument_list|)
decl_stmt|;
name|bool
name|allow_incr
init|=
name|property
operator|!=
name|motif_clip_temporary
decl_stmt|;
comment|// This 'bool' can be removed once there is a proper fix for QTBUG-32853
if|if
condition|(
name|m_clipboard_closing
condition|)
name|allow_incr
operator|=
literal|false
expr_stmt|;
comment|// X_ChangeProperty protocol request is 24 bytes
specifier|const
name|int
name|increment
init|=
operator|(
name|xcb_get_maximum_request_length
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
operator|*
literal|4
operator|)
operator|-
literal|24
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|size
argument_list|()
operator|>
name|increment
operator|&&
name|allow_incr
condition|)
block|{
name|long
name|bytes
init|=
name|data
operator|.
name|size
argument_list|()
decl_stmt|;
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|window
argument_list|,
name|property
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|INCR
argument_list|)
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|bytes
argument_list|)
expr_stmt|;
operator|new
name|INCRTransaction
argument_list|(
name|connection
argument_list|()
argument_list|,
name|window
argument_list|,
name|property
argument_list|,
name|data
argument_list|,
name|increment
argument_list|,
name|atomFormat
argument_list|,
name|dataFormat
argument_list|,
name|clipboard_timeout
argument_list|)
expr_stmt|;
return|return
name|property
return|;
block|}
comment|// make sure we can perform the XChangeProperty in a single request
if|if
condition|(
name|data
operator|.
name|size
argument_list|()
operator|>
name|increment
condition|)
return|return
name|XCB_NONE
return|;
comment|// ### perhaps use several XChangeProperty calls w/ PropModeAppend?
name|int
name|dataSize
init|=
name|data
operator|.
name|size
argument_list|()
operator|/
operator|(
name|dataFormat
operator|/
literal|8
operator|)
decl_stmt|;
comment|// use a single request to transfer data
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|window
argument_list|,
name|property
argument_list|,
name|atomFormat
argument_list|,
name|dataFormat
argument_list|,
name|dataSize
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|data
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|property
return|;
block|}
end_function
begin_function
DECL|function|handleSelectionClearRequest
name|void
name|QXcbClipboard
operator|::
name|handleSelectionClearRequest
parameter_list|(
name|xcb_selection_clear_event_t
modifier|*
name|event
parameter_list|)
block|{
name|QClipboard
operator|::
name|Mode
name|mode
init|=
name|modeForAtom
argument_list|(
name|event
operator|->
name|selection
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|>
name|QClipboard
operator|::
name|Selection
condition|)
return|return;
comment|// ignore the event if it was generated before we gained selection ownership
if|if
condition|(
name|m_timestamp
index|[
name|mode
index|]
operator|!=
name|XCB_CURRENT_TIME
operator|&&
name|event
operator|->
name|time
operator|<=
name|m_timestamp
index|[
name|mode
index|]
condition|)
return|return;
comment|//    DEBUG("QClipboard: new selection owner 0x%lx at time %lx (ours %lx)",
comment|//          XGetSelectionOwner(dpy, XA_PRIMARY),
comment|//          xevent->xselectionclear.time, d->timestamp);
name|xcb_window_t
name|newOwner
init|=
name|getSelectionOwner
argument_list|(
name|event
operator|->
name|selection
argument_list|)
decl_stmt|;
comment|/* If selection ownership was given up voluntarily from QClipboard::clear(), then we do nothing here     since its already handled in setMimeData. Otherwise, the event must have come from another client     as a result of a call to xcb_set_selection_owner in which case we need to delete the local mime data     */
if|if
condition|(
name|newOwner
operator|!=
name|XCB_NONE
condition|)
block|{
if|if
condition|(
name|m_clientClipboard
index|[
name|QClipboard
operator|::
name|Clipboard
index|]
operator|!=
name|m_clientClipboard
index|[
name|QClipboard
operator|::
name|Selection
index|]
condition|)
operator|delete
name|m_clientClipboard
index|[
name|mode
index|]
expr_stmt|;
name|m_clientClipboard
index|[
name|mode
index|]
operator|=
literal|0
expr_stmt|;
name|m_timestamp
index|[
name|mode
index|]
operator|=
name|XCB_CURRENT_TIME
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|handleSelectionRequest
name|void
name|QXcbClipboard
operator|::
name|handleSelectionRequest
parameter_list|(
name|xcb_selection_request_event_t
modifier|*
name|req
parameter_list|)
block|{
if|if
condition|(
name|requestor
argument_list|()
operator|&&
name|req
operator|->
name|requestor
operator|==
name|requestor
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbClipboard: Selection request should be caught before"
argument_list|)
expr_stmt|;
return|return;
block|}
name|xcb_selection_notify_event_t
name|event
decl_stmt|;
name|event
operator|.
name|response_type
operator|=
name|XCB_SELECTION_NOTIFY
expr_stmt|;
name|event
operator|.
name|requestor
operator|=
name|req
operator|->
name|requestor
expr_stmt|;
name|event
operator|.
name|selection
operator|=
name|req
operator|->
name|selection
expr_stmt|;
name|event
operator|.
name|target
operator|=
name|req
operator|->
name|target
expr_stmt|;
name|event
operator|.
name|property
operator|=
name|XCB_NONE
expr_stmt|;
name|event
operator|.
name|time
operator|=
name|req
operator|->
name|time
expr_stmt|;
name|QMimeData
modifier|*
name|d
decl_stmt|;
name|QClipboard
operator|::
name|Mode
name|mode
init|=
name|modeForAtom
argument_list|(
name|req
operator|->
name|selection
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|>
name|QClipboard
operator|::
name|Selection
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QXcbClipboard: Unknown selection"
operator|<<
name|connection
argument_list|()
operator|->
name|atomName
argument_list|(
name|req
operator|->
name|selection
argument_list|)
expr_stmt|;
name|xcb_send_event
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|req
operator|->
name|requestor
argument_list|,
name|XCB_EVENT_MASK_NO_EVENT
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|=
name|m_clientClipboard
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbClipboard: Cannot transfer data, no data available"
argument_list|)
expr_stmt|;
name|xcb_send_event
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|req
operator|->
name|requestor
argument_list|,
name|XCB_EVENT_MASK_NO_EVENT
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m_timestamp
index|[
name|mode
index|]
operator|==
name|XCB_CURRENT_TIME
comment|// we don't own the selection anymore
operator|||
operator|(
name|req
operator|->
name|time
operator|!=
name|XCB_CURRENT_TIME
operator|&&
name|req
operator|->
name|time
operator|<
name|m_timestamp
index|[
name|mode
index|]
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbClipboard: SelectionRequest too old"
argument_list|)
expr_stmt|;
name|xcb_send_event
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|req
operator|->
name|requestor
argument_list|,
name|XCB_EVENT_MASK_NO_EVENT
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|xcb_atom_t
name|targetsAtom
init|=
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|TARGETS
argument_list|)
decl_stmt|;
name|xcb_atom_t
name|multipleAtom
init|=
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|MULTIPLE
argument_list|)
decl_stmt|;
name|xcb_atom_t
name|timestampAtom
init|=
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|TIMESTAMP
argument_list|)
decl_stmt|;
struct|struct
name|AtomPair
block|{
name|xcb_atom_t
name|target
decl_stmt|;
name|xcb_atom_t
name|property
decl_stmt|;
block|}
modifier|*
name|multi
init|=
literal|0
struct|;
name|xcb_atom_t
name|multi_type
init|=
name|XCB_NONE
decl_stmt|;
name|int
name|multi_format
init|=
literal|0
decl_stmt|;
name|int
name|nmulti
init|=
literal|0
decl_stmt|;
name|int
name|imulti
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|multi_writeback
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|target
operator|==
name|multipleAtom
condition|)
block|{
name|QByteArray
name|multi_data
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|property
operator|==
name|XCB_NONE
operator|||
operator|!
name|clipboardReadProperty
argument_list|(
name|req
operator|->
name|requestor
argument_list|,
name|req
operator|->
name|property
argument_list|,
literal|false
argument_list|,
operator|&
name|multi_data
argument_list|,
literal|0
argument_list|,
operator|&
name|multi_type
argument_list|,
operator|&
name|multi_format
argument_list|)
operator|||
name|multi_format
operator|!=
literal|32
condition|)
block|{
comment|// MULTIPLE property not formatted correctly
name|xcb_send_event
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|req
operator|->
name|requestor
argument_list|,
name|XCB_EVENT_MASK_NO_EVENT
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|nmulti
operator|=
name|multi_data
operator|.
name|size
argument_list|()
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|multi
argument_list|)
expr_stmt|;
name|multi
operator|=
operator|new
name|AtomPair
index|[
name|nmulti
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|multi
argument_list|,
name|multi_data
operator|.
name|data
argument_list|()
argument_list|,
name|multi_data
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|imulti
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|imulti
operator|<
name|nmulti
condition|;
operator|++
name|imulti
control|)
block|{
name|xcb_atom_t
name|target
decl_stmt|;
name|xcb_atom_t
name|property
decl_stmt|;
if|if
condition|(
name|multi
condition|)
block|{
name|target
operator|=
name|multi
index|[
name|imulti
index|]
operator|.
name|target
expr_stmt|;
name|property
operator|=
name|multi
index|[
name|imulti
index|]
operator|.
name|property
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|req
operator|->
name|target
expr_stmt|;
name|property
operator|=
name|req
operator|->
name|property
expr_stmt|;
if|if
condition|(
name|property
operator|==
name|XCB_NONE
condition|)
comment|// obsolete client
name|property
operator|=
name|target
expr_stmt|;
block|}
name|xcb_atom_t
name|ret
init|=
name|XCB_NONE
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|XCB_NONE
operator|||
name|property
operator|==
name|XCB_NONE
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|==
name|timestampAtom
condition|)
block|{
if|if
condition|(
name|m_timestamp
index|[
name|mode
index|]
operator|!=
name|XCB_CURRENT_TIME
condition|)
block|{
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|req
operator|->
name|requestor
argument_list|,
name|property
argument_list|,
name|XCB_ATOM_INTEGER
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|,
operator|&
name|m_timestamp
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
name|ret
operator|=
name|property
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QXcbClipboard: Invalid data timestamp"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|target
operator|==
name|targetsAtom
condition|)
block|{
name|ret
operator|=
name|sendTargetsSelection
argument_list|(
name|d
argument_list|,
name|req
operator|->
name|requestor
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|sendSelection
argument_list|(
name|d
argument_list|,
name|target
argument_list|,
name|req
operator|->
name|requestor
argument_list|,
name|property
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nmulti
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|XCB_NONE
condition|)
block|{
name|multi
index|[
name|imulti
index|]
operator|.
name|property
operator|=
name|XCB_NONE
expr_stmt|;
name|multi_writeback
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|event
operator|.
name|property
operator|=
name|ret
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nmulti
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|multi_writeback
condition|)
block|{
comment|// according to ICCCM 2.6.2 says to put None back
comment|// into the original property on the requestor window
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|req
operator|->
name|requestor
argument_list|,
name|req
operator|->
name|property
argument_list|,
name|multi_type
argument_list|,
literal|32
argument_list|,
name|nmulti
operator|*
literal|2
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|multi
argument_list|)
expr_stmt|;
block|}
operator|delete
index|[]
name|multi
expr_stmt|;
name|event
operator|.
name|property
operator|=
name|req
operator|->
name|property
expr_stmt|;
block|}
comment|// send selection notify to requestor
name|xcb_send_event
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|req
operator|->
name|requestor
argument_list|,
name|XCB_EVENT_MASK_NO_EVENT
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleXFixesSelectionRequest
name|void
name|QXcbClipboard
operator|::
name|handleXFixesSelectionRequest
parameter_list|(
name|xcb_xfixes_selection_notify_event_t
modifier|*
name|event
parameter_list|)
block|{
name|QClipboard
operator|::
name|Mode
name|mode
init|=
name|modeForAtom
argument_list|(
name|event
operator|->
name|selection
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|>
name|QClipboard
operator|::
name|Selection
condition|)
return|return;
comment|// here we care only about the xfixes events that come from non Qt processes
if|if
condition|(
name|event
operator|->
name|owner
operator|!=
name|XCB_NONE
operator|&&
name|event
operator|->
name|owner
operator|!=
name|owner
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|m_xClipboard
index|[
name|mode
index|]
condition|)
block|{
name|m_xClipboard
index|[
name|mode
index|]
operator|=
operator|new
name|QXcbClipboardMime
argument_list|(
name|mode
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_xClipboard
index|[
name|mode
index|]
operator|->
name|reset
argument_list|()
expr_stmt|;
block|}
name|emitChanged
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|subtype
operator|==
name|XCB_XFIXES_SELECTION_EVENT_SELECTION_CLIENT_CLOSE
operator|||
name|event
operator|->
name|subtype
operator|==
name|XCB_XFIXES_SELECTION_EVENT_SELECTION_WINDOW_DESTROY
condition|)
name|emitChanged
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|maxSelectionIncr
specifier|static
specifier|inline
name|int
name|maxSelectionIncr
parameter_list|(
name|xcb_connection_t
modifier|*
name|c
parameter_list|)
block|{
name|int
name|l
init|=
name|xcb_get_maximum_request_length
argument_list|(
name|c
argument_list|)
decl_stmt|;
return|return
operator|(
name|l
operator|>
literal|65536
condition|?
literal|65536
operator|*
literal|4
else|:
name|l
operator|*
literal|4
operator|)
operator|-
literal|100
return|;
block|}
end_function
begin_function
DECL|function|clipboardReadProperty
name|bool
name|QXcbClipboard
operator|::
name|clipboardReadProperty
parameter_list|(
name|xcb_window_t
name|win
parameter_list|,
name|xcb_atom_t
name|property
parameter_list|,
name|bool
name|deleteProperty
parameter_list|,
name|QByteArray
modifier|*
name|buffer
parameter_list|,
name|int
modifier|*
name|size
parameter_list|,
name|xcb_atom_t
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|format
parameter_list|)
block|{
name|int
name|maxsize
init|=
name|maxSelectionIncr
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
decl_stmt|;
name|ulong
name|bytes_left
decl_stmt|;
comment|// bytes_after
name|xcb_atom_t
name|dummy_type
decl_stmt|;
name|int
name|dummy_format
decl_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
comment|// allow null args
name|type
operator|=
operator|&
name|dummy_type
expr_stmt|;
if|if
condition|(
operator|!
name|format
condition|)
name|format
operator|=
operator|&
name|dummy_format
expr_stmt|;
comment|// Don't read anything, just get the size of the property data
name|xcb_get_property_cookie_t
name|cookie
init|=
name|Q_XCB_CALL
argument_list|(
name|xcb_get_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|win
argument_list|,
name|property
argument_list|,
name|XCB_GET_PROPERTY_TYPE_ANY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|xcb_get_property_reply_t
modifier|*
name|reply
init|=
name|xcb_get_property_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|cookie
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reply
operator|||
name|reply
operator|->
name|type
operator|==
name|XCB_NONE
condition|)
block|{
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
operator|*
name|type
operator|=
name|reply
operator|->
name|type
expr_stmt|;
operator|*
name|format
operator|=
name|reply
operator|->
name|format
expr_stmt|;
name|bytes_left
operator|=
name|reply
operator|->
name|bytes_after
expr_stmt|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|,
name|buffer_offset
init|=
literal|0
decl_stmt|;
name|int
name|newSize
init|=
name|bytes_left
decl_stmt|;
name|buffer
operator|->
name|resize
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
name|bool
name|ok
init|=
operator|(
name|buffer
operator|->
name|size
argument_list|()
operator|==
name|newSize
operator|)
decl_stmt|;
if|if
condition|(
name|ok
operator|&&
name|newSize
condition|)
block|{
comment|// could allocate buffer
while|while
condition|(
name|bytes_left
condition|)
block|{
comment|// more to read...
name|xcb_get_property_cookie_t
name|cookie
init|=
name|Q_XCB_CALL
argument_list|(
name|xcb_get_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|win
argument_list|,
name|property
argument_list|,
name|XCB_GET_PROPERTY_TYPE_ANY
argument_list|,
name|offset
argument_list|,
name|maxsize
operator|/
literal|4
argument_list|)
argument_list|)
decl_stmt|;
name|reply
operator|=
name|xcb_get_property_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|cookie
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reply
operator|||
name|reply
operator|->
name|type
operator|==
name|XCB_NONE
condition|)
block|{
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|type
operator|=
name|reply
operator|->
name|type
expr_stmt|;
operator|*
name|format
operator|=
name|reply
operator|->
name|format
expr_stmt|;
name|bytes_left
operator|=
name|reply
operator|->
name|bytes_after
expr_stmt|;
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
name|xcb_get_property_value
argument_list|(
name|reply
argument_list|)
decl_stmt|;
name|int
name|length
init|=
name|xcb_get_property_value_length
argument_list|(
name|reply
argument_list|)
decl_stmt|;
comment|// Here we check if we get a buffer overflow and tries to
comment|// recover -- this shouldn't normally happen, but it doesn't
comment|// hurt to be defensive
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|buffer_offset
operator|+
name|length
argument_list|)
operator|>
name|buffer
operator|->
name|size
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbClipboard: buffer overflow"
argument_list|)
expr_stmt|;
name|length
operator|=
name|buffer
operator|->
name|size
argument_list|()
operator|-
name|buffer_offset
expr_stmt|;
comment|// escape loop
name|bytes_left
operator|=
literal|0
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buffer
operator|->
name|data
argument_list|()
operator|+
name|buffer_offset
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|buffer_offset
operator|+=
name|length
expr_stmt|;
if|if
condition|(
name|bytes_left
condition|)
block|{
comment|// offset is specified in 32-bit multiples
name|offset
operator|+=
name|length
operator|/
literal|4
expr_stmt|;
block|}
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
block|}
comment|// correct size, not 0-term.
if|if
condition|(
name|size
condition|)
operator|*
name|size
operator|=
name|buffer_offset
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|INCR
argument_list|)
condition|)
name|m_incr_receive_time
operator|=
name|connection
argument_list|()
operator|->
name|getTimestamp
argument_list|()
expr_stmt|;
if|if
condition|(
name|deleteProperty
condition|)
name|xcb_delete_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|win
argument_list|,
name|property
argument_list|)
expr_stmt|;
name|connection
argument_list|()
operator|->
name|flush
argument_list|()
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|class|Notify
class|class
name|Notify
block|{
public|public:
DECL|function|Notify
name|Notify
parameter_list|(
name|xcb_window_t
name|win
parameter_list|,
name|int
name|t
parameter_list|)
member_init_list|:
name|window
argument_list|(
name|win
argument_list|)
member_init_list|,
name|type
argument_list|(
name|t
argument_list|)
block|{}
DECL|member|window
name|xcb_window_t
name|window
decl_stmt|;
DECL|member|type
name|int
name|type
decl_stmt|;
DECL|function|checkEvent
name|bool
name|checkEvent
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|event
condition|)
return|return
literal|false
return|;
name|int
name|t
init|=
name|event
operator|->
name|response_type
operator|&
literal|0x7f
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|type
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|t
operator|==
name|XCB_PROPERTY_NOTIFY
condition|)
block|{
name|xcb_property_notify_event_t
modifier|*
name|pn
init|=
operator|(
name|xcb_property_notify_event_t
operator|*
operator|)
name|event
decl_stmt|;
if|if
condition|(
name|pn
operator|->
name|window
operator|==
name|window
condition|)
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|XCB_SELECTION_NOTIFY
condition|)
block|{
name|xcb_selection_notify_event_t
modifier|*
name|sn
init|=
operator|(
name|xcb_selection_notify_event_t
operator|*
operator|)
name|event
decl_stmt|;
if|if
condition|(
name|sn
operator|->
name|requestor
operator|==
name|window
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
class|;
DECL|class|ClipboardEvent
class|class
name|ClipboardEvent
block|{
public|public:
DECL|function|ClipboardEvent
name|ClipboardEvent
parameter_list|(
name|QXcbConnection
modifier|*
name|c
parameter_list|)
block|{
name|clipboard
operator|=
name|c
operator|->
name|internAtom
argument_list|(
literal|"CLIPBOARD"
argument_list|)
expr_stmt|;
block|}
DECL|member|clipboard
name|xcb_atom_t
name|clipboard
decl_stmt|;
DECL|function|checkEvent
name|bool
name|checkEvent
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|e
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|false
return|;
name|int
name|type
init|=
name|e
operator|->
name|response_type
operator|&
literal|0x7f
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|XCB_SELECTION_REQUEST
condition|)
block|{
name|xcb_selection_request_event_t
modifier|*
name|sr
init|=
operator|(
name|xcb_selection_request_event_t
operator|*
operator|)
name|e
decl_stmt|;
return|return
name|sr
operator|->
name|selection
operator|==
name|XCB_ATOM_PRIMARY
operator|||
name|sr
operator|->
name|selection
operator|==
name|clipboard
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|XCB_SELECTION_CLEAR
condition|)
block|{
name|xcb_selection_clear_event_t
modifier|*
name|sc
init|=
operator|(
name|xcb_selection_clear_event_t
operator|*
operator|)
name|e
decl_stmt|;
return|return
name|sc
operator|->
name|selection
operator|==
name|XCB_ATOM_PRIMARY
operator|||
name|sc
operator|->
name|selection
operator|==
name|clipboard
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
class|;
block|}
end_namespace
begin_function
DECL|function|waitForClipboardEvent
name|xcb_generic_event_t
modifier|*
name|QXcbClipboard
operator|::
name|waitForClipboardEvent
parameter_list|(
name|xcb_window_t
name|win
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|timeout
parameter_list|,
name|bool
name|checkManager
parameter_list|)
block|{
name|QElapsedTimer
name|timer
decl_stmt|;
name|timer
operator|.
name|start
argument_list|()
expr_stmt|;
do|do
block|{
name|Notify
name|notify
argument_list|(
name|win
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|xcb_generic_event_t
modifier|*
name|e
init|=
name|connection
argument_list|()
operator|->
name|checkEvent
argument_list|(
name|notify
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
condition|)
return|return
name|e
return|;
if|if
condition|(
name|checkManager
condition|)
block|{
name|xcb_get_selection_owner_cookie_t
name|cookie
init|=
name|xcb_get_selection_owner
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIPBOARD_MANAGER
argument_list|)
argument_list|)
decl_stmt|;
name|xcb_get_selection_owner_reply_t
modifier|*
name|reply
init|=
name|xcb_get_selection_owner_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|cookie
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reply
operator|||
name|reply
operator|->
name|owner
operator|==
name|XCB_NONE
condition|)
block|{
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
comment|// process other clipboard events, since someone is probably requesting data from us
name|ClipboardEvent
name|clipboard
argument_list|(
name|connection
argument_list|()
argument_list|)
decl_stmt|;
name|e
operator|=
name|connection
argument_list|()
operator|->
name|checkEvent
argument_list|(
name|clipboard
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|connection
argument_list|()
operator|->
name|handleXcbEvent
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|connection
argument_list|()
operator|->
name|flush
argument_list|()
expr_stmt|;
comment|// sleep 50 ms, so we don't use up CPU cycles all the time.
name|struct
name|timeval
name|usleep_tv
decl_stmt|;
name|usleep_tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|usleep_tv
operator|.
name|tv_usec
operator|=
literal|50000
expr_stmt|;
name|select
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|usleep_tv
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|timer
operator|.
name|elapsed
argument_list|()
operator|<
name|timeout
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|clipboardReadIncrementalProperty
name|QByteArray
name|QXcbClipboard
operator|::
name|clipboardReadIncrementalProperty
parameter_list|(
name|xcb_window_t
name|win
parameter_list|,
name|xcb_atom_t
name|property
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|bool
name|nullterm
parameter_list|)
block|{
name|QByteArray
name|buf
decl_stmt|;
name|QByteArray
name|tmp_buf
decl_stmt|;
name|bool
name|alloc_error
init|=
literal|false
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|xcb_timestamp_t
name|prev_time
init|=
name|m_incr_receive_time
decl_stmt|;
if|if
condition|(
name|nbytes
operator|>
literal|0
condition|)
block|{
comment|// Reserve buffer + zero-terminator (for text data)
comment|// We want to complete the INCR transfer even if we cannot
comment|// allocate more memory
name|buf
operator|.
name|resize
argument_list|(
name|nbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|alloc_error
operator|=
name|buf
operator|.
name|size
argument_list|()
operator|!=
name|nbytes
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|connection
argument_list|()
operator|->
name|flush
argument_list|()
expr_stmt|;
name|xcb_generic_event_t
modifier|*
name|ge
init|=
name|waitForClipboardEvent
argument_list|(
name|win
argument_list|,
name|XCB_PROPERTY_NOTIFY
argument_list|,
name|clipboard_timeout
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ge
condition|)
break|break;
name|xcb_property_notify_event_t
modifier|*
name|event
init|=
operator|(
name|xcb_property_notify_event_t
operator|*
operator|)
name|ge
decl_stmt|;
if|if
condition|(
name|event
operator|->
name|atom
operator|!=
name|property
operator|||
name|event
operator|->
name|state
operator|!=
name|XCB_PROPERTY_NEW_VALUE
operator|||
name|event
operator|->
name|time
operator|<
name|prev_time
condition|)
continue|continue;
name|prev_time
operator|=
name|event
operator|->
name|time
expr_stmt|;
if|if
condition|(
name|clipboardReadProperty
argument_list|(
name|win
argument_list|,
name|property
argument_list|,
literal|true
argument_list|,
operator|&
name|tmp_buf
argument_list|,
operator|&
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
comment|// no more data, we're done
if|if
condition|(
name|nullterm
condition|)
block|{
name|buf
operator|.
name|resize
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|offset
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|resize
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|alloc_error
condition|)
block|{
if|if
condition|(
name|offset
operator|+
name|length
operator|>
operator|(
name|int
operator|)
name|buf
operator|.
name|size
argument_list|()
condition|)
block|{
name|buf
operator|.
name|resize
argument_list|(
name|offset
operator|+
name|length
operator|+
literal|65535
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|size
argument_list|()
operator|!=
name|offset
operator|+
name|length
operator|+
literal|65535
condition|)
block|{
name|alloc_error
operator|=
literal|true
expr_stmt|;
name|length
operator|=
name|buf
operator|.
name|size
argument_list|()
operator|-
name|offset
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
name|buf
operator|.
name|data
argument_list|()
operator|+
name|offset
argument_list|,
name|tmp_buf
operator|.
name|constData
argument_list|()
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|tmp_buf
operator|.
name|resize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|length
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
block|}
name|free
argument_list|(
name|ge
argument_list|)
expr_stmt|;
block|}
comment|// timed out ... create a new requestor window, otherwise the requestor
comment|// could consider next request to be still part of this timed out request
name|setRequestor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|getDataInFormat
name|QByteArray
name|QXcbClipboard
operator|::
name|getDataInFormat
parameter_list|(
name|xcb_atom_t
name|modeAtom
parameter_list|,
name|xcb_atom_t
name|fmtAtom
parameter_list|)
block|{
return|return
name|getSelection
argument_list|(
name|modeAtom
argument_list|,
name|fmtAtom
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_QT_SELECTION
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|getSelection
name|QByteArray
name|QXcbClipboard
operator|::
name|getSelection
parameter_list|(
name|xcb_atom_t
name|selection
parameter_list|,
name|xcb_atom_t
name|target
parameter_list|,
name|xcb_atom_t
name|property
parameter_list|,
name|xcb_timestamp_t
name|time
parameter_list|)
block|{
name|QByteArray
name|buf
decl_stmt|;
name|xcb_window_t
name|win
init|=
name|requestor
argument_list|()
decl_stmt|;
if|if
condition|(
name|time
operator|==
literal|0
condition|)
name|time
operator|=
name|connection
argument_list|()
operator|->
name|time
argument_list|()
expr_stmt|;
name|xcb_delete_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|win
argument_list|,
name|property
argument_list|)
expr_stmt|;
name|xcb_convert_selection
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|win
argument_list|,
name|selection
argument_list|,
name|target
argument_list|,
name|property
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|connection
argument_list|()
operator|->
name|sync
argument_list|()
expr_stmt|;
name|xcb_generic_event_t
modifier|*
name|ge
init|=
name|waitForClipboardEvent
argument_list|(
name|win
argument_list|,
name|XCB_SELECTION_NOTIFY
argument_list|,
name|clipboard_timeout
argument_list|)
decl_stmt|;
name|bool
name|no_selection
init|=
operator|!
name|ge
operator|||
operator|(
operator|(
name|xcb_selection_notify_event_t
operator|*
operator|)
name|ge
operator|)
operator|->
name|property
operator|==
name|XCB_NONE
decl_stmt|;
name|free
argument_list|(
name|ge
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_selection
condition|)
return|return
name|buf
return|;
name|xcb_atom_t
name|type
decl_stmt|;
if|if
condition|(
name|clipboardReadProperty
argument_list|(
name|win
argument_list|,
name|property
argument_list|,
literal|true
argument_list|,
operator|&
name|buf
argument_list|,
literal|0
argument_list|,
operator|&
name|type
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|INCR
argument_list|)
condition|)
block|{
name|int
name|nbytes
init|=
name|buf
operator|.
name|size
argument_list|()
operator|>=
literal|4
condition|?
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buf
operator|.
name|data
argument_list|()
operator|)
else|:
literal|0
decl_stmt|;
name|buf
operator|=
name|clipboardReadIncrementalProperty
argument_list|(
name|win
argument_list|,
name|property
argument_list|,
name|nbytes
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CLIPBOARD
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"qxcbclipboard.moc"
end_include
end_unit
