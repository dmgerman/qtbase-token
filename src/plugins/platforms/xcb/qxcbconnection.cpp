begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtGui/private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/QDebug>
end_include
begin_include
include|#
directive|include
file|"qxcbconnection.h"
end_include
begin_include
include|#
directive|include
file|"qxcbkeyboard.h"
end_include
begin_include
include|#
directive|include
file|"qxcbscreen.h"
end_include
begin_include
include|#
directive|include
file|"qxcbwindow.h"
end_include
begin_include
include|#
directive|include
file|"qxcbclipboard.h"
end_include
begin_include
include|#
directive|include
file|"qxcbdrag.h"
end_include
begin_include
include|#
directive|include
file|"qxcbwmsupport.h"
end_include
begin_include
include|#
directive|include
file|"qxcbnativeinterface.h"
end_include
begin_include
include|#
directive|include
file|"qxcbintegration.h"
end_include
begin_include
include|#
directive|include
file|"qxcbsystemtraytracker.h"
end_include
begin_include
include|#
directive|include
file|"qxcbglintegrationfactory.h"
end_include
begin_include
include|#
directive|include
file|"qxcbglintegration.h"
end_include
begin_include
include|#
directive|include
file|<QSocketNotifier>
end_include
begin_include
include|#
directive|include
file|<QAbstractEventDispatcher>
end_include
begin_include
include|#
directive|include
file|<QTimer>
end_include
begin_include
include|#
directive|include
file|<QByteArray>
end_include
begin_include
include|#
directive|include
file|<QScopedPointer>
end_include
begin_include
include|#
directive|include
file|<algorithm>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<xcb/shm.h>
end_include
begin_include
include|#
directive|include
file|<xcb/sync.h>
end_include
begin_include
include|#
directive|include
file|<xcb/xfixes.h>
end_include
begin_include
include|#
directive|include
file|<xcb/xinerama.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_USE_XLIB
end_ifdef
begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include
begin_include
include|#
directive|include
file|<X11/Xlib-xcb.h>
end_include
begin_include
include|#
directive|include
file|<X11/Xlibint.h>
end_include
begin_include
include|#
directive|include
file|<X11/Xutil.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|XCB_USE_XINPUT2
argument_list|)
end_if
begin_include
include|#
directive|include
file|<X11/extensions/XI2proto.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_USE_RENDER
end_ifdef
begin_include
include|#
directive|include
file|<xcb/render.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_CC_GNU
argument_list|)
operator|&&
name|defined
argument_list|(
name|Q_OF_ELF
argument_list|)
end_if
begin_decl_stmt
specifier|static
name|xcb_generic_event_t
modifier|*
name|local_xcb_poll_for_queued_event
argument_list|(
name|xcb_connection_t
operator|*
name|c
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|weakref
argument_list|(
literal|"xcb_poll_for_queued_event"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|checkXcbPollForQueuedEvent
specifier|static
specifier|inline
name|void
name|checkXcbPollForQueuedEvent
parameter_list|()
block|{ }
end_function
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|<dlfcn.h>
end_include
begin_typedef
DECL|typedef|XcbPollForQueuedEventFunctionPointer
typedef|typedef
name|xcb_generic_event_t
modifier|*
function_decl|(
modifier|*
name|XcbPollForQueuedEventFunctionPointer
function_decl|)
parameter_list|(
name|xcb_connection_t
modifier|*
name|c
parameter_list|)
function_decl|;
end_typedef
begin_decl_stmt
DECL|variable|local_xcb_poll_for_queued_event
specifier|static
name|XcbPollForQueuedEventFunctionPointer
name|local_xcb_poll_for_queued_event
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|checkXcbPollForQueuedEvent
specifier|static
specifier|inline
name|void
name|checkXcbPollForQueuedEvent
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|RTLD_DEFAULT
name|local_xcb_poll_for_queued_event
operator|=
operator|(
name|XcbPollForQueuedEventFunctionPointer
operator|)
name|dlsym
argument_list|(
name|RTLD_DEFAULT
argument_list|,
literal|"xcb_poll_for_queued_event"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|Q_LOGGING_CATEGORY
argument_list|(
name|lcQpaXInput
argument_list|,
literal|"qt.qpa.input"
argument_list|)
name|Q_LOGGING_CATEGORY
argument_list|(
name|lcQpaXInputDevices
argument_list|,
literal|"qt.qpa.input.devices"
argument_list|)
name|Q_LOGGING_CATEGORY
argument_list|(
name|lcQpaScreen
argument_list|,
literal|"qt.qpa.screen"
argument_list|)
comment|// this event type was added in libxcb 1.10,
comment|// but we support also older version
ifndef|#
directive|ifndef
name|XCB_GE_GENERIC
DECL|macro|XCB_GE_GENERIC
define|#
directive|define
name|XCB_GE_GENERIC
value|35
endif|#
directive|endif
comment|// Starting from the xcb version 1.9.3 struct xcb_ge_event_t has changed:
comment|// - "pad0" became "extension"
comment|// - "pad1" and "pad" became "pad0"
comment|// New and old version of this struct share the following fields:
decl|typedef struct
DECL|struct|qt_xcb_ge_event_t
name|qt_xcb_ge_event_t
argument_list|{
DECL|member|response_type
name|uint8_t
name|response_type
argument_list|;
DECL|member|extension
name|uint8_t
name|extension
argument_list|;
DECL|member|sequence
name|uint16_t
name|sequence
argument_list|;
DECL|member|length
name|uint32_t
name|length
argument_list|;
DECL|member|event_type
name|uint16_t
name|event_type
argument_list|; }
DECL|typedef|qt_xcb_ge_event_t
name|qt_xcb_ge_event_t
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|isXIEvent
specifier|static
specifier|inline
name|bool
name|isXIEvent
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|,
name|int
name|opCode
parameter_list|)
block|{
name|qt_xcb_ge_event_t
modifier|*
name|e
init|=
operator|(
name|qt_xcb_ge_event_t
operator|*
operator|)
name|event
decl_stmt|;
return|return
name|e
operator|->
name|extension
operator|==
name|opCode
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_USE_XLIB
end_ifdef
begin_decl_stmt
DECL|variable|xcbConnectionErrors
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|xcbConnectionErrors
index|[]
init|=
block|{
literal|"No error"
block|,
comment|/* Error 0 */
literal|"I/O error"
block|,
comment|/* XCB_CONN_ERROR */
literal|"Unsupported extension used"
block|,
comment|/* XCB_CONN_CLOSED_EXT_NOTSUPPORTED */
literal|"Out of memory"
block|,
comment|/* XCB_CONN_CLOSED_MEM_INSUFFICIENT */
literal|"Maximum allowed requested length exceeded"
block|,
comment|/* XCB_CONN_CLOSED_REQ_LEN_EXCEED */
literal|"Failed to parse display string"
block|,
comment|/* XCB_CONN_CLOSED_PARSE_ERR */
literal|"No such screen on display"
block|,
comment|/* XCB_CONN_CLOSED_INVALID_SCREEN */
literal|"Error during FD passing"
comment|/* XCB_CONN_CLOSED_FDPASSING_FAILED */
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|nullErrorHandler
specifier|static
name|int
name|nullErrorHandler
parameter_list|(
name|Display
modifier|*
parameter_list|,
name|XErrorEvent
modifier|*
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|ioErrorHandler
specifier|static
name|int
name|ioErrorHandler
parameter_list|(
name|Display
modifier|*
name|dpy
parameter_list|)
block|{
name|xcb_connection_t
modifier|*
name|conn
init|=
name|XGetXCBConnection
argument_list|(
name|dpy
argument_list|)
decl_stmt|;
if|if
condition|(
name|conn
operator|!=
name|NULL
condition|)
block|{
comment|/* Print a message with a textual description of the error */
name|int
name|code
init|=
name|xcb_connection_has_error
argument_list|(
name|conn
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
init|=
literal|"Unknown error"
decl_stmt|;
name|int
name|arrayLength
init|=
sizeof|sizeof
argument_list|(
name|xcbConnectionErrors
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xcbConnectionErrors
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
operator|&&
name|code
operator|<
name|arrayLength
condition|)
name|str
operator|=
name|xcbConnectionErrors
index|[
name|code
index|]
expr_stmt|;
name|qWarning
argument_list|(
literal|"The X11 connection broke: %s (code %d)"
argument_list|,
name|str
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
return|return
name|_XDefaultIOError
argument_list|(
name|dpy
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|findScreenForCrtc
name|QXcbScreen
modifier|*
name|QXcbConnection
operator|::
name|findScreenForCrtc
parameter_list|(
name|xcb_window_t
name|rootWindow
parameter_list|,
name|xcb_randr_crtc_t
name|crtc
parameter_list|)
specifier|const
block|{
foreach|foreach
control|(
name|QXcbScreen
modifier|*
name|screen
decl|,
name|m_screens
control|)
block|{
if|if
condition|(
name|screen
operator|->
name|root
argument_list|()
operator|==
name|rootWindow
operator|&&
name|screen
operator|->
name|crtc
argument_list|()
operator|==
name|crtc
condition|)
return|return
name|screen
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|findScreenForOutput
name|QXcbScreen
modifier|*
name|QXcbConnection
operator|::
name|findScreenForOutput
parameter_list|(
name|xcb_window_t
name|rootWindow
parameter_list|,
name|xcb_randr_output_t
name|output
parameter_list|)
specifier|const
block|{
foreach|foreach
control|(
name|QXcbScreen
modifier|*
name|screen
decl|,
name|m_screens
control|)
block|{
if|if
condition|(
name|screen
operator|->
name|root
argument_list|()
operator|==
name|rootWindow
operator|&&
name|screen
operator|->
name|output
argument_list|()
operator|==
name|output
condition|)
return|return
name|screen
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|virtualDesktopForRootWindow
name|QXcbVirtualDesktop
modifier|*
name|QXcbConnection
operator|::
name|virtualDesktopForRootWindow
parameter_list|(
name|xcb_window_t
name|rootWindow
parameter_list|)
specifier|const
block|{
foreach|foreach
control|(
name|QXcbVirtualDesktop
modifier|*
name|virtualDesktop
decl|,
name|m_virtualDesktops
control|)
block|{
if|if
condition|(
name|virtualDesktop
operator|->
name|screen
argument_list|()
operator|->
name|root
operator|==
name|rootWindow
condition|)
return|return
name|virtualDesktop
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     \brief Synchronizes the screen list, adds new screens, removes deleted ones */
end_comment
begin_function
DECL|function|updateScreens
name|void
name|QXcbConnection
operator|::
name|updateScreens
parameter_list|(
specifier|const
name|xcb_randr_notify_event_t
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|->
name|subCode
operator|==
name|XCB_RANDR_NOTIFY_CRTC_CHANGE
condition|)
block|{
name|xcb_randr_crtc_change_t
name|crtc
init|=
name|event
operator|->
name|u
operator|.
name|cc
decl_stmt|;
name|QXcbVirtualDesktop
modifier|*
name|virtualDesktop
init|=
name|virtualDesktopForRootWindow
argument_list|(
name|crtc
operator|.
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|virtualDesktop
condition|)
comment|// Not for us
return|return;
name|QXcbScreen
modifier|*
name|screen
init|=
name|findScreenForCrtc
argument_list|(
name|crtc
operator|.
name|window
argument_list|,
name|crtc
operator|.
name|crtc
argument_list|)
decl_stmt|;
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|)
operator|<<
literal|"QXcbConnection: XCB_RANDR_NOTIFY_CRTC_CHANGE:"
operator|<<
name|crtc
operator|.
name|crtc
operator|<<
literal|"mode"
operator|<<
name|crtc
operator|.
name|mode
operator|<<
literal|"relevant screen"
operator|<<
name|screen
expr_stmt|;
comment|// Only update geometry when there's a valid mode on the CRTC
comment|// CRTC with node mode could mean that output has been disabled, and we'll
comment|// get RRNotifyOutputChange notification for that.
if|if
condition|(
name|screen
operator|&&
name|crtc
operator|.
name|mode
condition|)
block|{
if|if
condition|(
name|crtc
operator|.
name|rotation
operator|==
name|XCB_RANDR_ROTATION_ROTATE_90
operator|||
name|crtc
operator|.
name|rotation
operator|==
name|XCB_RANDR_ROTATION_ROTATE_270
condition|)
name|std
operator|::
name|swap
argument_list|(
name|crtc
operator|.
name|width
argument_list|,
name|crtc
operator|.
name|height
argument_list|)
expr_stmt|;
name|screen
operator|->
name|updateGeometry
argument_list|(
name|QRect
argument_list|(
name|crtc
operator|.
name|x
argument_list|,
name|crtc
operator|.
name|y
argument_list|,
name|crtc
operator|.
name|width
argument_list|,
name|crtc
operator|.
name|height
argument_list|)
argument_list|,
name|crtc
operator|.
name|rotation
argument_list|)
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|mode
argument_list|()
operator|!=
name|crtc
operator|.
name|mode
condition|)
name|screen
operator|->
name|updateRefreshRate
argument_list|(
name|crtc
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|subCode
operator|==
name|XCB_RANDR_NOTIFY_OUTPUT_CHANGE
condition|)
block|{
name|xcb_randr_output_change_t
name|output
init|=
name|event
operator|->
name|u
operator|.
name|oc
decl_stmt|;
name|QXcbVirtualDesktop
modifier|*
name|virtualDesktop
init|=
name|virtualDesktopForRootWindow
argument_list|(
name|output
operator|.
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|virtualDesktop
condition|)
comment|// Not for us
return|return;
name|QXcbScreen
modifier|*
name|screen
init|=
name|findScreenForOutput
argument_list|(
name|output
operator|.
name|window
argument_list|,
name|output
operator|.
name|output
argument_list|)
decl_stmt|;
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|)
operator|<<
literal|"QXcbConnection: XCB_RANDR_NOTIFY_OUTPUT_CHANGE:"
operator|<<
name|output
operator|.
name|output
expr_stmt|;
if|if
condition|(
name|screen
operator|&&
name|output
operator|.
name|connection
operator|==
name|XCB_RANDR_CONNECTION_DISCONNECTED
condition|)
block|{
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|)
operator|<<
literal|"screen"
operator|<<
name|screen
operator|->
name|name
argument_list|()
operator|<<
literal|"has been disconnected"
expr_stmt|;
name|destroyScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|screen
operator|&&
name|output
operator|.
name|connection
operator|==
name|XCB_RANDR_CONNECTION_CONNECTED
condition|)
block|{
comment|// New XRandR output is available and it's enabled
if|if
condition|(
name|output
operator|.
name|crtc
operator|!=
name|XCB_NONE
operator|&&
name|output
operator|.
name|mode
operator|!=
name|XCB_NONE
condition|)
block|{
name|xcb_randr_get_output_info_cookie_t
name|outputInfoCookie
init|=
name|xcb_randr_get_output_info
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|output
operator|.
name|output
argument_list|,
name|output
operator|.
name|config_timestamp
argument_list|)
decl_stmt|;
name|QScopedPointer
argument_list|<
name|xcb_randr_get_output_info_reply_t
argument_list|,
name|QScopedPointerPodDeleter
argument_list|>
name|outputInfo
argument_list|(
name|xcb_randr_get_output_info_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|outputInfoCookie
argument_list|,
name|NULL
argument_list|)
argument_list|)
decl_stmt|;
comment|// Find a fake screen
specifier|const
specifier|auto
name|scrs
init|=
name|virtualDesktop
operator|->
name|screens
argument_list|()
decl_stmt|;
for|for
control|(
name|QPlatformScreen
modifier|*
name|scr
range|:
name|scrs
control|)
block|{
name|QXcbScreen
modifier|*
name|xcbScreen
init|=
operator|(
name|QXcbScreen
operator|*
operator|)
name|scr
decl_stmt|;
if|if
condition|(
name|xcbScreen
operator|->
name|output
argument_list|()
operator|==
name|XCB_NONE
condition|)
block|{
name|screen
operator|=
name|xcbScreen
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|screen
condition|)
block|{
name|QString
name|nameWas
init|=
name|screen
operator|->
name|name
argument_list|()
decl_stmt|;
comment|// Transform the fake screen into a physical screen
name|screen
operator|->
name|setOutput
argument_list|(
name|output
operator|.
name|output
argument_list|,
name|outputInfo
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|updateScreen
argument_list|(
name|screen
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|)
operator|<<
literal|"output"
operator|<<
name|screen
operator|->
name|name
argument_list|()
operator|<<
literal|"is connected and enabled; was fake:"
operator|<<
name|nameWas
expr_stmt|;
block|}
else|else
block|{
name|screen
operator|=
name|createScreen
argument_list|(
name|virtualDesktop
argument_list|,
name|output
argument_list|,
name|outputInfo
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|)
operator|<<
literal|"output"
operator|<<
name|screen
operator|->
name|name
argument_list|()
operator|<<
literal|"is connected and enabled"
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|screen
condition|)
block|{
if|if
condition|(
name|output
operator|.
name|crtc
operator|==
name|XCB_NONE
operator|&&
name|output
operator|.
name|mode
operator|==
name|XCB_NONE
condition|)
block|{
comment|// Screen has been disabled
name|xcb_randr_get_output_info_cookie_t
name|outputInfoCookie
init|=
name|xcb_randr_get_output_info
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|output
operator|.
name|output
argument_list|,
name|output
operator|.
name|config_timestamp
argument_list|)
decl_stmt|;
name|QScopedPointer
argument_list|<
name|xcb_randr_get_output_info_reply_t
argument_list|,
name|QScopedPointerPodDeleter
argument_list|>
name|outputInfo
argument_list|(
name|xcb_randr_get_output_info_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|outputInfoCookie
argument_list|,
name|NULL
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|outputInfo
operator|->
name|crtc
operator|==
name|XCB_NONE
condition|)
block|{
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|)
operator|<<
literal|"output"
operator|<<
name|screen
operator|->
name|name
argument_list|()
operator|<<
literal|"has been disabled"
expr_stmt|;
name|destroyScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|)
operator|<<
literal|"output"
operator|<<
name|screen
operator|->
name|name
argument_list|()
operator|<<
literal|"has been temporarily disabled for the mode switch"
expr_stmt|;
comment|// Reset crtc to skip RRCrtcChangeNotify events,
comment|// because they may be invalid in the middle of the mode switch
name|screen
operator|->
name|setCrtc
argument_list|(
name|XCB_NONE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|updateScreen
argument_list|(
name|screen
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|)
operator|<<
literal|"output has changed"
operator|<<
name|screen
expr_stmt|;
block|}
block|}
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|)
operator|<<
literal|"primary output is"
operator|<<
name|qAsConst
argument_list|(
name|m_screens
argument_list|)
operator|.
name|first
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|checkOutputIsPrimary
name|bool
name|QXcbConnection
operator|::
name|checkOutputIsPrimary
parameter_list|(
name|xcb_window_t
name|rootWindow
parameter_list|,
name|xcb_randr_output_t
name|output
parameter_list|)
block|{
name|xcb_generic_error_t
modifier|*
name|error
init|=
literal|0
decl_stmt|;
name|xcb_randr_get_output_primary_cookie_t
name|primaryCookie
init|=
name|xcb_randr_get_output_primary
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|rootWindow
argument_list|)
decl_stmt|;
name|QScopedPointer
argument_list|<
name|xcb_randr_get_output_primary_reply_t
argument_list|,
name|QScopedPointerPodDeleter
argument_list|>
name|primary
argument_list|(
name|xcb_randr_get_output_primary_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|primaryCookie
argument_list|,
operator|&
name|error
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|primary
operator|||
name|error
condition|)
block|{
name|qWarning
argument_list|(
literal|"failed to get the primary output of the screen"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|NULL
expr_stmt|;
block|}
specifier|const
name|bool
name|isPrimary
init|=
name|primary
condition|?
operator|(
name|primary
operator|->
name|output
operator|==
name|output
operator|)
else|:
literal|false
decl_stmt|;
return|return
name|isPrimary
return|;
block|}
end_function
begin_function
DECL|function|updateScreen
name|void
name|QXcbConnection
operator|::
name|updateScreen
parameter_list|(
name|QXcbScreen
modifier|*
name|screen
parameter_list|,
specifier|const
name|xcb_randr_output_change_t
modifier|&
name|outputChange
parameter_list|)
block|{
name|screen
operator|->
name|setCrtc
argument_list|(
name|outputChange
operator|.
name|crtc
argument_list|)
expr_stmt|;
comment|// Set the new crtc, because it can be invalid
name|screen
operator|->
name|updateGeometry
argument_list|(
name|outputChange
operator|.
name|config_timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|mode
argument_list|()
operator|!=
name|outputChange
operator|.
name|mode
condition|)
name|screen
operator|->
name|updateRefreshRate
argument_list|(
name|outputChange
operator|.
name|mode
argument_list|)
expr_stmt|;
comment|// Only screen which belongs to the primary virtual desktop can be a primary screen
if|if
condition|(
name|screen
operator|->
name|screenNumber
argument_list|()
operator|==
name|m_primaryScreenNumber
condition|)
block|{
if|if
condition|(
operator|!
name|screen
operator|->
name|isPrimary
argument_list|()
operator|&&
name|checkOutputIsPrimary
argument_list|(
name|outputChange
operator|.
name|window
argument_list|,
name|outputChange
operator|.
name|output
argument_list|)
condition|)
block|{
name|screen
operator|->
name|setPrimary
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// If the screen became primary, reshuffle the order in QGuiApplicationPrivate
specifier|const
name|int
name|idx
init|=
name|m_screens
operator|.
name|indexOf
argument_list|(
name|screen
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
block|{
name|qAsConst
argument_list|(
name|m_screens
argument_list|)
operator|.
name|first
argument_list|()
operator|->
name|setPrimary
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|m_screens
operator|.
name|swap
argument_list|(
literal|0
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
name|screen
operator|->
name|virtualDesktop
argument_list|()
operator|->
name|setPrimaryScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|QXcbIntegration
operator|::
name|instance
argument_list|()
operator|->
name|setPrimaryScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|createScreen
name|QXcbScreen
modifier|*
name|QXcbConnection
operator|::
name|createScreen
parameter_list|(
name|QXcbVirtualDesktop
modifier|*
name|virtualDesktop
parameter_list|,
specifier|const
name|xcb_randr_output_change_t
modifier|&
name|outputChange
parameter_list|,
name|xcb_randr_get_output_info_reply_t
modifier|*
name|outputInfo
parameter_list|)
block|{
name|QXcbScreen
modifier|*
name|screen
init|=
operator|new
name|QXcbScreen
argument_list|(
name|this
argument_list|,
name|virtualDesktop
argument_list|,
name|outputChange
operator|.
name|output
argument_list|,
name|outputInfo
argument_list|)
decl_stmt|;
comment|// Only screen which belongs to the primary virtual desktop can be a primary screen
if|if
condition|(
name|screen
operator|->
name|screenNumber
argument_list|()
operator|==
name|m_primaryScreenNumber
condition|)
name|screen
operator|->
name|setPrimary
argument_list|(
name|checkOutputIsPrimary
argument_list|(
name|outputChange
operator|.
name|window
argument_list|,
name|outputChange
operator|.
name|output
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|isPrimary
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|m_screens
operator|.
name|isEmpty
argument_list|()
condition|)
name|qAsConst
argument_list|(
name|m_screens
argument_list|)
operator|.
name|first
argument_list|()
operator|->
name|setPrimary
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|m_screens
operator|.
name|prepend
argument_list|(
name|screen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_screens
operator|.
name|append
argument_list|(
name|screen
argument_list|)
expr_stmt|;
block|}
name|virtualDesktop
operator|->
name|addScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|QXcbIntegration
operator|::
name|instance
argument_list|()
operator|->
name|screenAdded
argument_list|(
name|screen
argument_list|,
name|screen
operator|->
name|isPrimary
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|screen
return|;
block|}
end_function
begin_function
DECL|function|destroyScreen
name|void
name|QXcbConnection
operator|::
name|destroyScreen
parameter_list|(
name|QXcbScreen
modifier|*
name|screen
parameter_list|)
block|{
name|QXcbVirtualDesktop
modifier|*
name|virtualDesktop
init|=
name|screen
operator|->
name|virtualDesktop
argument_list|()
decl_stmt|;
if|if
condition|(
name|virtualDesktop
operator|->
name|screens
argument_list|()
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// If there are no other screens on the same virtual desktop,
comment|// then transform the physical screen into a fake screen.
specifier|const
name|QString
name|nameWas
init|=
name|screen
operator|->
name|name
argument_list|()
decl_stmt|;
name|screen
operator|->
name|setOutput
argument_list|(
name|XCB_NONE
argument_list|,
name|Q_NULLPTR
argument_list|)
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|)
operator|<<
literal|"transformed"
operator|<<
name|nameWas
operator|<<
literal|"to fake"
operator|<<
name|screen
expr_stmt|;
block|}
else|else
block|{
comment|// There is more than one screen on the same virtual desktop, remove the screen
name|m_screens
operator|.
name|removeOne
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|virtualDesktop
operator|->
name|removeScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
comment|// When primary screen is removed, set the new primary screen
comment|// which belongs to the primary virtual desktop.
if|if
condition|(
name|screen
operator|->
name|isPrimary
argument_list|()
condition|)
block|{
name|QXcbScreen
modifier|*
name|newPrimary
init|=
operator|(
name|QXcbScreen
operator|*
operator|)
name|virtualDesktop
operator|->
name|screens
argument_list|()
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|newPrimary
operator|->
name|setPrimary
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|const
name|int
name|idx
init|=
name|m_screens
operator|.
name|indexOf
argument_list|(
name|newPrimary
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
name|m_screens
operator|.
name|swap
argument_list|(
literal|0
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|QXcbIntegration
operator|::
name|instance
argument_list|()
operator|->
name|setPrimaryScreen
argument_list|(
name|newPrimary
argument_list|)
expr_stmt|;
block|}
name|QXcbIntegration
operator|::
name|instance
argument_list|()
operator|->
name|destroyScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|initializeScreens
name|void
name|QXcbConnection
operator|::
name|initializeScreens
parameter_list|()
block|{
name|xcb_screen_iterator_t
name|it
init|=
name|xcb_setup_roots_iterator
argument_list|(
name|m_setup
argument_list|)
decl_stmt|;
name|int
name|xcbScreenNumber
init|=
literal|0
decl_stmt|;
comment|// screen number in the xcb sense
name|QXcbScreen
modifier|*
name|primaryScreen
init|=
name|Q_NULLPTR
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|rem
condition|)
block|{
comment|// Each "screen" in xcb terminology is a virtual desktop,
comment|// potentially a collection of separate juxtaposed monitors.
comment|// But we want a separate QScreen for each output (e.g. DVI-I-1, VGA-1, etc.)
comment|// which will become virtual siblings.
name|xcb_screen_t
modifier|*
name|xcbScreen
init|=
name|it
operator|.
name|data
decl_stmt|;
name|QXcbVirtualDesktop
modifier|*
name|virtualDesktop
init|=
operator|new
name|QXcbVirtualDesktop
argument_list|(
name|this
argument_list|,
name|xcbScreen
argument_list|,
name|xcbScreenNumber
argument_list|)
decl_stmt|;
name|m_virtualDesktops
operator|.
name|append
argument_list|(
name|virtualDesktop
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QPlatformScreen
modifier|*
argument_list|>
name|siblings
decl_stmt|;
if|if
condition|(
name|has_randr_extension
condition|)
block|{
name|xcb_generic_error_t
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
comment|// RRGetScreenResourcesCurrent is fast but it may return nothing if the
comment|// configuration is not initialized wrt to the hardware. We should call
comment|// RRGetScreenResources in this case.
name|QScopedPointer
argument_list|<
name|xcb_randr_get_screen_resources_reply_t
argument_list|,
name|QScopedPointerPodDeleter
argument_list|>
name|resources
decl_stmt|;
name|xcb_randr_get_screen_resources_current_cookie_t
name|resourcesCookie
init|=
name|xcb_randr_get_screen_resources_current
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcbScreen
operator|->
name|root
argument_list|)
decl_stmt|;
name|QScopedPointer
argument_list|<
name|xcb_randr_get_screen_resources_current_reply_t
argument_list|,
name|QScopedPointerPodDeleter
argument_list|>
name|resources_current
argument_list|(
name|xcb_randr_get_screen_resources_current_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|resourcesCookie
argument_list|,
operator|&
name|error
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|resources_current
operator|||
name|error
condition|)
block|{
name|qWarning
argument_list|(
literal|"failed to get the current screen resources"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xcb_timestamp_t
name|timestamp
decl_stmt|;
name|xcb_randr_output_t
modifier|*
name|outputs
init|=
name|Q_NULLPTR
decl_stmt|;
name|int
name|outputCount
init|=
name|xcb_randr_get_screen_resources_current_outputs_length
argument_list|(
name|resources_current
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|outputCount
condition|)
block|{
name|timestamp
operator|=
name|resources_current
operator|->
name|config_timestamp
expr_stmt|;
name|outputs
operator|=
name|xcb_randr_get_screen_resources_current_outputs
argument_list|(
name|resources_current
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xcb_randr_get_screen_resources_cookie_t
name|resourcesCookie
init|=
name|xcb_randr_get_screen_resources
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcbScreen
operator|->
name|root
argument_list|)
decl_stmt|;
name|resources
operator|.
name|reset
argument_list|(
name|xcb_randr_get_screen_resources_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|resourcesCookie
argument_list|,
operator|&
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resources
operator|||
name|error
condition|)
block|{
name|qWarning
argument_list|(
literal|"failed to get the screen resources"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timestamp
operator|=
name|resources
operator|->
name|config_timestamp
expr_stmt|;
name|outputCount
operator|=
name|xcb_randr_get_screen_resources_outputs_length
argument_list|(
name|resources
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|outputs
operator|=
name|xcb_randr_get_screen_resources_outputs
argument_list|(
name|resources
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outputCount
condition|)
block|{
name|xcb_randr_get_output_primary_cookie_t
name|primaryCookie
init|=
name|xcb_randr_get_output_primary
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcbScreen
operator|->
name|root
argument_list|)
decl_stmt|;
name|QScopedPointer
argument_list|<
name|xcb_randr_get_output_primary_reply_t
argument_list|,
name|QScopedPointerPodDeleter
argument_list|>
name|primary
argument_list|(
name|xcb_randr_get_output_primary_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|primaryCookie
argument_list|,
operator|&
name|error
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|primary
operator|||
name|error
condition|)
block|{
name|qWarning
argument_list|(
literal|"failed to get the primary output of the screen"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outputCount
condition|;
name|i
operator|++
control|)
block|{
name|QScopedPointer
argument_list|<
name|xcb_randr_get_output_info_reply_t
argument_list|,
name|QScopedPointerPodDeleter
argument_list|>
name|output
argument_list|(
name|xcb_randr_get_output_info_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcb_randr_get_output_info_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|outputs
index|[
name|i
index|]
argument_list|,
name|timestamp
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
decl_stmt|;
comment|// Invalid, disconnected or disabled output
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|output
operator|->
name|connection
operator|!=
name|XCB_RANDR_CONNECTION_CONNECTED
condition|)
block|{
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|,
literal|"Output %s is not connected"
argument_list|,
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|xcb_randr_get_output_info_name
argument_list|(
name|output
operator|.
name|data
argument_list|()
argument_list|)
argument_list|,
name|xcb_randr_get_output_info_name_length
argument_list|(
name|output
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|output
operator|->
name|crtc
operator|==
name|XCB_NONE
condition|)
block|{
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|,
literal|"Output %s is not enabled"
argument_list|,
name|qPrintable
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|xcb_randr_get_output_info_name
argument_list|(
name|output
operator|.
name|data
argument_list|()
argument_list|)
argument_list|,
name|xcb_randr_get_output_info_name_length
argument_list|(
name|output
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|QXcbScreen
modifier|*
name|screen
init|=
operator|new
name|QXcbScreen
argument_list|(
name|this
argument_list|,
name|virtualDesktop
argument_list|,
name|outputs
index|[
name|i
index|]
argument_list|,
name|output
operator|.
name|data
argument_list|()
argument_list|)
decl_stmt|;
name|siblings
operator|<<
name|screen
expr_stmt|;
name|m_screens
operator|<<
name|screen
expr_stmt|;
comment|// There can be multiple outputs per screen, use either
comment|// the first or an exact match.  An exact match isn't
comment|// always available if primary->output is XCB_NONE
comment|// or currently disconnected output.
if|if
condition|(
name|m_primaryScreenNumber
operator|==
name|xcbScreenNumber
condition|)
block|{
if|if
condition|(
operator|!
name|primaryScreen
operator|||
operator|(
name|primary
operator|&&
name|outputs
index|[
name|i
index|]
operator|==
name|primary
operator|->
name|output
operator|)
condition|)
block|{
if|if
condition|(
name|primaryScreen
condition|)
name|primaryScreen
operator|->
name|setPrimary
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|primaryScreen
operator|=
name|screen
expr_stmt|;
name|primaryScreen
operator|->
name|setPrimary
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|siblings
operator|.
name|prepend
argument_list|(
name|siblings
operator|.
name|takeLast
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|has_xinerama_extension
condition|)
block|{
comment|// Xinerama is available
name|xcb_xinerama_query_screens_cookie_t
name|cookie
init|=
name|xcb_xinerama_query_screens
argument_list|(
name|m_connection
argument_list|)
decl_stmt|;
name|xcb_xinerama_query_screens_reply_t
modifier|*
name|screens
init|=
name|xcb_xinerama_query_screens_reply
argument_list|(
name|m_connection
argument_list|,
name|cookie
argument_list|,
name|Q_NULLPTR
argument_list|)
decl_stmt|;
if|if
condition|(
name|screens
condition|)
block|{
name|xcb_xinerama_screen_info_iterator_t
name|it
init|=
name|xcb_xinerama_query_screens_screen_info_iterator
argument_list|(
name|screens
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|rem
condition|)
block|{
name|xcb_xinerama_screen_info_t
modifier|*
name|screen_info
init|=
name|it
operator|.
name|data
decl_stmt|;
name|QXcbScreen
modifier|*
name|screen
init|=
operator|new
name|QXcbScreen
argument_list|(
name|this
argument_list|,
name|virtualDesktop
argument_list|,
name|XCB_NONE
argument_list|,
name|Q_NULLPTR
argument_list|,
name|screen_info
argument_list|,
name|it
operator|.
name|index
argument_list|)
decl_stmt|;
name|siblings
operator|<<
name|screen
expr_stmt|;
name|m_screens
operator|<<
name|screen
expr_stmt|;
name|xcb_xinerama_screen_info_next
argument_list|(
operator|&
name|it
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|screens
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|siblings
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If there are no XRandR outputs or XRandR extension is missing,
comment|// then create a fake/legacy screen.
name|QXcbScreen
modifier|*
name|screen
init|=
operator|new
name|QXcbScreen
argument_list|(
name|this
argument_list|,
name|virtualDesktop
argument_list|,
name|XCB_NONE
argument_list|,
name|Q_NULLPTR
argument_list|)
decl_stmt|;
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|)
operator|<<
literal|"created fake screen"
operator|<<
name|screen
expr_stmt|;
name|m_screens
operator|<<
name|screen
expr_stmt|;
if|if
condition|(
name|m_primaryScreenNumber
operator|==
name|xcbScreenNumber
condition|)
block|{
name|primaryScreen
operator|=
name|screen
expr_stmt|;
name|primaryScreen
operator|->
name|setPrimary
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|siblings
operator|<<
name|screen
expr_stmt|;
block|}
name|virtualDesktop
operator|->
name|setScreens
argument_list|(
name|siblings
argument_list|)
expr_stmt|;
name|xcb_screen_next
argument_list|(
operator|&
name|it
argument_list|)
expr_stmt|;
operator|++
name|xcbScreenNumber
expr_stmt|;
block|}
comment|// for each xcb screen
foreach|foreach
control|(
name|QXcbVirtualDesktop
modifier|*
name|virtualDesktop
decl|,
name|m_virtualDesktops
control|)
name|virtualDesktop
operator|->
name|subscribeToXFixesSelectionNotify
argument_list|()
expr_stmt|;
if|if
condition|(
name|m_virtualDesktops
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qFatal
argument_list|(
literal|"QXcbConnection: no screens available"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Ensure the primary screen is first on the list
if|if
condition|(
name|primaryScreen
condition|)
block|{
if|if
condition|(
name|qAsConst
argument_list|(
name|m_screens
argument_list|)
operator|.
name|first
argument_list|()
operator|!=
name|primaryScreen
condition|)
block|{
name|m_screens
operator|.
name|removeOne
argument_list|(
name|primaryScreen
argument_list|)
expr_stmt|;
name|m_screens
operator|.
name|prepend
argument_list|(
name|primaryScreen
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Push the screens to QGuiApplication
foreach|foreach
control|(
name|QXcbScreen
modifier|*
name|screen
decl|,
name|m_screens
control|)
block|{
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|)
operator|<<
literal|"adding"
operator|<<
name|screen
operator|<<
literal|"(Primary:"
operator|<<
name|screen
operator|->
name|isPrimary
argument_list|()
operator|<<
literal|")"
expr_stmt|;
name|QXcbIntegration
operator|::
name|instance
argument_list|()
operator|->
name|screenAdded
argument_list|(
name|screen
argument_list|,
name|screen
operator|->
name|isPrimary
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|qCDebug
argument_list|(
name|lcQpaScreen
argument_list|)
operator|<<
literal|"primary output is"
operator|<<
name|qAsConst
argument_list|(
name|m_screens
argument_list|)
operator|.
name|first
argument_list|()
operator|->
name|name
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_constructor
DECL|function|QXcbConnection
name|QXcbConnection
operator|::
name|QXcbConnection
parameter_list|(
name|QXcbNativeInterface
modifier|*
name|nativeInterface
parameter_list|,
name|bool
name|canGrabServer
parameter_list|,
name|xcb_visualid_t
name|defaultVisualId
parameter_list|,
specifier|const
name|char
modifier|*
name|displayName
parameter_list|)
member_init_list|:
name|m_connection
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_canGrabServer
argument_list|(
name|canGrabServer
argument_list|)
member_init_list|,
name|m_defaultVisualId
argument_list|(
name|defaultVisualId
argument_list|)
member_init_list|,
name|m_primaryScreenNumber
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_displayName
argument_list|(
name|displayName
condition|?
name|QByteArray
argument_list|(
name|displayName
argument_list|)
else|:
name|qgetenv
argument_list|(
literal|"DISPLAY"
argument_list|)
argument_list|)
member_init_list|,
name|m_nativeInterface
argument_list|(
name|nativeInterface
argument_list|)
ifdef|#
directive|ifdef
name|XCB_USE_XLIB
member_init_list|,
name|m_xlib_display
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
member_init_list|,
name|xfixes_first_event
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|xrandr_first_event
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|xkb_first_event
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|has_xinerama_extension
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|has_shape_extension
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|has_randr_extension
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|has_input_shape
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|has_xkb
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_buttons
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_focusWindow
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_mouseGrabber
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_clientLeader
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_systemTrayTracker
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_glIntegration
argument_list|(
name|Q_NULLPTR
argument_list|)
member_init_list|,
name|m_xiGrab
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_qtSelectionOwner
argument_list|(
literal|0
argument_list|)
block|{
ifdef|#
directive|ifdef
name|XCB_USE_XLIB
name|Display
modifier|*
name|dpy
init|=
name|XOpenDisplay
argument_list|(
name|m_displayName
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dpy
condition|)
block|{
name|m_primaryScreenNumber
operator|=
name|DefaultScreen
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|m_connection
operator|=
name|XGetXCBConnection
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|XSetEventQueueOwner
argument_list|(
name|dpy
argument_list|,
name|XCBOwnsEventQueue
argument_list|)
expr_stmt|;
name|XSetErrorHandler
argument_list|(
name|nullErrorHandler
argument_list|)
expr_stmt|;
name|XSetIOErrorHandler
argument_list|(
name|ioErrorHandler
argument_list|)
expr_stmt|;
name|m_xlib_display
operator|=
name|dpy
expr_stmt|;
block|}
else|#
directive|else
name|m_connection
operator|=
name|xcb_connect
argument_list|(
name|m_displayName
operator|.
name|constData
argument_list|()
argument_list|,
operator|&
name|m_primaryScreenNumber
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//XCB_USE_XLIB
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
operator|!
name|m_connection
operator|||
name|xcb_connection_has_error
argument_list|(
name|m_connection
argument_list|)
argument_list|)
condition|)
name|qFatal
argument_list|(
literal|"QXcbConnection: Could not connect to display %s"
argument_list|,
name|m_displayName
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|m_reader
operator|=
operator|new
name|QXcbEventReader
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|m_reader
operator|->
name|start
argument_list|()
expr_stmt|;
name|xcb_extension_t
modifier|*
name|extensions
index|[]
init|=
block|{
operator|&
name|xcb_shm_id
block|,
operator|&
name|xcb_xfixes_id
block|,
operator|&
name|xcb_randr_id
block|,
operator|&
name|xcb_shape_id
block|,
operator|&
name|xcb_sync_id
block|,
ifndef|#
directive|ifndef
name|QT_NO_XKB
operator|&
name|xcb_xkb_id
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCB_USE_RENDER
operator|&
name|xcb_render_id
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
for|for
control|(
name|xcb_extension_t
modifier|*
modifier|*
name|ext_it
init|=
name|extensions
init|;
operator|*
name|ext_it
condition|;
operator|++
name|ext_it
control|)
name|xcb_prefetch_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|*
name|ext_it
argument_list|)
expr_stmt|;
name|m_setup
operator|=
name|xcb_get_setup
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
expr_stmt|;
name|initializeAllAtoms
argument_list|()
expr_stmt|;
name|m_time
operator|=
name|XCB_CURRENT_TIME
expr_stmt|;
name|m_netWmUserTime
operator|=
name|XCB_CURRENT_TIME
expr_stmt|;
if|if
condition|(
operator|!
name|qEnvironmentVariableIsSet
argument_list|(
literal|"QT_XCB_NO_XRANDR"
argument_list|)
condition|)
name|initializeXRandr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|has_randr_extension
condition|)
name|initializeXinerama
argument_list|()
expr_stmt|;
name|initializeXFixes
argument_list|()
expr_stmt|;
name|initializeScreens
argument_list|()
expr_stmt|;
name|initializeXRender
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|XCB_USE_XINPUT2
argument_list|)
name|m_xi2Enabled
operator|=
literal|false
expr_stmt|;
name|initializeXInput2
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|initializeXShape
argument_list|()
expr_stmt|;
name|initializeXKB
argument_list|()
expr_stmt|;
name|m_wmSupport
operator|.
name|reset
argument_list|(
operator|new
name|QXcbWMSupport
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|m_keyboard
operator|=
operator|new
name|QXcbKeyboard
argument_list|(
name|this
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
name|m_clipboard
operator|=
operator|new
name|QXcbClipboard
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
name|m_drag
operator|=
operator|new
name|QXcbDrag
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_startupId
operator|=
name|qgetenv
argument_list|(
literal|"DESKTOP_STARTUP_ID"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_startupId
operator|.
name|isNull
argument_list|()
condition|)
name|qunsetenv
argument_list|(
literal|"DESKTOP_STARTUP_ID"
argument_list|)
expr_stmt|;
name|QStringList
name|glIntegrationNames
decl_stmt|;
name|glIntegrationNames
operator|<<
name|QStringLiteral
argument_list|(
literal|"xcb_glx"
argument_list|)
operator|<<
name|QStringLiteral
argument_list|(
literal|"xcb_egl"
argument_list|)
expr_stmt|;
name|QString
name|glIntegrationName
init|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|qgetenv
argument_list|(
literal|"QT_XCB_GL_INTEGRATION"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|glIntegrationName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
literal|"QT_XCB_GL_INTEGRATION is set to"
operator|<<
name|glIntegrationName
expr_stmt|;
if|if
condition|(
name|glIntegrationName
operator|!=
name|QLatin1String
argument_list|(
literal|"none"
argument_list|)
condition|)
block|{
name|glIntegrationNames
operator|.
name|removeAll
argument_list|(
name|glIntegrationName
argument_list|)
expr_stmt|;
name|glIntegrationNames
operator|.
name|prepend
argument_list|(
name|glIntegrationName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glIntegrationNames
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|glIntegrationNames
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
literal|"Choosing xcb gl-integration based on following priority\n"
operator|<<
name|glIntegrationNames
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|glIntegrationNames
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|m_glIntegration
condition|;
name|i
operator|++
control|)
block|{
name|m_glIntegration
operator|=
name|QXcbGlIntegrationFactory
operator|::
name|create
argument_list|(
name|glIntegrationNames
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_glIntegration
operator|&&
operator|!
name|m_glIntegration
operator|->
name|initialize
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
literal|"Failed to initialize xcb gl-integration"
operator|<<
name|glIntegrationNames
operator|.
name|at
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|delete
name|m_glIntegration
expr_stmt|;
name|m_glIntegration
operator|=
name|Q_NULLPTR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|m_glIntegration
condition|)
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
literal|"Failed to create xcb gl-integration"
expr_stmt|;
block|}
name|sync
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QXcbConnection
name|QXcbConnection
operator|::
name|~
name|QXcbConnection
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
operator|delete
name|m_clipboard
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
operator|delete
name|m_drag
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|XCB_USE_XINPUT2
argument_list|)
name|finalizeXInput2
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m_reader
operator|->
name|isRunning
argument_list|()
condition|)
block|{
name|sendConnectionEvent
argument_list|(
name|QXcbAtom
operator|::
name|_QT_CLOSE_CONNECTION
argument_list|)
expr_stmt|;
name|m_reader
operator|->
name|wait
argument_list|()
expr_stmt|;
block|}
operator|delete
name|m_reader
expr_stmt|;
name|QXcbIntegration
modifier|*
name|integration
init|=
name|QXcbIntegration
operator|::
name|instance
argument_list|()
decl_stmt|;
comment|// Delete screens in reverse order to avoid crash in case of multiple screens
while|while
condition|(
operator|!
name|m_screens
operator|.
name|isEmpty
argument_list|()
condition|)
name|integration
operator|->
name|destroyScreen
argument_list|(
name|m_screens
operator|.
name|takeLast
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|m_virtualDesktops
operator|.
name|isEmpty
argument_list|()
condition|)
operator|delete
name|m_virtualDesktops
operator|.
name|takeLast
argument_list|()
expr_stmt|;
operator|delete
name|m_glIntegration
expr_stmt|;
ifdef|#
directive|ifdef
name|XCB_USE_XLIB
name|XCloseDisplay
argument_list|(
operator|(
name|Display
operator|*
operator|)
name|m_xlib_display
argument_list|)
expr_stmt|;
else|#
directive|else
name|xcb_disconnect
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|delete
name|m_keyboard
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|primaryScreen
name|QXcbScreen
modifier|*
name|QXcbConnection
operator|::
name|primaryScreen
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|m_screens
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|m_screens
operator|.
name|first
argument_list|()
operator|->
name|screenNumber
argument_list|()
operator|==
name|primaryScreenNumber
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|m_screens
operator|.
name|first
argument_list|()
return|;
block|}
return|return
name|Q_NULLPTR
return|;
block|}
end_function
begin_function
DECL|function|addWindowEventListener
name|void
name|QXcbConnection
operator|::
name|addWindowEventListener
parameter_list|(
name|xcb_window_t
name|id
parameter_list|,
name|QXcbWindowEventListener
modifier|*
name|eventListener
parameter_list|)
block|{
name|m_mapper
operator|.
name|insert
argument_list|(
name|id
argument_list|,
name|eventListener
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|removeWindowEventListener
name|void
name|QXcbConnection
operator|::
name|removeWindowEventListener
parameter_list|(
name|xcb_window_t
name|id
parameter_list|)
block|{
name|m_mapper
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|windowEventListenerFromId
name|QXcbWindowEventListener
modifier|*
name|QXcbConnection
operator|::
name|windowEventListenerFromId
parameter_list|(
name|xcb_window_t
name|id
parameter_list|)
block|{
return|return
name|m_mapper
operator|.
name|value
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|platformWindowFromId
name|QXcbWindow
modifier|*
name|QXcbConnection
operator|::
name|platformWindowFromId
parameter_list|(
name|xcb_window_t
name|id
parameter_list|)
block|{
name|QXcbWindowEventListener
modifier|*
name|listener
init|=
name|m_mapper
operator|.
name|value
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|listener
condition|)
return|return
name|listener
operator|->
name|toWindow
argument_list|()
return|;
return|return
literal|0
return|;
block|}
end_function
begin_define
DECL|macro|HANDLE_PLATFORM_WINDOW_EVENT
define|#
directive|define
name|HANDLE_PLATFORM_WINDOW_EVENT
parameter_list|(
name|event_t
parameter_list|,
name|windowMember
parameter_list|,
name|handler
parameter_list|)
define|\
value|{ \     event_t *e = (event_t *)event; \     if (QXcbWindowEventListener *eventListener = windowEventListenerFromId(e->windowMember))  { \         handled = eventListener->handleGenericEvent(event,&result); \         if (!handled) \             eventListener->handler(e); \     } \ } \ break;
end_define
begin_define
DECL|macro|HANDLE_KEYBOARD_EVENT
define|#
directive|define
name|HANDLE_KEYBOARD_EVENT
parameter_list|(
name|event_t
parameter_list|,
name|handler
parameter_list|)
define|\
value|{ \     event_t *e = (event_t *)event; \     if (QXcbWindowEventListener *eventListener = windowEventListenerFromId(e->event)) { \         handled = eventListener->handleGenericEvent(event,&result); \         if (!handled) \             m_keyboard->handler(e); \     } \ } \ break;
end_define
begin_comment
comment|//#define XCB_EVENT_DEBUG
end_comment
begin_function
DECL|function|printXcbEvent
name|void
name|printXcbEvent
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XCB_EVENT_DEBUG
DECL|macro|PRINT_XCB_EVENT
define|#
directive|define
name|PRINT_XCB_EVENT
parameter_list|(
name|ev
parameter_list|)
define|\
value|case ev: \         qDebug("QXcbConnection: %s: %d - %s - sequence: %d", message, int(ev), #ev, event->sequence); \         break;
switch|switch
condition|(
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
condition|)
block|{
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_KEY_PRESS
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_KEY_RELEASE
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_BUTTON_PRESS
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_BUTTON_RELEASE
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_MOTION_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_ENTER_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_LEAVE_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_FOCUS_IN
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_FOCUS_OUT
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_KEYMAP_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_EXPOSE
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_GRAPHICS_EXPOSURE
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_NO_EXPOSURE
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_VISIBILITY_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_CREATE_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_DESTROY_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_UNMAP_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_MAP_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_MAP_REQUEST
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_REPARENT_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_CONFIGURE_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_CONFIGURE_REQUEST
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_GRAVITY_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_RESIZE_REQUEST
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_CIRCULATE_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_CIRCULATE_REQUEST
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_PROPERTY_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_SELECTION_CLEAR
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_SELECTION_REQUEST
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_SELECTION_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_COLORMAP_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_CLIENT_MESSAGE
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_MAPPING_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_GE_GENERIC
argument_list|)
expr_stmt|;
default|default:
name|qDebug
argument_list|(
literal|"QXcbConnection: %s: unknown event - response_type: %d - sequence: %d"
argument_list|,
name|message
argument_list|,
name|int
argument_list|(
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
argument_list|)
argument_list|,
name|int
argument_list|(
name|event
operator|->
name|sequence
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_decl_stmt
DECL|variable|xcb_errors
specifier|const
name|char
modifier|*
name|xcb_errors
index|[]
init|=
block|{
literal|"Success"
block|,
literal|"BadRequest"
block|,
literal|"BadValue"
block|,
literal|"BadWindow"
block|,
literal|"BadPixmap"
block|,
literal|"BadAtom"
block|,
literal|"BadCursor"
block|,
literal|"BadFont"
block|,
literal|"BadMatch"
block|,
literal|"BadDrawable"
block|,
literal|"BadAccess"
block|,
literal|"BadAlloc"
block|,
literal|"BadColor"
block|,
literal|"BadGC"
block|,
literal|"BadIDChoice"
block|,
literal|"BadName"
block|,
literal|"BadLength"
block|,
literal|"BadImplementation"
block|,
literal|"Unknown"
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|xcb_protocol_request_codes
specifier|const
name|char
modifier|*
name|xcb_protocol_request_codes
index|[]
init|=
block|{
literal|"Null"
block|,
literal|"CreateWindow"
block|,
literal|"ChangeWindowAttributes"
block|,
literal|"GetWindowAttributes"
block|,
literal|"DestroyWindow"
block|,
literal|"DestroySubwindows"
block|,
literal|"ChangeSaveSet"
block|,
literal|"ReparentWindow"
block|,
literal|"MapWindow"
block|,
literal|"MapSubwindows"
block|,
literal|"UnmapWindow"
block|,
literal|"UnmapSubwindows"
block|,
literal|"ConfigureWindow"
block|,
literal|"CirculateWindow"
block|,
literal|"GetGeometry"
block|,
literal|"QueryTree"
block|,
literal|"InternAtom"
block|,
literal|"GetAtomName"
block|,
literal|"ChangeProperty"
block|,
literal|"DeleteProperty"
block|,
literal|"GetProperty"
block|,
literal|"ListProperties"
block|,
literal|"SetSelectionOwner"
block|,
literal|"GetSelectionOwner"
block|,
literal|"ConvertSelection"
block|,
literal|"SendEvent"
block|,
literal|"GrabPointer"
block|,
literal|"UngrabPointer"
block|,
literal|"GrabButton"
block|,
literal|"UngrabButton"
block|,
literal|"ChangeActivePointerGrab"
block|,
literal|"GrabKeyboard"
block|,
literal|"UngrabKeyboard"
block|,
literal|"GrabKey"
block|,
literal|"UngrabKey"
block|,
literal|"AllowEvents"
block|,
literal|"GrabServer"
block|,
literal|"UngrabServer"
block|,
literal|"QueryPointer"
block|,
literal|"GetMotionEvents"
block|,
literal|"TranslateCoords"
block|,
literal|"WarpPointer"
block|,
literal|"SetInputFocus"
block|,
literal|"GetInputFocus"
block|,
literal|"QueryKeymap"
block|,
literal|"OpenFont"
block|,
literal|"CloseFont"
block|,
literal|"QueryFont"
block|,
literal|"QueryTextExtents"
block|,
literal|"ListFonts"
block|,
literal|"ListFontsWithInfo"
block|,
literal|"SetFontPath"
block|,
literal|"GetFontPath"
block|,
literal|"CreatePixmap"
block|,
literal|"FreePixmap"
block|,
literal|"CreateGC"
block|,
literal|"ChangeGC"
block|,
literal|"CopyGC"
block|,
literal|"SetDashes"
block|,
literal|"SetClipRectangles"
block|,
literal|"FreeGC"
block|,
literal|"ClearArea"
block|,
literal|"CopyArea"
block|,
literal|"CopyPlane"
block|,
literal|"PolyPoint"
block|,
literal|"PolyLine"
block|,
literal|"PolySegment"
block|,
literal|"PolyRectangle"
block|,
literal|"PolyArc"
block|,
literal|"FillPoly"
block|,
literal|"PolyFillRectangle"
block|,
literal|"PolyFillArc"
block|,
literal|"PutImage"
block|,
literal|"GetImage"
block|,
literal|"PolyText8"
block|,
literal|"PolyText16"
block|,
literal|"ImageText8"
block|,
literal|"ImageText16"
block|,
literal|"CreateColormap"
block|,
literal|"FreeColormap"
block|,
literal|"CopyColormapAndFree"
block|,
literal|"InstallColormap"
block|,
literal|"UninstallColormap"
block|,
literal|"ListInstalledColormaps"
block|,
literal|"AllocColor"
block|,
literal|"AllocNamedColor"
block|,
literal|"AllocColorCells"
block|,
literal|"AllocColorPlanes"
block|,
literal|"FreeColors"
block|,
literal|"StoreColors"
block|,
literal|"StoreNamedColor"
block|,
literal|"QueryColors"
block|,
literal|"LookupColor"
block|,
literal|"CreateCursor"
block|,
literal|"CreateGlyphCursor"
block|,
literal|"FreeCursor"
block|,
literal|"RecolorCursor"
block|,
literal|"QueryBestSize"
block|,
literal|"QueryExtension"
block|,
literal|"ListExtensions"
block|,
literal|"ChangeKeyboardMapping"
block|,
literal|"GetKeyboardMapping"
block|,
literal|"ChangeKeyboardControl"
block|,
literal|"GetKeyboardControl"
block|,
literal|"Bell"
block|,
literal|"ChangePointerControl"
block|,
literal|"GetPointerControl"
block|,
literal|"SetScreenSaver"
block|,
literal|"GetScreenSaver"
block|,
literal|"ChangeHosts"
block|,
literal|"ListHosts"
block|,
literal|"SetAccessControl"
block|,
literal|"SetCloseDownMode"
block|,
literal|"KillClient"
block|,
literal|"RotateProperties"
block|,
literal|"ForceScreenSaver"
block|,
literal|"SetPointerMapping"
block|,
literal|"GetPointerMapping"
block|,
literal|"SetModifierMapping"
block|,
literal|"GetModifierMapping"
block|,
literal|"Unknown"
block|}
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|Q_XCB_DEBUG
end_ifdef
begin_function
DECL|function|log
name|void
name|QXcbConnection
operator|::
name|log
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|sequence
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_callLogMutex
argument_list|)
decl_stmt|;
name|CallInfo
name|info
decl_stmt|;
name|info
operator|.
name|sequence
operator|=
name|sequence
expr_stmt|;
name|info
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|info
operator|.
name|line
operator|=
name|line
expr_stmt|;
name|m_callLog
operator|<<
name|info
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|handleXcbError
name|void
name|QXcbConnection
operator|::
name|handleXcbError
parameter_list|(
name|xcb_generic_error_t
modifier|*
name|error
parameter_list|)
block|{
name|long
name|result
init|=
literal|0
decl_stmt|;
name|QAbstractEventDispatcher
modifier|*
name|dispatcher
init|=
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|()
decl_stmt|;
if|if
condition|(
name|dispatcher
operator|&&
name|dispatcher
operator|->
name|filterNativeEvent
argument_list|(
name|m_nativeInterface
operator|->
name|genericEventFilterType
argument_list|()
argument_list|,
name|error
argument_list|,
operator|&
name|result
argument_list|)
condition|)
return|return;
name|uint
name|clamped_error_code
init|=
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|error
operator|->
name|error_code
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|xcb_errors
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xcb_errors
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|uint
name|clamped_major_code
init|=
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|error
operator|->
name|major_code
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|xcb_protocol_request_codes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xcb_protocol_request_codes
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|qWarning
argument_list|(
literal|"QXcbConnection: XCB error: %d (%s), sequence: %d, resource id: %d, major code: %d (%s), minor code: %d"
argument_list|,
name|int
argument_list|(
name|error
operator|->
name|error_code
argument_list|)
argument_list|,
name|xcb_errors
index|[
name|clamped_error_code
index|]
argument_list|,
name|int
argument_list|(
name|error
operator|->
name|sequence
argument_list|)
argument_list|,
name|int
argument_list|(
name|error
operator|->
name|resource_id
argument_list|)
argument_list|,
name|int
argument_list|(
name|error
operator|->
name|major_code
argument_list|)
argument_list|,
name|xcb_protocol_request_codes
index|[
name|clamped_major_code
index|]
argument_list|,
name|int
argument_list|(
name|error
operator|->
name|minor_code
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_XCB_DEBUG
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_callLogMutex
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|m_callLog
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|sequence
operator|==
name|error
operator|->
name|sequence
condition|)
block|{
name|qDebug
argument_list|(
literal|"Caused by: %s:%d"
argument_list|,
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|file
operator|.
name|constData
argument_list|()
argument_list|,
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|sequence
operator|>
name|error
operator|->
name|sequence
condition|)
block|{
name|qDebug
argument_list|(
literal|"Caused some time before: %s:%d"
argument_list|,
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|file
operator|.
name|constData
argument_list|()
argument_list|,
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|qDebug
argument_list|(
literal|"and after: %s:%d"
argument_list|,
name|m_callLog
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|file
operator|.
name|constData
argument_list|()
argument_list|,
name|m_callLog
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|m_callLog
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|m_callLog
operator|.
name|isEmpty
argument_list|()
condition|)
name|qDebug
argument_list|(
literal|"Caused some time after: %s:%d"
argument_list|,
name|qAsConst
argument_list|(
name|m_callLog
argument_list|)
operator|.
name|first
argument_list|()
operator|.
name|file
operator|.
name|constData
argument_list|()
argument_list|,
name|qAsConst
argument_list|(
name|m_callLog
argument_list|)
operator|.
name|first
argument_list|()
operator|.
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|translateMouseButtons
specifier|static
name|Qt
operator|::
name|MouseButtons
name|translateMouseButtons
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|Qt
operator|::
name|MouseButtons
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|s
operator|&
name|XCB_BUTTON_MASK_1
condition|)
name|ret
operator||=
name|Qt
operator|::
name|LeftButton
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|XCB_BUTTON_MASK_2
condition|)
name|ret
operator||=
name|Qt
operator|::
name|MidButton
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|XCB_BUTTON_MASK_3
condition|)
name|ret
operator||=
name|Qt
operator|::
name|RightButton
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|translateMouseButton
name|Qt
operator|::
name|MouseButton
name|QXcbConnection
operator|::
name|translateMouseButton
parameter_list|(
name|xcb_button_t
name|s
parameter_list|)
block|{
switch|switch
condition|(
name|s
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Qt
operator|::
name|LeftButton
return|;
case|case
literal|2
case|:
return|return
name|Qt
operator|::
name|MidButton
return|;
case|case
literal|3
case|:
return|return
name|Qt
operator|::
name|RightButton
return|;
comment|// Button values 4-7 were already handled as Wheel events, and won't occur here.
case|case
literal|8
case|:
return|return
name|Qt
operator|::
name|BackButton
return|;
comment|// Also known as Qt::ExtraButton1
case|case
literal|9
case|:
return|return
name|Qt
operator|::
name|ForwardButton
return|;
comment|// Also known as Qt::ExtraButton2
case|case
literal|10
case|:
return|return
name|Qt
operator|::
name|ExtraButton3
return|;
case|case
literal|11
case|:
return|return
name|Qt
operator|::
name|ExtraButton4
return|;
case|case
literal|12
case|:
return|return
name|Qt
operator|::
name|ExtraButton5
return|;
case|case
literal|13
case|:
return|return
name|Qt
operator|::
name|ExtraButton6
return|;
case|case
literal|14
case|:
return|return
name|Qt
operator|::
name|ExtraButton7
return|;
case|case
literal|15
case|:
return|return
name|Qt
operator|::
name|ExtraButton8
return|;
case|case
literal|16
case|:
return|return
name|Qt
operator|::
name|ExtraButton9
return|;
case|case
literal|17
case|:
return|return
name|Qt
operator|::
name|ExtraButton10
return|;
case|case
literal|18
case|:
return|return
name|Qt
operator|::
name|ExtraButton11
return|;
case|case
literal|19
case|:
return|return
name|Qt
operator|::
name|ExtraButton12
return|;
case|case
literal|20
case|:
return|return
name|Qt
operator|::
name|ExtraButton13
return|;
case|case
literal|21
case|:
return|return
name|Qt
operator|::
name|ExtraButton14
return|;
case|case
literal|22
case|:
return|return
name|Qt
operator|::
name|ExtraButton15
return|;
case|case
literal|23
case|:
return|return
name|Qt
operator|::
name|ExtraButton16
return|;
case|case
literal|24
case|:
return|return
name|Qt
operator|::
name|ExtraButton17
return|;
case|case
literal|25
case|:
return|return
name|Qt
operator|::
name|ExtraButton18
return|;
case|case
literal|26
case|:
return|return
name|Qt
operator|::
name|ExtraButton19
return|;
case|case
literal|27
case|:
return|return
name|Qt
operator|::
name|ExtraButton20
return|;
case|case
literal|28
case|:
return|return
name|Qt
operator|::
name|ExtraButton21
return|;
case|case
literal|29
case|:
return|return
name|Qt
operator|::
name|ExtraButton22
return|;
case|case
literal|30
case|:
return|return
name|Qt
operator|::
name|ExtraButton23
return|;
case|case
literal|31
case|:
return|return
name|Qt
operator|::
name|ExtraButton24
return|;
default|default:
return|return
name|Qt
operator|::
name|NoButton
return|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_XKB
end_ifndef
begin_namespace
namespace|namespace
block|{
typedef|typedef
union|union
block|{
comment|/* All XKB events share these fields. */
struct|struct
block|{
DECL|member|response_type
name|uint8_t
name|response_type
decl_stmt|;
DECL|member|xkbType
name|uint8_t
name|xkbType
decl_stmt|;
DECL|member|sequence
name|uint16_t
name|sequence
decl_stmt|;
DECL|member|time
name|xcb_timestamp_t
name|time
decl_stmt|;
DECL|member|deviceID
name|uint8_t
name|deviceID
decl_stmt|;
DECL|member|any
block|}
name|any
struct|;
DECL|member|new_keyboard_notify
name|xcb_xkb_new_keyboard_notify_event_t
name|new_keyboard_notify
decl_stmt|;
DECL|member|map_notify
name|xcb_xkb_map_notify_event_t
name|map_notify
decl_stmt|;
DECL|member|state_notify
name|xcb_xkb_state_notify_event_t
name|state_notify
decl_stmt|;
DECL|typedef|_xkb_event
block|}
name|_xkb_event
typedef|;
block|}
end_namespace
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|handleXcbEvent
name|void
name|QXcbConnection
operator|::
name|handleXcbEvent
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|Q_XCB_DEBUG
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_callLogMutex
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|m_callLog
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|sequence
operator|>=
name|event
operator|->
name|sequence
condition|)
break|break;
name|m_callLog
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|long
name|result
init|=
literal|0
decl_stmt|;
name|QAbstractEventDispatcher
modifier|*
name|dispatcher
init|=
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|()
decl_stmt|;
name|bool
name|handled
init|=
name|dispatcher
operator|&&
name|dispatcher
operator|->
name|filterNativeEvent
argument_list|(
name|m_nativeInterface
operator|->
name|genericEventFilterType
argument_list|()
argument_list|,
name|event
argument_list|,
operator|&
name|result
argument_list|)
decl_stmt|;
name|uint
name|response_type
init|=
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
decl_stmt|;
if|if
condition|(
operator|!
name|handled
condition|)
block|{
switch|switch
condition|(
name|response_type
condition|)
block|{
case|case
name|XCB_EXPOSE
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_expose_event_t
argument_list|,
name|window
argument_list|,
name|handleExposeEvent
argument_list|)
expr_stmt|;
comment|// press/release/motion is only delivered here when XI 2.2+ is _not_ in use
case|case
name|XCB_BUTTON_PRESS
case|:
block|{
name|xcb_button_press_event_t
modifier|*
name|ev
init|=
operator|(
name|xcb_button_press_event_t
operator|*
operator|)
name|event
decl_stmt|;
name|m_keyboard
operator|->
name|updateXKBStateFromCore
argument_list|(
name|ev
operator|->
name|state
argument_list|)
expr_stmt|;
comment|// the event explicitly contains the state of the three first buttons,
comment|// the rest we need to manage ourselves
name|m_buttons
operator|=
operator|(
name|m_buttons
operator|&
operator|~
literal|0x7
operator|)
operator||
name|translateMouseButtons
argument_list|(
name|ev
operator|->
name|state
argument_list|)
expr_stmt|;
name|m_buttons
operator||=
name|translateMouseButton
argument_list|(
name|ev
operator|->
name|detail
argument_list|)
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaXInput
argument_list|,
literal|"legacy mouse press, button %d state %X"
argument_list|,
name|ev
operator|->
name|detail
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|m_buttons
argument_list|)
argument_list|)
expr_stmt|;
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_button_press_event_t
argument_list|,
name|event
argument_list|,
name|handleButtonPressEvent
argument_list|)
expr_stmt|;
block|}
case|case
name|XCB_BUTTON_RELEASE
case|:
block|{
name|xcb_button_release_event_t
modifier|*
name|ev
init|=
operator|(
name|xcb_button_release_event_t
operator|*
operator|)
name|event
decl_stmt|;
name|m_keyboard
operator|->
name|updateXKBStateFromCore
argument_list|(
name|ev
operator|->
name|state
argument_list|)
expr_stmt|;
name|m_buttons
operator|=
operator|(
name|m_buttons
operator|&
operator|~
literal|0x7
operator|)
operator||
name|translateMouseButtons
argument_list|(
name|ev
operator|->
name|state
argument_list|)
expr_stmt|;
name|m_buttons
operator|&=
operator|~
name|translateMouseButton
argument_list|(
name|ev
operator|->
name|detail
argument_list|)
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaXInput
argument_list|,
literal|"legacy mouse release, button %d state %X"
argument_list|,
name|ev
operator|->
name|detail
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|m_buttons
argument_list|)
argument_list|)
expr_stmt|;
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_button_release_event_t
argument_list|,
name|event
argument_list|,
name|handleButtonReleaseEvent
argument_list|)
expr_stmt|;
block|}
case|case
name|XCB_MOTION_NOTIFY
case|:
block|{
name|xcb_motion_notify_event_t
modifier|*
name|ev
init|=
operator|(
name|xcb_motion_notify_event_t
operator|*
operator|)
name|event
decl_stmt|;
name|m_keyboard
operator|->
name|updateXKBStateFromCore
argument_list|(
name|ev
operator|->
name|state
argument_list|)
expr_stmt|;
name|m_buttons
operator|=
operator|(
name|m_buttons
operator|&
operator|~
literal|0x7
operator|)
operator||
name|translateMouseButtons
argument_list|(
name|ev
operator|->
name|state
argument_list|)
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaXInput
argument_list|,
literal|"legacy mouse move %d,%d button %d state %X"
argument_list|,
name|ev
operator|->
name|event_x
argument_list|,
name|ev
operator|->
name|event_y
argument_list|,
name|ev
operator|->
name|detail
argument_list|,
cast|static_cast
argument_list|<
name|unsigned
name|int
argument_list|>
argument_list|(
name|m_buttons
argument_list|)
argument_list|)
expr_stmt|;
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_motion_notify_event_t
argument_list|,
name|event
argument_list|,
name|handleMotionNotifyEvent
argument_list|)
expr_stmt|;
block|}
case|case
name|XCB_CONFIGURE_NOTIFY
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_configure_notify_event_t
argument_list|,
name|event
argument_list|,
name|handleConfigureNotifyEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_MAP_NOTIFY
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_map_notify_event_t
argument_list|,
name|event
argument_list|,
name|handleMapNotifyEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_UNMAP_NOTIFY
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_unmap_notify_event_t
argument_list|,
name|event
argument_list|,
name|handleUnmapNotifyEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_DESTROY_NOTIFY
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_destroy_notify_event_t
argument_list|,
name|event
argument_list|,
name|handleDestroyNotifyEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_CLIENT_MESSAGE
case|:
name|handleClientMessageEvent
argument_list|(
operator|(
name|xcb_client_message_event_t
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|XCB_ENTER_NOTIFY
case|:
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT22
if|if
condition|(
name|isAtLeastXI22
argument_list|()
operator|&&
name|xi2MouseEvents
argument_list|()
condition|)
break|break;
endif|#
directive|endif
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_enter_notify_event_t
argument_list|,
name|event
argument_list|,
name|handleEnterNotifyEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_LEAVE_NOTIFY
case|:
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT22
if|if
condition|(
name|isAtLeastXI22
argument_list|()
operator|&&
name|xi2MouseEvents
argument_list|()
condition|)
break|break;
endif|#
directive|endif
name|m_keyboard
operator|->
name|updateXKBStateFromCore
argument_list|(
operator|(
operator|(
name|xcb_leave_notify_event_t
operator|*
operator|)
name|event
operator|)
operator|->
name|state
argument_list|)
expr_stmt|;
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_leave_notify_event_t
argument_list|,
name|event
argument_list|,
name|handleLeaveNotifyEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_FOCUS_IN
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_focus_in_event_t
argument_list|,
name|event
argument_list|,
name|handleFocusInEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_FOCUS_OUT
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_focus_out_event_t
argument_list|,
name|event
argument_list|,
name|handleFocusOutEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_KEY_PRESS
case|:
block|{
name|xcb_key_press_event_t
modifier|*
name|kp
init|=
operator|(
name|xcb_key_press_event_t
operator|*
operator|)
name|event
decl_stmt|;
name|m_keyboard
operator|->
name|updateXKBStateFromCore
argument_list|(
name|kp
operator|->
name|state
argument_list|)
expr_stmt|;
name|setTime
argument_list|(
name|kp
operator|->
name|time
argument_list|)
expr_stmt|;
name|HANDLE_KEYBOARD_EVENT
argument_list|(
name|xcb_key_press_event_t
argument_list|,
name|handleKeyPressEvent
argument_list|)
expr_stmt|;
block|}
case|case
name|XCB_KEY_RELEASE
case|:
name|m_keyboard
operator|->
name|updateXKBStateFromCore
argument_list|(
operator|(
operator|(
name|xcb_key_release_event_t
operator|*
operator|)
name|event
operator|)
operator|->
name|state
argument_list|)
expr_stmt|;
name|HANDLE_KEYBOARD_EVENT
argument_list|(
name|xcb_key_release_event_t
argument_list|,
name|handleKeyReleaseEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_MAPPING_NOTIFY
case|:
name|m_keyboard
operator|->
name|handleMappingNotifyEvent
argument_list|(
operator|(
name|xcb_mapping_notify_event_t
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|XCB_SELECTION_REQUEST
case|:
block|{
name|xcb_selection_request_event_t
modifier|*
name|sr
init|=
operator|(
name|xcb_selection_request_event_t
operator|*
operator|)
name|event
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
if|if
condition|(
name|sr
operator|->
name|selection
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndSelection
argument_list|)
condition|)
name|m_drag
operator|->
name|handleSelectionRequest
argument_list|(
name|sr
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
name|m_clipboard
operator|->
name|handleSelectionRequest
argument_list|(
name|sr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
block|}
case|case
name|XCB_SELECTION_CLEAR
case|:
name|setTime
argument_list|(
operator|(
operator|(
name|xcb_selection_clear_event_t
operator|*
operator|)
name|event
operator|)
operator|->
name|time
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
name|m_clipboard
operator|->
name|handleSelectionClearRequest
argument_list|(
operator|(
name|xcb_selection_clear_event_t
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|handled
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|XCB_SELECTION_NOTIFY
case|:
name|setTime
argument_list|(
operator|(
operator|(
name|xcb_selection_notify_event_t
operator|*
operator|)
name|event
operator|)
operator|->
name|time
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|XCB_PROPERTY_NOTIFY
case|:
block|{
name|xcb_property_notify_event_t
modifier|*
name|pn
init|=
operator|(
name|xcb_property_notify_event_t
operator|*
operator|)
name|event
decl_stmt|;
if|if
condition|(
name|pn
operator|->
name|atom
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_NET_WORKAREA
argument_list|)
condition|)
block|{
name|QXcbVirtualDesktop
modifier|*
name|virtualDesktop
init|=
name|virtualDesktopForRootWindow
argument_list|(
name|pn
operator|->
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
name|virtualDesktop
condition|)
name|virtualDesktop
operator|->
name|updateWorkArea
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_property_notify_event_t
argument_list|,
name|window
argument_list|,
name|handlePropertyNotifyEvent
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|XCB_USE_XINPUT2
argument_list|)
case|case
name|XCB_GE_GENERIC
case|:
comment|// Here the windowEventListener is invoked from xi2HandleEvent()
if|if
condition|(
name|m_xi2Enabled
operator|&&
name|isXIEvent
argument_list|(
name|event
argument_list|,
name|m_xiOpCode
argument_list|)
condition|)
name|xi2HandleEvent
argument_list|(
cast|reinterpret_cast
argument_list|<
name|xcb_ge_event_t
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|handled
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|handled
condition|)
block|{
if|if
condition|(
name|response_type
operator|==
name|xfixes_first_event
operator|+
name|XCB_XFIXES_SELECTION_NOTIFY
condition|)
block|{
name|xcb_xfixes_selection_notify_event_t
modifier|*
name|notify_event
init|=
operator|(
name|xcb_xfixes_selection_notify_event_t
operator|*
operator|)
name|event
decl_stmt|;
name|setTime
argument_list|(
name|notify_event
operator|->
name|timestamp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
name|m_clipboard
operator|->
name|handleXFixesSelectionRequest
argument_list|(
name|notify_event
argument_list|)
expr_stmt|;
endif|#
directive|endif
foreach|foreach
control|(
name|QXcbVirtualDesktop
modifier|*
name|virtualDesktop
decl|,
name|m_virtualDesktops
control|)
name|virtualDesktop
operator|->
name|handleXFixesSelectionNotify
argument_list|(
name|notify_event
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_randr_extension
operator|&&
name|response_type
operator|==
name|xrandr_first_event
operator|+
name|XCB_RANDR_NOTIFY
condition|)
block|{
name|updateScreens
argument_list|(
operator|(
name|xcb_randr_notify_event_t
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_randr_extension
operator|&&
name|response_type
operator|==
name|xrandr_first_event
operator|+
name|XCB_RANDR_SCREEN_CHANGE_NOTIFY
condition|)
block|{
name|xcb_randr_screen_change_notify_event_t
modifier|*
name|change_event
init|=
operator|(
name|xcb_randr_screen_change_notify_event_t
operator|*
operator|)
name|event
decl_stmt|;
foreach|foreach
control|(
name|QXcbScreen
modifier|*
name|s
decl|,
name|m_screens
control|)
block|{
if|if
condition|(
name|s
operator|->
name|root
argument_list|()
operator|==
name|change_event
operator|->
name|root
condition|)
name|s
operator|->
name|handleScreenChange
argument_list|(
name|change_event
argument_list|)
expr_stmt|;
block|}
name|handled
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_XKB
block|}
elseif|else
if|if
condition|(
name|response_type
operator|==
name|xkb_first_event
condition|)
block|{
comment|// https://bugs.freedesktop.org/show_bug.cgi?id=51295
name|_xkb_event
modifier|*
name|xkb_event
init|=
cast|reinterpret_cast
argument_list|<
name|_xkb_event
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|xkb_event
operator|->
name|any
operator|.
name|deviceID
operator|==
name|m_keyboard
operator|->
name|coreDeviceId
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|xkb_event
operator|->
name|any
operator|.
name|xkbType
condition|)
block|{
comment|// XkbNewKkdNotify and XkbMapNotify together capture all sorts of keymap
comment|// updates (e.g. xmodmap, xkbcomp, setxkbmap), with minimal redundent recompilations.
case|case
name|XCB_XKB_STATE_NOTIFY
case|:
name|m_keyboard
operator|->
name|updateXKBState
argument_list|(
operator|&
name|xkb_event
operator|->
name|state_notify
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|XCB_XKB_MAP_NOTIFY
case|:
name|m_keyboard
operator|->
name|handleMappingNotifyEvent
argument_list|(
operator|&
name|xkb_event
operator|->
name|map_notify
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|XCB_XKB_NEW_KEYBOARD_NOTIFY
case|:
block|{
name|xcb_xkb_new_keyboard_notify_event_t
modifier|*
name|ev
init|=
operator|&
name|xkb_event
operator|->
name|new_keyboard_notify
decl_stmt|;
if|if
condition|(
name|ev
operator|->
name|changed
operator|&
name|XCB_XKB_NKN_DETAIL_KEYCODES
condition|)
name|m_keyboard
operator|->
name|updateKeymap
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
operator|!
name|handled
operator|&&
name|m_glIntegration
condition|)
name|handled
operator|=
name|m_glIntegration
operator|->
name|handleXcbEvent
argument_list|(
name|event
argument_list|,
name|response_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|handled
condition|)
name|printXcbEvent
argument_list|(
literal|"Handled XCB event"
argument_list|,
name|event
argument_list|)
expr_stmt|;
else|else
name|printXcbEvent
argument_list|(
literal|"Unhandled XCB event"
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addPeekFunc
name|void
name|QXcbConnection
operator|::
name|addPeekFunc
parameter_list|(
name|PeekFunc
name|f
parameter_list|)
block|{
name|m_peekFuncs
operator|.
name|append
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QXcbEventReader
name|QXcbEventReader
operator|::
name|QXcbEventReader
parameter_list|(
name|QXcbConnection
modifier|*
name|connection
parameter_list|)
member_init_list|:
name|m_connection
argument_list|(
name|connection
argument_list|)
block|{
name|checkXcbPollForQueuedEvent
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|start
name|void
name|QXcbEventReader
operator|::
name|start
parameter_list|()
block|{
if|if
condition|(
name|local_xcb_poll_for_queued_event
condition|)
block|{
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|eventPending
argument_list|()
argument_list|)
argument_list|,
name|m_connection
argument_list|,
name|SLOT
argument_list|(
name|processXcbEvents
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|m_connection
argument_list|,
name|SLOT
argument_list|(
name|processXcbEvents
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QThread
operator|::
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Must be done after we have an event-dispatcher. By posting a method invocation
comment|// we are sure that by the time the method is called we have an event-dispatcher.
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"registerForEvents"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|registerForEvents
name|void
name|QXcbEventReader
operator|::
name|registerForEvents
parameter_list|()
block|{
name|QSocketNotifier
modifier|*
name|notifier
init|=
operator|new
name|QSocketNotifier
argument_list|(
name|xcb_get_file_descriptor
argument_list|(
name|m_connection
operator|->
name|xcb_connection
argument_list|()
argument_list|)
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|connect
argument_list|(
name|notifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|m_connection
argument_list|,
name|SLOT
argument_list|(
name|processXcbEvents
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QAbstractEventDispatcher
modifier|*
name|dispatcher
init|=
name|QGuiApplicationPrivate
operator|::
name|eventDispatcher
decl_stmt|;
name|connect
argument_list|(
name|dispatcher
argument_list|,
name|SIGNAL
argument_list|(
name|aboutToBlock
argument_list|()
argument_list|)
argument_list|,
name|m_connection
argument_list|,
name|SLOT
argument_list|(
name|processXcbEvents
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|dispatcher
argument_list|,
name|SIGNAL
argument_list|(
name|awake
argument_list|()
argument_list|)
argument_list|,
name|m_connection
argument_list|,
name|SLOT
argument_list|(
name|processXcbEvents
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|registerEventDispatcher
name|void
name|QXcbEventReader
operator|::
name|registerEventDispatcher
parameter_list|(
name|QAbstractEventDispatcher
modifier|*
name|dispatcher
parameter_list|)
block|{
comment|// flush the xcb connection before the EventDispatcher is going to block
comment|// In the non-threaded case processXcbEvents is called before going to block,
comment|// which flushes the connection.
if|if
condition|(
name|local_xcb_poll_for_queued_event
condition|)
name|connect
argument_list|(
name|dispatcher
argument_list|,
name|SIGNAL
argument_list|(
name|aboutToBlock
argument_list|()
argument_list|)
argument_list|,
name|m_connection
argument_list|,
name|SLOT
argument_list|(
name|flush
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|run
name|void
name|QXcbEventReader
operator|::
name|run
parameter_list|()
block|{
name|xcb_generic_event_t
modifier|*
name|event
decl_stmt|;
while|while
condition|(
name|m_connection
operator|&&
operator|(
name|event
operator|=
name|xcb_wait_for_event
argument_list|(
name|m_connection
operator|->
name|xcb_connection
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|m_mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|addEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
while|while
condition|(
name|m_connection
operator|&&
operator|(
name|event
operator|=
name|local_xcb_poll_for_queued_event
argument_list|(
name|m_connection
operator|->
name|xcb_connection
argument_list|()
argument_list|)
operator|)
condition|)
name|addEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|m_mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
emit|emit
name|eventPending
argument_list|()
emit|;
block|}
name|m_mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_events
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|m_events
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|m_events
operator|.
name|clear
argument_list|()
expr_stmt|;
name|m_mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addEvent
name|void
name|QXcbEventReader
operator|::
name|addEvent
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
operator|(
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
operator|)
operator|==
name|XCB_CLIENT_MESSAGE
operator|&&
operator|(
operator|(
name|xcb_client_message_event_t
operator|*
operator|)
name|event
operator|)
operator|->
name|type
operator|==
name|m_connection
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_QT_CLOSE_CONNECTION
argument_list|)
condition|)
name|m_connection
operator|=
literal|0
expr_stmt|;
name|m_events
operator|<<
name|event
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lock
name|QXcbEventArray
modifier|*
name|QXcbEventReader
operator|::
name|lock
parameter_list|()
block|{
name|m_mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|local_xcb_poll_for_queued_event
condition|)
block|{
while|while
condition|(
name|xcb_generic_event_t
modifier|*
name|event
init|=
name|xcb_poll_for_event
argument_list|(
name|m_connection
operator|->
name|xcb_connection
argument_list|()
argument_list|)
condition|)
name|m_events
operator|<<
name|event
expr_stmt|;
block|}
return|return
operator|&
name|m_events
return|;
block|}
end_function
begin_function
DECL|function|unlock
name|void
name|QXcbEventReader
operator|::
name|unlock
parameter_list|()
block|{
name|m_mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setFocusWindow
name|void
name|QXcbConnection
operator|::
name|setFocusWindow
parameter_list|(
name|QXcbWindow
modifier|*
name|w
parameter_list|)
block|{
name|m_focusWindow
operator|=
name|w
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setMouseGrabber
name|void
name|QXcbConnection
operator|::
name|setMouseGrabber
parameter_list|(
name|QXcbWindow
modifier|*
name|w
parameter_list|)
block|{
name|m_mouseGrabber
operator|=
name|w
expr_stmt|;
block|}
end_function
begin_function
DECL|function|grabServer
name|void
name|QXcbConnection
operator|::
name|grabServer
parameter_list|()
block|{
if|if
condition|(
name|m_canGrabServer
condition|)
name|xcb_grab_server
argument_list|(
name|m_connection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ungrabServer
name|void
name|QXcbConnection
operator|::
name|ungrabServer
parameter_list|()
block|{
if|if
condition|(
name|m_canGrabServer
condition|)
name|xcb_ungrab_server
argument_list|(
name|m_connection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendConnectionEvent
name|void
name|QXcbConnection
operator|::
name|sendConnectionEvent
parameter_list|(
name|QXcbAtom
operator|::
name|Atom
name|a
parameter_list|,
name|uint
name|id
parameter_list|)
block|{
name|xcb_client_message_event_t
name|event
decl_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|xcb_window_t
name|eventListener
init|=
name|xcb_generate_id
argument_list|(
name|m_connection
argument_list|)
decl_stmt|;
name|xcb_screen_iterator_t
name|it
init|=
name|xcb_setup_roots_iterator
argument_list|(
name|m_setup
argument_list|)
decl_stmt|;
name|xcb_screen_t
modifier|*
name|screen
init|=
name|it
operator|.
name|data
decl_stmt|;
name|Q_XCB_CALL
argument_list|(
name|xcb_create_window
argument_list|(
name|m_connection
argument_list|,
name|XCB_COPY_FROM_PARENT
argument_list|,
name|eventListener
argument_list|,
name|screen
operator|->
name|root
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|XCB_WINDOW_CLASS_INPUT_ONLY
argument_list|,
name|screen
operator|->
name|root_visual
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|response_type
operator|=
name|XCB_CLIENT_MESSAGE
expr_stmt|;
name|event
operator|.
name|format
operator|=
literal|32
expr_stmt|;
name|event
operator|.
name|sequence
operator|=
literal|0
expr_stmt|;
name|event
operator|.
name|window
operator|=
name|eventListener
expr_stmt|;
name|event
operator|.
name|type
operator|=
name|atom
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|event
operator|.
name|data
operator|.
name|data32
index|[
literal|0
index|]
operator|=
name|id
expr_stmt|;
name|Q_XCB_CALL
argument_list|(
name|xcb_send_event
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|eventListener
argument_list|,
name|XCB_EVENT_MASK_NO_EVENT
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|Q_XCB_CALL
argument_list|(
name|xcb_destroy_window
argument_list|(
name|m_connection
argument_list|,
name|eventListener
argument_list|)
argument_list|)
expr_stmt|;
name|xcb_flush
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|class|PropertyNotifyEvent
class|class
name|PropertyNotifyEvent
block|{
public|public:
DECL|function|PropertyNotifyEvent
name|PropertyNotifyEvent
parameter_list|(
name|xcb_window_t
name|win
parameter_list|,
name|xcb_atom_t
name|property
parameter_list|)
member_init_list|:
name|window
argument_list|(
name|win
argument_list|)
member_init_list|,
name|type
argument_list|(
name|XCB_PROPERTY_NOTIFY
argument_list|)
member_init_list|,
name|atom
argument_list|(
name|property
argument_list|)
block|{}
DECL|member|window
name|xcb_window_t
name|window
decl_stmt|;
DECL|member|type
name|int
name|type
decl_stmt|;
DECL|member|atom
name|xcb_atom_t
name|atom
decl_stmt|;
DECL|function|checkEvent
name|bool
name|checkEvent
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|event
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|(
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
operator|)
operator|!=
name|type
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|xcb_property_notify_event_t
modifier|*
name|pn
init|=
operator|(
name|xcb_property_notify_event_t
operator|*
operator|)
name|event
decl_stmt|;
if|if
condition|(
operator|(
name|pn
operator|->
name|window
operator|==
name|window
operator|)
operator|&&
operator|(
name|pn
operator|->
name|atom
operator|==
name|atom
operator|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
class|;
block|}
end_namespace
begin_function
DECL|function|getTimestamp
name|xcb_timestamp_t
name|QXcbConnection
operator|::
name|getTimestamp
parameter_list|()
block|{
comment|// send a dummy event to myself to get the timestamp from X server.
name|xcb_window_t
name|root_win
init|=
name|rootWindow
argument_list|()
decl_stmt|;
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_APPEND
argument_list|,
name|root_win
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIP_TEMPORARY
argument_list|)
argument_list|,
name|XCB_ATOM_INTEGER
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|connection
argument_list|()
operator|->
name|flush
argument_list|()
expr_stmt|;
name|PropertyNotifyEvent
name|checker
argument_list|(
name|root_win
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIP_TEMPORARY
argument_list|)
argument_list|)
decl_stmt|;
name|xcb_generic_event_t
modifier|*
name|event
init|=
literal|0
decl_stmt|;
comment|// lets keep this inside a loop to avoid a possible race condition, where
comment|// reader thread has not yet had the time to acquire the mutex in order
comment|// to add the new set of events to its event queue
while|while
condition|(
operator|!
name|event
condition|)
block|{
name|connection
argument_list|()
operator|->
name|sync
argument_list|()
expr_stmt|;
name|event
operator|=
name|checkEvent
argument_list|(
name|checker
argument_list|)
expr_stmt|;
block|}
name|xcb_property_notify_event_t
modifier|*
name|pn
init|=
operator|(
name|xcb_property_notify_event_t
operator|*
operator|)
name|event
decl_stmt|;
name|xcb_timestamp_t
name|timestamp
init|=
name|pn
operator|->
name|time
decl_stmt|;
name|free
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|xcb_delete_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|root_win
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIP_TEMPORARY
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|timestamp
return|;
block|}
end_function
begin_function
DECL|function|getSelectionOwner
name|xcb_window_t
name|QXcbConnection
operator|::
name|getSelectionOwner
parameter_list|(
name|xcb_atom_t
name|atom
parameter_list|)
specifier|const
block|{
name|xcb_connection_t
modifier|*
name|c
init|=
name|xcb_connection
argument_list|()
decl_stmt|;
name|xcb_get_selection_owner_cookie_t
name|cookie
init|=
name|xcb_get_selection_owner
argument_list|(
name|c
argument_list|,
name|atom
argument_list|)
decl_stmt|;
name|xcb_get_selection_owner_reply_t
modifier|*
name|reply
decl_stmt|;
name|reply
operator|=
name|xcb_get_selection_owner_reply
argument_list|(
name|c
argument_list|,
name|cookie
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xcb_window_t
name|win
init|=
name|reply
operator|->
name|owner
decl_stmt|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function
begin_function
DECL|function|getQtSelectionOwner
name|xcb_window_t
name|QXcbConnection
operator|::
name|getQtSelectionOwner
parameter_list|()
block|{
if|if
condition|(
operator|!
name|m_qtSelectionOwner
condition|)
block|{
name|xcb_screen_t
modifier|*
name|xcbScreen
init|=
name|primaryVirtualDesktop
argument_list|()
operator|->
name|screen
argument_list|()
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|,
name|y
init|=
literal|0
decl_stmt|,
name|w
init|=
literal|3
decl_stmt|,
name|h
init|=
literal|3
decl_stmt|;
name|m_qtSelectionOwner
operator|=
name|xcb_generate_id
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
expr_stmt|;
name|Q_XCB_CALL
argument_list|(
name|xcb_create_window
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_COPY_FROM_PARENT
argument_list|,
comment|// depth -- same as root
name|m_qtSelectionOwner
argument_list|,
comment|// window id
name|xcbScreen
operator|->
name|root
argument_list|,
comment|// parent window id
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
literal|0
argument_list|,
comment|// border width
name|XCB_WINDOW_CLASS_INPUT_OUTPUT
argument_list|,
comment|// window class
name|xcbScreen
operator|->
name|root_visual
argument_list|,
comment|// visual
literal|0
argument_list|,
comment|// value mask
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// value list
block|}
return|return
name|m_qtSelectionOwner
return|;
block|}
end_function
begin_function
DECL|function|rootWindow
name|xcb_window_t
name|QXcbConnection
operator|::
name|rootWindow
parameter_list|()
block|{
name|QXcbScreen
modifier|*
name|s
init|=
name|primaryScreen
argument_list|()
decl_stmt|;
return|return
name|s
condition|?
name|s
operator|->
name|root
argument_list|()
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|clientLeader
name|xcb_window_t
name|QXcbConnection
operator|::
name|clientLeader
parameter_list|()
block|{
if|if
condition|(
name|m_clientLeader
operator|==
literal|0
condition|)
block|{
name|m_clientLeader
operator|=
name|xcb_generate_id
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
expr_stmt|;
name|QXcbScreen
modifier|*
name|screen
init|=
name|primaryScreen
argument_list|()
decl_stmt|;
name|Q_XCB_CALL
argument_list|(
name|xcb_create_window
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_COPY_FROM_PARENT
argument_list|,
name|m_clientLeader
argument_list|,
name|screen
operator|->
name|root
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|XCB_WINDOW_CLASS_INPUT_OUTPUT
argument_list|,
name|screen
operator|->
name|screen
argument_list|()
operator|->
name|root_visual
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|QByteArray
name|ba
argument_list|(
literal|"Qt client leader window"
argument_list|)
decl_stmt|;
name|Q_XCB_CALL
argument_list|(
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|m_clientLeader
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_NET_WM_NAME
argument_list|)
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|UTF8_STRING
argument_list|)
argument_list|,
literal|8
argument_list|,
name|ba
operator|.
name|length
argument_list|()
argument_list|,
name|ba
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_XCB_CALL
argument_list|(
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|m_clientLeader
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|WM_CLIENT_LEADER
argument_list|)
argument_list|,
name|XCB_ATOM_WINDOW
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|,
operator|&
name|m_clientLeader
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_SESSIONMANAGER
argument_list|)
operator|&&
name|defined
argument_list|(
name|XCB_USE_SM
argument_list|)
comment|// If we are session managed, inform the window manager about it
name|QByteArray
name|session
init|=
name|qGuiApp
operator|->
name|sessionId
argument_list|()
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|session
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Q_XCB_CALL
argument_list|(
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|m_clientLeader
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|SM_CLIENT_ID
argument_list|)
argument_list|,
name|XCB_ATOM_STRING
argument_list|,
literal|8
argument_list|,
name|session
operator|.
name|length
argument_list|()
argument_list|,
name|session
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|m_clientLeader
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_USE_XLIB
end_ifdef
begin_function
DECL|function|xlib_display
name|void
modifier|*
name|QXcbConnection
operator|::
name|xlib_display
parameter_list|()
specifier|const
block|{
return|return
name|m_xlib_display
return|;
block|}
end_function
begin_function
DECL|function|createVisualInfoForDefaultVisualId
name|void
modifier|*
name|QXcbConnection
operator|::
name|createVisualInfoForDefaultVisualId
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|m_defaultVisualId
operator|==
name|UINT_MAX
condition|)
return|return
literal|0
return|;
name|XVisualInfo
name|info
decl_stmt|;
name|memset
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|visualid
operator|=
name|m_defaultVisualId
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|XVisualInfo
modifier|*
name|retVisual
init|=
name|XGetVisualInfo
argument_list|(
name|DISPLAY_FROM_XCB
argument_list|(
name|this
argument_list|)
argument_list|,
name|VisualIDMask
argument_list|,
operator|&
name|info
argument_list|,
operator|&
name|count
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|count
operator|<
literal|2
argument_list|)
expr_stmt|;
return|return
name|retVisual
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|XCB_USE_XINPUT2
argument_list|)
end_if
begin_comment
comment|// it is safe to cast XI_* events here as long as we are only touching the first 32 bytes,
end_comment
begin_comment
comment|// after that position event needs memmove, see xi2PrepareXIGenericDeviceEvent
end_comment
begin_function
DECL|function|isXIType
specifier|static
specifier|inline
name|bool
name|isXIType
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|,
name|int
name|opCode
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isXIEvent
argument_list|(
name|event
argument_list|,
name|opCode
argument_list|)
condition|)
return|return
literal|false
return|;
name|xXIGenericDeviceEvent
modifier|*
name|xiEvent
init|=
cast|reinterpret_cast
argument_list|<
name|xXIGenericDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
return|return
name|xiEvent
operator|->
name|evtype
operator|==
name|type
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|isValid
specifier|static
specifier|inline
name|bool
name|isValid
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|)
block|{
return|return
name|event
operator|&&
operator|(
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
operator|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Compresses events of the same type to avoid swamping the event queue.     If event compression is not desired there are several options what developers can do:      1) Write responsive applications. We drop events that have been buffered in the event        queue while waiting on unresponsive GUI thread.     2) Use QAbstractNativeEventFilter to get all events from X connection. This is not optimal        because it requires working with native event types.     3) Or add public API to Qt for disabling event compression QTBUG-44964  */
end_comment
begin_function
DECL|function|compressEvent
name|bool
name|QXcbConnection
operator|::
name|compressEvent
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|,
name|int
name|currentIndex
parameter_list|,
name|QXcbEventArray
modifier|*
name|eventqueue
parameter_list|)
specifier|const
block|{
name|uint
name|responseType
init|=
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
decl_stmt|;
name|int
name|nextIndex
init|=
name|currentIndex
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|responseType
operator|==
name|XCB_MOTION_NOTIFY
condition|)
block|{
comment|// compress XCB_MOTION_NOTIFY notify events
for|for
control|(
name|int
name|j
init|=
name|nextIndex
init|;
name|j
operator|<
name|eventqueue
operator|->
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|xcb_generic_event_t
modifier|*
name|next
init|=
name|eventqueue
operator|->
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|(
name|next
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|next
operator|->
name|response_type
operator|==
name|XCB_MOTION_NOTIFY
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|XCB_USE_XINPUT2
argument_list|)
comment|// compress XI_* events
if|if
condition|(
name|responseType
operator|==
name|XCB_GE_GENERIC
condition|)
block|{
if|if
condition|(
operator|!
name|m_xi2Enabled
condition|)
return|return
literal|false
return|;
comment|// compress XI_Motion
if|if
condition|(
name|isXIType
argument_list|(
name|event
argument_list|,
name|m_xiOpCode
argument_list|,
name|XI_Motion
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
name|nextIndex
init|;
name|j
operator|<
name|eventqueue
operator|->
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|xcb_generic_event_t
modifier|*
name|next
init|=
name|eventqueue
operator|->
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|(
name|next
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|isXIType
argument_list|(
name|next
argument_list|,
name|m_xiOpCode
argument_list|,
name|XI_Motion
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT22
comment|// compress XI_TouchUpdate for the same touch point id
if|if
condition|(
name|isXIType
argument_list|(
name|event
argument_list|,
name|m_xiOpCode
argument_list|,
name|XI_TouchUpdate
argument_list|)
condition|)
block|{
name|xXIDeviceEvent
modifier|*
name|xiDeviceEvent
init|=
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|uint32_t
name|id
init|=
name|xiDeviceEvent
operator|->
name|detail
operator|%
name|INT_MAX
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|nextIndex
init|;
name|j
operator|<
name|eventqueue
operator|->
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|xcb_generic_event_t
modifier|*
name|next
init|=
name|eventqueue
operator|->
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|(
name|next
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|isXIType
argument_list|(
name|next
argument_list|,
name|m_xiOpCode
argument_list|,
name|XI_TouchUpdate
argument_list|)
condition|)
block|{
name|xXIDeviceEvent
modifier|*
name|xiDeviceNextEvent
init|=
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|xiDeviceNextEvent
operator|->
name|detail
operator|%
name|INT_MAX
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
endif|#
directive|endif
return|return
literal|false
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|responseType
operator|==
name|XCB_CONFIGURE_NOTIFY
condition|)
block|{
comment|// compress multiple configure notify events for the same window
for|for
control|(
name|int
name|j
init|=
name|nextIndex
init|;
name|j
operator|<
name|eventqueue
operator|->
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|xcb_generic_event_t
modifier|*
name|next
init|=
name|eventqueue
operator|->
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|isValid
argument_list|(
name|next
argument_list|)
operator|&&
name|next
operator|->
name|response_type
operator|==
name|XCB_CONFIGURE_NOTIFY
operator|&&
operator|(
operator|(
name|xcb_configure_notify_event_t
operator|*
operator|)
name|next
operator|)
operator|->
name|event
operator|==
operator|(
operator|(
name|xcb_configure_notify_event_t
operator|*
operator|)
name|event
operator|)
operator|->
name|event
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|processXcbEvents
name|void
name|QXcbConnection
operator|::
name|processXcbEvents
parameter_list|()
block|{
name|int
name|connection_error
init|=
name|xcb_connection_has_error
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|connection_error
condition|)
block|{
name|qWarning
argument_list|(
literal|"The X11 connection broke (error %d). Did the X11 server die?"
argument_list|,
name|connection_error
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|QXcbEventArray
modifier|*
name|eventqueue
init|=
name|m_reader
operator|->
name|lock
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|eventqueue
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|xcb_generic_event_t
modifier|*
name|event
init|=
name|eventqueue
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|event
condition|)
continue|continue;
name|QScopedPointer
argument_list|<
name|xcb_generic_event_t
argument_list|,
name|QScopedPointerPodDeleter
argument_list|>
name|eventGuard
argument_list|(
name|event
argument_list|)
decl_stmt|;
operator|(
operator|*
name|eventqueue
operator|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
operator|)
condition|)
block|{
name|handleXcbError
argument_list|(
operator|(
name|xcb_generic_error_t
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|compressEvent
argument_list|(
name|event
argument_list|,
name|i
argument_list|,
name|eventqueue
argument_list|)
condition|)
continue|continue;
name|bool
name|accepted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|clipboard
argument_list|()
operator|->
name|processIncr
argument_list|()
condition|)
name|clipboard
argument_list|()
operator|->
name|incrTransactionPeeker
argument_list|(
name|event
argument_list|,
name|accepted
argument_list|)
expr_stmt|;
if|if
condition|(
name|accepted
condition|)
continue|continue;
name|auto
name|isWaitingFor
init|=
capture|[
modifier|=
capture|]
parameter_list|(
name|PeekFunc
name|peekFunc
parameter_list|)
block|{
comment|// These callbacks return true if the event is what they were
comment|// waiting for, remove them from the list in that case.
return|return
name|peekFunc
argument_list|(
name|this
argument_list|,
name|event
argument_list|)
return|;
block|}
decl_stmt|;
name|m_peekFuncs
operator|.
name|erase
argument_list|(
name|std
operator|::
name|remove_if
argument_list|(
name|m_peekFuncs
operator|.
name|begin
argument_list|()
argument_list|,
name|m_peekFuncs
operator|.
name|end
argument_list|()
argument_list|,
name|isWaitingFor
argument_list|)
argument_list|,
name|m_peekFuncs
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|m_reader
operator|->
name|unlock
argument_list|()
expr_stmt|;
name|handleXcbEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|m_reader
operator|->
name|lock
argument_list|()
expr_stmt|;
block|}
name|eventqueue
operator|->
name|clear
argument_list|()
expr_stmt|;
name|m_reader
operator|->
name|unlock
argument_list|()
expr_stmt|;
comment|// Indicate with a null event that the event the callbacks are waiting for
comment|// is not in the queue currently.
name|Q_FOREACH
argument_list|(
argument|PeekFunc f
argument_list|,
argument|m_peekFuncs
argument_list|)
name|f
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_peekFuncs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|xcb_flush
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleClientMessageEvent
name|void
name|QXcbConnection
operator|::
name|handleClientMessageEvent
parameter_list|(
specifier|const
name|xcb_client_message_event_t
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|->
name|format
operator|!=
literal|32
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
if|if
condition|(
name|event
operator|->
name|type
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndStatus
argument_list|)
condition|)
block|{
name|drag
argument_list|()
operator|->
name|handleStatus
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|type
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndFinished
argument_list|)
condition|)
block|{
name|drag
argument_list|()
operator|->
name|handleFinished
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|m_systemTrayTracker
operator|&&
name|event
operator|->
name|type
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|MANAGER
argument_list|)
condition|)
name|m_systemTrayTracker
operator|->
name|notifyManagerClientMessageEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|QXcbWindow
modifier|*
name|window
init|=
name|platformWindowFromId
argument_list|(
name|event
operator|->
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
return|return;
name|window
operator|->
name|handleClientMessageEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|checkEvent
name|xcb_generic_event_t
modifier|*
name|QXcbConnection
operator|::
name|checkEvent
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|QXcbEventArray
modifier|*
name|eventqueue
init|=
name|m_reader
operator|->
name|lock
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|eventqueue
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|xcb_generic_event_t
modifier|*
name|event
init|=
name|eventqueue
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|event
operator|&&
name|event
operator|->
name|response_type
operator|==
name|type
condition|)
block|{
operator|(
operator|*
name|eventqueue
operator|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|m_reader
operator|->
name|unlock
argument_list|()
expr_stmt|;
return|return
name|event
return|;
block|}
block|}
name|m_reader
operator|->
name|unlock
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|xcb_atomnames
specifier|static
specifier|const
name|char
modifier|*
name|xcb_atomnames
init|=
block|{
comment|// window-manager<-> client protocols
literal|"WM_PROTOCOLS\0"
literal|"WM_DELETE_WINDOW\0"
literal|"WM_TAKE_FOCUS\0"
literal|"_NET_WM_PING\0"
literal|"_NET_WM_CONTEXT_HELP\0"
literal|"_NET_WM_SYNC_REQUEST\0"
literal|"_NET_WM_SYNC_REQUEST_COUNTER\0"
literal|"MANAGER\0"
literal|"_NET_SYSTEM_TRAY_OPCODE\0"
comment|// ICCCM window state
literal|"WM_STATE\0"
literal|"WM_CHANGE_STATE\0"
literal|"WM_CLASS\0"
literal|"WM_NAME\0"
comment|// Session management
literal|"WM_CLIENT_LEADER\0"
literal|"WM_WINDOW_ROLE\0"
literal|"SM_CLIENT_ID\0"
comment|// Clipboard
literal|"CLIPBOARD\0"
literal|"INCR\0"
literal|"TARGETS\0"
literal|"MULTIPLE\0"
literal|"TIMESTAMP\0"
literal|"SAVE_TARGETS\0"
literal|"CLIP_TEMPORARY\0"
literal|"_QT_SELECTION\0"
literal|"_QT_CLIPBOARD_SENTINEL\0"
literal|"_QT_SELECTION_SENTINEL\0"
literal|"CLIPBOARD_MANAGER\0"
literal|"RESOURCE_MANAGER\0"
literal|"_XSETROOT_ID\0"
literal|"_QT_SCROLL_DONE\0"
literal|"_QT_INPUT_ENCODING\0"
literal|"_QT_CLOSE_CONNECTION\0"
literal|"_MOTIF_WM_HINTS\0"
literal|"DTWM_IS_RUNNING\0"
literal|"ENLIGHTENMENT_DESKTOP\0"
literal|"_DT_SAVE_MODE\0"
literal|"_SGI_DESKS_MANAGER\0"
comment|// EWMH (aka NETWM)
literal|"_NET_SUPPORTED\0"
literal|"_NET_VIRTUAL_ROOTS\0"
literal|"_NET_WORKAREA\0"
literal|"_NET_MOVERESIZE_WINDOW\0"
literal|"_NET_WM_MOVERESIZE\0"
literal|"_NET_WM_NAME\0"
literal|"_NET_WM_ICON_NAME\0"
literal|"_NET_WM_ICON\0"
literal|"_NET_WM_PID\0"
literal|"_NET_WM_WINDOW_OPACITY\0"
literal|"_NET_WM_STATE\0"
literal|"_NET_WM_STATE_ABOVE\0"
literal|"_NET_WM_STATE_BELOW\0"
literal|"_NET_WM_STATE_FULLSCREEN\0"
literal|"_NET_WM_STATE_MAXIMIZED_HORZ\0"
literal|"_NET_WM_STATE_MAXIMIZED_VERT\0"
literal|"_NET_WM_STATE_MODAL\0"
literal|"_NET_WM_STATE_STAYS_ON_TOP\0"
literal|"_NET_WM_STATE_DEMANDS_ATTENTION\0"
literal|"_NET_WM_USER_TIME\0"
literal|"_NET_WM_USER_TIME_WINDOW\0"
literal|"_NET_WM_FULL_PLACEMENT\0"
literal|"_NET_WM_WINDOW_TYPE\0"
literal|"_NET_WM_WINDOW_TYPE_DESKTOP\0"
literal|"_NET_WM_WINDOW_TYPE_DOCK\0"
literal|"_NET_WM_WINDOW_TYPE_TOOLBAR\0"
literal|"_NET_WM_WINDOW_TYPE_MENU\0"
literal|"_NET_WM_WINDOW_TYPE_UTILITY\0"
literal|"_NET_WM_WINDOW_TYPE_SPLASH\0"
literal|"_NET_WM_WINDOW_TYPE_DIALOG\0"
literal|"_NET_WM_WINDOW_TYPE_DROPDOWN_MENU\0"
literal|"_NET_WM_WINDOW_TYPE_POPUP_MENU\0"
literal|"_NET_WM_WINDOW_TYPE_TOOLTIP\0"
literal|"_NET_WM_WINDOW_TYPE_NOTIFICATION\0"
literal|"_NET_WM_WINDOW_TYPE_COMBO\0"
literal|"_NET_WM_WINDOW_TYPE_DND\0"
literal|"_NET_WM_WINDOW_TYPE_NORMAL\0"
literal|"_KDE_NET_WM_WINDOW_TYPE_OVERRIDE\0"
literal|"_KDE_NET_WM_FRAME_STRUT\0"
literal|"_NET_FRAME_EXTENTS\0"
literal|"_NET_STARTUP_INFO\0"
literal|"_NET_STARTUP_INFO_BEGIN\0"
literal|"_NET_SUPPORTING_WM_CHECK\0"
literal|"_NET_WM_CM_S0\0"
literal|"_NET_SYSTEM_TRAY_VISUAL\0"
literal|"_NET_ACTIVE_WINDOW\0"
comment|// Property formats
literal|"TEXT\0"
literal|"UTF8_STRING\0"
literal|"CARDINAL\0"
comment|// xdnd
literal|"XdndEnter\0"
literal|"XdndPosition\0"
literal|"XdndStatus\0"
literal|"XdndLeave\0"
literal|"XdndDrop\0"
literal|"XdndFinished\0"
literal|"XdndTypeList\0"
literal|"XdndActionList\0"
literal|"XdndSelection\0"
literal|"XdndAware\0"
literal|"XdndProxy\0"
literal|"XdndActionCopy\0"
literal|"XdndActionLink\0"
literal|"XdndActionMove\0"
literal|"XdndActionPrivate\0"
comment|// Motif DND
literal|"_MOTIF_DRAG_AND_DROP_MESSAGE\0"
literal|"_MOTIF_DRAG_INITIATOR_INFO\0"
literal|"_MOTIF_DRAG_RECEIVER_INFO\0"
literal|"_MOTIF_DRAG_WINDOW\0"
literal|"_MOTIF_DRAG_TARGETS\0"
literal|"XmTRANSFER_SUCCESS\0"
literal|"XmTRANSFER_FAILURE\0"
comment|// Xkb
literal|"_XKB_RULES_NAMES\0"
comment|// XEMBED
literal|"_XEMBED\0"
literal|"_XEMBED_INFO\0"
comment|// XInput2
literal|"Button Left\0"
literal|"Button Middle\0"
literal|"Button Right\0"
literal|"Button Wheel Up\0"
literal|"Button Wheel Down\0"
literal|"Button Horiz Wheel Left\0"
literal|"Button Horiz Wheel Right\0"
literal|"Abs MT Position X\0"
literal|"Abs MT Position Y\0"
literal|"Abs MT Touch Major\0"
literal|"Abs MT Touch Minor\0"
literal|"Abs MT Orientation\0"
literal|"Abs MT Pressure\0"
literal|"Abs MT Tracking ID\0"
literal|"Max Contacts\0"
literal|"Rel X\0"
literal|"Rel Y\0"
comment|// XInput2 tablet
literal|"Abs X\0"
literal|"Abs Y\0"
literal|"Abs Pressure\0"
literal|"Abs Tilt X\0"
literal|"Abs Tilt Y\0"
literal|"Abs Wheel\0"
literal|"Abs Distance\0"
literal|"Wacom Serial IDs\0"
literal|"INTEGER\0"
literal|"Rel Horiz Wheel\0"
literal|"Rel Vert Wheel\0"
literal|"Rel Horiz Scroll\0"
literal|"Rel Vert Scroll\0"
literal|"_XSETTINGS_SETTINGS\0"
literal|"_COMPIZ_DECOR_PENDING\0"
literal|"_COMPIZ_DECOR_REQUEST\0"
literal|"_COMPIZ_DECOR_DELETE_PIXMAP\0"
literal|"_COMPIZ_TOOLKIT_ACTION\0"
literal|"_GTK_LOAD_ICONTHEMES\0"
comment|// \0\0 terminates loop.
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|qatom
name|QXcbAtom
operator|::
name|Atom
name|QXcbConnection
operator|::
name|qatom
parameter_list|(
name|xcb_atom_t
name|xatom
parameter_list|)
specifier|const
block|{
return|return
cast|static_cast
argument_list|<
name|QXcbAtom
operator|::
name|Atom
argument_list|>
argument_list|(
name|std
operator|::
name|find
argument_list|(
name|m_allAtoms
argument_list|,
name|m_allAtoms
operator|+
name|QXcbAtom
operator|::
name|NAtoms
argument_list|,
name|xatom
argument_list|)
operator|-
name|m_allAtoms
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|initializeAllAtoms
name|void
name|QXcbConnection
operator|::
name|initializeAllAtoms
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|names
index|[
name|QXcbAtom
operator|::
name|NAtoms
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
init|=
name|xcb_atomnames
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
name|names
index|[
name|i
operator|++
index|]
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
operator|++
name|ptr
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|i
operator|==
name|QXcbAtom
operator|::
name|NPredefinedAtoms
argument_list|)
expr_stmt|;
name|QByteArray
name|settings_atom_name
argument_list|(
literal|"_QT_SETTINGS_TIMESTAMP_"
argument_list|)
decl_stmt|;
name|settings_atom_name
operator|+=
name|m_displayName
expr_stmt|;
name|names
index|[
name|i
operator|++
index|]
operator|=
name|settings_atom_name
expr_stmt|;
name|xcb_intern_atom_cookie_t
name|cookies
index|[
name|QXcbAtom
operator|::
name|NAtoms
index|]
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|i
operator|==
name|QXcbAtom
operator|::
name|NAtoms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QXcbAtom
operator|::
name|NAtoms
condition|;
operator|++
name|i
control|)
name|cookies
index|[
name|i
index|]
operator|=
name|xcb_intern_atom
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|strlen
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QXcbAtom
operator|::
name|NAtoms
condition|;
operator|++
name|i
control|)
block|{
name|xcb_intern_atom_reply_t
modifier|*
name|reply
init|=
name|xcb_intern_atom_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|cookies
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|m_allAtoms
index|[
name|i
index|]
operator|=
name|reply
operator|->
name|atom
expr_stmt|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|internAtom
name|xcb_atom_t
name|QXcbConnection
operator|::
name|internAtom
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
operator|||
operator|*
name|name
operator|==
literal|0
condition|)
return|return
name|XCB_NONE
return|;
name|xcb_intern_atom_cookie_t
name|cookie
init|=
name|xcb_intern_atom
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|xcb_intern_atom_reply_t
modifier|*
name|reply
init|=
name|xcb_intern_atom_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|cookie
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|atom
init|=
name|reply
operator|->
name|atom
decl_stmt|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|atom
return|;
block|}
end_function
begin_function
DECL|function|atomName
name|QByteArray
name|QXcbConnection
operator|::
name|atomName
parameter_list|(
name|xcb_atom_t
name|atom
parameter_list|)
block|{
if|if
condition|(
operator|!
name|atom
condition|)
return|return
name|QByteArray
argument_list|()
return|;
name|xcb_generic_error_t
modifier|*
name|error
init|=
literal|0
decl_stmt|;
name|xcb_get_atom_name_cookie_t
name|cookie
init|=
name|Q_XCB_CALL
argument_list|(
name|xcb_get_atom_name
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|atom
argument_list|)
argument_list|)
decl_stmt|;
name|xcb_get_atom_name_reply_t
modifier|*
name|reply
init|=
name|xcb_get_atom_name_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|cookie
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QXcbConnection::atomName: bad Atom"
operator|<<
name|atom
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reply
condition|)
block|{
name|QByteArray
name|result
argument_list|(
name|xcb_get_atom_name_name
argument_list|(
name|reply
argument_list|)
argument_list|,
name|xcb_get_atom_name_name_length
argument_list|(
name|reply
argument_list|)
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|formatForDepth
specifier|const
name|xcb_format_t
modifier|*
name|QXcbConnection
operator|::
name|formatForDepth
parameter_list|(
name|uint8_t
name|depth
parameter_list|)
specifier|const
block|{
name|xcb_format_iterator_t
name|iterator
init|=
name|xcb_setup_pixmap_formats_iterator
argument_list|(
name|m_setup
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|rem
condition|)
block|{
name|xcb_format_t
modifier|*
name|format
init|=
name|iterator
operator|.
name|data
decl_stmt|;
if|if
condition|(
name|format
operator|->
name|depth
operator|==
name|depth
condition|)
return|return
name|format
return|;
name|xcb_format_next
argument_list|(
operator|&
name|iterator
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|sync
name|void
name|QXcbConnection
operator|::
name|sync
parameter_list|()
block|{
comment|// from xcb_aux_sync
name|xcb_get_input_focus_cookie_t
name|cookie
init|=
name|Q_XCB_CALL
argument_list|(
name|xcb_get_input_focus
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|xcb_get_input_focus_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|cookie
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initializeXFixes
name|void
name|QXcbConnection
operator|::
name|initializeXFixes
parameter_list|()
block|{
name|xcb_generic_error_t
modifier|*
name|error
init|=
literal|0
decl_stmt|;
specifier|const
name|xcb_query_extension_reply_t
modifier|*
name|reply
init|=
name|xcb_get_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|&
name|xcb_xfixes_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reply
operator|||
operator|!
name|reply
operator|->
name|present
condition|)
return|return;
name|xfixes_first_event
operator|=
name|reply
operator|->
name|first_event
expr_stmt|;
name|xcb_xfixes_query_version_cookie_t
name|xfixes_query_cookie
init|=
name|xcb_xfixes_query_version
argument_list|(
name|m_connection
argument_list|,
name|XCB_XFIXES_MAJOR_VERSION
argument_list|,
name|XCB_XFIXES_MINOR_VERSION
argument_list|)
decl_stmt|;
name|xcb_xfixes_query_version_reply_t
modifier|*
name|xfixes_query
init|=
name|xcb_xfixes_query_version_reply
argument_list|(
name|m_connection
argument_list|,
name|xfixes_query_cookie
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xfixes_query
operator|||
name|error
operator|||
name|xfixes_query
operator|->
name|major_version
operator|<
literal|2
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to initialize XFixes"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|xfixes_first_event
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|xfixes_query
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initializeXRender
name|void
name|QXcbConnection
operator|::
name|initializeXRender
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|XCB_USE_RENDER
specifier|const
name|xcb_query_extension_reply_t
modifier|*
name|reply
init|=
name|xcb_get_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|&
name|xcb_render_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reply
operator|||
operator|!
name|reply
operator|->
name|present
condition|)
return|return;
name|xcb_generic_error_t
modifier|*
name|error
init|=
literal|0
decl_stmt|;
name|xcb_render_query_version_cookie_t
name|xrender_query_cookie
init|=
name|xcb_render_query_version
argument_list|(
name|m_connection
argument_list|,
name|XCB_RENDER_MAJOR_VERSION
argument_list|,
name|XCB_RENDER_MINOR_VERSION
argument_list|)
decl_stmt|;
name|xcb_render_query_version_reply_t
modifier|*
name|xrender_query
init|=
name|xcb_render_query_version_reply
argument_list|(
name|m_connection
argument_list|,
name|xrender_query_cookie
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xrender_query
operator|||
name|error
operator|||
operator|(
name|xrender_query
operator|->
name|major_version
operator|==
literal|0
operator|&&
name|xrender_query
operator|->
name|minor_version
operator|<
literal|5
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to initialize XRender"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|xrender_query
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|initializeXRandr
name|void
name|QXcbConnection
operator|::
name|initializeXRandr
parameter_list|()
block|{
specifier|const
name|xcb_query_extension_reply_t
modifier|*
name|reply
init|=
name|xcb_get_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|&
name|xcb_randr_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reply
operator|||
operator|!
name|reply
operator|->
name|present
condition|)
return|return;
name|xrandr_first_event
operator|=
name|reply
operator|->
name|first_event
expr_stmt|;
name|xcb_generic_error_t
modifier|*
name|error
init|=
literal|0
decl_stmt|;
name|xcb_randr_query_version_cookie_t
name|xrandr_query_cookie
init|=
name|xcb_randr_query_version
argument_list|(
name|m_connection
argument_list|,
name|XCB_RANDR_MAJOR_VERSION
argument_list|,
name|XCB_RANDR_MINOR_VERSION
argument_list|)
decl_stmt|;
name|has_randr_extension
operator|=
literal|true
expr_stmt|;
name|xcb_randr_query_version_reply_t
modifier|*
name|xrandr_query
init|=
name|xcb_randr_query_version_reply
argument_list|(
name|m_connection
argument_list|,
name|xrandr_query_cookie
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xrandr_query
operator|||
name|error
operator|||
operator|(
name|xrandr_query
operator|->
name|major_version
operator|<
literal|1
operator|||
operator|(
name|xrandr_query
operator|->
name|major_version
operator|==
literal|1
operator|&&
name|xrandr_query
operator|->
name|minor_version
operator|<
literal|2
operator|)
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to initialize XRandr"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|has_randr_extension
operator|=
literal|false
expr_stmt|;
block|}
name|free
argument_list|(
name|xrandr_query
argument_list|)
expr_stmt|;
name|xcb_screen_iterator_t
name|rootIter
init|=
name|xcb_setup_roots_iterator
argument_list|(
name|m_setup
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|rootIter
operator|.
name|rem
condition|;
name|xcb_screen_next
argument_list|(
operator|&
name|rootIter
argument_list|)
control|)
block|{
name|xcb_randr_select_input
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|rootIter
operator|.
name|data
operator|->
name|root
argument_list|,
name|XCB_RANDR_NOTIFY_MASK_SCREEN_CHANGE
operator||
name|XCB_RANDR_NOTIFY_MASK_OUTPUT_CHANGE
operator||
name|XCB_RANDR_NOTIFY_MASK_CRTC_CHANGE
operator||
name|XCB_RANDR_NOTIFY_MASK_OUTPUT_PROPERTY
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|initializeXinerama
name|void
name|QXcbConnection
operator|::
name|initializeXinerama
parameter_list|()
block|{
specifier|const
name|xcb_query_extension_reply_t
modifier|*
name|reply
init|=
name|xcb_get_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|&
name|xcb_xinerama_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reply
operator|||
operator|!
name|reply
operator|->
name|present
condition|)
return|return;
name|xcb_generic_error_t
modifier|*
name|error
init|=
name|Q_NULLPTR
decl_stmt|;
name|xcb_xinerama_is_active_cookie_t
name|xinerama_query_cookie
init|=
name|xcb_xinerama_is_active
argument_list|(
name|m_connection
argument_list|)
decl_stmt|;
name|xcb_xinerama_is_active_reply_t
modifier|*
name|xinerama_is_active
init|=
name|xcb_xinerama_is_active_reply
argument_list|(
name|m_connection
argument_list|,
name|xinerama_query_cookie
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
name|has_xinerama_extension
operator|=
name|xinerama_is_active
operator|&&
operator|!
name|error
operator|&&
name|xinerama_is_active
operator|->
name|state
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xinerama_is_active
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initializeXShape
name|void
name|QXcbConnection
operator|::
name|initializeXShape
parameter_list|()
block|{
specifier|const
name|xcb_query_extension_reply_t
modifier|*
name|xshape_reply
init|=
name|xcb_get_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|&
name|xcb_shape_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xshape_reply
operator|||
operator|!
name|xshape_reply
operator|->
name|present
condition|)
return|return;
name|has_shape_extension
operator|=
literal|true
expr_stmt|;
name|xcb_shape_query_version_cookie_t
name|cookie
init|=
name|xcb_shape_query_version
argument_list|(
name|m_connection
argument_list|)
decl_stmt|;
name|xcb_shape_query_version_reply_t
modifier|*
name|shape_query
init|=
name|xcb_shape_query_version_reply
argument_list|(
name|m_connection
argument_list|,
name|cookie
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shape_query
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to initialize SHAPE extension"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shape_query
operator|->
name|major_version
operator|>
literal|1
operator|||
operator|(
name|shape_query
operator|->
name|major_version
operator|==
literal|1
operator|&&
name|shape_query
operator|->
name|minor_version
operator|>=
literal|1
operator|)
condition|)
block|{
comment|// The input shape is the only thing added in SHAPE 1.1
name|has_input_shape
operator|=
literal|true
expr_stmt|;
block|}
name|free
argument_list|(
name|shape_query
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initializeXKB
name|void
name|QXcbConnection
operator|::
name|initializeXKB
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_XKB
specifier|const
name|xcb_query_extension_reply_t
modifier|*
name|reply
init|=
name|xcb_get_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|&
name|xcb_xkb_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reply
operator|||
operator|!
name|reply
operator|->
name|present
condition|)
block|{
name|qWarning
argument_list|(
literal|"Qt: XKEYBOARD extension not present on the X server."
argument_list|)
expr_stmt|;
name|xkb_first_event
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|xkb_first_event
operator|=
name|reply
operator|->
name|first_event
expr_stmt|;
name|xcb_connection_t
modifier|*
name|c
init|=
name|connection
argument_list|()
operator|->
name|xcb_connection
argument_list|()
decl_stmt|;
name|xcb_xkb_use_extension_cookie_t
name|xkb_query_cookie
decl_stmt|;
name|xcb_xkb_use_extension_reply_t
modifier|*
name|xkb_query
decl_stmt|;
name|xkb_query_cookie
operator|=
name|xcb_xkb_use_extension
argument_list|(
name|c
argument_list|,
name|XKB_X11_MIN_MAJOR_XKB_VERSION
argument_list|,
name|XKB_X11_MIN_MINOR_XKB_VERSION
argument_list|)
expr_stmt|;
name|xkb_query
operator|=
name|xcb_xkb_use_extension_reply
argument_list|(
name|c
argument_list|,
name|xkb_query_cookie
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xkb_query
condition|)
block|{
name|qWarning
argument_list|(
literal|"Qt: Failed to initialize XKB extension"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|xkb_query
operator|->
name|supported
condition|)
block|{
name|qWarning
argument_list|(
literal|"Qt: Unsupported XKB version (We want %d %d, but X server has %d %d)"
argument_list|,
name|XCB_XKB_MAJOR_VERSION
argument_list|,
name|XCB_XKB_MINOR_VERSION
argument_list|,
name|xkb_query
operator|->
name|serverMajor
argument_list|,
name|xkb_query
operator|->
name|serverMinor
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xkb_query
argument_list|)
expr_stmt|;
return|return;
block|}
name|has_xkb
operator|=
literal|true
expr_stmt|;
name|free
argument_list|(
name|xkb_query
argument_list|)
expr_stmt|;
specifier|const
name|uint16_t
name|required_map_parts
init|=
operator|(
name|XCB_XKB_MAP_PART_KEY_TYPES
operator||
name|XCB_XKB_MAP_PART_KEY_SYMS
operator||
name|XCB_XKB_MAP_PART_MODIFIER_MAP
operator||
name|XCB_XKB_MAP_PART_EXPLICIT_COMPONENTS
operator||
name|XCB_XKB_MAP_PART_KEY_ACTIONS
operator||
name|XCB_XKB_MAP_PART_KEY_BEHAVIORS
operator||
name|XCB_XKB_MAP_PART_VIRTUAL_MODS
operator||
name|XCB_XKB_MAP_PART_VIRTUAL_MOD_MAP
operator|)
decl_stmt|;
specifier|const
name|uint16_t
name|required_events
init|=
operator|(
name|XCB_XKB_EVENT_TYPE_NEW_KEYBOARD_NOTIFY
operator||
name|XCB_XKB_EVENT_TYPE_MAP_NOTIFY
operator||
name|XCB_XKB_EVENT_TYPE_STATE_NOTIFY
operator|)
decl_stmt|;
comment|// XKB events are reported to all interested clients without regard
comment|// to the current keyboard input focus or grab state
name|xcb_void_cookie_t
name|select
init|=
name|xcb_xkb_select_events_checked
argument_list|(
name|c
argument_list|,
name|XCB_XKB_ID_USE_CORE_KBD
argument_list|,
name|required_events
argument_list|,
literal|0
argument_list|,
name|required_events
argument_list|,
name|required_map_parts
argument_list|,
name|required_map_parts
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|xcb_generic_error_t
modifier|*
name|error
init|=
name|xcb_request_check
argument_list|(
name|c
argument_list|,
name|select
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"Qt: failed to select notify events from xcb-xkb"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|XCB_USE_XINPUT22
argument_list|)
end_if
begin_function
DECL|function|xi2MouseEvents
name|bool
name|QXcbConnection
operator|::
name|xi2MouseEvents
parameter_list|()
specifier|const
block|{
specifier|static
name|bool
name|mouseViaXI2
init|=
operator|!
name|qEnvironmentVariableIsSet
argument_list|(
literal|"QT_XCB_NO_XI2_MOUSE"
argument_list|)
decl_stmt|;
comment|// FIXME: Don't use XInput2 mouse events when Xinerama extension
comment|// is enabled, because it causes problems with multi-monitor setup.
return|return
name|mouseViaXI2
operator|&&
operator|!
name|has_xinerama_extension
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|XCB_USE_XINPUT2
argument_list|)
end_if
begin_function
DECL|function|xi2ValuatorOffset
specifier|static
name|int
name|xi2ValuatorOffset
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|maskPtr
parameter_list|,
name|int
name|maskLen
parameter_list|,
name|int
name|number
parameter_list|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maskLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|number
operator|<
literal|8
condition|)
block|{
if|if
condition|(
operator|(
name|maskPtr
index|[
name|i
index|]
operator|&
operator|(
literal|1
operator|<<
name|number
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|number
condition|)
return|return
name|offset
return|;
if|if
condition|(
name|maskPtr
index|[
name|i
index|]
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
name|offset
operator|++
expr_stmt|;
block|}
name|number
operator|-=
literal|8
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|xi2GetValuatorValueIfSet
name|bool
name|QXcbConnection
operator|::
name|xi2GetValuatorValueIfSet
parameter_list|(
specifier|const
name|void
modifier|*
name|event
parameter_list|,
name|int
name|valuatorNum
parameter_list|,
name|double
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|xXIDeviceEvent
modifier|*
name|xideviceevent
init|=
cast|static_cast
argument_list|<
specifier|const
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|buttonsMaskAddr
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|&
name|xideviceevent
index|[
literal|1
index|]
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|valuatorsMaskAddr
init|=
name|buttonsMaskAddr
operator|+
name|xideviceevent
operator|->
name|buttons_len
operator|*
literal|4
decl_stmt|;
name|FP3232
modifier|*
name|valuatorsValuesAddr
init|=
operator|(
name|FP3232
operator|*
operator|)
operator|(
name|valuatorsMaskAddr
operator|+
name|xideviceevent
operator|->
name|valuators_len
operator|*
literal|4
operator|)
decl_stmt|;
name|int
name|valuatorOffset
init|=
name|xi2ValuatorOffset
argument_list|(
name|valuatorsMaskAddr
argument_list|,
name|xideviceevent
operator|->
name|valuators_len
argument_list|,
name|valuatorNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|valuatorOffset
operator|<
literal|0
condition|)
return|return
literal|false
return|;
operator|*
name|value
operator|=
name|valuatorsValuesAddr
index|[
name|valuatorOffset
index|]
operator|.
name|integral
expr_stmt|;
operator|*
name|value
operator|+=
operator|(
operator|(
name|double
operator|)
name|valuatorsValuesAddr
index|[
name|valuatorOffset
index|]
operator|.
name|frac
operator|/
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|/
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|xi2PrepareXIGenericDeviceEvent
name|void
name|QXcbConnection
operator|::
name|xi2PrepareXIGenericDeviceEvent
parameter_list|(
name|xcb_ge_event_t
modifier|*
name|event
parameter_list|)
block|{
comment|// xcb event structs contain stuff that wasn't on the wire, the full_sequence field
comment|// adds an extra 4 bytes and generic events cookie data is on the wire right after the standard 32 bytes.
comment|// Move this data back to have the same layout in memory as it was on the wire
comment|// and allow casting, overwriting the full_sequence field.
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|event
operator|+
literal|32
argument_list|,
operator|(
name|char
operator|*
operator|)
name|event
operator|+
literal|36
argument_list|,
name|event
operator|->
name|length
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// defined(XCB_USE_XINPUT2)
end_comment
begin_function
DECL|function|systemTrayTracker
name|QXcbSystemTrayTracker
modifier|*
name|QXcbConnection
operator|::
name|systemTrayTracker
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|m_systemTrayTracker
condition|)
block|{
name|QXcbConnection
modifier|*
name|self
init|=
cast|const_cast
argument_list|<
name|QXcbConnection
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|self
operator|->
name|m_systemTrayTracker
operator|=
name|QXcbSystemTrayTracker
operator|::
name|create
argument_list|(
name|self
argument_list|)
operator|)
condition|)
block|{
name|connect
argument_list|(
name|m_systemTrayTracker
argument_list|,
name|SIGNAL
argument_list|(
name|systemTrayWindowChanged
argument_list|(
name|QScreen
operator|*
argument_list|)
argument_list|)
argument_list|,
name|QGuiApplication
operator|::
name|platformNativeInterface
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|systemTrayWindowChanged
argument_list|(
name|QScreen
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|m_systemTrayTracker
return|;
block|}
end_function
begin_function
DECL|function|xEmbedSystemTrayAvailable
name|bool
name|QXcbConnection
operator|::
name|xEmbedSystemTrayAvailable
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
condition|)
return|return
literal|false
return|;
name|QXcbConnection
modifier|*
name|connection
init|=
cast|static_cast
argument_list|<
name|QXcbIntegration
operator|*
argument_list|>
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
argument_list|)
operator|->
name|defaultConnection
argument_list|()
decl_stmt|;
return|return
name|connection
operator|->
name|systemTrayTracker
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|xEmbedSystemTrayVisualHasAlphaChannel
name|bool
name|QXcbConnection
operator|::
name|xEmbedSystemTrayVisualHasAlphaChannel
parameter_list|()
block|{
if|if
condition|(
operator|!
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
condition|)
return|return
literal|false
return|;
name|QXcbConnection
modifier|*
name|connection
init|=
cast|static_cast
argument_list|<
name|QXcbIntegration
operator|*
argument_list|>
argument_list|(
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
argument_list|)
operator|->
name|defaultConnection
argument_list|()
decl_stmt|;
return|return
name|connection
operator|->
name|systemTrayTracker
argument_list|()
operator|&&
name|connection
operator|->
name|systemTrayTracker
argument_list|()
operator|->
name|visualHasAlphaChannel
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|event
name|bool
name|QXcbConnection
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|User
operator|+
literal|1
condition|)
block|{
name|QXcbSyncWindowRequest
modifier|*
name|ev
init|=
cast|static_cast
argument_list|<
name|QXcbSyncWindowRequest
operator|*
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|QXcbWindow
modifier|*
name|w
init|=
name|ev
operator|->
name|window
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
condition|)
block|{
name|w
operator|->
name|updateSyncRequestCounter
argument_list|()
expr_stmt|;
name|ev
operator|->
name|invalidate
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
name|QObject
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|invalidate
name|void
name|QXcbSyncWindowRequest
operator|::
name|invalidate
parameter_list|()
block|{
if|if
condition|(
name|m_window
condition|)
block|{
name|m_window
operator|->
name|clearSyncWindowRequest
argument_list|()
expr_stmt|;
name|m_window
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_constructor
DECL|function|QXcbConnectionGrabber
name|QXcbConnectionGrabber
operator|::
name|QXcbConnectionGrabber
parameter_list|(
name|QXcbConnection
modifier|*
name|connection
parameter_list|)
member_init_list|:
name|m_connection
argument_list|(
name|connection
argument_list|)
block|{
name|connection
operator|->
name|grabServer
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QXcbConnectionGrabber
name|QXcbConnectionGrabber
operator|::
name|~
name|QXcbConnectionGrabber
parameter_list|()
block|{
if|if
condition|(
name|m_connection
condition|)
name|m_connection
operator|->
name|ungrabServer
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|release
name|void
name|QXcbConnectionGrabber
operator|::
name|release
parameter_list|()
block|{
if|if
condition|(
name|m_connection
condition|)
block|{
name|m_connection
operator|->
name|ungrabServer
argument_list|()
expr_stmt|;
name|m_connection
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
