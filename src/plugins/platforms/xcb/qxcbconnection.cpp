begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<QtGui/private/qguiapplication_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/QDebug>
end_include
begin_include
include|#
directive|include
file|"qxcbconnection.h"
end_include
begin_include
include|#
directive|include
file|"qxcbkeyboard.h"
end_include
begin_include
include|#
directive|include
file|"qxcbscreen.h"
end_include
begin_include
include|#
directive|include
file|"qxcbwindow.h"
end_include
begin_include
include|#
directive|include
file|"qxcbclipboard.h"
end_include
begin_include
include|#
directive|include
file|"qxcbdrag.h"
end_include
begin_include
include|#
directive|include
file|"qxcbwmsupport.h"
end_include
begin_include
include|#
directive|include
file|"qxcbnativeinterface.h"
end_include
begin_include
include|#
directive|include
file|"qxcbintegration.h"
end_include
begin_include
include|#
directive|include
file|<QtAlgorithms>
end_include
begin_include
include|#
directive|include
file|<QSocketNotifier>
end_include
begin_include
include|#
directive|include
file|<QAbstractEventDispatcher>
end_include
begin_include
include|#
directive|include
file|<QTimer>
end_include
begin_include
include|#
directive|include
file|<QByteArray>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<xcb/xfixes.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_USE_XLIB
end_ifdef
begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include
begin_include
include|#
directive|include
file|<X11/Xlib-xcb.h>
end_include
begin_include
include|#
directive|include
file|<X11/Xlibint.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_USE_RENDER
end_ifdef
begin_include
include|#
directive|include
file|<xcb/render.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|XCB_HAS_XCB_GLX
argument_list|)
end_if
begin_include
include|#
directive|include
file|<xcb/glx.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_USE_EGL
end_ifdef
begin_comment
comment|//don't pull in eglext prototypes
end_comment
begin_include
include|#
directive|include
file|<EGL/egl.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_USE_DRI2
end_ifdef
begin_include
include|#
directive|include
file|<xcb/dri2.h>
end_include
begin_extern
extern|extern
literal|"C"
block|{
include|#
directive|include
file|<xf86drm.h>
block|}
end_extern
begin_define
DECL|macro|MESA_EGL_NO_X11_HEADERS
define|#
directive|define
name|MESA_EGL_NO_X11_HEADERS
end_define
begin_define
DECL|macro|EGL_EGLEXT_PROTOTYPES
define|#
directive|define
name|EGL_EGLEXT_PROTOTYPES
end_define
begin_include
include|#
directive|include
file|<EGL/egl.h>
end_include
begin_include
include|#
directive|include
file|<EGL/eglext.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|XCB_USE_XINPUT2
argument_list|)
operator|||
name|defined
argument_list|(
name|XCB_USE_XINPUT2_MAEMO
argument_list|)
end_if
begin_include
include|#
directive|include
file|<X11/extensions/XInput2.h>
end_include
begin_include
include|#
directive|include
file|<X11/extensions/XI2proto.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
ifdef|#
directive|ifdef
name|XCB_USE_XLIB
DECL|function|nullErrorHandler
specifier|static
name|int
name|nullErrorHandler
parameter_list|(
name|Display
modifier|*
parameter_list|,
name|XErrorEvent
modifier|*
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|findOrCreateScreen
name|QXcbScreen
modifier|*
name|QXcbConnection
operator|::
name|findOrCreateScreen
parameter_list|(
name|QList
argument_list|<
name|QXcbScreen
modifier|*
argument_list|>
modifier|&
name|newScreens
parameter_list|,
name|int
name|screenNumber
parameter_list|,
name|xcb_screen_t
modifier|*
name|xcbScreen
parameter_list|,
name|xcb_randr_get_output_info_reply_t
modifier|*
name|output
parameter_list|)
block|{
name|QString
name|name
decl_stmt|;
if|if
condition|(
name|output
condition|)
name|name
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|xcb_randr_get_output_info_name
argument_list|(
name|output
argument_list|)
argument_list|,
name|xcb_randr_get_output_info_name_length
argument_list|(
name|output
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|QByteArray
name|displayName
init|=
name|m_displayName
decl_stmt|;
name|int
name|dotPos
init|=
name|displayName
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|dotPos
operator|!=
operator|-
literal|1
condition|)
name|displayName
operator|.
name|truncate
argument_list|(
name|dotPos
argument_list|)
expr_stmt|;
name|name
operator|=
name|displayName
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|screenNumber
argument_list|)
expr_stmt|;
block|}
foreach|foreach
control|(
name|QXcbScreen
modifier|*
name|scr
decl|,
name|m_screens
control|)
if|if
condition|(
name|scr
operator|->
name|name
argument_list|()
operator|==
name|name
operator|&&
name|scr
operator|->
name|root
argument_list|()
operator|==
name|xcbScreen
operator|->
name|root
condition|)
return|return
name|scr
return|;
name|QXcbScreen
modifier|*
name|ret
init|=
operator|new
name|QXcbScreen
argument_list|(
name|this
argument_list|,
name|xcbScreen
argument_list|,
name|output
argument_list|,
name|name
argument_list|,
name|screenNumber
argument_list|)
decl_stmt|;
name|newScreens
operator|<<
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     \brief Synchronizes the screen list, adds new screens, removes deleted ones */
end_comment
begin_function
DECL|function|updateScreens
name|void
name|QXcbConnection
operator|::
name|updateScreens
parameter_list|()
block|{
name|xcb_screen_iterator_t
name|it
init|=
name|xcb_setup_roots_iterator
argument_list|(
name|m_setup
argument_list|)
decl_stmt|;
name|int
name|screenNumber
init|=
literal|0
decl_stmt|;
comment|// index of this QScreen in QGuiApplication::screens()
name|int
name|xcbScreenNumber
init|=
literal|0
decl_stmt|;
comment|// screen number in the xcb sense
name|QSet
argument_list|<
name|QXcbScreen
modifier|*
argument_list|>
name|activeScreens
decl_stmt|;
name|QList
argument_list|<
name|QXcbScreen
modifier|*
argument_list|>
name|newScreens
decl_stmt|;
name|QXcbScreen
modifier|*
name|primaryScreen
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|rem
condition|)
block|{
comment|// Each "screen" in xcb terminology is a virtual desktop,
comment|// potentially a collection of separate juxtaposed monitors.
comment|// But we want a separate QScreen for each output (e.g. DVI-I-1, VGA-1, etc.)
comment|// which will become virtual siblings.
name|xcb_screen_t
modifier|*
name|xcbScreen
init|=
name|it
operator|.
name|data
decl_stmt|;
name|QList
argument_list|<
name|QPlatformScreen
modifier|*
argument_list|>
name|siblings
decl_stmt|;
name|int
name|outputCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|has_randr_extension
condition|)
block|{
name|xcb_generic_error_t
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|xcb_randr_get_output_primary_cookie_t
name|primaryCookie
init|=
name|xcb_randr_get_output_primary
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcbScreen
operator|->
name|root
argument_list|)
decl_stmt|;
name|xcb_randr_get_screen_resources_current_cookie_t
name|resourcesCookie
init|=
name|xcb_randr_get_screen_resources_current
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcbScreen
operator|->
name|root
argument_list|)
decl_stmt|;
name|xcb_randr_get_output_primary_reply_t
modifier|*
name|primary
init|=
name|xcb_randr_get_output_primary_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|primaryCookie
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|primary
operator|||
name|error
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to get the primary output of the screen"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xcb_randr_get_screen_resources_current_reply_t
modifier|*
name|resources
init|=
name|xcb_randr_get_screen_resources_current_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|resourcesCookie
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|resources
operator|||
name|error
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to get the screen resources"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xcb_timestamp_t
name|timestamp
init|=
name|resources
operator|->
name|config_timestamp
decl_stmt|;
name|outputCount
operator|=
name|xcb_randr_get_screen_resources_current_outputs_length
argument_list|(
name|resources
argument_list|)
expr_stmt|;
name|xcb_randr_output_t
modifier|*
name|outputs
init|=
name|xcb_randr_get_screen_resources_current_outputs
argument_list|(
name|resources
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outputCount
condition|;
name|i
operator|++
control|)
block|{
name|xcb_randr_get_output_info_reply_t
modifier|*
name|output
init|=
name|xcb_randr_get_output_info_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcb_randr_get_output_info_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|outputs
index|[
name|i
index|]
argument_list|,
name|timestamp
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|Q_XCB_DEBUG
name|QString
name|outputName
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|xcb_randr_get_output_info_name
argument_list|(
name|output
argument_list|)
argument_list|,
name|xcb_randr_get_output_info_name_length
argument_list|(
name|output
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|output
operator|->
name|crtc
operator|==
name|XCB_NONE
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_XCB_DEBUG
name|qDebug
argument_list|(
literal|"Screen output %s is not connected"
argument_list|,
name|qPrintable
argument_list|(
name|outputName
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|QXcbScreen
modifier|*
name|screen
init|=
name|findOrCreateScreen
argument_list|(
name|newScreens
argument_list|,
name|xcbScreenNumber
argument_list|,
name|xcbScreen
argument_list|,
name|output
argument_list|)
decl_stmt|;
name|siblings
operator|<<
name|screen
expr_stmt|;
name|activeScreens
operator|<<
name|screen
expr_stmt|;
operator|++
name|screenNumber
expr_stmt|;
if|if
condition|(
operator|!
name|primaryScreen
operator|&&
name|primary
condition|)
block|{
if|if
condition|(
name|primary
operator|->
name|output
operator|==
name|XCB_NONE
operator|||
name|outputs
index|[
name|i
index|]
operator|==
name|primary
operator|->
name|output
condition|)
block|{
name|primaryScreen
operator|=
name|screen
expr_stmt|;
name|siblings
operator|.
name|prepend
argument_list|(
name|siblings
operator|.
name|takeLast
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_XCB_DEBUG
name|qDebug
argument_list|(
literal|"Primary output is %d: %s"
argument_list|,
name|primary
operator|->
name|output
argument_list|,
name|qPrintable
argument_list|(
name|outputName
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|free
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|resources
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|primary
argument_list|)
expr_stmt|;
block|}
comment|// If there's no randr extension, or there was some error above, or the screen
comment|// doesn't have outputs for some other reason (e.g. on VNC or ssh -X), just assume there is one screen.
if|if
condition|(
name|outputCount
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_XCB_DEBUG
name|qDebug
argument_list|(
literal|"Found a screen with zero outputs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QXcbScreen
modifier|*
name|screen
init|=
name|findOrCreateScreen
argument_list|(
name|newScreens
argument_list|,
name|xcbScreenNumber
argument_list|,
name|xcbScreen
argument_list|)
decl_stmt|;
name|siblings
operator|<<
name|screen
expr_stmt|;
name|activeScreens
operator|<<
name|screen
expr_stmt|;
if|if
condition|(
operator|!
name|primaryScreen
condition|)
name|primaryScreen
operator|=
name|screen
expr_stmt|;
operator|++
name|screenNumber
expr_stmt|;
block|}
foreach|foreach
control|(
name|QPlatformScreen
modifier|*
name|s
decl|,
name|siblings
control|)
operator|(
operator|(
name|QXcbScreen
operator|*
operator|)
name|s
operator|)
operator|->
name|setVirtualSiblings
argument_list|(
name|siblings
argument_list|)
expr_stmt|;
name|xcb_screen_next
argument_list|(
operator|&
name|it
argument_list|)
expr_stmt|;
operator|++
name|xcbScreenNumber
expr_stmt|;
block|}
comment|// for each xcb screen
comment|// Now activeScreens is the complete set of screens which are active at this time.
comment|// Delete any existing screens which are not in activeScreens
for|for
control|(
name|int
name|i
init|=
name|m_screens
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|!
name|activeScreens
operator|.
name|contains
argument_list|(
name|m_screens
index|[
name|i
index|]
argument_list|)
condition|)
block|{
operator|(
operator|(
name|QXcbIntegration
operator|*
operator|)
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|)
operator|->
name|removeDefaultOpenGLContextInfo
argument_list|(
name|m_screens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|delete
name|m_screens
index|[
name|i
index|]
expr_stmt|;
name|m_screens
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add any new screens, and make sure the primary screen comes first
comment|// since it is used by QGuiApplication::primaryScreen()
foreach|foreach
control|(
name|QXcbScreen
modifier|*
name|screen
decl|,
name|newScreens
control|)
block|{
if|if
condition|(
name|screen
operator|==
name|primaryScreen
condition|)
name|m_screens
operator|.
name|prepend
argument_list|(
name|screen
argument_list|)
expr_stmt|;
else|else
name|m_screens
operator|.
name|append
argument_list|(
name|screen
argument_list|)
expr_stmt|;
block|}
comment|// Now that they are in the right order, emit the added signals for new screens only
foreach|foreach
control|(
name|QXcbScreen
modifier|*
name|screen
decl|,
name|m_screens
control|)
if|if
condition|(
name|newScreens
operator|.
name|contains
argument_list|(
name|screen
argument_list|)
condition|)
operator|(
operator|(
name|QXcbIntegration
operator|*
operator|)
name|QGuiApplicationPrivate
operator|::
name|platformIntegration
argument_list|()
operator|)
operator|->
name|screenAdded
argument_list|(
name|screen
argument_list|)
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QXcbConnection
name|QXcbConnection
operator|::
name|QXcbConnection
parameter_list|(
name|QXcbNativeInterface
modifier|*
name|nativeInterface
parameter_list|,
specifier|const
name|char
modifier|*
name|displayName
parameter_list|)
member_init_list|:
name|m_connection
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_primaryScreen
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_displayName
argument_list|(
name|displayName
condition|?
name|QByteArray
argument_list|(
name|displayName
argument_list|)
else|:
name|qgetenv
argument_list|(
literal|"DISPLAY"
argument_list|)
argument_list|)
member_init_list|,
name|m_nativeInterface
argument_list|(
name|nativeInterface
argument_list|)
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT2_MAEMO
member_init_list|,
name|m_xinputData
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCB_USE_DRI2
member_init_list|,
name|m_dri2_major
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_dri2_minor
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|m_dri2_support_probed
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_has_support_for_dri2
argument_list|(
literal|false
argument_list|)
endif|#
directive|endif
member_init_list|,
name|xfixes_first_event
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|xrandr_first_event
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|has_glx_extension
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|has_shape_extension
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|has_randr_extension
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|has_input_shape
argument_list|(
literal|false
argument_list|)
block|{
ifdef|#
directive|ifdef
name|XCB_USE_XLIB
name|Display
modifier|*
name|dpy
init|=
name|XOpenDisplay
argument_list|(
name|m_displayName
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dpy
condition|)
block|{
name|m_primaryScreen
operator|=
name|DefaultScreen
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|m_connection
operator|=
name|XGetXCBConnection
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|XSetEventQueueOwner
argument_list|(
name|dpy
argument_list|,
name|XCBOwnsEventQueue
argument_list|)
expr_stmt|;
name|XSetErrorHandler
argument_list|(
name|nullErrorHandler
argument_list|)
expr_stmt|;
name|m_xlib_display
operator|=
name|dpy
expr_stmt|;
ifdef|#
directive|ifdef
name|XCB_USE_EGL
name|EGLDisplay
name|eglDisplay
init|=
name|eglGetDisplay
argument_list|(
name|dpy
argument_list|)
decl_stmt|;
name|m_egl_display
operator|=
name|eglDisplay
expr_stmt|;
name|EGLint
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|eglBindAPI
argument_list|(
name|EGL_OPENGL_ES_API
argument_list|)
expr_stmt|;
name|m_has_egl
operator|=
name|eglInitialize
argument_list|(
name|eglDisplay
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//XCB_USE_EGL
block|}
else|#
directive|else
name|m_connection
operator|=
name|xcb_connect
argument_list|(
name|m_displayName
operator|.
name|constData
argument_list|()
argument_list|,
operator|&
name|m_primaryScreen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//XCB_USE_XLIB
if|if
condition|(
operator|!
name|m_connection
operator|||
name|xcb_connection_has_error
argument_list|(
name|m_connection
argument_list|)
condition|)
name|qFatal
argument_list|(
literal|"QXcbConnection: Could not connect to display %s"
argument_list|,
name|m_displayName
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|m_reader
operator|=
operator|new
name|QXcbEventReader
argument_list|(
name|this
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XCB_POLL_FOR_QUEUED_EVENT
name|connect
argument_list|(
name|m_reader
argument_list|,
name|SIGNAL
argument_list|(
name|eventPending
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|processXcbEvents
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|m_reader
operator|->
name|start
argument_list|()
expr_stmt|;
else|#
directive|else
name|QSocketNotifier
modifier|*
name|notifier
init|=
operator|new
name|QSocketNotifier
argument_list|(
name|xcb_get_file_descriptor
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|connect
argument_list|(
name|notifier
argument_list|,
name|SIGNAL
argument_list|(
name|activated
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|processXcbEvents
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QAbstractEventDispatcher
modifier|*
name|dispatcher
init|=
name|QGuiApplicationPrivate
operator|::
name|eventDispatcher
decl_stmt|;
name|connect
argument_list|(
name|dispatcher
argument_list|,
name|SIGNAL
argument_list|(
name|aboutToBlock
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|processXcbEvents
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|dispatcher
argument_list|,
name|SIGNAL
argument_list|(
name|awake
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|processXcbEvents
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xcb_prefetch_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|&
name|xcb_xfixes_id
argument_list|)
expr_stmt|;
name|m_setup
operator|=
name|xcb_get_setup
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
expr_stmt|;
name|initializeAllAtoms
argument_list|()
expr_stmt|;
name|m_time
operator|=
name|XCB_CURRENT_TIME
expr_stmt|;
name|initializeXRandr
argument_list|()
expr_stmt|;
name|updateScreens
argument_list|()
expr_stmt|;
name|m_connectionEventListener
operator|=
name|xcb_generate_id
argument_list|(
name|m_connection
argument_list|)
expr_stmt|;
name|xcb_create_window
argument_list|(
name|m_connection
argument_list|,
name|XCB_COPY_FROM_PARENT
argument_list|,
name|m_connectionEventListener
argument_list|,
name|m_screens
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|root
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|XCB_WINDOW_CLASS_INPUT_ONLY
argument_list|,
name|m_screens
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|->
name|screen
argument_list|()
operator|->
name|root_visual
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initializeGLX
argument_list|()
expr_stmt|;
name|initializeXFixes
argument_list|()
expr_stmt|;
name|initializeXRender
argument_list|()
expr_stmt|;
name|m_xi2Enabled
operator|=
literal|false
expr_stmt|;
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT2_MAEMO
name|initializeXInput2Maemo
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|XCB_USE_XINPUT2
argument_list|)
name|initializeXInput2
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|initializeXShape
argument_list|()
expr_stmt|;
name|m_wmSupport
operator|.
name|reset
argument_list|(
operator|new
name|QXcbWMSupport
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|m_keyboard
operator|=
operator|new
name|QXcbKeyboard
argument_list|(
name|this
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
name|m_clipboard
operator|=
operator|new
name|QXcbClipboard
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
name|m_drag
operator|=
operator|new
name|QXcbDrag
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCB_USE_DRI2
name|initializeDri2
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sync
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QXcbConnection
name|QXcbConnection
operator|::
name|~
name|QXcbConnection
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
operator|delete
name|m_clipboard
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
operator|delete
name|m_drag
expr_stmt|;
endif|#
directive|endif
comment|// Delete screens in reverse order to avoid crash in case of multiple screens
while|while
condition|(
operator|!
name|m_screens
operator|.
name|isEmpty
argument_list|()
condition|)
operator|delete
name|m_screens
operator|.
name|takeLast
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT2_MAEMO
name|finalizeXInput2Maemo
argument_list|()
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|XCB_USE_XINPUT2
argument_list|)
name|finalizeXInput2
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCB_POLL_FOR_QUEUED_EVENT
name|sendConnectionEvent
argument_list|(
name|QXcbAtom
operator|::
name|_QT_CLOSE_CONNECTION
argument_list|)
expr_stmt|;
name|m_reader
operator|->
name|wait
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|delete
name|m_reader
expr_stmt|;
ifdef|#
directive|ifdef
name|XCB_USE_EGL
if|if
condition|(
name|m_has_egl
condition|)
name|eglTerminate
argument_list|(
name|m_egl_display
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//XCB_USE_EGL
ifdef|#
directive|ifdef
name|XCB_USE_XLIB
name|XCloseDisplay
argument_list|(
operator|(
name|Display
operator|*
operator|)
name|m_xlib_display
argument_list|)
expr_stmt|;
else|#
directive|else
name|xcb_disconnect
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|delete
name|m_keyboard
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|addWindow
name|void
name|QXcbConnection
operator|::
name|addWindow
parameter_list|(
name|xcb_window_t
name|id
parameter_list|,
name|QXcbWindow
modifier|*
name|window
parameter_list|)
block|{
name|m_mapper
operator|.
name|insert
argument_list|(
name|id
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|removeWindow
name|void
name|QXcbConnection
operator|::
name|removeWindow
parameter_list|(
name|xcb_window_t
name|id
parameter_list|)
block|{
name|m_mapper
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|platformWindowFromId
name|QXcbWindow
modifier|*
name|QXcbConnection
operator|::
name|platformWindowFromId
parameter_list|(
name|xcb_window_t
name|id
parameter_list|)
block|{
return|return
name|m_mapper
operator|.
name|value
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_define
DECL|macro|HANDLE_PLATFORM_WINDOW_EVENT
define|#
directive|define
name|HANDLE_PLATFORM_WINDOW_EVENT
parameter_list|(
name|event_t
parameter_list|,
name|windowMember
parameter_list|,
name|handler
parameter_list|)
define|\
value|{ \     event_t *e = (event_t *)event; \     if (QXcbWindow *platformWindow = platformWindowFromId(e->windowMember))  { \         handled = QWindowSystemInterface::handleNativeEvent(platformWindow->window(), m_nativeInterface->genericEventFilterType(), event,&result); \         if (!handled) \             platformWindow->handler(e); \     } \ } \ break;
end_define
begin_define
DECL|macro|HANDLE_KEYBOARD_EVENT
define|#
directive|define
name|HANDLE_KEYBOARD_EVENT
parameter_list|(
name|event_t
parameter_list|,
name|handler
parameter_list|)
define|\
value|{ \     event_t *e = (event_t *)event; \     if (QXcbWindow *platformWindow = platformWindowFromId(e->event)) { \         handled = QWindowSystemInterface::handleNativeEvent(platformWindow->window(), m_nativeInterface->genericEventFilterType(), event,&result); \         if (!handled) \             m_keyboard->handler(platformWindow, e); \     } \ } \ break;
end_define
begin_comment
comment|//#define XCB_EVENT_DEBUG
end_comment
begin_function
DECL|function|printXcbEvent
name|void
name|printXcbEvent
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XCB_EVENT_DEBUG
DECL|macro|PRINT_XCB_EVENT
define|#
directive|define
name|PRINT_XCB_EVENT
parameter_list|(
name|ev
parameter_list|)
define|\
value|case ev: \         qDebug("QXcbConnection: %s: %d - %s - sequence: %d", message, int(ev), #ev, event->sequence); \         break;
switch|switch
condition|(
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
condition|)
block|{
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_KEY_PRESS
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_KEY_RELEASE
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_BUTTON_PRESS
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_BUTTON_RELEASE
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_MOTION_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_ENTER_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_LEAVE_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_FOCUS_IN
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_FOCUS_OUT
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_KEYMAP_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_EXPOSE
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_GRAPHICS_EXPOSURE
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_VISIBILITY_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_CREATE_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_DESTROY_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_UNMAP_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_MAP_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_MAP_REQUEST
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_REPARENT_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_CONFIGURE_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_CONFIGURE_REQUEST
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_GRAVITY_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_RESIZE_REQUEST
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_CIRCULATE_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_CIRCULATE_REQUEST
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_PROPERTY_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_SELECTION_CLEAR
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_SELECTION_REQUEST
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_SELECTION_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_COLORMAP_NOTIFY
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_CLIENT_MESSAGE
argument_list|)
expr_stmt|;
name|PRINT_XCB_EVENT
argument_list|(
name|XCB_MAPPING_NOTIFY
argument_list|)
expr_stmt|;
default|default:
name|qDebug
argument_list|(
literal|"QXcbConnection: %s: unknown event - response_type: %d - sequence: %d"
argument_list|,
name|message
argument_list|,
name|int
argument_list|(
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
argument_list|)
argument_list|,
name|int
argument_list|(
name|event
operator|->
name|sequence
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_decl_stmt
DECL|variable|xcb_errors
specifier|const
name|char
modifier|*
name|xcb_errors
index|[]
init|=
block|{
literal|"Success"
block|,
literal|"BadRequest"
block|,
literal|"BadValue"
block|,
literal|"BadWindow"
block|,
literal|"BadPixmap"
block|,
literal|"BadAtom"
block|,
literal|"BadCursor"
block|,
literal|"BadFont"
block|,
literal|"BadMatch"
block|,
literal|"BadDrawable"
block|,
literal|"BadAccess"
block|,
literal|"BadAlloc"
block|,
literal|"BadColor"
block|,
literal|"BadGC"
block|,
literal|"BadIDChoice"
block|,
literal|"BadName"
block|,
literal|"BadLength"
block|,
literal|"BadImplementation"
block|,
literal|"Unknown"
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|xcb_protocol_request_codes
specifier|const
name|char
modifier|*
name|xcb_protocol_request_codes
index|[]
init|=
block|{
literal|"Null"
block|,
literal|"CreateWindow"
block|,
literal|"ChangeWindowAttributes"
block|,
literal|"GetWindowAttributes"
block|,
literal|"DestroyWindow"
block|,
literal|"DestroySubwindows"
block|,
literal|"ChangeSaveSet"
block|,
literal|"ReparentWindow"
block|,
literal|"MapWindow"
block|,
literal|"MapSubwindows"
block|,
literal|"UnmapWindow"
block|,
literal|"UnmapSubwindows"
block|,
literal|"ConfigureWindow"
block|,
literal|"CirculateWindow"
block|,
literal|"GetGeometry"
block|,
literal|"QueryTree"
block|,
literal|"InternAtom"
block|,
literal|"GetAtomName"
block|,
literal|"ChangeProperty"
block|,
literal|"DeleteProperty"
block|,
literal|"GetProperty"
block|,
literal|"ListProperties"
block|,
literal|"SetSelectionOwner"
block|,
literal|"GetSelectionOwner"
block|,
literal|"ConvertSelection"
block|,
literal|"SendEvent"
block|,
literal|"GrabPointer"
block|,
literal|"UngrabPointer"
block|,
literal|"GrabButton"
block|,
literal|"UngrabButton"
block|,
literal|"ChangeActivePointerGrab"
block|,
literal|"GrabKeyboard"
block|,
literal|"UngrabKeyboard"
block|,
literal|"GrabKey"
block|,
literal|"UngrabKey"
block|,
literal|"AllowEvents"
block|,
literal|"GrabServer"
block|,
literal|"UngrabServer"
block|,
literal|"QueryPointer"
block|,
literal|"GetMotionEvents"
block|,
literal|"TranslateCoords"
block|,
literal|"WarpPointer"
block|,
literal|"SetInputFocus"
block|,
literal|"GetInputFocus"
block|,
literal|"QueryKeymap"
block|,
literal|"OpenFont"
block|,
literal|"CloseFont"
block|,
literal|"QueryFont"
block|,
literal|"QueryTextExtents"
block|,
literal|"ListFonts"
block|,
literal|"ListFontsWithInfo"
block|,
literal|"SetFontPath"
block|,
literal|"GetFontPath"
block|,
literal|"CreatePixmap"
block|,
literal|"FreePixmap"
block|,
literal|"CreateGC"
block|,
literal|"ChangeGC"
block|,
literal|"CopyGC"
block|,
literal|"SetDashes"
block|,
literal|"SetClipRectangles"
block|,
literal|"FreeGC"
block|,
literal|"ClearArea"
block|,
literal|"CopyArea"
block|,
literal|"CopyPlane"
block|,
literal|"PolyPoint"
block|,
literal|"PolyLine"
block|,
literal|"PolySegment"
block|,
literal|"PolyRectangle"
block|,
literal|"PolyArc"
block|,
literal|"FillPoly"
block|,
literal|"PolyFillRectangle"
block|,
literal|"PolyFillArc"
block|,
literal|"PutImage"
block|,
literal|"GetImage"
block|,
literal|"PolyText8"
block|,
literal|"PolyText16"
block|,
literal|"ImageText8"
block|,
literal|"ImageText16"
block|,
literal|"CreateColormap"
block|,
literal|"FreeColormap"
block|,
literal|"CopyColormapAndFree"
block|,
literal|"InstallColormap"
block|,
literal|"UninstallColormap"
block|,
literal|"ListInstalledColormaps"
block|,
literal|"AllocColor"
block|,
literal|"AllocNamedColor"
block|,
literal|"AllocColorCells"
block|,
literal|"AllocColorPlanes"
block|,
literal|"FreeColors"
block|,
literal|"StoreColors"
block|,
literal|"StoreNamedColor"
block|,
literal|"QueryColors"
block|,
literal|"LookupColor"
block|,
literal|"CreateCursor"
block|,
literal|"CreateGlyphCursor"
block|,
literal|"FreeCursor"
block|,
literal|"RecolorCursor"
block|,
literal|"QueryBestSize"
block|,
literal|"QueryExtension"
block|,
literal|"ListExtensions"
block|,
literal|"ChangeKeyboardMapping"
block|,
literal|"GetKeyboardMapping"
block|,
literal|"ChangeKeyboardControl"
block|,
literal|"GetKeyboardControl"
block|,
literal|"Bell"
block|,
literal|"ChangePointerControl"
block|,
literal|"GetPointerControl"
block|,
literal|"SetScreenSaver"
block|,
literal|"GetScreenSaver"
block|,
literal|"ChangeHosts"
block|,
literal|"ListHosts"
block|,
literal|"SetAccessControl"
block|,
literal|"SetCloseDownMode"
block|,
literal|"KillClient"
block|,
literal|"RotateProperties"
block|,
literal|"ForceScreenSaver"
block|,
literal|"SetPointerMapping"
block|,
literal|"GetPointerMapping"
block|,
literal|"SetModifierMapping"
block|,
literal|"GetModifierMapping"
block|,
literal|"Unknown"
block|}
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|Q_XCB_DEBUG
end_ifdef
begin_function
DECL|function|log
name|void
name|QXcbConnection
operator|::
name|log
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|sequence
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_callLogMutex
argument_list|)
decl_stmt|;
name|CallInfo
name|info
decl_stmt|;
name|info
operator|.
name|sequence
operator|=
name|sequence
expr_stmt|;
name|info
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|info
operator|.
name|line
operator|=
name|line
expr_stmt|;
name|m_callLog
operator|<<
name|info
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|handleXcbError
name|void
name|QXcbConnection
operator|::
name|handleXcbError
parameter_list|(
name|xcb_generic_error_t
modifier|*
name|error
parameter_list|)
block|{
name|uint
name|clamped_error_code
init|=
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|error
operator|->
name|error_code
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|xcb_errors
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xcb_errors
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|uint
name|clamped_major_code
init|=
name|qMin
argument_list|<
name|uint
argument_list|>
argument_list|(
name|error
operator|->
name|major_code
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|xcb_protocol_request_codes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xcb_protocol_request_codes
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|qWarning
argument_list|(
literal|"QXcbConnection: XCB error: %d (%s), sequence: %d, resource id: %d, major code: %d (%s), minor code: %d"
argument_list|,
name|int
argument_list|(
name|error
operator|->
name|error_code
argument_list|)
argument_list|,
name|xcb_errors
index|[
name|clamped_error_code
index|]
argument_list|,
name|int
argument_list|(
name|error
operator|->
name|sequence
argument_list|)
argument_list|,
name|int
argument_list|(
name|error
operator|->
name|resource_id
argument_list|)
argument_list|,
name|int
argument_list|(
name|error
operator|->
name|major_code
argument_list|)
argument_list|,
name|xcb_protocol_request_codes
index|[
name|clamped_major_code
index|]
argument_list|,
name|int
argument_list|(
name|error
operator|->
name|minor_code
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_XCB_DEBUG
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_callLogMutex
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|m_callLog
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|sequence
operator|==
name|error
operator|->
name|sequence
condition|)
block|{
name|qDebug
argument_list|(
literal|"Caused by: %s:%d"
argument_list|,
name|qPrintable
argument_list|(
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|file
argument_list|)
argument_list|,
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|sequence
operator|>
name|error
operator|->
name|sequence
condition|)
block|{
name|qDebug
argument_list|(
literal|"Caused some time before: %s:%d"
argument_list|,
name|qPrintable
argument_list|(
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|file
argument_list|)
argument_list|,
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|qDebug
argument_list|(
literal|"and after: %s:%d"
argument_list|,
name|qPrintable
argument_list|(
name|m_callLog
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|file
argument_list|)
argument_list|,
name|m_callLog
operator|.
name|at
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|m_callLog
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|m_callLog
operator|.
name|isEmpty
argument_list|()
condition|)
name|qDebug
argument_list|(
literal|"Caused some time after: %s:%d"
argument_list|,
name|qPrintable
argument_list|(
name|m_callLog
operator|.
name|first
argument_list|()
operator|.
name|file
argument_list|)
argument_list|,
name|m_callLog
operator|.
name|first
argument_list|()
operator|.
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|handleXcbEvent
name|void
name|QXcbConnection
operator|::
name|handleXcbEvent
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|Q_XCB_DEBUG
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|m_callLogMutex
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|m_callLog
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|m_callLog
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|sequence
operator|>=
name|event
operator|->
name|sequence
condition|)
break|break;
name|m_callLog
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|long
name|result
init|=
literal|0
decl_stmt|;
name|QAbstractEventDispatcher
modifier|*
name|dispatcher
init|=
name|QAbstractEventDispatcher
operator|::
name|instance
argument_list|()
decl_stmt|;
name|bool
name|handled
init|=
name|dispatcher
operator|&&
name|dispatcher
operator|->
name|filterNativeEvent
argument_list|(
name|m_nativeInterface
operator|->
name|genericEventFilterType
argument_list|()
argument_list|,
name|event
argument_list|,
operator|&
name|result
argument_list|)
decl_stmt|;
name|uint
name|response_type
init|=
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
decl_stmt|;
if|if
condition|(
operator|!
name|handled
condition|)
block|{
switch|switch
condition|(
name|response_type
condition|)
block|{
case|case
name|XCB_EXPOSE
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_expose_event_t
argument_list|,
name|window
argument_list|,
name|handleExposeEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_BUTTON_PRESS
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_button_press_event_t
argument_list|,
name|event
argument_list|,
name|handleButtonPressEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_BUTTON_RELEASE
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_button_release_event_t
argument_list|,
name|event
argument_list|,
name|handleButtonReleaseEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_MOTION_NOTIFY
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_motion_notify_event_t
argument_list|,
name|event
argument_list|,
name|handleMotionNotifyEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_CONFIGURE_NOTIFY
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_configure_notify_event_t
argument_list|,
name|event
argument_list|,
name|handleConfigureNotifyEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_MAP_NOTIFY
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_map_notify_event_t
argument_list|,
name|event
argument_list|,
name|handleMapNotifyEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_UNMAP_NOTIFY
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_unmap_notify_event_t
argument_list|,
name|event
argument_list|,
name|handleUnmapNotifyEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_CLIENT_MESSAGE
case|:
name|handleClientMessageEvent
argument_list|(
operator|(
name|xcb_client_message_event_t
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
case|case
name|XCB_ENTER_NOTIFY
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_enter_notify_event_t
argument_list|,
name|event
argument_list|,
name|handleEnterNotifyEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_LEAVE_NOTIFY
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_leave_notify_event_t
argument_list|,
name|event
argument_list|,
name|handleLeaveNotifyEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_FOCUS_IN
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_focus_in_event_t
argument_list|,
name|event
argument_list|,
name|handleFocusInEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_FOCUS_OUT
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_focus_out_event_t
argument_list|,
name|event
argument_list|,
name|handleFocusOutEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_KEY_PRESS
case|:
name|HANDLE_KEYBOARD_EVENT
argument_list|(
name|xcb_key_press_event_t
argument_list|,
name|handleKeyPressEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_KEY_RELEASE
case|:
name|HANDLE_KEYBOARD_EVENT
argument_list|(
name|xcb_key_release_event_t
argument_list|,
name|handleKeyReleaseEvent
argument_list|)
expr_stmt|;
case|case
name|XCB_MAPPING_NOTIFY
case|:
name|m_keyboard
operator|->
name|handleMappingNotifyEvent
argument_list|(
operator|(
name|xcb_mapping_notify_event_t
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|XCB_SELECTION_REQUEST
case|:
block|{
name|xcb_selection_request_event_t
modifier|*
name|sr
init|=
operator|(
name|xcb_selection_request_event_t
operator|*
operator|)
name|event
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
if|if
condition|(
name|sr
operator|->
name|selection
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndSelection
argument_list|)
condition|)
name|m_drag
operator|->
name|handleSelectionRequest
argument_list|(
name|sr
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
name|m_clipboard
operator|->
name|handleSelectionRequest
argument_list|(
name|sr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
block|}
case|case
name|XCB_SELECTION_CLEAR
case|:
name|setTime
argument_list|(
operator|(
operator|(
name|xcb_selection_clear_event_t
operator|*
operator|)
name|event
operator|)
operator|->
name|time
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
name|m_clipboard
operator|->
name|handleSelectionClearRequest
argument_list|(
operator|(
name|xcb_selection_clear_event_t
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|handled
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|XCB_SELECTION_NOTIFY
case|:
name|setTime
argument_list|(
operator|(
operator|(
name|xcb_selection_notify_event_t
operator|*
operator|)
name|event
operator|)
operator|->
name|time
argument_list|)
expr_stmt|;
name|handled
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|XCB_PROPERTY_NOTIFY
case|:
name|HANDLE_PLATFORM_WINDOW_EVENT
argument_list|(
name|xcb_property_notify_event_t
argument_list|,
name|window
argument_list|,
name|handlePropertyNotifyEvent
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT2_MAEMO
case|case
name|GenericEvent
case|:
name|handleGenericEventMaemo
argument_list|(
operator|(
name|xcb_ge_event_t
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
break|break;
elif|#
directive|elif
name|defined
argument_list|(
name|XCB_USE_XINPUT2
argument_list|)
case|case
name|GenericEvent
case|:
if|if
condition|(
name|m_xi2Enabled
condition|)
name|xi2HandleEvent
argument_list|(
cast|reinterpret_cast
argument_list|<
name|xcb_ge_event_t
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|handled
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|handled
condition|)
block|{
if|if
condition|(
name|response_type
operator|==
name|xfixes_first_event
operator|+
name|XCB_XFIXES_SELECTION_NOTIFY
condition|)
block|{
name|setTime
argument_list|(
operator|(
operator|(
name|xcb_xfixes_selection_notify_event_t
operator|*
operator|)
name|event
operator|)
operator|->
name|timestamp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_CLIPBOARD
name|m_clipboard
operator|->
name|handleXFixesSelectionRequest
argument_list|(
operator|(
name|xcb_xfixes_selection_notify_event_t
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|handled
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_randr_extension
operator|&&
name|response_type
operator|==
name|xrandr_first_event
operator|+
name|XCB_RANDR_SCREEN_CHANGE_NOTIFY
condition|)
block|{
name|updateScreens
argument_list|()
expr_stmt|;
name|xcb_randr_screen_change_notify_event_t
modifier|*
name|change_event
init|=
operator|(
name|xcb_randr_screen_change_notify_event_t
operator|*
operator|)
name|event
decl_stmt|;
foreach|foreach
control|(
name|QXcbScreen
modifier|*
name|s
decl|,
name|m_screens
control|)
block|{
if|if
condition|(
name|s
operator|->
name|root
argument_list|()
operator|==
name|change_event
operator|->
name|root
condition|)
block|{
name|s
operator|->
name|handleScreenChange
argument_list|(
name|change_event
argument_list|)
expr_stmt|;
name|s
operator|->
name|updateRefreshRate
argument_list|()
expr_stmt|;
block|}
block|}
name|handled
operator|=
literal|true
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|XCB_USE_XLIB
if|if
condition|(
operator|!
name|handled
condition|)
block|{
comment|// Check if a custom XEvent constructor was registered in xlib for this event type, and call it discarding the constructed XEvent if any.
comment|// XESetWireToEvent might be used by libraries to intercept messages from the X server e.g. the OpenGL lib waiting for DRI2 events.
name|Display
modifier|*
name|xdisplay
init|=
operator|(
name|Display
operator|*
operator|)
name|m_xlib_display
decl_stmt|;
name|XLockDisplay
argument_list|(
name|xdisplay
argument_list|)
expr_stmt|;
name|Bool
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|(
name|Display
modifier|*
parameter_list|,
name|XEvent
modifier|*
parameter_list|,
name|xEvent
modifier|*
parameter_list|)
init|=
name|XESetWireToEvent
argument_list|(
name|xdisplay
argument_list|,
name|response_type
argument_list|,
literal|0
argument_list|)
function_decl|;
if|if
condition|(
name|proc
condition|)
block|{
name|XESetWireToEvent
argument_list|(
name|xdisplay
argument_list|,
name|response_type
argument_list|,
name|proc
argument_list|)
expr_stmt|;
name|XEvent
name|dummy
decl_stmt|;
name|event
operator|->
name|sequence
operator|=
name|LastKnownRequestProcessed
argument_list|(
name|m_xlib_display
argument_list|)
expr_stmt|;
name|proc
argument_list|(
name|xdisplay
argument_list|,
operator|&
name|dummy
argument_list|,
operator|(
name|xEvent
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
block|}
name|XUnlockDisplay
argument_list|(
name|xdisplay
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|handled
condition|)
name|printXcbEvent
argument_list|(
literal|"Handled XCB event"
argument_list|,
name|event
argument_list|)
expr_stmt|;
else|else
name|printXcbEvent
argument_list|(
literal|"Unhandled XCB event"
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|addPeekFunc
name|void
name|QXcbConnection
operator|::
name|addPeekFunc
parameter_list|(
name|PeekFunc
name|f
parameter_list|)
block|{
name|m_peekFuncs
operator|.
name|append
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_POLL_FOR_QUEUED_EVENT
end_ifdef
begin_function
DECL|function|run
name|void
name|QXcbEventReader
operator|::
name|run
parameter_list|()
block|{
name|xcb_generic_event_t
modifier|*
name|event
decl_stmt|;
while|while
condition|(
name|m_connection
operator|&&
operator|(
name|event
operator|=
name|xcb_wait_for_event
argument_list|(
name|m_connection
operator|->
name|xcb_connection
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|m_mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|addEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
while|while
condition|(
name|m_connection
operator|&&
operator|(
name|event
operator|=
name|xcb_poll_for_queued_event
argument_list|(
name|m_connection
operator|->
name|xcb_connection
argument_list|()
argument_list|)
operator|)
condition|)
name|addEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|m_mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
emit|emit
name|eventPending
argument_list|()
emit|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_events
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|m_events
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|addEvent
name|void
name|QXcbEventReader
operator|::
name|addEvent
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
operator|(
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
operator|)
operator|==
name|XCB_CLIENT_MESSAGE
operator|&&
operator|(
operator|(
name|xcb_client_message_event_t
operator|*
operator|)
name|event
operator|)
operator|->
name|type
operator|==
name|m_connection
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_QT_CLOSE_CONNECTION
argument_list|)
condition|)
name|m_connection
operator|=
literal|0
expr_stmt|;
name|m_events
operator|<<
name|event
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lock
name|QXcbEventArray
modifier|*
name|QXcbEventReader
operator|::
name|lock
parameter_list|()
block|{
name|m_mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|XCB_POLL_FOR_QUEUED_EVENT
while|while
condition|(
name|xcb_generic_event_t
modifier|*
name|event
init|=
name|xcb_poll_for_event
argument_list|(
name|m_connection
operator|->
name|xcb_connection
argument_list|()
argument_list|)
condition|)
name|m_events
operator|<<
name|event
expr_stmt|;
endif|#
directive|endif
return|return
operator|&
name|m_events
return|;
block|}
end_function
begin_function
DECL|function|unlock
name|void
name|QXcbEventReader
operator|::
name|unlock
parameter_list|()
block|{
name|m_mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendConnectionEvent
name|void
name|QXcbConnection
operator|::
name|sendConnectionEvent
parameter_list|(
name|QXcbAtom
operator|::
name|Atom
name|a
parameter_list|,
name|uint
name|id
parameter_list|)
block|{
name|xcb_client_message_event_t
name|event
decl_stmt|;
name|memset
argument_list|(
operator|&
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|response_type
operator|=
name|XCB_CLIENT_MESSAGE
expr_stmt|;
name|event
operator|.
name|format
operator|=
literal|32
expr_stmt|;
name|event
operator|.
name|sequence
operator|=
literal|0
expr_stmt|;
name|event
operator|.
name|window
operator|=
name|m_connectionEventListener
expr_stmt|;
name|event
operator|.
name|type
operator|=
name|atom
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|event
operator|.
name|data
operator|.
name|data32
index|[
literal|0
index|]
operator|=
name|id
expr_stmt|;
name|Q_XCB_CALL
argument_list|(
name|xcb_send_event
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|m_connectionEventListener
argument_list|,
name|XCB_EVENT_MASK_NO_EVENT
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|xcb_flush
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|class|PropertyNotifyEvent
class|class
name|PropertyNotifyEvent
block|{
public|public:
DECL|function|PropertyNotifyEvent
name|PropertyNotifyEvent
parameter_list|(
name|xcb_window_t
name|win
parameter_list|,
name|xcb_atom_t
name|property
parameter_list|)
member_init_list|:
name|window
argument_list|(
name|win
argument_list|)
member_init_list|,
name|type
argument_list|(
name|XCB_PROPERTY_NOTIFY
argument_list|)
member_init_list|,
name|atom
argument_list|(
name|property
argument_list|)
block|{}
DECL|member|window
name|xcb_window_t
name|window
decl_stmt|;
DECL|member|type
name|int
name|type
decl_stmt|;
DECL|member|atom
name|xcb_atom_t
name|atom
decl_stmt|;
DECL|function|checkEvent
name|bool
name|checkEvent
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|event
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|(
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
operator|)
operator|!=
name|type
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|xcb_property_notify_event_t
modifier|*
name|pn
init|=
operator|(
name|xcb_property_notify_event_t
operator|*
operator|)
name|event
decl_stmt|;
if|if
condition|(
operator|(
name|pn
operator|->
name|window
operator|==
name|window
operator|)
operator|&&
operator|(
name|pn
operator|->
name|atom
operator|==
name|atom
operator|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
class|;
block|}
end_namespace
begin_function
DECL|function|getTimestamp
name|xcb_timestamp_t
name|QXcbConnection
operator|::
name|getTimestamp
parameter_list|()
block|{
comment|// send a dummy event to myself to get the timestamp from X server.
name|xcb_window_t
name|rootWindow
init|=
name|screens
argument_list|()
operator|.
name|at
argument_list|(
name|primaryScreen
argument_list|()
argument_list|)
operator|->
name|root
argument_list|()
decl_stmt|;
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_APPEND
argument_list|,
name|rootWindow
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIP_TEMPORARY
argument_list|)
argument_list|,
name|XCB_ATOM_INTEGER
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|connection
argument_list|()
operator|->
name|flush
argument_list|()
expr_stmt|;
name|PropertyNotifyEvent
name|checker
argument_list|(
name|rootWindow
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIP_TEMPORARY
argument_list|)
argument_list|)
decl_stmt|;
name|xcb_generic_event_t
modifier|*
name|event
init|=
literal|0
decl_stmt|;
comment|// lets keep this inside a loop to avoid a possible race condition, where
comment|// reader thread has not yet had the time to acquire the mutex in order
comment|// to add the new set of events to its event queue
while|while
condition|(
literal|true
condition|)
block|{
name|connection
argument_list|()
operator|->
name|sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|event
operator|=
name|checkEvent
argument_list|(
name|checker
argument_list|)
condition|)
break|break;
block|}
name|xcb_property_notify_event_t
modifier|*
name|pn
init|=
operator|(
name|xcb_property_notify_event_t
operator|*
operator|)
name|event
decl_stmt|;
name|xcb_timestamp_t
name|timestamp
init|=
name|pn
operator|->
name|time
decl_stmt|;
name|free
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|xcb_delete_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|rootWindow
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|CLIP_TEMPORARY
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|timestamp
return|;
block|}
end_function
begin_function
DECL|function|processXcbEvents
name|void
name|QXcbConnection
operator|::
name|processXcbEvents
parameter_list|()
block|{
name|QXcbEventArray
modifier|*
name|eventqueue
init|=
name|m_reader
operator|->
name|lock
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|eventqueue
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|xcb_generic_event_t
modifier|*
name|event
init|=
name|eventqueue
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|event
condition|)
continue|continue;
operator|(
operator|*
name|eventqueue
operator|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|uint
name|response_type
init|=
name|event
operator|->
name|response_type
operator|&
operator|~
literal|0x80
decl_stmt|;
if|if
condition|(
operator|!
name|response_type
condition|)
block|{
name|handleXcbError
argument_list|(
operator|(
name|xcb_generic_error_t
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QVector
argument_list|<
name|PeekFunc
argument_list|>
operator|::
name|iterator
name|it
init|=
name|m_peekFuncs
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|m_peekFuncs
operator|.
name|end
argument_list|()
condition|)
block|{
comment|// These callbacks return true if the event is what they were
comment|// waiting for, remove them from the list in that case.
if|if
condition|(
call|(
modifier|*
name|it
call|)
argument_list|(
name|event
argument_list|)
condition|)
name|it
operator|=
name|m_peekFuncs
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
else|else
operator|++
name|it
expr_stmt|;
block|}
name|m_reader
operator|->
name|unlock
argument_list|()
expr_stmt|;
name|handleXcbEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|m_reader
operator|->
name|lock
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
name|eventqueue
operator|->
name|clear
argument_list|()
expr_stmt|;
name|m_reader
operator|->
name|unlock
argument_list|()
expr_stmt|;
comment|// Indicate with a null event that the event the callbacks are waiting for
comment|// is not in the queue currently.
name|Q_FOREACH
argument_list|(
argument|PeekFunc f
argument_list|,
argument|m_peekFuncs
argument_list|)
name|f
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|m_peekFuncs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|xcb_flush
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleClientMessageEvent
name|void
name|QXcbConnection
operator|::
name|handleClientMessageEvent
parameter_list|(
specifier|const
name|xcb_client_message_event_t
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|->
name|format
operator|!=
literal|32
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
if|if
condition|(
name|event
operator|->
name|type
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndStatus
argument_list|)
condition|)
block|{
name|drag
argument_list|()
operator|->
name|handleStatus
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|type
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndFinished
argument_list|)
condition|)
block|{
name|drag
argument_list|()
operator|->
name|handleFinished
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QXcbWindow
modifier|*
name|window
init|=
name|platformWindowFromId
argument_list|(
name|event
operator|->
name|window
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
return|return;
name|window
operator|->
name|handleClientMessageEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|checkEvent
name|xcb_generic_event_t
modifier|*
name|QXcbConnection
operator|::
name|checkEvent
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|QXcbEventArray
modifier|*
name|eventqueue
init|=
name|m_reader
operator|->
name|lock
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|eventqueue
operator|->
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|xcb_generic_event_t
modifier|*
name|event
init|=
name|eventqueue
operator|->
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|event
operator|&&
name|event
operator|->
name|response_type
operator|==
name|type
condition|)
block|{
operator|(
operator|*
name|eventqueue
operator|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|m_reader
operator|->
name|unlock
argument_list|()
expr_stmt|;
return|return
name|event
return|;
block|}
block|}
name|m_reader
operator|->
name|unlock
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|xcb_atomnames
specifier|static
specifier|const
name|char
modifier|*
name|xcb_atomnames
init|=
block|{
comment|// window-manager<-> client protocols
literal|"WM_PROTOCOLS\0"
literal|"WM_DELETE_WINDOW\0"
literal|"WM_TAKE_FOCUS\0"
literal|"_NET_WM_PING\0"
literal|"_NET_WM_CONTEXT_HELP\0"
literal|"_NET_WM_SYNC_REQUEST\0"
literal|"_NET_WM_SYNC_REQUEST_COUNTER\0"
comment|// ICCCM window state
literal|"WM_STATE\0"
literal|"WM_CHANGE_STATE\0"
comment|// Session management
literal|"WM_CLIENT_LEADER\0"
literal|"WM_WINDOW_ROLE\0"
literal|"SM_CLIENT_ID\0"
comment|// Clipboard
literal|"CLIPBOARD\0"
literal|"INCR\0"
literal|"TARGETS\0"
literal|"MULTIPLE\0"
literal|"TIMESTAMP\0"
literal|"SAVE_TARGETS\0"
literal|"CLIP_TEMPORARY\0"
literal|"_QT_SELECTION\0"
literal|"_QT_CLIPBOARD_SENTINEL\0"
literal|"_QT_SELECTION_SENTINEL\0"
literal|"CLIPBOARD_MANAGER\0"
literal|"RESOURCE_MANAGER\0"
literal|"_XSETROOT_ID\0"
literal|"_QT_SCROLL_DONE\0"
literal|"_QT_INPUT_ENCODING\0"
literal|"_QT_CLOSE_CONNECTION\0"
literal|"_MOTIF_WM_HINTS\0"
literal|"DTWM_IS_RUNNING\0"
literal|"ENLIGHTENMENT_DESKTOP\0"
literal|"_DT_SAVE_MODE\0"
literal|"_SGI_DESKS_MANAGER\0"
comment|// EWMH (aka NETWM)
literal|"_NET_SUPPORTED\0"
literal|"_NET_VIRTUAL_ROOTS\0"
literal|"_NET_WORKAREA\0"
literal|"_NET_MOVERESIZE_WINDOW\0"
literal|"_NET_WM_MOVERESIZE\0"
literal|"_NET_WM_NAME\0"
literal|"_NET_WM_ICON_NAME\0"
literal|"_NET_WM_ICON\0"
literal|"_NET_WM_PID\0"
literal|"_NET_WM_WINDOW_OPACITY\0"
literal|"_NET_WM_STATE\0"
literal|"_NET_WM_STATE_ABOVE\0"
literal|"_NET_WM_STATE_BELOW\0"
literal|"_NET_WM_STATE_FULLSCREEN\0"
literal|"_NET_WM_STATE_MAXIMIZED_HORZ\0"
literal|"_NET_WM_STATE_MAXIMIZED_VERT\0"
literal|"_NET_WM_STATE_MODAL\0"
literal|"_NET_WM_STATE_STAYS_ON_TOP\0"
literal|"_NET_WM_STATE_DEMANDS_ATTENTION\0"
literal|"_NET_WM_USER_TIME\0"
literal|"_NET_WM_USER_TIME_WINDOW\0"
literal|"_NET_WM_FULL_PLACEMENT\0"
literal|"_NET_WM_WINDOW_TYPE\0"
literal|"_NET_WM_WINDOW_TYPE_DESKTOP\0"
literal|"_NET_WM_WINDOW_TYPE_DOCK\0"
literal|"_NET_WM_WINDOW_TYPE_TOOLBAR\0"
literal|"_NET_WM_WINDOW_TYPE_MENU\0"
literal|"_NET_WM_WINDOW_TYPE_UTILITY\0"
literal|"_NET_WM_WINDOW_TYPE_SPLASH\0"
literal|"_NET_WM_WINDOW_TYPE_DIALOG\0"
literal|"_NET_WM_WINDOW_TYPE_DROPDOWN_MENU\0"
literal|"_NET_WM_WINDOW_TYPE_POPUP_MENU\0"
literal|"_NET_WM_WINDOW_TYPE_TOOLTIP\0"
literal|"_NET_WM_WINDOW_TYPE_NOTIFICATION\0"
literal|"_NET_WM_WINDOW_TYPE_COMBO\0"
literal|"_NET_WM_WINDOW_TYPE_DND\0"
literal|"_NET_WM_WINDOW_TYPE_NORMAL\0"
literal|"_KDE_NET_WM_WINDOW_TYPE_OVERRIDE\0"
literal|"_KDE_NET_WM_FRAME_STRUT\0"
literal|"_NET_STARTUP_INFO\0"
literal|"_NET_STARTUP_INFO_BEGIN\0"
literal|"_NET_SUPPORTING_WM_CHECK\0"
literal|"_NET_WM_CM_S0\0"
literal|"_NET_SYSTEM_TRAY_VISUAL\0"
literal|"_NET_ACTIVE_WINDOW\0"
comment|// Property formats
literal|"TEXT\0"
literal|"UTF8_STRING\0"
literal|"CARDINAL\0"
comment|// xdnd
literal|"XdndEnter\0"
literal|"XdndPosition\0"
literal|"XdndStatus\0"
literal|"XdndLeave\0"
literal|"XdndDrop\0"
literal|"XdndFinished\0"
literal|"XdndTypeList\0"
literal|"XdndActionList\0"
literal|"XdndSelection\0"
literal|"XdndAware\0"
literal|"XdndProxy\0"
literal|"XdndActionCopy\0"
literal|"XdndActionLink\0"
literal|"XdndActionMove\0"
literal|"XdndActionPrivate\0"
comment|// Motif DND
literal|"_MOTIF_DRAG_AND_DROP_MESSAGE\0"
literal|"_MOTIF_DRAG_INITIATOR_INFO\0"
literal|"_MOTIF_DRAG_RECEIVER_INFO\0"
literal|"_MOTIF_DRAG_WINDOW\0"
literal|"_MOTIF_DRAG_TARGETS\0"
literal|"XmTRANSFER_SUCCESS\0"
literal|"XmTRANSFER_FAILURE\0"
comment|// Xkb
literal|"_XKB_RULES_NAMES\0"
comment|// XEMBED
literal|"_XEMBED\0"
literal|"_XEMBED_INFO\0"
comment|// XInput2
literal|"Button Left\0"
literal|"Button Middle\0"
literal|"Button Right\0"
literal|"Button Wheel Up\0"
literal|"Button Wheel Down\0"
literal|"Button Horiz Wheel Left\0"
literal|"Button Horiz Wheel Right\0"
literal|"Abs MT Position X\0"
literal|"Abs MT Position Y\0"
literal|"Abs MT Touch Major\0"
literal|"Abs MT Touch Minor\0"
literal|"Abs MT Pressure\0"
literal|"Abs MT Tracking ID\0"
literal|"Max Contacts\0"
comment|// XInput2 tablet
literal|"Abs X\0"
literal|"Abs Y\0"
literal|"Abs Pressure\0"
literal|"Abs Tilt X\0"
literal|"Abs Tilt Y\0"
literal|"Abs Wheel\0"
literal|"Abs Distance\0"
literal|"Wacom Serial IDs\0"
literal|"INTEGER\0"
if|#
directive|if
name|XCB_USE_MAEMO_WINDOW_PROPERTIES
literal|"_MEEGOTOUCH_ORIENTATION_ANGLE\0"
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|atom
name|xcb_atom_t
name|QXcbConnection
operator|::
name|atom
parameter_list|(
name|QXcbAtom
operator|::
name|Atom
name|atom
parameter_list|)
block|{
return|return
name|m_allAtoms
index|[
name|atom
index|]
return|;
block|}
end_function
begin_function
DECL|function|initializeAllAtoms
name|void
name|QXcbConnection
operator|::
name|initializeAllAtoms
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|names
index|[
name|QXcbAtom
operator|::
name|NAtoms
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
init|=
name|xcb_atomnames
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
name|names
index|[
name|i
operator|++
index|]
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
operator|++
name|ptr
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|i
operator|==
name|QXcbAtom
operator|::
name|NPredefinedAtoms
argument_list|)
expr_stmt|;
name|QByteArray
name|settings_atom_name
argument_list|(
literal|"_QT_SETTINGS_TIMESTAMP_"
argument_list|)
decl_stmt|;
name|settings_atom_name
operator|+=
name|m_displayName
expr_stmt|;
name|names
index|[
name|i
operator|++
index|]
operator|=
name|settings_atom_name
expr_stmt|;
name|xcb_intern_atom_cookie_t
name|cookies
index|[
name|QXcbAtom
operator|::
name|NAtoms
index|]
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|i
operator|==
name|QXcbAtom
operator|::
name|NAtoms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QXcbAtom
operator|::
name|NAtoms
condition|;
operator|++
name|i
control|)
name|cookies
index|[
name|i
index|]
operator|=
name|xcb_intern_atom
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|strlen
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QXcbAtom
operator|::
name|NAtoms
condition|;
operator|++
name|i
control|)
block|{
name|xcb_intern_atom_reply_t
modifier|*
name|reply
init|=
name|xcb_intern_atom_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|cookies
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|m_allAtoms
index|[
name|i
index|]
operator|=
name|reply
operator|->
name|atom
expr_stmt|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|internAtom
name|xcb_atom_t
name|QXcbConnection
operator|::
name|internAtom
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
operator|||
operator|*
name|name
operator|==
literal|0
condition|)
return|return
name|XCB_NONE
return|;
name|xcb_intern_atom_cookie_t
name|cookie
init|=
name|xcb_intern_atom
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|xcb_intern_atom_reply_t
modifier|*
name|reply
init|=
name|xcb_intern_atom_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|cookie
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|atom
init|=
name|reply
operator|->
name|atom
decl_stmt|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|atom
return|;
block|}
end_function
begin_function
DECL|function|atomName
name|QByteArray
name|QXcbConnection
operator|::
name|atomName
parameter_list|(
name|xcb_atom_t
name|atom
parameter_list|)
block|{
if|if
condition|(
operator|!
name|atom
condition|)
return|return
name|QByteArray
argument_list|()
return|;
name|xcb_generic_error_t
modifier|*
name|error
init|=
literal|0
decl_stmt|;
name|xcb_get_atom_name_cookie_t
name|cookie
init|=
name|Q_XCB_CALL
argument_list|(
name|xcb_get_atom_name
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|atom
argument_list|)
argument_list|)
decl_stmt|;
name|xcb_get_atom_name_reply_t
modifier|*
name|reply
init|=
name|xcb_get_atom_name_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|cookie
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QXcbConnection::atomName: bad Atom"
operator|<<
name|atom
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reply
condition|)
block|{
name|QByteArray
name|result
argument_list|(
name|xcb_get_atom_name_name
argument_list|(
name|reply
argument_list|)
argument_list|,
name|xcb_get_atom_name_name_length
argument_list|(
name|reply
argument_list|)
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|formatForDepth
specifier|const
name|xcb_format_t
modifier|*
name|QXcbConnection
operator|::
name|formatForDepth
parameter_list|(
name|uint8_t
name|depth
parameter_list|)
specifier|const
block|{
name|xcb_format_iterator_t
name|iterator
init|=
name|xcb_setup_pixmap_formats_iterator
argument_list|(
name|m_setup
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|rem
condition|)
block|{
name|xcb_format_t
modifier|*
name|format
init|=
name|iterator
operator|.
name|data
decl_stmt|;
if|if
condition|(
name|format
operator|->
name|depth
operator|==
name|depth
condition|)
return|return
name|format
return|;
name|xcb_format_next
argument_list|(
operator|&
name|iterator
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|sync
name|void
name|QXcbConnection
operator|::
name|sync
parameter_list|()
block|{
comment|// from xcb_aux_sync
name|xcb_get_input_focus_cookie_t
name|cookie
init|=
name|Q_XCB_CALL
argument_list|(
name|xcb_get_input_focus
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|xcb_get_input_focus_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|cookie
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initializeXFixes
name|void
name|QXcbConnection
operator|::
name|initializeXFixes
parameter_list|()
block|{
name|xcb_generic_error_t
modifier|*
name|error
init|=
literal|0
decl_stmt|;
specifier|const
name|xcb_query_extension_reply_t
modifier|*
name|reply
init|=
name|xcb_get_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|&
name|xcb_xfixes_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reply
operator|||
operator|!
name|reply
operator|->
name|present
condition|)
return|return;
name|xfixes_first_event
operator|=
name|reply
operator|->
name|first_event
expr_stmt|;
name|xcb_xfixes_query_version_cookie_t
name|xfixes_query_cookie
init|=
name|xcb_xfixes_query_version
argument_list|(
name|m_connection
argument_list|,
name|XCB_XFIXES_MAJOR_VERSION
argument_list|,
name|XCB_XFIXES_MINOR_VERSION
argument_list|)
decl_stmt|;
name|xcb_xfixes_query_version_reply_t
modifier|*
name|xfixes_query
init|=
name|xcb_xfixes_query_version_reply
argument_list|(
name|m_connection
argument_list|,
name|xfixes_query_cookie
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xfixes_query
operator|||
name|error
operator|||
name|xfixes_query
operator|->
name|major_version
operator|<
literal|2
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to initialize XFixes"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|xfixes_first_event
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|xfixes_query
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initializeXRender
name|void
name|QXcbConnection
operator|::
name|initializeXRender
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|XCB_USE_RENDER
specifier|const
name|xcb_query_extension_reply_t
modifier|*
name|reply
init|=
name|xcb_get_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|&
name|xcb_render_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reply
operator|||
operator|!
name|reply
operator|->
name|present
condition|)
return|return;
name|xcb_generic_error_t
modifier|*
name|error
init|=
literal|0
decl_stmt|;
name|xcb_render_query_version_cookie_t
name|xrender_query_cookie
init|=
name|xcb_render_query_version
argument_list|(
name|m_connection
argument_list|,
name|XCB_RENDER_MAJOR_VERSION
argument_list|,
name|XCB_RENDER_MINOR_VERSION
argument_list|)
decl_stmt|;
name|xcb_render_query_version_reply_t
modifier|*
name|xrender_query
init|=
name|xcb_render_query_version_reply
argument_list|(
name|m_connection
argument_list|,
name|xrender_query_cookie
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xrender_query
operator|||
name|error
operator|||
operator|(
name|xrender_query
operator|->
name|major_version
operator|==
literal|0
operator|&&
name|xrender_query
operator|->
name|minor_version
operator|<
literal|5
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to initialize XRender"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|xrender_query
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|initializeGLX
name|void
name|QXcbConnection
operator|::
name|initializeGLX
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|XCB_HAS_XCB_GLX
specifier|const
name|xcb_query_extension_reply_t
modifier|*
name|reply
init|=
name|xcb_get_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|&
name|xcb_glx_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reply
operator|||
operator|!
name|reply
operator|->
name|present
condition|)
return|return;
name|has_glx_extension
operator|=
literal|true
expr_stmt|;
name|xcb_generic_error_t
modifier|*
name|error
init|=
literal|0
decl_stmt|;
name|xcb_glx_query_version_cookie_t
name|xglx_query_cookie
init|=
name|xcb_glx_query_version
argument_list|(
name|m_connection
argument_list|,
name|XCB_GLX_MAJOR_VERSION
argument_list|,
name|XCB_GLX_MINOR_VERSION
argument_list|)
decl_stmt|;
name|xcb_glx_query_version_reply_t
modifier|*
name|xglx_query
init|=
name|xcb_glx_query_version_reply
argument_list|(
name|m_connection
argument_list|,
name|xglx_query_cookie
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xglx_query
operator|||
name|error
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to initialize GLX"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|has_glx_extension
operator|=
literal|false
expr_stmt|;
block|}
name|free
argument_list|(
name|xglx_query
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// no way to check, assume GLX is present
name|has_glx_extension
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|initializeXRandr
name|void
name|QXcbConnection
operator|::
name|initializeXRandr
parameter_list|()
block|{
specifier|const
name|xcb_query_extension_reply_t
modifier|*
name|reply
init|=
name|xcb_get_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|&
name|xcb_randr_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reply
operator|||
operator|!
name|reply
operator|->
name|present
condition|)
return|return;
name|xrandr_first_event
operator|=
name|reply
operator|->
name|first_event
expr_stmt|;
name|xcb_generic_error_t
modifier|*
name|error
init|=
literal|0
decl_stmt|;
name|xcb_randr_query_version_cookie_t
name|xrandr_query_cookie
init|=
name|xcb_randr_query_version
argument_list|(
name|m_connection
argument_list|,
name|XCB_RANDR_MAJOR_VERSION
argument_list|,
name|XCB_RANDR_MINOR_VERSION
argument_list|)
decl_stmt|;
name|has_randr_extension
operator|=
literal|true
expr_stmt|;
name|xcb_randr_query_version_reply_t
modifier|*
name|xrandr_query
init|=
name|xcb_randr_query_version_reply
argument_list|(
name|m_connection
argument_list|,
name|xrandr_query_cookie
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xrandr_query
operator|||
name|error
operator|||
operator|(
name|xrandr_query
operator|->
name|major_version
operator|<
literal|1
operator|||
operator|(
name|xrandr_query
operator|->
name|major_version
operator|==
literal|1
operator|&&
name|xrandr_query
operator|->
name|minor_version
operator|<
literal|2
operator|)
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to initialize XRandr"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|has_randr_extension
operator|=
literal|false
expr_stmt|;
block|}
name|free
argument_list|(
name|xrandr_query
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initializeXShape
name|void
name|QXcbConnection
operator|::
name|initializeXShape
parameter_list|()
block|{
specifier|const
name|xcb_query_extension_reply_t
modifier|*
name|xshape_reply
init|=
name|xcb_get_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|&
name|xcb_shape_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xshape_reply
operator|||
operator|!
name|xshape_reply
operator|->
name|present
condition|)
return|return;
name|has_shape_extension
operator|=
literal|true
expr_stmt|;
name|xcb_shape_query_version_cookie_t
name|cookie
init|=
name|xcb_shape_query_version
argument_list|(
name|m_connection
argument_list|)
decl_stmt|;
name|xcb_shape_query_version_reply_t
modifier|*
name|shape_query
init|=
name|xcb_shape_query_version_reply
argument_list|(
name|m_connection
argument_list|,
name|cookie
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|shape_query
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to initialize SHAPE extension"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shape_query
operator|->
name|major_version
operator|>
literal|1
operator|||
operator|(
name|shape_query
operator|->
name|major_version
operator|==
literal|1
operator|&&
name|shape_query
operator|->
name|minor_version
operator|>=
literal|1
operator|)
condition|)
block|{
comment|// The input shape is the only thing added in SHAPE 1.1
name|has_input_shape
operator|=
literal|true
expr_stmt|;
block|}
name|free
argument_list|(
name|shape_query
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|XCB_USE_EGL
argument_list|)
end_if
begin_function
DECL|function|hasEgl
name|bool
name|QXcbConnection
operator|::
name|hasEgl
parameter_list|()
specifier|const
block|{
return|return
name|m_has_egl
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// defined(XCB_USE_EGL)
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_USE_DRI2
end_ifdef
begin_function
DECL|function|initializeDri2
name|void
name|QXcbConnection
operator|::
name|initializeDri2
parameter_list|()
block|{
name|xcb_dri2_connect_cookie_t
name|connect_cookie
init|=
name|xcb_dri2_connect_unchecked
argument_list|(
name|m_connection
argument_list|,
name|m_screens
index|[
literal|0
index|]
operator|->
name|root
argument_list|()
argument_list|,
name|XCB_DRI2_DRIVER_TYPE_DRI
argument_list|)
decl_stmt|;
name|xcb_dri2_connect_reply_t
modifier|*
name|connect
init|=
name|xcb_dri2_connect_reply
argument_list|(
name|m_connection
argument_list|,
name|connect_cookie
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|connect
operator|||
name|connect
operator|->
name|driver_name_length
operator|+
name|connect
operator|->
name|device_name_length
operator|==
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to connect to DRI2"
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_dri2_device_name
operator|=
name|QByteArray
argument_list|(
name|xcb_dri2_connect_device_name
argument_list|(
name|connect
argument_list|)
argument_list|,
name|xcb_dri2_connect_device_name_length
argument_list|(
name|connect
argument_list|)
argument_list|)
expr_stmt|;
operator|delete
name|connect
expr_stmt|;
name|int
name|fd
init|=
name|open
argument_list|(
name|m_dri2_device_name
operator|.
name|constData
argument_list|()
argument_list|,
name|O_RDWR
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QXcbConnection: Couldn't open DRI2 device"
operator|<<
name|m_dri2_device_name
expr_stmt|;
name|m_dri2_device_name
operator|=
name|QByteArray
argument_list|()
expr_stmt|;
return|return;
block|}
name|drm_magic_t
name|magic
decl_stmt|;
if|if
condition|(
name|drmGetMagic
argument_list|(
name|fd
argument_list|,
operator|&
name|magic
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to get drmMagic"
argument_list|)
expr_stmt|;
return|return;
block|}
name|xcb_dri2_authenticate_cookie_t
name|authenticate_cookie
init|=
name|xcb_dri2_authenticate_unchecked
argument_list|(
name|m_connection
argument_list|,
name|m_screens
index|[
literal|0
index|]
operator|->
name|root
argument_list|()
argument_list|,
name|magic
argument_list|)
decl_stmt|;
name|xcb_dri2_authenticate_reply_t
modifier|*
name|authenticate
init|=
name|xcb_dri2_authenticate_reply
argument_list|(
name|m_connection
argument_list|,
name|authenticate_cookie
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|authenticate
operator|==
name|NULL
operator|||
operator|!
name|authenticate
operator|->
name|authenticated
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: DRI2: failed to authenticate"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|authenticate
argument_list|)
expr_stmt|;
return|return;
block|}
operator|delete
name|authenticate
expr_stmt|;
name|EGLDisplay
name|display
init|=
name|eglGetDRMDisplayMESA
argument_list|(
name|fd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|display
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to create EGL display using DRI2"
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_egl_display
operator|=
name|display
expr_stmt|;
name|EGLint
name|major
decl_stmt|,
name|minor
decl_stmt|;
if|if
condition|(
operator|!
name|eglInitialize
argument_list|(
name|display
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QXcbConnection: Failed to initialize EGL display using DRI2"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function
begin_function
DECL|function|hasSupportForDri2
name|bool
name|QXcbConnection
operator|::
name|hasSupportForDri2
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|m_dri2_support_probed
condition|)
block|{
name|xcb_generic_error_t
modifier|*
name|error
init|=
literal|0
decl_stmt|;
name|xcb_prefetch_extension_data
argument_list|(
name|m_connection
argument_list|,
operator|&
name|xcb_dri2_id
argument_list|)
expr_stmt|;
name|xcb_dri2_query_version_cookie_t
name|dri2_query_cookie
init|=
name|xcb_dri2_query_version
argument_list|(
name|m_connection
argument_list|,
name|XCB_DRI2_MAJOR_VERSION
argument_list|,
name|XCB_DRI2_MINOR_VERSION
argument_list|)
decl_stmt|;
name|xcb_dri2_query_version_reply_t
modifier|*
name|dri2_query
init|=
name|xcb_dri2_query_version_reply
argument_list|(
name|m_connection
argument_list|,
name|dri2_query_cookie
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dri2_query
operator|||
name|error
condition|)
block|{
operator|delete
name|error
expr_stmt|;
operator|delete
name|dri2_query
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QXcbConnection
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QXcbConnection
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|m_dri2_major
operator|=
name|dri2_query
operator|->
name|major_version
expr_stmt|;
name|that
operator|->
name|m_dri2_minor
operator|=
name|dri2_query
operator|->
name|minor_version
expr_stmt|;
name|that
operator|->
name|m_has_support_for_dri2
operator|=
literal|true
expr_stmt|;
name|that
operator|->
name|m_dri2_support_probed
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|m_has_support_for_dri2
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//XCB_USE_DRI2
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|XCB_USE_XINPUT2
argument_list|)
operator|||
name|defined
argument_list|(
name|XCB_USE_XINPUT2_MAEMO
argument_list|)
end_if
begin_comment
comment|// Borrowed from libXi.
end_comment
begin_function
DECL|function|xi2CountBits
name|int
name|QXcbConnection
operator|::
name|xi2CountBits
parameter_list|(
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|bits
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|x
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|ptr
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|x
operator|>
literal|0
condition|)
block|{
name|bits
operator|+=
operator|(
name|x
operator|&
literal|0x1
operator|)
expr_stmt|;
name|x
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|bits
return|;
block|}
end_function
begin_function
DECL|function|xi2GetValuatorValueIfSet
name|bool
name|QXcbConnection
operator|::
name|xi2GetValuatorValueIfSet
parameter_list|(
name|void
modifier|*
name|event
parameter_list|,
name|int
name|valuatorNum
parameter_list|,
name|double
modifier|*
name|value
parameter_list|)
block|{
name|xXIDeviceEvent
modifier|*
name|xideviceevent
init|=
cast|static_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buttonsMaskAddr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|xideviceevent
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|valuatorsMaskAddr
init|=
name|buttonsMaskAddr
operator|+
name|xideviceevent
operator|->
name|buttons_len
operator|*
literal|4
decl_stmt|;
name|FP3232
modifier|*
name|valuatorsValuesAddr
init|=
operator|(
name|FP3232
operator|*
operator|)
operator|(
name|valuatorsMaskAddr
operator|+
name|xideviceevent
operator|->
name|valuators_len
operator|*
literal|4
operator|)
decl_stmt|;
name|int
name|numValuatorValues
init|=
name|xi2CountBits
argument_list|(
name|valuatorsMaskAddr
argument_list|,
name|xideviceevent
operator|->
name|valuators_len
operator|*
literal|4
argument_list|)
decl_stmt|;
comment|// This relies on all bit being set until a certain number i.e. it doesn't support only bit 0 and 5 being set in the mask.
comment|// Just like the original code, works for now.
if|if
condition|(
name|valuatorNum
operator|>=
name|numValuatorValues
condition|)
return|return
literal|false
return|;
operator|*
name|value
operator|=
name|valuatorsValuesAddr
index|[
name|valuatorNum
index|]
operator|.
name|integral
expr_stmt|;
operator|*
name|value
operator|+=
operator|(
operator|(
name|double
operator|)
name|valuatorsValuesAddr
index|[
name|valuatorNum
index|]
operator|.
name|frac
operator|/
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|/
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|xi2PrepareXIGenericDeviceEvent
name|bool
name|QXcbConnection
operator|::
name|xi2PrepareXIGenericDeviceEvent
parameter_list|(
name|xcb_ge_event_t
modifier|*
name|event
parameter_list|,
name|int
name|opCode
parameter_list|)
block|{
comment|// xGenericEvent has "extension" on the second byte, xcb_ge_event_t has "pad0".
if|if
condition|(
name|event
operator|->
name|pad0
operator|==
name|opCode
condition|)
block|{
comment|// xcb event structs contain stuff that wasn't on the wire, the full_sequence field
comment|// adds an extra 4 bytes and generic events cookie data is on the wire right after the standard 32 bytes.
comment|// Move this data back to have the same layout in memory as it was on the wire
comment|// and allow casting, overwriting the full_sequence field.
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|event
operator|+
literal|32
argument_list|,
operator|(
name|char
operator|*
operator|)
name|event
operator|+
literal|36
argument_list|,
name|event
operator|->
name|length
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// defined(XCB_USE_XINPUT2) || defined(XCB_USE_XINPUT2_MAEMO)
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
