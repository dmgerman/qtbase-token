begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtGui module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qxcbdrag.h"
end_include
begin_include
include|#
directive|include
file|<xcb/xcb.h>
end_include
begin_include
include|#
directive|include
file|"qxcbconnection.h"
end_include
begin_include
include|#
directive|include
file|"qxcbclipboard.h"
end_include
begin_include
include|#
directive|include
file|"qxcbmime.h"
end_include
begin_include
include|#
directive|include
file|"qxcbwindow.h"
end_include
begin_include
include|#
directive|include
file|"qwindow.h"
end_include
begin_include
include|#
directive|include
file|<private/qdnd_p.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qevent.h>
end_include
begin_include
include|#
directive|include
file|<qguiapplication.h>
end_include
begin_include
include|#
directive|include
file|<qrect.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|macro|DND_DEBUG
define|#
directive|define
name|DND_DEBUG
ifdef|#
directive|ifdef
name|DND_DEBUG
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|qDebug
else|#
directive|else
define|#
directive|define
name|DEBUG
value|if(0) qDebug
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DND_DEBUG
DECL|macro|DNDDEBUG
define|#
directive|define
name|DNDDEBUG
value|qDebug()
else|#
directive|else
define|#
directive|define
name|DNDDEBUG
value|if(0) qDebug()
endif|#
directive|endif
DECL|variable|xdnd_version
specifier|const
name|int
name|xdnd_version
init|=
literal|5
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|xcb_window
specifier|static
specifier|inline
name|xcb_window_t
name|xcb_window
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|)
block|{
return|return
cast|static_cast
argument_list|<
name|QXcbWindow
operator|*
argument_list|>
argument_list|(
name|w
operator|->
name|handle
argument_list|()
argument_list|)
operator|->
name|xcb_window
argument_list|()
return|;
block|}
end_function
begin_class
DECL|class|QDropData
class|class
name|QDropData
super|:
specifier|public
name|QXcbMime
block|{
public|public:
name|QDropData
parameter_list|(
name|QXcbDrag
modifier|*
name|d
parameter_list|)
constructor_decl|;
name|~
name|QDropData
parameter_list|()
destructor_decl|;
protected|protected:
name|bool
name|hasFormat_sys
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|)
specifier|const
function_decl|;
name|QStringList
name|formats_sys
parameter_list|()
specifier|const
function_decl|;
name|QVariant
name|retrieveData_sys
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|QVariant
operator|::
name|Type
name|type
parameter_list|)
specifier|const
function_decl|;
name|QVariant
name|xdndObtainData
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|format
parameter_list|,
name|QVariant
operator|::
name|Type
name|requestedType
parameter_list|)
specifier|const
function_decl|;
DECL|member|drag
name|QXcbDrag
modifier|*
name|drag
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QXcbDrag
name|QXcbDrag
operator|::
name|QXcbDrag
parameter_list|(
name|QXcbConnection
modifier|*
name|c
parameter_list|)
block|{
name|m_connection
operator|=
name|c
expr_stmt|;
name|dropData
operator|=
operator|new
name|QDropData
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|startDrag
argument_list|()
expr_stmt|;
comment|// init variables
block|}
end_constructor
begin_destructor
DECL|function|~QXcbDrag
name|QXcbDrag
operator|::
name|~
name|QXcbDrag
parameter_list|()
block|{
operator|delete
name|dropData
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|platformDropData
name|QMimeData
modifier|*
name|QXcbDrag
operator|::
name|platformDropData
parameter_list|()
block|{
return|return
name|dropData
return|;
block|}
end_function
begin_function
DECL|function|startDrag
name|void
name|QXcbDrag
operator|::
name|startDrag
parameter_list|()
block|{
name|currentWindow
operator|.
name|clear
argument_list|()
expr_stmt|;
name|xdnd_dragsource
operator|=
name|XCB_NONE
expr_stmt|;
name|last_target_accepted_action
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
name|waiting_for_status
operator|=
literal|false
expr_stmt|;
name|current_proxy_target
operator|=
name|XCB_NONE
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cancel
name|void
name|QXcbDrag
operator|::
name|cancel
parameter_list|()
block|{
comment|//###
block|}
end_function
begin_function
DECL|function|move
name|void
name|QXcbDrag
operator|::
name|move
parameter_list|(
specifier|const
name|QMouseEvent
modifier|*
name|me
parameter_list|)
block|{
comment|// ###
block|}
end_function
begin_function
DECL|function|drop
name|void
name|QXcbDrag
operator|::
name|drop
parameter_list|(
specifier|const
name|QMouseEvent
modifier|*
name|me
parameter_list|)
block|{
comment|// ###
block|}
end_function
begin_define
DECL|macro|ATOM
define|#
directive|define
name|ATOM
parameter_list|(
name|x
parameter_list|)
value|connection()->atom(QXcbAtom::x)
end_define
begin_function
DECL|function|toDropAction
name|Qt
operator|::
name|DropAction
name|QXcbDrag
operator|::
name|toDropAction
parameter_list|(
name|xcb_atom_t
name|atom
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|atom
operator|==
name|ATOM
argument_list|(
name|XdndActionCopy
argument_list|)
operator|||
name|atom
operator|==
literal|0
condition|)
return|return
name|Qt
operator|::
name|CopyAction
return|;
if|if
condition|(
name|atom
operator|==
name|ATOM
argument_list|(
name|XdndActionLink
argument_list|)
condition|)
return|return
name|Qt
operator|::
name|LinkAction
return|;
if|if
condition|(
name|atom
operator|==
name|ATOM
argument_list|(
name|XdndActionMove
argument_list|)
condition|)
return|return
name|Qt
operator|::
name|MoveAction
return|;
return|return
name|Qt
operator|::
name|CopyAction
return|;
block|}
end_function
begin_function
DECL|function|toXdndAction
name|xcb_atom_t
name|QXcbDrag
operator|::
name|toXdndAction
parameter_list|(
name|Qt
operator|::
name|DropAction
name|a
parameter_list|)
specifier|const
block|{
switch|switch
condition|(
name|a
condition|)
block|{
case|case
name|Qt
operator|::
name|CopyAction
case|:
return|return
name|ATOM
argument_list|(
name|XdndActionCopy
argument_list|)
return|;
case|case
name|Qt
operator|::
name|LinkAction
case|:
return|return
name|ATOM
argument_list|(
name|XdndActionLink
argument_list|)
return|;
case|case
name|Qt
operator|::
name|MoveAction
case|:
case|case
name|Qt
operator|::
name|TargetMoveAction
case|:
return|return
name|ATOM
argument_list|(
name|XdndActionMove
argument_list|)
return|;
case|case
name|Qt
operator|::
name|IgnoreAction
case|:
return|return
name|XCB_NONE
return|;
default|default:
return|return
name|ATOM
argument_list|(
name|XdndActionCopy
argument_list|)
return|;
block|}
block|}
end_function
begin_undef
DECL|macro|ATOM
undef|#
directive|undef
name|ATOM
end_undef
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
unit|static int findXdndDropTransactionByWindow(Window window) {     int at = -1;     for (int i = 0; i< X11->dndDropTransactions.count(); ++i) {         const QXdndDropTransaction&t = X11->dndDropTransactions.at(i);         if (t.target == window || t.proxy_target == window) {             at = i;             break;         }     }     return at; }  static int findXdndDropTransactionByTime(Time timestamp) {     int at = -1;     for (int i = 0; i< X11->dndDropTransactions.count(); ++i) {         const QXdndDropTransaction&t = X11->dndDropTransactions.at(i);         if (t.timestamp == timestamp) {             at = i;             break;         }     }     return at; }
comment|// timer used to discard old XdndDrop transactions
end_comment
begin_comment
unit|static int transaction_expiry_timer = -1; enum { XdndDropTransactionTimeout = 5000 };
comment|// 5 seconds
end_comment
begin_comment
unit|static void restartXdndDropExpiryTimer() {     if (transaction_expiry_timer != -1)         QDragManager::self()->killTimer(transaction_expiry_timer);     transaction_expiry_timer = QDragManager::self()->startTimer(XdndDropTransactionTimeout); }
comment|// find an ancestor with XdndAware on it
end_comment
begin_comment
unit|static Window findXdndAwareParent(Window window) {     Window target = 0;     forever {
comment|// check if window has XdndAware
end_comment
begin_comment
unit|Atom type = 0;         int f;         unsigned long n, a;         unsigned char *data = 0;         if (XGetWindowProperty(X11->display, window, ATOM(XdndAware), 0, 0, False,                                AnyPropertyType,&type,&f,&n,&a,&data) == Success) { 	    if (data)                 XFree(data); 	    if (type) {                 target = window;                 break;             }         }
comment|// try window's parent
end_comment
begin_comment
unit|Window root;         Window parent;         Window *children;         uint unused;         if (!XQueryTree(X11->display, window,&root,&parent,&children,&unused))             break;         if (children)             XFree(children);         if (window == root)             break;         window = parent;     }     return target; }
comment|// clean up the stuff used.
end_comment
begin_comment
unit|static void qt_xdnd_cleanup();  static void qt_xdnd_send_leave();
comment|// timer used when target wants "continuous" move messages (eg. scroll)
end_comment
begin_comment
unit|static int heartbeat = -1;
comment|// top-level window we sent position to last.
end_comment
begin_comment
unit|static Window qt_xdnd_current_target;
comment|// window to send events to (always valid if qt_xdnd_current_target)
end_comment
begin_comment
unit|static Window current_proxy_target;
comment|// widget we forwarded position to last, and local position
end_comment
begin_comment
unit|static QPointer<QWidget> currentWindow; static QPoint currentPosition;
comment|// timestamp from the XdndPosition and XdndDrop
end_comment
begin_comment
unit|static Time target_time;
comment|// screen number containing the pointer... -1 means default
end_comment
begin_comment
unit|static int qt_xdnd_current_screen = -1;
comment|// state of dragging... true if dragging, false if not
end_comment
begin_comment
unit|bool qt_xdnd_dragging = false;  static bool waiting_for_status = false;
comment|// used to preset each new QDragMoveEvent
end_comment
begin_comment
comment|// Shift/Ctrl handling, and final drop status
end_comment
begin_comment
unit|static Qt::DropAction global_accepted_action = Qt::CopyAction; static Qt::DropActions possible_actions = Qt::IgnoreAction;
comment|// for embedding only
end_comment
begin_comment
unit|static QWidget* current_embedding_widget  = 0; static xcb_client_message_event_t last_enter_event;
comment|// cursors
end_comment
begin_comment
unit|static QCursor *noDropCursor = 0; static QCursor *moveCursor = 0; static QCursor *copyCursor = 0; static QCursor *linkCursor = 0;   class QExtraWidget : public QWidget {     Q_DECLARE_PRIVATE(QWidget) public:     inline QWExtra* extraData();     inline QTLWExtra* topData(); };  inline QWExtra* QExtraWidget::extraData() { return d_func()->extraData(); } inline QTLWExtra* QExtraWidget::topData() { return d_func()->topData(); }    void QX11Data::xdndSetup() {     QCursorData::initialize();     qAddPostRoutine(qt_xdnd_cleanup); }   void qt_xdnd_cleanup() {     delete noDropCursor;     noDropCursor = 0;     delete copyCursor;     copyCursor = 0;     delete moveCursor;     moveCursor = 0;     delete linkCursor;     linkCursor = 0;     delete defaultPm;     defaultPm = 0;     delete xdnd_data.desktop_proxy;     xdnd_data.desktop_proxy = 0;     delete xdnd_data.deco;     xdnd_data.deco = 0; }   static QWidget *find_child(QWidget *tlw, QPoint& p) {     QWidget *widget = tlw;      p = widget->mapFromGlobal(p);     bool done = false;     while (!done) {         done = true;         if (((QExtraWidget*)widget)->extraData()&&              ((QExtraWidget*)widget)->extraData()->xDndProxy != 0)             break;
comment|// stop searching for widgets under the mouse cursor if found widget is a proxy.
end_comment
begin_endif
unit|QObjectList children = widget->children();         if (!children.isEmpty()) {             for(int i = children.size(); i> 0;) {                 --i;                 QWidget *w = qobject_cast<QWidget *>(children.at(i));                 if (!w)                     continue;                 if (w->testAttribute(Qt::WA_TransparentForMouseEvents))                     continue;                 if (w->isVisible()&&                      w->geometry().contains(p)&&                      !w->isWindow()) {                     widget = w;                     done = false;                     p = widget->mapFromParent(p);                     break;                 }             }         }     }     return widget; }   static bool checkEmbedded(QWidget* w, const XEvent* xe) {     if (!w)         return false;      if (current_embedding_widget != 0&& current_embedding_widget != w) {         qt_xdnd_current_target = ((QExtraWidget*)current_embedding_widget)->extraData()->xDndProxy;         current_proxy_target = qt_xdnd_current_target;         qt_xdnd_send_leave();         qt_xdnd_current_target = 0;         current_proxy_target = 0;         current_embedding_widget = 0;     }      QWExtra* extra = ((QExtraWidget*)w)->extraData();     if (extra&& extra->xDndProxy != 0) {          if (current_embedding_widget != w) {              last_enter_event.xany.window = extra->xDndProxy;             XSendEvent(X11->display, extra->xDndProxy, False, NoEventMask,&last_enter_event);             current_embedding_widget = w;         }          ((XEvent*)xe)->xany.window = extra->xDndProxy;         XSendEvent(X11->display, extra->xDndProxy, False, NoEventMask, (XEvent*)xe);         if (currentWindow != w) {             currentWindow = w;         }         return true;     }     current_embedding_widget = 0;     return false; }
endif|#
directive|endif
end_endif
begin_function
DECL|function|handleEnter
name|void
name|QXcbDrag
operator|::
name|handleEnter
parameter_list|(
name|QWindow
modifier|*
name|window
parameter_list|,
specifier|const
name|xcb_client_message_event_t
modifier|*
name|event
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|()
operator|<<
literal|"handleEnter"
operator|<<
name|window
expr_stmt|;
comment|//    motifdnd_active = false;
comment|//    last_enter_event.xclient = xe->xclient;
name|int
name|version
init|=
call|(
name|int
call|)
argument_list|(
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|1
index|]
operator|>>
literal|24
argument_list|)
decl_stmt|;
if|if
condition|(
name|version
operator|>
name|xdnd_version
condition|)
return|return;
name|xdnd_dragsource
operator|=
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|1
index|]
operator|&
literal|1
condition|)
block|{
comment|// get the types from XdndTypeList
name|xcb_get_property_cookie_t
name|cookie
init|=
name|xcb_get_property
argument_list|(
name|connection
argument_list|()
operator|->
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|xdnd_dragsource
argument_list|,
name|connection
argument_list|()
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndTypelist
argument_list|)
argument_list|,
name|QXcbAtom
operator|::
name|XA_ATOM
argument_list|,
literal|0
argument_list|,
name|xdnd_max_type
argument_list|)
decl_stmt|;
name|xcb_get_property_reply_t
modifier|*
name|reply
init|=
name|xcb_get_property_reply
argument_list|(
name|connection
argument_list|()
operator|->
name|xcb_connection
argument_list|()
argument_list|,
name|cookie
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
operator|&&
name|reply
operator|->
name|type
operator|!=
name|XCB_NONE
operator|&&
name|reply
operator|->
name|format
operator|==
literal|32
condition|)
block|{
name|int
name|length
init|=
name|xcb_get_property_value_length
argument_list|(
name|reply
argument_list|)
operator|/
literal|4
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|xdnd_max_type
condition|)
name|length
operator|=
name|xdnd_max_type
expr_stmt|;
name|xcb_atom_t
modifier|*
name|atoms
init|=
operator|(
name|xcb_atom_t
operator|*
operator|)
name|xcb_get_property_value
argument_list|(
name|reply
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
name|xdnd_types
operator|.
name|append
argument_list|(
name|atoms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// get the types from the message
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|event
operator|->
name|data
operator|.
name|data32
index|[
name|i
index|]
condition|)
name|xdnd_types
operator|.
name|append
argument_list|(
name|event
operator|->
name|data
operator|.
name|data32
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xdnd_types
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
name|DEBUG
argument_list|()
operator|<<
literal|"    "
operator|<<
name|connection
argument_list|()
operator|->
name|atomName
argument_list|(
name|xdnd_types
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handle_xdnd_position
name|void
name|QXcbDrag
operator|::
name|handle_xdnd_position
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|,
specifier|const
name|xcb_client_message_event_t
modifier|*
name|e
parameter_list|,
name|bool
name|passive
parameter_list|)
block|{
name|QPoint
name|p
argument_list|(
operator|(
name|e
operator|->
name|data
operator|.
name|data32
index|[
literal|2
index|]
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
argument_list|,
name|e
operator|->
name|data
operator|.
name|data32
index|[
literal|2
index|]
operator|&
literal|0x0000ffff
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|QRect
name|geometry
init|=
name|w
operator|->
name|geometry
argument_list|()
decl_stmt|;
name|p
operator|-=
name|geometry
operator|.
name|topLeft
argument_list|()
expr_stmt|;
comment|// ####
comment|//    if (!passive&& checkEmbedded(w, e))
comment|//        return;
if|if
condition|(
operator|!
name|w
operator|||
operator|(
comment|/*!w->acceptDrops()&&*/
operator|(
name|w
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
name|e
operator|->
name|data
operator|.
name|data32
index|[
literal|0
index|]
operator|!=
name|xdnd_dragsource
condition|)
block|{
name|DEBUG
argument_list|(
literal|"xdnd drag position from unexpected source (%x not %x)"
argument_list|,
name|e
operator|->
name|data
operator|.
name|data32
index|[
literal|0
index|]
argument_list|,
name|xdnd_dragsource
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// timestamp from the source
if|if
condition|(
name|e
operator|->
name|data
operator|.
name|data32
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
name|target_time
comment|/*= X11->userTime*/
operator|=
name|e
operator|->
name|data
operator|.
name|data32
index|[
literal|3
index|]
expr_stmt|;
name|QDragManager
modifier|*
name|manager
init|=
name|QDragManager
operator|::
name|self
argument_list|()
decl_stmt|;
name|QMimeData
modifier|*
name|dropData
init|=
name|manager
operator|->
name|dropData
argument_list|()
decl_stmt|;
name|xcb_client_message_event_t
name|response
decl_stmt|;
name|response
operator|.
name|response_type
operator|=
name|XCB_CLIENT_MESSAGE
expr_stmt|;
name|response
operator|.
name|window
operator|=
name|xdnd_dragsource
expr_stmt|;
name|response
operator|.
name|format
operator|=
literal|32
expr_stmt|;
name|response
operator|.
name|type
operator|=
name|connection
argument_list|()
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndStatus
argument_list|)
expr_stmt|;
name|response
operator|.
name|data
operator|.
name|data32
index|[
literal|0
index|]
operator|=
name|xcb_window
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|response
operator|.
name|data
operator|.
name|data32
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|// flags
name|response
operator|.
name|data
operator|.
name|data32
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|// x, y
name|response
operator|.
name|data
operator|.
name|data32
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|// w, h
name|response
operator|.
name|data
operator|.
name|data32
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|// action
if|if
condition|(
operator|!
name|passive
condition|)
block|{
comment|// otherwise just reject
name|QRect
name|answerRect
argument_list|(
name|p
operator|+
name|geometry
operator|.
name|topLeft
argument_list|()
argument_list|,
name|QSize
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|manager
operator|->
name|object
condition|)
block|{
name|manager
operator|->
name|possible_actions
operator|=
name|manager
operator|->
name|dragPrivate
argument_list|()
operator|->
name|possible_actions
expr_stmt|;
block|}
else|else
block|{
name|manager
operator|->
name|possible_actions
operator|=
name|Qt
operator|::
name|DropActions
argument_list|(
name|toDropAction
argument_list|(
name|e
operator|->
name|data
operator|.
name|data32
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|//             possible_actions |= Qt::CopyAction;
block|}
name|QDragMoveEvent
name|me
argument_list|(
name|p
argument_list|,
name|manager
operator|->
name|possible_actions
argument_list|,
name|dropData
argument_list|,
name|QGuiApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QGuiApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|DropAction
name|accepted_action
init|=
name|Qt
operator|::
name|IgnoreAction
decl_stmt|;
name|currentPosition
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|currentWindow
operator|.
name|data
argument_list|()
condition|)
block|{
if|if
condition|(
name|currentWindow
condition|)
block|{
name|QDragLeaveEvent
name|e
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|currentWindow
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
name|currentWindow
operator|=
name|w
expr_stmt|;
name|last_target_accepted_action
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
name|QDragEnterEvent
name|de
argument_list|(
name|p
argument_list|,
name|manager
operator|->
name|possible_actions
argument_list|,
name|dropData
argument_list|,
name|QGuiApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QGuiApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|de
operator|.
name|isAccepted
argument_list|()
operator|&&
name|de
operator|.
name|dropAction
argument_list|()
operator|!=
name|Qt
operator|::
name|IgnoreAction
condition|)
name|last_target_accepted_action
operator|=
name|de
operator|.
name|dropAction
argument_list|()
expr_stmt|;
block|}
name|DEBUG
argument_list|()
operator|<<
literal|"qt_handle_xdnd_position action="
operator|<<
name|connection
argument_list|()
operator|->
name|atomName
argument_list|(
name|e
operator|->
name|data
operator|.
name|data32
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_target_accepted_action
operator|!=
name|Qt
operator|::
name|IgnoreAction
condition|)
block|{
name|me
operator|.
name|setDropAction
argument_list|(
name|last_target_accepted_action
argument_list|)
expr_stmt|;
name|me
operator|.
name|accept
argument_list|()
expr_stmt|;
block|}
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|w
argument_list|,
operator|&
name|me
argument_list|)
expr_stmt|;
if|if
condition|(
name|me
operator|.
name|isAccepted
argument_list|()
condition|)
block|{
name|response
operator|.
name|data
operator|.
name|data32
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|// yes
name|accepted_action
operator|=
name|me
operator|.
name|dropAction
argument_list|()
expr_stmt|;
name|last_target_accepted_action
operator|=
name|accepted_action
expr_stmt|;
block|}
else|else
block|{
name|response
operator|.
name|data
operator|.
name|data32
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|last_target_accepted_action
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
block|}
name|answerRect
operator|=
name|me
operator|.
name|answerRect
argument_list|()
operator|.
name|translated
argument_list|(
name|geometry
operator|.
name|topLeft
argument_list|()
argument_list|)
operator|.
name|intersected
argument_list|(
name|geometry
argument_list|)
expr_stmt|;
if|if
condition|(
name|answerRect
operator|.
name|left
argument_list|()
operator|<
literal|0
condition|)
name|answerRect
operator|.
name|setLeft
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|answerRect
operator|.
name|right
argument_list|()
operator|>
literal|4096
condition|)
name|answerRect
operator|.
name|setRight
argument_list|(
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
name|answerRect
operator|.
name|top
argument_list|()
operator|<
literal|0
condition|)
name|answerRect
operator|.
name|setTop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|answerRect
operator|.
name|bottom
argument_list|()
operator|>
literal|4096
condition|)
name|answerRect
operator|.
name|setBottom
argument_list|(
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
name|answerRect
operator|.
name|width
argument_list|()
operator|<
literal|0
condition|)
name|answerRect
operator|.
name|setWidth
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|answerRect
operator|.
name|height
argument_list|()
operator|<
literal|0
condition|)
name|answerRect
operator|.
name|setHeight
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|response
operator|.
name|data
operator|.
name|data32
index|[
literal|2
index|]
operator|=
operator|(
name|answerRect
operator|.
name|x
argument_list|()
operator|<<
literal|16
operator|)
operator|+
name|answerRect
operator|.
name|y
argument_list|()
expr_stmt|;
name|response
operator|.
name|data
operator|.
name|data32
index|[
literal|3
index|]
operator|=
operator|(
name|answerRect
operator|.
name|width
argument_list|()
operator|<<
literal|16
operator|)
operator|+
name|answerRect
operator|.
name|height
argument_list|()
expr_stmt|;
name|response
operator|.
name|data
operator|.
name|data32
index|[
literal|4
index|]
operator|=
name|toXdndAction
argument_list|(
name|accepted_action
argument_list|)
expr_stmt|;
block|}
comment|// reset
name|target_time
operator|=
name|XCB_CURRENT_TIME
expr_stmt|;
name|QXcbWindow
modifier|*
name|source
init|=
name|connection
argument_list|()
operator|->
name|platformWindowFromId
argument_list|(
name|xdnd_dragsource
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|&&
operator|(
name|source
operator|->
name|window
argument_list|()
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
comment|/*&& !source->acceptDrops()*/
condition|)
name|source
operator|=
literal|0
expr_stmt|;
name|DEBUG
argument_list|()
operator|<<
literal|"sending XdndStatus"
expr_stmt|;
if|if
condition|(
name|source
condition|)
name|handle_xdnd_status
argument_list|(
name|source
operator|->
name|window
argument_list|()
argument_list|,
operator|&
name|response
argument_list|,
name|passive
argument_list|)
expr_stmt|;
else|else
name|Q_XCB_CALL
argument_list|(
name|xcb_send_event
argument_list|(
name|connection
argument_list|()
operator|->
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|xdnd_dragsource
argument_list|,
name|XCB_EVENT_MASK_NO_EVENT
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|response
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_namespace
namespace|namespace
block|{
DECL|class|ClientMessageScanner
class|class
name|ClientMessageScanner
block|{
public|public:
DECL|function|ClientMessageScanner
name|ClientMessageScanner
parameter_list|(
name|xcb_atom_t
name|a
parameter_list|)
member_init_list|:
name|atom
argument_list|(
name|a
argument_list|)
block|{}
DECL|member|atom
name|xcb_atom_t
name|atom
decl_stmt|;
DECL|function|check
name|bool
name|check
parameter_list|(
name|xcb_generic_event_t
modifier|*
name|event
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|event
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|(
name|event
operator|->
name|response_type
operator|&
literal|0x7f
operator|)
operator|!=
name|XCB_CLIENT_MESSAGE
condition|)
return|return
literal|false
return|;
return|return
operator|(
operator|(
name|xcb_client_message_event_t
operator|*
operator|)
name|event
operator|)
operator|->
name|type
operator|==
name|atom
return|;
block|}
block|}
class|;
block|}
end_namespace
begin_function
DECL|function|handlePosition
name|void
name|QXcbDrag
operator|::
name|handlePosition
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|,
specifier|const
name|xcb_client_message_event_t
modifier|*
name|event
parameter_list|,
name|bool
name|passive
parameter_list|)
block|{
name|xcb_client_message_event_t
modifier|*
name|lastEvent
init|=
cast|const_cast
argument_list|<
name|xcb_client_message_event_t
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|xcb_generic_event_t
modifier|*
name|nextEvent
decl_stmt|;
name|ClientMessageScanner
name|scanner
argument_list|(
name|connection
argument_list|()
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndPosition
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|nextEvent
operator|=
name|connection
argument_list|()
operator|->
name|checkEvent
argument_list|(
name|scanner
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|lastEvent
operator|!=
name|event
condition|)
name|free
argument_list|(
name|lastEvent
argument_list|)
expr_stmt|;
name|lastEvent
operator|=
operator|(
name|xcb_client_message_event_t
operator|*
operator|)
name|nextEvent
expr_stmt|;
block|}
name|handle_xdnd_position
argument_list|(
name|w
argument_list|,
name|lastEvent
argument_list|,
name|passive
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastEvent
operator|!=
name|event
condition|)
name|free
argument_list|(
name|lastEvent
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handle_xdnd_status
name|void
name|QXcbDrag
operator|::
name|handle_xdnd_status
parameter_list|(
name|QWindow
modifier|*
parameter_list|,
specifier|const
name|xcb_client_message_event_t
modifier|*
name|event
parameter_list|,
name|bool
parameter_list|)
block|{
comment|// ignore late status messages
if|if
condition|(
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|0
index|]
operator|&&
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|0
index|]
operator|!=
name|current_proxy_target
condition|)
return|return;
name|Qt
operator|::
name|DropAction
name|newAction
init|=
operator|(
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|1
index|]
operator|&
literal|0x1
operator|)
condition|?
name|toDropAction
argument_list|(
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|4
index|]
argument_list|)
else|:
name|Qt
operator|::
name|IgnoreAction
decl_stmt|;
if|if
condition|(
operator|(
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|1
index|]
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|QPoint
name|p
argument_list|(
operator|(
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|2
index|]
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
argument_list|,
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|2
index|]
operator|&
literal|0x0000ffff
argument_list|)
decl_stmt|;
name|QSize
name|s
argument_list|(
operator|(
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|3
index|]
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
argument_list|,
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|3
index|]
operator|&
literal|0x0000ffff
argument_list|)
decl_stmt|;
name|source_sameanswer
operator|=
name|QRect
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|source_sameanswer
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
name|QDragManager
modifier|*
name|manager
init|=
name|QDragManager
operator|::
name|self
argument_list|()
decl_stmt|;
name|manager
operator|->
name|willDrop
operator|=
operator|(
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|1
index|]
operator|&
literal|0x1
operator|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|global_accepted_action
operator|!=
name|newAction
condition|)
block|{
name|manager
operator|->
name|global_accepted_action
operator|=
name|newAction
expr_stmt|;
name|manager
operator|->
name|emitActionChanged
argument_list|(
name|newAction
argument_list|)
expr_stmt|;
block|}
name|manager
operator|->
name|updateCursor
argument_list|()
expr_stmt|;
name|waiting_for_status
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleStatus
name|void
name|QXcbDrag
operator|::
name|handleStatus
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|,
specifier|const
name|xcb_client_message_event_t
modifier|*
name|event
parameter_list|,
name|bool
name|passive
parameter_list|)
block|{
name|DEBUG
argument_list|(
literal|"xdndHandleStatus"
argument_list|)
expr_stmt|;
name|xcb_client_message_event_t
modifier|*
name|lastEvent
init|=
cast|const_cast
argument_list|<
name|xcb_client_message_event_t
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|xcb_generic_event_t
modifier|*
name|nextEvent
decl_stmt|;
name|ClientMessageScanner
name|scanner
argument_list|(
name|connection
argument_list|()
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndStatus
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|nextEvent
operator|=
name|connection
argument_list|()
operator|->
name|checkEvent
argument_list|(
name|scanner
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|lastEvent
operator|!=
name|event
condition|)
name|free
argument_list|(
name|lastEvent
argument_list|)
expr_stmt|;
name|lastEvent
operator|=
operator|(
name|xcb_client_message_event_t
operator|*
operator|)
name|nextEvent
expr_stmt|;
block|}
name|handle_xdnd_status
argument_list|(
name|w
argument_list|,
name|lastEvent
argument_list|,
name|passive
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastEvent
operator|!=
name|event
condition|)
name|free
argument_list|(
name|lastEvent
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|"xdndHandleStatus end"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleLeave
name|void
name|QXcbDrag
operator|::
name|handleLeave
parameter_list|(
name|QWindow
modifier|*
name|w
parameter_list|,
specifier|const
name|xcb_client_message_event_t
modifier|*
name|event
parameter_list|,
name|bool
comment|/*passive*/
parameter_list|)
block|{
name|DEBUG
argument_list|(
literal|"xdnd leave"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentWindow
operator|||
name|w
operator|!=
name|currentWindow
operator|.
name|data
argument_list|()
condition|)
return|return;
comment|// sanity
comment|// ###
comment|//    if (checkEmbedded(current_embedding_widget, event)) {
comment|//        current_embedding_widget = 0;
comment|//        currentWindow.clear();
comment|//        return;
comment|//    }
if|if
condition|(
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|0
index|]
operator|!=
name|xdnd_dragsource
condition|)
block|{
comment|// This often happens - leave other-process window quickly
name|DEBUG
argument_list|(
literal|"xdnd drag leave from unexpected source (%x not %x"
argument_list|,
name|event
operator|->
name|data
operator|.
name|data32
index|[
literal|0
index|]
argument_list|,
name|xdnd_dragsource
argument_list|)
expr_stmt|;
block|}
name|QDragLeaveEvent
name|e
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|currentWindow
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|xdnd_dragsource
operator|=
literal|0
expr_stmt|;
name|xdnd_types
operator|.
name|clear
argument_list|()
expr_stmt|;
name|currentWindow
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
unit|void qt_xdnd_send_leave() {     if (!qt_xdnd_current_target)         return;      QDragManager *manager = QDragManager::self();      XClientMessageEvent leave;     leave.type = ClientMessage;     leave.window = qt_xdnd_current_target;     leave.format = 32;     leave.message_type = ATOM(XdndLeave);     leave.data.l[0] = manager->dragPrivate()->source->effectiveWinId();     leave.data.l[1] = 0;
comment|// flags
end_comment
begin_comment
unit|leave.data.l[2] = 0;
comment|// x, y
end_comment
begin_comment
unit|leave.data.l[3] = 0;
comment|// w, h
end_comment
begin_comment
unit|leave.data.l[4] = 0;
comment|// just null
end_comment
begin_comment
unit|QWidget * w = QWidget::find(current_proxy_target);      if (w&& (w->windowType() == Qt::Desktop)&& !w->acceptDrops())         w = 0;      if (w)         X11->xdndHandleLeave(w, (const XEvent *)&leave, false);     else         XSendEvent(X11->display, current_proxy_target, False,                     NoEventMask, (XEvent*)&leave);
comment|// reset the drag manager state
end_comment
begin_comment
unit|manager->willDrop = false;     if (global_accepted_action != Qt::IgnoreAction)         manager->emitActionChanged(Qt::IgnoreAction);     global_accepted_action = Qt::IgnoreAction;     manager->updateCursor();     qt_xdnd_current_target = 0;     current_proxy_target = 0;     qt_xdnd_source_current_time = 0;     waiting_for_status = false; }
comment|// TODO: remove and use QApplication::currentKeyboardModifiers() in Qt 4.8.
end_comment
begin_endif
unit|static Qt::KeyboardModifiers currentKeyboardModifiers() {     Window root;     Window child;     int root_x, root_y, win_x, win_y;     uint keybstate;     for (int i = 0; i< ScreenCount(X11->display); ++i) {         if (XQueryPointer(X11->display, QX11Info::appRootWindow(i),&root,&child,&root_x,&root_y,&win_x,&win_y,&keybstate))             return X11->translateModifiers(keybstate& 0x00ff);     }     return 0; }
endif|#
directive|endif
end_endif
begin_function
DECL|function|handleDrop
name|void
name|QXcbDrag
operator|::
name|handleDrop
parameter_list|(
name|QWindow
modifier|*
parameter_list|,
specifier|const
name|xcb_client_message_event_t
modifier|*
name|event
parameter_list|,
name|bool
name|passive
parameter_list|)
block|{
name|DEBUG
argument_list|(
literal|"xdndHandleDrop"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentWindow
condition|)
block|{
name|xdnd_dragsource
operator|=
literal|0
expr_stmt|;
return|return;
comment|// sanity
block|}
comment|// ###
comment|//    if (!passive&& checkEmbedded(currentWindow, xe)){
comment|//        current_embedding_widget = 0;
comment|//        xdnd_dragsource = 0;
comment|//        currentWindow = 0;
comment|//        return;
comment|//    }
specifier|const
name|uint32_t
modifier|*
name|l
init|=
name|event
operator|->
name|data
operator|.
name|data32
decl_stmt|;
name|QDragManager
modifier|*
name|manager
init|=
name|QDragManager
operator|::
name|self
argument_list|()
decl_stmt|;
name|DEBUG
argument_list|(
literal|"xdnd drop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
index|[
literal|0
index|]
operator|!=
name|xdnd_dragsource
condition|)
block|{
name|DEBUG
argument_list|(
literal|"xdnd drop from unexpected source (%x not %x"
argument_list|,
name|l
index|[
literal|0
index|]
argument_list|,
name|xdnd_dragsource
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// update the "user time" from the timestamp in the event.
if|if
condition|(
name|l
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|target_time
operator|=
comment|/*X11->userTime =*/
name|l
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|passive
condition|)
block|{
comment|// this could be a same-application drop, just proxied due to
comment|// some XEMBEDding, so try to find the real QMimeData used
comment|// based on the timestamp for this drop.
name|QMimeData
modifier|*
name|dropData
init|=
literal|0
decl_stmt|;
comment|// ###
comment|//        int at = findXdndDropTransactionByTime(target_time);
comment|//        if (at != -1)
comment|//            dropData = QDragManager::dragPrivate(X11->dndDropTransactions.at(at).object)->data;
comment|// if we can't find it, then use the data in the drag manager
if|if
condition|(
operator|!
name|dropData
condition|)
name|dropData
operator|=
name|manager
operator|->
name|dropData
argument_list|()
expr_stmt|;
comment|// Drop coming from another app? Update keyboard modifiers.
comment|//        if (!qt_xdnd_dragging) {
comment|//            QApplicationPrivate::modifier_buttons = currentKeyboardModifiers();
comment|//        }
name|QDropEvent
name|de
argument_list|(
name|currentPosition
argument_list|,
name|manager
operator|->
name|possible_actions
argument_list|,
name|dropData
argument_list|,
name|QGuiApplication
operator|::
name|mouseButtons
argument_list|()
argument_list|,
name|QGuiApplication
operator|::
name|keyboardModifiers
argument_list|()
argument_list|)
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|currentWindow
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|de
operator|.
name|isAccepted
argument_list|()
condition|)
block|{
comment|// Ignore a failed drag
name|manager
operator|->
name|global_accepted_action
operator|=
name|Qt
operator|::
name|IgnoreAction
expr_stmt|;
block|}
else|else
block|{
name|manager
operator|->
name|global_accepted_action
operator|=
name|de
operator|.
name|dropAction
argument_list|()
expr_stmt|;
block|}
name|xcb_client_message_event_t
name|finished
decl_stmt|;
name|finished
operator|.
name|type
operator|=
name|XCB_CLIENT_MESSAGE
expr_stmt|;
name|finished
operator|.
name|window
operator|=
name|xdnd_dragsource
expr_stmt|;
name|finished
operator|.
name|format
operator|=
literal|32
expr_stmt|;
name|finished
operator|.
name|type
operator|=
name|connection
argument_list|()
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndFinished
argument_list|)
expr_stmt|;
name|DNDDEBUG
operator|<<
literal|"xdndHandleDrop"
operator|<<
literal|"currentWindow"
operator|<<
name|currentWindow
operator|<<
operator|(
name|currentWindow
condition|?
name|xcb_window
argument_list|(
name|currentWindow
operator|.
name|data
argument_list|()
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|finished
operator|.
name|data
operator|.
name|data32
index|[
literal|0
index|]
operator|=
name|currentWindow
condition|?
name|xcb_window
argument_list|(
name|currentWindow
operator|.
name|data
argument_list|()
argument_list|)
else|:
name|XCB_NONE
expr_stmt|;
name|finished
operator|.
name|data
operator|.
name|data32
index|[
literal|1
index|]
operator|=
name|de
operator|.
name|isAccepted
argument_list|()
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|// flags
name|finished
operator|.
name|data
operator|.
name|data32
index|[
literal|2
index|]
operator|=
name|toXdndAction
argument_list|(
name|manager
operator|->
name|global_accepted_action
argument_list|)
expr_stmt|;
name|Q_XCB_CALL
argument_list|(
name|xcb_send_event
argument_list|(
name|connection
argument_list|()
operator|->
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|xdnd_dragsource
argument_list|,
name|XCB_EVENT_MASK_NO_EVENT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|finished
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QDragLeaveEvent
name|e
decl_stmt|;
name|QGuiApplication
operator|::
name|sendEvent
argument_list|(
name|currentWindow
operator|.
name|data
argument_list|()
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
name|xdnd_dragsource
operator|=
literal|0
expr_stmt|;
name|currentWindow
operator|.
name|clear
argument_list|()
expr_stmt|;
name|waiting_for_status
operator|=
literal|false
expr_stmt|;
comment|// reset
name|target_time
operator|=
name|XCB_CURRENT_TIME
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
unit|void QX11Data::xdndHandleFinished(QWidget *, const XEvent * xe, bool passive) {     DEBUG("xdndHandleFinished");     const unsigned long *l = (const unsigned long *)xe->xclient.data.l;      DNDDEBUG<< "xdndHandleFinished, l[0]"<< l[0]<< "qt_xdnd_current_target"<< qt_xdnd_current_target<< "qt_xdnd_current_proxy_targe"<< current_proxy_target;      if (l[0]) {         int at = findXdndDropTransactionByWindow(l[0]);         if (at != -1) {             restartXdndDropExpiryTimer();              QXdndDropTransaction t = X11->dndDropTransactions.takeAt(at);             QDragManager *manager = QDragManager::self();              Window target = qt_xdnd_current_target;             Window proxy_target = current_proxy_target;             QWidget *embedding_widget = current_embedding_widget;             QDrag *currentObject = manager->object;              qt_xdnd_current_target = t.target;             current_proxy_target = t.proxy_target;             current_embedding_widget = t.embedding_widget;             manager->object = t.object;              if (!passive)                 (void) checkEmbedded(currentWindow, xe);              current_embedding_widget = 0;             qt_xdnd_current_target = 0;             current_proxy_target = 0;              if (t.object)                 t.object->deleteLater();              qt_xdnd_current_target = target;             current_proxy_target = proxy_target;             current_embedding_widget = embedding_widget;             manager->object = currentObject;         }     }     waiting_for_status = false; }   void QDragManager::timerEvent(QTimerEvent* e) {     if (e->timerId() == heartbeat&& source_sameanswer.isNull()) {         move(QCursor::pos());     } else if (e->timerId() == transaction_expiry_timer) {         for (int i = 0; i< X11->dndDropTransactions.count(); ++i) {             const QXdndDropTransaction&t = X11->dndDropTransactions.at(i);             if (t.targetWidget) {
comment|// dnd within the same process, don't delete these
end_comment
begin_comment
unit|continue;             }             t.object->deleteLater();             X11->dndDropTransactions.removeAt(i--);         }          killTimer(transaction_expiry_timer);         transaction_expiry_timer = -1;     } }  bool QDragManager::eventFilter(QObject * o, QEvent * e) {     if (beingCancelled) {         if (e->type() == QEvent::KeyRelease&& ((QKeyEvent*)e)->key() == Qt::Key_Escape) {             qApp->removeEventFilter(this);             Q_ASSERT(object == 0);             beingCancelled = false;             eventLoop->exit();             return true;
comment|// block the key release
end_comment
begin_comment
unit|}         return false;     }      Q_ASSERT(object != 0);      if (!o->isWidgetType())         return false;      if (e->type() == QEvent::MouseMove) {         QMouseEvent* me = (QMouseEvent *)e;         move(me->globalPos());         return true;     } else if (e->type() == QEvent::MouseButtonRelease) {         DEBUG("pre drop");         qApp->removeEventFilter(this);         if (willDrop)             drop();         else             cancel();         DEBUG("drop, resetting object");         beingCancelled = false;         eventLoop->exit();         return true;     }      if (e->type() == QEvent::ShortcutOverride) {
comment|// prevent accelerators from firing while dragging
end_comment
begin_comment
unit|e->accept();         return true;     }      if (e->type() == QEvent::KeyPress || e->type() == QEvent::KeyRelease) {         QKeyEvent *ke = ((QKeyEvent*)e);         if (ke->key() == Qt::Key_Escape&& e->type() == QEvent::KeyPress) {             cancel();             qApp->removeEventFilter(this);             beingCancelled = false;             eventLoop->exit();         } else {             source_sameanswer = QRect();
comment|// force move
end_comment
begin_comment
unit|move(QCursor::pos());         }         return true;
comment|// Eat all key events
end_comment
begin_comment
unit|}
comment|// ### We bind modality to widgets, so we have to do this
end_comment
begin_comment
comment|// ###  "manually".
end_comment
begin_comment
comment|// DnD is modal - eat all other interactive events
end_comment
begin_ifndef
unit|switch (e->type()) {       case QEvent::MouseButtonPress:       case QEvent::MouseButtonRelease:       case QEvent::MouseButtonDblClick:       case QEvent::MouseMove:       case QEvent::KeyPress:       case QEvent::KeyRelease:       case QEvent::Wheel:       case QEvent::ShortcutOverride:         return true;       default:         return false;     } }  void QDragManager::updateCursor() {     if (!noDropCursor) {
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_endif
unit|noDropCursor = new QCursor(Qt::ForbiddenCursor);         moveCursor = new QCursor(Qt::DragMoveCursor);         copyCursor = new QCursor(Qt::DragCopyCursor);         linkCursor = new QCursor(Qt::DragLinkCursor);
endif|#
directive|endif
end_endif
begin_comment
unit|}      QCursor *c;     if (willDrop) {         if (global_accepted_action == Qt::CopyAction) {             c = copyCursor;         } else if (global_accepted_action == Qt::LinkAction) {             c = linkCursor;         } else {             c = moveCursor;         }         if (xdnd_data.deco) {             xdnd_data.deco->show();             xdnd_data.deco->raise();         }     } else {         c = noDropCursor;
comment|//if (qt_xdnd_deco)
end_comment
begin_comment
comment|//    qt_xdnd_deco->hide();
end_comment
begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_endif
unit|if (c)         qApp->changeOverrideCursor(*c);
endif|#
directive|endif
end_endif
begin_ifndef
unit|}   void QDragManager::cancel(bool deleteSource) {     DEBUG("QDragManager::cancel");     Q_ASSERT(heartbeat != -1);     killTimer(heartbeat);     heartbeat = -1;     beingCancelled = true;     qt_xdnd_dragging = false;      if (qt_xdnd_current_target)         qt_xdnd_send_leave();
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_endif
unit|if (restoreCursor) {         QApplication::restoreOverrideCursor();         restoreCursor = false;     }
endif|#
directive|endif
end_endif
begin_comment
unit|if (deleteSource&& object)         object->deleteLater();     object = 0;     qDeleteInEventHandler(xdnd_data.deco);     xdnd_data.deco = 0;      global_accepted_action = Qt::IgnoreAction; }  static Window findRealWindow(const QPoint& pos, Window w, int md) {     if (xdnd_data.deco&& w == xdnd_data.deco->effectiveWinId())         return 0;      if (md) {         X11->ignoreBadwindow();         XWindowAttributes attr;         XGetWindowAttributes(X11->display, w,&attr);         if (X11->badwindow())             return 0;          if (attr.map_state == IsViewable&& QRect(attr.x,attr.y,attr.width,attr.height).contains(pos)) {             {                 Atom   type = XNone;                 int f;                 unsigned long n, a;                 unsigned char *data;                  XGetWindowProperty(X11->display, w, ATOM(XdndAware), 0, 0, False,                                    AnyPropertyType,&type,&f,&n,&a,&data);                 if (data) XFree(data);                 if (type)                     return w;             }              Window r, p;             Window* c;             uint nc;             if (XQueryTree(X11->display, w,&r,&p,&c,&nc)) {                 r=0;                 for (uint i=nc; !r&& i--;) {                     r = findRealWindow(pos-QPoint(attr.x,attr.y),                                         c[i], md-1);                 }                 XFree(c);                 if (r)                     return r;
comment|// We didn't find a client window!  Just use the
end_comment
begin_comment
comment|// innermost window.
end_comment
begin_comment
unit|}
comment|// No children!
end_comment
begin_ifdef
unit|return w;         }     }     return 0; }  void QDragManager::move(const QPoint& globalPos) {
ifdef|#
directive|ifdef
name|QT_NO_CURSOR
end_ifdef
begin_else
unit|Q_UNUSED(globalPos);     return;
else|#
directive|else
end_else
begin_comment
unit|DEBUG()<< "QDragManager::move enter";     if (!object) {
comment|// perhaps the target crashed?
end_comment
begin_comment
unit|return;     }      int screen = QCursor::x11Screen();     if ((qt_xdnd_current_screen == -1&& screen != X11->defaultScreen) || (screen != qt_xdnd_current_screen)) {
comment|// recreate the pixmap on the new screen...
end_comment
begin_comment
unit|delete xdnd_data.deco;         QWidget* parent = object->source()->window()->x11Info().screen() == screen             ? object->source()->window() : QApplication::desktop()->screen(screen);         xdnd_data.deco = new QShapedPixmapWidget(parent);         if (!QWidget::mouseGrabber()) {             updatePixmap();             xdnd_data.deco->grabMouse();         }     }     xdnd_data.deco->move(QCursor::pos() - xdnd_data.deco->pm_hot);      if (source_sameanswer.contains(globalPos)&& source_sameanswer.isValid())         return;      qt_xdnd_current_screen = screen;     Window rootwin = QX11Info::appRootWindow(qt_xdnd_current_screen);     Window target = 0;     int lx = 0, ly = 0;     if (!XTranslateCoordinates(X11->display, rootwin, rootwin, globalPos.x(), globalPos.y(),&lx,&ly,&target))
comment|// some weird error...
end_comment
begin_comment
unit|return;      if (target == rootwin) {
comment|// Ok.
end_comment
begin_comment
unit|} else if (target) {
comment|//me
end_comment
begin_comment
unit|Window src = rootwin;         while (target != 0) {             DNDDEBUG<< "checking target for XdndAware"<< QWidget::find(target)<< target;             int lx2, ly2;             Window t;
comment|// translate coordinates
end_comment
begin_comment
unit|if (!XTranslateCoordinates(X11->display, src, target, lx, ly,&lx2,&ly2,&t)) {                 target = 0;                 break;             }             lx = lx2;             ly = ly2;             src = target;
comment|// check if it has XdndAware
end_comment
begin_comment
unit|Atom type = 0; 	    int f; 	    unsigned long n, a; 	    unsigned char *data = 0; 	    XGetWindowProperty(X11->display, target, ATOM(XdndAware), 0, 0, False,                                AnyPropertyType,&type,&f,&n,&a,&data); 	    if (data)                 XFree(data); 	    if (type) {                 DNDDEBUG<< "Found XdndAware on "<< QWidget::find(target)<< target;                 break;             }
comment|// find child at the coordinates
end_comment
begin_comment
unit|if (!XTranslateCoordinates(X11->display, src, src, lx, ly,&lx2,&ly2,&target)) {                 target = 0;                 break;             }         }         if (xdnd_data.deco&& (!target || target == xdnd_data.deco->effectiveWinId())) {             DNDDEBUG<< "need to find real window";             target = findRealWindow(globalPos, rootwin, 6);             DNDDEBUG<< "real window found"<< QWidget::find(target)<< target;         }     }      QWidget* w;     if (target) {         w = QWidget::find((WId)target);         if (w&& (w->windowType() == Qt::Desktop)&& !w->acceptDrops())             w = 0;     } else {         w = 0;         target = rootwin;     }      DNDDEBUG<< "and the final target is "<< QWidget::find(target)<< target;     DNDDEBUG<< "the widget w is"<< w;      WId proxy_target = xdndProxy(target);     if (!proxy_target)         proxy_target = target;     int target_version = 1;      if (proxy_target) {         Atom   type = XNone;         int r, f;         unsigned long n, a;         unsigned char *retval;         X11->ignoreBadwindow();         r = XGetWindowProperty(X11->display, proxy_target, ATOM(XdndAware), 0,                                1, False, AnyPropertyType,&type,&f,&n,&a,&retval);         int *tv = (int *)retval;         if (r != Success || X11->badwindow()) {             target = 0;         } else {             target_version = qMin(xdnd_version,tv ? *tv : 1);             if (tv)                 XFree(tv);
comment|//             if (!(!X11->badwindow()&& type))
end_comment
begin_comment
comment|//                 target = 0;
end_comment
begin_comment
unit|}     }      if (target != qt_xdnd_current_target) {         if (qt_xdnd_current_target)             qt_xdnd_send_leave();          qt_xdnd_current_target = target;         current_proxy_target = proxy_target;         if (target) {             QVector<Atom> types;             int flags = target_version<< 24;             QStringList fmts = QInternalMimeData::formatsHelper(dragPrivate()->data);             for (int i = 0; i< fmts.size(); ++i) {                 QList<Atom> atoms = X11->xdndMimeAtomsForFormat(fmts.at(i));                 for (int j = 0; j< atoms.size(); ++j) {                     if (!types.contains(atoms.at(j)))                         types.append(atoms.at(j));                 }             }             if (types.size()> 3) {                 XChangeProperty(X11->display,                                 dragPrivate()->source->effectiveWinId(), ATOM(XdndTypelist),                                 XA_ATOM, 32, PropModeReplace,                                 (unsigned char *)types.data(),                                 types.size());                 flags |= 0x0001;             }             XClientMessageEvent enter;             enter.type = ClientMessage;             enter.window = target;             enter.format = 32;             enter.message_type = ATOM(XdndEnter);             enter.data.l[0] = dragPrivate()->source->effectiveWinId();             enter.data.l[1] = flags;             enter.data.l[2] = types.size()>0 ? types.at(0) : 0;             enter.data.l[3] = types.size()>1 ? types.at(1) : 0;             enter.data.l[4] = types.size()>2 ? types.at(2) : 0;
comment|// provisionally set the rectangle to 5x5 pixels...
end_comment
begin_comment
unit|source_sameanswer = QRect(globalPos.x() - 2,                                               globalPos.y() -2 , 5, 5);              DEBUG("sending Xdnd enter");             if (w)                 X11->xdndHandleEnter(w, (const XEvent *)&enter, false);             else if (target)                 XSendEvent(X11->display, proxy_target, False, NoEventMask, (XEvent*)&enter);             waiting_for_status = false;         }     }     if (waiting_for_status)         return;      if (target) {         waiting_for_status = true;          XClientMessageEvent move;         move.type = ClientMessage;         move.window = target;         move.format = 32;         move.message_type = ATOM(XdndPosition);         move.window = target;         move.data.l[0] = dragPrivate()->source->effectiveWinId();         move.data.l[1] = 0;
comment|// flags
end_comment
begin_endif
unit|move.data.l[2] = (globalPos.x()<< 16) + globalPos.y();         move.data.l[3] = X11->time;         move.data.l[4] = qtaction_to_xdndaction(defaultAction(dragPrivate()->possible_actions, QApplication::keyboardModifiers()));         DEBUG("sending Xdnd position");          qt_xdnd_source_current_time = X11->time;          if (w)             handle_xdnd_position(w, (const XEvent *)&move, false);         else             XSendEvent(X11->display, proxy_target, False, NoEventMask,                        (XEvent*)&move);     } else {         if (willDrop) {             willDrop = false;             updateCursor();         }     }     DEBUG()<< "QDragManager::move leave";
endif|#
directive|endif
end_endif
begin_comment
unit|}   void QDragManager::drop() {     Q_ASSERT(heartbeat != -1);     killTimer(heartbeat);     heartbeat = -1;     qt_xdnd_dragging = false;      if (!qt_xdnd_current_target)         return;      qDeleteInEventHandler(xdnd_data.deco);     xdnd_data.deco = 0;      XClientMessageEvent drop;     drop.type = ClientMessage;     drop.window = qt_xdnd_current_target;     drop.format = 32;     drop.message_type = ATOM(XdndDrop);     drop.data.l[0] = dragPrivate()->source->effectiveWinId();     drop.data.l[1] = 0;
comment|// flags
end_comment
begin_ifndef
unit|drop.data.l[2] = X11->time;      drop.data.l[3] = 0;     drop.data.l[4] = 0;      QWidget * w = QWidget::find(current_proxy_target);      if (w&& (w->windowType() == Qt::Desktop)&& !w->acceptDrops())         w = 0;      QXdndDropTransaction t = {         X11->time,         qt_xdnd_current_target,         current_proxy_target,         w,         current_embedding_widget,         object     };     X11->dndDropTransactions.append(t);     restartXdndDropExpiryTimer();      if (w)         X11->xdndHandleDrop(w, (const XEvent *)&drop, false);     else         XSendEvent(X11->display, current_proxy_target, False,                    NoEventMask, (XEvent*)&drop);      qt_xdnd_current_target = 0;     current_proxy_target = 0;     qt_xdnd_source_current_time = 0;     current_embedding_widget = 0;     object = 0;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_endif
unit|if (restoreCursor) {         QApplication::restoreOverrideCursor();         restoreCursor = false;     }
endif|#
directive|endif
end_endif
begin_comment
unit|}    bool QX11Data::xdndHandleBadwindow() {     if (qt_xdnd_current_target) {         QDragManager *manager = QDragManager::self();         if (manager->object) {             qt_xdnd_current_target = 0;             current_proxy_target = 0;             manager->object->deleteLater();             manager->object = 0;             delete xdnd_data.deco;             xdnd_data.deco = 0;             return true;         }     }     if (xdnd_dragsource) {         xdnd_dragsource = 0;         if (currentWindow) {             QApplication::postEvent(currentWindow, new QDragLeaveEvent);             currentWindow = 0;         }         return true;     }     return false; }  void QX11Data::xdndHandleSelectionRequest(const XSelectionRequestEvent * req) {     if (!req)         return;     XEvent evt;     evt.xselection.type = SelectionNotify;     evt.xselection.display = req->display;     evt.xselection.requestor = req->requestor;     evt.xselection.selection = req->selection;     evt.xselection.target = XNone;     evt.xselection.property = XNone;     evt.xselection.time = req->time;      QDragManager *manager = QDragManager::self();     QDrag *currentObject = manager->object;
comment|// which transaction do we use? (note: -2 means use current manager->object)
end_comment
begin_comment
unit|int at = -1;
comment|// figure out which data the requestor is really interested in
end_comment
begin_comment
unit|if (manager->object&& req->time == qt_xdnd_source_current_time) {
comment|// requestor wants the current drag data
end_comment
begin_comment
unit|at = -2;     } else {
comment|// if someone has requested data in response to XdndDrop, find the corresponding transaction. the
end_comment
begin_comment
comment|// spec says to call XConvertSelection() using the timestamp from the XdndDrop
end_comment
begin_comment
unit|at = findXdndDropTransactionByTime(req->time);         if (at == -1) {
comment|// no dice, perhaps the client was nice enough to use the same window id in XConvertSelection()
end_comment
begin_comment
comment|// that we sent the XdndDrop event to.
end_comment
begin_comment
unit|at = findXdndDropTransactionByWindow(req->requestor);         }         if (at == -1&& req->time == CurrentTime) {
comment|// previous Qt versions always requested the data on a child of the target window
end_comment
begin_comment
comment|// using CurrentTime... but it could be asking for either drop data or the current drag's data
end_comment
begin_comment
unit|Window target = findXdndAwareParent(req->requestor);             if (target) {                 if (qt_xdnd_current_target&& qt_xdnd_current_target == target)                     at = -2;                 else                     at = findXdndDropTransactionByWindow(target);             }         }     }     if (at>= 0) {         restartXdndDropExpiryTimer();
comment|// use the drag object from an XdndDrop tansaction
end_comment
begin_comment
unit|manager->object = X11->dndDropTransactions.at(at).object;     } else if (at != -2) {
comment|// no transaction found, we'll have to reject the request
end_comment
begin_comment
unit|manager->object = 0;     }     if (manager->object) {         Atom atomFormat = req->target;         int dataFormat = 0;         QByteArray data;         if (X11->xdndMimeDataForAtom(req->target, manager->dragPrivate()->data,&data,&atomFormat,&dataFormat)) {             int dataSize = data.size() / (dataFormat / 8);             XChangeProperty (X11->display, req->requestor, req->property,                              atomFormat, dataFormat, PropModeReplace,                              (unsigned char *)data.data(), dataSize);             evt.xselection.property = req->property;             evt.xselection.target = atomFormat;         }     }
comment|// reset manager->object in case we modified it above
end_comment
begin_comment
unit|manager->object = currentObject;
comment|// ### this can die if req->requestor crashes at the wrong
end_comment
begin_comment
comment|// ### moment
end_comment
begin_comment
unit|XSendEvent(X11->display, req->requestor, False, 0,&evt); }
comment|/*   Enable drag and drop for widget w by installing the proper   properties on w's toplevel widget. */
end_comment
begin_comment
unit|bool QX11Data::dndEnable(QWidget* w, bool on) {     w = w->window();      if (bool(((QExtraWidget*)w)->topData()->dnd) == on)         return true;
comment|// been there, done that
end_comment
begin_comment
unit|((QExtraWidget*)w)->topData()->dnd = on ? 1 : 0;      motifdndEnable(w, on);     return xdndEnable(w, on); }  Qt::DropAction QDragManager::drag(QDrag * o) {     if (object == o || !o || !o->d_func()->source)         return Qt::IgnoreAction;      if (object) {         cancel();         qApp->removeEventFilter(this);         beingCancelled = false;     }      if (object) {
comment|// the last drag and drop operation hasn't finished, so we are going to wait
end_comment
begin_comment
comment|// for one second to see if it does... if the finish message comes after this,
end_comment
begin_comment
comment|// then we could still have problems, but this is highly unlikely
end_comment
begin_comment
unit|QApplication::flush();          QElapsedTimer timer;         timer.start();         do {             XEvent event;             if (XCheckTypedEvent(X11->display, ClientMessage,&event))                 qApp->x11ProcessEvent(&event);
comment|// sleep 50 ms, so we don't use up CPU cycles all the time.
end_comment
begin_ifndef
unit|struct timeval usleep_tv;             usleep_tv.tv_sec = 0;             usleep_tv.tv_usec = 50000;             select(0, 0, 0, 0,&usleep_tv);         } while (object&& timer.hasExpired(1000));     }      object = o;     object->d_func()->target = 0;     xdnd_data.deco = new QShapedPixmapWidget(object->source()->window());      willDrop = false;      updatePixmap();      qApp->installEventFilter(this);     XSetSelectionOwner(X11->display, ATOM(XdndSelection), dragPrivate()->source->window()->internalWinId(), X11->time);     global_accepted_action = Qt::CopyAction;     source_sameanswer = QRect();
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_comment
comment|// set the override cursor (must be done here, since it is updated
end_comment
begin_comment
comment|// in the call to move() below)
end_comment
begin_endif
unit|qApp->setOverrideCursor(Qt::ArrowCursor);     restoreCursor = true;
endif|#
directive|endif
end_endif
begin_ifndef
unit|move(QCursor::pos());     heartbeat = startTimer(200);      qt_xdnd_dragging = true;      if (!QWidget::mouseGrabber())         xdnd_data.deco->grabMouse();      eventLoop = new QEventLoop;     (void) eventLoop->exec();     delete eventLoop;     eventLoop = 0;
ifndef|#
directive|ifndef
name|QT_NO_CURSOR
end_ifndef
begin_endif
unit|if (restoreCursor) {         qApp->restoreOverrideCursor();         restoreCursor = false;     }
endif|#
directive|endif
end_endif
begin_comment
comment|// delete cursors as they may be different next drag.
end_comment
begin_comment
unit|delete noDropCursor;     noDropCursor = 0;     delete copyCursor;     copyCursor = 0;     delete moveCursor;     moveCursor = 0;     delete linkCursor;     linkCursor = 0;      delete xdnd_data.deco;     xdnd_data.deco = 0;     if (heartbeat != -1)         killTimer(heartbeat);     heartbeat = -1;     qt_xdnd_current_screen = -1;     qt_xdnd_dragging = false;      return global_accepted_action;
comment|// object persists until we get an xdnd_finish message
end_comment
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_function
DECL|function|xdndProxy
specifier|static
name|xcb_window_t
name|xdndProxy
parameter_list|(
name|QXcbConnection
modifier|*
name|c
parameter_list|,
name|xcb_window_t
name|w
parameter_list|)
block|{
name|xcb_window_t
name|proxy
init|=
name|XCB_NONE
decl_stmt|;
name|xcb_get_property_cookie_t
name|cookie
init|=
name|xcb_get_property
argument_list|(
name|c
operator|->
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|w
argument_list|,
name|c
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndProxy
argument_list|)
argument_list|,
name|QXcbAtom
operator|::
name|XA_WINDOW
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|xcb_get_property_reply_t
modifier|*
name|reply
init|=
name|xcb_get_property_reply
argument_list|(
name|c
operator|->
name|xcb_connection
argument_list|()
argument_list|,
name|cookie
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
operator|&&
name|reply
operator|->
name|type
operator|==
name|QXcbAtom
operator|::
name|XA_WINDOW
condition|)
name|proxy
operator|=
operator|*
operator|(
operator|(
name|xcb_window_t
operator|*
operator|)
name|xcb_get_property_value
argument_list|(
name|reply
argument_list|)
operator|)
expr_stmt|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
name|proxy
operator|==
name|XCB_NONE
condition|)
return|return
name|proxy
return|;
comment|// exists and is real?
name|cookie
operator|=
name|xcb_get_property
argument_list|(
name|c
operator|->
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|proxy
argument_list|,
name|c
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndProxy
argument_list|)
argument_list|,
name|QXcbAtom
operator|::
name|XA_WINDOW
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reply
operator|=
name|xcb_get_property_reply
argument_list|(
name|c
operator|->
name|xcb_connection
argument_list|()
argument_list|,
name|cookie
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
operator|&&
name|reply
operator|->
name|type
operator|==
name|QXcbAtom
operator|::
name|XA_WINDOW
condition|)
block|{
name|xcb_window_t
name|p
init|=
operator|*
operator|(
operator|(
name|xcb_window_t
operator|*
operator|)
name|xcb_get_property_value
argument_list|(
name|reply
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|proxy
operator|!=
name|p
condition|)
name|proxy
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|proxy
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|proxy
return|;
block|}
end_function
begin_function
DECL|function|dndEnable
name|bool
name|QXcbDrag
operator|::
name|dndEnable
parameter_list|(
name|QXcbWindow
modifier|*
name|w
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
name|DNDDEBUG
operator|<<
literal|"xdndEnable"
operator|<<
name|w
operator|<<
name|on
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
name|QXcbWindow
modifier|*
name|xdnd_widget
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|w
operator|->
name|window
argument_list|()
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
block|{
if|if
condition|(
name|desktop_proxy
condition|)
comment|// *WE* already have one.
return|return
literal|false
return|;
name|xcb_grab_server
argument_list|(
name|connection
argument_list|()
operator|->
name|xcb_connection
argument_list|()
argument_list|)
expr_stmt|;
comment|// As per Xdnd4, use XdndProxy
name|xcb_window_t
name|proxy_id
init|=
name|xdndProxy
argument_list|(
name|connection
argument_list|()
argument_list|,
name|w
operator|->
name|xcb_window
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|proxy_id
condition|)
block|{
name|desktop_proxy
operator|=
operator|new
name|QWindow
expr_stmt|;
name|xdnd_widget
operator|=
cast|static_cast
argument_list|<
name|QXcbWindow
operator|*
argument_list|>
argument_list|(
name|desktop_proxy
operator|->
name|handle
argument_list|()
argument_list|)
expr_stmt|;
name|proxy_id
operator|=
name|xdnd_widget
operator|->
name|xcb_window
argument_list|()
expr_stmt|;
name|xcb_atom_t
name|xdnd_proxy
init|=
name|connection
argument_list|()
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndProxy
argument_list|)
decl_stmt|;
name|xcb_change_property
argument_list|(
name|connection
argument_list|()
operator|->
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|w
operator|->
name|xcb_window
argument_list|()
argument_list|,
name|xdnd_proxy
argument_list|,
name|QXcbAtom
operator|::
name|XA_WINDOW
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|,
operator|&
name|proxy_id
argument_list|)
expr_stmt|;
name|xcb_change_property
argument_list|(
name|connection
argument_list|()
operator|->
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|proxy_id
argument_list|,
name|xdnd_proxy
argument_list|,
name|QXcbAtom
operator|::
name|XA_WINDOW
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|,
operator|&
name|proxy_id
argument_list|)
expr_stmt|;
block|}
name|xcb_ungrab_server
argument_list|(
name|connection
argument_list|()
operator|->
name|xcb_connection
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xdnd_widget
operator|=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|xdnd_widget
condition|)
block|{
name|DNDDEBUG
operator|<<
literal|"setting XdndAware for"
operator|<<
name|xdnd_widget
operator|<<
name|xdnd_widget
operator|->
name|xcb_window
argument_list|()
expr_stmt|;
name|xcb_atom_t
name|atm
init|=
name|xdnd_version
decl_stmt|;
name|xcb_change_property
argument_list|(
name|connection
argument_list|()
operator|->
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|xdnd_widget
operator|->
name|xcb_window
argument_list|()
argument_list|,
name|connection
argument_list|()
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndAware
argument_list|)
argument_list|,
name|QXcbAtom
operator|::
name|XA_ATOM
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|,
operator|&
name|atm
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|w
operator|->
name|window
argument_list|()
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
block|{
name|xcb_delete_property
argument_list|(
name|connection
argument_list|()
operator|->
name|xcb_connection
argument_list|()
argument_list|,
name|w
operator|->
name|xcb_window
argument_list|()
argument_list|,
name|connection
argument_list|()
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndProxy
argument_list|)
argument_list|)
expr_stmt|;
operator|delete
name|desktop_proxy
expr_stmt|;
name|desktop_proxy
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|DNDDEBUG
operator|<<
literal|"not deleting XDndAware"
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_function
begin_constructor
DECL|function|QDropData
name|QDropData
operator|::
name|QDropData
parameter_list|(
name|QXcbDrag
modifier|*
name|d
parameter_list|)
member_init_list|:
name|QXcbMime
argument_list|()
member_init_list|,
name|drag
argument_list|(
name|d
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QDropData
name|QDropData
operator|::
name|~
name|QDropData
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|retrieveData_sys
name|QVariant
name|QDropData
operator|::
name|retrieveData_sys
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimetype
parameter_list|,
name|QVariant
operator|::
name|Type
name|requestedType
parameter_list|)
specifier|const
block|{
name|QByteArray
name|mime
init|=
name|mimetype
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
name|QVariant
name|data
init|=
comment|/*X11->motifdnd_active                       ? X11->motifdndObtainData(mime)                       :*/
name|xdndObtainData
argument_list|(
name|mime
argument_list|,
name|requestedType
argument_list|)
decl_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_function
DECL|function|xdndObtainData
name|QVariant
name|QDropData
operator|::
name|xdndObtainData
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|format
parameter_list|,
name|QVariant
operator|::
name|Type
name|requestedType
parameter_list|)
specifier|const
block|{
name|QByteArray
name|result
decl_stmt|;
name|QDragManager
modifier|*
name|manager
init|=
name|QDragManager
operator|::
name|self
argument_list|()
decl_stmt|;
name|QXcbConnection
modifier|*
name|c
init|=
name|drag
operator|->
name|connection
argument_list|()
decl_stmt|;
name|QXcbWindow
modifier|*
name|xcb_window
init|=
name|c
operator|->
name|platformWindowFromId
argument_list|(
name|drag
operator|->
name|xdnd_dragsource
argument_list|)
decl_stmt|;
if|if
condition|(
name|xcb_window
operator|&&
name|manager
operator|->
name|object
operator|&&
name|xcb_window
operator|->
name|window
argument_list|()
operator|->
name|windowType
argument_list|()
operator|!=
name|Qt
operator|::
name|Desktop
condition|)
block|{
name|QDragPrivate
modifier|*
name|o
init|=
name|manager
operator|->
name|dragPrivate
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|data
operator|->
name|hasFormat
argument_list|(
name|QLatin1String
argument_list|(
name|format
argument_list|)
argument_list|)
condition|)
name|result
operator|=
name|o
operator|->
name|data
operator|->
name|data
argument_list|(
name|QLatin1String
argument_list|(
name|format
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|QList
argument_list|<
name|xcb_atom_t
argument_list|>
name|atoms
init|=
name|drag
operator|->
name|xdnd_types
decl_stmt|;
name|QByteArray
name|encoding
decl_stmt|;
name|xcb_atom_t
name|a
init|=
name|mimeAtomForFormat
argument_list|(
name|c
argument_list|,
name|QLatin1String
argument_list|(
name|format
argument_list|)
argument_list|,
name|requestedType
argument_list|,
name|atoms
argument_list|,
operator|&
name|encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|==
name|XCB_NONE
condition|)
return|return
name|result
return|;
if|if
condition|(
name|c
operator|->
name|clipboard
argument_list|()
operator|->
name|getSelectionOwner
argument_list|(
name|drag
operator|->
name|connection
argument_list|()
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndSelection
argument_list|)
argument_list|)
operator|==
name|XCB_NONE
condition|)
return|return
name|result
return|;
comment|// should never happen?
name|QWindow
modifier|*
name|tw
init|=
name|drag
operator|->
name|currentWindow
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|drag
operator|->
name|currentWindow
operator|||
operator|(
name|drag
operator|->
name|currentWindow
operator|.
name|data
argument_list|()
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
name|tw
operator|=
operator|new
name|QWindow
expr_stmt|;
name|xcb_window_t
name|win
init|=
operator|::
name|xcb_window
argument_list|(
name|tw
argument_list|)
decl_stmt|;
name|xcb_atom_t
name|xdnd_selection
init|=
name|c
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|XdndSelection
argument_list|)
decl_stmt|;
name|result
operator|=
name|c
operator|->
name|clipboard
argument_list|()
operator|->
name|getSelection
argument_list|(
name|win
argument_list|,
name|xdnd_selection
argument_list|,
name|a
argument_list|,
name|xdnd_selection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drag
operator|->
name|currentWindow
operator|||
operator|(
name|drag
operator|->
name|currentWindow
operator|.
name|data
argument_list|()
operator|->
name|windowType
argument_list|()
operator|==
name|Qt
operator|::
name|Desktop
operator|)
condition|)
operator|delete
name|tw
expr_stmt|;
return|return
name|mimeConvertToFormat
argument_list|(
name|c
argument_list|,
name|a
argument_list|,
name|result
argument_list|,
name|QLatin1String
argument_list|(
name|format
argument_list|)
argument_list|,
name|requestedType
argument_list|,
name|encoding
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|hasFormat_sys
name|bool
name|QDropData
operator|::
name|hasFormat_sys
parameter_list|(
specifier|const
name|QString
modifier|&
name|format
parameter_list|)
specifier|const
block|{
return|return
name|formats
argument_list|()
operator|.
name|contains
argument_list|(
name|format
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|formats_sys
name|QStringList
name|QDropData
operator|::
name|formats_sys
parameter_list|()
specifier|const
block|{
name|QStringList
name|formats
decl_stmt|;
comment|//    if (X11->motifdnd_active) {
comment|//        int i = 0;
comment|//        QByteArray fmt;
comment|//        while (!(fmt = X11->motifdndFormat(i)).isEmpty()) {
comment|//            formats.append(QLatin1String(fmt));
comment|//            ++i;
comment|//        }
comment|//    } else {
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|drag
operator|->
name|xdnd_types
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QString
name|f
init|=
name|mimeAtomToString
argument_list|(
name|drag
operator|->
name|connection
argument_list|()
argument_list|,
name|drag
operator|->
name|xdnd_types
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|formats
operator|.
name|contains
argument_list|(
name|f
argument_list|)
condition|)
name|formats
operator|.
name|append
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|//    }
return|return
name|formats
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
