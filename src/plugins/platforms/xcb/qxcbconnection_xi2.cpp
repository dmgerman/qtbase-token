begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qxcbconnection.h"
end_include
begin_include
include|#
directive|include
file|"qxcbwindow.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qwindowsysteminterface.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT2
end_ifdef
begin_include
include|#
directive|include
file|<X11/extensions/XInput2.h>
end_include
begin_include
include|#
directive|include
file|<X11/extensions/XI2proto.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
end_ifndef
begin_function
DECL|function|q_xi2_is_tablet
specifier|static
specifier|inline
name|bool
name|q_xi2_is_tablet
parameter_list|(
name|XIDeviceInfo
modifier|*
name|dev
parameter_list|)
block|{
name|QByteArray
name|name
argument_list|(
name|dev
operator|->
name|name
argument_list|)
decl_stmt|;
name|name
operator|=
name|name
operator|.
name|toLower
argument_list|()
expr_stmt|;
comment|// Cannot just check for "wacom" because that would also pick up the touch and tablet-button devices.
return|return
name|name
operator|.
name|contains
argument_list|(
literal|"stylus"
argument_list|)
operator|||
name|name
operator|.
name|contains
argument_list|(
literal|"eraser"
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TABLETEVENT
end_comment
begin_function
DECL|function|initializeXInput2
name|void
name|QXcbConnection
operator|::
name|initializeXInput2
parameter_list|()
block|{
name|Display
modifier|*
name|xDisplay
init|=
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
decl_stmt|;
if|if
condition|(
name|XQueryExtension
argument_list|(
name|xDisplay
argument_list|,
literal|"XInputExtension"
argument_list|,
operator|&
name|m_xiOpCode
argument_list|,
operator|&
name|m_xiEventBase
argument_list|,
operator|&
name|m_xiErrorBase
argument_list|)
condition|)
block|{
name|int
name|xiMajor
init|=
literal|2
decl_stmt|;
name|m_xi2Minor
operator|=
literal|2
expr_stmt|;
comment|// try 2.2 first, needed for TouchBegin/Update/End
if|if
condition|(
name|XIQueryVersion
argument_list|(
name|xDisplay
argument_list|,
operator|&
name|xiMajor
argument_list|,
operator|&
name|m_xi2Minor
argument_list|)
operator|==
name|BadRequest
condition|)
block|{
name|m_xi2Minor
operator|=
literal|0
expr_stmt|;
comment|// for tablet support 2.0 is enough
name|m_xi2Enabled
operator|=
name|XIQueryVersion
argument_list|(
name|xDisplay
argument_list|,
operator|&
name|xiMajor
argument_list|,
operator|&
name|m_xi2Minor
argument_list|)
operator|!=
name|BadRequest
expr_stmt|;
block|}
else|else
block|{
name|m_xi2Enabled
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|m_xi2Enabled
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
comment|// Tablet support: Figure out the stylus-related devices. We will
comment|// only select events on this device. Press, motion, etc. events
comment|// must never be selected for _all_ devices as that would render
comment|// the standard XCB_MOTION_NOTIFY and similar handlers useless and
comment|// we have no intention to infect all the pure xcb code with
comment|// Xlib-based XI2.
name|xi2SetupTabletDevices
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
block|}
block|}
block|}
end_function
begin_function
DECL|function|finalizeXInput2
name|void
name|QXcbConnection
operator|::
name|finalizeXInput2
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|xi2Select
name|void
name|QXcbConnection
operator|::
name|xi2Select
parameter_list|(
name|xcb_window_t
name|window
parameter_list|)
block|{
if|if
condition|(
operator|!
name|m_xi2Enabled
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
comment|// Tablets.
if|if
condition|(
operator|!
name|m_tabletData
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Display
modifier|*
name|xDisplay
init|=
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
decl_stmt|;
name|QVector
argument_list|<
name|XIEventMask
argument_list|>
name|xiEventMask
argument_list|(
name|m_tabletData
operator|.
name|count
argument_list|()
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bitMask
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|xiBitMask
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|bitMask
argument_list|)
decl_stmt|;
name|bitMask
operator||=
name|XI_ButtonPressMask
expr_stmt|;
name|bitMask
operator||=
name|XI_ButtonReleaseMask
expr_stmt|;
name|bitMask
operator||=
name|XI_MotionMask
expr_stmt|;
name|bitMask
operator||=
name|XI_PropertyEventMask
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_tabletData
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|xiEventMask
index|[
name|i
index|]
operator|.
name|deviceid
operator|=
name|m_tabletData
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|deviceId
expr_stmt|;
name|xiEventMask
index|[
name|i
index|]
operator|.
name|mask_len
operator|=
sizeof|sizeof
argument_list|(
name|bitMask
argument_list|)
expr_stmt|;
name|xiEventMask
index|[
name|i
index|]
operator|.
name|mask
operator|=
name|xiBitMask
expr_stmt|;
block|}
name|XISelectEvents
argument_list|(
name|xDisplay
argument_list|,
name|window
argument_list|,
name|xiEventMask
operator|.
name|data
argument_list|()
argument_list|,
name|m_tabletData
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
block|}
end_function
begin_function
DECL|function|xi2HandleEvent
name|void
name|QXcbConnection
operator|::
name|xi2HandleEvent
parameter_list|(
name|xcb_ge_event_t
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|xi2PrepareXIGenericDeviceEvent
argument_list|(
name|event
argument_list|,
name|m_xiOpCode
argument_list|)
condition|)
block|{
name|xXIGenericDeviceEvent
modifier|*
name|xiEvent
init|=
cast|reinterpret_cast
argument_list|<
name|xXIGenericDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_tabletData
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|m_tabletData
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|deviceId
operator|==
name|xiEvent
operator|->
name|deviceid
condition|)
block|{
name|xi2HandleTabletEvent
argument_list|(
name|xiEvent
argument_list|,
operator|&
name|m_tabletData
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
end_ifndef
begin_function
DECL|function|xi2QueryTabletData
name|void
name|QXcbConnection
operator|::
name|xi2QueryTabletData
parameter_list|(
name|void
modifier|*
name|dev
parameter_list|,
name|TabletData
modifier|*
name|tabletData
parameter_list|)
block|{
name|XIDeviceInfo
modifier|*
name|device
init|=
cast|static_cast
argument_list|<
name|XIDeviceInfo
operator|*
argument_list|>
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|tabletData
operator|->
name|deviceId
operator|=
name|device
operator|->
name|deviceid
expr_stmt|;
name|tabletData
operator|->
name|pointerType
operator|=
name|QTabletEvent
operator|::
name|Pen
expr_stmt|;
if|if
condition|(
name|QByteArray
argument_list|(
name|device
operator|->
name|name
argument_list|)
operator|.
name|toLower
argument_list|()
operator|.
name|contains
argument_list|(
literal|"eraser"
argument_list|)
condition|)
name|tabletData
operator|->
name|pointerType
operator|=
name|QTabletEvent
operator|::
name|Eraser
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|device
operator|->
name|num_classes
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|device
operator|->
name|classes
index|[
name|i
index|]
operator|->
name|type
condition|)
block|{
case|case
name|XIValuatorClass
case|:
block|{
name|XIValuatorClassInfo
modifier|*
name|vci
init|=
cast|reinterpret_cast
argument_list|<
name|XIValuatorClassInfo
operator|*
argument_list|>
argument_list|(
name|device
operator|->
name|classes
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsX
argument_list|)
condition|)
name|val
operator|=
name|QXcbAtom
operator|::
name|AbsX
expr_stmt|;
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsY
argument_list|)
condition|)
name|val
operator|=
name|QXcbAtom
operator|::
name|AbsY
expr_stmt|;
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsPressure
argument_list|)
condition|)
name|val
operator|=
name|QXcbAtom
operator|::
name|AbsPressure
expr_stmt|;
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsTiltX
argument_list|)
condition|)
name|val
operator|=
name|QXcbAtom
operator|::
name|AbsTiltX
expr_stmt|;
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsTiltY
argument_list|)
condition|)
name|val
operator|=
name|QXcbAtom
operator|::
name|AbsTiltY
expr_stmt|;
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsWheel
argument_list|)
condition|)
name|val
operator|=
name|QXcbAtom
operator|::
name|AbsWheel
expr_stmt|;
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsDistance
argument_list|)
condition|)
name|val
operator|=
name|QXcbAtom
operator|::
name|AbsDistance
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|TabletData
operator|::
name|ValuatorClassInfo
name|info
decl_stmt|;
name|info
operator|.
name|minVal
operator|=
name|vci
operator|->
name|min
expr_stmt|;
name|info
operator|.
name|maxVal
operator|=
name|vci
operator|->
name|max
expr_stmt|;
name|info
operator|.
name|number
operator|=
name|vci
operator|->
name|number
expr_stmt|;
name|tabletData
operator|->
name|valuatorInfo
index|[
name|val
index|]
operator|=
name|info
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function
begin_function
DECL|function|xi2SetupTabletDevices
name|void
name|QXcbConnection
operator|::
name|xi2SetupTabletDevices
parameter_list|()
block|{
name|Display
modifier|*
name|xDisplay
init|=
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
decl_stmt|;
name|m_tabletData
operator|.
name|clear
argument_list|()
expr_stmt|;
name|int
name|deviceCount
init|=
literal|0
decl_stmt|;
name|XIDeviceInfo
modifier|*
name|devices
init|=
name|XIQueryDevice
argument_list|(
name|xDisplay
argument_list|,
name|XIAllDevices
argument_list|,
operator|&
name|deviceCount
argument_list|)
decl_stmt|;
if|if
condition|(
name|devices
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deviceCount
condition|;
operator|++
name|i
control|)
block|{
name|int
name|unused
init|=
literal|0
decl_stmt|;
name|XIDeviceInfo
modifier|*
name|dev
init|=
name|XIQueryDevice
argument_list|(
name|xDisplay
argument_list|,
name|devices
index|[
name|i
index|]
operator|.
name|deviceid
argument_list|,
operator|&
name|unused
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
if|if
condition|(
name|q_xi2_is_tablet
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|TabletData
name|tabletData
decl_stmt|;
name|xi2QueryTabletData
argument_list|(
name|dev
argument_list|,
operator|&
name|tabletData
argument_list|)
expr_stmt|;
name|m_tabletData
operator|.
name|append
argument_list|(
name|tabletData
argument_list|)
expr_stmt|;
block|}
name|XIFreeDeviceInfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
name|XIFreeDeviceInfo
argument_list|(
name|devices
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|xi2HandleTabletEvent
name|void
name|QXcbConnection
operator|::
name|xi2HandleTabletEvent
parameter_list|(
name|void
modifier|*
name|event
parameter_list|,
name|TabletData
modifier|*
name|tabletData
parameter_list|)
block|{
name|Display
modifier|*
name|xDisplay
init|=
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
decl_stmt|;
name|xXIGenericDeviceEvent
modifier|*
name|xiEvent
init|=
cast|static_cast
argument_list|<
name|xXIGenericDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|xiEvent
operator|->
name|evtype
condition|)
block|{
case|case
name|XI_ButtonPress
case|:
comment|// stylus down
if|if
condition|(
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|detail
operator|==
literal|1
condition|)
block|{
comment|// ignore the physical buttons on the stylus
name|tabletData
operator|->
name|down
operator|=
literal|true
expr_stmt|;
name|xi2ReportTabletEvent
argument_list|(
operator|*
name|tabletData
argument_list|,
name|xiEvent
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XI_ButtonRelease
case|:
comment|// stylus up
if|if
condition|(
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|detail
operator|==
literal|1
condition|)
block|{
name|tabletData
operator|->
name|down
operator|=
literal|false
expr_stmt|;
name|xi2ReportTabletEvent
argument_list|(
operator|*
name|tabletData
argument_list|,
name|xiEvent
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XI_Motion
case|:
comment|// Report TabletMove only when the stylus is touching the tablet.
comment|// No possiblity to report proximity motion (no suitable Qt event exists yet).
if|if
condition|(
name|tabletData
operator|->
name|down
condition|)
name|xi2ReportTabletEvent
argument_list|(
operator|*
name|tabletData
argument_list|,
name|xiEvent
argument_list|)
expr_stmt|;
break|break;
case|case
name|XI_PropertyEvent
case|:
block|{
name|xXIPropertyEvent
modifier|*
name|ev
init|=
cast|reinterpret_cast
argument_list|<
name|xXIPropertyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|ev
operator|->
name|what
operator|==
name|XIPropertyModified
condition|)
block|{
if|if
condition|(
name|ev
operator|->
name|property
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|WacomSerialIDs
argument_list|)
condition|)
block|{
name|Atom
name|propType
decl_stmt|;
name|int
name|propFormat
decl_stmt|;
name|unsigned
name|long
name|numItems
decl_stmt|,
name|bytesAfter
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|XIGetProperty
argument_list|(
name|xDisplay
argument_list|,
name|tabletData
operator|->
name|deviceId
argument_list|,
name|ev
operator|->
name|property
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
literal|0
argument_list|,
name|AnyPropertyType
argument_list|,
operator|&
name|propType
argument_list|,
operator|&
name|propFormat
argument_list|,
operator|&
name|numItems
argument_list|,
operator|&
name|bytesAfter
argument_list|,
operator|&
name|data
argument_list|)
operator|==
name|Success
condition|)
block|{
if|if
condition|(
name|propType
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|INTEGER
argument_list|)
operator|&&
name|propFormat
operator|==
literal|32
condition|)
block|{
name|int
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numItems
condition|;
operator|++
name|i
control|)
name|tabletData
operator|->
name|serialId
operator||=
name|qint64
argument_list|(
name|ptr
index|[
name|i
index|]
argument_list|)
operator|<<
operator|(
name|i
operator|*
literal|32
operator|)
expr_stmt|;
block|}
name|XFree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
comment|// With recent-enough X drivers this property change event seems to come always
comment|// when entering and leaving proximity. Due to the lack of other options hook up
comment|// the enter/leave events to it.
if|if
condition|(
name|tabletData
operator|->
name|inProximity
condition|)
block|{
name|tabletData
operator|->
name|inProximity
operator|=
literal|false
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleTabletLeaveProximityEvent
argument_list|(
name|QTabletEvent
operator|::
name|Stylus
argument_list|,
name|tabletData
operator|->
name|pointerType
argument_list|,
name|tabletData
operator|->
name|serialId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tabletData
operator|->
name|inProximity
operator|=
literal|true
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleTabletEnterProximityEvent
argument_list|(
name|QTabletEvent
operator|::
name|Stylus
argument_list|,
name|tabletData
operator|->
name|pointerType
argument_list|,
name|tabletData
operator|->
name|serialId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function
begin_function
DECL|function|xi2ReportTabletEvent
name|void
name|QXcbConnection
operator|::
name|xi2ReportTabletEvent
parameter_list|(
specifier|const
name|TabletData
modifier|&
name|tabletData
parameter_list|,
name|void
modifier|*
name|event
parameter_list|)
block|{
name|xXIDeviceEvent
modifier|*
name|ev
init|=
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|QXcbWindow
modifier|*
name|xcbWindow
init|=
name|platformWindowFromId
argument_list|(
name|ev
operator|->
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xcbWindow
condition|)
return|return;
name|QWindow
modifier|*
name|window
init|=
name|xcbWindow
operator|->
name|window
argument_list|()
decl_stmt|;
specifier|const
name|double
name|scale
init|=
literal|65536.0
decl_stmt|;
name|QPointF
name|local
argument_list|(
name|ev
operator|->
name|event_x
operator|/
name|scale
argument_list|,
name|ev
operator|->
name|event_y
operator|/
name|scale
argument_list|)
decl_stmt|;
name|QPointF
name|global
argument_list|(
name|ev
operator|->
name|root_x
operator|/
name|scale
argument_list|,
name|ev
operator|->
name|root_y
operator|/
name|scale
argument_list|)
decl_stmt|;
name|double
name|pressure
init|=
literal|0
decl_stmt|,
name|rotation
init|=
literal|0
decl_stmt|;
name|int
name|xTilt
init|=
literal|0
decl_stmt|,
name|yTilt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|QHash
argument_list|<
name|int
argument_list|,
name|TabletData
operator|::
name|ValuatorClassInfo
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|tabletData
operator|.
name|valuatorInfo
operator|.
name|constBegin
argument_list|()
init|,
name|ite
init|=
name|tabletData
operator|.
name|valuatorInfo
operator|.
name|constEnd
argument_list|()
init|;
name|it
operator|!=
name|ite
condition|;
operator|++
name|it
control|)
block|{
name|int
name|valuator
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
specifier|const
name|TabletData
operator|::
name|ValuatorClassInfo
modifier|&
name|classInfo
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
name|double
name|value
decl_stmt|;
if|if
condition|(
name|xi2GetValuatorValueIfSet
argument_list|(
name|event
argument_list|,
name|classInfo
operator|.
name|number
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|double
name|normalizedValue
init|=
operator|(
name|value
operator|-
name|classInfo
operator|.
name|minVal
operator|)
operator|/
name|double
argument_list|(
name|classInfo
operator|.
name|maxVal
operator|-
name|classInfo
operator|.
name|minVal
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|valuator
condition|)
block|{
case|case
name|QXcbAtom
operator|::
name|AbsPressure
case|:
name|pressure
operator|=
name|normalizedValue
expr_stmt|;
break|break;
case|case
name|QXcbAtom
operator|::
name|AbsTiltX
case|:
name|xTilt
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|QXcbAtom
operator|::
name|AbsTiltY
case|:
name|yTilt
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|QXcbAtom
operator|::
name|AbsWheel
case|:
name|rotation
operator|=
name|value
operator|/
literal|64.0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|QWindowSystemInterface
operator|::
name|handleTabletEvent
argument_list|(
name|window
argument_list|,
name|tabletData
operator|.
name|down
argument_list|,
name|local
argument_list|,
name|global
argument_list|,
name|QTabletEvent
operator|::
name|Stylus
argument_list|,
name|tabletData
operator|.
name|pointerType
argument_list|,
name|pressure
argument_list|,
name|xTilt
argument_list|,
name|yTilt
argument_list|,
literal|0
argument_list|,
name|rotation
argument_list|,
literal|0
argument_list|,
name|tabletData
operator|.
name|serialId
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TABLETEVENT
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// XCB_USE_XINPUT2
end_comment
end_unit
