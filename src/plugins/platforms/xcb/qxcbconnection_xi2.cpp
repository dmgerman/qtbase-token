begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qxcbconnection.h"
end_include
begin_include
include|#
directive|include
file|"qxcbscreen.h"
end_include
begin_include
include|#
directive|include
file|"qxcbwindow.h"
end_include
begin_include
include|#
directive|include
file|"qtouchdevice.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qwindowsysteminterface.h>
end_include
begin_comment
comment|//#define XI2_DEBUG
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|XI2_DEBUG
end_ifdef
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT2
end_ifdef
begin_include
include|#
directive|include
file|<X11/extensions/XInput2.h>
end_include
begin_include
include|#
directive|include
file|<X11/extensions/XI2proto.h>
end_include
begin_define
DECL|macro|FINGER_MAX_WIDTH_MM
define|#
directive|define
name|FINGER_MAX_WIDTH_MM
value|10
end_define
begin_struct
DECL|struct|XInput2DeviceData
struct|struct
name|XInput2DeviceData
block|{
DECL|function|XInput2DeviceData
name|XInput2DeviceData
parameter_list|()
member_init_list|:
name|xiDeviceInfo
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|qtTouchDevice
argument_list|(
literal|0
argument_list|)
block|{     }
DECL|member|xiDeviceInfo
name|XIDeviceInfo
modifier|*
name|xiDeviceInfo
decl_stmt|;
DECL|member|qtTouchDevice
name|QTouchDevice
modifier|*
name|qtTouchDevice
decl_stmt|;
comment|// Stuff that is relevant only for touchpads
DECL|member|pointPressedPosition
name|QHash
argument_list|<
name|int
argument_list|,
name|QPointF
argument_list|>
name|pointPressedPosition
decl_stmt|;
comment|// in screen coordinates where each point was pressed
DECL|member|firstPressedPosition
name|QPointF
name|firstPressedPosition
decl_stmt|;
comment|// in screen coordinates where the first point was pressed
DECL|member|firstPressedNormalPosition
name|QPointF
name|firstPressedNormalPosition
decl_stmt|;
comment|// device coordinates (0 to 1, 0 to 1) where the first point was pressed
DECL|member|size
name|QSizeF
name|size
decl_stmt|;
comment|// device size in mm
block|}
struct|;
end_struct
begin_function
DECL|function|initializeXInput2
name|void
name|QXcbConnection
operator|::
name|initializeXInput2
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
name|m_tabletData
operator|.
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|Display
modifier|*
name|xDisplay
init|=
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
decl_stmt|;
if|if
condition|(
name|XQueryExtension
argument_list|(
name|xDisplay
argument_list|,
literal|"XInputExtension"
argument_list|,
operator|&
name|m_xiOpCode
argument_list|,
operator|&
name|m_xiEventBase
argument_list|,
operator|&
name|m_xiErrorBase
argument_list|)
condition|)
block|{
name|int
name|xiMajor
init|=
literal|2
decl_stmt|;
name|m_xi2Minor
operator|=
literal|2
expr_stmt|;
comment|// try 2.2 first, needed for TouchBegin/Update/End
if|if
condition|(
name|XIQueryVersion
argument_list|(
name|xDisplay
argument_list|,
operator|&
name|xiMajor
argument_list|,
operator|&
name|m_xi2Minor
argument_list|)
operator|==
name|BadRequest
condition|)
block|{
name|m_xi2Minor
operator|=
literal|0
expr_stmt|;
comment|// for tablet support 2.0 is enough
name|m_xi2Enabled
operator|=
name|XIQueryVersion
argument_list|(
name|xDisplay
argument_list|,
operator|&
name|xiMajor
argument_list|,
operator|&
name|m_xi2Minor
argument_list|)
operator|!=
name|BadRequest
expr_stmt|;
block|}
else|else
block|{
name|m_xi2Enabled
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|m_xi2Enabled
condition|)
block|{
ifdef|#
directive|ifdef
name|XI2_DEBUG
name|qDebug
argument_list|(
literal|"XInput version %d.%d is supported"
argument_list|,
name|xiMajor
argument_list|,
name|m_xi2Minor
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|deviceCount
init|=
literal|0
decl_stmt|;
name|XIDeviceInfo
modifier|*
name|devices
init|=
name|XIQueryDevice
argument_list|(
name|xDisplay
argument_list|,
name|XIAllDevices
argument_list|,
operator|&
name|deviceCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deviceCount
condition|;
operator|++
name|i
control|)
block|{
comment|// Only non-master pointing devices are relevant here.
if|if
condition|(
name|devices
index|[
name|i
index|]
operator|.
name|use
operator|!=
name|XISlavePointer
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|XI2_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"input device "
operator|<<
name|devices
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
name|TabletData
name|tabletData
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|devices
index|[
name|i
index|]
operator|.
name|num_classes
condition|;
operator|++
name|c
control|)
block|{
switch|switch
condition|(
name|devices
index|[
name|i
index|]
operator|.
name|classes
index|[
name|c
index|]
operator|->
name|type
condition|)
block|{
case|case
name|XIValuatorClass
case|:
block|{
name|XIValuatorClassInfo
modifier|*
name|vci
init|=
cast|reinterpret_cast
argument_list|<
name|XIValuatorClassInfo
operator|*
argument_list|>
argument_list|(
name|devices
index|[
name|i
index|]
operator|.
name|classes
index|[
name|c
index|]
argument_list|)
decl_stmt|;
specifier|const
name|int
name|valuatorAtom
init|=
name|qatom
argument_list|(
name|vci
operator|->
name|label
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|XI2_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"   has valuator"
operator|<<
name|atomName
argument_list|(
name|vci
operator|->
name|label
argument_list|)
operator|<<
literal|"recognized?"
operator|<<
operator|(
name|valuatorAtom
operator|<
name|QXcbAtom
operator|::
name|NAtoms
operator|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
if|if
condition|(
name|valuatorAtom
operator|<
name|QXcbAtom
operator|::
name|NAtoms
condition|)
block|{
name|TabletData
operator|::
name|ValuatorClassInfo
name|info
decl_stmt|;
name|info
operator|.
name|minVal
operator|=
name|vci
operator|->
name|min
expr_stmt|;
name|info
operator|.
name|maxVal
operator|=
name|vci
operator|->
name|max
expr_stmt|;
name|info
operator|.
name|number
operator|=
name|vci
operator|->
name|number
expr_stmt|;
name|tabletData
operator|.
name|valuatorInfo
index|[
name|valuatorAtom
index|]
operator|=
name|info
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
block|}
break|break;
default|default:
break|break;
block|}
block|}
name|bool
name|isTablet
init|=
literal|false
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
comment|// If we have found the valuators which we expect a tablet to have, assume it's a tablet.
if|if
condition|(
name|tabletData
operator|.
name|valuatorInfo
operator|.
name|contains
argument_list|(
name|QXcbAtom
operator|::
name|AbsX
argument_list|)
operator|&&
name|tabletData
operator|.
name|valuatorInfo
operator|.
name|contains
argument_list|(
name|QXcbAtom
operator|::
name|AbsY
argument_list|)
operator|&&
name|tabletData
operator|.
name|valuatorInfo
operator|.
name|contains
argument_list|(
name|QXcbAtom
operator|::
name|AbsPressure
argument_list|)
condition|)
block|{
name|tabletData
operator|.
name|deviceId
operator|=
name|devices
index|[
name|i
index|]
operator|.
name|deviceid
expr_stmt|;
name|tabletData
operator|.
name|pointerType
operator|=
name|QTabletEvent
operator|::
name|Pen
expr_stmt|;
if|if
condition|(
name|QByteArray
argument_list|(
name|devices
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|.
name|toLower
argument_list|()
operator|.
name|contains
argument_list|(
literal|"eraser"
argument_list|)
condition|)
name|tabletData
operator|.
name|pointerType
operator|=
name|QTabletEvent
operator|::
name|Eraser
expr_stmt|;
name|m_tabletData
operator|.
name|append
argument_list|(
name|tabletData
argument_list|)
expr_stmt|;
name|isTablet
operator|=
literal|true
expr_stmt|;
ifdef|#
directive|ifdef
name|XI2_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"   it's a tablet with pointer type"
operator|<<
name|tabletData
operator|.
name|pointerType
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
ifdef|#
directive|ifdef
name|XI2_DEBUG
if|if
condition|(
operator|!
name|isTablet
condition|)
block|{
name|XInput2DeviceData
modifier|*
name|dev
init|=
name|deviceForId
argument_list|(
name|devices
index|[
name|i
index|]
operator|.
name|deviceid
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|&&
name|dev
operator|->
name|qtTouchDevice
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchScreen
condition|)
name|qDebug
argument_list|(
literal|"   it's a touchscreen with type %d capabilities 0x%X max touch points %d"
argument_list|,
name|dev
operator|->
name|qtTouchDevice
operator|->
name|type
argument_list|()
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dev
operator|->
name|qtTouchDevice
operator|->
name|capabilities
argument_list|()
argument_list|,
name|dev
operator|->
name|qtTouchDevice
operator|->
name|maximumTouchPoints
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dev
operator|&&
name|dev
operator|->
name|qtTouchDevice
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchPad
condition|)
name|qDebug
argument_list|(
literal|"   it's a touchpad with type %d capabilities 0x%X max touch points %d size %f x %f"
argument_list|,
name|dev
operator|->
name|qtTouchDevice
operator|->
name|type
argument_list|()
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dev
operator|->
name|qtTouchDevice
operator|->
name|capabilities
argument_list|()
argument_list|,
name|dev
operator|->
name|qtTouchDevice
operator|->
name|maximumTouchPoints
argument_list|()
argument_list|,
name|dev
operator|->
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|dev
operator|->
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// XI2_DEBUG
block|}
name|XIFreeDeviceInfo
argument_list|(
name|devices
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|finalizeXInput2
name|void
name|QXcbConnection
operator|::
name|finalizeXInput2
parameter_list|()
block|{ }
end_function
begin_function
DECL|function|xi2Select
name|void
name|QXcbConnection
operator|::
name|xi2Select
parameter_list|(
name|xcb_window_t
name|window
parameter_list|)
block|{
if|if
condition|(
operator|!
name|m_xi2Enabled
condition|)
return|return;
name|Display
modifier|*
name|xDisplay
init|=
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bitMask
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|xiBitMask
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|bitMask
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT22
name|bitMask
operator||=
name|XI_TouchBeginMask
expr_stmt|;
name|bitMask
operator||=
name|XI_TouchUpdateMask
expr_stmt|;
name|bitMask
operator||=
name|XI_TouchEndMask
expr_stmt|;
name|XIEventMask
name|mask
decl_stmt|;
name|mask
operator|.
name|mask_len
operator|=
sizeof|sizeof
argument_list|(
name|bitMask
argument_list|)
expr_stmt|;
name|mask
operator|.
name|mask
operator|=
name|xiBitMask
expr_stmt|;
comment|// Enable each touchscreen
foreach|foreach
control|(
name|XInput2DeviceData
modifier|*
name|dev
decl|,
name|m_touchDevices
operator|.
name|values
argument_list|()
control|)
block|{
name|mask
operator|.
name|deviceid
operator|=
name|dev
operator|->
name|xiDeviceInfo
operator|->
name|deviceid
expr_stmt|;
name|Status
name|result
init|=
name|XISelectEvents
argument_list|(
name|xDisplay
argument_list|,
name|window
argument_list|,
operator|&
name|mask
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// If we have XInput>= 2.2 and successfully enable a touchscreen, then
comment|// it will provide touch only. In most other cases, there will be
comment|// emulated mouse events from the driver. If not, then Qt must do its
comment|// own mouse emulation to enable interaction with mouse-oriented QWidgets.
if|if
condition|(
name|m_xi2Minor
operator|>=
literal|2
operator|&&
name|result
operator|==
name|Success
condition|)
name|has_touch_without_mouse_emulation
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
comment|// XCB_USE_XINPUT22
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
comment|// For each tablet, select some additional event types.
comment|// Press, motion, etc. events must never be selected for _all_ devices
comment|// as that would render the standard XCB_MOTION_NOTIFY and
comment|// similar handlers useless and we have no intention to infect
comment|// all the pure xcb code with Xlib-based XI2.
if|if
condition|(
operator|!
name|m_tabletData
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QVector
argument_list|<
name|XIEventMask
argument_list|>
name|xiEventMask
argument_list|(
name|m_tabletData
operator|.
name|count
argument_list|()
argument_list|)
decl_stmt|;
name|bitMask
operator||=
name|XI_ButtonPressMask
expr_stmt|;
name|bitMask
operator||=
name|XI_ButtonReleaseMask
expr_stmt|;
name|bitMask
operator||=
name|XI_MotionMask
expr_stmt|;
name|bitMask
operator||=
name|XI_PropertyEventMask
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_tabletData
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|xiEventMask
index|[
name|i
index|]
operator|.
name|deviceid
operator|=
name|m_tabletData
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|deviceId
expr_stmt|;
name|xiEventMask
index|[
name|i
index|]
operator|.
name|mask_len
operator|=
sizeof|sizeof
argument_list|(
name|bitMask
argument_list|)
expr_stmt|;
name|xiEventMask
index|[
name|i
index|]
operator|.
name|mask
operator|=
name|xiBitMask
expr_stmt|;
block|}
name|XISelectEvents
argument_list|(
name|xDisplay
argument_list|,
name|window
argument_list|,
name|xiEventMask
operator|.
name|data
argument_list|()
argument_list|,
name|m_tabletData
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
block|}
end_function
begin_function
DECL|function|deviceForId
name|XInput2DeviceData
modifier|*
name|QXcbConnection
operator|::
name|deviceForId
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|XInput2DeviceData
modifier|*
name|dev
init|=
name|m_touchDevices
index|[
name|id
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
block|{
name|int
name|unused
init|=
literal|0
decl_stmt|;
name|QTouchDevice
operator|::
name|Capabilities
name|caps
init|=
literal|0
decl_stmt|;
name|dev
operator|=
operator|new
name|XInput2DeviceData
expr_stmt|;
name|dev
operator|->
name|xiDeviceInfo
operator|=
name|XIQueryDevice
argument_list|(
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
argument_list|,
name|id
argument_list|,
operator|&
name|unused
argument_list|)
expr_stmt|;
name|int
name|type
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|maxTouchPoints
init|=
literal|1
decl_stmt|;
name|bool
name|hasRelativeCoords
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|xiDeviceInfo
operator|->
name|num_classes
condition|;
operator|++
name|i
control|)
block|{
name|XIAnyClassInfo
modifier|*
name|classinfo
init|=
name|dev
operator|->
name|xiDeviceInfo
operator|->
name|classes
index|[
name|i
index|]
decl_stmt|;
switch|switch
condition|(
name|classinfo
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT22
case|case
name|XITouchClass
case|:
block|{
name|XITouchClassInfo
modifier|*
name|tci
init|=
cast|reinterpret_cast
argument_list|<
name|XITouchClassInfo
operator|*
argument_list|>
argument_list|(
name|classinfo
argument_list|)
decl_stmt|;
name|maxTouchPoints
operator|=
name|tci
operator|->
name|num_touches
expr_stmt|;
ifdef|#
directive|ifdef
name|XI2_DEBUG
name|qDebug
argument_list|(
literal|"   has touch class with mode %d"
argument_list|,
name|tci
operator|->
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|tci
operator|->
name|mode
condition|)
block|{
case|case
name|XIModeRelative
case|:
name|type
operator|=
name|QTouchDevice
operator|::
name|TouchPad
expr_stmt|;
break|break;
case|case
name|XIModeAbsolute
case|:
name|type
operator|=
name|QTouchDevice
operator|::
name|TouchScreen
expr_stmt|;
break|break;
block|}
block|}
break|break;
endif|#
directive|endif
comment|// XCB_USE_XINPUT22
case|case
name|XIValuatorClass
case|:
block|{
name|XIValuatorClassInfo
modifier|*
name|vci
init|=
cast|reinterpret_cast
argument_list|<
name|XIValuatorClassInfo
operator|*
argument_list|>
argument_list|(
name|classinfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTPositionX
argument_list|)
condition|)
name|caps
operator||=
name|QTouchDevice
operator|::
name|Position
operator||
name|QTouchDevice
operator|::
name|NormalizedPosition
expr_stmt|;
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTTouchMajor
argument_list|)
condition|)
name|caps
operator||=
name|QTouchDevice
operator|::
name|Area
expr_stmt|;
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTPressure
argument_list|)
operator|||
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsPressure
argument_list|)
condition|)
name|caps
operator||=
name|QTouchDevice
operator|::
name|Pressure
expr_stmt|;
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|RelX
argument_list|)
condition|)
block|{
name|hasRelativeCoords
operator|=
literal|true
expr_stmt|;
name|dev
operator|->
name|size
operator|.
name|setWidth
argument_list|(
operator|(
name|vci
operator|->
name|max
operator|-
name|vci
operator|->
name|min
operator|)
operator|*
literal|1000.0
operator|/
name|vci
operator|->
name|resolution
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|RelY
argument_list|)
condition|)
block|{
name|hasRelativeCoords
operator|=
literal|true
expr_stmt|;
name|dev
operator|->
name|size
operator|.
name|setHeight
argument_list|(
operator|(
name|vci
operator|->
name|max
operator|-
name|vci
operator|->
name|min
operator|)
operator|*
literal|1000.0
operator|/
name|vci
operator|->
name|resolution
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
name|type
operator|<
literal|0
operator|&&
name|caps
operator|&&
name|hasRelativeCoords
condition|)
block|{
name|type
operator|=
name|QTouchDevice
operator|::
name|TouchPad
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|size
operator|.
name|width
argument_list|()
operator|<
literal|10
operator|||
name|dev
operator|->
name|size
operator|.
name|height
argument_list|()
operator|<
literal|10
operator|||
name|dev
operator|->
name|size
operator|.
name|width
argument_list|()
operator|>
literal|10000
operator|||
name|dev
operator|->
name|size
operator|.
name|height
argument_list|()
operator|>
literal|10000
condition|)
name|dev
operator|->
name|size
operator|=
name|QSizeF
argument_list|(
literal|130
argument_list|,
literal|110
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|>=
name|QTouchDevice
operator|::
name|TouchScreen
operator|&&
name|type
operator|<=
name|QTouchDevice
operator|::
name|TouchPad
condition|)
block|{
name|dev
operator|->
name|qtTouchDevice
operator|=
operator|new
name|QTouchDevice
expr_stmt|;
name|dev
operator|->
name|qtTouchDevice
operator|->
name|setName
argument_list|(
name|dev
operator|->
name|xiDeviceInfo
operator|->
name|name
argument_list|)
expr_stmt|;
name|dev
operator|->
name|qtTouchDevice
operator|->
name|setType
argument_list|(
operator|(
name|QTouchDevice
operator|::
name|DeviceType
operator|)
name|type
argument_list|)
expr_stmt|;
name|dev
operator|->
name|qtTouchDevice
operator|->
name|setCapabilities
argument_list|(
name|caps
argument_list|)
expr_stmt|;
name|dev
operator|->
name|qtTouchDevice
operator|->
name|setMaximumTouchPoints
argument_list|(
name|maxTouchPoints
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|!=
literal|0
condition|)
name|QWindowSystemInterface
operator|::
name|registerTouchDevice
argument_list|(
name|dev
operator|->
name|qtTouchDevice
argument_list|)
expr_stmt|;
name|m_touchDevices
index|[
name|id
index|]
operator|=
name|dev
expr_stmt|;
block|}
else|else
block|{
name|m_touchDevices
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
operator|delete
name|dev
expr_stmt|;
name|dev
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|dev
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT22
end_ifdef
begin_function
DECL|function|fixed1616ToReal
specifier|static
name|qreal
name|fixed1616ToReal
parameter_list|(
name|FP1616
name|val
parameter_list|)
block|{
return|return
operator|(
name|qreal
argument_list|(
name|val
operator|>>
literal|16
argument_list|)
operator|)
operator|+
operator|(
name|val
operator|&
literal|0xFF
operator|)
operator|/
operator|(
name|qreal
operator|)
literal|0xFF
return|;
block|}
end_function
begin_function
DECL|function|valuatorNormalized
specifier|static
name|qreal
name|valuatorNormalized
parameter_list|(
name|double
name|value
parameter_list|,
name|XIValuatorClassInfo
modifier|*
name|vci
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>
name|vci
operator|->
name|max
condition|)
name|value
operator|=
name|vci
operator|->
name|max
expr_stmt|;
if|if
condition|(
name|value
operator|<
name|vci
operator|->
name|min
condition|)
name|value
operator|=
name|vci
operator|->
name|min
expr_stmt|;
return|return
operator|(
name|value
operator|-
name|vci
operator|->
name|min
operator|)
operator|/
operator|(
name|vci
operator|->
name|max
operator|-
name|vci
operator|->
name|min
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// XCB_USE_XINPUT22
end_comment
begin_function
DECL|function|xi2HandleEvent
name|void
name|QXcbConnection
operator|::
name|xi2HandleEvent
parameter_list|(
name|xcb_ge_event_t
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|xi2PrepareXIGenericDeviceEvent
argument_list|(
name|event
argument_list|,
name|m_xiOpCode
argument_list|)
condition|)
block|{
name|xXIGenericDeviceEvent
modifier|*
name|xiEvent
init|=
cast|reinterpret_cast
argument_list|<
name|xXIGenericDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_tabletData
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|m_tabletData
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|deviceId
operator|==
name|xiEvent
operator|->
name|deviceid
condition|)
block|{
if|if
condition|(
name|xi2HandleTabletEvent
argument_list|(
name|xiEvent
argument_list|,
operator|&
name|m_tabletData
index|[
name|i
index|]
argument_list|)
condition|)
return|return;
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT22
if|if
condition|(
name|xiEvent
operator|->
name|evtype
operator|==
name|XI_TouchBegin
operator|||
name|xiEvent
operator|->
name|evtype
operator|==
name|XI_TouchUpdate
operator|||
name|xiEvent
operator|->
name|evtype
operator|==
name|XI_TouchEnd
condition|)
block|{
name|xXIDeviceEvent
modifier|*
name|xiDeviceEvent
init|=
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|XI2_DEBUG
name|qDebug
argument_list|(
literal|"XI2 event type %d seq %d detail %d pos 0x%X,0x%X %f,%f root pos %f,%f"
argument_list|,
name|event
operator|->
name|event_type
argument_list|,
name|xiEvent
operator|->
name|sequenceNumber
argument_list|,
name|xiDeviceEvent
operator|->
name|detail
argument_list|,
name|xiDeviceEvent
operator|->
name|event_x
argument_list|,
name|xiDeviceEvent
operator|->
name|event_y
argument_list|,
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|event_x
argument_list|)
argument_list|,
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|event_y
argument_list|)
argument_list|,
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|root_x
argument_list|)
argument_list|,
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|root_y
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|QXcbWindow
modifier|*
name|platformWindow
init|=
name|platformWindowFromId
argument_list|(
name|xiDeviceEvent
operator|->
name|event
argument_list|)
condition|)
block|{
name|XInput2DeviceData
modifier|*
name|dev
init|=
name|deviceForId
argument_list|(
name|xiEvent
operator|->
name|deviceid
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|firstTouch
init|=
name|m_touchPoints
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|xiEvent
operator|->
name|evtype
operator|==
name|XI_TouchBegin
condition|)
block|{
name|QWindowSystemInterface
operator|::
name|TouchPoint
name|tp
decl_stmt|;
name|tp
operator|.
name|id
operator|=
name|xiDeviceEvent
operator|->
name|detail
operator|%
name|INT_MAX
expr_stmt|;
name|tp
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointPressed
expr_stmt|;
name|tp
operator|.
name|pressure
operator|=
operator|-
literal|1.0
expr_stmt|;
name|m_touchPoints
index|[
name|tp
operator|.
name|id
index|]
operator|=
name|tp
expr_stmt|;
block|}
name|QWindowSystemInterface
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|m_touchPoints
index|[
name|xiDeviceEvent
operator|->
name|detail
index|]
decl_stmt|;
name|qreal
name|x
init|=
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|root_x
argument_list|)
decl_stmt|;
name|qreal
name|y
init|=
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|root_y
argument_list|)
decl_stmt|;
name|qreal
name|nx
init|=
operator|-
literal|1.0
decl_stmt|,
name|ny
init|=
operator|-
literal|1.0
decl_stmt|,
name|w
init|=
literal|0.0
decl_stmt|,
name|h
init|=
literal|0.0
decl_stmt|;
name|QXcbScreen
modifier|*
name|screen
init|=
name|m_screens
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|xiDeviceInfo
operator|->
name|num_classes
condition|;
operator|++
name|i
control|)
block|{
name|XIAnyClassInfo
modifier|*
name|classinfo
init|=
name|dev
operator|->
name|xiDeviceInfo
operator|->
name|classes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|classinfo
operator|->
name|type
operator|==
name|XIValuatorClass
condition|)
block|{
name|XIValuatorClassInfo
modifier|*
name|vci
init|=
cast|reinterpret_cast
argument_list|<
name|XIValuatorClassInfo
operator|*
argument_list|>
argument_list|(
name|classinfo
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|vci
operator|->
name|number
decl_stmt|;
name|double
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|xi2GetValuatorValueIfSet
argument_list|(
name|xiDeviceEvent
argument_list|,
name|n
argument_list|,
operator|&
name|value
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|XI2_DEBUG
name|qDebug
argument_list|(
literal|"   valuator %20s value %lf from range %lf -> %lf"
argument_list|,
name|atomName
argument_list|(
name|vci
operator|->
name|label
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|value
argument_list|,
name|vci
operator|->
name|min
argument_list|,
name|vci
operator|->
name|max
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|RelX
argument_list|)
condition|)
block|{
name|nx
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|RelY
argument_list|)
condition|)
block|{
name|ny
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTPositionX
argument_list|)
condition|)
block|{
name|nx
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTPositionY
argument_list|)
condition|)
block|{
name|ny
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTTouchMajor
argument_list|)
condition|)
block|{
comment|// Convert the value within its range as a fraction of a finger's max (contact patch)
comment|//  width in mm, and from there to pixels depending on screen resolution
name|w
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
operator|*
name|FINGER_MAX_WIDTH_MM
operator|*
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
operator|/
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|width
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTTouchMinor
argument_list|)
condition|)
block|{
name|h
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
operator|*
name|FINGER_MAX_WIDTH_MM
operator|*
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|height
argument_list|()
operator|/
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTPressure
argument_list|)
operator|||
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsPressure
argument_list|)
condition|)
block|{
name|touchPoint
operator|.
name|pressure
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// If any value was not updated, use the last-known value.
if|if
condition|(
name|nx
operator|==
operator|-
literal|1.0
condition|)
block|{
name|x
operator|=
name|touchPoint
operator|.
name|area
operator|.
name|center
argument_list|()
operator|.
name|x
argument_list|()
expr_stmt|;
name|nx
operator|=
name|x
operator|/
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ny
operator|==
operator|-
literal|1.0
condition|)
block|{
name|y
operator|=
name|touchPoint
operator|.
name|area
operator|.
name|center
argument_list|()
operator|.
name|y
argument_list|()
expr_stmt|;
name|ny
operator|=
name|y
operator|/
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|xiEvent
operator|->
name|evtype
operator|!=
name|XI_TouchEnd
condition|)
block|{
if|if
condition|(
name|w
operator|==
literal|0.0
condition|)
name|w
operator|=
name|touchPoint
operator|.
name|area
operator|.
name|width
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|0.0
condition|)
name|h
operator|=
name|touchPoint
operator|.
name|area
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|xiEvent
operator|->
name|evtype
condition|)
block|{
case|case
name|XI_TouchBegin
case|:
if|if
condition|(
name|firstTouch
condition|)
block|{
name|dev
operator|->
name|firstPressedPosition
operator|=
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|dev
operator|->
name|firstPressedNormalPosition
operator|=
name|QPointF
argument_list|(
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|pointPressedPosition
operator|.
name|insert
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|,
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XI_TouchUpdate
case|:
if|if
condition|(
name|dev
operator|->
name|qtTouchDevice
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchPad
operator|&&
name|dev
operator|->
name|pointPressedPosition
operator|.
name|value
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|)
operator|==
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|qreal
name|dx
init|=
operator|(
name|nx
operator|-
name|dev
operator|->
name|firstPressedNormalPosition
operator|.
name|x
argument_list|()
operator|)
operator|*
name|dev
operator|->
name|size
operator|.
name|width
argument_list|()
operator|*
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
operator|/
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|dy
init|=
operator|(
name|ny
operator|-
name|dev
operator|->
name|firstPressedNormalPosition
operator|.
name|y
argument_list|()
operator|)
operator|*
name|dev
operator|->
name|size
operator|.
name|height
argument_list|()
operator|*
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|height
argument_list|()
operator|/
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|height
argument_list|()
decl_stmt|;
name|x
operator|=
name|dev
operator|->
name|firstPressedPosition
operator|.
name|x
argument_list|()
operator|+
name|dx
expr_stmt|;
name|y
operator|=
name|dev
operator|->
name|firstPressedPosition
operator|.
name|y
argument_list|()
operator|+
name|dy
expr_stmt|;
name|touchPoint
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointMoved
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|touchPoint
operator|.
name|area
operator|.
name|center
argument_list|()
operator|!=
name|QPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|touchPoint
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointMoved
expr_stmt|;
name|dev
operator|->
name|pointPressedPosition
index|[
name|touchPoint
operator|.
name|id
index|]
operator|=
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
else|else
name|touchPoint
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointStationary
expr_stmt|;
break|break;
case|case
name|XI_TouchEnd
case|:
name|touchPoint
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointReleased
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|qtTouchDevice
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchPad
operator|&&
name|dev
operator|->
name|pointPressedPosition
operator|.
name|value
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|)
operator|==
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|qreal
name|dx
init|=
operator|(
name|nx
operator|-
name|dev
operator|->
name|firstPressedNormalPosition
operator|.
name|x
argument_list|()
operator|)
operator|*
name|dev
operator|->
name|size
operator|.
name|width
argument_list|()
operator|*
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
operator|/
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|dy
init|=
operator|(
name|ny
operator|-
name|dev
operator|->
name|firstPressedNormalPosition
operator|.
name|y
argument_list|()
operator|)
operator|*
name|dev
operator|->
name|size
operator|.
name|width
argument_list|()
operator|*
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
operator|/
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|width
argument_list|()
decl_stmt|;
name|x
operator|=
name|dev
operator|->
name|firstPressedPosition
operator|.
name|x
argument_list|()
operator|+
name|dx
expr_stmt|;
name|y
operator|=
name|dev
operator|->
name|firstPressedPosition
operator|.
name|y
argument_list|()
operator|+
name|dy
expr_stmt|;
block|}
name|dev
operator|->
name|pointPressedPosition
operator|.
name|remove
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
name|touchPoint
operator|.
name|area
operator|=
name|QRectF
argument_list|(
name|x
operator|-
name|w
operator|/
literal|2
argument_list|,
name|y
operator|-
name|h
operator|/
literal|2
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|touchPoint
operator|.
name|normalPosition
operator|=
name|QPointF
argument_list|(
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XI2_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"   tp "
operator|<<
name|touchPoint
operator|.
name|id
operator|<<
literal|" state "
operator|<<
name|touchPoint
operator|.
name|state
operator|<<
literal|" pos norm "
operator|<<
name|touchPoint
operator|.
name|normalPosition
operator|<<
literal|" area "
operator|<<
name|touchPoint
operator|.
name|area
operator|<<
literal|" pressure "
operator|<<
name|touchPoint
operator|.
name|pressure
expr_stmt|;
endif|#
directive|endif
name|QWindowSystemInterface
operator|::
name|handleTouchEvent
argument_list|(
name|platformWindow
operator|->
name|window
argument_list|()
argument_list|,
name|xiEvent
operator|->
name|time
argument_list|,
name|dev
operator|->
name|qtTouchDevice
argument_list|,
name|m_touchPoints
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
comment|// If a touchpoint was released, we can forget it, because the ID won't be reused.
if|if
condition|(
name|touchPoint
operator|.
name|state
operator|==
name|Qt
operator|::
name|TouchPointReleased
condition|)
name|m_touchPoints
operator|.
name|remove
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// XCB_USE_XINPUT22
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
end_ifndef
begin_function
DECL|function|xi2HandleTabletEvent
name|bool
name|QXcbConnection
operator|::
name|xi2HandleTabletEvent
parameter_list|(
name|void
modifier|*
name|event
parameter_list|,
name|TabletData
modifier|*
name|tabletData
parameter_list|)
block|{
name|bool
name|handled
init|=
literal|true
decl_stmt|;
name|Display
modifier|*
name|xDisplay
init|=
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
decl_stmt|;
name|xXIGenericDeviceEvent
modifier|*
name|xiEvent
init|=
cast|static_cast
argument_list|<
name|xXIGenericDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|xiEvent
operator|->
name|evtype
condition|)
block|{
case|case
name|XI_ButtonPress
case|:
comment|// stylus down
if|if
condition|(
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|detail
operator|==
literal|1
condition|)
block|{
comment|// ignore the physical buttons on the stylus
name|tabletData
operator|->
name|down
operator|=
literal|true
expr_stmt|;
name|xi2ReportTabletEvent
argument_list|(
operator|*
name|tabletData
argument_list|,
name|xiEvent
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XI_ButtonRelease
case|:
comment|// stylus up
if|if
condition|(
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|detail
operator|==
literal|1
condition|)
block|{
name|tabletData
operator|->
name|down
operator|=
literal|false
expr_stmt|;
name|xi2ReportTabletEvent
argument_list|(
operator|*
name|tabletData
argument_list|,
name|xiEvent
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XI_Motion
case|:
comment|// Report TabletMove only when the stylus is touching the tablet.
comment|// No possibility to report proximity motion (no suitable Qt event exists yet).
if|if
condition|(
name|tabletData
operator|->
name|down
condition|)
name|xi2ReportTabletEvent
argument_list|(
operator|*
name|tabletData
argument_list|,
name|xiEvent
argument_list|)
expr_stmt|;
break|break;
case|case
name|XI_PropertyEvent
case|:
block|{
name|xXIPropertyEvent
modifier|*
name|ev
init|=
cast|reinterpret_cast
argument_list|<
name|xXIPropertyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|ev
operator|->
name|what
operator|==
name|XIPropertyModified
condition|)
block|{
if|if
condition|(
name|ev
operator|->
name|property
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|WacomSerialIDs
argument_list|)
condition|)
block|{
name|Atom
name|propType
decl_stmt|;
name|int
name|propFormat
decl_stmt|;
name|unsigned
name|long
name|numItems
decl_stmt|,
name|bytesAfter
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|XIGetProperty
argument_list|(
name|xDisplay
argument_list|,
name|tabletData
operator|->
name|deviceId
argument_list|,
name|ev
operator|->
name|property
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
literal|0
argument_list|,
name|AnyPropertyType
argument_list|,
operator|&
name|propType
argument_list|,
operator|&
name|propFormat
argument_list|,
operator|&
name|numItems
argument_list|,
operator|&
name|bytesAfter
argument_list|,
operator|&
name|data
argument_list|)
operator|==
name|Success
condition|)
block|{
if|if
condition|(
name|propType
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|INTEGER
argument_list|)
operator|&&
name|propFormat
operator|==
literal|32
condition|)
block|{
name|int
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
name|int
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numItems
condition|;
operator|++
name|i
control|)
name|tabletData
operator|->
name|serialId
operator||=
name|qint64
argument_list|(
name|ptr
index|[
name|i
index|]
argument_list|)
operator|<<
operator|(
name|i
operator|*
literal|32
operator|)
expr_stmt|;
block|}
name|XFree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
comment|// With recent-enough X drivers this property change event seems to come always
comment|// when entering and leaving proximity. Due to the lack of other options hook up
comment|// the enter/leave events to it.
if|if
condition|(
name|tabletData
operator|->
name|inProximity
condition|)
block|{
name|tabletData
operator|->
name|inProximity
operator|=
literal|false
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleTabletLeaveProximityEvent
argument_list|(
name|QTabletEvent
operator|::
name|Stylus
argument_list|,
name|tabletData
operator|->
name|pointerType
argument_list|,
name|tabletData
operator|->
name|serialId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tabletData
operator|->
name|inProximity
operator|=
literal|true
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleTabletEnterProximityEvent
argument_list|(
name|QTabletEvent
operator|::
name|Stylus
argument_list|,
name|tabletData
operator|->
name|pointerType
argument_list|,
name|tabletData
operator|->
name|serialId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
default|default:
name|handled
operator|=
literal|false
expr_stmt|;
break|break;
block|}
return|return
name|handled
return|;
block|}
end_function
begin_function
DECL|function|xi2ReportTabletEvent
name|void
name|QXcbConnection
operator|::
name|xi2ReportTabletEvent
parameter_list|(
specifier|const
name|TabletData
modifier|&
name|tabletData
parameter_list|,
name|void
modifier|*
name|event
parameter_list|)
block|{
name|xXIDeviceEvent
modifier|*
name|ev
init|=
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|QXcbWindow
modifier|*
name|xcbWindow
init|=
name|platformWindowFromId
argument_list|(
name|ev
operator|->
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xcbWindow
condition|)
return|return;
name|QWindow
modifier|*
name|window
init|=
name|xcbWindow
operator|->
name|window
argument_list|()
decl_stmt|;
specifier|const
name|double
name|scale
init|=
literal|65536.0
decl_stmt|;
name|QPointF
name|local
argument_list|(
name|ev
operator|->
name|event_x
operator|/
name|scale
argument_list|,
name|ev
operator|->
name|event_y
operator|/
name|scale
argument_list|)
decl_stmt|;
name|QPointF
name|global
argument_list|(
name|ev
operator|->
name|root_x
operator|/
name|scale
argument_list|,
name|ev
operator|->
name|root_y
operator|/
name|scale
argument_list|)
decl_stmt|;
name|double
name|pressure
init|=
literal|0
decl_stmt|,
name|rotation
init|=
literal|0
decl_stmt|;
name|int
name|xTilt
init|=
literal|0
decl_stmt|,
name|yTilt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|QHash
argument_list|<
name|int
argument_list|,
name|TabletData
operator|::
name|ValuatorClassInfo
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|tabletData
operator|.
name|valuatorInfo
operator|.
name|constBegin
argument_list|()
init|,
name|ite
init|=
name|tabletData
operator|.
name|valuatorInfo
operator|.
name|constEnd
argument_list|()
init|;
name|it
operator|!=
name|ite
condition|;
operator|++
name|it
control|)
block|{
name|int
name|valuator
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
specifier|const
name|TabletData
operator|::
name|ValuatorClassInfo
modifier|&
name|classInfo
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
name|double
name|value
decl_stmt|;
if|if
condition|(
name|xi2GetValuatorValueIfSet
argument_list|(
name|event
argument_list|,
name|classInfo
operator|.
name|number
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|double
name|normalizedValue
init|=
operator|(
name|value
operator|-
name|classInfo
operator|.
name|minVal
operator|)
operator|/
name|double
argument_list|(
name|classInfo
operator|.
name|maxVal
operator|-
name|classInfo
operator|.
name|minVal
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|valuator
condition|)
block|{
case|case
name|QXcbAtom
operator|::
name|AbsPressure
case|:
name|pressure
operator|=
name|normalizedValue
expr_stmt|;
break|break;
case|case
name|QXcbAtom
operator|::
name|AbsTiltX
case|:
name|xTilt
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|QXcbAtom
operator|::
name|AbsTiltY
case|:
name|yTilt
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|QXcbAtom
operator|::
name|AbsWheel
case|:
name|rotation
operator|=
name|value
operator|/
literal|64.0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|QWindowSystemInterface
operator|::
name|handleTabletEvent
argument_list|(
name|window
argument_list|,
name|tabletData
operator|.
name|down
argument_list|,
name|local
argument_list|,
name|global
argument_list|,
name|QTabletEvent
operator|::
name|Stylus
argument_list|,
name|tabletData
operator|.
name|pointerType
argument_list|,
name|pressure
argument_list|,
name|xTilt
argument_list|,
name|yTilt
argument_list|,
literal|0
argument_list|,
name|rotation
argument_list|,
literal|0
argument_list|,
name|tabletData
operator|.
name|serialId
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TABLETEVENT
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// XCB_USE_XINPUT2
end_comment
end_unit
