begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qxcbconnection.h"
end_include
begin_include
include|#
directive|include
file|"qxcbkeyboard.h"
end_include
begin_include
include|#
directive|include
file|"qxcbscreen.h"
end_include
begin_include
include|#
directive|include
file|"qxcbwindow.h"
end_include
begin_include
include|#
directive|include
file|"qtouchdevice.h"
end_include
begin_include
include|#
directive|include
file|<qpa/qwindowsysteminterface.h>
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT2
end_ifdef
begin_include
include|#
directive|include
file|<X11/extensions/XInput2.h>
end_include
begin_include
include|#
directive|include
file|<X11/extensions/XI2proto.h>
end_include
begin_define
DECL|macro|FINGER_MAX_WIDTH_MM
define|#
directive|define
name|FINGER_MAX_WIDTH_MM
value|10
end_define
begin_struct
DECL|struct|XInput2TouchDeviceData
struct|struct
name|XInput2TouchDeviceData
block|{
DECL|function|XInput2TouchDeviceData
name|XInput2TouchDeviceData
parameter_list|()
member_init_list|:
name|xiDeviceInfo
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|qtTouchDevice
argument_list|(
literal|0
argument_list|)
block|{     }
DECL|member|xiDeviceInfo
name|XIDeviceInfo
modifier|*
name|xiDeviceInfo
decl_stmt|;
DECL|member|qtTouchDevice
name|QTouchDevice
modifier|*
name|qtTouchDevice
decl_stmt|;
comment|// Stuff that is relevant only for touchpads
DECL|member|pointPressedPosition
name|QHash
argument_list|<
name|int
argument_list|,
name|QPointF
argument_list|>
name|pointPressedPosition
decl_stmt|;
comment|// in screen coordinates where each point was pressed
DECL|member|firstPressedPosition
name|QPointF
name|firstPressedPosition
decl_stmt|;
comment|// in screen coordinates where the first point was pressed
DECL|member|firstPressedNormalPosition
name|QPointF
name|firstPressedNormalPosition
decl_stmt|;
comment|// device coordinates (0 to 1, 0 to 1) where the first point was pressed
DECL|member|size
name|QSizeF
name|size
decl_stmt|;
comment|// device size in mm
block|}
struct|;
end_struct
begin_function
DECL|function|initializeXInput2
name|void
name|QXcbConnection
operator|::
name|initializeXInput2
parameter_list|()
block|{
comment|// TODO Qt 6 (or perhaps earlier): remove these redundant env variables
if|if
condition|(
name|qEnvironmentVariableIsSet
argument_list|(
literal|"QT_XCB_DEBUG_XINPUT"
argument_list|)
condition|)
cast|const_cast
argument_list|<
name|QLoggingCategory
operator|&
argument_list|>
argument_list|(
name|lcQpaXInput
argument_list|()
argument_list|)
operator|.
name|setEnabled
argument_list|(
name|QtDebugMsg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|qEnvironmentVariableIsSet
argument_list|(
literal|"QT_XCB_DEBUG_XINPUT_DEVICES"
argument_list|)
condition|)
cast|const_cast
argument_list|<
name|QLoggingCategory
operator|&
argument_list|>
argument_list|(
name|lcQpaXInputDevices
argument_list|()
argument_list|)
operator|.
name|setEnabled
argument_list|(
name|QtDebugMsg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Display
modifier|*
name|xDisplay
init|=
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
decl_stmt|;
if|if
condition|(
name|XQueryExtension
argument_list|(
name|xDisplay
argument_list|,
literal|"XInputExtension"
argument_list|,
operator|&
name|m_xiOpCode
argument_list|,
operator|&
name|m_xiEventBase
argument_list|,
operator|&
name|m_xiErrorBase
argument_list|)
condition|)
block|{
name|int
name|xiMajor
init|=
literal|2
decl_stmt|;
name|m_xi2Minor
operator|=
literal|2
expr_stmt|;
comment|// try 2.2 first, needed for TouchBegin/Update/End
if|if
condition|(
name|XIQueryVersion
argument_list|(
name|xDisplay
argument_list|,
operator|&
name|xiMajor
argument_list|,
operator|&
name|m_xi2Minor
argument_list|)
operator|==
name|BadRequest
condition|)
block|{
name|m_xi2Minor
operator|=
literal|1
expr_stmt|;
comment|// for smooth scrolling 2.1 is enough
if|if
condition|(
name|XIQueryVersion
argument_list|(
name|xDisplay
argument_list|,
operator|&
name|xiMajor
argument_list|,
operator|&
name|m_xi2Minor
argument_list|)
operator|==
name|BadRequest
condition|)
block|{
name|m_xi2Minor
operator|=
literal|0
expr_stmt|;
comment|// for tablet support 2.0 is enough
name|m_xi2Enabled
operator|=
name|XIQueryVersion
argument_list|(
name|xDisplay
argument_list|,
operator|&
name|xiMajor
argument_list|,
operator|&
name|m_xi2Minor
argument_list|)
operator|!=
name|BadRequest
expr_stmt|;
block|}
else|else
name|m_xi2Enabled
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|m_xi2Enabled
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|m_xi2Enabled
condition|)
block|{
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT22
name|qCDebug
argument_list|(
name|lcQpaXInputDevices
argument_list|,
literal|"XInput version %d.%d is available and Qt supports 2.2 or greater"
argument_list|,
name|xiMajor
argument_list|,
name|m_xi2Minor
argument_list|)
expr_stmt|;
else|#
directive|else
name|qCDebug
argument_list|(
name|lcQpaXInputDevices
argument_list|,
literal|"XInput version %d.%d is available and Qt supports 2.0"
argument_list|,
name|xiMajor
argument_list|,
name|m_xi2Minor
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|xi2SetupDevices
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|xi2SetupDevices
name|void
name|QXcbConnection
operator|::
name|xi2SetupDevices
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
name|m_tabletData
operator|.
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|m_scrollingDevices
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|m_xi2Enabled
condition|)
return|return;
name|Display
modifier|*
name|xDisplay
init|=
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
decl_stmt|;
name|int
name|deviceCount
init|=
literal|0
decl_stmt|;
name|XIDeviceInfo
modifier|*
name|devices
init|=
name|XIQueryDevice
argument_list|(
name|xDisplay
argument_list|,
name|XIAllDevices
argument_list|,
operator|&
name|deviceCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deviceCount
condition|;
operator|++
name|i
control|)
block|{
comment|// Only non-master pointing devices are relevant here.
if|if
condition|(
name|devices
index|[
name|i
index|]
operator|.
name|use
operator|!=
name|XISlavePointer
condition|)
continue|continue;
name|qCDebug
argument_list|(
name|lcQpaXInputDevices
argument_list|)
operator|<<
literal|"input device "
operator|<<
name|devices
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
name|TabletData
name|tabletData
decl_stmt|;
endif|#
directive|endif
name|ScrollingDevice
name|scrollingDevice
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|devices
index|[
name|i
index|]
operator|.
name|num_classes
condition|;
operator|++
name|c
control|)
block|{
switch|switch
condition|(
name|devices
index|[
name|i
index|]
operator|.
name|classes
index|[
name|c
index|]
operator|->
name|type
condition|)
block|{
case|case
name|XIValuatorClass
case|:
block|{
name|XIValuatorClassInfo
modifier|*
name|vci
init|=
cast|reinterpret_cast
argument_list|<
name|XIValuatorClassInfo
operator|*
argument_list|>
argument_list|(
name|devices
index|[
name|i
index|]
operator|.
name|classes
index|[
name|c
index|]
argument_list|)
decl_stmt|;
specifier|const
name|int
name|valuatorAtom
init|=
name|qatom
argument_list|(
name|vci
operator|->
name|label
argument_list|)
decl_stmt|;
name|qCDebug
argument_list|(
name|lcQpaXInputDevices
argument_list|)
operator|<<
literal|"   has valuator"
operator|<<
name|atomName
argument_list|(
name|vci
operator|->
name|label
argument_list|)
operator|<<
literal|"recognized?"
operator|<<
operator|(
name|valuatorAtom
operator|<
name|QXcbAtom
operator|::
name|NAtoms
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
if|if
condition|(
name|valuatorAtom
operator|<
name|QXcbAtom
operator|::
name|NAtoms
condition|)
block|{
name|TabletData
operator|::
name|ValuatorClassInfo
name|info
decl_stmt|;
name|info
operator|.
name|minVal
operator|=
name|vci
operator|->
name|min
expr_stmt|;
name|info
operator|.
name|maxVal
operator|=
name|vci
operator|->
name|max
expr_stmt|;
name|info
operator|.
name|number
operator|=
name|vci
operator|->
name|number
expr_stmt|;
name|tabletData
operator|.
name|valuatorInfo
index|[
name|valuatorAtom
index|]
operator|=
name|info
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
if|if
condition|(
name|valuatorAtom
operator|==
name|QXcbAtom
operator|::
name|RelHorizScroll
operator|||
name|valuatorAtom
operator|==
name|QXcbAtom
operator|::
name|RelHorizWheel
condition|)
name|scrollingDevice
operator|.
name|lastScrollPosition
operator|.
name|setX
argument_list|(
name|vci
operator|->
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|valuatorAtom
operator|==
name|QXcbAtom
operator|::
name|RelVertScroll
operator|||
name|valuatorAtom
operator|==
name|QXcbAtom
operator|::
name|RelVertWheel
condition|)
name|scrollingDevice
operator|.
name|lastScrollPosition
operator|.
name|setY
argument_list|(
name|vci
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT21
case|case
name|XIScrollClass
case|:
block|{
name|XIScrollClassInfo
modifier|*
name|sci
init|=
cast|reinterpret_cast
argument_list|<
name|XIScrollClassInfo
operator|*
argument_list|>
argument_list|(
name|devices
index|[
name|i
index|]
operator|.
name|classes
index|[
name|c
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|sci
operator|->
name|scroll_type
operator|==
name|XIScrollTypeVertical
condition|)
block|{
name|scrollingDevice
operator|.
name|orientations
operator||=
name|Qt
operator|::
name|Vertical
expr_stmt|;
name|scrollingDevice
operator|.
name|verticalIndex
operator|=
name|sci
operator|->
name|number
expr_stmt|;
name|scrollingDevice
operator|.
name|verticalIncrement
operator|=
name|sci
operator|->
name|increment
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sci
operator|->
name|scroll_type
operator|==
name|XIScrollTypeHorizontal
condition|)
block|{
name|scrollingDevice
operator|.
name|orientations
operator||=
name|Qt
operator|::
name|Horizontal
expr_stmt|;
name|scrollingDevice
operator|.
name|horizontalIndex
operator|=
name|sci
operator|->
name|number
expr_stmt|;
name|scrollingDevice
operator|.
name|horizontalIncrement
operator|=
name|sci
operator|->
name|increment
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XIButtonClass
case|:
block|{
name|XIButtonClassInfo
modifier|*
name|bci
init|=
cast|reinterpret_cast
argument_list|<
name|XIButtonClassInfo
operator|*
argument_list|>
argument_list|(
name|devices
index|[
name|i
index|]
operator|.
name|classes
index|[
name|c
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|bci
operator|->
name|num_buttons
operator|>=
literal|5
condition|)
block|{
name|Atom
name|label4
init|=
name|bci
operator|->
name|labels
index|[
literal|3
index|]
decl_stmt|;
name|Atom
name|label5
init|=
name|bci
operator|->
name|labels
index|[
literal|4
index|]
decl_stmt|;
comment|// Some drivers have no labels on the wheel buttons, some have no label on just one and some have no label on
comment|// button 4 and the wrong one on button 5. So we just check that they are not labelled with unrelated buttons.
if|if
condition|(
operator|(
operator|!
name|label4
operator|||
name|qatom
argument_list|(
name|label4
argument_list|)
operator|==
name|QXcbAtom
operator|::
name|ButtonWheelUp
operator|||
name|qatom
argument_list|(
name|label4
argument_list|)
operator|==
name|QXcbAtom
operator|::
name|ButtonWheelDown
operator|)
operator|&&
operator|(
operator|!
name|label5
operator|||
name|qatom
argument_list|(
name|label5
argument_list|)
operator|==
name|QXcbAtom
operator|::
name|ButtonWheelUp
operator|||
name|qatom
argument_list|(
name|label5
argument_list|)
operator|==
name|QXcbAtom
operator|::
name|ButtonWheelDown
operator|)
condition|)
name|scrollingDevice
operator|.
name|legacyOrientations
operator||=
name|Qt
operator|::
name|Vertical
expr_stmt|;
block|}
if|if
condition|(
name|bci
operator|->
name|num_buttons
operator|>=
literal|7
condition|)
block|{
name|Atom
name|label6
init|=
name|bci
operator|->
name|labels
index|[
literal|5
index|]
decl_stmt|;
name|Atom
name|label7
init|=
name|bci
operator|->
name|labels
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|label6
operator|||
name|qatom
argument_list|(
name|label6
argument_list|)
operator|==
name|QXcbAtom
operator|::
name|ButtonHorizWheelLeft
operator|)
operator|&&
operator|(
operator|!
name|label7
operator|||
name|qatom
argument_list|(
name|label7
argument_list|)
operator|==
name|QXcbAtom
operator|::
name|ButtonHorizWheelRight
operator|)
condition|)
name|scrollingDevice
operator|.
name|legacyOrientations
operator||=
name|Qt
operator|::
name|Horizontal
expr_stmt|;
block|}
name|qCDebug
argument_list|(
name|lcQpaXInputDevices
argument_list|,
literal|"   has %d buttons"
argument_list|,
name|bci
operator|->
name|num_buttons
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
name|XIKeyClass
case|:
name|qCDebug
argument_list|(
name|lcQpaXInputDevices
argument_list|)
operator|<<
literal|"   it's a keyboard"
expr_stmt|;
break|break;
case|case
name|XITouchClass
case|:
comment|// will be handled in deviceForId()
break|break;
default|default:
name|qCDebug
argument_list|(
name|lcQpaXInputDevices
argument_list|)
operator|<<
literal|"   has class"
operator|<<
name|devices
index|[
name|i
index|]
operator|.
name|classes
index|[
name|c
index|]
operator|->
name|type
expr_stmt|;
break|break;
block|}
block|}
name|bool
name|isTablet
init|=
literal|false
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
comment|// If we have found the valuators which we expect a tablet to have, it might be a tablet.
if|if
condition|(
name|tabletData
operator|.
name|valuatorInfo
operator|.
name|contains
argument_list|(
name|QXcbAtom
operator|::
name|AbsX
argument_list|)
operator|&&
name|tabletData
operator|.
name|valuatorInfo
operator|.
name|contains
argument_list|(
name|QXcbAtom
operator|::
name|AbsY
argument_list|)
operator|&&
name|tabletData
operator|.
name|valuatorInfo
operator|.
name|contains
argument_list|(
name|QXcbAtom
operator|::
name|AbsPressure
argument_list|)
condition|)
name|isTablet
operator|=
literal|true
expr_stmt|;
comment|// But we need to be careful not to take the touch and tablet-button devices as tablets.
name|QByteArray
name|name
init|=
name|QByteArray
argument_list|(
name|devices
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|QString
name|dbgType
init|=
name|QLatin1String
argument_list|(
literal|"UNKNOWN"
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|contains
argument_list|(
literal|"eraser"
argument_list|)
condition|)
block|{
name|isTablet
operator|=
literal|true
expr_stmt|;
name|tabletData
operator|.
name|pointerType
operator|=
name|QTabletEvent
operator|::
name|Eraser
expr_stmt|;
name|dbgType
operator|=
name|QLatin1String
argument_list|(
literal|"eraser"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|contains
argument_list|(
literal|"cursor"
argument_list|)
condition|)
block|{
name|isTablet
operator|=
literal|true
expr_stmt|;
name|tabletData
operator|.
name|pointerType
operator|=
name|QTabletEvent
operator|::
name|Cursor
expr_stmt|;
name|dbgType
operator|=
name|QLatin1String
argument_list|(
literal|"cursor"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|name
operator|.
name|contains
argument_list|(
literal|"pen"
argument_list|)
operator|||
name|name
operator|.
name|contains
argument_list|(
literal|"stylus"
argument_list|)
operator|)
operator|&&
name|isTablet
condition|)
block|{
name|tabletData
operator|.
name|pointerType
operator|=
name|QTabletEvent
operator|::
name|Pen
expr_stmt|;
name|dbgType
operator|=
name|QLatin1String
argument_list|(
literal|"pen"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|contains
argument_list|(
literal|"wacom"
argument_list|)
operator|&&
name|isTablet
operator|&&
operator|!
name|name
operator|.
name|contains
argument_list|(
literal|"touch"
argument_list|)
condition|)
block|{
comment|// combined device (evdev) rather than separate pen/eraser (wacom driver)
name|tabletData
operator|.
name|pointerType
operator|=
name|QTabletEvent
operator|::
name|Pen
expr_stmt|;
name|dbgType
operator|=
name|QLatin1String
argument_list|(
literal|"pen"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|contains
argument_list|(
literal|"aiptek"
argument_list|)
comment|/*&& device == QXcbAtom::KEYBOARD */
condition|)
block|{
comment|// some "Genius" tablets
name|isTablet
operator|=
literal|true
expr_stmt|;
name|tabletData
operator|.
name|pointerType
operator|=
name|QTabletEvent
operator|::
name|Pen
expr_stmt|;
name|dbgType
operator|=
name|QLatin1String
argument_list|(
literal|"pen"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isTablet
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|isTablet
condition|)
block|{
name|tabletData
operator|.
name|deviceId
operator|=
name|devices
index|[
name|i
index|]
operator|.
name|deviceid
expr_stmt|;
name|m_tabletData
operator|.
name|append
argument_list|(
name|tabletData
argument_list|)
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaXInputDevices
argument_list|)
operator|<<
literal|"   it's a tablet with pointer type"
operator|<<
name|dbgType
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT21
if|if
condition|(
name|scrollingDevice
operator|.
name|orientations
operator|||
name|scrollingDevice
operator|.
name|legacyOrientations
condition|)
block|{
name|scrollingDevice
operator|.
name|deviceId
operator|=
name|devices
index|[
name|i
index|]
operator|.
name|deviceid
expr_stmt|;
comment|// Only use legacy wheel button events when we don't have real scroll valuators.
name|scrollingDevice
operator|.
name|legacyOrientations
operator|&=
operator|~
name|scrollingDevice
operator|.
name|orientations
expr_stmt|;
name|m_scrollingDevices
operator|.
name|insert
argument_list|(
name|scrollingDevice
operator|.
name|deviceId
argument_list|,
name|scrollingDevice
argument_list|)
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaXInputDevices
argument_list|)
operator|<<
literal|"   it's a scrolling device"
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|isTablet
condition|)
block|{
comment|// touchDeviceForId populates XInput2DeviceData the first time it is called
comment|// with a new deviceId. On subsequent calls it will return the cached object.
name|XInput2TouchDeviceData
modifier|*
name|dev
init|=
name|touchDeviceForId
argument_list|(
name|devices
index|[
name|i
index|]
operator|.
name|deviceid
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|&&
name|lcQpaXInputDevices
argument_list|()
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|qtTouchDevice
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchScreen
condition|)
name|qCDebug
argument_list|(
name|lcQpaXInputDevices
argument_list|,
literal|"   it's a touchscreen with type %d capabilities 0x%X max touch points %d"
argument_list|,
name|dev
operator|->
name|qtTouchDevice
operator|->
name|type
argument_list|()
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dev
operator|->
name|qtTouchDevice
operator|->
name|capabilities
argument_list|()
argument_list|,
name|dev
operator|->
name|qtTouchDevice
operator|->
name|maximumTouchPoints
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dev
operator|->
name|qtTouchDevice
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchPad
condition|)
name|qCDebug
argument_list|(
name|lcQpaXInputDevices
argument_list|,
literal|"   it's a touchpad with type %d capabilities 0x%X max touch points %d size %f x %f"
argument_list|,
name|dev
operator|->
name|qtTouchDevice
operator|->
name|type
argument_list|()
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dev
operator|->
name|qtTouchDevice
operator|->
name|capabilities
argument_list|()
argument_list|,
name|dev
operator|->
name|qtTouchDevice
operator|->
name|maximumTouchPoints
argument_list|()
argument_list|,
name|dev
operator|->
name|size
operator|.
name|width
argument_list|()
argument_list|,
name|dev
operator|->
name|size
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|XIFreeDeviceInfo
argument_list|(
name|devices
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|finalizeXInput2
name|void
name|QXcbConnection
operator|::
name|finalizeXInput2
parameter_list|()
block|{
foreach|foreach
control|(
name|XInput2TouchDeviceData
modifier|*
name|dev
decl|,
name|m_touchDevices
control|)
block|{
if|if
condition|(
name|dev
operator|->
name|xiDeviceInfo
condition|)
name|XIFreeDeviceInfo
argument_list|(
name|dev
operator|->
name|xiDeviceInfo
argument_list|)
expr_stmt|;
operator|delete
name|dev
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|xi2Select
name|void
name|QXcbConnection
operator|::
name|xi2Select
parameter_list|(
name|xcb_window_t
name|window
parameter_list|)
block|{
if|if
condition|(
operator|!
name|m_xi2Enabled
condition|)
return|return;
name|Display
modifier|*
name|xDisplay
init|=
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|bitMask
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|xiBitMask
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|bitMask
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT22
name|bitMask
operator||=
name|XI_TouchBeginMask
expr_stmt|;
name|bitMask
operator||=
name|XI_TouchUpdateMask
expr_stmt|;
name|bitMask
operator||=
name|XI_TouchEndMask
expr_stmt|;
name|XIEventMask
name|mask
decl_stmt|;
name|mask
operator|.
name|mask_len
operator|=
sizeof|sizeof
argument_list|(
name|bitMask
argument_list|)
expr_stmt|;
name|mask
operator|.
name|mask
operator|=
name|xiBitMask
expr_stmt|;
if|if
condition|(
operator|!
name|m_touchDevices
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|mask
operator|.
name|deviceid
operator|=
name|XIAllMasterDevices
expr_stmt|;
name|Status
name|result
init|=
name|XISelectEvents
argument_list|(
name|xDisplay
argument_list|,
name|window
argument_list|,
operator|&
name|mask
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// If we select for touch events on the master pointer, XInput2
comment|// will not synthesize mouse events. This means Qt must do it,
comment|// which is also preferable, since Qt can control better when
comment|// to do so.
if|if
condition|(
name|m_xi2Minor
operator|>=
literal|2
operator|&&
name|result
operator|==
name|Success
condition|)
name|has_touch_without_mouse_emulation
operator|=
literal|true
expr_stmt|;
block|}
endif|#
directive|endif
comment|// XCB_USE_XINPUT22
name|QSet
argument_list|<
name|int
argument_list|>
name|tabletDevices
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
comment|// For each tablet, select some additional event types.
comment|// Press, motion, etc. events must never be selected for _all_ devices
comment|// as that would render the standard XCB_MOTION_NOTIFY and
comment|// similar handlers useless and we have no intention to infect
comment|// all the pure xcb code with Xlib-based XI2.
if|if
condition|(
operator|!
name|m_tabletData
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|unsigned
name|int
name|tabletBitMask
decl_stmt|;
name|unsigned
name|char
modifier|*
name|xiTabletBitMask
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|tabletBitMask
argument_list|)
decl_stmt|;
name|QVector
argument_list|<
name|XIEventMask
argument_list|>
name|xiEventMask
argument_list|(
name|m_tabletData
operator|.
name|count
argument_list|()
argument_list|)
decl_stmt|;
name|tabletBitMask
operator|=
name|XI_ButtonPressMask
expr_stmt|;
name|tabletBitMask
operator||=
name|XI_ButtonReleaseMask
expr_stmt|;
name|tabletBitMask
operator||=
name|XI_MotionMask
expr_stmt|;
name|tabletBitMask
operator||=
name|XI_PropertyEventMask
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_tabletData
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|deviceId
init|=
name|m_tabletData
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|deviceId
decl_stmt|;
name|tabletDevices
operator|.
name|insert
argument_list|(
name|deviceId
argument_list|)
expr_stmt|;
name|xiEventMask
index|[
name|i
index|]
operator|.
name|deviceid
operator|=
name|deviceId
expr_stmt|;
name|xiEventMask
index|[
name|i
index|]
operator|.
name|mask_len
operator|=
sizeof|sizeof
argument_list|(
name|tabletBitMask
argument_list|)
expr_stmt|;
name|xiEventMask
index|[
name|i
index|]
operator|.
name|mask
operator|=
name|xiTabletBitMask
expr_stmt|;
block|}
name|XISelectEvents
argument_list|(
name|xDisplay
argument_list|,
name|window
argument_list|,
name|xiEventMask
operator|.
name|data
argument_list|()
argument_list|,
name|m_tabletData
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT21
comment|// Enable each scroll device
if|if
condition|(
operator|!
name|m_scrollingDevices
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QVector
argument_list|<
name|XIEventMask
argument_list|>
name|xiEventMask
argument_list|(
name|m_scrollingDevices
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|scrollBitMask
decl_stmt|;
name|unsigned
name|char
modifier|*
name|xiScrollBitMask
init|=
cast|reinterpret_cast
argument_list|<
name|unsigned
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|scrollBitMask
argument_list|)
decl_stmt|;
name|scrollBitMask
operator|=
name|XI_MotionMask
expr_stmt|;
name|scrollBitMask
operator||=
name|XI_ButtonReleaseMask
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Q_FOREACH
argument_list|(
argument|const ScrollingDevice& scrollingDevice
argument_list|,
argument|m_scrollingDevices
argument_list|)
block|{
if|if
condition|(
name|tabletDevices
operator|.
name|contains
argument_list|(
name|scrollingDevice
operator|.
name|deviceId
argument_list|)
condition|)
continue|continue;
comment|// All necessary events are already captured.
name|xiEventMask
index|[
name|i
index|]
operator|.
name|deviceid
operator|=
name|scrollingDevice
operator|.
name|deviceId
expr_stmt|;
name|xiEventMask
index|[
name|i
index|]
operator|.
name|mask_len
operator|=
sizeof|sizeof
argument_list|(
name|scrollBitMask
argument_list|)
expr_stmt|;
name|xiEventMask
index|[
name|i
index|]
operator|.
name|mask
operator|=
name|xiScrollBitMask
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|XISelectEvents
argument_list|(
name|xDisplay
argument_list|,
name|window
argument_list|,
name|xiEventMask
operator|.
name|data
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|xiBitMask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|{
comment|// Listen for hotplug events
name|XIEventMask
name|xiEventMask
decl_stmt|;
name|bitMask
operator|=
name|XI_HierarchyChangedMask
expr_stmt|;
name|xiEventMask
operator|.
name|deviceid
operator|=
name|XIAllDevices
expr_stmt|;
name|xiEventMask
operator|.
name|mask_len
operator|=
sizeof|sizeof
argument_list|(
name|bitMask
argument_list|)
expr_stmt|;
name|xiEventMask
operator|.
name|mask
operator|=
name|xiBitMask
expr_stmt|;
name|XISelectEvents
argument_list|(
name|xDisplay
argument_list|,
name|window
argument_list|,
operator|&
name|xiEventMask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|touchDeviceForId
name|XInput2TouchDeviceData
modifier|*
name|QXcbConnection
operator|::
name|touchDeviceForId
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|XInput2TouchDeviceData
modifier|*
name|dev
init|=
name|Q_NULLPTR
decl_stmt|;
name|QHash
argument_list|<
name|int
argument_list|,
name|XInput2TouchDeviceData
modifier|*
argument_list|>
operator|::
name|const_iterator
name|devIt
init|=
name|m_touchDevices
operator|.
name|find
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|devIt
operator|!=
name|m_touchDevices
operator|.
name|end
argument_list|()
condition|)
block|{
name|dev
operator|=
name|devIt
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|nrDevices
init|=
literal|0
decl_stmt|;
name|QTouchDevice
operator|::
name|Capabilities
name|caps
init|=
literal|0
decl_stmt|;
name|dev
operator|=
operator|new
name|XInput2TouchDeviceData
expr_stmt|;
name|dev
operator|->
name|xiDeviceInfo
operator|=
name|XIQueryDevice
argument_list|(
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
argument_list|,
name|id
argument_list|,
operator|&
name|nrDevices
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrDevices
operator|<=
literal|0
condition|)
block|{
operator|delete
name|dev
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|type
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|maxTouchPoints
init|=
literal|1
decl_stmt|;
name|bool
name|hasRelativeCoords
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|xiDeviceInfo
operator|->
name|num_classes
condition|;
operator|++
name|i
control|)
block|{
name|XIAnyClassInfo
modifier|*
name|classinfo
init|=
name|dev
operator|->
name|xiDeviceInfo
operator|->
name|classes
index|[
name|i
index|]
decl_stmt|;
switch|switch
condition|(
name|classinfo
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT22
case|case
name|XITouchClass
case|:
block|{
name|XITouchClassInfo
modifier|*
name|tci
init|=
cast|reinterpret_cast
argument_list|<
name|XITouchClassInfo
operator|*
argument_list|>
argument_list|(
name|classinfo
argument_list|)
decl_stmt|;
name|maxTouchPoints
operator|=
name|tci
operator|->
name|num_touches
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaXInputDevices
argument_list|,
literal|"   has touch class with mode %d"
argument_list|,
name|tci
operator|->
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tci
operator|->
name|mode
condition|)
block|{
case|case
name|XIDependentTouch
case|:
name|type
operator|=
name|QTouchDevice
operator|::
name|TouchPad
expr_stmt|;
break|break;
case|case
name|XIDirectTouch
case|:
name|type
operator|=
name|QTouchDevice
operator|::
name|TouchScreen
expr_stmt|;
break|break;
block|}
break|break;
block|}
endif|#
directive|endif
comment|// XCB_USE_XINPUT22
case|case
name|XIValuatorClass
case|:
block|{
name|XIValuatorClassInfo
modifier|*
name|vci
init|=
cast|reinterpret_cast
argument_list|<
name|XIValuatorClassInfo
operator|*
argument_list|>
argument_list|(
name|classinfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTPositionX
argument_list|)
condition|)
name|caps
operator||=
name|QTouchDevice
operator|::
name|Position
operator||
name|QTouchDevice
operator|::
name|NormalizedPosition
expr_stmt|;
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTTouchMajor
argument_list|)
condition|)
name|caps
operator||=
name|QTouchDevice
operator|::
name|Area
expr_stmt|;
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTPressure
argument_list|)
operator|||
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsPressure
argument_list|)
condition|)
name|caps
operator||=
name|QTouchDevice
operator|::
name|Pressure
expr_stmt|;
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|RelX
argument_list|)
condition|)
block|{
name|hasRelativeCoords
operator|=
literal|true
expr_stmt|;
name|dev
operator|->
name|size
operator|.
name|setWidth
argument_list|(
operator|(
name|vci
operator|->
name|max
operator|-
name|vci
operator|->
name|min
operator|)
operator|*
literal|1000.0
operator|/
name|vci
operator|->
name|resolution
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|RelY
argument_list|)
condition|)
block|{
name|hasRelativeCoords
operator|=
literal|true
expr_stmt|;
name|dev
operator|->
name|size
operator|.
name|setHeight
argument_list|(
operator|(
name|vci
operator|->
name|max
operator|-
name|vci
operator|->
name|min
operator|)
operator|*
literal|1000.0
operator|/
name|vci
operator|->
name|resolution
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsX
argument_list|)
condition|)
block|{
name|dev
operator|->
name|size
operator|.
name|setHeight
argument_list|(
operator|(
name|vci
operator|->
name|max
operator|-
name|vci
operator|->
name|min
operator|)
operator|*
literal|1000.0
operator|/
name|vci
operator|->
name|resolution
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsY
argument_list|)
condition|)
block|{
name|dev
operator|->
name|size
operator|.
name|setWidth
argument_list|(
operator|(
name|vci
operator|->
name|max
operator|-
name|vci
operator|->
name|min
operator|)
operator|*
literal|1000.0
operator|/
name|vci
operator|->
name|resolution
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|type
operator|<
literal|0
operator|&&
name|caps
operator|&&
name|hasRelativeCoords
condition|)
block|{
name|type
operator|=
name|QTouchDevice
operator|::
name|TouchPad
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|size
operator|.
name|width
argument_list|()
operator|<
literal|10
operator|||
name|dev
operator|->
name|size
operator|.
name|height
argument_list|()
operator|<
literal|10
operator|||
name|dev
operator|->
name|size
operator|.
name|width
argument_list|()
operator|>
literal|10000
operator|||
name|dev
operator|->
name|size
operator|.
name|height
argument_list|()
operator|>
literal|10000
condition|)
name|dev
operator|->
name|size
operator|=
name|QSizeF
argument_list|(
literal|130
argument_list|,
literal|110
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|>=
name|QTouchDevice
operator|::
name|TouchScreen
operator|&&
name|type
operator|<=
name|QTouchDevice
operator|::
name|TouchPad
condition|)
block|{
name|dev
operator|->
name|qtTouchDevice
operator|=
operator|new
name|QTouchDevice
expr_stmt|;
name|dev
operator|->
name|qtTouchDevice
operator|->
name|setName
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
name|dev
operator|->
name|xiDeviceInfo
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|qtTouchDevice
operator|->
name|setType
argument_list|(
operator|(
name|QTouchDevice
operator|::
name|DeviceType
operator|)
name|type
argument_list|)
expr_stmt|;
name|dev
operator|->
name|qtTouchDevice
operator|->
name|setCapabilities
argument_list|(
name|caps
argument_list|)
expr_stmt|;
name|dev
operator|->
name|qtTouchDevice
operator|->
name|setMaximumTouchPoints
argument_list|(
name|maxTouchPoints
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|!=
literal|0
condition|)
name|QWindowSystemInterface
operator|::
name|registerTouchDevice
argument_list|(
name|dev
operator|->
name|qtTouchDevice
argument_list|)
expr_stmt|;
name|m_touchDevices
index|[
name|id
index|]
operator|=
name|dev
expr_stmt|;
block|}
else|else
block|{
name|XIFreeDeviceInfo
argument_list|(
name|dev
operator|->
name|xiDeviceInfo
argument_list|)
expr_stmt|;
operator|delete
name|dev
expr_stmt|;
name|dev
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|dev
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|XCB_USE_XINPUT21
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|QT_NO_TABLETEVENT
argument_list|)
end_if
begin_function
DECL|function|fixed1616ToReal
specifier|static
name|qreal
name|fixed1616ToReal
parameter_list|(
name|FP1616
name|val
parameter_list|)
block|{
return|return
operator|(
name|qreal
argument_list|(
name|val
operator|>>
literal|16
argument_list|)
operator|)
operator|+
operator|(
name|val
operator|&
literal|0xFFFF
operator|)
operator|/
operator|(
name|qreal
operator|)
literal|0xFFFF
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// defined(XCB_USE_XINPUT21) || !defined(QT_NO_TABLETEVENT)
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|XCB_USE_XINPUT21
argument_list|)
end_if
begin_function
DECL|function|valuatorNormalized
specifier|static
name|qreal
name|valuatorNormalized
parameter_list|(
name|double
name|value
parameter_list|,
name|XIValuatorClassInfo
modifier|*
name|vci
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>
name|vci
operator|->
name|max
condition|)
name|value
operator|=
name|vci
operator|->
name|max
expr_stmt|;
if|if
condition|(
name|value
operator|<
name|vci
operator|->
name|min
condition|)
name|value
operator|=
name|vci
operator|->
name|min
expr_stmt|;
return|return
operator|(
name|value
operator|-
name|vci
operator|->
name|min
operator|)
operator|/
operator|(
name|vci
operator|->
name|max
operator|-
name|vci
operator|->
name|min
operator|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// XCB_USE_XINPUT21
end_comment
begin_function
DECL|function|xi2HandleEvent
name|void
name|QXcbConnection
operator|::
name|xi2HandleEvent
parameter_list|(
name|xcb_ge_event_t
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
name|xi2PrepareXIGenericDeviceEvent
argument_list|(
name|event
argument_list|,
name|m_xiOpCode
argument_list|)
condition|)
block|{
name|xXIGenericDeviceEvent
modifier|*
name|xiEvent
init|=
cast|reinterpret_cast
argument_list|<
name|xXIGenericDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|xiEvent
operator|->
name|evtype
operator|==
name|XI_HierarchyChanged
condition|)
block|{
name|xi2HandleHierachyEvent
argument_list|(
name|xiEvent
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|m_tabletData
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|m_tabletData
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|deviceId
operator|==
name|xiEvent
operator|->
name|deviceid
condition|)
block|{
if|if
condition|(
name|xi2HandleTabletEvent
argument_list|(
name|xiEvent
argument_list|,
operator|&
name|m_tabletData
index|[
name|i
index|]
argument_list|)
condition|)
return|return;
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_TABLETEVENT
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT21
name|QHash
argument_list|<
name|int
argument_list|,
name|ScrollingDevice
argument_list|>
operator|::
name|iterator
name|device
init|=
name|m_scrollingDevices
operator|.
name|find
argument_list|(
name|xiEvent
operator|->
name|deviceid
argument_list|)
decl_stmt|;
if|if
condition|(
name|device
operator|!=
name|m_scrollingDevices
operator|.
name|end
argument_list|()
condition|)
name|xi2HandleScrollEvent
argument_list|(
name|xiEvent
argument_list|,
name|device
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// XCB_USE_XINPUT21
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT22
if|if
condition|(
name|xiEvent
operator|->
name|evtype
operator|==
name|XI_TouchBegin
operator|||
name|xiEvent
operator|->
name|evtype
operator|==
name|XI_TouchUpdate
operator|||
name|xiEvent
operator|->
name|evtype
operator|==
name|XI_TouchEnd
condition|)
block|{
name|xXIDeviceEvent
modifier|*
name|xiDeviceEvent
init|=
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|lcQpaXInput
argument_list|()
operator|.
name|isDebugEnabled
argument_list|()
argument_list|)
condition|)
name|qCDebug
argument_list|(
name|lcQpaXInput
argument_list|,
literal|"XI2 touch event type %d seq %d detail %d pos %6.1f, %6.1f root pos %6.1f, %6.1f"
argument_list|,
name|event
operator|->
name|event_type
argument_list|,
name|xiEvent
operator|->
name|sequenceNumber
argument_list|,
name|xiDeviceEvent
operator|->
name|detail
argument_list|,
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|event_x
argument_list|)
argument_list|,
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|event_y
argument_list|)
argument_list|,
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|root_x
argument_list|)
argument_list|,
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|root_y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|QXcbWindow
modifier|*
name|platformWindow
init|=
name|platformWindowFromId
argument_list|(
name|xiDeviceEvent
operator|->
name|event
argument_list|)
condition|)
block|{
name|XInput2TouchDeviceData
modifier|*
name|dev
init|=
name|touchDeviceForId
argument_list|(
name|xiDeviceEvent
operator|->
name|sourceid
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
specifier|const
name|bool
name|firstTouch
init|=
name|m_touchPoints
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|xiEvent
operator|->
name|evtype
operator|==
name|XI_TouchBegin
condition|)
block|{
name|QWindowSystemInterface
operator|::
name|TouchPoint
name|tp
decl_stmt|;
name|tp
operator|.
name|id
operator|=
name|xiDeviceEvent
operator|->
name|detail
operator|%
name|INT_MAX
expr_stmt|;
name|tp
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointPressed
expr_stmt|;
name|tp
operator|.
name|pressure
operator|=
operator|-
literal|1.0
expr_stmt|;
name|m_touchPoints
index|[
name|tp
operator|.
name|id
index|]
operator|=
name|tp
expr_stmt|;
block|}
name|QWindowSystemInterface
operator|::
name|TouchPoint
modifier|&
name|touchPoint
init|=
name|m_touchPoints
index|[
name|xiDeviceEvent
operator|->
name|detail
index|]
decl_stmt|;
name|qreal
name|x
init|=
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|root_x
argument_list|)
decl_stmt|;
name|qreal
name|y
init|=
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|root_y
argument_list|)
decl_stmt|;
name|qreal
name|nx
init|=
operator|-
literal|1.0
decl_stmt|,
name|ny
init|=
operator|-
literal|1.0
decl_stmt|,
name|w
init|=
literal|0.0
decl_stmt|,
name|h
init|=
literal|0.0
decl_stmt|;
name|QXcbScreen
modifier|*
name|screen
init|=
name|m_screens
operator|.
name|at
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|xiDeviceInfo
operator|->
name|num_classes
condition|;
operator|++
name|i
control|)
block|{
name|XIAnyClassInfo
modifier|*
name|classinfo
init|=
name|dev
operator|->
name|xiDeviceInfo
operator|->
name|classes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|classinfo
operator|->
name|type
operator|==
name|XIValuatorClass
condition|)
block|{
name|XIValuatorClassInfo
modifier|*
name|vci
init|=
cast|reinterpret_cast
argument_list|<
name|XIValuatorClassInfo
operator|*
argument_list|>
argument_list|(
name|classinfo
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|vci
operator|->
name|number
decl_stmt|;
name|double
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|xi2GetValuatorValueIfSet
argument_list|(
name|xiDeviceEvent
argument_list|,
name|n
argument_list|,
operator|&
name|value
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|lcQpaXInput
argument_list|()
operator|.
name|isDebugEnabled
argument_list|()
argument_list|)
condition|)
name|qCDebug
argument_list|(
name|lcQpaXInput
argument_list|,
literal|"   valuator %20s value %lf from range %lf -> %lf"
argument_list|,
name|atomName
argument_list|(
name|vci
operator|->
name|label
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|,
name|value
argument_list|,
name|vci
operator|->
name|min
argument_list|,
name|vci
operator|->
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|RelX
argument_list|)
condition|)
block|{
name|nx
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|RelY
argument_list|)
condition|)
block|{
name|ny
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsX
argument_list|)
condition|)
block|{
name|nx
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsY
argument_list|)
condition|)
block|{
name|ny
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTPositionX
argument_list|)
condition|)
block|{
name|nx
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTPositionY
argument_list|)
condition|)
block|{
name|ny
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTTouchMajor
argument_list|)
condition|)
block|{
comment|// Convert the value within its range as a fraction of a finger's max (contact patch)
comment|//  width in mm, and from there to pixels depending on screen resolution
name|w
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
operator|*
name|FINGER_MAX_WIDTH_MM
operator|*
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
operator|/
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|width
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTTouchMinor
argument_list|)
condition|)
block|{
name|h
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
operator|*
name|FINGER_MAX_WIDTH_MM
operator|*
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|height
argument_list|()
operator|/
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsMTPressure
argument_list|)
operator|||
name|vci
operator|->
name|label
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|AbsPressure
argument_list|)
condition|)
block|{
name|touchPoint
operator|.
name|pressure
operator|=
name|valuatorNormalized
argument_list|(
name|value
argument_list|,
name|vci
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// If any value was not updated, use the last-known value.
if|if
condition|(
name|nx
operator|==
operator|-
literal|1.0
condition|)
block|{
name|x
operator|=
name|touchPoint
operator|.
name|area
operator|.
name|center
argument_list|()
operator|.
name|x
argument_list|()
expr_stmt|;
name|nx
operator|=
name|x
operator|/
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ny
operator|==
operator|-
literal|1.0
condition|)
block|{
name|y
operator|=
name|touchPoint
operator|.
name|area
operator|.
name|center
argument_list|()
operator|.
name|y
argument_list|()
expr_stmt|;
name|ny
operator|=
name|y
operator|/
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|xiEvent
operator|->
name|evtype
operator|!=
name|XI_TouchEnd
condition|)
block|{
if|if
condition|(
name|w
operator|==
literal|0.0
condition|)
name|w
operator|=
name|touchPoint
operator|.
name|area
operator|.
name|width
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|0.0
condition|)
name|h
operator|=
name|touchPoint
operator|.
name|area
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|xiEvent
operator|->
name|evtype
condition|)
block|{
case|case
name|XI_TouchBegin
case|:
if|if
condition|(
name|firstTouch
condition|)
block|{
name|dev
operator|->
name|firstPressedPosition
operator|=
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|dev
operator|->
name|firstPressedNormalPosition
operator|=
name|QPointF
argument_list|(
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|pointPressedPosition
operator|.
name|insert
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|,
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XI_TouchUpdate
case|:
if|if
condition|(
name|dev
operator|->
name|qtTouchDevice
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchPad
operator|&&
name|dev
operator|->
name|pointPressedPosition
operator|.
name|value
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|)
operator|==
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|qreal
name|dx
init|=
operator|(
name|nx
operator|-
name|dev
operator|->
name|firstPressedNormalPosition
operator|.
name|x
argument_list|()
operator|)
operator|*
name|dev
operator|->
name|size
operator|.
name|width
argument_list|()
operator|*
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
operator|/
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|dy
init|=
operator|(
name|ny
operator|-
name|dev
operator|->
name|firstPressedNormalPosition
operator|.
name|y
argument_list|()
operator|)
operator|*
name|dev
operator|->
name|size
operator|.
name|height
argument_list|()
operator|*
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|height
argument_list|()
operator|/
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|height
argument_list|()
decl_stmt|;
name|x
operator|=
name|dev
operator|->
name|firstPressedPosition
operator|.
name|x
argument_list|()
operator|+
name|dx
expr_stmt|;
name|y
operator|=
name|dev
operator|->
name|firstPressedPosition
operator|.
name|y
argument_list|()
operator|+
name|dy
expr_stmt|;
name|touchPoint
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointMoved
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|touchPoint
operator|.
name|area
operator|.
name|center
argument_list|()
operator|!=
name|QPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|touchPoint
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointMoved
expr_stmt|;
name|dev
operator|->
name|pointPressedPosition
index|[
name|touchPoint
operator|.
name|id
index|]
operator|=
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XI_TouchEnd
case|:
name|touchPoint
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointReleased
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|qtTouchDevice
operator|->
name|type
argument_list|()
operator|==
name|QTouchDevice
operator|::
name|TouchPad
operator|&&
name|dev
operator|->
name|pointPressedPosition
operator|.
name|value
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|)
operator|==
name|QPointF
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|qreal
name|dx
init|=
operator|(
name|nx
operator|-
name|dev
operator|->
name|firstPressedNormalPosition
operator|.
name|x
argument_list|()
operator|)
operator|*
name|dev
operator|->
name|size
operator|.
name|width
argument_list|()
operator|*
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
operator|/
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|width
argument_list|()
decl_stmt|;
name|qreal
name|dy
init|=
operator|(
name|ny
operator|-
name|dev
operator|->
name|firstPressedNormalPosition
operator|.
name|y
argument_list|()
operator|)
operator|*
name|dev
operator|->
name|size
operator|.
name|width
argument_list|()
operator|*
name|screen
operator|->
name|geometry
argument_list|()
operator|.
name|width
argument_list|()
operator|/
name|screen
operator|->
name|physicalSize
argument_list|()
operator|.
name|width
argument_list|()
decl_stmt|;
name|x
operator|=
name|dev
operator|->
name|firstPressedPosition
operator|.
name|x
argument_list|()
operator|+
name|dx
expr_stmt|;
name|y
operator|=
name|dev
operator|->
name|firstPressedPosition
operator|.
name|y
argument_list|()
operator|+
name|dy
expr_stmt|;
block|}
name|dev
operator|->
name|pointPressedPosition
operator|.
name|remove
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
name|touchPoint
operator|.
name|area
operator|=
name|QRectF
argument_list|(
name|x
operator|-
name|w
operator|/
literal|2
argument_list|,
name|y
operator|-
name|h
operator|/
literal|2
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|touchPoint
operator|.
name|normalPosition
operator|=
name|QPointF
argument_list|(
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|lcQpaXInput
argument_list|()
operator|.
name|isDebugEnabled
argument_list|()
argument_list|)
condition|)
name|qCDebug
argument_list|(
name|lcQpaXInput
argument_list|)
operator|<<
literal|"   touchpoint "
operator|<<
name|touchPoint
operator|.
name|id
operator|<<
literal|" state "
operator|<<
name|touchPoint
operator|.
name|state
operator|<<
literal|" pos norm "
operator|<<
name|touchPoint
operator|.
name|normalPosition
operator|<<
literal|" area "
operator|<<
name|touchPoint
operator|.
name|area
operator|<<
literal|" pressure "
operator|<<
name|touchPoint
operator|.
name|pressure
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleTouchEvent
argument_list|(
name|platformWindow
operator|->
name|window
argument_list|()
argument_list|,
name|xiEvent
operator|->
name|time
argument_list|,
name|dev
operator|->
name|qtTouchDevice
argument_list|,
name|m_touchPoints
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|touchPoint
operator|.
name|state
operator|==
name|Qt
operator|::
name|TouchPointReleased
condition|)
comment|// If a touchpoint was released, we can forget it, because the ID won't be reused.
name|m_touchPoints
operator|.
name|remove
argument_list|(
name|touchPoint
operator|.
name|id
argument_list|)
expr_stmt|;
else|else
comment|// Make sure that we don't send TouchPointPressed/Moved in more than one QTouchEvent
comment|// with this touch point if the next XI2 event is about a different touch point.
name|touchPoint
operator|.
name|state
operator|=
name|Qt
operator|::
name|TouchPointStationary
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// XCB_USE_XINPUT22
block|}
block|}
end_function
begin_function
DECL|function|xi2HandleHierachyEvent
name|void
name|QXcbConnection
operator|::
name|xi2HandleHierachyEvent
parameter_list|(
name|void
modifier|*
name|event
parameter_list|)
block|{
name|xXIHierarchyEvent
modifier|*
name|xiEvent
init|=
cast|reinterpret_cast
argument_list|<
name|xXIHierarchyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
comment|// We only care about hotplugged devices
if|if
condition|(
operator|!
operator|(
name|xiEvent
operator|->
name|flags
operator|&
operator|(
name|XISlaveRemoved
operator||
name|XISlaveAdded
operator|)
operator|)
condition|)
return|return;
name|xi2SetupDevices
argument_list|()
expr_stmt|;
comment|// Reselect events for all event-listening windows.
name|Q_FOREACH
argument_list|(
argument|xcb_window_t window
argument_list|,
argument|m_mapper.keys()
argument_list|)
block|{
name|xi2Select
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|handleEnterEvent
name|void
name|QXcbConnection
operator|::
name|handleEnterEvent
parameter_list|(
specifier|const
name|xcb_enter_notify_event_t
modifier|*
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT21
name|QHash
argument_list|<
name|int
argument_list|,
name|ScrollingDevice
argument_list|>
operator|::
name|iterator
name|it
init|=
name|m_scrollingDevices
operator|.
name|begin
argument_list|()
decl_stmt|;
specifier|const
name|QHash
argument_list|<
name|int
argument_list|,
name|ScrollingDevice
argument_list|>
operator|::
name|iterator
name|end
init|=
name|m_scrollingDevices
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|end
condition|)
block|{
name|ScrollingDevice
modifier|&
name|scrollingDevice
init|=
name|it
operator|.
name|value
argument_list|()
decl_stmt|;
name|int
name|nrDevices
init|=
literal|0
decl_stmt|;
name|XIDeviceInfo
modifier|*
name|xiDeviceInfo
init|=
name|XIQueryDevice
argument_list|(
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
argument_list|,
name|scrollingDevice
operator|.
name|deviceId
argument_list|,
operator|&
name|nrDevices
argument_list|)
decl_stmt|;
if|if
condition|(
name|nrDevices
operator|<=
literal|0
condition|)
block|{
name|it
operator|=
name|m_scrollingDevices
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|xiDeviceInfo
operator|->
name|num_classes
condition|;
operator|++
name|c
control|)
block|{
if|if
condition|(
name|xiDeviceInfo
operator|->
name|classes
index|[
name|c
index|]
operator|->
name|type
operator|==
name|XIValuatorClass
condition|)
block|{
name|XIValuatorClassInfo
modifier|*
name|vci
init|=
cast|reinterpret_cast
argument_list|<
name|XIValuatorClassInfo
operator|*
argument_list|>
argument_list|(
name|xiDeviceInfo
operator|->
name|classes
index|[
name|c
index|]
argument_list|)
decl_stmt|;
specifier|const
name|int
name|valuatorAtom
init|=
name|qatom
argument_list|(
name|vci
operator|->
name|label
argument_list|)
decl_stmt|;
if|if
condition|(
name|valuatorAtom
operator|==
name|QXcbAtom
operator|::
name|RelHorizScroll
operator|||
name|valuatorAtom
operator|==
name|QXcbAtom
operator|::
name|RelHorizWheel
condition|)
name|scrollingDevice
operator|.
name|lastScrollPosition
operator|.
name|setX
argument_list|(
name|vci
operator|->
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|valuatorAtom
operator|==
name|QXcbAtom
operator|::
name|RelVertScroll
operator|||
name|valuatorAtom
operator|==
name|QXcbAtom
operator|::
name|RelVertWheel
condition|)
name|scrollingDevice
operator|.
name|lastScrollPosition
operator|.
name|setY
argument_list|(
name|vci
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|XIFreeDeviceInfo
argument_list|(
name|xiDeviceInfo
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|xi2HandleScrollEvent
name|void
name|QXcbConnection
operator|::
name|xi2HandleScrollEvent
parameter_list|(
name|void
modifier|*
name|event
parameter_list|,
name|ScrollingDevice
modifier|&
name|scrollingDevice
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XCB_USE_XINPUT21
name|xXIGenericDeviceEvent
modifier|*
name|xiEvent
init|=
cast|reinterpret_cast
argument_list|<
name|xXIGenericDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|xiEvent
operator|->
name|evtype
operator|==
name|XI_Motion
operator|&&
name|scrollingDevice
operator|.
name|orientations
condition|)
block|{
name|xXIDeviceEvent
modifier|*
name|xiDeviceEvent
init|=
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|QXcbWindow
modifier|*
name|platformWindow
init|=
name|platformWindowFromId
argument_list|(
name|xiDeviceEvent
operator|->
name|event
argument_list|)
condition|)
block|{
name|QPoint
name|rawDelta
decl_stmt|;
name|QPoint
name|angleDelta
decl_stmt|;
name|double
name|value
decl_stmt|;
if|if
condition|(
name|scrollingDevice
operator|.
name|orientations
operator|&
name|Qt
operator|::
name|Vertical
condition|)
block|{
if|if
condition|(
name|xi2GetValuatorValueIfSet
argument_list|(
name|xiDeviceEvent
argument_list|,
name|scrollingDevice
operator|.
name|verticalIndex
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|double
name|delta
init|=
name|scrollingDevice
operator|.
name|lastScrollPosition
operator|.
name|y
argument_list|()
operator|-
name|value
decl_stmt|;
name|scrollingDevice
operator|.
name|lastScrollPosition
operator|.
name|setY
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|angleDelta
operator|.
name|setY
argument_list|(
operator|(
name|delta
operator|/
name|scrollingDevice
operator|.
name|verticalIncrement
operator|)
operator|*
literal|120
argument_list|)
expr_stmt|;
comment|// We do not set "pixel" delta if it is only measured in ticks.
if|if
condition|(
name|scrollingDevice
operator|.
name|verticalIncrement
operator|>
literal|1
condition|)
name|rawDelta
operator|.
name|setY
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scrollingDevice
operator|.
name|orientations
operator|&
name|Qt
operator|::
name|Horizontal
condition|)
block|{
if|if
condition|(
name|xi2GetValuatorValueIfSet
argument_list|(
name|xiDeviceEvent
argument_list|,
name|scrollingDevice
operator|.
name|horizontalIndex
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|double
name|delta
init|=
name|scrollingDevice
operator|.
name|lastScrollPosition
operator|.
name|x
argument_list|()
operator|-
name|value
decl_stmt|;
name|scrollingDevice
operator|.
name|lastScrollPosition
operator|.
name|setX
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|angleDelta
operator|.
name|setX
argument_list|(
operator|(
name|delta
operator|/
name|scrollingDevice
operator|.
name|horizontalIncrement
operator|)
operator|*
literal|120
argument_list|)
expr_stmt|;
comment|// We do not set "pixel" delta if it is only measured in ticks.
if|if
condition|(
name|scrollingDevice
operator|.
name|horizontalIncrement
operator|>
literal|1
condition|)
name|rawDelta
operator|.
name|setX
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|angleDelta
operator|.
name|isNull
argument_list|()
condition|)
block|{
specifier|const
name|int
name|dpr
init|=
name|int
argument_list|(
name|platformWindow
operator|->
name|devicePixelRatio
argument_list|()
argument_list|)
decl_stmt|;
name|QPoint
name|local
argument_list|(
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|event_x
argument_list|)
operator|/
name|dpr
argument_list|,
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|event_y
argument_list|)
operator|/
name|dpr
argument_list|)
decl_stmt|;
name|QPoint
name|global
argument_list|(
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|root_x
argument_list|)
operator|/
name|dpr
argument_list|,
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|root_y
argument_list|)
operator|/
name|dpr
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
init|=
name|keyboard
argument_list|()
operator|->
name|translateModifiers
argument_list|(
name|xiDeviceEvent
operator|->
name|mods
operator|.
name|effective_mods
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifiers
operator|&
name|Qt
operator|::
name|AltModifier
condition|)
block|{
name|std
operator|::
name|swap
argument_list|(
name|angleDelta
operator|.
name|rx
argument_list|()
argument_list|,
name|angleDelta
operator|.
name|ry
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|swap
argument_list|(
name|rawDelta
operator|.
name|rx
argument_list|()
argument_list|,
name|rawDelta
operator|.
name|ry
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QWindowSystemInterface
operator|::
name|handleWheelEvent
argument_list|(
name|platformWindow
operator|->
name|window
argument_list|()
argument_list|,
name|xiEvent
operator|->
name|time
argument_list|,
name|local
argument_list|,
name|global
argument_list|,
name|rawDelta
argument_list|,
name|angleDelta
argument_list|,
name|modifiers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|xiEvent
operator|->
name|evtype
operator|==
name|XI_ButtonRelease
operator|&&
name|scrollingDevice
operator|.
name|legacyOrientations
condition|)
block|{
name|xXIDeviceEvent
modifier|*
name|xiDeviceEvent
init|=
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|QXcbWindow
modifier|*
name|platformWindow
init|=
name|platformWindowFromId
argument_list|(
name|xiDeviceEvent
operator|->
name|event
argument_list|)
condition|)
block|{
name|QPoint
name|angleDelta
decl_stmt|;
if|if
condition|(
name|scrollingDevice
operator|.
name|legacyOrientations
operator|&
name|Qt
operator|::
name|Vertical
condition|)
block|{
if|if
condition|(
name|xiDeviceEvent
operator|->
name|detail
operator|==
literal|4
condition|)
name|angleDelta
operator|.
name|setY
argument_list|(
literal|120
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xiDeviceEvent
operator|->
name|detail
operator|==
literal|5
condition|)
name|angleDelta
operator|.
name|setY
argument_list|(
operator|-
literal|120
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scrollingDevice
operator|.
name|legacyOrientations
operator|&
name|Qt
operator|::
name|Horizontal
condition|)
block|{
if|if
condition|(
name|xiDeviceEvent
operator|->
name|detail
operator|==
literal|6
condition|)
name|angleDelta
operator|.
name|setX
argument_list|(
literal|120
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xiDeviceEvent
operator|->
name|detail
operator|==
literal|7
condition|)
name|angleDelta
operator|.
name|setX
argument_list|(
operator|-
literal|120
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|angleDelta
operator|.
name|isNull
argument_list|()
condition|)
block|{
specifier|const
name|int
name|dpr
init|=
name|int
argument_list|(
name|platformWindow
operator|->
name|devicePixelRatio
argument_list|()
argument_list|)
decl_stmt|;
name|QPoint
name|local
argument_list|(
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|event_x
argument_list|)
operator|/
name|dpr
argument_list|,
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|event_y
argument_list|)
operator|/
name|dpr
argument_list|)
decl_stmt|;
name|QPoint
name|global
argument_list|(
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|root_x
argument_list|)
operator|/
name|dpr
argument_list|,
name|fixed1616ToReal
argument_list|(
name|xiDeviceEvent
operator|->
name|root_y
argument_list|)
operator|/
name|dpr
argument_list|)
decl_stmt|;
name|Qt
operator|::
name|KeyboardModifiers
name|modifiers
init|=
name|keyboard
argument_list|()
operator|->
name|translateModifiers
argument_list|(
name|xiDeviceEvent
operator|->
name|mods
operator|.
name|effective_mods
argument_list|)
decl_stmt|;
if|if
condition|(
name|modifiers
operator|&
name|Qt
operator|::
name|AltModifier
condition|)
name|std
operator|::
name|swap
argument_list|(
name|angleDelta
operator|.
name|rx
argument_list|()
argument_list|,
name|angleDelta
operator|.
name|ry
argument_list|()
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleWheelEvent
argument_list|(
name|platformWindow
operator|->
name|window
argument_list|()
argument_list|,
name|xiEvent
operator|->
name|time
argument_list|,
name|local
argument_list|,
name|global
argument_list|,
name|QPoint
argument_list|()
argument_list|,
name|angleDelta
argument_list|,
name|modifiers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|scrollingDevice
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// XCB_USE_XINPUT21
block|}
end_function
begin_function
DECL|function|xiToQtMouseButton
specifier|static
name|Qt
operator|::
name|MouseButton
name|xiToQtMouseButton
parameter_list|(
name|uint32_t
name|b
parameter_list|)
block|{
switch|switch
condition|(
name|b
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Qt
operator|::
name|LeftButton
return|;
case|case
literal|2
case|:
return|return
name|Qt
operator|::
name|MiddleButton
return|;
case|case
literal|3
case|:
return|return
name|Qt
operator|::
name|RightButton
return|;
comment|// 4-7 are for scrolling
default|default:
break|break;
block|}
if|if
condition|(
name|b
operator|>=
literal|8
operator|&&
name|b
operator|<=
name|Qt
operator|::
name|MaxMouseButton
condition|)
return|return
cast|static_cast
argument_list|<
name|Qt
operator|::
name|MouseButton
argument_list|>
argument_list|(
name|Qt
operator|::
name|BackButton
operator|<<
operator|(
name|b
operator|-
literal|8
operator|)
argument_list|)
return|;
return|return
name|Qt
operator|::
name|NoButton
return|;
block|}
end_function
begin_function
DECL|function|toolIdToTabletDevice
specifier|static
name|QTabletEvent
operator|::
name|TabletDevice
name|toolIdToTabletDevice
parameter_list|(
name|quint32
name|toolId
parameter_list|)
block|{
comment|// keep in sync with wacom_intuos_inout() in Linux kernel driver wacom_wac.c
switch|switch
condition|(
name|toolId
condition|)
block|{
case|case
literal|0xd12
case|:
case|case
literal|0x912
case|:
case|case
literal|0x112
case|:
case|case
literal|0x913
case|:
comment|/* Intuos3 Airbrush */
case|case
literal|0x91b
case|:
comment|/* Intuos3 Airbrush Eraser */
case|case
literal|0x902
case|:
comment|/* Intuos4/5 13HD/24HD Airbrush */
case|case
literal|0x90a
case|:
comment|/* Intuos4/5 13HD/24HD Airbrush Eraser */
case|case
literal|0x100902
case|:
comment|/* Intuos4/5 13HD/24HD Airbrush */
case|case
literal|0x10090a
case|:
comment|/* Intuos4/5 13HD/24HD Airbrush Eraser */
return|return
name|QTabletEvent
operator|::
name|Airbrush
return|;
case|case
literal|0x007
case|:
comment|/* Mouse 4D and 2D */
case|case
literal|0x09c
case|:
case|case
literal|0x094
case|:
return|return
name|QTabletEvent
operator|::
name|FourDMouse
return|;
case|case
literal|0x017
case|:
comment|/* Intuos3 2D Mouse */
case|case
literal|0x806
case|:
comment|/* Intuos4 Mouse */
case|case
literal|0x096
case|:
comment|/* Lens cursor */
case|case
literal|0x097
case|:
comment|/* Intuos3 Lens cursor */
case|case
literal|0x006
case|:
comment|/* Intuos4 Lens cursor */
return|return
name|QTabletEvent
operator|::
name|Puck
return|;
case|case
literal|0x885
case|:
comment|/* Intuos3 Art Pen (Marker Pen) */
case|case
literal|0x100804
case|:
comment|/* Intuos4/5 13HD/24HD Art Pen */
case|case
literal|0x10080c
case|:
comment|/* Intuos4/5 13HD/24HD Art Pen Eraser */
return|return
name|QTabletEvent
operator|::
name|RotationStylus
return|;
case|case
literal|0
case|:
return|return
name|QTabletEvent
operator|::
name|NoDevice
return|;
block|}
return|return
name|QTabletEvent
operator|::
name|Stylus
return|;
comment|// Safe default assumption if nonzero
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_TABLETEVENT
end_ifndef
begin_function
DECL|function|xi2HandleTabletEvent
name|bool
name|QXcbConnection
operator|::
name|xi2HandleTabletEvent
parameter_list|(
name|void
modifier|*
name|event
parameter_list|,
name|TabletData
modifier|*
name|tabletData
parameter_list|)
block|{
name|bool
name|handled
init|=
literal|true
decl_stmt|;
name|Display
modifier|*
name|xDisplay
init|=
cast|static_cast
argument_list|<
name|Display
operator|*
argument_list|>
argument_list|(
name|m_xlib_display
argument_list|)
decl_stmt|;
name|xXIGenericDeviceEvent
modifier|*
name|xiEvent
init|=
cast|static_cast
argument_list|<
name|xXIGenericDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|xiEvent
operator|->
name|evtype
condition|)
block|{
case|case
name|XI_ButtonPress
case|:
block|{
name|Qt
operator|::
name|MouseButton
name|b
init|=
name|xiToQtMouseButton
argument_list|(
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|detail
argument_list|)
decl_stmt|;
name|tabletData
operator|->
name|buttons
operator||=
name|b
expr_stmt|;
name|xi2ReportTabletEvent
argument_list|(
operator|*
name|tabletData
argument_list|,
name|xiEvent
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XI_ButtonRelease
case|:
block|{
name|Qt
operator|::
name|MouseButton
name|b
init|=
name|xiToQtMouseButton
argument_list|(
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
operator|->
name|detail
argument_list|)
decl_stmt|;
name|tabletData
operator|->
name|buttons
operator|^=
name|b
expr_stmt|;
name|xi2ReportTabletEvent
argument_list|(
operator|*
name|tabletData
argument_list|,
name|xiEvent
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XI_Motion
case|:
comment|// Report TabletMove only when the stylus is touching the tablet or any button is pressed.
comment|// TODO: report proximity (hover) motion (no suitable Qt event exists yet).
if|if
condition|(
name|tabletData
operator|->
name|buttons
operator|!=
name|Qt
operator|::
name|NoButton
condition|)
name|xi2ReportTabletEvent
argument_list|(
operator|*
name|tabletData
argument_list|,
name|xiEvent
argument_list|)
expr_stmt|;
break|break;
case|case
name|XI_PropertyEvent
case|:
block|{
comment|// This is the wacom driver's way of reporting tool proximity.
comment|// The evdev driver doesn't do it this way.
name|xXIPropertyEvent
modifier|*
name|ev
init|=
cast|reinterpret_cast
argument_list|<
name|xXIPropertyEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
name|ev
operator|->
name|what
operator|==
name|XIPropertyModified
condition|)
block|{
if|if
condition|(
name|ev
operator|->
name|property
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|WacomSerialIDs
argument_list|)
condition|)
block|{
enum|enum
name|WacomSerialIndex
block|{
name|_WACSER_USB_ID
init|=
literal|0
block|,
name|_WACSER_LAST_TOOL_SERIAL
block|,
name|_WACSER_LAST_TOOL_ID
block|,
name|_WACSER_TOOL_SERIAL
block|,
name|_WACSER_TOOL_ID
block|,
name|_WACSER_COUNT
block|}
enum|;
name|Atom
name|propType
decl_stmt|;
name|int
name|propFormat
decl_stmt|;
name|unsigned
name|long
name|numItems
decl_stmt|,
name|bytesAfter
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|XIGetProperty
argument_list|(
name|xDisplay
argument_list|,
name|tabletData
operator|->
name|deviceId
argument_list|,
name|ev
operator|->
name|property
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|,
literal|0
argument_list|,
name|AnyPropertyType
argument_list|,
operator|&
name|propType
argument_list|,
operator|&
name|propFormat
argument_list|,
operator|&
name|numItems
argument_list|,
operator|&
name|bytesAfter
argument_list|,
operator|&
name|data
argument_list|)
operator|==
name|Success
condition|)
block|{
if|if
condition|(
name|propType
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|INTEGER
argument_list|)
operator|&&
name|propFormat
operator|==
literal|32
operator|&&
name|numItems
operator|==
name|_WACSER_COUNT
condition|)
block|{
name|quint32
modifier|*
name|ptr
init|=
cast|reinterpret_cast
argument_list|<
name|quint32
operator|*
argument_list|>
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|quint32
name|tool
init|=
name|ptr
index|[
name|_WACSER_TOOL_ID
index|]
decl_stmt|;
comment|// Workaround for http://sourceforge.net/p/linuxwacom/bugs/246/
comment|// e.g. on Thinkpad Helix, tool ID will be 0 and serial will be 1
if|if
condition|(
operator|!
name|tool
operator|&&
name|ptr
index|[
name|_WACSER_TOOL_SERIAL
index|]
condition|)
name|tool
operator|=
name|ptr
index|[
name|_WACSER_TOOL_SERIAL
index|]
expr_stmt|;
comment|// The property change event informs us which tool is in proximity or which one left proximity.
if|if
condition|(
name|tool
condition|)
block|{
name|tabletData
operator|->
name|inProximity
operator|=
literal|true
expr_stmt|;
name|tabletData
operator|->
name|tool
operator|=
name|toolIdToTabletDevice
argument_list|(
name|tool
argument_list|)
expr_stmt|;
name|tabletData
operator|->
name|serialId
operator|=
name|qint64
argument_list|(
name|ptr
index|[
name|_WACSER_USB_ID
index|]
argument_list|)
operator|<<
literal|32
operator||
name|qint64
argument_list|(
name|ptr
index|[
name|_WACSER_TOOL_SERIAL
index|]
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleTabletEnterProximityEvent
argument_list|(
name|tabletData
operator|->
name|tool
argument_list|,
name|tabletData
operator|->
name|pointerType
argument_list|,
name|tabletData
operator|->
name|serialId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tabletData
operator|->
name|inProximity
operator|=
literal|false
expr_stmt|;
name|tabletData
operator|->
name|tool
operator|=
name|toolIdToTabletDevice
argument_list|(
name|ptr
index|[
name|_WACSER_LAST_TOOL_ID
index|]
argument_list|)
expr_stmt|;
comment|// Workaround for http://sourceforge.net/p/linuxwacom/bugs/246/
comment|// e.g. on Thinkpad Helix, tool ID will be 0 and serial will be 1
if|if
condition|(
operator|!
name|tabletData
operator|->
name|tool
condition|)
name|tabletData
operator|->
name|tool
operator|=
name|toolIdToTabletDevice
argument_list|(
name|ptr
index|[
name|_WACSER_LAST_TOOL_SERIAL
index|]
argument_list|)
expr_stmt|;
name|tabletData
operator|->
name|serialId
operator|=
name|qint64
argument_list|(
name|ptr
index|[
name|_WACSER_USB_ID
index|]
argument_list|)
operator|<<
literal|32
operator||
name|qint64
argument_list|(
name|ptr
index|[
name|_WACSER_LAST_TOOL_SERIAL
index|]
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleTabletLeaveProximityEvent
argument_list|(
name|tabletData
operator|->
name|tool
argument_list|,
name|tabletData
operator|->
name|pointerType
argument_list|,
name|tabletData
operator|->
name|serialId
argument_list|)
expr_stmt|;
block|}
comment|// TODO maybe have a hash of tabletData->deviceId to device data so we can
comment|// look up the tablet name here, and distinguish multiple tablets
name|qCDebug
argument_list|(
name|lcQpaXInput
argument_list|,
literal|"XI2 proximity change on tablet %d (USB %x): last tool: %x id %x current tool: %x id %x TabletDevice %d"
argument_list|,
name|ev
operator|->
name|deviceid
argument_list|,
name|ptr
index|[
name|_WACSER_USB_ID
index|]
argument_list|,
name|ptr
index|[
name|_WACSER_LAST_TOOL_SERIAL
index|]
argument_list|,
name|ptr
index|[
name|_WACSER_LAST_TOOL_ID
index|]
argument_list|,
name|ptr
index|[
name|_WACSER_TOOL_SERIAL
index|]
argument_list|,
name|ptr
index|[
name|_WACSER_TOOL_ID
index|]
argument_list|,
name|tabletData
operator|->
name|tool
argument_list|)
expr_stmt|;
block|}
name|XFree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
default|default:
name|handled
operator|=
literal|false
expr_stmt|;
break|break;
block|}
return|return
name|handled
return|;
block|}
end_function
begin_function
DECL|function|xi2ReportTabletEvent
name|void
name|QXcbConnection
operator|::
name|xi2ReportTabletEvent
parameter_list|(
name|TabletData
modifier|&
name|tabletData
parameter_list|,
name|void
modifier|*
name|event
parameter_list|)
block|{
name|xXIDeviceEvent
modifier|*
name|ev
init|=
cast|reinterpret_cast
argument_list|<
name|xXIDeviceEvent
operator|*
argument_list|>
argument_list|(
name|event
argument_list|)
decl_stmt|;
name|QXcbWindow
modifier|*
name|xcbWindow
init|=
name|platformWindowFromId
argument_list|(
name|ev
operator|->
name|event
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xcbWindow
condition|)
return|return;
name|QWindow
modifier|*
name|window
init|=
name|xcbWindow
operator|->
name|window
argument_list|()
decl_stmt|;
specifier|const
name|double
name|scale
init|=
literal|65536.0
decl_stmt|;
name|QPointF
name|local
argument_list|(
name|ev
operator|->
name|event_x
operator|/
name|scale
argument_list|,
name|ev
operator|->
name|event_y
operator|/
name|scale
argument_list|)
decl_stmt|;
name|QPointF
name|global
argument_list|(
name|ev
operator|->
name|root_x
operator|/
name|scale
argument_list|,
name|ev
operator|->
name|root_y
operator|/
name|scale
argument_list|)
decl_stmt|;
name|double
name|pressure
init|=
literal|0
decl_stmt|,
name|rotation
init|=
literal|0
decl_stmt|,
name|tangentialPressure
init|=
literal|0
decl_stmt|;
name|int
name|xTilt
init|=
literal|0
decl_stmt|,
name|yTilt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|QHash
argument_list|<
name|int
argument_list|,
name|TabletData
operator|::
name|ValuatorClassInfo
argument_list|>
operator|::
name|iterator
name|it
init|=
name|tabletData
operator|.
name|valuatorInfo
operator|.
name|begin
argument_list|()
init|,
name|ite
init|=
name|tabletData
operator|.
name|valuatorInfo
operator|.
name|end
argument_list|()
init|;
name|it
operator|!=
name|ite
condition|;
operator|++
name|it
control|)
block|{
name|int
name|valuator
init|=
name|it
operator|.
name|key
argument_list|()
decl_stmt|;
name|TabletData
operator|::
name|ValuatorClassInfo
modifier|&
name|classInfo
argument_list|(
name|it
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
name|xi2GetValuatorValueIfSet
argument_list|(
name|event
argument_list|,
name|classInfo
operator|.
name|number
argument_list|,
operator|&
name|classInfo
operator|.
name|curVal
argument_list|)
expr_stmt|;
name|double
name|normalizedValue
init|=
operator|(
name|classInfo
operator|.
name|curVal
operator|-
name|classInfo
operator|.
name|minVal
operator|)
operator|/
operator|(
name|classInfo
operator|.
name|maxVal
operator|-
name|classInfo
operator|.
name|minVal
operator|)
decl_stmt|;
switch|switch
condition|(
name|valuator
condition|)
block|{
case|case
name|QXcbAtom
operator|::
name|AbsPressure
case|:
name|pressure
operator|=
name|normalizedValue
expr_stmt|;
break|break;
case|case
name|QXcbAtom
operator|::
name|AbsTiltX
case|:
name|xTilt
operator|=
name|classInfo
operator|.
name|curVal
expr_stmt|;
break|break;
case|case
name|QXcbAtom
operator|::
name|AbsTiltY
case|:
name|yTilt
operator|=
name|classInfo
operator|.
name|curVal
expr_stmt|;
break|break;
case|case
name|QXcbAtom
operator|::
name|AbsWheel
case|:
switch|switch
condition|(
name|tabletData
operator|.
name|tool
condition|)
block|{
case|case
name|QTabletEvent
operator|::
name|Airbrush
case|:
name|tangentialPressure
operator|=
name|normalizedValue
operator|*
literal|2.0
operator|-
literal|1.0
expr_stmt|;
comment|// Convert 0..1 range to -1..+1 range
break|break;
case|case
name|QTabletEvent
operator|::
name|RotationStylus
case|:
name|rotation
operator|=
name|normalizedValue
operator|*
literal|360.0
operator|-
literal|180.0
expr_stmt|;
comment|// Convert 0..1 range to -180..+180 degrees
break|break;
default|default:
comment|// Other types of styli do not use this valuator
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|Q_UNLIKELY
argument_list|(
name|lcQpaXInput
argument_list|()
operator|.
name|isDebugEnabled
argument_list|()
argument_list|)
condition|)
name|qCDebug
argument_list|(
name|lcQpaXInput
argument_list|,
literal|"XI2 event on tablet %d with tool %d type %d seq %d detail %d pos %6.1f, %6.1f root pos %6.1f, %6.1f buttons 0x%x pressure %4.2lf tilt %d, %d rotation %6.2lf"
argument_list|,
name|ev
operator|->
name|deviceid
argument_list|,
name|tabletData
operator|.
name|tool
argument_list|,
name|ev
operator|->
name|evtype
argument_list|,
name|ev
operator|->
name|sequenceNumber
argument_list|,
name|ev
operator|->
name|detail
argument_list|,
name|fixed1616ToReal
argument_list|(
name|ev
operator|->
name|event_x
argument_list|)
argument_list|,
name|fixed1616ToReal
argument_list|(
name|ev
operator|->
name|event_y
argument_list|)
argument_list|,
name|fixed1616ToReal
argument_list|(
name|ev
operator|->
name|root_x
argument_list|)
argument_list|,
name|fixed1616ToReal
argument_list|(
name|ev
operator|->
name|root_y
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|tabletData
operator|.
name|buttons
argument_list|,
name|pressure
argument_list|,
name|xTilt
argument_list|,
name|yTilt
argument_list|,
name|rotation
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleTabletEvent
argument_list|(
name|window
argument_list|,
name|local
argument_list|,
name|global
argument_list|,
name|tabletData
operator|.
name|tool
argument_list|,
name|tabletData
operator|.
name|pointerType
argument_list|,
name|tabletData
operator|.
name|buttons
argument_list|,
name|pressure
argument_list|,
name|xTilt
argument_list|,
name|yTilt
argument_list|,
name|tangentialPressure
argument_list|,
name|rotation
argument_list|,
literal|0
argument_list|,
name|tabletData
operator|.
name|serialId
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_TABLETEVENT
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// XCB_USE_XINPUT2
end_comment
end_unit
