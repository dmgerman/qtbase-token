begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qxcbscreen.h"
end_include
begin_include
include|#
directive|include
file|"qxcbwindow.h"
end_include
begin_include
include|#
directive|include
file|"qxcbcursor.h"
end_include
begin_include
include|#
directive|include
file|"qxcbimage.h"
end_include
begin_include
include|#
directive|include
file|"qnamespace.h"
end_include
begin_include
include|#
directive|include
file|"qxcbxsettings.h"
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_include
include|#
directive|include
file|<qpa/qwindowsysteminterface.h>
end_include
begin_include
include|#
directive|include
file|<private/qmath_p.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_constructor
DECL|function|QXcbScreen
name|QXcbScreen
operator|::
name|QXcbScreen
parameter_list|(
name|QXcbConnection
modifier|*
name|connection
parameter_list|,
name|xcb_screen_t
modifier|*
name|scr
parameter_list|,
name|xcb_randr_get_output_info_reply_t
modifier|*
name|output
parameter_list|,
name|QString
name|outputName
parameter_list|,
name|int
name|number
parameter_list|)
member_init_list|:
name|QXcbObject
argument_list|(
name|connection
argument_list|)
member_init_list|,
name|m_screen
argument_list|(
name|scr
argument_list|)
member_init_list|,
name|m_crtc
argument_list|(
name|output
condition|?
name|output
operator|->
name|crtc
else|:
literal|0
argument_list|)
member_init_list|,
name|m_outputName
argument_list|(
name|outputName
argument_list|)
member_init_list|,
name|m_sizeMillimeters
argument_list|(
name|output
condition|?
name|QSize
argument_list|(
name|output
operator|->
name|mm_width
argument_list|,
name|output
operator|->
name|mm_height
argument_list|)
else|:
name|QSize
argument_list|()
argument_list|)
member_init_list|,
name|m_virtualSize
argument_list|(
name|scr
operator|->
name|width_in_pixels
argument_list|,
name|scr
operator|->
name|height_in_pixels
argument_list|)
member_init_list|,
name|m_virtualSizeMillimeters
argument_list|(
name|scr
operator|->
name|width_in_millimeters
argument_list|,
name|scr
operator|->
name|height_in_millimeters
argument_list|)
member_init_list|,
name|m_orientation
argument_list|(
name|Qt
operator|::
name|PrimaryOrientation
argument_list|)
member_init_list|,
name|m_number
argument_list|(
name|number
argument_list|)
member_init_list|,
name|m_refreshRate
argument_list|(
literal|60
argument_list|)
member_init_list|,
name|m_forcedDpi
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|m_hintStyle
argument_list|(
name|QFontEngine
operator|::
name|HintStyle
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
member_init_list|,
name|m_xSettings
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
name|connection
operator|->
name|hasXRandr
argument_list|()
condition|)
name|xcb_randr_select_input
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|screen
argument_list|()
operator|->
name|root
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|updateGeometry
argument_list|(
name|output
condition|?
name|output
operator|->
name|timestamp
else|:
literal|0
argument_list|)
expr_stmt|;
name|updateRefreshRate
argument_list|()
expr_stmt|;
comment|// On VNC, it can be that physical size is unknown while
comment|// virtual size is known (probably back-calculated from DPI and resolution)
if|if
condition|(
name|m_sizeMillimeters
operator|.
name|isEmpty
argument_list|()
condition|)
name|m_sizeMillimeters
operator|=
name|m_virtualSizeMillimeters
expr_stmt|;
if|if
condition|(
name|m_geometry
operator|.
name|isEmpty
argument_list|()
condition|)
name|m_geometry
operator|=
name|QRect
argument_list|(
name|QPoint
argument_list|()
argument_list|,
name|m_virtualSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_availableGeometry
operator|.
name|isEmpty
argument_list|()
condition|)
name|m_availableGeometry
operator|=
name|QRect
argument_list|(
name|QPoint
argument_list|()
argument_list|,
name|m_virtualSize
argument_list|)
expr_stmt|;
name|readXResources
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_XCB_DEBUG
name|qDebug
argument_list|()
expr_stmt|;
name|qDebug
argument_list|(
literal|"Screen output %s of xcb screen %d:"
argument_list|,
name|m_outputName
operator|.
name|toUtf8
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|m_number
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  width..........: %lf"
argument_list|,
name|m_sizeMillimeters
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  height.........: %lf"
argument_list|,
name|m_sizeMillimeters
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  geometry.......: %d x %d +%d +%d"
argument_list|,
name|m_geometry
operator|.
name|width
argument_list|()
argument_list|,
name|m_geometry
operator|.
name|height
argument_list|()
argument_list|,
name|m_geometry
operator|.
name|x
argument_list|()
argument_list|,
name|m_geometry
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  virtual width..: %lf"
argument_list|,
name|m_virtualSizeMillimeters
operator|.
name|width
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  virtual height.: %lf"
argument_list|,
name|m_virtualSizeMillimeters
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  virtual geom...: %d x %d"
argument_list|,
name|m_virtualSize
operator|.
name|width
argument_list|()
argument_list|,
name|m_virtualSize
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  avail virt geom: %d x %d +%d +%d"
argument_list|,
name|m_availableGeometry
operator|.
name|width
argument_list|()
argument_list|,
name|m_availableGeometry
operator|.
name|height
argument_list|()
argument_list|,
name|m_availableGeometry
operator|.
name|x
argument_list|()
argument_list|,
name|m_availableGeometry
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  depth..........: %d"
argument_list|,
name|screen
argument_list|()
operator|->
name|root_depth
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  white pixel....: %x"
argument_list|,
name|screen
argument_list|()
operator|->
name|white_pixel
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  black pixel....: %x"
argument_list|,
name|screen
argument_list|()
operator|->
name|black_pixel
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  refresh rate...: %d"
argument_list|,
name|m_refreshRate
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"  root ID........: %x"
argument_list|,
name|screen
argument_list|()
operator|->
name|root
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QScopedPointer
argument_list|<
name|xcb_get_window_attributes_reply_t
argument_list|,
name|QScopedPointerPodDeleter
argument_list|>
name|rootAttribs
argument_list|(
name|xcb_get_window_attributes_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcb_get_window_attributes_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|screen
argument_list|()
operator|->
name|root
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|quint32
name|existingEventMask
init|=
name|rootAttribs
operator|.
name|isNull
argument_list|()
condition|?
literal|0
else|:
name|rootAttribs
operator|->
name|your_event_mask
decl_stmt|;
specifier|const
name|quint32
name|mask
init|=
name|XCB_CW_EVENT_MASK
decl_stmt|;
specifier|const
name|quint32
name|values
index|[]
init|=
block|{
comment|// XCB_CW_EVENT_MASK
name|XCB_EVENT_MASK_ENTER_WINDOW
operator||
name|XCB_EVENT_MASK_LEAVE_WINDOW
operator||
name|XCB_EVENT_MASK_PROPERTY_CHANGE
operator||
name|XCB_EVENT_MASK_STRUCTURE_NOTIFY
comment|// for the "MANAGER" atom (system tray notification).
operator||
name|existingEventMask
comment|// don't overwrite the event mask on the root window
block|}
decl_stmt|;
name|xcb_change_window_attributes
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|screen
argument_list|()
operator|->
name|root
argument_list|,
name|mask
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|xcb_get_property_reply_t
modifier|*
name|reply
init|=
name|xcb_get_property_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcb_get_property_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|screen
argument_list|()
operator|->
name|root
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_NET_SUPPORTING_WM_CHECK
argument_list|)
argument_list|,
name|XCB_ATOM_WINDOW
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
operator|&&
name|reply
operator|->
name|format
operator|==
literal|32
operator|&&
name|reply
operator|->
name|type
operator|==
name|XCB_ATOM_WINDOW
condition|)
block|{
name|xcb_window_t
name|windowManager
init|=
operator|*
operator|(
operator|(
name|xcb_window_t
operator|*
operator|)
name|xcb_get_property_value
argument_list|(
name|reply
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|windowManager
operator|!=
name|XCB_WINDOW_NONE
condition|)
block|{
name|xcb_get_property_reply_t
modifier|*
name|windowManagerReply
init|=
name|xcb_get_property_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcb_get_property_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|windowManager
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_NET_WM_NAME
argument_list|)
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|UTF8_STRING
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|windowManagerReply
operator|&&
name|windowManagerReply
operator|->
name|format
operator|==
literal|8
operator|&&
name|windowManagerReply
operator|->
name|type
operator|==
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|UTF8_STRING
argument_list|)
condition|)
block|{
name|m_windowManagerName
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|xcb_get_property_value
argument_list|(
name|windowManagerReply
argument_list|)
argument_list|,
name|xcb_get_property_value_length
argument_list|(
name|windowManagerReply
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_XCB_DEBUG
name|qDebug
argument_list|(
literal|"  window manager.: %s"
argument_list|,
name|qPrintable
argument_list|(
name|m_windowManagerName
argument_list|)
argument_list|)
expr_stmt|;
name|qDebug
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|free
argument_list|(
name|windowManagerReply
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
specifier|const
name|xcb_query_extension_reply_t
modifier|*
name|sync_reply
init|=
name|xcb_get_extension_data
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
operator|&
name|xcb_sync_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sync_reply
operator|||
operator|!
name|sync_reply
operator|->
name|present
condition|)
name|m_syncRequestSupported
operator|=
literal|false
expr_stmt|;
else|else
name|m_syncRequestSupported
operator|=
literal|true
expr_stmt|;
name|m_clientLeader
operator|=
name|xcb_generate_id
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
expr_stmt|;
name|Q_XCB_CALL2
argument_list|(
name|xcb_create_window
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_COPY_FROM_PARENT
argument_list|,
name|m_clientLeader
argument_list|,
name|screen
argument_list|()
operator|->
name|root
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|XCB_WINDOW_CLASS_INPUT_OUTPUT
argument_list|,
name|screen
argument_list|()
operator|->
name|root_visual
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|connection
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DEBUG
name|QByteArray
name|ba
argument_list|(
literal|"Qt client leader window for screen "
argument_list|)
decl_stmt|;
name|ba
operator|+=
name|m_outputName
operator|.
name|toUtf8
argument_list|()
expr_stmt|;
name|Q_XCB_CALL2
argument_list|(
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|m_clientLeader
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_NET_WM_NAME
argument_list|)
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|UTF8_STRING
argument_list|)
argument_list|,
literal|8
argument_list|,
name|ba
operator|.
name|length
argument_list|()
argument_list|,
name|ba
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|,
name|connection
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_XCB_CALL2
argument_list|(
name|xcb_change_property
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|XCB_PROP_MODE_REPLACE
argument_list|,
name|m_clientLeader
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|WM_CLIENT_LEADER
argument_list|)
argument_list|,
name|XCB_ATOM_WINDOW
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|,
operator|&
name|m_clientLeader
argument_list|)
argument_list|,
name|connection
argument_list|)
expr_stmt|;
name|xcb_depth_iterator_t
name|depth_iterator
init|=
name|xcb_screen_allowed_depths_iterator
argument_list|(
name|screen
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|depth_iterator
operator|.
name|rem
condition|)
block|{
name|xcb_depth_t
modifier|*
name|depth
init|=
name|depth_iterator
operator|.
name|data
decl_stmt|;
name|xcb_visualtype_iterator_t
name|visualtype_iterator
init|=
name|xcb_depth_visuals_iterator
argument_list|(
name|depth
argument_list|)
decl_stmt|;
while|while
condition|(
name|visualtype_iterator
operator|.
name|rem
condition|)
block|{
name|xcb_visualtype_t
modifier|*
name|visualtype
init|=
name|visualtype_iterator
operator|.
name|data
decl_stmt|;
name|m_visuals
operator|.
name|insert
argument_list|(
name|visualtype
operator|->
name|visual_id
argument_list|,
operator|*
name|visualtype
argument_list|)
expr_stmt|;
name|xcb_visualtype_next
argument_list|(
operator|&
name|visualtype_iterator
argument_list|)
expr_stmt|;
block|}
name|xcb_depth_next
argument_list|(
operator|&
name|depth_iterator
argument_list|)
expr_stmt|;
block|}
name|m_cursor
operator|=
operator|new
name|QXcbCursor
argument_list|(
name|connection
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QXcbScreen
name|QXcbScreen
operator|::
name|~
name|QXcbScreen
parameter_list|()
block|{
operator|delete
name|m_cursor
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|topLevelAt
name|QWindow
modifier|*
name|QXcbScreen
operator|::
name|topLevelAt
parameter_list|(
specifier|const
name|QPoint
modifier|&
name|p
parameter_list|)
specifier|const
block|{
name|xcb_window_t
name|root
init|=
name|m_screen
operator|->
name|root
decl_stmt|;
name|int
name|x
init|=
name|p
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|p
operator|.
name|y
argument_list|()
decl_stmt|;
name|xcb_window_t
name|parent
init|=
name|root
decl_stmt|;
name|xcb_window_t
name|child
init|=
name|root
decl_stmt|;
do|do
block|{
name|xcb_translate_coordinates_cookie_t
name|translate_cookie
init|=
name|xcb_translate_coordinates_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|parent
argument_list|,
name|child
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|xcb_translate_coordinates_reply_t
modifier|*
name|translate_reply
init|=
name|xcb_translate_coordinates_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|translate_cookie
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|translate_reply
condition|)
block|{
return|return
literal|0
return|;
block|}
name|parent
operator|=
name|child
expr_stmt|;
name|child
operator|=
name|translate_reply
operator|->
name|child
expr_stmt|;
name|x
operator|=
name|translate_reply
operator|->
name|dst_x
expr_stmt|;
name|y
operator|=
name|translate_reply
operator|->
name|dst_y
expr_stmt|;
name|free
argument_list|(
name|translate_reply
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|child
operator|||
name|child
operator|==
name|root
condition|)
return|return
literal|0
return|;
name|QPlatformWindow
modifier|*
name|platformWindow
init|=
name|connection
argument_list|()
operator|->
name|platformWindowFromId
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|platformWindow
condition|)
return|return
name|platformWindow
operator|->
name|window
argument_list|()
return|;
block|}
do|while
condition|(
name|parent
operator|!=
name|child
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|windowShown
name|void
name|QXcbScreen
operator|::
name|windowShown
parameter_list|(
name|QXcbWindow
modifier|*
name|window
parameter_list|)
block|{
comment|// Freedesktop.org Startup Notification
if|if
condition|(
operator|!
name|connection
argument_list|()
operator|->
name|startupId
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|window
operator|->
name|window
argument_list|()
operator|->
name|isTopLevel
argument_list|()
condition|)
block|{
name|sendStartupMessage
argument_list|(
name|QByteArrayLiteral
argument_list|(
literal|"remove: ID="
argument_list|)
operator|+
name|connection
argument_list|()
operator|->
name|startupId
argument_list|()
argument_list|)
expr_stmt|;
name|connection
argument_list|()
operator|->
name|clearStartupId
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|sendStartupMessage
name|void
name|QXcbScreen
operator|::
name|sendStartupMessage
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|message
parameter_list|)
specifier|const
block|{
name|xcb_window_t
name|rootWindow
init|=
name|root
argument_list|()
decl_stmt|;
name|xcb_client_message_event_t
name|ev
decl_stmt|;
name|ev
operator|.
name|response_type
operator|=
name|XCB_CLIENT_MESSAGE
expr_stmt|;
name|ev
operator|.
name|format
operator|=
literal|8
expr_stmt|;
name|ev
operator|.
name|type
operator|=
name|connection
argument_list|()
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_NET_STARTUP_INFO_BEGIN
argument_list|)
expr_stmt|;
name|ev
operator|.
name|window
operator|=
name|rootWindow
expr_stmt|;
name|int
name|sent
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
name|message
operator|.
name|length
argument_list|()
operator|+
literal|1
decl_stmt|;
comment|// include NUL byte
specifier|const
name|char
modifier|*
name|data
init|=
name|message
operator|.
name|constData
argument_list|()
decl_stmt|;
do|do
block|{
if|if
condition|(
name|sent
operator|==
literal|20
condition|)
name|ev
operator|.
name|type
operator|=
name|connection
argument_list|()
operator|->
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_NET_STARTUP_INFO
argument_list|)
expr_stmt|;
specifier|const
name|int
name|start
init|=
name|sent
decl_stmt|;
specifier|const
name|int
name|numBytes
init|=
name|qMin
argument_list|(
name|length
operator|-
name|start
argument_list|,
literal|20
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ev
operator|.
name|data
operator|.
name|data8
argument_list|,
name|data
operator|+
name|start
argument_list|,
name|numBytes
argument_list|)
expr_stmt|;
name|xcb_send_event
argument_list|(
name|connection
argument_list|()
operator|->
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|rootWindow
argument_list|,
name|XCB_EVENT_MASK_PROPERTY_CHANGE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|ev
argument_list|)
expr_stmt|;
name|sent
operator|+=
name|numBytes
expr_stmt|;
block|}
do|while
condition|(
name|sent
operator|<
name|length
condition|)
do|;
block|}
end_function
begin_function
DECL|function|visualForId
specifier|const
name|xcb_visualtype_t
modifier|*
name|QXcbScreen
operator|::
name|visualForId
parameter_list|(
name|xcb_visualid_t
name|visualid
parameter_list|)
specifier|const
block|{
name|QMap
argument_list|<
name|xcb_visualid_t
argument_list|,
name|xcb_visualtype_t
argument_list|>
operator|::
name|const_iterator
name|it
init|=
name|m_visuals
operator|.
name|find
argument_list|(
name|visualid
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|==
name|m_visuals
operator|.
name|constEnd
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
operator|&
operator|*
name|it
return|;
block|}
end_function
begin_function
DECL|function|format
name|QImage
operator|::
name|Format
name|QXcbScreen
operator|::
name|format
parameter_list|()
specifier|const
block|{
return|return
name|QImage
operator|::
name|Format_RGB32
return|;
block|}
end_function
begin_function
DECL|function|logicalDpi
name|QDpi
name|QXcbScreen
operator|::
name|logicalDpi
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|m_forcedDpi
operator|>
literal|0
condition|)
return|return
name|QDpi
argument_list|(
name|m_forcedDpi
argument_list|,
name|m_forcedDpi
argument_list|)
return|;
return|return
name|QDpi
argument_list|(
name|Q_MM_PER_INCH
operator|*
name|m_virtualSize
operator|.
name|width
argument_list|()
operator|/
name|m_virtualSizeMillimeters
operator|.
name|width
argument_list|()
argument_list|,
name|Q_MM_PER_INCH
operator|*
name|m_virtualSize
operator|.
name|height
argument_list|()
operator|/
name|m_virtualSizeMillimeters
operator|.
name|height
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|cursor
name|QPlatformCursor
modifier|*
name|QXcbScreen
operator|::
name|cursor
parameter_list|()
specifier|const
block|{
return|return
name|m_cursor
return|;
block|}
end_function
begin_comment
comment|/*!     \brief handle the XCB screen change event and update properties      On a mobile device, the ideal use case is that the accelerometer would     drive the orientation. This could be achieved by using QSensors to read the     accelerometer and adjusting the rotation in QML, or by reading the     orientation from the QScreen object and doing the same, or in many other     ways. However, on X we have the XRandR extension, which makes it possible     to have the whole screen rotated, so that individual apps DO NOT have to     rotate themselves. Apps could optionally use the     QScreen::primaryOrientation property to optimize layout though.     Furthermore, there is no support in X for accelerometer events anyway. So     it makes more sense on a Linux system running X to just run a daemon which     monitors the accelerometer and runs xrandr automatically to do the rotation,     then apps do not have to be aware of it (but probably the window manager     would resize them accordingly). updateGeometry() is written with this     design in mind. Therefore the physical geometry, available geometry,     virtual geometry, orientation and primaryOrientation should all change at     the same time.  On a system which cannot rotate the whole screen, it would     be correct for only the orientation (not the primary orientation) to     change. */
end_comment
begin_function
DECL|function|handleScreenChange
name|void
name|QXcbScreen
operator|::
name|handleScreenChange
parameter_list|(
name|xcb_randr_screen_change_notify_event_t
modifier|*
name|change_event
parameter_list|)
block|{
name|updateGeometry
argument_list|(
name|change_event
operator|->
name|config_timestamp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|change_event
operator|->
name|rotation
condition|)
block|{
case|case
name|XCB_RANDR_ROTATION_ROTATE_0
case|:
comment|// xrandr --rotate normal
name|m_orientation
operator|=
name|Qt
operator|::
name|LandscapeOrientation
expr_stmt|;
name|m_virtualSize
operator|.
name|setWidth
argument_list|(
name|change_event
operator|->
name|width
argument_list|)
expr_stmt|;
name|m_virtualSize
operator|.
name|setHeight
argument_list|(
name|change_event
operator|->
name|height
argument_list|)
expr_stmt|;
name|m_virtualSizeMillimeters
operator|.
name|setWidth
argument_list|(
name|change_event
operator|->
name|mwidth
argument_list|)
expr_stmt|;
name|m_virtualSizeMillimeters
operator|.
name|setHeight
argument_list|(
name|change_event
operator|->
name|mheight
argument_list|)
expr_stmt|;
break|break;
case|case
name|XCB_RANDR_ROTATION_ROTATE_90
case|:
comment|// xrandr --rotate left
name|m_orientation
operator|=
name|Qt
operator|::
name|PortraitOrientation
expr_stmt|;
name|m_virtualSize
operator|.
name|setWidth
argument_list|(
name|change_event
operator|->
name|height
argument_list|)
expr_stmt|;
name|m_virtualSize
operator|.
name|setHeight
argument_list|(
name|change_event
operator|->
name|width
argument_list|)
expr_stmt|;
name|m_virtualSizeMillimeters
operator|.
name|setWidth
argument_list|(
name|change_event
operator|->
name|mheight
argument_list|)
expr_stmt|;
name|m_virtualSizeMillimeters
operator|.
name|setHeight
argument_list|(
name|change_event
operator|->
name|mwidth
argument_list|)
expr_stmt|;
break|break;
case|case
name|XCB_RANDR_ROTATION_ROTATE_180
case|:
comment|// xrandr --rotate inverted
name|m_orientation
operator|=
name|Qt
operator|::
name|InvertedLandscapeOrientation
expr_stmt|;
name|m_virtualSize
operator|.
name|setWidth
argument_list|(
name|change_event
operator|->
name|width
argument_list|)
expr_stmt|;
name|m_virtualSize
operator|.
name|setHeight
argument_list|(
name|change_event
operator|->
name|height
argument_list|)
expr_stmt|;
name|m_virtualSizeMillimeters
operator|.
name|setWidth
argument_list|(
name|change_event
operator|->
name|mwidth
argument_list|)
expr_stmt|;
name|m_virtualSizeMillimeters
operator|.
name|setHeight
argument_list|(
name|change_event
operator|->
name|mheight
argument_list|)
expr_stmt|;
break|break;
case|case
name|XCB_RANDR_ROTATION_ROTATE_270
case|:
comment|// xrandr --rotate right
name|m_orientation
operator|=
name|Qt
operator|::
name|InvertedPortraitOrientation
expr_stmt|;
name|m_virtualSize
operator|.
name|setWidth
argument_list|(
name|change_event
operator|->
name|height
argument_list|)
expr_stmt|;
name|m_virtualSize
operator|.
name|setHeight
argument_list|(
name|change_event
operator|->
name|width
argument_list|)
expr_stmt|;
name|m_virtualSizeMillimeters
operator|.
name|setWidth
argument_list|(
name|change_event
operator|->
name|mheight
argument_list|)
expr_stmt|;
name|m_virtualSizeMillimeters
operator|.
name|setHeight
argument_list|(
name|change_event
operator|->
name|mwidth
argument_list|)
expr_stmt|;
break|break;
comment|// We don't need to do anything with these, since QScreen doesn't store reflection state,
comment|// and Qt-based applications probably don't need to care about it anyway.
case|case
name|XCB_RANDR_ROTATION_REFLECT_X
case|:
break|break;
case|case
name|XCB_RANDR_ROTATION_REFLECT_Y
case|:
break|break;
block|}
name|QWindowSystemInterface
operator|::
name|handleScreenGeometryChange
argument_list|(
name|QPlatformScreen
operator|::
name|screen
argument_list|()
argument_list|,
name|geometry
argument_list|()
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleScreenOrientationChange
argument_list|(
name|QPlatformScreen
operator|::
name|screen
argument_list|()
argument_list|,
name|m_orientation
argument_list|)
expr_stmt|;
name|QDpi
name|ldpi
init|=
name|logicalDpi
argument_list|()
decl_stmt|;
name|QWindowSystemInterface
operator|::
name|handleScreenLogicalDotsPerInchChange
argument_list|(
name|QPlatformScreen
operator|::
name|screen
argument_list|()
argument_list|,
name|ldpi
operator|.
name|first
argument_list|,
name|ldpi
operator|.
name|second
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateGeometry
name|void
name|QXcbScreen
operator|::
name|updateGeometry
parameter_list|(
name|xcb_timestamp_t
name|timestamp
parameter_list|)
block|{
if|if
condition|(
name|connection
argument_list|()
operator|->
name|hasXRandr
argument_list|()
condition|)
block|{
name|xcb_randr_get_crtc_info_reply_t
modifier|*
name|crtc
init|=
name|xcb_randr_get_crtc_info_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcb_randr_get_crtc_info_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|m_crtc
argument_list|,
name|timestamp
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|crtc
condition|)
block|{
name|m_geometry
operator|=
name|QRect
argument_list|(
name|crtc
operator|->
name|x
argument_list|,
name|crtc
operator|->
name|y
argument_list|,
name|crtc
operator|->
name|width
argument_list|,
name|crtc
operator|->
name|height
argument_list|)
expr_stmt|;
name|m_availableGeometry
operator|=
name|m_geometry
expr_stmt|;
name|free
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
block|}
name|xcb_get_property_reply_t
modifier|*
name|workArea
init|=
name|xcb_get_property_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcb_get_property_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|screen
argument_list|()
operator|->
name|root
argument_list|,
name|atom
argument_list|(
name|QXcbAtom
operator|::
name|_NET_WORKAREA
argument_list|)
argument_list|,
name|XCB_ATOM_CARDINAL
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|workArea
operator|&&
name|workArea
operator|->
name|type
operator|==
name|XCB_ATOM_CARDINAL
operator|&&
name|workArea
operator|->
name|format
operator|==
literal|32
operator|&&
name|workArea
operator|->
name|value_len
operator|>=
literal|4
condition|)
block|{
comment|// If workArea->value_len> 4, the remaining ones seem to be for virtual desktops.
comment|// But QScreen doesn't know about that concept.  In reality there could be a
comment|// "docked" panel (with _NET_WM_STRUT_PARTIAL atom set) on just one desktop.
comment|// But for now just assume the first 4 values give us the geometry of the
comment|// "work area", AKA "available geometry"
name|uint32_t
modifier|*
name|geom
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|xcb_get_property_value
argument_list|(
name|workArea
argument_list|)
decl_stmt|;
name|QRect
name|virtualAvailableGeometry
argument_list|(
name|geom
index|[
literal|0
index|]
argument_list|,
name|geom
index|[
literal|1
index|]
argument_list|,
name|geom
index|[
literal|2
index|]
argument_list|,
name|geom
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
comment|// Take the intersection of the desktop's available geometry with this screen's geometry
comment|// to get the part of the available geometry which belongs to this screen.
name|m_availableGeometry
operator|=
name|m_geometry
operator|&
name|virtualAvailableGeometry
expr_stmt|;
block|}
name|free
argument_list|(
name|workArea
argument_list|)
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleScreenAvailableGeometryChange
argument_list|(
name|QPlatformScreen
operator|::
name|screen
argument_list|()
argument_list|,
name|m_availableGeometry
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|updateRefreshRate
name|void
name|QXcbScreen
operator|::
name|updateRefreshRate
parameter_list|()
block|{
if|if
condition|(
operator|!
name|connection
argument_list|()
operator|->
name|hasXRandr
argument_list|()
condition|)
return|return;
name|int
name|rate
init|=
name|m_refreshRate
decl_stmt|;
name|xcb_randr_get_screen_info_reply_t
modifier|*
name|screenInfoReply
init|=
name|xcb_randr_get_screen_info_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcb_randr_get_screen_info_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|m_screen
operator|->
name|root
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|screenInfoReply
condition|)
block|{
name|rate
operator|=
name|screenInfoReply
operator|->
name|rate
expr_stmt|;
name|free
argument_list|(
name|screenInfoReply
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rate
operator|==
name|m_refreshRate
condition|)
return|return;
name|m_refreshRate
operator|=
name|rate
expr_stmt|;
name|QWindowSystemInterface
operator|::
name|handleScreenRefreshRateChange
argument_list|(
name|QPlatformScreen
operator|::
name|screen
argument_list|()
argument_list|,
name|rate
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|grabWindow
name|QPixmap
name|QXcbScreen
operator|::
name|grabWindow
parameter_list|(
name|WId
name|window
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|width
operator|==
literal|0
operator|||
name|height
operator|==
literal|0
condition|)
return|return
name|QPixmap
argument_list|()
return|;
comment|// TODO: handle multiple screens
name|QXcbScreen
modifier|*
name|screen
init|=
cast|const_cast
argument_list|<
name|QXcbScreen
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|xcb_window_t
name|root
init|=
name|screen
operator|->
name|root
argument_list|()
decl_stmt|;
if|if
condition|(
name|window
operator|==
literal|0
condition|)
name|window
operator|=
name|root
expr_stmt|;
name|xcb_get_geometry_cookie_t
name|geometry_cookie
init|=
name|xcb_get_geometry_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|window
argument_list|)
decl_stmt|;
name|xcb_get_geometry_reply_t
modifier|*
name|reply
init|=
name|xcb_get_geometry_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|geometry_cookie
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reply
condition|)
block|{
return|return
name|QPixmap
argument_list|()
return|;
block|}
if|if
condition|(
name|width
operator|<
literal|0
condition|)
name|width
operator|=
name|reply
operator|->
name|width
operator|-
name|x
expr_stmt|;
if|if
condition|(
name|height
operator|<
literal|0
condition|)
name|height
operator|=
name|reply
operator|->
name|height
operator|-
name|y
expr_stmt|;
name|geometry_cookie
operator|=
name|xcb_get_geometry_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|xcb_get_geometry_reply_t
modifier|*
name|root_reply
init|=
name|xcb_get_geometry_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|geometry_cookie
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|root_reply
condition|)
block|{
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|()
return|;
block|}
if|if
condition|(
name|reply
operator|->
name|depth
operator|==
name|root_reply
operator|->
name|depth
condition|)
block|{
comment|// if the depth of the specified window and the root window are the
comment|// same, grab pixels from the root window (so that we get the any
comment|// overlapping windows and window manager frames)
comment|// map x and y to the root window
name|xcb_translate_coordinates_cookie_t
name|translate_cookie
init|=
name|xcb_translate_coordinates_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|window
argument_list|,
name|root
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|xcb_translate_coordinates_reply_t
modifier|*
name|translate_reply
init|=
name|xcb_translate_coordinates_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|translate_cookie
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|translate_reply
condition|)
block|{
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|root_reply
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|()
return|;
block|}
name|x
operator|=
name|translate_reply
operator|->
name|dst_x
expr_stmt|;
name|y
operator|=
name|translate_reply
operator|->
name|dst_y
expr_stmt|;
name|window
operator|=
name|root
expr_stmt|;
name|free
argument_list|(
name|translate_reply
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|reply
operator|=
name|root_reply
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|root_reply
argument_list|)
expr_stmt|;
name|root_reply
operator|=
literal|0
expr_stmt|;
block|}
name|xcb_get_window_attributes_reply_t
modifier|*
name|attributes_reply
init|=
name|xcb_get_window_attributes_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcb_get_window_attributes_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|window
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|attributes_reply
condition|)
block|{
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|QPixmap
argument_list|()
return|;
block|}
specifier|const
name|xcb_visualtype_t
modifier|*
name|visual
init|=
name|screen
operator|->
name|visualForId
argument_list|(
name|attributes_reply
operator|->
name|visual
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|attributes_reply
argument_list|)
expr_stmt|;
name|xcb_pixmap_t
name|pixmap
init|=
name|xcb_generate_id
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
decl_stmt|;
name|xcb_create_pixmap
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|reply
operator|->
name|depth
argument_list|,
name|pixmap
argument_list|,
name|window
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|uint32_t
name|gc_value_mask
init|=
name|XCB_GC_SUBWINDOW_MODE
decl_stmt|;
name|uint32_t
name|gc_value_list
index|[]
init|=
block|{
name|XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS
block|}
decl_stmt|;
name|xcb_gcontext_t
name|gc
init|=
name|xcb_generate_id
argument_list|(
name|xcb_connection
argument_list|()
argument_list|)
decl_stmt|;
name|xcb_create_gc
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|gc
argument_list|,
name|pixmap
argument_list|,
name|gc_value_mask
argument_list|,
name|gc_value_list
argument_list|)
expr_stmt|;
name|xcb_copy_area
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|window
argument_list|,
name|pixmap
argument_list|,
name|gc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|QPixmap
name|result
init|=
name|qt_xcb_pixmapFromXPixmap
argument_list|(
name|connection
argument_list|()
argument_list|,
name|pixmap
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|reply
operator|->
name|depth
argument_list|,
name|visual
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|xcb_free_gc
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|gc
argument_list|)
expr_stmt|;
name|xcb_free_pixmap
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|pixmap
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|xResource
name|bool
name|QXcbScreen
operator|::
name|xResource
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|identifier
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|expectedIdentifier
parameter_list|,
name|int
modifier|*
name|value
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|value
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
operator|.
name|startsWith
argument_list|(
name|expectedIdentifier
argument_list|)
condition|)
block|{
name|QByteArray
name|stringValue
init|=
name|identifier
operator|.
name|mid
argument_list|(
name|expectedIdentifier
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
operator|*
name|value
operator|=
name|stringValue
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|stringValue
operator|==
literal|"hintfull"
condition|)
operator|*
name|value
operator|=
name|QFontEngine
operator|::
name|HintFull
expr_stmt|;
elseif|else
if|if
condition|(
name|stringValue
operator|==
literal|"hintnone"
condition|)
operator|*
name|value
operator|=
name|QFontEngine
operator|::
name|HintNone
expr_stmt|;
elseif|else
if|if
condition|(
name|stringValue
operator|==
literal|"hintmedium"
condition|)
operator|*
name|value
operator|=
name|QFontEngine
operator|::
name|HintMedium
expr_stmt|;
elseif|else
if|if
condition|(
name|stringValue
operator|==
literal|"hintslight"
condition|)
operator|*
name|value
operator|=
name|QFontEngine
operator|::
name|HintLight
expr_stmt|;
return|return
operator|*
name|value
operator|!=
literal|0
return|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|readXResources
name|void
name|QXcbScreen
operator|::
name|readXResources
parameter_list|()
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|QByteArray
name|resources
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|xcb_get_property_reply_t
modifier|*
name|reply
init|=
name|xcb_get_property_reply
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
name|xcb_get_property_unchecked
argument_list|(
name|xcb_connection
argument_list|()
argument_list|,
literal|false
argument_list|,
name|screen
argument_list|()
operator|->
name|root
argument_list|,
name|XCB_ATOM_RESOURCE_MANAGER
argument_list|,
name|XCB_ATOM_STRING
argument_list|,
name|offset
operator|/
literal|4
argument_list|,
literal|8192
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|bool
name|more
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|reply
operator|&&
name|reply
operator|->
name|format
operator|==
literal|8
operator|&&
name|reply
operator|->
name|type
operator|==
name|XCB_ATOM_STRING
condition|)
block|{
name|resources
operator|+=
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|xcb_get_property_value
argument_list|(
name|reply
argument_list|)
argument_list|,
name|xcb_get_property_value_length
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|xcb_get_property_value_length
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|more
operator|=
name|reply
operator|->
name|bytes_after
operator|!=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|reply
condition|)
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|more
condition|)
break|break;
block|}
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|split
init|=
name|resources
operator|.
name|split
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|split
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QByteArray
modifier|&
name|r
init|=
name|split
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|xResource
argument_list|(
name|r
argument_list|,
literal|"Xft.dpi:\t"
argument_list|,
operator|&
name|value
argument_list|)
condition|)
name|m_forcedDpi
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|xResource
argument_list|(
name|r
argument_list|,
literal|"Xft.hintstyle:\t"
argument_list|,
operator|&
name|value
argument_list|)
condition|)
name|m_hintStyle
operator|=
name|QFontEngine
operator|::
name|HintStyle
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|xSettings
name|QXcbXSettings
modifier|*
name|QXcbScreen
operator|::
name|xSettings
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|m_xSettings
condition|)
block|{
name|QXcbScreen
modifier|*
name|self
init|=
cast|const_cast
argument_list|<
name|QXcbScreen
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|self
operator|->
name|m_xSettings
operator|=
operator|new
name|QXcbXSettings
argument_list|(
name|self
argument_list|)
expr_stmt|;
block|}
return|return
name|m_xSettings
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
