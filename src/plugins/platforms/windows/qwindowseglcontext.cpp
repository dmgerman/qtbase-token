begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qwindowseglcontext.h"
end_include
begin_include
include|#
directive|include
file|"qwindowscontext.h"
end_include
begin_include
include|#
directive|include
file|"qwindowswindow.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/QDebug>
end_include
begin_include
include|#
directive|include
file|<QtGui/QOpenGLContext>
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QT_OPENGL_ES_2_ANGLE
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_OPENGL_DYNAMIC
argument_list|)
end_if
begin_include
include|#
directive|include
file|<EGL/eglext.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|/*!     \class QWindowsEGLStaticContext     \brief Static data for QWindowsEGLContext.      Keeps the display. The class is shared via QSharedPointer in the windows, the     contexts and in QWindowsIntegration. The display will be closed if the last instance     is deleted.      No EGL or OpenGL functions are called directly. Instead, they are resolved     dynamically. This works even if the plugin links directly to libegl/libglesv2 so     there is no need to differentiate between dynamic or Angle-only builds in here.      \internal     \ingroup qt-lighthouse-win */
DECL|member|libEGL
name|QWindowsLibEGL
name|QWindowsEGLStaticContext
operator|::
name|libEGL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|libGLESv2
name|QWindowsLibGLESv2
name|QWindowsEGLStaticContext
operator|::
name|libGLESv2
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_STATIC
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_OPENGL_DYNAMIC
argument_list|)
end_if
begin_ifdef
ifdef|#
directive|ifdef
name|Q_CC_MINGW
end_ifdef
begin_function
DECL|function|resolveFunc
specifier|static
name|void
modifier|*
name|resolveFunc
parameter_list|(
name|HMODULE
name|lib
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|QString
name|baseNameStr
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|QString
name|nameStr
decl_stmt|;
name|void
modifier|*
name|proc
init|=
literal|0
decl_stmt|;
comment|// Play nice with 32-bit mingw: Try func first, then func@0, func@4,
comment|// func@8, func@12, ..., func@64. The def file does not provide any aliases
comment|// in libEGL and libGLESv2 in these builds which results in exporting
comment|// function names like eglInitialize@12. This cannot be fixed without
comment|// breaking binary compatibility. So be flexible here instead.
name|int
name|argSize
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|!
name|proc
operator|&&
name|argSize
operator|<=
literal|64
condition|)
block|{
name|nameStr
operator|=
name|baseNameStr
expr_stmt|;
if|if
condition|(
name|argSize
operator|>=
literal|0
condition|)
name|nameStr
operator|+=
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|argSize
argument_list|)
expr_stmt|;
name|argSize
operator|=
name|argSize
operator|<
literal|0
condition|?
literal|0
else|:
name|argSize
operator|+
literal|4
expr_stmt|;
name|proc
operator|=
operator|(
name|void
operator|*
operator|)
operator|::
name|GetProcAddress
argument_list|(
name|lib
argument_list|,
name|nameStr
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|proc
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|resolveFunc
specifier|static
name|void
modifier|*
name|resolveFunc
parameter_list|(
name|HMODULE
name|lib
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|Q_OS_WINCE
return|return
operator|(
name|void
operator|*
operator|)
operator|::
name|GetProcAddress
argument_list|(
name|lib
argument_list|,
name|name
argument_list|)
return|;
else|#
directive|else
return|return
operator|(
name|void
operator|*
operator|)
operator|::
name|GetProcAddress
argument_list|(
name|lib
argument_list|,
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|QString
operator|::
name|fromLatin1
argument_list|(
name|name
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|)
return|;
endif|#
directive|endif
comment|// Q_OS_WINCE
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_CC_MINGW
end_comment
begin_function
DECL|function|resolve
name|void
modifier|*
name|QWindowsLibEGL
operator|::
name|resolve
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|m_lib
condition|?
name|resolveFunc
argument_list|(
name|m_lib
argument_list|,
name|name
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QT_STATIC
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_STATIC
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_OPENGL_DYNAMIC
argument_list|)
end_if
begin_define
DECL|macro|RESOLVE
define|#
directive|define
name|RESOLVE
parameter_list|(
name|signature
parameter_list|,
name|name
parameter_list|)
value|signature(resolve( #name ));
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|RESOLVE
define|#
directive|define
name|RESOLVE
parameter_list|(
name|signature
parameter_list|,
name|name
parameter_list|)
value|signature(&::name);
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|init
name|bool
name|QWindowsLibEGL
operator|::
name|init
parameter_list|()
block|{
specifier|const
name|char
name|dllName
index|[]
init|=
name|QT_STRINGIFY
argument_list|(
name|LIBEGL_NAME
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
literal|"d"
endif|#
directive|endif
literal|""
decl_stmt|;
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
literal|"Qt: Using EGL from"
operator|<<
name|dllName
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_STATIC
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_OPENGL_DYNAMIC
argument_list|)
name|m_lib
operator|=
operator|::
name|LoadLibraryW
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|QString
operator|::
name|fromLatin1
argument_list|(
name|dllName
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_lib
condition|)
block|{
name|qErrnoWarning
argument_list|(
operator|::
name|GetLastError
argument_list|()
argument_list|,
literal|"Failed to load %s"
argument_list|,
name|dllName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
endif|#
directive|endif
name|eglGetError
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLint
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
argument_list|,
name|eglGetError
argument_list|)
expr_stmt|;
name|eglGetDisplay
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLDisplay
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLNativeDisplayType
argument_list|)
operator|)
argument_list|,
name|eglGetDisplay
argument_list|)
expr_stmt|;
name|eglInitialize
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLBoolean
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLDisplay
argument_list|,
name|EGLint
operator|*
argument_list|,
name|EGLint
operator|*
argument_list|)
operator|)
argument_list|,
name|eglInitialize
argument_list|)
expr_stmt|;
name|eglTerminate
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLBoolean
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLDisplay
argument_list|)
operator|)
argument_list|,
name|eglTerminate
argument_list|)
expr_stmt|;
name|eglChooseConfig
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLBoolean
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLDisplay
argument_list|,
specifier|const
name|EGLint
operator|*
argument_list|,
name|EGLConfig
operator|*
argument_list|,
name|EGLint
argument_list|,
name|EGLint
operator|*
argument_list|)
operator|)
argument_list|,
name|eglChooseConfig
argument_list|)
expr_stmt|;
name|eglGetConfigAttrib
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLBoolean
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLDisplay
argument_list|,
name|EGLConfig
argument_list|,
name|EGLint
argument_list|,
name|EGLint
operator|*
argument_list|)
operator|)
argument_list|,
name|eglGetConfigAttrib
argument_list|)
expr_stmt|;
name|eglCreateWindowSurface
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLSurface
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLDisplay
argument_list|,
name|EGLConfig
argument_list|,
name|EGLNativeWindowType
argument_list|,
specifier|const
name|EGLint
operator|*
argument_list|)
operator|)
argument_list|,
name|eglCreateWindowSurface
argument_list|)
expr_stmt|;
name|eglCreatePbufferSurface
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLSurface
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLDisplay
argument_list|,
name|EGLConfig
argument_list|,
specifier|const
name|EGLint
operator|*
argument_list|)
operator|)
argument_list|,
name|eglCreatePbufferSurface
argument_list|)
expr_stmt|;
name|eglDestroySurface
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLBoolean
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLDisplay
argument_list|,
name|EGLSurface
argument_list|)
operator|)
argument_list|,
name|eglDestroySurface
argument_list|)
expr_stmt|;
name|eglBindAPI
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLBoolean
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLenum
argument_list|)
operator|)
argument_list|,
name|eglBindAPI
argument_list|)
expr_stmt|;
name|eglSwapInterval
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLBoolean
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLDisplay
argument_list|,
name|EGLint
argument_list|)
operator|)
argument_list|,
name|eglSwapInterval
argument_list|)
expr_stmt|;
name|eglCreateContext
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLContext
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLDisplay
argument_list|,
name|EGLConfig
argument_list|,
name|EGLContext
argument_list|,
specifier|const
name|EGLint
operator|*
argument_list|)
operator|)
argument_list|,
name|eglCreateContext
argument_list|)
expr_stmt|;
name|eglDestroyContext
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLBoolean
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLDisplay
argument_list|,
name|EGLContext
argument_list|)
operator|)
argument_list|,
name|eglDestroyContext
argument_list|)
expr_stmt|;
name|eglMakeCurrent
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLBoolean
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLDisplay
argument_list|,
name|EGLSurface
argument_list|,
name|EGLSurface
argument_list|,
name|EGLContext
argument_list|)
operator|)
argument_list|,
name|eglMakeCurrent
argument_list|)
expr_stmt|;
name|eglGetCurrentContext
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLContext
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
argument_list|,
name|eglGetCurrentContext
argument_list|)
expr_stmt|;
name|eglGetCurrentSurface
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLSurface
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLint
argument_list|)
operator|)
argument_list|,
name|eglGetCurrentSurface
argument_list|)
expr_stmt|;
name|eglGetCurrentDisplay
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLDisplay
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
argument_list|,
name|eglGetCurrentDisplay
argument_list|)
expr_stmt|;
name|eglSwapBuffers
operator|=
name|RESOLVE
argument_list|(
operator|(
name|EGLBoolean
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLDisplay
argument_list|,
name|EGLSurface
argument_list|)
operator|)
argument_list|,
name|eglSwapBuffers
argument_list|)
expr_stmt|;
name|eglGetProcAddress
operator|=
name|RESOLVE
argument_list|(
operator|(
name|QFunctionPointer
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|)
argument_list|,
name|eglGetProcAddress
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eglGetError
operator|||
operator|!
name|eglGetDisplay
operator|||
operator|!
name|eglInitialize
operator|||
operator|!
name|eglGetProcAddress
condition|)
return|return
literal|false
return|;
name|eglGetPlatformDisplayEXT
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|EGL_ANGLE_platform_angle
name|eglGetPlatformDisplayEXT
operator|=
expr|reinterpret_cast
operator|<
name|EGLDisplay
argument_list|(
name|EGLAPIENTRY
operator|*
argument_list|)
argument_list|(
name|EGLenum
argument_list|,
name|void
operator|*
argument_list|,
specifier|const
name|EGLint
operator|*
argument_list|)
operator|>
operator|(
name|eglGetProcAddress
argument_list|(
literal|"eglGetPlatformDisplayEXT"
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_STATIC
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_OPENGL_DYNAMIC
argument_list|)
end_if
begin_function
DECL|function|resolve
name|void
modifier|*
name|QWindowsLibGLESv2
operator|::
name|resolve
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|m_lib
condition|?
name|resolveFunc
argument_list|(
name|m_lib
argument_list|,
name|name
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QT_STATIC
end_comment
begin_function
DECL|function|init
name|bool
name|QWindowsLibGLESv2
operator|::
name|init
parameter_list|()
block|{
specifier|const
name|char
name|dllName
index|[]
init|=
name|QT_STRINGIFY
argument_list|(
name|LIBGLESV2_NAME
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|QT_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
literal|"d"
endif|#
directive|endif
literal|""
decl_stmt|;
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
literal|"Qt: Using OpenGL ES 2.0 from"
operator|<<
name|dllName
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_STATIC
argument_list|)
operator|||
name|defined
argument_list|(
name|QT_OPENGL_DYNAMIC
argument_list|)
name|m_lib
operator|=
operator|::
name|LoadLibraryW
argument_list|(
cast|reinterpret_cast
argument_list|<
name|LPCWSTR
argument_list|>
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|dllName
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_lib
condition|)
block|{
name|qErrnoWarning
argument_list|(
name|int
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
argument_list|,
literal|"Failed to load %s"
argument_list|,
name|dllName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
endif|#
directive|endif
comment|// !QT_STATIC
name|void
function_decl|(
name|APIENTRY
modifier|*
name|glBindTexture
function_decl|)
parameter_list|(
name|GLenum
name|target
parameter_list|,
name|GLuint
name|texture
parameter_list|)
init|=
name|RESOLVE
argument_list|(
operator|(
name|void
argument_list|(
name|APIENTRY
operator|*
argument_list|)
operator|(
name|GLenum
call|,
name|GLuint
operator|)
operator|)
operator|,
name|glBindTexture
block|)
function|;
end_function
begin_function_decl
name|GLuint
function_decl|(
name|APIENTRY
modifier|*
name|glCreateShader
function_decl|)
parameter_list|(
name|GLenum
name|type
parameter_list|)
init|=
name|RESOLVE
argument_list|(
operator|(
name|GLuint
argument_list|(
name|APIENTRY
operator|*
argument_list|)
operator|(
name|GLenum
operator|)
operator|)
operator|,
name|glCreateShader
end_function_decl
begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt
begin_function_decl
name|void
function_decl|(
name|APIENTRY
modifier|*
name|glClearDepthf
function_decl|)
parameter_list|(
name|GLclampf
name|depth
parameter_list|)
init|=
name|RESOLVE
argument_list|(
operator|(
name|void
argument_list|(
name|APIENTRY
operator|*
argument_list|)
operator|(
name|GLclampf
operator|)
operator|)
operator|,
name|glClearDepthf
end_function_decl
begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|glGetString
operator|=
name|RESOLVE
argument_list|(
operator|(
specifier|const
name|GLubyte
operator|*
operator|(
name|APIENTRY
operator|*
operator|)
operator|(
name|GLenum
operator|)
operator|)
argument_list|,
name|glGetString
argument_list|)
expr_stmt|;
end_expr_stmt
begin_return
return|return
name|glBindTexture
operator|&&
name|glCreateShader
operator|&&
name|glClearDepthf
return|;
end_return
begin_expr_stmt
unit|}  QWindowsEGLStaticContext
DECL|function|QWindowsEGLStaticContext
operator|::
name|QWindowsEGLStaticContext
operator|(
name|EGLDisplay
name|display
operator|)
operator|:
name|m_display
argument_list|(
argument|display
argument_list|)
block|{ }
DECL|function|create
name|QWindowsEGLStaticContext
operator|*
name|QWindowsEGLStaticContext
operator|::
name|create
operator|(
name|QWindowsOpenGLTester
operator|::
name|Renderers
name|preferredType
operator|)
block|{
specifier|const
name|HDC
name|dc
operator|=
name|QWindowsContext
operator|::
name|instance
argument_list|()
operator|->
name|displayContext
argument_list|()
block|;
if|if
condition|(
operator|!
name|dc
condition|)
block|{
name|qWarning
argument_list|(
literal|"%s: No Display"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_expr_stmt
begin_if
if|if
condition|(
operator|!
name|libEGL
operator|.
name|init
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"%s: Failed to load and resolve libEGL functions"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_if
begin_if
if|if
condition|(
operator|!
name|libGLESv2
operator|.
name|init
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"%s: Failed to load and resolve libGLESv2 functions"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_if
begin_decl_stmt
name|EGLDisplay
name|display
init|=
name|EGL_NO_DISPLAY
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|EGLint
name|major
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|EGLint
name|minor
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|EGL_ANGLE_platform_angle
end_ifdef
begin_if
if|if
condition|(
name|libEGL
operator|.
name|eglGetPlatformDisplayEXT
operator|&&
operator|(
name|preferredType
operator|&
name|QWindowsOpenGLTester
operator|::
name|AngleBackendMask
operator|)
condition|)
block|{
specifier|const
name|EGLint
name|anglePlatformAttributes
index|[]
index|[
literal|5
index|]
init|=
block|{
block|{
name|EGL_PLATFORM_ANGLE_TYPE_ANGLE
block|,
name|EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE
block|,
name|EGL_NONE
block|}
block|,
block|{
name|EGL_PLATFORM_ANGLE_TYPE_ANGLE
block|,
name|EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE
block|,
name|EGL_NONE
block|}
block|,
block|{
name|EGL_PLATFORM_ANGLE_TYPE_ANGLE
block|,
name|EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE
block|,
name|EGL_PLATFORM_ANGLE_DEVICE_TYPE_ANGLE
block|,
name|EGL_PLATFORM_ANGLE_DEVICE_TYPE_WARP_ANGLE
block|,
name|EGL_NONE
block|}
block|}
decl_stmt|;
specifier|const
name|EGLint
modifier|*
name|attributes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|preferredType
operator|&
name|QWindowsOpenGLTester
operator|::
name|AngleRendererD3d11
condition|)
name|attributes
operator|=
name|anglePlatformAttributes
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|preferredType
operator|&
name|QWindowsOpenGLTester
operator|::
name|AngleRendererD3d9
condition|)
name|attributes
operator|=
name|anglePlatformAttributes
index|[
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|preferredType
operator|&
name|QWindowsOpenGLTester
operator|::
name|AngleRendererD3d11Warp
condition|)
name|attributes
operator|=
name|anglePlatformAttributes
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|attributes
condition|)
block|{
name|display
operator|=
name|libEGL
operator|.
name|eglGetPlatformDisplayEXT
argument_list|(
name|EGL_PLATFORM_ANGLE_ANGLE
argument_list|,
name|dc
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|libEGL
operator|.
name|eglInitialize
argument_list|(
name|display
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|)
condition|)
block|{
name|display
operator|=
name|EGL_NO_DISPLAY
expr_stmt|;
name|major
operator|=
name|minor
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_if
begin_else
else|#
directive|else
end_else
begin_comment
comment|// EGL_ANGLE_platform_angle
end_comment
begin_macro
name|Q_UNUSED
argument_list|(
argument|preferredType
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|if
condition|(
name|display
operator|==
name|EGL_NO_DISPLAY
condition|)
name|display
operator|=
name|libEGL
operator|.
name|eglGetDisplay
argument_list|(
name|dc
argument_list|)
expr_stmt|;
end_if
begin_if
if|if
condition|(
operator|!
name|display
condition|)
block|{
name|qWarning
argument_list|(
literal|"%s: Could not obtain EGL display"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_if
begin_if
if|if
condition|(
operator|!
name|major
operator|&&
operator|!
name|libEGL
operator|.
name|eglInitialize
argument_list|(
name|display
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|)
condition|)
block|{
name|int
name|err
init|=
name|libEGL
operator|.
name|eglGetError
argument_list|()
decl_stmt|;
name|qWarning
argument_list|(
literal|"%s: Could not initialize EGL display: error 0x%x"
argument_list|,
name|__FUNCTION__
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0x3001
condition|)
name|qWarning
argument_list|(
literal|"%s: When using ANGLE, check if d3dcompiler_4x.dll is available"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_if
begin_expr_stmt
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
name|__FUNCTION__
operator|<<
literal|"Created EGL display"
operator|<<
name|display
operator|<<
literal|'v'
operator|<<
name|major
operator|<<
literal|'.'
operator|<<
name|minor
expr_stmt|;
end_expr_stmt
begin_return
return|return
operator|new
name|QWindowsEGLStaticContext
argument_list|(
name|display
argument_list|)
return|;
end_return
begin_destructor
unit|}  QWindowsEGLStaticContext
DECL|function|~QWindowsEGLStaticContext
operator|::
name|~
name|QWindowsEGLStaticContext
parameter_list|()
block|{
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
name|__FUNCTION__
operator|<<
literal|"Releasing EGL display "
operator|<<
name|m_display
expr_stmt|;
name|libEGL
operator|.
name|eglTerminate
argument_list|(
name|m_display
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|createContext
name|QWindowsOpenGLContext
modifier|*
name|QWindowsEGLStaticContext
operator|::
name|createContext
parameter_list|(
name|QOpenGLContext
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|new
name|QWindowsEGLContext
argument_list|(
name|this
argument_list|,
name|context
operator|->
name|format
argument_list|()
argument_list|,
name|context
operator|->
name|shareHandle
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|createWindowSurface
name|void
modifier|*
name|QWindowsEGLStaticContext
operator|::
name|createWindowSurface
parameter_list|(
name|void
modifier|*
name|nativeWindow
parameter_list|,
name|void
modifier|*
name|nativeConfig
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
operator|*
name|err
operator|=
literal|0
expr_stmt|;
name|EGLSurface
name|surface
init|=
name|libEGL
operator|.
name|eglCreateWindowSurface
argument_list|(
name|m_display
argument_list|,
name|nativeConfig
argument_list|,
cast|static_cast
argument_list|<
name|EGLNativeWindowType
argument_list|>
argument_list|(
name|nativeWindow
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|surface
operator|==
name|EGL_NO_SURFACE
condition|)
block|{
operator|*
name|err
operator|=
name|libEGL
operator|.
name|eglGetError
argument_list|()
expr_stmt|;
name|qWarning
argument_list|(
literal|"%s: Could not create the EGL window surface: 0x%x"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|*
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|surface
return|;
block|}
end_function
begin_function
DECL|function|destroyWindowSurface
name|void
name|QWindowsEGLStaticContext
operator|::
name|destroyWindowSurface
parameter_list|(
name|void
modifier|*
name|nativeSurface
parameter_list|)
block|{
name|libEGL
operator|.
name|eglDestroySurface
argument_list|(
name|m_display
argument_list|,
name|nativeSurface
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|formatFromConfig
name|QSurfaceFormat
name|QWindowsEGLStaticContext
operator|::
name|formatFromConfig
parameter_list|(
name|EGLDisplay
name|display
parameter_list|,
name|EGLConfig
name|config
parameter_list|,
specifier|const
name|QSurfaceFormat
modifier|&
name|referenceFormat
parameter_list|)
block|{
name|QSurfaceFormat
name|format
decl_stmt|;
name|EGLint
name|redSize
init|=
literal|0
decl_stmt|;
name|EGLint
name|greenSize
init|=
literal|0
decl_stmt|;
name|EGLint
name|blueSize
init|=
literal|0
decl_stmt|;
name|EGLint
name|alphaSize
init|=
literal|0
decl_stmt|;
name|EGLint
name|depthSize
init|=
literal|0
decl_stmt|;
name|EGLint
name|stencilSize
init|=
literal|0
decl_stmt|;
name|EGLint
name|sampleCount
init|=
literal|0
decl_stmt|;
name|libEGL
operator|.
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|,
name|config
argument_list|,
name|EGL_RED_SIZE
argument_list|,
operator|&
name|redSize
argument_list|)
expr_stmt|;
name|libEGL
operator|.
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|,
name|config
argument_list|,
name|EGL_GREEN_SIZE
argument_list|,
operator|&
name|greenSize
argument_list|)
expr_stmt|;
name|libEGL
operator|.
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|,
name|config
argument_list|,
name|EGL_BLUE_SIZE
argument_list|,
operator|&
name|blueSize
argument_list|)
expr_stmt|;
name|libEGL
operator|.
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|,
name|config
argument_list|,
name|EGL_ALPHA_SIZE
argument_list|,
operator|&
name|alphaSize
argument_list|)
expr_stmt|;
name|libEGL
operator|.
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|,
name|config
argument_list|,
name|EGL_DEPTH_SIZE
argument_list|,
operator|&
name|depthSize
argument_list|)
expr_stmt|;
name|libEGL
operator|.
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|,
name|config
argument_list|,
name|EGL_STENCIL_SIZE
argument_list|,
operator|&
name|stencilSize
argument_list|)
expr_stmt|;
name|libEGL
operator|.
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|,
name|config
argument_list|,
name|EGL_SAMPLES
argument_list|,
operator|&
name|sampleCount
argument_list|)
expr_stmt|;
name|format
operator|.
name|setRenderableType
argument_list|(
name|QSurfaceFormat
operator|::
name|OpenGLES
argument_list|)
expr_stmt|;
name|format
operator|.
name|setVersion
argument_list|(
name|referenceFormat
operator|.
name|majorVersion
argument_list|()
argument_list|,
name|referenceFormat
operator|.
name|minorVersion
argument_list|()
argument_list|)
expr_stmt|;
name|format
operator|.
name|setProfile
argument_list|(
name|referenceFormat
operator|.
name|profile
argument_list|()
argument_list|)
expr_stmt|;
name|format
operator|.
name|setOptions
argument_list|(
name|referenceFormat
operator|.
name|options
argument_list|()
argument_list|)
expr_stmt|;
name|format
operator|.
name|setRedBufferSize
argument_list|(
name|redSize
argument_list|)
expr_stmt|;
name|format
operator|.
name|setGreenBufferSize
argument_list|(
name|greenSize
argument_list|)
expr_stmt|;
name|format
operator|.
name|setBlueBufferSize
argument_list|(
name|blueSize
argument_list|)
expr_stmt|;
name|format
operator|.
name|setAlphaBufferSize
argument_list|(
name|alphaSize
argument_list|)
expr_stmt|;
name|format
operator|.
name|setDepthBufferSize
argument_list|(
name|depthSize
argument_list|)
expr_stmt|;
name|format
operator|.
name|setStencilBufferSize
argument_list|(
name|stencilSize
argument_list|)
expr_stmt|;
name|format
operator|.
name|setSamples
argument_list|(
name|sampleCount
argument_list|)
expr_stmt|;
name|format
operator|.
name|setStereo
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|format
operator|.
name|setSwapInterval
argument_list|(
name|referenceFormat
operator|.
name|swapInterval
argument_list|()
argument_list|)
expr_stmt|;
comment|// Clear the EGL error state because some of the above may
comment|// have errored out because the attribute is not applicable
comment|// to the surface type.  Such errors don't matter.
name|libEGL
operator|.
name|eglGetError
argument_list|()
expr_stmt|;
return|return
name|format
return|;
block|}
end_function
begin_comment
comment|/*!     \class QWindowsEGLContext     \brief Open EGL context.      \section1 Using QWindowsEGLContext for Desktop with ANGLE     \section2 Build Instructions     \list     \o Install the Direct X SDK     \o Checkout and build ANGLE (SVN repository) as explained here:        \l{http://code.google.com/p/angleproject/wiki/DevSetup}{ANGLE-Project}.        When building for 64bit, de-activate the "WarnAsError" option        in every project file (as otherwise integer conversion        warnings will break the build).     \o Run configure.exe with the options "-opengl es2".     \o Build qtbase and test some examples.     \endlist      \internal     \ingroup qt-lighthouse-win */
end_comment
begin_constructor
DECL|function|QWindowsEGLContext
name|QWindowsEGLContext
operator|::
name|QWindowsEGLContext
parameter_list|(
name|QWindowsEGLStaticContext
modifier|*
name|staticContext
parameter_list|,
specifier|const
name|QSurfaceFormat
modifier|&
name|format
parameter_list|,
name|QPlatformOpenGLContext
modifier|*
name|share
parameter_list|)
member_init_list|:
name|m_staticContext
argument_list|(
name|staticContext
argument_list|)
member_init_list|,
name|m_eglDisplay
argument_list|(
name|staticContext
operator|->
name|display
argument_list|()
argument_list|)
member_init_list|,
name|m_api
argument_list|(
name|EGL_OPENGL_ES_API
argument_list|)
member_init_list|,
name|m_swapInterval
argument_list|(
operator|-
literal|1
argument_list|)
block|{
if|if
condition|(
operator|!
name|m_staticContext
condition|)
return|return;
name|m_eglConfig
operator|=
name|chooseConfig
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|m_format
operator|=
name|m_staticContext
operator|->
name|formatFromConfig
argument_list|(
name|m_eglDisplay
argument_list|,
name|m_eglConfig
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|m_shareContext
operator|=
name|share
condition|?
cast|static_cast
argument_list|<
name|QWindowsEGLContext
operator|*
argument_list|>
argument_list|(
name|share
argument_list|)
operator|->
name|m_eglContext
else|:
literal|0
expr_stmt|;
name|QVector
argument_list|<
name|EGLint
argument_list|>
name|contextAttrs
decl_stmt|;
name|contextAttrs
operator|.
name|append
argument_list|(
name|EGL_CONTEXT_CLIENT_VERSION
argument_list|)
expr_stmt|;
name|contextAttrs
operator|.
name|append
argument_list|(
name|m_format
operator|.
name|majorVersion
argument_list|()
argument_list|)
expr_stmt|;
name|contextAttrs
operator|.
name|append
argument_list|(
name|EGL_NONE
argument_list|)
expr_stmt|;
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglBindAPI
argument_list|(
name|m_api
argument_list|)
expr_stmt|;
name|m_eglContext
operator|=
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglCreateContext
argument_list|(
name|m_eglDisplay
argument_list|,
name|m_eglConfig
argument_list|,
name|m_shareContext
argument_list|,
name|contextAttrs
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_eglContext
operator|==
name|EGL_NO_CONTEXT
operator|&&
name|m_shareContext
operator|!=
name|EGL_NO_CONTEXT
condition|)
block|{
name|m_shareContext
operator|=
literal|0
expr_stmt|;
name|m_eglContext
operator|=
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglCreateContext
argument_list|(
name|m_eglDisplay
argument_list|,
name|m_eglConfig
argument_list|,
literal|0
argument_list|,
name|contextAttrs
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m_eglContext
operator|==
name|EGL_NO_CONTEXT
condition|)
block|{
name|int
name|err
init|=
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetError
argument_list|()
decl_stmt|;
name|qWarning
argument_list|(
literal|"QWindowsEGLContext: Failed to create context, eglError: %x, this: %p"
argument_list|,
name|err
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// ANGLE gives bad alloc when it fails to reset a previously lost D3D device.
comment|// A common cause for this is disabling the graphics adapter used by the app.
if|if
condition|(
name|err
operator|==
name|EGL_BAD_ALLOC
condition|)
name|qWarning
argument_list|(
literal|"QWindowsEGLContext: Graphics device lost. (Did the adapter get disabled?)"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Make the context current to ensure the GL version query works. This needs a surface too.
specifier|const
name|EGLint
name|pbufferAttributes
index|[]
init|=
block|{
name|EGL_WIDTH
block|,
literal|1
block|,
name|EGL_HEIGHT
block|,
literal|1
block|,
name|EGL_LARGEST_PBUFFER
block|,
name|EGL_FALSE
block|,
name|EGL_NONE
block|}
decl_stmt|;
name|EGLSurface
name|pbuffer
init|=
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglCreatePbufferSurface
argument_list|(
name|m_eglDisplay
argument_list|,
name|m_eglConfig
argument_list|,
name|pbufferAttributes
argument_list|)
decl_stmt|;
if|if
condition|(
name|pbuffer
operator|==
name|EGL_NO_SURFACE
condition|)
return|return;
name|EGLDisplay
name|prevDisplay
init|=
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetCurrentDisplay
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevDisplay
operator|==
name|EGL_NO_DISPLAY
condition|)
comment|// when no context is current
name|prevDisplay
operator|=
name|m_eglDisplay
expr_stmt|;
name|EGLContext
name|prevContext
init|=
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetCurrentContext
argument_list|()
decl_stmt|;
name|EGLSurface
name|prevSurfaceDraw
init|=
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetCurrentSurface
argument_list|(
name|EGL_DRAW
argument_list|)
decl_stmt|;
name|EGLSurface
name|prevSurfaceRead
init|=
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetCurrentSurface
argument_list|(
name|EGL_READ
argument_list|)
decl_stmt|;
if|if
condition|(
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglMakeCurrent
argument_list|(
name|m_eglDisplay
argument_list|,
name|pbuffer
argument_list|,
name|pbuffer
argument_list|,
name|m_eglContext
argument_list|)
condition|)
block|{
specifier|const
name|GLubyte
modifier|*
name|s
init|=
name|QWindowsEGLStaticContext
operator|::
name|libGLESv2
operator|.
name|glGetString
argument_list|(
name|GL_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|QByteArray
name|version
init|=
name|QByteArray
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
if|if
condition|(
name|QPlatformOpenGLContext
operator|::
name|parseOpenGLVersion
argument_list|(
name|version
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
condition|)
block|{
name|m_format
operator|.
name|setMajorVersion
argument_list|(
name|major
argument_list|)
expr_stmt|;
name|m_format
operator|.
name|setMinorVersion
argument_list|(
name|minor
argument_list|)
expr_stmt|;
block|}
block|}
name|m_format
operator|.
name|setProfile
argument_list|(
name|QSurfaceFormat
operator|::
name|NoProfile
argument_list|)
expr_stmt|;
name|m_format
operator|.
name|setOptions
argument_list|(
name|QSurfaceFormat
operator|::
name|FormatOptions
argument_list|()
argument_list|)
expr_stmt|;
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglMakeCurrent
argument_list|(
name|prevDisplay
argument_list|,
name|prevSurfaceDraw
argument_list|,
name|prevSurfaceRead
argument_list|,
name|prevContext
argument_list|)
expr_stmt|;
block|}
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglDestroySurface
argument_list|(
name|m_eglDisplay
argument_list|,
name|pbuffer
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QWindowsEGLContext
name|QWindowsEGLContext
operator|::
name|~
name|QWindowsEGLContext
parameter_list|()
block|{
if|if
condition|(
name|m_eglContext
operator|!=
name|EGL_NO_CONTEXT
condition|)
block|{
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglDestroyContext
argument_list|(
name|m_eglDisplay
argument_list|,
name|m_eglContext
argument_list|)
expr_stmt|;
name|m_eglContext
operator|=
name|EGL_NO_CONTEXT
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|makeCurrent
name|bool
name|QWindowsEGLContext
operator|::
name|makeCurrent
parameter_list|(
name|QPlatformSurface
modifier|*
name|surface
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|surface
operator|->
name|surface
argument_list|()
operator|->
name|supportsOpenGL
argument_list|()
argument_list|)
expr_stmt|;
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglBindAPI
argument_list|(
name|m_api
argument_list|)
expr_stmt|;
name|QWindowsWindow
modifier|*
name|window
init|=
cast|static_cast
argument_list|<
name|QWindowsWindow
operator|*
argument_list|>
argument_list|(
name|surface
argument_list|)
decl_stmt|;
name|window
operator|->
name|aboutToMakeCurrent
argument_list|()
expr_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|EGLSurface
name|eglSurface
init|=
cast|static_cast
argument_list|<
name|EGLSurface
argument_list|>
argument_list|(
name|window
operator|->
name|surface
argument_list|(
name|m_eglConfig
argument_list|,
operator|&
name|err
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|eglSurface
operator|==
name|EGL_NO_SURFACE
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|EGL_CONTEXT_LOST
condition|)
block|{
name|m_eglContext
operator|=
name|EGL_NO_CONTEXT
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
literal|"Got EGL context lost in createWindowSurface() for context"
operator|<<
name|this
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|==
name|EGL_BAD_ACCESS
condition|)
block|{
comment|// With ANGLE this means no (D3D) device and can happen when disabling/changing graphics adapters.
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
literal|"Bad access (missing device?) in createWindowSurface() for context"
operator|<<
name|this
expr_stmt|;
comment|// Simulate context loss as the context is useless.
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglDestroyContext
argument_list|(
name|m_eglDisplay
argument_list|,
name|m_eglContext
argument_list|)
expr_stmt|;
name|m_eglContext
operator|=
name|EGL_NO_CONTEXT
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// shortcut: on some GPUs, eglMakeCurrent is not a cheap operation
if|if
condition|(
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetCurrentContext
argument_list|()
operator|==
name|m_eglContext
operator|&&
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetCurrentDisplay
argument_list|()
operator|==
name|m_eglDisplay
operator|&&
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetCurrentSurface
argument_list|(
name|EGL_READ
argument_list|)
operator|==
name|eglSurface
operator|&&
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetCurrentSurface
argument_list|(
name|EGL_DRAW
argument_list|)
operator|==
name|eglSurface
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|const
name|bool
name|ok
init|=
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglMakeCurrent
argument_list|(
name|m_eglDisplay
argument_list|,
name|eglSurface
argument_list|,
name|eglSurface
argument_list|,
name|m_eglContext
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
specifier|const
name|int
name|requestedSwapInterval
init|=
name|surface
operator|->
name|format
argument_list|()
operator|.
name|swapInterval
argument_list|()
decl_stmt|;
if|if
condition|(
name|requestedSwapInterval
operator|>=
literal|0
operator|&&
name|m_swapInterval
operator|!=
name|requestedSwapInterval
condition|)
block|{
name|m_swapInterval
operator|=
name|requestedSwapInterval
expr_stmt|;
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglSwapInterval
argument_list|(
name|m_staticContext
operator|->
name|display
argument_list|()
argument_list|,
name|m_swapInterval
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|err
operator|=
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetError
argument_list|()
expr_stmt|;
comment|// EGL_CONTEXT_LOST (loss of the D3D device) is not necessarily fatal.
comment|// Qt Quick is able to recover for example.
if|if
condition|(
name|err
operator|==
name|EGL_CONTEXT_LOST
condition|)
block|{
name|m_eglContext
operator|=
name|EGL_NO_CONTEXT
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
literal|"Got EGL context lost in makeCurrent() for context"
operator|<<
name|this
expr_stmt|;
comment|// Drop the surface. Will recreate on the next makeCurrent.
name|window
operator|->
name|invalidateSurface
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"%s: Failed to make surface current. eglError: %x, this: %p"
argument_list|,
name|__FUNCTION__
argument_list|,
name|err
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ok
return|;
block|}
end_function
begin_function
DECL|function|doneCurrent
name|void
name|QWindowsEGLContext
operator|::
name|doneCurrent
parameter_list|()
block|{
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglBindAPI
argument_list|(
name|m_api
argument_list|)
expr_stmt|;
name|bool
name|ok
init|=
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglMakeCurrent
argument_list|(
name|m_eglDisplay
argument_list|,
name|EGL_NO_SURFACE
argument_list|,
name|EGL_NO_SURFACE
argument_list|,
name|EGL_NO_CONTEXT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|qWarning
argument_list|(
literal|"%s: Failed to make no context/surface current. eglError: %d, this: %p"
argument_list|,
name|__FUNCTION__
argument_list|,
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetError
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|swapBuffers
name|void
name|QWindowsEGLContext
operator|::
name|swapBuffers
parameter_list|(
name|QPlatformSurface
modifier|*
name|surface
parameter_list|)
block|{
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglBindAPI
argument_list|(
name|m_api
argument_list|)
expr_stmt|;
name|QWindowsWindow
modifier|*
name|window
init|=
cast|static_cast
argument_list|<
name|QWindowsWindow
operator|*
argument_list|>
argument_list|(
name|surface
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|EGLSurface
name|eglSurface
init|=
cast|static_cast
argument_list|<
name|EGLSurface
argument_list|>
argument_list|(
name|window
operator|->
name|surface
argument_list|(
name|m_eglConfig
argument_list|,
operator|&
name|err
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|eglSurface
operator|==
name|EGL_NO_SURFACE
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|EGL_CONTEXT_LOST
condition|)
block|{
name|m_eglContext
operator|=
name|EGL_NO_CONTEXT
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
literal|"Got EGL context lost in createWindowSurface() for context"
operator|<<
name|this
expr_stmt|;
block|}
return|return;
block|}
name|bool
name|ok
init|=
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglSwapBuffers
argument_list|(
name|m_eglDisplay
argument_list|,
name|eglSurface
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|err
operator|=
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetError
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EGL_CONTEXT_LOST
condition|)
block|{
name|m_eglContext
operator|=
name|EGL_NO_CONTEXT
expr_stmt|;
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
literal|"Got EGL context lost in eglSwapBuffers()"
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"%s: Failed to swap buffers. eglError: %d, this: %p"
argument_list|,
name|__FUNCTION__
argument_list|,
name|err
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|getProcAddress
name|QFunctionPointer
name|QWindowsEGLContext
operator|::
name|getProcAddress
parameter_list|(
specifier|const
name|char
modifier|*
name|procName
parameter_list|)
block|{
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglBindAPI
argument_list|(
name|m_api
argument_list|)
expr_stmt|;
name|QFunctionPointer
name|procAddress
init|=
literal|nullptr
decl_stmt|;
comment|// Special logic for ANGLE extensions for blitFramebuffer and
comment|// renderbufferStorageMultisample. In version 2 contexts the extensions
comment|// must be used instead of the suffixless, version 3.0 functions.
if|if
condition|(
name|m_format
operator|.
name|majorVersion
argument_list|()
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|procName
argument_list|,
literal|"glBlitFramebuffer"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|procName
argument_list|,
literal|"glRenderbufferStorageMultisample"
argument_list|)
condition|)
block|{
name|char
name|extName
index|[
literal|32
operator|+
literal|5
operator|+
literal|1
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|extName
argument_list|,
name|procName
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|extName
argument_list|,
literal|"ANGLE"
argument_list|)
expr_stmt|;
name|procAddress
operator|=
cast|reinterpret_cast
argument_list|<
name|QFunctionPointer
argument_list|>
argument_list|(
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetProcAddress
argument_list|(
name|extName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|procAddress
condition|)
name|procAddress
operator|=
cast|reinterpret_cast
argument_list|<
name|QFunctionPointer
argument_list|>
argument_list|(
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetProcAddress
argument_list|(
name|procName
argument_list|)
argument_list|)
expr_stmt|;
comment|// We support AllGLFunctionsQueryable, which means this function must be able to
comment|// return a function pointer for standard GLES2 functions too. These are not
comment|// guaranteed to be queryable via eglGetProcAddress().
if|if
condition|(
operator|!
name|procAddress
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QT_STATIC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_OPENGL_DYNAMIC
argument_list|)
specifier|static
struct|struct
name|StdFunc
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|void
modifier|*
name|func
decl_stmt|;
block|}
name|standardFuncs
index|[]
init|=
block|{
block|{
literal|"glBindTexture"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glBindTexture
block|}
block|,
block|{
literal|"glBlendFunc"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glBlendFunc
block|}
block|,
block|{
literal|"glClear"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glClear
block|}
block|,
block|{
literal|"glClearColor"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glClearColor
block|}
block|,
block|{
literal|"glClearStencil"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glClearStencil
block|}
block|,
block|{
literal|"glColorMask"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glColorMask
block|}
block|,
block|{
literal|"glCopyTexImage2D"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glCopyTexImage2D
block|}
block|,
block|{
literal|"glCopyTexSubImage2D"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glCopyTexSubImage2D
block|}
block|,
block|{
literal|"glCullFace"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glCullFace
block|}
block|,
block|{
literal|"glDeleteTextures"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDeleteTextures
block|}
block|,
block|{
literal|"glDepthFunc"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDepthFunc
block|}
block|,
block|{
literal|"glDepthMask"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDepthMask
block|}
block|,
block|{
literal|"glDisable"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDisable
block|}
block|,
block|{
literal|"glDrawArrays"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDrawArrays
block|}
block|,
block|{
literal|"glDrawElements"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDrawElements
block|}
block|,
block|{
literal|"glEnable"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glEnable
block|}
block|,
block|{
literal|"glFinish"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glFinish
block|}
block|,
block|{
literal|"glFlush"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glFlush
block|}
block|,
block|{
literal|"glFrontFace"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glFrontFace
block|}
block|,
block|{
literal|"glGenTextures"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGenTextures
block|}
block|,
block|{
literal|"glGetBooleanv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetBooleanv
block|}
block|,
block|{
literal|"glGetError"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetError
block|}
block|,
block|{
literal|"glGetFloatv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetFloatv
block|}
block|,
block|{
literal|"glGetIntegerv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetIntegerv
block|}
block|,
block|{
literal|"glGetString"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetString
block|}
block|,
block|{
literal|"glGetTexParameterfv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetTexParameterfv
block|}
block|,
block|{
literal|"glGetTexParameteriv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetTexParameteriv
block|}
block|,
block|{
literal|"glHint"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glHint
block|}
block|,
block|{
literal|"glIsEnabled"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glIsEnabled
block|}
block|,
block|{
literal|"glIsTexture"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glIsTexture
block|}
block|,
block|{
literal|"glLineWidth"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glLineWidth
block|}
block|,
block|{
literal|"glPixelStorei"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glPixelStorei
block|}
block|,
block|{
literal|"glPolygonOffset"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glPolygonOffset
block|}
block|,
block|{
literal|"glReadPixels"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glReadPixels
block|}
block|,
block|{
literal|"glScissor"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glScissor
block|}
block|,
block|{
literal|"glStencilFunc"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glStencilFunc
block|}
block|,
block|{
literal|"glStencilMask"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glStencilMask
block|}
block|,
block|{
literal|"glStencilOp"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glStencilOp
block|}
block|,
block|{
literal|"glTexImage2D"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glTexImage2D
block|}
block|,
block|{
literal|"glTexParameterf"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glTexParameterf
block|}
block|,
block|{
literal|"glTexParameterfv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glTexParameterfv
block|}
block|,
block|{
literal|"glTexParameteri"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glTexParameteri
block|}
block|,
block|{
literal|"glTexParameteriv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glTexParameteriv
block|}
block|,
block|{
literal|"glTexSubImage2D"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glTexSubImage2D
block|}
block|,
block|{
literal|"glViewport"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glViewport
block|}
block|,
block|{
literal|"glActiveTexture"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glActiveTexture
block|}
block|,
block|{
literal|"glAttachShader"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glAttachShader
block|}
block|,
block|{
literal|"glBindAttribLocation"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glBindAttribLocation
block|}
block|,
block|{
literal|"glBindBuffer"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glBindBuffer
block|}
block|,
block|{
literal|"glBindFramebuffer"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glBindFramebuffer
block|}
block|,
block|{
literal|"glBindRenderbuffer"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glBindRenderbuffer
block|}
block|,
block|{
literal|"glBlendColor"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glBlendColor
block|}
block|,
block|{
literal|"glBlendEquation"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glBlendEquation
block|}
block|,
block|{
literal|"glBlendEquationSeparate"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glBlendEquationSeparate
block|}
block|,
block|{
literal|"glBlendFuncSeparate"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glBlendFuncSeparate
block|}
block|,
block|{
literal|"glBufferData"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glBufferData
block|}
block|,
block|{
literal|"glBufferSubData"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glBufferSubData
block|}
block|,
block|{
literal|"glCheckFramebufferStatus"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glCheckFramebufferStatus
block|}
block|,
block|{
literal|"glCompileShader"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glCompileShader
block|}
block|,
block|{
literal|"glCompressedTexImage2D"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glCompressedTexImage2D
block|}
block|,
block|{
literal|"glCompressedTexSubImage2D"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glCompressedTexSubImage2D
block|}
block|,
block|{
literal|"glCreateProgram"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glCreateProgram
block|}
block|,
block|{
literal|"glCreateShader"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glCreateShader
block|}
block|,
block|{
literal|"glDeleteBuffers"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDeleteBuffers
block|}
block|,
block|{
literal|"glDeleteFramebuffers"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDeleteFramebuffers
block|}
block|,
block|{
literal|"glDeleteProgram"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDeleteProgram
block|}
block|,
block|{
literal|"glDeleteRenderbuffers"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDeleteRenderbuffers
block|}
block|,
block|{
literal|"glDeleteShader"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDeleteShader
block|}
block|,
block|{
literal|"glDetachShader"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDetachShader
block|}
block|,
block|{
literal|"glDisableVertexAttribArray"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDisableVertexAttribArray
block|}
block|,
block|{
literal|"glEnableVertexAttribArray"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glEnableVertexAttribArray
block|}
block|,
block|{
literal|"glFramebufferRenderbuffer"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glFramebufferRenderbuffer
block|}
block|,
block|{
literal|"glFramebufferTexture2D"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glFramebufferTexture2D
block|}
block|,
block|{
literal|"glGenBuffers"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGenBuffers
block|}
block|,
block|{
literal|"glGenerateMipmap"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGenerateMipmap
block|}
block|,
block|{
literal|"glGenFramebuffers"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGenFramebuffers
block|}
block|,
block|{
literal|"glGenRenderbuffers"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGenRenderbuffers
block|}
block|,
block|{
literal|"glGetActiveAttrib"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetActiveAttrib
block|}
block|,
block|{
literal|"glGetActiveUniform"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetActiveUniform
block|}
block|,
block|{
literal|"glGetAttachedShaders"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetAttachedShaders
block|}
block|,
block|{
literal|"glGetAttribLocation"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetAttribLocation
block|}
block|,
block|{
literal|"glGetBufferParameteriv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetBufferParameteriv
block|}
block|,
block|{
literal|"glGetFramebufferAttachmentParameteriv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetFramebufferAttachmentParameteriv
block|}
block|,
block|{
literal|"glGetProgramiv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetProgramiv
block|}
block|,
block|{
literal|"glGetProgramInfoLog"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetProgramInfoLog
block|}
block|,
block|{
literal|"glGetRenderbufferParameteriv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetRenderbufferParameteriv
block|}
block|,
block|{
literal|"glGetShaderiv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetShaderiv
block|}
block|,
block|{
literal|"glGetShaderInfoLog"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetShaderInfoLog
block|}
block|,
block|{
literal|"glGetShaderPrecisionFormat"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetShaderPrecisionFormat
block|}
block|,
block|{
literal|"glGetShaderSource"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetShaderSource
block|}
block|,
block|{
literal|"glGetUniformfv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetUniformfv
block|}
block|,
block|{
literal|"glGetUniformiv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetUniformiv
block|}
block|,
block|{
literal|"glGetUniformLocation"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetUniformLocation
block|}
block|,
block|{
literal|"glGetVertexAttribfv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetVertexAttribfv
block|}
block|,
block|{
literal|"glGetVertexAttribiv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetVertexAttribiv
block|}
block|,
block|{
literal|"glGetVertexAttribPointerv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glGetVertexAttribPointerv
block|}
block|,
block|{
literal|"glIsBuffer"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glIsBuffer
block|}
block|,
block|{
literal|"glIsFramebuffer"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glIsFramebuffer
block|}
block|,
block|{
literal|"glIsProgram"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glIsProgram
block|}
block|,
block|{
literal|"glIsRenderbuffer"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glIsRenderbuffer
block|}
block|,
block|{
literal|"glIsShader"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glIsShader
block|}
block|,
block|{
literal|"glLinkProgram"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glLinkProgram
block|}
block|,
block|{
literal|"glReleaseShaderCompiler"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glReleaseShaderCompiler
block|}
block|,
block|{
literal|"glRenderbufferStorage"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glRenderbufferStorage
block|}
block|,
block|{
literal|"glSampleCoverage"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glSampleCoverage
block|}
block|,
block|{
literal|"glShaderBinary"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glShaderBinary
block|}
block|,
block|{
literal|"glShaderSource"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glShaderSource
block|}
block|,
block|{
literal|"glStencilFuncSeparate"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glStencilFuncSeparate
block|}
block|,
block|{
literal|"glStencilMaskSeparate"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glStencilMaskSeparate
block|}
block|,
block|{
literal|"glStencilOpSeparate"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glStencilOpSeparate
block|}
block|,
block|{
literal|"glUniform1f"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform1f
block|}
block|,
block|{
literal|"glUniform1fv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform1fv
block|}
block|,
block|{
literal|"glUniform1i"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform1i
block|}
block|,
block|{
literal|"glUniform1iv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform1iv
block|}
block|,
block|{
literal|"glUniform2f"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform2f
block|}
block|,
block|{
literal|"glUniform2fv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform2fv
block|}
block|,
block|{
literal|"glUniform2i"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform2i
block|}
block|,
block|{
literal|"glUniform2iv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform2iv
block|}
block|,
block|{
literal|"glUniform3f"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform3f
block|}
block|,
block|{
literal|"glUniform3fv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform3fv
block|}
block|,
block|{
literal|"glUniform3i"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform3i
block|}
block|,
block|{
literal|"glUniform3iv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform3iv
block|}
block|,
block|{
literal|"glUniform4f"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform4f
block|}
block|,
block|{
literal|"glUniform4fv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform4fv
block|}
block|,
block|{
literal|"glUniform4i"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform4i
block|}
block|,
block|{
literal|"glUniform4iv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniform4iv
block|}
block|,
block|{
literal|"glUniformMatrix2fv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniformMatrix2fv
block|}
block|,
block|{
literal|"glUniformMatrix3fv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniformMatrix3fv
block|}
block|,
block|{
literal|"glUniformMatrix4fv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUniformMatrix4fv
block|}
block|,
block|{
literal|"glUseProgram"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glUseProgram
block|}
block|,
block|{
literal|"glValidateProgram"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glValidateProgram
block|}
block|,
block|{
literal|"glVertexAttrib1f"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glVertexAttrib1f
block|}
block|,
block|{
literal|"glVertexAttrib1fv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glVertexAttrib1fv
block|}
block|,
block|{
literal|"glVertexAttrib2f"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glVertexAttrib2f
block|}
block|,
block|{
literal|"glVertexAttrib2fv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glVertexAttrib2fv
block|}
block|,
block|{
literal|"glVertexAttrib3f"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glVertexAttrib3f
block|}
block|,
block|{
literal|"glVertexAttrib3fv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glVertexAttrib3fv
block|}
block|,
block|{
literal|"glVertexAttrib4f"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glVertexAttrib4f
block|}
block|,
block|{
literal|"glVertexAttrib4fv"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glVertexAttrib4fv
block|}
block|,
block|{
literal|"glVertexAttribPointer"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glVertexAttribPointer
block|}
block|,
block|{
literal|"glClearDepthf"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glClearDepthf
block|}
block|,
block|{
literal|"glDepthRangef"
block|,
operator|(
name|void
operator|*
operator|)
operator|::
name|glDepthRangef
block|}
block|}
struct|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|standardFuncs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|StdFunc
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|qstrcmp
argument_list|(
name|procName
argument_list|,
name|standardFuncs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
cast|reinterpret_cast
argument_list|<
name|QFunctionPointer
argument_list|>
argument_list|(
name|standardFuncs
index|[
name|i
index|]
operator|.
name|func
argument_list|)
return|;
else|#
directive|else
name|procAddress
operator|=
cast|reinterpret_cast
argument_list|<
name|QFunctionPointer
argument_list|>
argument_list|(
name|QWindowsEGLStaticContext
operator|::
name|libGLESv2
operator|.
name|resolve
argument_list|(
name|procName
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|QWindowsContext
operator|::
name|verbose
operator|>
literal|1
condition|)
name|qCDebug
argument_list|(
name|lcQpaGl
argument_list|)
operator|<<
name|__FUNCTION__
operator|<<
name|procName
operator|<<
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetCurrentContext
argument_list|()
operator|<<
literal|"returns"
operator|<<
name|procAddress
expr_stmt|;
return|return
name|procAddress
return|;
block|}
end_function
begin_function
DECL|function|createConfigAttributesFromFormat
specifier|static
name|QVector
argument_list|<
name|EGLint
argument_list|>
name|createConfigAttributesFromFormat
parameter_list|(
specifier|const
name|QSurfaceFormat
modifier|&
name|format
parameter_list|)
block|{
name|int
name|redSize
init|=
name|format
operator|.
name|redBufferSize
argument_list|()
decl_stmt|;
name|int
name|greenSize
init|=
name|format
operator|.
name|greenBufferSize
argument_list|()
decl_stmt|;
name|int
name|blueSize
init|=
name|format
operator|.
name|blueBufferSize
argument_list|()
decl_stmt|;
name|int
name|alphaSize
init|=
name|format
operator|.
name|alphaBufferSize
argument_list|()
decl_stmt|;
name|int
name|depthSize
init|=
name|format
operator|.
name|depthBufferSize
argument_list|()
decl_stmt|;
name|int
name|stencilSize
init|=
name|format
operator|.
name|stencilBufferSize
argument_list|()
decl_stmt|;
name|int
name|sampleCount
init|=
name|format
operator|.
name|samples
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|EGLint
argument_list|>
name|configAttributes
decl_stmt|;
name|configAttributes
operator|.
name|reserve
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|EGL_RED_SIZE
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|redSize
operator|>
literal|0
condition|?
name|redSize
else|:
literal|0
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|EGL_GREEN_SIZE
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|greenSize
operator|>
literal|0
condition|?
name|greenSize
else|:
literal|0
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|EGL_BLUE_SIZE
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|blueSize
operator|>
literal|0
condition|?
name|blueSize
else|:
literal|0
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|EGL_ALPHA_SIZE
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|alphaSize
operator|>
literal|0
condition|?
name|alphaSize
else|:
literal|0
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|EGL_DEPTH_SIZE
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|depthSize
operator|>
literal|0
condition|?
name|depthSize
else|:
literal|0
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|EGL_STENCIL_SIZE
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|stencilSize
operator|>
literal|0
condition|?
name|stencilSize
else|:
literal|0
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|EGL_SAMPLES
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|sampleCount
operator|>
literal|0
condition|?
name|sampleCount
else|:
literal|0
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|EGL_SAMPLE_BUFFERS
argument_list|)
expr_stmt|;
name|configAttributes
operator|.
name|append
argument_list|(
name|sampleCount
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|configAttributes
return|;
block|}
end_function
begin_function
DECL|function|reduceConfigAttributes
specifier|static
name|bool
name|reduceConfigAttributes
parameter_list|(
name|QVector
argument_list|<
name|EGLint
argument_list|>
modifier|*
name|configAttributes
parameter_list|)
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|i
operator|=
name|configAttributes
operator|->
name|indexOf
argument_list|(
name|EGL_SWAP_BEHAVIOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|configAttributes
operator|->
name|remove
argument_list|(
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|configAttributes
operator|->
name|indexOf
argument_list|(
name|EGL_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|configAttributes
operator|->
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
literal|16
condition|)
block|{
name|configAttributes
operator|->
name|remove
argument_list|(
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|i
operator|=
name|configAttributes
operator|->
name|indexOf
argument_list|(
name|EGL_SAMPLES
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|EGLint
name|value
init|=
name|configAttributes
operator|->
name|value
argument_list|(
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|>
literal|1
condition|)
name|configAttributes
operator|->
name|replace
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|qMin
argument_list|(
name|EGLint
argument_list|(
literal|16
argument_list|)
argument_list|,
name|value
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|configAttributes
operator|->
name|remove
argument_list|(
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|i
operator|=
name|configAttributes
operator|->
name|indexOf
argument_list|(
name|EGL_SAMPLE_BUFFERS
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|configAttributes
operator|->
name|remove
argument_list|(
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|i
operator|=
name|configAttributes
operator|->
name|indexOf
argument_list|(
name|EGL_ALPHA_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|configAttributes
operator|->
name|remove
argument_list|(
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EGL_BIND_TO_TEXTURE_RGBA
argument_list|)
operator|&&
name|defined
argument_list|(
name|EGL_BIND_TO_TEXTURE_RGB
argument_list|)
name|i
operator|=
name|configAttributes
operator|->
name|indexOf
argument_list|(
name|EGL_BIND_TO_TEXTURE_RGBA
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|configAttributes
operator|->
name|replace
argument_list|(
name|i
argument_list|,
name|EGL_BIND_TO_TEXTURE_RGB
argument_list|)
expr_stmt|;
name|configAttributes
operator|->
name|replace
argument_list|(
name|i
operator|+
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|true
return|;
block|}
name|i
operator|=
name|configAttributes
operator|->
name|indexOf
argument_list|(
name|EGL_STENCIL_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|configAttributes
operator|->
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|>
literal|1
condition|)
name|configAttributes
operator|->
name|replace
argument_list|(
name|i
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|configAttributes
operator|->
name|remove
argument_list|(
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|i
operator|=
name|configAttributes
operator|->
name|indexOf
argument_list|(
name|EGL_DEPTH_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|configAttributes
operator|->
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|>
literal|1
condition|)
name|configAttributes
operator|->
name|replace
argument_list|(
name|i
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|configAttributes
operator|->
name|remove
argument_list|(
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
ifdef|#
directive|ifdef
name|EGL_BIND_TO_TEXTURE_RGB
name|i
operator|=
name|configAttributes
operator|->
name|indexOf
argument_list|(
name|EGL_BIND_TO_TEXTURE_RGB
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|configAttributes
operator|->
name|remove
argument_list|(
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
endif|#
directive|endif
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|chooseConfig
name|EGLConfig
name|QWindowsEGLContext
operator|::
name|chooseConfig
parameter_list|(
specifier|const
name|QSurfaceFormat
modifier|&
name|format
parameter_list|)
block|{
name|QVector
argument_list|<
name|EGLint
argument_list|>
name|configureAttributes
init|=
name|createConfigAttributesFromFormat
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|configureAttributes
operator|.
name|append
argument_list|(
name|EGL_SURFACE_TYPE
argument_list|)
expr_stmt|;
name|configureAttributes
operator|.
name|append
argument_list|(
name|EGL_WINDOW_BIT
argument_list|)
expr_stmt|;
name|configureAttributes
operator|.
name|append
argument_list|(
name|EGL_RENDERABLE_TYPE
argument_list|)
expr_stmt|;
name|configureAttributes
operator|.
name|append
argument_list|(
name|EGL_OPENGL_ES2_BIT
argument_list|)
expr_stmt|;
name|configureAttributes
operator|.
name|append
argument_list|(
name|EGL_NONE
argument_list|)
expr_stmt|;
name|EGLDisplay
name|display
init|=
name|m_staticContext
operator|->
name|display
argument_list|()
decl_stmt|;
name|EGLConfig
name|cfg
init|=
literal|0
decl_stmt|;
do|do
block|{
comment|// Get the number of matching configurations for this set of properties.
name|EGLint
name|matching
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglChooseConfig
argument_list|(
name|display
argument_list|,
name|configureAttributes
operator|.
name|constData
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|matching
argument_list|)
operator|||
operator|!
name|matching
condition|)
continue|continue;
comment|// Fetch all of the matching configurations and find the
comment|// first that matches the pixel format we wanted.
name|int
name|i
init|=
name|configureAttributes
operator|.
name|indexOf
argument_list|(
name|EGL_RED_SIZE
argument_list|)
decl_stmt|;
name|int
name|confAttrRed
init|=
name|configureAttributes
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|i
operator|=
name|configureAttributes
operator|.
name|indexOf
argument_list|(
name|EGL_GREEN_SIZE
argument_list|)
expr_stmt|;
name|int
name|confAttrGreen
init|=
name|configureAttributes
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|i
operator|=
name|configureAttributes
operator|.
name|indexOf
argument_list|(
name|EGL_BLUE_SIZE
argument_list|)
expr_stmt|;
name|int
name|confAttrBlue
init|=
name|configureAttributes
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|i
operator|=
name|configureAttributes
operator|.
name|indexOf
argument_list|(
name|EGL_ALPHA_SIZE
argument_list|)
expr_stmt|;
name|int
name|confAttrAlpha
init|=
name|i
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|configureAttributes
operator|.
name|at
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|QVector
argument_list|<
name|EGLConfig
argument_list|>
name|configs
argument_list|(
name|matching
argument_list|)
decl_stmt|;
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglChooseConfig
argument_list|(
name|display
argument_list|,
name|configureAttributes
operator|.
name|constData
argument_list|()
argument_list|,
name|configs
operator|.
name|data
argument_list|()
argument_list|,
name|configs
operator|.
name|size
argument_list|()
argument_list|,
operator|&
name|matching
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|&&
name|matching
operator|>
literal|0
condition|)
name|cfg
operator|=
name|configs
operator|.
name|constFirst
argument_list|()
expr_stmt|;
name|EGLint
name|red
init|=
literal|0
decl_stmt|;
name|EGLint
name|green
init|=
literal|0
decl_stmt|;
name|EGLint
name|blue
init|=
literal|0
decl_stmt|;
name|EGLint
name|alpha
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|configs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|confAttrRed
condition|)
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|,
name|configs
index|[
name|i
index|]
argument_list|,
name|EGL_RED_SIZE
argument_list|,
operator|&
name|red
argument_list|)
expr_stmt|;
if|if
condition|(
name|confAttrGreen
condition|)
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|,
name|configs
index|[
name|i
index|]
argument_list|,
name|EGL_GREEN_SIZE
argument_list|,
operator|&
name|green
argument_list|)
expr_stmt|;
if|if
condition|(
name|confAttrBlue
condition|)
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|,
name|configs
index|[
name|i
index|]
argument_list|,
name|EGL_BLUE_SIZE
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
if|if
condition|(
name|confAttrAlpha
condition|)
name|QWindowsEGLStaticContext
operator|::
name|libEGL
operator|.
name|eglGetConfigAttrib
argument_list|(
name|display
argument_list|,
name|configs
index|[
name|i
index|]
argument_list|,
name|EGL_ALPHA_SIZE
argument_list|,
operator|&
name|alpha
argument_list|)
expr_stmt|;
if|if
condition|(
name|red
operator|==
name|confAttrRed
operator|&&
name|green
operator|==
name|confAttrGreen
operator|&&
name|blue
operator|==
name|confAttrBlue
operator|&&
name|alpha
operator|==
name|confAttrAlpha
condition|)
return|return
name|configs
index|[
name|i
index|]
return|;
block|}
block|}
do|while
condition|(
name|reduceConfigAttributes
argument_list|(
operator|&
name|configureAttributes
argument_list|)
condition|)
do|;
if|if
condition|(
operator|!
name|cfg
condition|)
name|qWarning
argument_list|(
literal|"Cannot find EGLConfig, returning null config"
argument_list|)
expr_stmt|;
return|return
name|cfg
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
