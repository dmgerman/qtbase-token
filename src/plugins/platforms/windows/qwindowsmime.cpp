begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the plugins of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qwindowsmime.h"
end_include
begin_include
include|#
directive|include
file|"qwindowscontext.h"
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qdnd_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/QTextCodec>
end_include
begin_include
include|#
directive|include
file|<QtCore/QMap>
end_include
begin_include
include|#
directive|include
file|<QtCore/QUrl>
end_include
begin_include
include|#
directive|include
file|<QtCore/QDir>
end_include
begin_include
include|#
directive|include
file|<QtCore/QDebug>
end_include
begin_include
include|#
directive|include
file|<QtCore/QBuffer>
end_include
begin_include
include|#
directive|include
file|<QtGui/QImageReader>
end_include
begin_include
include|#
directive|include
file|<QtGui/QImageWriter>
end_include
begin_include
include|#
directive|include
file|<shlobj.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/* The MSVC compilers allows multi-byte characters, that has the behavior of  * that each character gets shifted into position. 0x73524742 below is for MSVC  * equivalent to doing 'sRGB', but this does of course not work  * on conformant C++ compilers. */
end_comment
begin_define
DECL|macro|BMP_LCS_sRGB
define|#
directive|define
name|BMP_LCS_sRGB
value|0x73524742
end_define
begin_define
DECL|macro|BMP_LCS_GM_IMAGES
define|#
directive|define
name|BMP_LCS_GM_IMAGES
value|0x00000004L
end_define
begin_struct
DECL|struct|_CIEXYZ
struct|struct
name|_CIEXYZ
block|{
DECL|member|ciexyzX
DECL|member|ciexyzY
DECL|member|ciexyzZ
name|long
name|ciexyzX
decl_stmt|,
name|ciexyzY
decl_stmt|,
name|ciexyzZ
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|_CIEXYZTRIPLE
struct|struct
name|_CIEXYZTRIPLE
block|{
DECL|member|ciexyzRed
DECL|member|ciexyzGreen
DECL|member|ciexyzBlue
name|_CIEXYZ
name|ciexyzRed
decl_stmt|,
name|ciexyzGreen
decl_stmt|,
name|ciexyzBlue
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|BMP_BITMAPV5HEADER
struct|struct
name|BMP_BITMAPV5HEADER
block|{
DECL|member|bV5Size
name|DWORD
name|bV5Size
decl_stmt|;
DECL|member|bV5Width
name|LONG
name|bV5Width
decl_stmt|;
DECL|member|bV5Height
name|LONG
name|bV5Height
decl_stmt|;
DECL|member|bV5Planes
name|WORD
name|bV5Planes
decl_stmt|;
DECL|member|bV5BitCount
name|WORD
name|bV5BitCount
decl_stmt|;
DECL|member|bV5Compression
name|DWORD
name|bV5Compression
decl_stmt|;
DECL|member|bV5SizeImage
name|DWORD
name|bV5SizeImage
decl_stmt|;
DECL|member|bV5XPelsPerMeter
name|LONG
name|bV5XPelsPerMeter
decl_stmt|;
DECL|member|bV5YPelsPerMeter
name|LONG
name|bV5YPelsPerMeter
decl_stmt|;
DECL|member|bV5ClrUsed
name|DWORD
name|bV5ClrUsed
decl_stmt|;
DECL|member|bV5ClrImportant
name|DWORD
name|bV5ClrImportant
decl_stmt|;
DECL|member|bV5RedMask
name|DWORD
name|bV5RedMask
decl_stmt|;
DECL|member|bV5GreenMask
name|DWORD
name|bV5GreenMask
decl_stmt|;
DECL|member|bV5BlueMask
name|DWORD
name|bV5BlueMask
decl_stmt|;
DECL|member|bV5AlphaMask
name|DWORD
name|bV5AlphaMask
decl_stmt|;
DECL|member|bV5CSType
name|DWORD
name|bV5CSType
decl_stmt|;
DECL|member|bV5Endpoints
name|_CIEXYZTRIPLE
name|bV5Endpoints
decl_stmt|;
DECL|member|bV5GammaRed
name|DWORD
name|bV5GammaRed
decl_stmt|;
DECL|member|bV5GammaGreen
name|DWORD
name|bV5GammaGreen
decl_stmt|;
DECL|member|bV5GammaBlue
name|DWORD
name|bV5GammaBlue
decl_stmt|;
DECL|member|bV5Intent
name|DWORD
name|bV5Intent
decl_stmt|;
DECL|member|bV5ProfileData
name|DWORD
name|bV5ProfileData
decl_stmt|;
DECL|member|bV5ProfileSize
name|DWORD
name|bV5ProfileSize
decl_stmt|;
DECL|member|bV5Reserved
name|DWORD
name|bV5Reserved
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|BMP_BITFIELDS
specifier|static
specifier|const
name|int
name|BMP_BITFIELDS
init|=
literal|3
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|dibFormatC
specifier|static
specifier|const
name|char
name|dibFormatC
index|[]
init|=
literal|"dib"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|msgConversionError
specifier|static
specifier|inline
name|QByteArray
name|msgConversionError
parameter_list|(
specifier|const
name|char
modifier|*
name|func
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
name|QByteArray
name|msg
init|=
name|func
decl_stmt|;
name|msg
operator|+=
literal|": Unable to convert DIB image. The image converter plugin for '"
expr_stmt|;
name|msg
operator|+=
name|format
expr_stmt|;
name|msg
operator|+=
literal|"' is not available. Available formats: "
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|af
decl|,
name|QImageReader
operator|::
name|supportedImageFormats
argument_list|()
control|)
block|{
name|msg
operator|+=
name|af
expr_stmt|;
name|msg
operator|+=
literal|' '
expr_stmt|;
block|}
return|return
name|msg
return|;
block|}
end_function
begin_function
DECL|function|readDib
specifier|static
specifier|inline
name|QImage
name|readDib
parameter_list|(
name|QByteArray
name|data
parameter_list|)
block|{
name|QBuffer
name|buffer
argument_list|(
operator|&
name|data
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|QImageReader
name|reader
argument_list|(
operator|&
name|buffer
argument_list|,
name|dibFormatC
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reader
operator|.
name|canRead
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"%s"
argument_list|,
name|msgConversionError
argument_list|(
name|__FUNCTION__
argument_list|,
name|dibFormatC
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|QImage
argument_list|()
return|;
block|}
return|return
name|reader
operator|.
name|read
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|writeDib
specifier|static
name|QByteArray
name|writeDib
parameter_list|(
specifier|const
name|QImage
modifier|&
name|img
parameter_list|)
block|{
name|QByteArray
name|ba
decl_stmt|;
name|QBuffer
name|buffer
argument_list|(
operator|&
name|ba
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadWrite
argument_list|)
expr_stmt|;
name|QImageWriter
name|writer
argument_list|(
operator|&
name|buffer
argument_list|,
name|dibFormatC
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|writer
operator|.
name|canWrite
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"%s"
argument_list|,
name|msgConversionError
argument_list|(
name|__FUNCTION__
argument_list|,
name|dibFormatC
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ba
return|;
block|}
if|if
condition|(
operator|!
name|writer
operator|.
name|write
argument_list|(
name|img
argument_list|)
condition|)
name|ba
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|ba
return|;
block|}
end_function
begin_function
DECL|function|qt_write_dibv5
specifier|static
name|bool
name|qt_write_dibv5
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QImage
name|image
parameter_list|)
block|{
name|QIODevice
modifier|*
name|d
init|=
name|s
operator|.
name|device
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isWritable
argument_list|()
condition|)
return|return
literal|false
return|;
comment|//depth will be always 32
name|int
name|bpl_bmp
init|=
name|image
operator|.
name|width
argument_list|()
operator|*
literal|4
decl_stmt|;
name|BMP_BITMAPV5HEADER
name|bi
decl_stmt|;
name|ZeroMemory
argument_list|(
operator|&
name|bi
argument_list|,
sizeof|sizeof
argument_list|(
name|bi
argument_list|)
argument_list|)
expr_stmt|;
name|bi
operator|.
name|bV5Size
operator|=
sizeof|sizeof
argument_list|(
name|BMP_BITMAPV5HEADER
argument_list|)
expr_stmt|;
name|bi
operator|.
name|bV5Width
operator|=
name|image
operator|.
name|width
argument_list|()
expr_stmt|;
name|bi
operator|.
name|bV5Height
operator|=
name|image
operator|.
name|height
argument_list|()
expr_stmt|;
name|bi
operator|.
name|bV5Planes
operator|=
literal|1
expr_stmt|;
name|bi
operator|.
name|bV5BitCount
operator|=
literal|32
expr_stmt|;
name|bi
operator|.
name|bV5Compression
operator|=
name|BI_BITFIELDS
expr_stmt|;
name|bi
operator|.
name|bV5SizeImage
operator|=
name|bpl_bmp
operator|*
name|image
operator|.
name|height
argument_list|()
expr_stmt|;
name|bi
operator|.
name|bV5XPelsPerMeter
operator|=
literal|0
expr_stmt|;
name|bi
operator|.
name|bV5YPelsPerMeter
operator|=
literal|0
expr_stmt|;
name|bi
operator|.
name|bV5ClrUsed
operator|=
literal|0
expr_stmt|;
name|bi
operator|.
name|bV5ClrImportant
operator|=
literal|0
expr_stmt|;
name|bi
operator|.
name|bV5BlueMask
operator|=
literal|0x000000ff
expr_stmt|;
name|bi
operator|.
name|bV5GreenMask
operator|=
literal|0x0000ff00
expr_stmt|;
name|bi
operator|.
name|bV5RedMask
operator|=
literal|0x00ff0000
expr_stmt|;
name|bi
operator|.
name|bV5AlphaMask
operator|=
literal|0xff000000
expr_stmt|;
name|bi
operator|.
name|bV5CSType
operator|=
name|BMP_LCS_sRGB
expr_stmt|;
comment|//LCS_sRGB
name|bi
operator|.
name|bV5Intent
operator|=
name|BMP_LCS_GM_IMAGES
expr_stmt|;
comment|//LCS_GM_IMAGES
name|d
operator|->
name|write
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
operator|&
name|bi
argument_list|)
argument_list|,
name|bi
operator|.
name|bV5Size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return
literal|false
return|;
name|DWORD
name|colorSpace
index|[
literal|3
index|]
init|=
block|{
literal|0x00ff0000
block|,
literal|0x0000ff00
block|,
literal|0x000000ff
block|}
decl_stmt|;
name|d
operator|->
name|write
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|colorSpace
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|colorSpace
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|image
operator|.
name|format
argument_list|()
operator|!=
name|QImage
operator|::
name|Format_ARGB32
condition|)
name|image
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32
argument_list|)
expr_stmt|;
name|uchar
modifier|*
name|buf
init|=
operator|new
name|uchar
index|[
name|bpl_bmp
index|]
decl_stmt|;
name|uchar
modifier|*
name|b
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|bpl_bmp
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
name|image
operator|.
name|height
argument_list|()
operator|-
literal|1
init|;
name|y
operator|>=
literal|0
condition|;
name|y
operator|--
control|)
block|{
comment|// write the image bits
name|QRgb
modifier|*
name|p
init|=
operator|(
name|QRgb
operator|*
operator|)
name|image
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|QRgb
modifier|*
name|end
init|=
name|p
operator|+
name|image
operator|.
name|width
argument_list|()
decl_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|int
name|alpha
init|=
name|qAlpha
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|alpha
condition|)
block|{
operator|*
name|b
operator|++
operator|=
name|qBlue
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|b
operator|++
operator|=
name|qGreen
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|b
operator|++
operator|=
name|qRed
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//white for fully transparent pixels.
operator|*
name|b
operator|++
operator|=
literal|0xff
expr_stmt|;
operator|*
name|b
operator|++
operator|=
literal|0xff
expr_stmt|;
operator|*
name|b
operator|++
operator|=
literal|0xff
expr_stmt|;
block|}
operator|*
name|b
operator|++
operator|=
name|alpha
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|d
operator|->
name|write
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|bpl_bmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
block|{
operator|delete
index|[]
name|buf
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
operator|delete
index|[]
name|buf
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|calc_shift
specifier|static
name|int
name|calc_shift
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|mask
operator|&
literal|1
operator|)
condition|)
block|{
name|result
operator|++
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|//Supports only 32 bit DIBV5
end_comment
begin_function
DECL|function|qt_read_dibv5
specifier|static
name|bool
name|qt_read_dibv5
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|BMP_BITMAPV5HEADER
name|bi
decl_stmt|;
name|QIODevice
modifier|*
name|d
init|=
name|s
operator|.
name|device
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|atEnd
argument_list|()
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|bi
argument_list|,
sizeof|sizeof
argument_list|(
name|bi
argument_list|)
argument_list|)
expr_stmt|;
comment|// read BITMAPV5HEADER header
if|if
condition|(
name|s
operator|.
name|status
argument_list|()
operator|!=
name|QDataStream
operator|::
name|Ok
condition|)
return|return
literal|false
return|;
name|int
name|nbits
init|=
name|bi
operator|.
name|bV5BitCount
decl_stmt|;
name|int
name|comp
init|=
name|bi
operator|.
name|bV5Compression
decl_stmt|;
if|if
condition|(
name|nbits
operator|!=
literal|32
operator|||
name|bi
operator|.
name|bV5Planes
operator|!=
literal|1
operator|||
name|comp
operator|!=
name|BMP_BITFIELDS
condition|)
return|return
literal|false
return|;
comment|//Unsupported DIBV5 format
name|int
name|w
init|=
name|bi
operator|.
name|bV5Width
decl_stmt|,
name|h
init|=
name|bi
operator|.
name|bV5Height
decl_stmt|;
name|int
name|red_mask
init|=
name|bi
operator|.
name|bV5RedMask
decl_stmt|;
name|int
name|green_mask
init|=
name|bi
operator|.
name|bV5GreenMask
decl_stmt|;
name|int
name|blue_mask
init|=
name|bi
operator|.
name|bV5BlueMask
decl_stmt|;
name|int
name|alpha_mask
init|=
name|bi
operator|.
name|bV5AlphaMask
decl_stmt|;
name|int
name|red_shift
init|=
literal|0
decl_stmt|;
name|int
name|green_shift
init|=
literal|0
decl_stmt|;
name|int
name|blue_shift
init|=
literal|0
decl_stmt|;
name|int
name|alpha_shift
init|=
literal|0
decl_stmt|;
name|QImage
operator|::
name|Format
name|format
init|=
name|QImage
operator|::
name|Format_ARGB32
decl_stmt|;
if|if
condition|(
name|bi
operator|.
name|bV5Height
operator|<
literal|0
condition|)
name|h
operator|=
operator|-
name|h
expr_stmt|;
comment|// support images with negative height
if|if
condition|(
name|image
operator|.
name|size
argument_list|()
operator|!=
name|QSize
argument_list|(
name|w
argument_list|,
name|h
argument_list|)
operator|||
name|image
operator|.
name|format
argument_list|()
operator|!=
name|format
condition|)
block|{
name|image
operator|=
name|QImage
argument_list|(
name|w
argument_list|,
name|h
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
comment|// could not create image
return|return
literal|false
return|;
block|}
name|image
operator|.
name|setDotsPerMeterX
argument_list|(
name|bi
operator|.
name|bV5XPelsPerMeter
argument_list|)
expr_stmt|;
name|image
operator|.
name|setDotsPerMeterY
argument_list|(
name|bi
operator|.
name|bV5YPelsPerMeter
argument_list|)
expr_stmt|;
comment|// read color table
name|DWORD
name|colorSpace
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|colorSpace
argument_list|,
sizeof|sizeof
argument_list|(
name|colorSpace
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|colorSpace
argument_list|)
condition|)
return|return
literal|false
return|;
name|red_shift
operator|=
name|calc_shift
argument_list|(
name|red_mask
argument_list|)
expr_stmt|;
name|green_shift
operator|=
name|calc_shift
argument_list|(
name|green_mask
argument_list|)
expr_stmt|;
name|blue_shift
operator|=
name|calc_shift
argument_list|(
name|blue_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_mask
condition|)
block|{
name|alpha_shift
operator|=
name|calc_shift
argument_list|(
name|alpha_mask
argument_list|)
expr_stmt|;
block|}
name|int
name|bpl
init|=
name|image
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
name|uchar
modifier|*
name|data
init|=
name|image
operator|.
name|bits
argument_list|()
decl_stmt|;
name|QRgb
modifier|*
name|p
decl_stmt|;
name|QRgb
modifier|*
name|end
decl_stmt|;
name|uchar
modifier|*
name|buf24
init|=
operator|new
name|uchar
index|[
name|bpl
index|]
decl_stmt|;
name|int
name|bpl24
init|=
operator|(
operator|(
name|w
operator|*
name|nbits
operator|+
literal|31
operator|)
operator|/
literal|32
operator|)
operator|*
literal|4
decl_stmt|;
name|uchar
modifier|*
name|b
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|--
name|h
operator|>=
literal|0
condition|)
block|{
name|p
operator|=
operator|(
name|QRgb
operator|*
operator|)
operator|(
name|data
operator|+
name|h
operator|*
name|bpl
operator|)
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|w
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf24
argument_list|,
name|bpl24
argument_list|)
operator|!=
name|bpl24
condition|)
break|break;
name|b
operator|=
name|buf24
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|c
operator|=
operator|*
name|b
operator||
operator|(
operator|*
operator|(
name|b
operator|+
literal|1
operator|)
operator|)
operator|<<
literal|8
operator||
operator|(
operator|*
operator|(
name|b
operator|+
literal|2
operator|)
operator|)
operator|<<
literal|16
operator||
operator|(
operator|*
operator|(
name|b
operator|+
literal|3
operator|)
operator|)
operator|<<
literal|24
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|qRgba
argument_list|(
operator|(
operator|(
name|c
operator|&
name|red_mask
operator|)
operator|>>
name|red_shift
operator|)
argument_list|,
operator|(
operator|(
name|c
operator|&
name|green_mask
operator|)
operator|>>
name|green_shift
operator|)
argument_list|,
operator|(
operator|(
name|c
operator|&
name|blue_mask
operator|)
operator|>>
name|blue_shift
operator|)
argument_list|,
operator|(
operator|(
name|c
operator|&
name|alpha_mask
operator|)
operator|>>
name|alpha_shift
operator|)
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|4
expr_stmt|;
block|}
block|}
operator|delete
index|[]
name|buf24
expr_stmt|;
if|if
condition|(
name|bi
operator|.
name|bV5Height
operator|<
literal|0
condition|)
block|{
comment|// Flip the image
name|uchar
modifier|*
name|buf
init|=
operator|new
name|uchar
index|[
name|bpl
index|]
decl_stmt|;
name|h
operator|=
operator|-
name|bi
operator|.
name|bV5Height
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|h
operator|/
literal|2
condition|;
operator|++
name|y
control|)
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|data
operator|+
name|y
operator|*
name|bpl
argument_list|,
name|bpl
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
name|y
operator|*
name|bpl
argument_list|,
name|data
operator|+
operator|(
name|h
operator|-
name|y
operator|-
literal|1
operator|)
operator|*
name|bpl
argument_list|,
name|bpl
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
operator|(
name|h
operator|-
name|y
operator|-
literal|1
operator|)
operator|*
name|bpl
argument_list|,
name|buf
argument_list|,
name|bpl
argument_list|)
expr_stmt|;
block|}
operator|delete
index|[]
name|buf
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|//#define QMIME_DEBUG
end_comment
begin_comment
comment|// helpers for using global memory
end_comment
begin_function
DECL|function|getCf
specifier|static
name|int
name|getCf
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|)
block|{
return|return
name|formatetc
operator|.
name|cfFormat
return|;
block|}
end_function
begin_function
DECL|function|setCf
specifier|static
name|FORMATETC
name|setCf
parameter_list|(
name|int
name|cf
parameter_list|)
block|{
name|FORMATETC
name|formatetc
decl_stmt|;
name|formatetc
operator|.
name|cfFormat
operator|=
name|cf
expr_stmt|;
name|formatetc
operator|.
name|dwAspect
operator|=
name|DVASPECT_CONTENT
expr_stmt|;
name|formatetc
operator|.
name|lindex
operator|=
operator|-
literal|1
expr_stmt|;
name|formatetc
operator|.
name|ptd
operator|=
name|NULL
expr_stmt|;
name|formatetc
operator|.
name|tymed
operator|=
name|TYMED_HGLOBAL
expr_stmt|;
return|return
name|formatetc
return|;
block|}
end_function
begin_function
DECL|function|setData
specifier|static
name|bool
name|setData
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|STGMEDIUM
modifier|*
name|pmedium
parameter_list|)
block|{
name|HGLOBAL
name|hData
init|=
name|GlobalAlloc
argument_list|(
literal|0
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hData
condition|)
return|return
literal|false
return|;
name|void
modifier|*
name|out
init|=
name|GlobalLock
argument_list|(
name|hData
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|GlobalUnlock
argument_list|(
name|hData
argument_list|)
expr_stmt|;
name|pmedium
operator|->
name|tymed
operator|=
name|TYMED_HGLOBAL
expr_stmt|;
name|pmedium
operator|->
name|hGlobal
operator|=
name|hData
expr_stmt|;
name|pmedium
operator|->
name|pUnkForRelease
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|getData
specifier|static
name|QByteArray
name|getData
parameter_list|(
name|int
name|cf
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
block|{
name|QByteArray
name|data
decl_stmt|;
name|FORMATETC
name|formatetc
init|=
name|setCf
argument_list|(
name|cf
argument_list|)
decl_stmt|;
name|STGMEDIUM
name|s
decl_stmt|;
if|if
condition|(
name|pDataObj
operator|->
name|GetData
argument_list|(
operator|&
name|formatetc
argument_list|,
operator|&
name|s
argument_list|)
operator|==
name|S_OK
condition|)
block|{
name|DWORD
modifier|*
name|val
init|=
operator|(
name|DWORD
operator|*
operator|)
name|GlobalLock
argument_list|(
name|s
operator|.
name|hGlobal
argument_list|)
decl_stmt|;
name|data
operator|=
name|QByteArray
operator|::
name|fromRawData
argument_list|(
operator|(
name|char
operator|*
operator|)
name|val
argument_list|,
name|GlobalSize
argument_list|(
name|s
operator|.
name|hGlobal
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|detach
argument_list|()
expr_stmt|;
name|GlobalUnlock
argument_list|(
name|s
operator|.
name|hGlobal
argument_list|)
expr_stmt|;
name|ReleaseStgMedium
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//Try reading IStream data
name|formatetc
operator|.
name|tymed
operator|=
name|TYMED_ISTREAM
expr_stmt|;
if|if
condition|(
name|pDataObj
operator|->
name|GetData
argument_list|(
operator|&
name|formatetc
argument_list|,
operator|&
name|s
argument_list|)
operator|==
name|S_OK
condition|)
block|{
name|char
name|szBuffer
index|[
literal|4096
index|]
decl_stmt|;
name|ULONG
name|actualRead
init|=
literal|0
decl_stmt|;
name|LARGE_INTEGER
name|pos
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
comment|//Move to front (can fail depending on the data model implemented)
name|HRESULT
name|hr
init|=
name|s
operator|.
name|pstm
operator|->
name|Seek
argument_list|(
name|pos
argument_list|,
name|STREAM_SEEK_SET
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
while|while
condition|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
condition|)
block|{
name|hr
operator|=
name|s
operator|.
name|pstm
operator|->
name|Read
argument_list|(
name|szBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|szBuffer
argument_list|)
argument_list|,
operator|&
name|actualRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUCCEEDED
argument_list|(
name|hr
argument_list|)
operator|&&
name|actualRead
operator|>
literal|0
condition|)
block|{
name|data
operator|+=
name|QByteArray
operator|::
name|fromRawData
argument_list|(
name|szBuffer
argument_list|,
name|actualRead
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|actualRead
operator|!=
sizeof|sizeof
argument_list|(
name|szBuffer
argument_list|)
condition|)
break|break;
block|}
name|data
operator|.
name|detach
argument_list|()
expr_stmt|;
name|ReleaseStgMedium
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|data
return|;
block|}
end_function
begin_function
DECL|function|canGetData
specifier|static
name|bool
name|canGetData
parameter_list|(
name|int
name|cf
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
block|{
name|FORMATETC
name|formatetc
init|=
name|setCf
argument_list|(
name|cf
argument_list|)
decl_stmt|;
if|if
condition|(
name|pDataObj
operator|->
name|QueryGetData
argument_list|(
operator|&
name|formatetc
argument_list|)
operator|!=
name|S_OK
condition|)
block|{
name|formatetc
operator|.
name|tymed
operator|=
name|TYMED_ISTREAM
expr_stmt|;
return|return
name|pDataObj
operator|->
name|QueryGetData
argument_list|(
operator|&
name|formatetc
argument_list|)
operator|==
name|S_OK
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \class QWindowsMime     \brief The QWindowsMime class maps open-standard MIME to Window Clipboard formats.     \internal     \ingroup qt-lighthouse-win      Qt's drag-and-drop and clipboard facilities use the MIME standard.     On X11, this maps trivially to the Xdnd protocol, but on Windows     although some applications use MIME types to describe clipboard     formats, others use arbitrary non-standardized naming conventions,     or unnamed built-in formats of Windows.      By instantiating subclasses of QWindowsMime that provide conversions     between Windows Clipboard and MIME formats, you can convert     proprietary clipboard formats to MIME formats.      Qt has predefined support for the following Windows Clipboard formats:      \table     \header \li Windows Format \li Equivalent MIME type     \row \li \c CF_UNICODETEXT \li \c text/plain     \row \li \c CF_TEXT        \li \c text/plain     \row \li \c CF_DIB         \li \c{image/xyz}, where \c xyz is                                  a \l{QImageWriter::supportedImageFormats()}{Qt image format}     \row \li \c CF_HDROP       \li \c text/uri-list     \row \li \c CF_INETURL     \li \c text/uri-list     \row \li \c CF_HTML        \li \c text/html     \endtable      An example use of this class would be to map the Windows Metafile     clipboard format (\c CF_METAFILEPICT) to and from the MIME type     \c{image/x-wmf}. This conversion might simply be adding or removing     a header, or even just passing on the data. See \l{Drag and Drop}     for more information on choosing and definition MIME types.      You can check if a MIME type is convertible using canConvertFromMime() and     can perform conversions with convertToMime() and convertFromMime().      \sa QWindowsMimeConverter */
end_comment
begin_comment
comment|/*! Constructs a new conversion object, adding it to the globally accessed list of available converters. */
end_comment
begin_constructor
DECL|function|QWindowsMime
name|QWindowsMime
operator|::
name|QWindowsMime
parameter_list|()
block|{ }
end_constructor
begin_comment
comment|/*! Destroys a conversion object, removing it from the global list of available converters. */
end_comment
begin_destructor
DECL|function|~QWindowsMime
name|QWindowsMime
operator|::
name|~
name|QWindowsMime
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Registers the MIME type \a mime, and returns an ID number     identifying the format on Windows. */
end_comment
begin_function
DECL|function|registerMimeType
name|int
name|QWindowsMime
operator|::
name|registerMimeType
parameter_list|(
specifier|const
name|QString
modifier|&
name|mime
parameter_list|)
block|{
name|int
name|f
init|=
name|RegisterClipboardFormat
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|mime
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|qErrnoWarning
argument_list|(
literal|"QWindowsMime::registerMimeType: Failed to register clipboard format"
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function
begin_comment
comment|/*! \fn bool QWindowsMime::canConvertFromMime(const FORMATETC&formatetc, const QMimeData *mimeData) const    Returns true if the converter can convert from the \a mimeData to   the format specified in \a formatetc.    All subclasses must reimplement this pure virtual function. */
end_comment
begin_comment
comment|/*!   \fn bool QWindowsMime::canConvertToMime(const QString&mimeType, IDataObject *pDataObj) const    Returns true if the converter can convert to the \a mimeType from   the available formats in \a pDataObj.    All subclasses must reimplement this pure virtual function. */
end_comment
begin_comment
comment|/*! \fn QString QWindowsMime::mimeForFormat(const FORMATETC&formatetc) const    Returns the mime type that will be created form the format specified   in \a formatetc, or an empty string if this converter does not support   \a formatetc.    All subclasses must reimplement this pure virtual function. */
end_comment
begin_comment
comment|/*! \fn QVector<FORMATETC> QWindowsMime::formatsForMime(const QString&mimeType, const QMimeData *mimeData) const    Returns a QVector of FORMATETC structures representing the different windows clipboard   formats that can be provided for the \a mimeType from the \a mimeData.    All subclasses must reimplement this pure virtual function. */
end_comment
begin_comment
comment|/*!     \fn QVariant QWindowsMime::convertToMime(const QString&mimeType, IDataObject *pDataObj,                                              QVariant::Type preferredType) const      Returns a QVariant containing the converted data for \a mimeType from \a pDataObj.     If possible the QVariant should be of the \a preferredType to avoid needless conversions.      All subclasses must reimplement this pure virtual function. */
end_comment
begin_comment
comment|/*! \fn bool QWindowsMime::convertFromMime(const FORMATETC&formatetc, const QMimeData *mimeData, STGMEDIUM * pmedium) const    Convert the \a mimeData to the format specified in \a formatetc.   The converted data should then be placed in \a pmedium structure.    Return true if the conversion was successful.    All subclasses must reimplement this pure virtual function. */
end_comment
begin_class
DECL|class|QWindowsMimeText
class|class
name|QWindowsMimeText
super|:
specifier|public
name|QWindowsMime
block|{
public|public:
name|bool
name|canConvertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
function_decl|;
name|QVariant
name|convertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mime
parameter_list|,
name|LPDATAOBJECT
name|pDataObj
parameter_list|,
name|QVariant
operator|::
name|Type
name|preferredType
parameter_list|)
specifier|const
function_decl|;
name|QString
name|mimeForFormat
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|)
specifier|const
function_decl|;
name|bool
name|canConvertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
function_decl|;
name|bool
name|convertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|,
name|STGMEDIUM
modifier|*
name|pmedium
parameter_list|)
specifier|const
function_decl|;
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|formatsForMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
function_decl|;
block|}
class|;
end_class
begin_function
DECL|function|canConvertFromMime
name|bool
name|QWindowsMimeText
operator|::
name|canConvertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
block|{
name|int
name|cf
init|=
name|getCf
argument_list|(
name|formatetc
argument_list|)
decl_stmt|;
return|return
operator|(
name|cf
operator|==
name|CF_UNICODETEXT
operator|||
name|cf
operator|==
name|CF_TEXT
operator|)
operator|&&
name|mimeData
operator|->
name|hasText
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/* text/plain is defined as using CRLF, but so many programs don't, and programmers just look for '\n' in strings. Windows really needs CRLF, so we ensure it here. */
end_comment
begin_function
DECL|function|convertFromMime
name|bool
name|QWindowsMimeText
operator|::
name|convertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|,
name|STGMEDIUM
modifier|*
name|pmedium
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|canConvertFromMime
argument_list|(
name|formatetc
argument_list|,
name|mimeData
argument_list|)
condition|)
block|{
name|QByteArray
name|data
decl_stmt|;
name|int
name|cf
init|=
name|getCf
argument_list|(
name|formatetc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cf
operator|==
name|CF_TEXT
condition|)
block|{
name|data
operator|=
name|mimeData
operator|->
name|text
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
expr_stmt|;
comment|// Anticipate required space for CRLFs at 1/40
name|int
name|maxsize
init|=
name|data
operator|.
name|size
argument_list|()
operator|+
name|data
operator|.
name|size
argument_list|()
operator|/
literal|40
operator|+
literal|3
decl_stmt|;
name|QByteArray
name|r
argument_list|(
name|maxsize
argument_list|,
literal|'\0'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|o
init|=
name|r
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
init|=
name|data
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|int
name|s
init|=
name|data
operator|.
name|size
argument_list|()
decl_stmt|;
name|bool
name|cr
init|=
literal|false
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|d
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|cr
operator|=
literal|true
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|cr
condition|)
name|o
index|[
name|j
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
block|}
name|cr
operator|=
literal|false
expr_stmt|;
block|}
name|o
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|j
operator|+
literal|3
operator|>=
name|maxsize
condition|)
block|{
name|maxsize
operator|+=
name|maxsize
operator|/
literal|4
expr_stmt|;
name|r
operator|.
name|resize
argument_list|(
name|maxsize
argument_list|)
expr_stmt|;
name|o
operator|=
name|r
operator|.
name|data
argument_list|()
expr_stmt|;
block|}
block|}
name|o
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|setData
argument_list|(
name|r
argument_list|,
name|pmedium
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cf
operator|==
name|CF_UNICODETEXT
condition|)
block|{
name|QString
name|str
init|=
name|mimeData
operator|->
name|text
argument_list|()
decl_stmt|;
specifier|const
name|QChar
modifier|*
name|u
init|=
name|str
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|QString
name|res
decl_stmt|;
specifier|const
name|int
name|s
init|=
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|maxsize
init|=
name|s
operator|+
name|s
operator|/
literal|40
operator|+
literal|3
decl_stmt|;
name|res
operator|.
name|resize
argument_list|(
name|maxsize
argument_list|)
expr_stmt|;
name|int
name|ri
init|=
literal|0
decl_stmt|;
name|bool
name|cr
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|*
name|u
operator|==
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
condition|)
name|cr
operator|=
literal|true
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|u
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
operator|&&
operator|!
name|cr
condition|)
name|res
index|[
name|ri
operator|++
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|cr
operator|=
literal|false
expr_stmt|;
block|}
name|res
index|[
name|ri
operator|++
index|]
operator|=
operator|*
name|u
expr_stmt|;
if|if
condition|(
name|ri
operator|+
literal|3
operator|>=
name|maxsize
condition|)
block|{
name|maxsize
operator|+=
name|maxsize
operator|/
literal|4
expr_stmt|;
name|res
operator|.
name|resize
argument_list|(
name|maxsize
argument_list|)
expr_stmt|;
block|}
operator|++
name|u
expr_stmt|;
block|}
name|res
operator|.
name|truncate
argument_list|(
name|ri
argument_list|)
expr_stmt|;
specifier|const
name|int
name|byteLength
init|=
name|res
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
decl_stmt|;
name|QByteArray
name|r
argument_list|(
name|byteLength
operator|+
literal|2
argument_list|,
literal|'\0'
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|r
operator|.
name|data
argument_list|()
argument_list|,
name|res
operator|.
name|unicode
argument_list|()
argument_list|,
name|byteLength
argument_list|)
expr_stmt|;
name|r
index|[
name|byteLength
index|]
operator|=
literal|0
expr_stmt|;
name|r
index|[
name|byteLength
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|setData
argument_list|(
name|r
argument_list|,
name|pmedium
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|canConvertToMime
name|bool
name|QWindowsMimeText
operator|::
name|canConvertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
block|{
return|return
name|mimeType
operator|.
name|startsWith
argument_list|(
name|QStringLiteral
argument_list|(
literal|"text/plain"
argument_list|)
argument_list|)
operator|&&
operator|(
name|canGetData
argument_list|(
name|CF_UNICODETEXT
argument_list|,
name|pDataObj
argument_list|)
operator|||
name|canGetData
argument_list|(
name|CF_TEXT
argument_list|,
name|pDataObj
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|mimeForFormat
name|QString
name|QWindowsMimeText
operator|::
name|mimeForFormat
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|)
specifier|const
block|{
name|int
name|cf
init|=
name|getCf
argument_list|(
name|formatetc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cf
operator|==
name|CF_UNICODETEXT
operator|||
name|cf
operator|==
name|CF_TEXT
condition|)
return|return
name|QStringLiteral
argument_list|(
literal|"text/plain"
argument_list|)
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|formatsForMime
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|QWindowsMimeText
operator|::
name|formatsForMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
block|{
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|formatics
decl_stmt|;
if|if
condition|(
name|mimeType
operator|.
name|startsWith
argument_list|(
name|QStringLiteral
argument_list|(
literal|"text/plain"
argument_list|)
argument_list|)
operator|&&
name|mimeData
operator|->
name|hasText
argument_list|()
condition|)
block|{
name|formatics
operator|+=
name|setCf
argument_list|(
name|CF_UNICODETEXT
argument_list|)
expr_stmt|;
name|formatics
operator|+=
name|setCf
argument_list|(
name|CF_TEXT
argument_list|)
expr_stmt|;
block|}
return|return
name|formatics
return|;
block|}
end_function
begin_function
DECL|function|convertToMime
name|QVariant
name|QWindowsMimeText
operator|::
name|convertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mime
parameter_list|,
name|LPDATAOBJECT
name|pDataObj
parameter_list|,
name|QVariant
operator|::
name|Type
name|preferredType
parameter_list|)
specifier|const
block|{
name|QVariant
name|ret
decl_stmt|;
if|if
condition|(
name|canConvertToMime
argument_list|(
name|mime
argument_list|,
name|pDataObj
argument_list|)
condition|)
block|{
name|QString
name|str
decl_stmt|;
name|QByteArray
name|data
init|=
name|getData
argument_list|(
name|CF_UNICODETEXT
argument_list|,
name|pDataObj
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|str
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|data
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|str
operator|.
name|replace
argument_list|(
name|QStringLiteral
argument_list|(
literal|"\r\n"
argument_list|)
argument_list|,
name|QStringLiteral
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|getData
argument_list|(
name|CF_TEXT
argument_list|,
name|pDataObj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|const
name|char
modifier|*
name|d
init|=
name|data
operator|.
name|data
argument_list|()
decl_stmt|;
specifier|const
name|int
name|s
init|=
name|qstrlen
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|QByteArray
name|r
argument_list|(
name|data
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
literal|'\0'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|o
init|=
name|r
operator|.
name|data
argument_list|()
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|d
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\r'
condition|)
name|o
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|o
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|preferredType
operator|==
name|QVariant
operator|::
name|String
condition|)
name|ret
operator|=
name|str
expr_stmt|;
else|else
name|ret
operator|=
name|str
operator|.
name|toUtf8
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|QWindowsContext
operator|::
name|verboseOLE
condition|)
name|qDebug
argument_list|()
operator|<<
name|__FUNCTION__
operator|<<
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_class
DECL|class|QWindowsMimeURI
class|class
name|QWindowsMimeURI
super|:
specifier|public
name|QWindowsMime
block|{
public|public:
name|QWindowsMimeURI
parameter_list|()
constructor_decl|;
name|bool
name|canConvertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
function_decl|;
name|QVariant
name|convertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mime
parameter_list|,
name|LPDATAOBJECT
name|pDataObj
parameter_list|,
name|QVariant
operator|::
name|Type
name|preferredType
parameter_list|)
specifier|const
function_decl|;
name|QString
name|mimeForFormat
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|)
specifier|const
function_decl|;
name|bool
name|canConvertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
function_decl|;
name|bool
name|convertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|,
name|STGMEDIUM
modifier|*
name|pmedium
parameter_list|)
specifier|const
function_decl|;
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|formatsForMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
function_decl|;
private|private:
DECL|member|CF_INETURL_W
name|int
name|CF_INETURL_W
decl_stmt|;
comment|// wide char version
DECL|member|CF_INETURL
name|int
name|CF_INETURL
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QWindowsMimeURI
name|QWindowsMimeURI
operator|::
name|QWindowsMimeURI
parameter_list|()
block|{
name|CF_INETURL_W
operator|=
name|QWindowsMime
operator|::
name|registerMimeType
argument_list|(
name|QStringLiteral
argument_list|(
literal|"UniformResourceLocatorW"
argument_list|)
argument_list|)
expr_stmt|;
name|CF_INETURL
operator|=
name|QWindowsMime
operator|::
name|registerMimeType
argument_list|(
name|QStringLiteral
argument_list|(
literal|"UniformResourceLocator"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|canConvertFromMime
name|bool
name|QWindowsMimeURI
operator|::
name|canConvertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mimeData
operator|->
name|hasUrls
argument_list|()
operator|&&
name|getCf
argument_list|(
name|formatetc
argument_list|)
operator|==
name|CF_HDROP
condition|)
block|{
name|QList
argument_list|<
name|QUrl
argument_list|>
name|urls
init|=
name|mimeData
operator|->
name|urls
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|urls
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|urls
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLocalFile
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
operator|(
name|getCf
argument_list|(
name|formatetc
argument_list|)
operator|==
name|CF_INETURL_W
operator|||
name|getCf
argument_list|(
name|formatetc
argument_list|)
operator|==
name|CF_INETURL
operator|)
operator|&&
name|mimeData
operator|->
name|hasUrls
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|convertFromMime
name|bool
name|QWindowsMimeURI
operator|::
name|convertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|,
name|STGMEDIUM
modifier|*
name|pmedium
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|canConvertFromMime
argument_list|(
name|formatetc
argument_list|,
name|mimeData
argument_list|)
condition|)
block|{
if|if
condition|(
name|getCf
argument_list|(
name|formatetc
argument_list|)
operator|==
name|CF_HDROP
condition|)
block|{
name|QList
argument_list|<
name|QUrl
argument_list|>
name|urls
init|=
name|mimeData
operator|->
name|urls
argument_list|()
decl_stmt|;
name|QStringList
name|fileNames
decl_stmt|;
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
name|DROPFILES
argument_list|)
operator|+
literal|2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|urls
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QString
name|fn
init|=
name|QDir
operator|::
name|toNativeSeparators
argument_list|(
name|urls
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toLocalFile
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fn
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
operator|*
operator|(
name|fn
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|)
expr_stmt|;
name|fileNames
operator|.
name|append
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
name|QByteArray
name|result
argument_list|(
name|size
argument_list|,
literal|'\0'
argument_list|)
decl_stmt|;
name|DROPFILES
modifier|*
name|d
init|=
operator|(
name|DROPFILES
operator|*
operator|)
name|result
operator|.
name|data
argument_list|()
decl_stmt|;
name|d
operator|->
name|pFiles
operator|=
sizeof|sizeof
argument_list|(
name|DROPFILES
argument_list|)
expr_stmt|;
name|GetCursorPos
argument_list|(
operator|&
name|d
operator|->
name|pt
argument_list|)
expr_stmt|;
comment|// try
name|d
operator|->
name|fNC
operator|=
literal|true
expr_stmt|;
name|char
modifier|*
name|files
init|=
operator|(
operator|(
name|char
operator|*
operator|)
name|d
operator|)
operator|+
name|d
operator|->
name|pFiles
decl_stmt|;
name|d
operator|->
name|fWide
operator|=
literal|true
expr_stmt|;
name|wchar_t
modifier|*
name|f
init|=
operator|(
name|wchar_t
operator|*
operator|)
name|files
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|l
init|=
name|fileNames
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|length
argument_list|()
decl_stmt|;
name|memcpy
argument_list|(
name|f
argument_list|,
name|fileNames
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|utf16
argument_list|()
argument_list|,
name|l
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|+=
name|l
expr_stmt|;
operator|*
name|f
operator|++
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|f
operator|=
literal|0
expr_stmt|;
return|return
name|setData
argument_list|(
name|result
argument_list|,
name|pmedium
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|getCf
argument_list|(
name|formatetc
argument_list|)
operator|==
name|CF_INETURL_W
condition|)
block|{
name|QList
argument_list|<
name|QUrl
argument_list|>
name|urls
init|=
name|mimeData
operator|->
name|urls
argument_list|()
decl_stmt|;
name|QByteArray
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|urls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|url
init|=
name|urls
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|result
operator|=
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|url
operator|.
name|utf16
argument_list|()
argument_list|,
name|url
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|setData
argument_list|(
name|result
argument_list|,
name|pmedium
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|getCf
argument_list|(
name|formatetc
argument_list|)
operator|==
name|CF_INETURL
condition|)
block|{
name|QList
argument_list|<
name|QUrl
argument_list|>
name|urls
init|=
name|mimeData
operator|->
name|urls
argument_list|()
decl_stmt|;
name|QByteArray
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|urls
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|=
name|urls
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|toLocal8Bit
argument_list|()
expr_stmt|;
return|return
name|setData
argument_list|(
name|result
argument_list|,
name|pmedium
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|canConvertToMime
name|bool
name|QWindowsMimeURI
operator|::
name|canConvertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
block|{
return|return
name|mimeType
operator|==
name|QStringLiteral
argument_list|(
literal|"text/uri-list"
argument_list|)
operator|&&
operator|(
name|canGetData
argument_list|(
name|CF_HDROP
argument_list|,
name|pDataObj
argument_list|)
operator|||
name|canGetData
argument_list|(
name|CF_INETURL_W
argument_list|,
name|pDataObj
argument_list|)
operator|||
name|canGetData
argument_list|(
name|CF_INETURL
argument_list|,
name|pDataObj
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|mimeForFormat
name|QString
name|QWindowsMimeURI
operator|::
name|mimeForFormat
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|)
specifier|const
block|{
name|QString
name|format
decl_stmt|;
if|if
condition|(
name|getCf
argument_list|(
name|formatetc
argument_list|)
operator|==
name|CF_HDROP
operator|||
name|getCf
argument_list|(
name|formatetc
argument_list|)
operator|==
name|CF_INETURL_W
operator|||
name|getCf
argument_list|(
name|formatetc
argument_list|)
operator|==
name|CF_INETURL
condition|)
name|format
operator|=
name|QStringLiteral
argument_list|(
literal|"text/uri-list"
argument_list|)
expr_stmt|;
return|return
name|format
return|;
block|}
end_function
begin_function
DECL|function|formatsForMime
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|QWindowsMimeURI
operator|::
name|formatsForMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
block|{
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|formatics
decl_stmt|;
if|if
condition|(
name|mimeType
operator|==
name|QStringLiteral
argument_list|(
literal|"text/uri-list"
argument_list|)
condition|)
block|{
if|if
condition|(
name|canConvertFromMime
argument_list|(
name|setCf
argument_list|(
name|CF_HDROP
argument_list|)
argument_list|,
name|mimeData
argument_list|)
condition|)
name|formatics
operator|+=
name|setCf
argument_list|(
name|CF_HDROP
argument_list|)
expr_stmt|;
if|if
condition|(
name|canConvertFromMime
argument_list|(
name|setCf
argument_list|(
name|CF_INETURL_W
argument_list|)
argument_list|,
name|mimeData
argument_list|)
condition|)
name|formatics
operator|+=
name|setCf
argument_list|(
name|CF_INETURL_W
argument_list|)
expr_stmt|;
if|if
condition|(
name|canConvertFromMime
argument_list|(
name|setCf
argument_list|(
name|CF_INETURL
argument_list|)
argument_list|,
name|mimeData
argument_list|)
condition|)
name|formatics
operator|+=
name|setCf
argument_list|(
name|CF_INETURL
argument_list|)
expr_stmt|;
block|}
return|return
name|formatics
return|;
block|}
end_function
begin_function
DECL|function|convertToMime
name|QVariant
name|QWindowsMimeURI
operator|::
name|convertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|LPDATAOBJECT
name|pDataObj
parameter_list|,
name|QVariant
operator|::
name|Type
name|preferredType
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|mimeType
operator|==
name|QStringLiteral
argument_list|(
literal|"text/uri-list"
argument_list|)
condition|)
block|{
if|if
condition|(
name|canGetData
argument_list|(
name|CF_HDROP
argument_list|,
name|pDataObj
argument_list|)
condition|)
block|{
name|QByteArray
name|texturi
decl_stmt|;
name|QList
argument_list|<
name|QVariant
argument_list|>
name|urls
decl_stmt|;
name|QByteArray
name|data
init|=
name|getData
argument_list|(
name|CF_HDROP
argument_list|,
name|pDataObj
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QVariant
argument_list|()
return|;
name|LPDROPFILES
name|hdrop
init|=
operator|(
name|LPDROPFILES
operator|)
name|data
operator|.
name|data
argument_list|()
decl_stmt|;
if|if
condition|(
name|hdrop
operator|->
name|fWide
condition|)
block|{
specifier|const
name|wchar_t
modifier|*
name|filesw
init|=
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
operator|(
name|data
operator|.
name|data
argument_list|()
operator|+
name|hdrop
operator|->
name|pFiles
operator|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|filesw
index|[
name|i
index|]
condition|)
block|{
name|QString
name|fileurl
init|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|filesw
operator|+
name|i
argument_list|)
decl_stmt|;
name|urls
operator|+=
name|QUrl
operator|::
name|fromLocalFile
argument_list|(
name|fileurl
argument_list|)
expr_stmt|;
name|i
operator|+=
name|fileurl
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|files
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
operator|.
name|data
argument_list|()
operator|+
name|hdrop
operator|->
name|pFiles
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|files
index|[
name|i
index|]
condition|)
block|{
name|urls
operator|+=
name|QUrl
operator|::
name|fromLocalFile
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|files
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
name|int
argument_list|(
name|strlen
argument_list|(
name|files
operator|+
name|i
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|preferredType
operator|==
name|QVariant
operator|::
name|Url
operator|&&
name|urls
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
name|urls
operator|.
name|at
argument_list|(
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|urls
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|urls
return|;
block|}
elseif|else
if|if
condition|(
name|canGetData
argument_list|(
name|CF_INETURL_W
argument_list|,
name|pDataObj
argument_list|)
condition|)
block|{
name|QByteArray
name|data
init|=
name|getData
argument_list|(
name|CF_INETURL_W
argument_list|,
name|pDataObj
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QVariant
argument_list|()
return|;
return|return
name|QUrl
argument_list|(
name|QString
operator|::
name|fromWCharArray
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|data
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|canGetData
argument_list|(
name|CF_INETURL
argument_list|,
name|pDataObj
argument_list|)
condition|)
block|{
name|QByteArray
name|data
init|=
name|getData
argument_list|(
name|CF_INETURL
argument_list|,
name|pDataObj
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QVariant
argument_list|()
return|;
return|return
name|QUrl
argument_list|(
name|QString
operator|::
name|fromLocal8Bit
argument_list|(
name|data
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_class
DECL|class|QWindowsMimeHtml
class|class
name|QWindowsMimeHtml
super|:
specifier|public
name|QWindowsMime
block|{
public|public:
name|QWindowsMimeHtml
parameter_list|()
constructor_decl|;
comment|// for converting from Qt
name|bool
name|canConvertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
function_decl|;
name|bool
name|convertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|,
name|STGMEDIUM
modifier|*
name|pmedium
parameter_list|)
specifier|const
function_decl|;
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|formatsForMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
function_decl|;
comment|// for converting to Qt
name|bool
name|canConvertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
function_decl|;
name|QVariant
name|convertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mime
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|,
name|QVariant
operator|::
name|Type
name|preferredType
parameter_list|)
specifier|const
function_decl|;
name|QString
name|mimeForFormat
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|)
specifier|const
function_decl|;
private|private:
DECL|member|CF_HTML
name|int
name|CF_HTML
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QWindowsMimeHtml
name|QWindowsMimeHtml
operator|::
name|QWindowsMimeHtml
parameter_list|()
block|{
name|CF_HTML
operator|=
name|QWindowsMime
operator|::
name|registerMimeType
argument_list|(
name|QStringLiteral
argument_list|(
literal|"HTML Format"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|formatsForMime
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|QWindowsMimeHtml
operator|::
name|formatsForMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
block|{
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|formatetcs
decl_stmt|;
if|if
condition|(
name|mimeType
operator|==
name|QStringLiteral
argument_list|(
literal|"text/html"
argument_list|)
operator|&&
operator|(
operator|!
name|mimeData
operator|->
name|html
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
name|formatetcs
operator|+=
name|setCf
argument_list|(
name|CF_HTML
argument_list|)
expr_stmt|;
return|return
name|formatetcs
return|;
block|}
end_function
begin_function
DECL|function|mimeForFormat
name|QString
name|QWindowsMimeHtml
operator|::
name|mimeForFormat
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|getCf
argument_list|(
name|formatetc
argument_list|)
operator|==
name|CF_HTML
condition|)
return|return
name|QStringLiteral
argument_list|(
literal|"text/html"
argument_list|)
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|canConvertToMime
name|bool
name|QWindowsMimeHtml
operator|::
name|canConvertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
block|{
return|return
name|mimeType
operator|==
name|QStringLiteral
argument_list|(
literal|"text/html"
argument_list|)
operator|&&
name|canGetData
argument_list|(
name|CF_HTML
argument_list|,
name|pDataObj
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|canConvertFromMime
name|bool
name|QWindowsMimeHtml
operator|::
name|canConvertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
block|{
return|return
name|getCf
argument_list|(
name|formatetc
argument_list|)
operator|==
name|CF_HTML
operator|&&
operator|(
operator|!
name|mimeData
operator|->
name|html
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/* The windows HTML clipboard format is as follows (xxxxxxxxxx is a 10 integer number giving the positions in bytes). Charset used is mostly utf8, but can be different, ie. we have to look for the<meta> charset tag    Version: 1.0   StartHTML:xxxxxxxxxx   EndHTML:xxxxxxxxxx   StartFragment:xxxxxxxxxx   EndFragment:xxxxxxxxxx   ...html...  */
end_comment
begin_function
DECL|function|convertToMime
name|QVariant
name|QWindowsMimeHtml
operator|::
name|convertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mime
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|,
name|QVariant
operator|::
name|Type
name|preferredType
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|preferredType
argument_list|)
expr_stmt|;
name|QVariant
name|result
decl_stmt|;
if|if
condition|(
name|canConvertToMime
argument_list|(
name|mime
argument_list|,
name|pDataObj
argument_list|)
condition|)
block|{
name|QByteArray
name|html
init|=
name|getData
argument_list|(
name|CF_HTML
argument_list|,
name|pDataObj
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QMIME_DEBUG
name|qDebug
argument_list|(
literal|"QWindowsMimeHtml::convertToMime"
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"raw :"
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
name|html
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|start
init|=
name|html
operator|.
name|indexOf
argument_list|(
literal|"StartHTML:"
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|html
operator|.
name|indexOf
argument_list|(
literal|"EndHTML:"
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|startOffset
init|=
name|start
operator|+
literal|10
decl_stmt|;
name|int
name|i
init|=
name|startOffset
decl_stmt|;
while|while
condition|(
name|html
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
literal|'\r'
operator|&&
name|html
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
literal|'\n'
condition|)
operator|++
name|i
expr_stmt|;
name|QByteArray
name|bytecount
init|=
name|html
operator|.
name|mid
argument_list|(
name|startOffset
argument_list|,
name|i
operator|-
name|startOffset
argument_list|)
decl_stmt|;
name|start
operator|=
name|bytecount
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|endOffset
init|=
name|end
operator|+
literal|8
decl_stmt|;
name|int
name|i
init|=
name|endOffset
decl_stmt|;
while|while
condition|(
name|html
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
literal|'\r'
operator|&&
name|html
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|!=
literal|'\n'
condition|)
operator|++
name|i
expr_stmt|;
name|QByteArray
name|bytecount
init|=
name|html
operator|.
name|mid
argument_list|(
name|endOffset
argument_list|,
name|i
operator|-
name|endOffset
argument_list|)
decl_stmt|;
name|end
operator|=
name|bytecount
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|>
name|start
operator|&&
name|start
operator|>
literal|0
condition|)
block|{
name|html
operator|=
name|html
operator|.
name|mid
argument_list|(
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|html
operator|.
name|replace
argument_list|(
literal|'\r'
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|result
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|html
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|convertFromMime
name|bool
name|QWindowsMimeHtml
operator|::
name|convertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|,
name|STGMEDIUM
modifier|*
name|pmedium
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|canConvertFromMime
argument_list|(
name|formatetc
argument_list|,
name|mimeData
argument_list|)
condition|)
block|{
name|QByteArray
name|data
init|=
name|mimeData
operator|->
name|html
argument_list|()
operator|.
name|toUtf8
argument_list|()
decl_stmt|;
name|QByteArray
name|result
init|=
literal|"Version:1.0\r\n"
comment|// 0-12
literal|"StartHTML:0000000107\r\n"
comment|// 13-35
literal|"EndHTML:0000000000\r\n"
comment|// 36-55
literal|"StartFragment:0000000000\r\n"
comment|// 56-81
literal|"EndFragment:0000000000\r\n\r\n"
decl_stmt|;
comment|// 82-107
if|if
condition|(
name|data
operator|.
name|indexOf
argument_list|(
literal|"<!--StartFragment-->"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|result
operator|+=
literal|"<!--StartFragment-->"
expr_stmt|;
name|result
operator|+=
name|data
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|indexOf
argument_list|(
literal|"<!--EndFragment-->"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|result
operator|+=
literal|"<!--EndFragment-->"
expr_stmt|;
comment|// set the correct number for EndHTML
name|QByteArray
name|pos
init|=
name|QString
operator|::
name|number
argument_list|(
name|result
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|result
operator|.
name|data
argument_list|()
operator|+
literal|53
operator|-
name|pos
operator|.
name|length
argument_list|()
operator|)
argument_list|,
name|pos
operator|.
name|constData
argument_list|()
argument_list|,
name|pos
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// set correct numbers for StartFragment and EndFragment
name|pos
operator|=
name|QString
operator|::
name|number
argument_list|(
name|result
operator|.
name|indexOf
argument_list|(
literal|"<!--StartFragment-->"
argument_list|)
operator|+
literal|20
argument_list|)
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|result
operator|.
name|data
argument_list|()
operator|+
literal|79
operator|-
name|pos
operator|.
name|length
argument_list|()
operator|)
argument_list|,
name|pos
operator|.
name|constData
argument_list|()
argument_list|,
name|pos
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|pos
operator|=
name|QString
operator|::
name|number
argument_list|(
name|result
operator|.
name|indexOf
argument_list|(
literal|"<!--EndFragment-->"
argument_list|)
argument_list|)
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|result
operator|.
name|data
argument_list|()
operator|+
literal|103
operator|-
name|pos
operator|.
name|length
argument_list|()
operator|)
argument_list|,
name|pos
operator|.
name|constData
argument_list|()
argument_list|,
name|pos
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|setData
argument_list|(
name|result
argument_list|,
name|pmedium
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_IMAGEFORMAT_BMP
end_ifndef
begin_class
DECL|class|QWindowsMimeImage
class|class
name|QWindowsMimeImage
super|:
specifier|public
name|QWindowsMime
block|{
public|public:
name|QWindowsMimeImage
parameter_list|()
constructor_decl|;
comment|// for converting from Qt
name|bool
name|canConvertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
function_decl|;
name|bool
name|convertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|,
name|STGMEDIUM
modifier|*
name|pmedium
parameter_list|)
specifier|const
function_decl|;
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|formatsForMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
function_decl|;
comment|// for converting to Qt
name|bool
name|canConvertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
function_decl|;
name|QVariant
name|convertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mime
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|,
name|QVariant
operator|::
name|Type
name|preferredType
parameter_list|)
specifier|const
function_decl|;
name|QString
name|mimeForFormat
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|)
specifier|const
function_decl|;
private|private:
name|bool
name|hasOriginalDIBV5
parameter_list|(
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
function_decl|;
DECL|member|CF_PNG
name|UINT
name|CF_PNG
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QWindowsMimeImage
name|QWindowsMimeImage
operator|::
name|QWindowsMimeImage
parameter_list|()
block|{
name|CF_PNG
operator|=
name|RegisterClipboardFormat
argument_list|(
literal|L"PNG"
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|formatsForMime
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|QWindowsMimeImage
operator|::
name|formatsForMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
block|{
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|formatetcs
decl_stmt|;
if|if
condition|(
name|mimeData
operator|->
name|hasImage
argument_list|()
operator|&&
name|mimeType
operator|==
name|QStringLiteral
argument_list|(
literal|"application/x-qt-image"
argument_list|)
condition|)
block|{
comment|//add DIBV5 if image has alpha channel
name|QImage
name|image
init|=
name|qvariant_cast
argument_list|<
name|QImage
argument_list|>
argument_list|(
name|mimeData
operator|->
name|imageData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|image
operator|.
name|isNull
argument_list|()
operator|&&
name|image
operator|.
name|hasAlphaChannel
argument_list|()
condition|)
name|formatetcs
operator|+=
name|setCf
argument_list|(
name|CF_DIBV5
argument_list|)
expr_stmt|;
name|formatetcs
operator|+=
name|setCf
argument_list|(
name|CF_DIB
argument_list|)
expr_stmt|;
block|}
return|return
name|formatetcs
return|;
block|}
end_function
begin_function
DECL|function|mimeForFormat
name|QString
name|QWindowsMimeImage
operator|::
name|mimeForFormat
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|)
specifier|const
block|{
name|int
name|cf
init|=
name|getCf
argument_list|(
name|formatetc
argument_list|)
decl_stmt|;
if|if
condition|(
name|cf
operator|==
name|CF_DIB
operator|||
name|cf
operator|==
name|CF_DIBV5
operator|||
name|cf
operator|==
name|int
argument_list|(
name|CF_PNG
argument_list|)
condition|)
return|return
name|QStringLiteral
argument_list|(
literal|"application/x-qt-image"
argument_list|)
return|;
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|canConvertToMime
name|bool
name|QWindowsMimeImage
operator|::
name|canConvertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|(
name|mimeType
operator|==
name|QStringLiteral
argument_list|(
literal|"application/x-qt-image"
argument_list|)
operator|)
operator|&&
operator|(
name|canGetData
argument_list|(
name|CF_DIB
argument_list|,
name|pDataObj
argument_list|)
operator|||
name|canGetData
argument_list|(
name|CF_PNG
argument_list|,
name|pDataObj
argument_list|)
operator|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|canConvertFromMime
name|bool
name|QWindowsMimeImage
operator|::
name|canConvertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
block|{
name|int
name|cf
init|=
name|getCf
argument_list|(
name|formatetc
argument_list|)
decl_stmt|;
if|if
condition|(
name|mimeData
operator|->
name|hasImage
argument_list|()
condition|)
block|{
if|if
condition|(
name|cf
operator|==
name|CF_DIB
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|cf
operator|==
name|CF_DIBV5
condition|)
block|{
comment|//support DIBV5 conversion only if the image has alpha channel
name|QImage
name|image
init|=
name|qvariant_cast
argument_list|<
name|QImage
argument_list|>
argument_list|(
name|mimeData
operator|->
name|imageData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|image
operator|.
name|isNull
argument_list|()
operator|&&
name|image
operator|.
name|hasAlphaChannel
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|convertFromMime
name|bool
name|QWindowsMimeImage
operator|::
name|convertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|,
name|STGMEDIUM
modifier|*
name|pmedium
parameter_list|)
specifier|const
block|{
name|int
name|cf
init|=
name|getCf
argument_list|(
name|formatetc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|cf
operator|==
name|CF_DIB
operator|||
name|cf
operator|==
name|CF_DIBV5
operator|)
operator|&&
name|mimeData
operator|->
name|hasImage
argument_list|()
condition|)
block|{
name|QImage
name|img
init|=
name|qvariant_cast
argument_list|<
name|QImage
argument_list|>
argument_list|(
name|mimeData
operator|->
name|imageData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|img
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
name|QByteArray
name|ba
decl_stmt|;
if|if
condition|(
name|cf
operator|==
name|CF_DIB
condition|)
block|{
if|if
condition|(
name|img
operator|.
name|format
argument_list|()
operator|>
name|QImage
operator|::
name|Format_ARGB32
condition|)
name|img
operator|=
name|img
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_RGB32
argument_list|)
expr_stmt|;
specifier|const
name|QByteArray
name|ba
init|=
name|writeDib
argument_list|(
name|img
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ba
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|setData
argument_list|(
name|ba
argument_list|,
name|pmedium
argument_list|)
return|;
block|}
else|else
block|{
name|QDataStream
name|s
argument_list|(
operator|&
name|ba
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|s
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|LittleEndian
argument_list|)
expr_stmt|;
comment|// Intel byte order ####
if|if
condition|(
name|qt_write_dibv5
argument_list|(
name|s
argument_list|,
name|img
argument_list|)
condition|)
return|return
name|setData
argument_list|(
name|ba
argument_list|,
name|pmedium
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|hasOriginalDIBV5
name|bool
name|QWindowsMimeImage
operator|::
name|hasOriginalDIBV5
parameter_list|(
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
block|{
name|bool
name|isSynthesized
init|=
literal|true
decl_stmt|;
name|IEnumFORMATETC
modifier|*
name|pEnum
init|=
name|NULL
decl_stmt|;
name|HRESULT
name|res
init|=
name|pDataObj
operator|->
name|EnumFormatEtc
argument_list|(
literal|1
argument_list|,
operator|&
name|pEnum
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|S_OK
operator|&&
name|pEnum
condition|)
block|{
name|FORMATETC
name|fc
decl_stmt|;
while|while
condition|(
operator|(
name|res
operator|=
name|pEnum
operator|->
name|Next
argument_list|(
literal|1
argument_list|,
operator|&
name|fc
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|S_OK
condition|)
block|{
if|if
condition|(
name|fc
operator|.
name|ptd
condition|)
name|CoTaskMemFree
argument_list|(
name|fc
operator|.
name|ptd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|.
name|cfFormat
operator|==
name|CF_DIB
condition|)
break|break;
elseif|else
if|if
condition|(
name|fc
operator|.
name|cfFormat
operator|==
name|CF_DIBV5
condition|)
block|{
name|isSynthesized
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
name|pEnum
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
return|return
operator|!
name|isSynthesized
return|;
block|}
end_function
begin_function
DECL|function|convertToMime
name|QVariant
name|QWindowsMimeImage
operator|::
name|convertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|,
name|QVariant
operator|::
name|Type
name|preferredType
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|preferredType
argument_list|)
expr_stmt|;
name|QVariant
name|result
decl_stmt|;
if|if
condition|(
name|mimeType
operator|!=
name|QStringLiteral
argument_list|(
literal|"application/x-qt-image"
argument_list|)
condition|)
return|return
name|result
return|;
comment|//Try to convert from a format which has more data
comment|//DIBV5, use only if its is not synthesized
if|if
condition|(
name|canGetData
argument_list|(
name|CF_DIBV5
argument_list|,
name|pDataObj
argument_list|)
operator|&&
name|hasOriginalDIBV5
argument_list|(
name|pDataObj
argument_list|)
condition|)
block|{
name|QImage
name|img
decl_stmt|;
name|QByteArray
name|data
init|=
name|getData
argument_list|(
name|CF_DIBV5
argument_list|,
name|pDataObj
argument_list|)
decl_stmt|;
name|QDataStream
name|s
argument_list|(
operator|&
name|data
argument_list|,
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
decl_stmt|;
name|s
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|LittleEndian
argument_list|)
expr_stmt|;
if|if
condition|(
name|qt_read_dibv5
argument_list|(
name|s
argument_list|,
name|img
argument_list|)
condition|)
block|{
comment|// #### supports only 32bit DIBV5
return|return
name|img
return|;
block|}
block|}
comment|//PNG, MS Office place this (undocumented)
if|if
condition|(
name|canGetData
argument_list|(
name|CF_PNG
argument_list|,
name|pDataObj
argument_list|)
condition|)
block|{
name|QImage
name|img
decl_stmt|;
name|QByteArray
name|data
init|=
name|getData
argument_list|(
name|CF_PNG
argument_list|,
name|pDataObj
argument_list|)
decl_stmt|;
if|if
condition|(
name|img
operator|.
name|loadFromData
argument_list|(
name|data
argument_list|,
literal|"PNG"
argument_list|)
condition|)
block|{
return|return
name|img
return|;
block|}
block|}
comment|//Fallback to DIB
if|if
condition|(
name|canGetData
argument_list|(
name|CF_DIB
argument_list|,
name|pDataObj
argument_list|)
condition|)
block|{
specifier|const
name|QImage
name|img
init|=
name|readDib
argument_list|(
name|getData
argument_list|(
name|CF_DIB
argument_list|,
name|pDataObj
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|img
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|img
return|;
block|}
comment|// Failed
return|return
name|result
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|QBuiltInMimes
class|class
name|QBuiltInMimes
super|:
specifier|public
name|QWindowsMime
block|{
public|public:
name|QBuiltInMimes
parameter_list|()
constructor_decl|;
comment|// for converting from Qt
name|bool
name|canConvertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
function_decl|;
name|bool
name|convertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|,
name|STGMEDIUM
modifier|*
name|pmedium
parameter_list|)
specifier|const
function_decl|;
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|formatsForMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
function_decl|;
comment|// for converting to Qt
name|bool
name|canConvertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
function_decl|;
name|QVariant
name|convertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mime
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|,
name|QVariant
operator|::
name|Type
name|preferredType
parameter_list|)
specifier|const
function_decl|;
name|QString
name|mimeForFormat
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|)
specifier|const
function_decl|;
private|private:
DECL|member|outFormats
name|QMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
name|outFormats
decl_stmt|;
DECL|member|inFormats
name|QMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
name|inFormats
decl_stmt|;
block|}
class|;
end_class
begin_constructor
DECL|function|QBuiltInMimes
name|QBuiltInMimes
operator|::
name|QBuiltInMimes
parameter_list|()
member_init_list|:
name|QWindowsMime
argument_list|()
block|{
name|outFormats
operator|.
name|insert
argument_list|(
name|QWindowsMime
operator|::
name|registerMimeType
argument_list|(
name|QStringLiteral
argument_list|(
literal|"application/x-color"
argument_list|)
argument_list|)
argument_list|,
name|QStringLiteral
argument_list|(
literal|"application/x-color"
argument_list|)
argument_list|)
expr_stmt|;
name|inFormats
operator|.
name|insert
argument_list|(
name|QWindowsMime
operator|::
name|registerMimeType
argument_list|(
name|QStringLiteral
argument_list|(
literal|"application/x-color"
argument_list|)
argument_list|)
argument_list|,
name|QStringLiteral
argument_list|(
literal|"application/x-color"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|canConvertFromMime
name|bool
name|QBuiltInMimes
operator|::
name|canConvertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
block|{
comment|// really check
return|return
name|formatetc
operator|.
name|tymed
operator|&
name|TYMED_HGLOBAL
operator|&&
name|outFormats
operator|.
name|contains
argument_list|(
name|formatetc
operator|.
name|cfFormat
argument_list|)
operator|&&
name|mimeData
operator|->
name|formats
argument_list|()
operator|.
name|contains
argument_list|(
name|outFormats
operator|.
name|value
argument_list|(
name|formatetc
operator|.
name|cfFormat
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convertFromMime
name|bool
name|QBuiltInMimes
operator|::
name|convertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|,
name|STGMEDIUM
modifier|*
name|pmedium
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|canConvertFromMime
argument_list|(
name|formatetc
argument_list|,
name|mimeData
argument_list|)
condition|)
block|{
name|QByteArray
name|data
decl_stmt|;
if|if
condition|(
name|outFormats
operator|.
name|value
argument_list|(
name|getCf
argument_list|(
name|formatetc
argument_list|)
argument_list|)
operator|==
name|QStringLiteral
argument_list|(
literal|"text/html"
argument_list|)
condition|)
block|{
comment|// text/html is in wide chars on windows (compatible with mozillia)
name|QString
name|html
init|=
name|mimeData
operator|->
name|html
argument_list|()
decl_stmt|;
comment|// same code as in the text converter up above
specifier|const
name|QChar
modifier|*
name|u
init|=
name|html
operator|.
name|unicode
argument_list|()
decl_stmt|;
name|QString
name|res
decl_stmt|;
specifier|const
name|int
name|s
init|=
name|html
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|maxsize
init|=
name|s
operator|+
name|s
operator|/
literal|40
operator|+
literal|3
decl_stmt|;
name|res
operator|.
name|resize
argument_list|(
name|maxsize
argument_list|)
expr_stmt|;
name|int
name|ri
init|=
literal|0
decl_stmt|;
name|bool
name|cr
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|*
name|u
operator|==
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
condition|)
name|cr
operator|=
literal|true
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|u
operator|==
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
operator|&&
operator|!
name|cr
condition|)
name|res
index|[
name|ri
operator|++
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|cr
operator|=
literal|false
expr_stmt|;
block|}
name|res
index|[
name|ri
operator|++
index|]
operator|=
operator|*
name|u
expr_stmt|;
if|if
condition|(
name|ri
operator|+
literal|3
operator|>=
name|maxsize
condition|)
block|{
name|maxsize
operator|+=
name|maxsize
operator|/
literal|4
expr_stmt|;
name|res
operator|.
name|resize
argument_list|(
name|maxsize
argument_list|)
expr_stmt|;
block|}
operator|++
name|u
expr_stmt|;
block|}
name|res
operator|.
name|truncate
argument_list|(
name|ri
argument_list|)
expr_stmt|;
specifier|const
name|int
name|byteLength
init|=
name|res
operator|.
name|length
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
decl_stmt|;
name|QByteArray
name|r
argument_list|(
name|byteLength
operator|+
literal|2
argument_list|,
literal|'\0'
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|r
operator|.
name|data
argument_list|()
argument_list|,
name|res
operator|.
name|unicode
argument_list|()
argument_list|,
name|byteLength
argument_list|)
expr_stmt|;
name|r
index|[
name|byteLength
index|]
operator|=
literal|0
expr_stmt|;
name|r
index|[
name|byteLength
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
name|data
operator|=
name|QInternalMimeData
operator|::
name|renderDataHelper
argument_list|(
name|outFormats
operator|.
name|value
argument_list|(
name|getCf
argument_list|(
name|formatetc
argument_list|)
argument_list|)
argument_list|,
name|mimeData
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//QT_NO_DRAGANDDROP
block|}
return|return
name|setData
argument_list|(
name|data
argument_list|,
name|pmedium
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|formatsForMime
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|QBuiltInMimes
operator|::
name|formatsForMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
block|{
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|formatetcs
decl_stmt|;
if|if
condition|(
operator|!
name|outFormats
operator|.
name|keys
argument_list|(
name|mimeType
argument_list|)
operator|.
name|isEmpty
argument_list|()
operator|&&
name|mimeData
operator|->
name|formats
argument_list|()
operator|.
name|contains
argument_list|(
name|mimeType
argument_list|)
condition|)
name|formatetcs
operator|+=
name|setCf
argument_list|(
name|outFormats
operator|.
name|key
argument_list|(
name|mimeType
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|formatetcs
return|;
block|}
end_function
begin_function
DECL|function|canConvertToMime
name|bool
name|QBuiltInMimes
operator|::
name|canConvertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
block|{
return|return
operator|(
operator|!
name|inFormats
operator|.
name|keys
argument_list|(
name|mimeType
argument_list|)
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
name|canGetData
argument_list|(
name|inFormats
operator|.
name|key
argument_list|(
name|mimeType
argument_list|)
argument_list|,
name|pDataObj
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convertToMime
name|QVariant
name|QBuiltInMimes
operator|::
name|convertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|,
name|QVariant
operator|::
name|Type
name|preferredType
parameter_list|)
specifier|const
block|{
name|QVariant
name|val
decl_stmt|;
if|if
condition|(
name|canConvertToMime
argument_list|(
name|mimeType
argument_list|,
name|pDataObj
argument_list|)
condition|)
block|{
name|QByteArray
name|data
init|=
name|getData
argument_list|(
name|inFormats
operator|.
name|key
argument_list|(
name|mimeType
argument_list|)
argument_list|,
name|pDataObj
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|QMIME_DEBUG
name|qDebug
argument_list|(
literal|"QBuiltInMimes::convertToMime()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mimeType
operator|==
name|QStringLiteral
argument_list|(
literal|"text/html"
argument_list|)
operator|&&
name|preferredType
operator|==
name|QVariant
operator|::
name|String
condition|)
block|{
comment|// text/html is in wide chars on windows (compatible with Mozilla)
name|val
operator|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|data
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|data
expr_stmt|;
comment|// it should be enough to return the data and let QMimeData do the rest.
block|}
block|}
block|}
return|return
name|val
return|;
block|}
end_function
begin_function
DECL|function|mimeForFormat
name|QString
name|QBuiltInMimes
operator|::
name|mimeForFormat
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|)
specifier|const
block|{
return|return
name|inFormats
operator|.
name|value
argument_list|(
name|getCf
argument_list|(
name|formatetc
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_class
DECL|class|QLastResortMimes
class|class
name|QLastResortMimes
super|:
specifier|public
name|QWindowsMime
block|{
public|public:
name|QLastResortMimes
parameter_list|()
constructor_decl|;
comment|// for converting from Qt
name|bool
name|canConvertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
function_decl|;
name|bool
name|convertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|,
name|STGMEDIUM
modifier|*
name|pmedium
parameter_list|)
specifier|const
function_decl|;
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|formatsForMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
function_decl|;
comment|// for converting to Qt
name|bool
name|canConvertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
function_decl|;
name|QVariant
name|convertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mime
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|,
name|QVariant
operator|::
name|Type
name|preferredType
parameter_list|)
specifier|const
function_decl|;
name|QString
name|mimeForFormat
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|)
specifier|const
function_decl|;
private|private:
DECL|member|formats
name|QMap
argument_list|<
name|int
argument_list|,
name|QString
argument_list|>
name|formats
decl_stmt|;
DECL|member|ianaTypes
specifier|static
name|QStringList
name|ianaTypes
decl_stmt|;
DECL|member|excludeList
specifier|static
name|QStringList
name|excludeList
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|member|ianaTypes
name|QStringList
name|QLastResortMimes
operator|::
name|ianaTypes
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|excludeList
name|QStringList
name|QLastResortMimes
operator|::
name|excludeList
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QLastResortMimes
name|QLastResortMimes
operator|::
name|QLastResortMimes
parameter_list|()
block|{
comment|//MIME Media-Types
if|if
condition|(
operator|!
name|ianaTypes
operator|.
name|size
argument_list|()
condition|)
block|{
name|ianaTypes
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"application/"
argument_list|)
argument_list|)
expr_stmt|;
name|ianaTypes
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"audio/"
argument_list|)
argument_list|)
expr_stmt|;
name|ianaTypes
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"example/"
argument_list|)
argument_list|)
expr_stmt|;
name|ianaTypes
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"image/"
argument_list|)
argument_list|)
expr_stmt|;
name|ianaTypes
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"message/"
argument_list|)
argument_list|)
expr_stmt|;
name|ianaTypes
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"model/"
argument_list|)
argument_list|)
expr_stmt|;
name|ianaTypes
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"multipart/"
argument_list|)
argument_list|)
expr_stmt|;
name|ianaTypes
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"text/"
argument_list|)
argument_list|)
expr_stmt|;
name|ianaTypes
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"video/"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//Types handled by other classes
if|if
condition|(
operator|!
name|excludeList
operator|.
name|size
argument_list|()
condition|)
block|{
name|excludeList
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"HTML Format"
argument_list|)
argument_list|)
expr_stmt|;
name|excludeList
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"UniformResourceLocator"
argument_list|)
argument_list|)
expr_stmt|;
name|excludeList
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"text/html"
argument_list|)
argument_list|)
expr_stmt|;
name|excludeList
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"text/plain"
argument_list|)
argument_list|)
expr_stmt|;
name|excludeList
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"text/uri-list"
argument_list|)
argument_list|)
expr_stmt|;
name|excludeList
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"application/x-qt-image"
argument_list|)
argument_list|)
expr_stmt|;
name|excludeList
operator|.
name|append
argument_list|(
name|QStringLiteral
argument_list|(
literal|"application/x-color"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_constructor
begin_function
DECL|function|canConvertFromMime
name|bool
name|QLastResortMimes
operator|::
name|canConvertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
block|{
comment|// really check
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
return|return
name|formatetc
operator|.
name|tymed
operator|&
name|TYMED_HGLOBAL
operator|&&
operator|(
name|formats
operator|.
name|contains
argument_list|(
name|formatetc
operator|.
name|cfFormat
argument_list|)
operator|&&
name|QInternalMimeData
operator|::
name|hasFormatHelper
argument_list|(
name|formats
operator|.
name|value
argument_list|(
name|formatetc
operator|.
name|cfFormat
argument_list|)
argument_list|,
name|mimeData
argument_list|)
operator|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|mimeData
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|formatetc
argument_list|)
expr_stmt|;
return|return
name|formatetc
operator|.
name|tymed
operator|&
name|TYMED_HGLOBAL
operator|&&
name|formats
operator|.
name|contains
argument_list|(
name|formatetc
operator|.
name|cfFormat
argument_list|)
return|;
endif|#
directive|endif
comment|//QT_NO_DRAGANDDROP
block|}
end_function
begin_function
DECL|function|convertFromMime
name|bool
name|QLastResortMimes
operator|::
name|convertFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|,
name|STGMEDIUM
modifier|*
name|pmedium
parameter_list|)
specifier|const
block|{
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
return|return
name|canConvertFromMime
argument_list|(
name|formatetc
argument_list|,
name|mimeData
argument_list|)
operator|&&
name|setData
argument_list|(
name|QInternalMimeData
operator|::
name|renderDataHelper
argument_list|(
name|formats
operator|.
name|value
argument_list|(
name|getCf
argument_list|(
name|formatetc
argument_list|)
argument_list|)
argument_list|,
name|mimeData
argument_list|)
argument_list|,
name|pmedium
argument_list|)
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|mimeData
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|formatetc
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|pmedium
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
endif|#
directive|endif
comment|//QT_NO_DRAGANDDROP
block|}
end_function
begin_function
DECL|function|formatsForMime
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|QLastResortMimes
operator|::
name|formatsForMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
specifier|const
name|QMimeData
modifier|*
comment|/*mimeData*/
parameter_list|)
specifier|const
block|{
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|formatetcs
decl_stmt|;
if|if
condition|(
operator|!
name|formats
operator|.
name|keys
argument_list|(
name|mimeType
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|formatetcs
operator|+=
name|setCf
argument_list|(
name|formats
operator|.
name|key
argument_list|(
name|mimeType
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|excludeList
operator|.
name|contains
argument_list|(
name|mimeType
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
block|{
comment|// register any other available formats
name|int
name|cf
init|=
name|QWindowsMime
operator|::
name|registerMimeType
argument_list|(
name|mimeType
argument_list|)
decl_stmt|;
name|QLastResortMimes
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QLastResortMimes
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|formats
operator|.
name|insert
argument_list|(
name|cf
argument_list|,
name|mimeType
argument_list|)
expr_stmt|;
name|formatetcs
operator|+=
name|setCf
argument_list|(
name|cf
argument_list|)
expr_stmt|;
block|}
return|return
name|formatetcs
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|x_qt_windows_mime
specifier|static
specifier|const
name|char
name|x_qt_windows_mime
index|[]
init|=
literal|"application/x-qt-windows-mime;value=\""
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|isCustomMimeType
specifier|static
name|bool
name|isCustomMimeType
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|)
block|{
return|return
name|mimeType
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
name|x_qt_windows_mime
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|customMimeType
specifier|static
name|QString
name|customMimeType
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|)
block|{
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
name|x_qt_windows_mime
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|n
init|=
name|mimeType
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
argument_list|)
operator|-
name|len
decl_stmt|;
return|return
name|mimeType
operator|.
name|mid
argument_list|(
name|len
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|canConvertToMime
name|bool
name|QLastResortMimes
operator|::
name|canConvertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|isCustomMimeType
argument_list|(
name|mimeType
argument_list|)
condition|)
block|{
name|QString
name|clipFormat
init|=
name|customMimeType
argument_list|(
name|mimeType
argument_list|)
decl_stmt|;
name|int
name|cf
init|=
name|RegisterClipboardFormat
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|clipFormat
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|canGetData
argument_list|(
name|cf
argument_list|,
name|pDataObj
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|formats
operator|.
name|keys
argument_list|(
name|mimeType
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// if it is not in there then register it an see if we can get it
name|int
name|cf
init|=
name|QWindowsMime
operator|::
name|registerMimeType
argument_list|(
name|mimeType
argument_list|)
decl_stmt|;
return|return
name|canGetData
argument_list|(
name|cf
argument_list|,
name|pDataObj
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|canGetData
argument_list|(
name|formats
operator|.
name|key
argument_list|(
name|mimeType
argument_list|)
argument_list|,
name|pDataObj
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|convertToMime
name|QVariant
name|QLastResortMimes
operator|::
name|convertToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|,
name|QVariant
operator|::
name|Type
name|preferredType
parameter_list|)
specifier|const
block|{
name|Q_UNUSED
argument_list|(
name|preferredType
argument_list|)
expr_stmt|;
name|QVariant
name|val
decl_stmt|;
if|if
condition|(
name|canConvertToMime
argument_list|(
name|mimeType
argument_list|,
name|pDataObj
argument_list|)
condition|)
block|{
name|QByteArray
name|data
decl_stmt|;
if|if
condition|(
name|isCustomMimeType
argument_list|(
name|mimeType
argument_list|)
condition|)
block|{
name|QString
name|clipFormat
init|=
name|customMimeType
argument_list|(
name|mimeType
argument_list|)
decl_stmt|;
name|int
name|cf
init|=
name|RegisterClipboardFormat
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|wchar_t
operator|*
argument_list|>
argument_list|(
name|clipFormat
operator|.
name|utf16
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|data
operator|=
name|getData
argument_list|(
name|cf
argument_list|,
name|pDataObj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|formats
operator|.
name|keys
argument_list|(
name|mimeType
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|cf
init|=
name|QWindowsMime
operator|::
name|registerMimeType
argument_list|(
name|mimeType
argument_list|)
decl_stmt|;
name|data
operator|=
name|getData
argument_list|(
name|cf
argument_list|,
name|pDataObj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|getData
argument_list|(
name|formats
operator|.
name|key
argument_list|(
name|mimeType
argument_list|)
argument_list|,
name|pDataObj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|data
operator|.
name|isEmpty
argument_list|()
condition|)
name|val
operator|=
name|data
expr_stmt|;
comment|// it should be enough to return the data and let QMimeData do the rest.
block|}
return|return
name|val
return|;
block|}
end_function
begin_function
DECL|function|mimeForFormat
name|QString
name|QLastResortMimes
operator|::
name|mimeForFormat
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|)
specifier|const
block|{
name|QString
name|format
init|=
name|formats
operator|.
name|value
argument_list|(
name|getCf
argument_list|(
name|formatetc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|format
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|format
return|;
name|wchar_t
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|int
name|len
init|=
name|GetClipboardFormatName
argument_list|(
name|getCf
argument_list|(
name|formatetc
argument_list|)
argument_list|,
name|buffer
argument_list|,
literal|256
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|QString
name|clipFormat
init|=
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DRAGANDDROP
if|if
condition|(
name|QInternalMimeData
operator|::
name|canReadData
argument_list|(
name|clipFormat
argument_list|)
condition|)
name|format
operator|=
name|clipFormat
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|formatetc
operator|.
name|cfFormat
operator|>=
literal|0xC000
operator|)
condition|)
block|{
comment|//create the mime as custom. not registered.
if|if
condition|(
operator|!
name|excludeList
operator|.
name|contains
argument_list|(
name|clipFormat
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
block|{
comment|//check if this is a mime type
name|bool
name|ianaType
init|=
literal|false
decl_stmt|;
name|int
name|sz
init|=
name|ianaTypes
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|clipFormat
operator|.
name|startsWith
argument_list|(
name|ianaTypes
index|[
name|i
index|]
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
block|{
name|ianaType
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ianaType
condition|)
name|format
operator|=
name|QLatin1String
argument_list|(
name|x_qt_windows_mime
argument_list|)
operator|+
name|clipFormat
operator|+
name|QLatin1Char
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
else|else
name|format
operator|=
name|clipFormat
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|//QT_NO_DRAGANDDROP
block|}
return|return
name|format
return|;
block|}
end_function
begin_comment
comment|/*!     \class QWindowsMimeConverter     \brief Manages the list of QWindowsMime instances.     \internal     \ingroup qt-lighthouse-win     \sa QWindowsMime */
end_comment
begin_constructor
DECL|function|QWindowsMimeConverter
name|QWindowsMimeConverter
operator|::
name|QWindowsMimeConverter
parameter_list|()
block|{ }
end_constructor
begin_destructor
DECL|function|~QWindowsMimeConverter
name|QWindowsMimeConverter
operator|::
name|~
name|QWindowsMimeConverter
parameter_list|()
block|{
name|qDeleteAll
argument_list|(
name|m_mimes
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|converterToMime
name|QWindowsMime
modifier|*
name|QWindowsMimeConverter
operator|::
name|converterToMime
parameter_list|(
specifier|const
name|QString
modifier|&
name|mimeType
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|m_mimes
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|m_mimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|canConvertToMime
argument_list|(
name|mimeType
argument_list|,
name|pDataObj
argument_list|)
condition|)
return|return
name|m_mimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|allMimesForFormats
name|QStringList
name|QWindowsMimeConverter
operator|::
name|allMimesForFormats
parameter_list|(
name|IDataObject
modifier|*
name|pDataObj
parameter_list|)
specifier|const
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
name|QStringList
name|formats
decl_stmt|;
name|LPENUMFORMATETC
name|FAR
name|fmtenum
decl_stmt|;
name|HRESULT
name|hr
init|=
name|pDataObj
operator|->
name|EnumFormatEtc
argument_list|(
name|DATADIR_GET
argument_list|,
operator|&
name|fmtenum
argument_list|)
decl_stmt|;
if|if
condition|(
name|hr
operator|==
name|NOERROR
condition|)
block|{
name|FORMATETC
name|fmtetc
decl_stmt|;
while|while
condition|(
name|S_OK
operator|==
name|fmtenum
operator|->
name|Next
argument_list|(
literal|1
argument_list|,
operator|&
name|fmtetc
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QMIME_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QWindowsMime::allMimesForFormats()"
argument_list|)
expr_stmt|;
name|wchar_t
name|buf
index|[
literal|256
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|GetClipboardFormatName
argument_list|(
name|fmtetc
operator|.
name|cfFormat
argument_list|,
name|buf
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"CF = %d : %s"
argument_list|,
name|fmtetc
operator|.
name|cfFormat
argument_list|,
name|QString
operator|::
name|fromWCharArray
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|int
name|i
init|=
name|m_mimes
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|QString
name|format
init|=
name|m_mimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|mimeForFormat
argument_list|(
name|fmtetc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|format
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|formats
operator|.
name|contains
argument_list|(
name|format
argument_list|)
condition|)
block|{
name|formats
operator|+=
name|format
expr_stmt|;
block|}
block|}
comment|// as documented in MSDN to avoid possible memleak
if|if
condition|(
name|fmtetc
operator|.
name|ptd
condition|)
name|CoTaskMemFree
argument_list|(
name|fmtetc
operator|.
name|ptd
argument_list|)
expr_stmt|;
block|}
name|fmtenum
operator|->
name|Release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|QWindowsContext
operator|::
name|verboseOLE
condition|)
name|qDebug
argument_list|()
operator|<<
name|__FUNCTION__
operator|<<
name|pDataObj
operator|<<
name|formats
expr_stmt|;
return|return
name|formats
return|;
block|}
end_function
begin_function
DECL|function|converterFromMime
name|QWindowsMime
modifier|*
name|QWindowsMimeConverter
operator|::
name|converterFromMime
parameter_list|(
specifier|const
name|FORMATETC
modifier|&
name|formatetc
parameter_list|,
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|m_mimes
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|m_mimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|canConvertFromMime
argument_list|(
name|formatetc
argument_list|,
name|mimeData
argument_list|)
condition|)
return|return
name|m_mimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|allFormatsForMime
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|QWindowsMimeConverter
operator|::
name|allFormatsForMime
parameter_list|(
specifier|const
name|QMimeData
modifier|*
name|mimeData
parameter_list|)
specifier|const
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
name|QVector
argument_list|<
name|FORMATETC
argument_list|>
name|formatics
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_NO_DRAGANDDROP
name|Q_UNUSED
argument_list|(
name|mimeData
argument_list|)
expr_stmt|;
else|#
directive|else
name|formatics
operator|.
name|reserve
argument_list|(
literal|20
argument_list|)
expr_stmt|;
specifier|const
name|QStringList
name|formats
init|=
name|QInternalMimeData
operator|::
name|formatsHelper
argument_list|(
name|mimeData
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
name|formats
operator|.
name|size
argument_list|()
condition|;
operator|++
name|f
control|)
block|{
for|for
control|(
name|int
name|i
init|=
name|m_mimes
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|formatics
operator|+=
name|m_mimes
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|formatsForMime
argument_list|(
name|formats
operator|.
name|at
argument_list|(
name|f
argument_list|)
argument_list|,
name|mimeData
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//QT_NO_DRAGANDDROP
return|return
name|formatics
return|;
block|}
end_function
begin_function
DECL|function|ensureInitialized
name|void
name|QWindowsMimeConverter
operator|::
name|ensureInitialized
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|m_mimes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|m_mimes
operator|<<
operator|new
name|QWindowsMimeImage
operator|<<
operator|new
name|QLastResortMimes
operator|<<
operator|new
name|QWindowsMimeText
operator|<<
operator|new
name|QWindowsMimeURI
operator|<<
operator|new
name|QWindowsMimeHtml
operator|<<
operator|new
name|QBuiltInMimes
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|convertToMime
name|QVariant
name|QWindowsMimeConverter
operator|::
name|convertToMime
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|mimeTypes
parameter_list|,
name|IDataObject
modifier|*
name|pDataObj
parameter_list|,
name|QVariant
operator|::
name|Type
name|preferredType
parameter_list|,
name|QString
modifier|*
name|formatIn
comment|/* = 0 */
parameter_list|)
specifier|const
block|{
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|format
decl|,
name|mimeTypes
control|)
block|{
if|if
condition|(
specifier|const
name|QWindowsMime
modifier|*
name|converter
init|=
name|converterToMime
argument_list|(
name|format
argument_list|,
name|pDataObj
argument_list|)
condition|)
block|{
if|if
condition|(
name|converter
operator|->
name|canConvertToMime
argument_list|(
name|format
argument_list|,
name|pDataObj
argument_list|)
condition|)
block|{
specifier|const
name|QVariant
name|dataV
init|=
name|converter
operator|->
name|convertToMime
argument_list|(
name|format
argument_list|,
name|pDataObj
argument_list|,
name|preferredType
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataV
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|QWindowsContext
operator|::
name|verboseOLE
condition|)
name|qDebug
argument_list|()
operator|<<
name|__FUNCTION__
operator|<<
name|mimeTypes
operator|<<
literal|"\nFormat: "
operator|<<
name|format
operator|<<
name|pDataObj
operator|<<
literal|" returns "
operator|<<
name|dataV
expr_stmt|;
if|if
condition|(
name|formatIn
condition|)
operator|*
name|formatIn
operator|=
name|format
expr_stmt|;
return|return
name|dataV
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|QWindowsContext
operator|::
name|verboseOLE
condition|)
name|qDebug
argument_list|()
operator|<<
name|__FUNCTION__
operator|<<
literal|"fails"
operator|<<
name|mimeTypes
operator|<<
name|pDataObj
operator|<<
name|preferredType
expr_stmt|;
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
