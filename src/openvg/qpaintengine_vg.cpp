begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtOpenVG module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qpaintengine_vg_p.h"
end_include
begin_include
include|#
directive|include
file|"qpixmapdata_vg_p.h"
end_include
begin_include
include|#
directive|include
file|"qpixmapfilter_vg_p.h"
end_include
begin_include
include|#
directive|include
file|"qvgcompositionhelper_p.h"
end_include
begin_include
include|#
directive|include
file|"qvgimagepool_p.h"
end_include
begin_include
include|#
directive|include
file|"qvgfontglyphcache_p.h"
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_EGL
argument_list|)
end_if
begin_include
include|#
directive|include
file|<QtGui/private/qeglcontext_p.h>
end_include
begin_include
include|#
directive|include
file|"qwindowsurface_vgegl_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QtCore/qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qdrawhelper_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qtextengine_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qfontengine_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qpainterpath_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/private/qstatictext_p.h>
end_include
begin_include
include|#
directive|include
file|<QtGui/QApplication>
end_include
begin_include
include|#
directive|include
file|<QtGui/QDesktopWidget>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmath.h>
end_include
begin_include
include|#
directive|include
file|<QDebug>
end_include
begin_include
include|#
directive|include
file|<QSet>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
comment|// vgRenderToMask() only exists in OpenVG 1.1 and higher.
comment|// Also, disable masking completely if we are using the scissor to clip.
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENVG_VERSION_1_1
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QVG_NO_RENDER_TO_MASK
argument_list|)
DECL|macro|QVG_NO_RENDER_TO_MASK
define|#
directive|define
name|QVG_NO_RENDER_TO_MASK
value|1
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|QVG_SCISSOR_CLIP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QVG_NO_RENDER_TO_MASK
argument_list|)
DECL|macro|QVG_NO_RENDER_TO_MASK
define|#
directive|define
name|QVG_NO_RENDER_TO_MASK
value|1
endif|#
directive|endif
comment|// use the same rounding as in qrasterizer.cpp (6 bit fixed point)
DECL|variable|aliasedCoordinateDelta
specifier|static
specifier|const
name|qreal
name|aliasedCoordinateDelta
init|=
literal|0.5
operator|-
literal|0.015625
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_DRAW_GLYPHS
argument_list|)
end_if
begin_class_decl
class_decl|class
name|QVGPaintEnginePrivate
class_decl|;
end_class_decl
begin_typedef
DECL|typedef|QVGFontCache
typedef|typedef
name|QHash
argument_list|<
name|QFontEngine
modifier|*
argument_list|,
name|QVGFontGlyphCache
modifier|*
argument_list|>
name|QVGFontCache
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|QVGFontEngineCleaner
class|class
name|QVGFontEngineCleaner
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
name|QVGFontEngineCleaner
parameter_list|(
name|QVGPaintEnginePrivate
modifier|*
name|d
parameter_list|)
constructor_decl|;
name|~
name|QVGFontEngineCleaner
parameter_list|()
destructor_decl|;
public|public
name|slots
public|:
name|void
name|fontEngineDestroyed
parameter_list|()
function_decl|;
private|private:
DECL|member|d_ptr
name|QVGPaintEnginePrivate
modifier|*
name|d_ptr
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QVGPaintEnginePrivate
class|class
name|QVGPaintEnginePrivate
super|:
specifier|public
name|QPaintEngineExPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QVGPaintEngine
parameter_list|)
specifier|public
private|:
comment|// Extra blending modes from VG_KHR_advanced_blending extension.
comment|// Use the QT_VG prefix to avoid conflicts with any definitions
comment|// that may come in via<VG/vgext.h>.
DECL|enum|AdvancedBlending
enum|enum
name|AdvancedBlending
block|{
DECL|enumerator|QT_VG_BLEND_OVERLAY_KHR
name|QT_VG_BLEND_OVERLAY_KHR
init|=
literal|0x2010
block|,
DECL|enumerator|QT_VG_BLEND_HARDLIGHT_KHR
name|QT_VG_BLEND_HARDLIGHT_KHR
init|=
literal|0x2011
block|,
DECL|enumerator|QT_VG_BLEND_SOFTLIGHT_SVG_KHR
name|QT_VG_BLEND_SOFTLIGHT_SVG_KHR
init|=
literal|0x2012
block|,
DECL|enumerator|QT_VG_BLEND_SOFTLIGHT_KHR
name|QT_VG_BLEND_SOFTLIGHT_KHR
init|=
literal|0x2013
block|,
DECL|enumerator|QT_VG_BLEND_COLORDODGE_KHR
name|QT_VG_BLEND_COLORDODGE_KHR
init|=
literal|0x2014
block|,
DECL|enumerator|QT_VG_BLEND_COLORBURN_KHR
name|QT_VG_BLEND_COLORBURN_KHR
init|=
literal|0x2015
block|,
DECL|enumerator|QT_VG_BLEND_DIFFERENCE_KHR
name|QT_VG_BLEND_DIFFERENCE_KHR
init|=
literal|0x2016
block|,
DECL|enumerator|QT_VG_BLEND_SUBTRACT_KHR
name|QT_VG_BLEND_SUBTRACT_KHR
init|=
literal|0x2017
block|,
DECL|enumerator|QT_VG_BLEND_INVERT_KHR
name|QT_VG_BLEND_INVERT_KHR
init|=
literal|0x2018
block|,
DECL|enumerator|QT_VG_BLEND_EXCLUSION_KHR
name|QT_VG_BLEND_EXCLUSION_KHR
init|=
literal|0x2019
block|,
DECL|enumerator|QT_VG_BLEND_LINEARDODGE_KHR
name|QT_VG_BLEND_LINEARDODGE_KHR
init|=
literal|0x201a
block|,
DECL|enumerator|QT_VG_BLEND_LINEARBURN_KHR
name|QT_VG_BLEND_LINEARBURN_KHR
init|=
literal|0x201b
block|,
DECL|enumerator|QT_VG_BLEND_VIVIDLIGHT_KHR
name|QT_VG_BLEND_VIVIDLIGHT_KHR
init|=
literal|0x201c
block|,
DECL|enumerator|QT_VG_BLEND_LINEARLIGHT_KHR
name|QT_VG_BLEND_LINEARLIGHT_KHR
init|=
literal|0x201d
block|,
DECL|enumerator|QT_VG_BLEND_PINLIGHT_KHR
name|QT_VG_BLEND_PINLIGHT_KHR
init|=
literal|0x201e
block|,
DECL|enumerator|QT_VG_BLEND_HARDMIX_KHR
name|QT_VG_BLEND_HARDMIX_KHR
init|=
literal|0x201f
block|,
DECL|enumerator|QT_VG_BLEND_CLEAR_KHR
name|QT_VG_BLEND_CLEAR_KHR
init|=
literal|0x2020
block|,
DECL|enumerator|QT_VG_BLEND_DST_KHR
name|QT_VG_BLEND_DST_KHR
init|=
literal|0x2021
block|,
DECL|enumerator|QT_VG_BLEND_SRC_OUT_KHR
name|QT_VG_BLEND_SRC_OUT_KHR
init|=
literal|0x2022
block|,
DECL|enumerator|QT_VG_BLEND_DST_OUT_KHR
name|QT_VG_BLEND_DST_OUT_KHR
init|=
literal|0x2023
block|,
DECL|enumerator|QT_VG_BLEND_SRC_ATOP_KHR
name|QT_VG_BLEND_SRC_ATOP_KHR
init|=
literal|0x2024
block|,
DECL|enumerator|QT_VG_BLEND_DST_ATOP_KHR
name|QT_VG_BLEND_DST_ATOP_KHR
init|=
literal|0x2025
block|,
DECL|enumerator|QT_VG_BLEND_XOR_KHR
name|QT_VG_BLEND_XOR_KHR
init|=
literal|0x2026
block|}
enum|;
name|QVGPaintEnginePrivate
parameter_list|(
name|QVGPaintEngine
modifier|*
name|q_ptr
parameter_list|)
constructor_decl|;
name|~
name|QVGPaintEnginePrivate
parameter_list|()
destructor_decl|;
name|void
name|init
parameter_list|()
function_decl|;
name|void
name|initObjects
parameter_list|()
function_decl|;
name|void
name|destroy
parameter_list|()
function_decl|;
name|void
name|setTransform
parameter_list|(
name|VGMatrixMode
name|mode
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|)
function_decl|;
name|void
name|updateTransform
parameter_list|(
name|QPaintDevice
modifier|*
name|pdev
parameter_list|)
function_decl|;
name|void
name|draw
parameter_list|(
name|VGPath
name|path
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|,
name|VGint
name|rule
init|=
name|VG_EVEN_ODD
parameter_list|)
function_decl|;
name|void
name|stroke
parameter_list|(
name|VGPath
name|path
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
function_decl|;
name|void
name|fill
parameter_list|(
name|VGPath
name|path
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|,
name|VGint
name|rule
init|=
name|VG_EVEN_ODD
parameter_list|)
function_decl|;
name|VGPath
name|vectorPathToVGPath
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|)
function_decl|;
name|VGPath
name|painterPathToVGPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
function_decl|;
name|VGPath
name|roundedRectPath
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|qreal
name|xRadius
parameter_list|,
name|qreal
name|yRadius
parameter_list|,
name|Qt
operator|::
name|SizeMode
name|mode
parameter_list|)
function_decl|;
name|VGPaintType
name|setBrush
parameter_list|(
name|VGPaint
name|paint
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|,
name|VGMatrixMode
name|mode
parameter_list|,
name|VGPaintType
name|prevPaintType
parameter_list|)
function_decl|;
name|void
name|setPenParams
parameter_list|(
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
function_decl|;
name|void
name|setBrushTransform
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|,
name|VGMatrixMode
name|mode
parameter_list|)
function_decl|;
name|void
name|setupColorRamp
parameter_list|(
specifier|const
name|QGradient
modifier|*
name|grad
parameter_list|,
name|VGPaint
name|paint
parameter_list|)
function_decl|;
name|void
name|setImageOptions
parameter_list|()
function_decl|;
name|void
name|systemStateChanged
parameter_list|()
function_decl|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_SCISSOR_CLIP
argument_list|)
name|void
name|ensureMask
parameter_list|(
name|QVGPaintEngine
modifier|*
name|engine
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
function_decl|;
name|void
name|modifyMask
parameter_list|(
name|QVGPaintEngine
modifier|*
name|engine
parameter_list|,
name|VGMaskOperation
name|op
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
function_decl|;
name|void
name|modifyMask
parameter_list|(
name|QVGPaintEngine
modifier|*
name|engine
parameter_list|,
name|VGMaskOperation
name|op
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
function_decl|;
endif|#
directive|endif
DECL|member|maxScissorRects
name|VGint
name|maxScissorRects
decl_stmt|;
comment|// Maximum scissor rectangles for clipping.
DECL|member|penPaint
name|VGPaint
name|penPaint
decl_stmt|;
comment|// Paint for currently active pen.
DECL|member|brushPaint
name|VGPaint
name|brushPaint
decl_stmt|;
comment|// Paint for currently active brush.
DECL|member|opacityPaint
name|VGPaint
name|opacityPaint
decl_stmt|;
comment|// Paint for drawing images with opacity.
DECL|member|fillPaint
name|VGPaint
name|fillPaint
decl_stmt|;
comment|// Current fill paint that is active.
DECL|member|currentPen
name|QPen
name|currentPen
decl_stmt|;
comment|// Current pen set in "penPaint".
DECL|member|currentBrush
name|QBrush
name|currentBrush
decl_stmt|;
comment|// Current brush set in "brushPaint".
DECL|member|forcePenChange
name|bool
name|forcePenChange
decl_stmt|;
comment|// Force a pen change, even if the same.
DECL|member|forceBrushChange
name|bool
name|forceBrushChange
decl_stmt|;
comment|// Force a brush change, even if the same.
DECL|member|hasExtendedRadialGradientPen
name|bool
name|hasExtendedRadialGradientPen
decl_stmt|;
comment|// Current pen's brush is extended radial gradient.
DECL|member|hasExtendedRadialGradientBrush
name|bool
name|hasExtendedRadialGradientBrush
decl_stmt|;
comment|// Current brush is extended radial gradient.
DECL|member|penType
name|VGPaintType
name|penType
decl_stmt|;
comment|// Type of the last pen that was set.
DECL|member|brushType
name|VGPaintType
name|brushType
decl_stmt|;
comment|// Type of the last brush that was set.
DECL|member|brushOrigin
name|QPointF
name|brushOrigin
decl_stmt|;
comment|// Current brush origin.
DECL|member|fillRule
name|VGint
name|fillRule
decl_stmt|;
comment|// Last fill rule that was set.
DECL|member|opacity
name|qreal
name|opacity
decl_stmt|;
comment|// Current drawing opacity.
DECL|member|paintOpacity
name|qreal
name|paintOpacity
decl_stmt|;
comment|// Opacity in opacityPaint.
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
DECL|member|rectPath
name|VGPath
name|rectPath
decl_stmt|;
comment|// Cached path for quick drawing of rectangles.
DECL|member|linePath
name|VGPath
name|linePath
decl_stmt|;
comment|// Cached path for quick drawing of lines.
DECL|member|roundRectPath
name|VGPath
name|roundRectPath
decl_stmt|;
comment|// Cached path for quick drawing of rounded rects.
endif|#
directive|endif
DECL|member|transform
name|QTransform
name|transform
decl_stmt|;
comment|// Currently active transform.
DECL|member|simpleTransform
name|bool
name|simpleTransform
decl_stmt|;
comment|// True if the transform is simple (non-projective).
DECL|member|penScale
name|qreal
name|penScale
decl_stmt|;
comment|// Pen scaling factor from "transform".
DECL|member|pathTransform
name|QTransform
name|pathTransform
decl_stmt|;
comment|// Calculated VG path transformation.
DECL|member|imageTransform
name|QTransform
name|imageTransform
decl_stmt|;
comment|// Calculated VG image transformation.
DECL|member|pathTransformSet
name|bool
name|pathTransformSet
decl_stmt|;
comment|// True if path transform set in the VG context.
DECL|member|maskValid
name|bool
name|maskValid
decl_stmt|;
comment|// True if vgMask() contains valid data.
DECL|member|maskIsSet
name|bool
name|maskIsSet
decl_stmt|;
comment|// True if mask would be fully set if it was valid.
DECL|member|scissorMask
name|bool
name|scissorMask
decl_stmt|;
comment|// True if scissor is used in place of the mask.
DECL|member|rawVG
name|bool
name|rawVG
decl_stmt|;
comment|// True if processing a raw VG escape.
DECL|member|maskRect
name|QRect
name|maskRect
decl_stmt|;
comment|// Rectangle version of mask if it is simple.
DECL|member|penTransform
name|QTransform
name|penTransform
decl_stmt|;
comment|// Transform for the pen.
DECL|member|brushTransform
name|QTransform
name|brushTransform
decl_stmt|;
comment|// Transform for the brush.
DECL|member|matrixMode
name|VGMatrixMode
name|matrixMode
decl_stmt|;
comment|// Last matrix mode that was set.
DECL|member|imageMode
name|VGImageMode
name|imageMode
decl_stmt|;
comment|// Last image mode that was set.
DECL|member|scissorRegion
name|QRegion
name|scissorRegion
decl_stmt|;
comment|// Currently active scissor region.
DECL|member|scissorActive
name|bool
name|scissorActive
decl_stmt|;
comment|// True if scissor region is active.
DECL|member|scissorDirty
name|bool
name|scissorDirty
decl_stmt|;
comment|// True if scissor is dirty after native painting.
DECL|member|dirty
name|QPaintEngine
operator|::
name|DirtyFlags
name|dirty
decl_stmt|;
DECL|member|clearColor
name|QColor
name|clearColor
decl_stmt|;
comment|// Last clear color that was set.
DECL|member|clearOpacity
name|VGfloat
name|clearOpacity
decl_stmt|;
comment|// Opacity during the last clear.
DECL|member|blendMode
name|VGBlendMode
name|blendMode
decl_stmt|;
comment|// Active blend mode.
DECL|member|renderingQuality
name|VGRenderingQuality
name|renderingQuality
decl_stmt|;
comment|// Active rendering quality.
DECL|member|imageQuality
name|VGImageQuality
name|imageQuality
decl_stmt|;
comment|// Active image quality.
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_DRAW_GLYPHS
argument_list|)
DECL|member|fontCache
name|QVGFontCache
name|fontCache
decl_stmt|;
DECL|member|fontEngineCleaner
name|QVGFontEngineCleaner
modifier|*
name|fontEngineCleaner
decl_stmt|;
endif|#
directive|endif
DECL|member|hasAdvancedBlending
name|bool
name|hasAdvancedBlending
decl_stmt|;
DECL|member|convolutionFilter
name|QScopedPointer
argument_list|<
name|QPixmapFilter
argument_list|>
name|convolutionFilter
decl_stmt|;
DECL|member|colorizeFilter
name|QScopedPointer
argument_list|<
name|QPixmapFilter
argument_list|>
name|colorizeFilter
decl_stmt|;
DECL|member|dropShadowFilter
name|QScopedPointer
argument_list|<
name|QPixmapFilter
argument_list|>
name|dropShadowFilter
decl_stmt|;
DECL|member|blurFilter
name|QScopedPointer
argument_list|<
name|QPixmapFilter
argument_list|>
name|blurFilter
decl_stmt|;
comment|// Ensure that the path transform is properly set in the VG context
comment|// before we perform a vgDrawPath() operation.
DECL|function|ensurePathTransform
specifier|inline
name|void
name|ensurePathTransform
parameter_list|()
block|{
if|if
condition|(
operator|!
name|pathTransformSet
condition|)
block|{
name|QTransform
name|aliasedTransform
init|=
name|pathTransform
decl_stmt|;
if|if
condition|(
name|renderingQuality
operator|==
name|VG_RENDERING_QUALITY_NONANTIALIASED
operator|&&
name|currentPen
operator|!=
name|Qt
operator|::
name|NoPen
condition|)
name|aliasedTransform
operator|=
name|aliasedTransform
operator|*
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|aliasedCoordinateDelta
argument_list|,
operator|-
name|aliasedCoordinateDelta
argument_list|)
expr_stmt|;
name|setTransform
argument_list|(
name|VG_MATRIX_PATH_USER_TO_SURFACE
argument_list|,
name|aliasedTransform
argument_list|)
expr_stmt|;
name|pathTransformSet
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Ensure that a specific pen has been set into penPaint.
DECL|function|ensurePen
specifier|inline
name|void
name|ensurePen
parameter_list|(
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
if|if
condition|(
name|forcePenChange
operator|||
name|pen
operator|!=
name|currentPen
condition|)
block|{
name|currentPen
operator|=
name|pen
expr_stmt|;
name|forcePenChange
operator|=
literal|false
expr_stmt|;
name|penType
operator|=
name|setBrush
argument_list|(
name|penPaint
argument_list|,
name|pen
operator|.
name|brush
argument_list|()
argument_list|,
name|VG_MATRIX_STROKE_PAINT_TO_USER
argument_list|,
name|penType
argument_list|)
expr_stmt|;
name|setPenParams
argument_list|(
name|pen
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Ensure that a specific brush has been set into brushPaint.
DECL|function|ensureBrush
specifier|inline
name|void
name|ensureBrush
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
if|if
condition|(
name|forceBrushChange
operator|||
name|brush
operator|!=
name|currentBrush
condition|)
block|{
name|currentBrush
operator|=
name|brush
expr_stmt|;
name|forceBrushChange
operator|=
literal|false
expr_stmt|;
name|brushType
operator|=
name|setBrush
argument_list|(
name|brushPaint
argument_list|,
name|brush
argument_list|,
name|VG_MATRIX_FILL_PAINT_TO_USER
argument_list|,
name|brushType
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fillPaint
operator|!=
name|brushPaint
condition|)
block|{
name|vgSetPaint
argument_list|(
name|brushPaint
argument_list|,
name|VG_FILL_PATH
argument_list|)
expr_stmt|;
name|fillPaint
operator|=
name|brushPaint
expr_stmt|;
block|}
block|}
DECL|function|needsEmulation
specifier|inline
name|bool
name|needsEmulation
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
specifier|const
block|{
specifier|extern
name|bool
name|qt_isExtendedRadialGradient
argument_list|(
specifier|const
name|QBrush
operator|&
name|brush
argument_list|)
decl_stmt|;
return|return
name|qt_isExtendedRadialGradient
argument_list|(
name|brush
argument_list|)
return|;
block|}
DECL|function|needsEmulation
specifier|inline
name|bool
name|needsEmulation
parameter_list|()
specifier|const
block|{
return|return
name|hasExtendedRadialGradientPen
operator|||
name|hasExtendedRadialGradientBrush
return|;
block|}
DECL|function|needsPenEmulation
specifier|inline
name|bool
name|needsPenEmulation
parameter_list|()
specifier|const
block|{
return|return
name|hasExtendedRadialGradientPen
return|;
block|}
DECL|function|needsBrushEmulation
specifier|inline
name|bool
name|needsBrushEmulation
parameter_list|()
specifier|const
block|{
return|return
name|hasExtendedRadialGradientBrush
return|;
block|}
comment|// Set various modes, but only if different.
specifier|inline
name|void
name|setImageMode
parameter_list|(
name|VGImageMode
name|mode
parameter_list|)
function_decl|;
specifier|inline
name|void
name|setRenderingQuality
parameter_list|(
name|VGRenderingQuality
name|mode
parameter_list|)
function_decl|;
specifier|inline
name|void
name|setImageQuality
parameter_list|(
name|VGImageQuality
name|mode
parameter_list|)
function_decl|;
specifier|inline
name|void
name|setBlendMode
parameter_list|(
name|VGBlendMode
name|mode
parameter_list|)
function_decl|;
specifier|inline
name|void
name|setFillRule
parameter_list|(
name|VGint
name|mode
parameter_list|)
function_decl|;
comment|// Clear all lazily-set modes.
name|void
name|clearModes
parameter_list|()
function_decl|;
private|private:
DECL|member|q
name|QVGPaintEngine
modifier|*
name|q
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|setImageMode
specifier|inline
name|void
name|QVGPaintEnginePrivate
operator|::
name|setImageMode
parameter_list|(
name|VGImageMode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|imageMode
operator|!=
name|mode
condition|)
block|{
name|imageMode
operator|=
name|mode
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_IMAGE_MODE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setRenderingQuality
specifier|inline
name|void
name|QVGPaintEnginePrivate
operator|::
name|setRenderingQuality
parameter_list|(
name|VGRenderingQuality
name|mode
parameter_list|)
block|{
if|if
condition|(
name|renderingQuality
operator|!=
name|mode
condition|)
block|{
name|vgSeti
argument_list|(
name|VG_RENDERING_QUALITY
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|renderingQuality
operator|=
name|mode
expr_stmt|;
name|pathTransformSet
operator|=
literal|false
expr_stmt|;
comment|// need to tweak transform for aliased stroking
block|}
block|}
end_function
begin_function
DECL|function|setImageQuality
specifier|inline
name|void
name|QVGPaintEnginePrivate
operator|::
name|setImageQuality
parameter_list|(
name|VGImageQuality
name|mode
parameter_list|)
block|{
if|if
condition|(
name|imageQuality
operator|!=
name|mode
condition|)
block|{
name|vgSeti
argument_list|(
name|VG_IMAGE_QUALITY
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|imageQuality
operator|=
name|mode
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setBlendMode
specifier|inline
name|void
name|QVGPaintEnginePrivate
operator|::
name|setBlendMode
parameter_list|(
name|VGBlendMode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|blendMode
operator|!=
name|mode
condition|)
block|{
name|vgSeti
argument_list|(
name|VG_BLEND_MODE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|blendMode
operator|=
name|mode
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setFillRule
specifier|inline
name|void
name|QVGPaintEnginePrivate
operator|::
name|setFillRule
parameter_list|(
name|VGint
name|mode
parameter_list|)
block|{
if|if
condition|(
name|fillRule
operator|!=
name|mode
condition|)
block|{
name|fillRule
operator|=
name|mode
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_FILL_RULE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|clearModes
name|void
name|QVGPaintEnginePrivate
operator|::
name|clearModes
parameter_list|()
block|{
name|matrixMode
operator|=
operator|(
name|VGMatrixMode
operator|)
literal|0
expr_stmt|;
name|imageMode
operator|=
operator|(
name|VGImageMode
operator|)
literal|0
expr_stmt|;
name|blendMode
operator|=
operator|(
name|VGBlendMode
operator|)
literal|0
expr_stmt|;
name|renderingQuality
operator|=
operator|(
name|VGRenderingQuality
operator|)
literal|0
expr_stmt|;
name|imageQuality
operator|=
operator|(
name|VGImageQuality
operator|)
literal|0
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QVGPaintEnginePrivate
name|QVGPaintEnginePrivate
operator|::
name|QVGPaintEnginePrivate
parameter_list|(
name|QVGPaintEngine
modifier|*
name|q_ptr
parameter_list|)
member_init_list|:
name|q
argument_list|(
name|q_ptr
argument_list|)
block|{
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|init
name|void
name|QVGPaintEnginePrivate
operator|::
name|init
parameter_list|()
block|{
name|maxScissorRects
operator|=
literal|0
expr_stmt|;
name|penPaint
operator|=
literal|0
expr_stmt|;
name|brushPaint
operator|=
literal|0
expr_stmt|;
name|opacityPaint
operator|=
literal|0
expr_stmt|;
name|fillPaint
operator|=
literal|0
expr_stmt|;
name|forcePenChange
operator|=
literal|true
expr_stmt|;
name|forceBrushChange
operator|=
literal|true
expr_stmt|;
name|hasExtendedRadialGradientPen
operator|=
literal|false
expr_stmt|;
name|hasExtendedRadialGradientBrush
operator|=
literal|false
expr_stmt|;
name|penType
operator|=
operator|(
name|VGPaintType
operator|)
literal|0
expr_stmt|;
name|brushType
operator|=
operator|(
name|VGPaintType
operator|)
literal|0
expr_stmt|;
name|brushOrigin
operator|=
name|QPointF
argument_list|(
literal|0.0f
argument_list|,
literal|0.0f
argument_list|)
expr_stmt|;
name|fillRule
operator|=
literal|0
expr_stmt|;
name|opacity
operator|=
literal|1.0
expr_stmt|;
name|paintOpacity
operator|=
literal|1.0f
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
name|rectPath
operator|=
literal|0
expr_stmt|;
name|linePath
operator|=
literal|0
expr_stmt|;
name|roundRectPath
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|simpleTransform
operator|=
literal|true
expr_stmt|;
name|pathTransformSet
operator|=
literal|false
expr_stmt|;
name|penScale
operator|=
literal|1.0
expr_stmt|;
name|maskValid
operator|=
literal|false
expr_stmt|;
name|maskIsSet
operator|=
literal|false
expr_stmt|;
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|rawVG
operator|=
literal|false
expr_stmt|;
name|scissorActive
operator|=
literal|false
expr_stmt|;
name|scissorDirty
operator|=
literal|false
expr_stmt|;
name|dirty
operator|=
literal|0
expr_stmt|;
name|clearOpacity
operator|=
literal|1.0f
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_DRAW_GLYPHS
argument_list|)
name|fontEngineCleaner
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|hasAdvancedBlending
operator|=
literal|false
expr_stmt|;
name|clearModes
argument_list|()
expr_stmt|;
block|}
end_function
begin_destructor
DECL|function|~QVGPaintEnginePrivate
name|QVGPaintEnginePrivate
operator|::
name|~
name|QVGPaintEnginePrivate
parameter_list|()
block|{
name|destroy
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|initObjects
name|void
name|QVGPaintEnginePrivate
operator|::
name|initObjects
parameter_list|()
block|{
name|maxScissorRects
operator|=
name|vgGeti
argument_list|(
name|VG_MAX_SCISSOR_RECTS
argument_list|)
expr_stmt|;
name|penPaint
operator|=
name|vgCreatePaint
argument_list|()
expr_stmt|;
name|vgSetParameteri
argument_list|(
name|penPaint
argument_list|,
name|VG_PAINT_TYPE
argument_list|,
name|VG_PAINT_TYPE_COLOR
argument_list|)
expr_stmt|;
name|vgSetPaint
argument_list|(
name|penPaint
argument_list|,
name|VG_STROKE_PATH
argument_list|)
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_MATRIX_MODE
argument_list|,
name|VG_MATRIX_STROKE_PAINT_TO_USER
argument_list|)
expr_stmt|;
name|vgLoadIdentity
argument_list|()
expr_stmt|;
name|brushPaint
operator|=
name|vgCreatePaint
argument_list|()
expr_stmt|;
name|vgSetParameteri
argument_list|(
name|brushPaint
argument_list|,
name|VG_PAINT_TYPE
argument_list|,
name|VG_PAINT_TYPE_COLOR
argument_list|)
expr_stmt|;
name|vgSetPaint
argument_list|(
name|brushPaint
argument_list|,
name|VG_FILL_PATH
argument_list|)
expr_stmt|;
name|fillPaint
operator|=
name|brushPaint
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_MATRIX_MODE
argument_list|,
name|VG_MATRIX_FILL_PAINT_TO_USER
argument_list|)
expr_stmt|;
name|vgLoadIdentity
argument_list|()
expr_stmt|;
name|matrixMode
operator|=
name|VG_MATRIX_FILL_PAINT_TO_USER
expr_stmt|;
name|opacityPaint
operator|=
name|vgCreatePaint
argument_list|()
expr_stmt|;
name|vgSetParameteri
argument_list|(
name|opacityPaint
argument_list|,
name|VG_PAINT_TYPE
argument_list|,
name|VG_PAINT_TYPE_COLOR
argument_list|)
expr_stmt|;
name|VGfloat
name|values
index|[
literal|4
index|]
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
literal|1.0f
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
literal|1.0f
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
literal|1.0f
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|paintOpacity
expr_stmt|;
name|vgSetParameterfv
argument_list|(
name|opacityPaint
argument_list|,
name|VG_PAINT_COLOR
argument_list|,
literal|4
argument_list|,
name|values
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
comment|// Create a dummy path for rectangle drawing, which we can
comment|// modify later with vgModifyPathCoords().  This should be
comment|// faster than constantly creating and destroying paths.
name|rectPath
operator|=
name|vgCreatePath
argument_list|(
name|VG_PATH_FORMAT_STANDARD
argument_list|,
name|VG_PATH_DATATYPE_F
argument_list|,
literal|1.0f
argument_list|,
comment|// scale
literal|0.0f
argument_list|,
comment|// bias
literal|5
argument_list|,
comment|// segmentCapacityHint
literal|8
argument_list|,
comment|// coordCapacityHint
name|VG_PATH_CAPABILITY_ALL
argument_list|)
expr_stmt|;
specifier|static
name|VGubyte
specifier|const
name|segments
index|[
literal|5
index|]
init|=
block|{
name|VG_MOVE_TO_ABS
block|,
name|VG_LINE_TO_ABS
block|,
name|VG_LINE_TO_ABS
block|,
name|VG_LINE_TO_ABS
block|,
name|VG_CLOSE_PATH
block|}
decl_stmt|;
name|VGfloat
name|coords
index|[
literal|8
index|]
decl_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
literal|0.0f
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
literal|0.0f
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
literal|100.0f
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|coords
index|[
literal|1
index|]
expr_stmt|;
name|coords
index|[
literal|4
index|]
operator|=
name|coords
index|[
literal|2
index|]
expr_stmt|;
name|coords
index|[
literal|5
index|]
operator|=
literal|100.0f
expr_stmt|;
name|coords
index|[
literal|6
index|]
operator|=
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|coords
index|[
literal|7
index|]
operator|=
name|coords
index|[
literal|5
index|]
expr_stmt|;
name|vgAppendPathData
argument_list|(
name|rectPath
argument_list|,
literal|5
argument_list|,
name|segments
argument_list|,
name|coords
argument_list|)
expr_stmt|;
comment|// Create a dummy line drawing path as well.
name|linePath
operator|=
name|vgCreatePath
argument_list|(
name|VG_PATH_FORMAT_STANDARD
argument_list|,
name|VG_PATH_DATATYPE_F
argument_list|,
literal|1.0f
argument_list|,
comment|// scale
literal|0.0f
argument_list|,
comment|// bias
literal|2
argument_list|,
comment|// segmentCapacityHint
literal|4
argument_list|,
comment|// coordCapacityHint
name|VG_PATH_CAPABILITY_ALL
argument_list|)
expr_stmt|;
name|vgAppendPathData
argument_list|(
name|linePath
argument_list|,
literal|2
argument_list|,
name|segments
argument_list|,
name|coords
argument_list|)
expr_stmt|;
endif|#
directive|endif
specifier|const
name|char
modifier|*
name|extensions
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|vgGetString
argument_list|(
name|VG_EXTENSIONS
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|extensions
condition|)
name|hasAdvancedBlending
operator|=
name|strstr
argument_list|(
name|extensions
argument_list|,
literal|"VG_KHR_advanced_blending"
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|destroy
name|void
name|QVGPaintEnginePrivate
operator|::
name|destroy
parameter_list|()
block|{
if|if
condition|(
name|penPaint
condition|)
name|vgDestroyPaint
argument_list|(
name|penPaint
argument_list|)
expr_stmt|;
if|if
condition|(
name|brushPaint
condition|)
name|vgDestroyPaint
argument_list|(
name|brushPaint
argument_list|)
expr_stmt|;
if|if
condition|(
name|opacityPaint
condition|)
name|vgDestroyPaint
argument_list|(
name|opacityPaint
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
if|if
condition|(
name|rectPath
condition|)
name|vgDestroyPath
argument_list|(
name|rectPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|linePath
condition|)
name|vgDestroyPath
argument_list|(
name|linePath
argument_list|)
expr_stmt|;
if|if
condition|(
name|roundRectPath
condition|)
name|vgDestroyPath
argument_list|(
name|roundRectPath
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_DRAW_GLYPHS
argument_list|)
name|QVGFontCache
operator|::
name|Iterator
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|fontCache
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|fontCache
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
operator|delete
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
name|fontCache
operator|.
name|clear
argument_list|()
expr_stmt|;
operator|delete
name|fontEngineCleaner
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|// Set a specific VG transformation matrix in the current VG context.
end_comment
begin_function
DECL|function|setTransform
name|void
name|QVGPaintEnginePrivate
operator|::
name|setTransform
parameter_list|(
name|VGMatrixMode
name|mode
parameter_list|,
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|)
block|{
name|VGfloat
name|mat
index|[
literal|9
index|]
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|matrixMode
condition|)
block|{
name|vgSeti
argument_list|(
name|VG_MATRIX_MODE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|matrixMode
operator|=
name|mode
expr_stmt|;
block|}
name|mat
index|[
literal|0
index|]
operator|=
name|transform
operator|.
name|m11
argument_list|()
expr_stmt|;
name|mat
index|[
literal|1
index|]
operator|=
name|transform
operator|.
name|m12
argument_list|()
expr_stmt|;
name|mat
index|[
literal|2
index|]
operator|=
name|transform
operator|.
name|m13
argument_list|()
expr_stmt|;
name|mat
index|[
literal|3
index|]
operator|=
name|transform
operator|.
name|m21
argument_list|()
expr_stmt|;
name|mat
index|[
literal|4
index|]
operator|=
name|transform
operator|.
name|m22
argument_list|()
expr_stmt|;
name|mat
index|[
literal|5
index|]
operator|=
name|transform
operator|.
name|m23
argument_list|()
expr_stmt|;
name|mat
index|[
literal|6
index|]
operator|=
name|transform
operator|.
name|m31
argument_list|()
expr_stmt|;
name|mat
index|[
literal|7
index|]
operator|=
name|transform
operator|.
name|m32
argument_list|()
expr_stmt|;
name|mat
index|[
literal|8
index|]
operator|=
name|transform
operator|.
name|m33
argument_list|()
expr_stmt|;
name|vgLoadMatrix
argument_list|(
name|mat
argument_list|)
expr_stmt|;
block|}
end_function
begin_function_decl
name|Q_GUI_EXPORT
name|bool
name|qt_scaleForTransform
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|,
name|qreal
modifier|*
name|scale
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|updateTransform
name|void
name|QVGPaintEnginePrivate
operator|::
name|updateTransform
parameter_list|(
name|QPaintDevice
modifier|*
name|pdev
parameter_list|)
block|{
name|VGfloat
name|devh
init|=
name|pdev
operator|->
name|height
argument_list|()
decl_stmt|;
comment|// Construct the VG transform by combining the Qt transform with
comment|// the following viewport transformation:
comment|//        | 1  0  0   |
comment|//        | 0 -1 devh |
comment|//        | 0  0  1   |
comment|// The full VG transform is effectively:
comment|//      1. Apply the user's transformation matrix.
comment|//      2. Flip the co-ordinate system upside down.
name|QTransform
name|viewport
argument_list|(
literal|1.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
operator|-
literal|1.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
name|devh
argument_list|,
literal|1.0f
argument_list|)
decl_stmt|;
comment|// Compute the path transform and determine if it is projective.
name|pathTransform
operator|=
name|transform
operator|*
name|viewport
expr_stmt|;
name|bool
name|projective
init|=
operator|(
name|pathTransform
operator|.
name|m13
argument_list|()
operator|!=
literal|0.0f
operator|||
name|pathTransform
operator|.
name|m23
argument_list|()
operator|!=
literal|0.0f
operator|||
name|pathTransform
operator|.
name|m33
argument_list|()
operator|!=
literal|1.0f
operator|)
decl_stmt|;
if|if
condition|(
name|projective
condition|)
block|{
comment|// The engine cannot do projective path transforms for us,
comment|// so we will have to convert the co-ordinates ourselves.
comment|// Change the matrix to just the viewport transformation.
name|pathTransform
operator|=
name|viewport
expr_stmt|;
name|simpleTransform
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|simpleTransform
operator|=
literal|true
expr_stmt|;
block|}
name|pathTransformSet
operator|=
literal|false
expr_stmt|;
comment|// The image transform is always the full transformation,
name|imageTransform
operator|=
name|transform
operator|*
name|viewport
expr_stmt|;
comment|// Calculate the scaling factor to use for turning cosmetic pens
comment|// into ordinary non-cosmetic pens.
name|qt_scaleForTransform
argument_list|(
name|transform
argument_list|,
operator|&
name|penScale
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|vectorPathToVGPath
name|VGPath
name|QVGPaintEnginePrivate
operator|::
name|vectorPathToVGPath
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|)
block|{
name|int
name|count
init|=
name|path
operator|.
name|elementCount
argument_list|()
decl_stmt|;
specifier|const
name|qreal
modifier|*
name|points
init|=
name|path
operator|.
name|points
argument_list|()
decl_stmt|;
specifier|const
name|QPainterPath
operator|::
name|ElementType
modifier|*
name|elements
init|=
name|path
operator|.
name|elements
argument_list|()
decl_stmt|;
name|VGPath
name|vgpath
init|=
name|vgCreatePath
argument_list|(
name|VG_PATH_FORMAT_STANDARD
argument_list|,
name|VG_PATH_DATATYPE_F
argument_list|,
literal|1.0f
argument_list|,
comment|// scale
literal|0.0f
argument_list|,
comment|// bias
name|count
operator|+
literal|1
argument_list|,
comment|// segmentCapacityHint
name|count
operator|*
literal|2
argument_list|,
comment|// coordCapacityHint
name|VG_PATH_CAPABILITY_ALL
argument_list|)
decl_stmt|;
comment|// Size is sufficient segments for drawRoundedRect() paths.
name|QVarLengthArray
argument_list|<
name|VGubyte
argument_list|,
literal|20
argument_list|>
name|segments
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|qreal
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|VGfloat
argument_list|)
operator|&&
name|elements
operator|&&
name|simpleTransform
condition|)
block|{
comment|// If Qt was compiled with qreal the same size as VGfloat,
comment|// then convert the segment types and use the incoming
comment|// points array directly.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|elements
index|[
name|i
index|]
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
name|segments
operator|.
name|append
argument_list|(
name|VG_MOVE_TO_ABS
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
name|segments
operator|.
name|append
argument_list|(
name|VG_LINE_TO_ABS
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
name|segments
operator|.
name|append
argument_list|(
name|VG_CUBIC_TO_ABS
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToDataElement
case|:
break|break;
block|}
block|}
if|if
condition|(
name|path
operator|.
name|hasImplicitClose
argument_list|()
condition|)
name|segments
operator|.
name|append
argument_list|(
name|VG_CLOSE_PATH
argument_list|)
expr_stmt|;
name|vgAppendPathData
argument_list|(
name|vgpath
argument_list|,
name|segments
operator|.
name|count
argument_list|()
argument_list|,
name|segments
operator|.
name|constData
argument_list|()
argument_list|,
cast|reinterpret_cast
argument_list|<
specifier|const
name|VGfloat
operator|*
argument_list|>
argument_list|(
name|points
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|vgpath
return|;
block|}
comment|// Sizes chosen so that drawRoundedRect() paths fit in these arrays.
name|QVarLengthArray
argument_list|<
name|VGfloat
argument_list|,
literal|48
argument_list|>
name|coords
decl_stmt|;
name|int
name|curvePos
init|=
literal|0
decl_stmt|;
name|QPointF
name|temp
decl_stmt|;
if|if
condition|(
name|elements
operator|&&
name|simpleTransform
condition|)
block|{
comment|// Convert the members of the element array.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|elements
index|[
name|i
index|]
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
block|{
name|coords
operator|.
name|append
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|points
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_MOVE_TO_ABS
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
block|{
name|coords
operator|.
name|append
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|points
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_LINE_TO_ABS
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
block|{
name|coords
operator|.
name|append
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|points
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|curvePos
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToDataElement
case|:
block|{
name|coords
operator|.
name|append
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|points
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|curvePos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|curvePos
operator|==
literal|6
condition|)
block|{
name|curvePos
operator|=
literal|0
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_CUBIC_TO_ABS
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|points
operator|+=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|elements
operator|&&
operator|!
name|simpleTransform
condition|)
block|{
comment|// Convert the members of the element array after applying the
comment|// current transform to the path locally.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|elements
index|[
name|i
index|]
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
block|{
name|temp
operator|=
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|,
name|points
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_MOVE_TO_ABS
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
block|{
name|temp
operator|=
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|,
name|points
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_LINE_TO_ABS
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
block|{
name|temp
operator|=
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|,
name|points
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|curvePos
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToDataElement
case|:
block|{
name|temp
operator|=
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|,
name|points
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|curvePos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|curvePos
operator|==
literal|6
condition|)
block|{
name|curvePos
operator|=
literal|0
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_CUBIC_TO_ABS
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|points
operator|+=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|simpleTransform
condition|)
block|{
comment|// If there is no element array, then the path is assumed
comment|// to be a MoveTo followed by several LineTo's.
name|coords
operator|.
name|append
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|points
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_MOVE_TO_ABS
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|points
operator|+=
literal|2
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|points
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_LINE_TO_ABS
argument_list|)
expr_stmt|;
operator|--
name|count
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
operator|!
name|simpleTransform
condition|)
block|{
comment|// Convert a simple path, and apply the transform locally.
name|temp
operator|=
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|,
name|points
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_MOVE_TO_ABS
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|points
operator|+=
literal|2
expr_stmt|;
name|temp
operator|=
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|,
name|points
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_LINE_TO_ABS
argument_list|)
expr_stmt|;
operator|--
name|count
expr_stmt|;
block|}
block|}
comment|// Close the path if specified.
if|if
condition|(
name|path
operator|.
name|hasImplicitClose
argument_list|()
condition|)
name|segments
operator|.
name|append
argument_list|(
name|VG_CLOSE_PATH
argument_list|)
expr_stmt|;
name|vgAppendPathData
argument_list|(
name|vgpath
argument_list|,
name|segments
operator|.
name|count
argument_list|()
argument_list|,
name|segments
operator|.
name|constData
argument_list|()
argument_list|,
name|coords
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vgpath
return|;
block|}
end_function
begin_function
DECL|function|painterPathToVGPath
name|VGPath
name|QVGPaintEnginePrivate
operator|::
name|painterPathToVGPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
block|{
name|int
name|count
init|=
name|path
operator|.
name|elementCount
argument_list|()
decl_stmt|;
name|VGPath
name|vgpath
init|=
name|vgCreatePath
argument_list|(
name|VG_PATH_FORMAT_STANDARD
argument_list|,
name|VG_PATH_DATATYPE_F
argument_list|,
literal|1.0f
argument_list|,
comment|// scale
literal|0.0f
argument_list|,
comment|// bias
name|count
operator|+
literal|1
argument_list|,
comment|// segmentCapacityHint
name|count
operator|*
literal|2
argument_list|,
comment|// coordCapacityHint
name|VG_PATH_CAPABILITY_ALL
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|vgpath
return|;
specifier|const
name|QPainterPath
operator|::
name|Element
modifier|*
name|elements
init|=
operator|&
operator|(
name|path
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
operator|)
decl_stmt|;
comment|// Sizes chosen so that drawRoundedRect() paths fit in these arrays.
name|QVarLengthArray
argument_list|<
name|VGfloat
argument_list|,
literal|48
argument_list|>
name|coords
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|VGubyte
argument_list|,
literal|20
argument_list|>
name|segments
decl_stmt|;
name|int
name|curvePos
init|=
literal|0
decl_stmt|;
name|QPointF
name|temp
decl_stmt|;
comment|// Keep track of the start and end of each sub-path.  QPainterPath
comment|// does not have an "implicit close" flag like QVectorPath does.
comment|// We therefore have to detect closed paths by looking for a LineTo
comment|// element that connects back to the initial MoveTo element.
name|qreal
name|startx
init|=
literal|0.0
decl_stmt|;
name|qreal
name|starty
init|=
literal|0.0
decl_stmt|;
name|qreal
name|endx
init|=
literal|0.0
decl_stmt|;
name|qreal
name|endy
init|=
literal|0.0
decl_stmt|;
name|bool
name|haveStart
init|=
literal|false
decl_stmt|;
name|bool
name|haveEnd
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|simpleTransform
condition|)
block|{
comment|// Convert the members of the element array.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|elements
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
block|{
if|if
condition|(
name|haveStart
operator|&&
name|haveEnd
operator|&&
name|startx
operator|==
name|endx
operator|&&
name|starty
operator|==
name|endy
condition|)
block|{
comment|// Implicitly close the previous sub-path.
name|segments
operator|.
name|append
argument_list|(
name|VG_CLOSE_PATH
argument_list|)
expr_stmt|;
block|}
name|startx
operator|=
name|elements
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|starty
operator|=
name|elements
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|startx
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|starty
argument_list|)
expr_stmt|;
name|haveStart
operator|=
literal|true
expr_stmt|;
name|haveEnd
operator|=
literal|false
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_MOVE_TO_ABS
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
block|{
name|endx
operator|=
name|elements
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|endy
operator|=
name|elements
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|endx
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|endy
argument_list|)
expr_stmt|;
name|haveEnd
operator|=
literal|true
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_LINE_TO_ABS
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
block|{
name|coords
operator|.
name|append
argument_list|(
name|elements
index|[
name|i
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|elements
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|haveEnd
operator|=
literal|false
expr_stmt|;
name|curvePos
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToDataElement
case|:
block|{
name|coords
operator|.
name|append
argument_list|(
name|elements
index|[
name|i
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|elements
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|haveEnd
operator|=
literal|false
expr_stmt|;
name|curvePos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|curvePos
operator|==
literal|6
condition|)
block|{
name|curvePos
operator|=
literal|0
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_CUBIC_TO_ABS
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
else|else
block|{
comment|// Convert the members of the element array after applying the
comment|// current transform to the path locally.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|elements
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|QPainterPath
operator|::
name|MoveToElement
case|:
block|{
if|if
condition|(
name|haveStart
operator|&&
name|haveEnd
operator|&&
name|startx
operator|==
name|endx
operator|&&
name|starty
operator|==
name|endy
condition|)
block|{
comment|// Implicitly close the previous sub-path.
name|segments
operator|.
name|append
argument_list|(
name|VG_CLOSE_PATH
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|elements
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|elements
index|[
name|i
index|]
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|startx
operator|=
name|temp
operator|.
name|x
argument_list|()
expr_stmt|;
name|starty
operator|=
name|temp
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|startx
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|starty
argument_list|)
expr_stmt|;
name|haveStart
operator|=
literal|true
expr_stmt|;
name|haveEnd
operator|=
literal|false
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_MOVE_TO_ABS
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|LineToElement
case|:
block|{
name|temp
operator|=
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|elements
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|elements
index|[
name|i
index|]
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|endx
operator|=
name|temp
operator|.
name|x
argument_list|()
expr_stmt|;
name|endy
operator|=
name|temp
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|endx
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|endy
argument_list|)
expr_stmt|;
name|haveEnd
operator|=
literal|true
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_LINE_TO_ABS
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToElement
case|:
block|{
name|temp
operator|=
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|elements
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|elements
index|[
name|i
index|]
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|haveEnd
operator|=
literal|false
expr_stmt|;
name|curvePos
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|QPainterPath
operator|::
name|CurveToDataElement
case|:
block|{
name|temp
operator|=
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|elements
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|elements
index|[
name|i
index|]
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|haveEnd
operator|=
literal|false
expr_stmt|;
name|curvePos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|curvePos
operator|==
literal|6
condition|)
block|{
name|curvePos
operator|=
literal|0
expr_stmt|;
name|segments
operator|.
name|append
argument_list|(
name|VG_CUBIC_TO_ABS
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|haveStart
operator|&&
name|haveEnd
operator|&&
name|startx
operator|==
name|endx
operator|&&
name|starty
operator|==
name|endy
condition|)
block|{
comment|// Implicitly close the last sub-path.
name|segments
operator|.
name|append
argument_list|(
name|VG_CLOSE_PATH
argument_list|)
expr_stmt|;
block|}
name|vgAppendPathData
argument_list|(
name|vgpath
argument_list|,
name|segments
operator|.
name|count
argument_list|()
argument_list|,
name|segments
operator|.
name|constData
argument_list|()
argument_list|,
name|coords
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vgpath
return|;
block|}
end_function
begin_function
DECL|function|roundedRectPath
name|VGPath
name|QVGPaintEnginePrivate
operator|::
name|roundedRectPath
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|qreal
name|xRadius
parameter_list|,
name|qreal
name|yRadius
parameter_list|,
name|Qt
operator|::
name|SizeMode
name|mode
parameter_list|)
block|{
specifier|static
name|VGubyte
name|roundedrect_types
index|[]
init|=
block|{
name|VG_MOVE_TO_ABS
block|,
name|VG_LINE_TO_ABS
block|,
name|VG_CUBIC_TO_ABS
block|,
name|VG_LINE_TO_ABS
block|,
name|VG_CUBIC_TO_ABS
block|,
name|VG_LINE_TO_ABS
block|,
name|VG_CUBIC_TO_ABS
block|,
name|VG_LINE_TO_ABS
block|,
name|VG_CUBIC_TO_ABS
block|,
name|VG_CLOSE_PATH
block|}
decl_stmt|;
name|qreal
name|x1
init|=
name|rect
operator|.
name|left
argument_list|()
decl_stmt|;
name|qreal
name|x2
init|=
name|rect
operator|.
name|right
argument_list|()
decl_stmt|;
name|qreal
name|y1
init|=
name|rect
operator|.
name|top
argument_list|()
decl_stmt|;
name|qreal
name|y2
init|=
name|rect
operator|.
name|bottom
argument_list|()
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|Qt
operator|::
name|RelativeSize
condition|)
block|{
name|xRadius
operator|=
name|xRadius
operator|*
name|rect
operator|.
name|width
argument_list|()
operator|/
literal|200.
expr_stmt|;
name|yRadius
operator|=
name|yRadius
operator|*
name|rect
operator|.
name|height
argument_list|()
operator|/
literal|200.
expr_stmt|;
block|}
name|xRadius
operator|=
name|qMin
argument_list|(
name|xRadius
argument_list|,
name|rect
operator|.
name|width
argument_list|()
operator|/
literal|2
argument_list|)
expr_stmt|;
name|yRadius
operator|=
name|qMin
argument_list|(
name|yRadius
argument_list|,
name|rect
operator|.
name|height
argument_list|()
operator|/
literal|2
argument_list|)
expr_stmt|;
name|VGfloat
name|pts
index|[]
init|=
block|{
name|x1
operator|+
name|xRadius
block|,
name|y1
block|,
comment|// MoveTo
name|x2
operator|-
name|xRadius
block|,
name|y1
block|,
comment|// LineTo
name|x2
operator|-
operator|(
literal|1
operator|-
name|KAPPA
operator|)
operator|*
name|xRadius
block|,
name|y1
block|,
comment|// CurveTo
name|x2
block|,
name|y1
operator|+
operator|(
literal|1
operator|-
name|KAPPA
operator|)
operator|*
name|yRadius
block|,
name|x2
block|,
name|y1
operator|+
name|yRadius
block|,
name|x2
block|,
name|y2
operator|-
name|yRadius
block|,
comment|// LineTo
name|x2
block|,
name|y2
operator|-
operator|(
literal|1
operator|-
name|KAPPA
operator|)
operator|*
name|yRadius
block|,
comment|// CurveTo
name|x2
operator|-
operator|(
literal|1
operator|-
name|KAPPA
operator|)
operator|*
name|xRadius
block|,
name|y2
block|,
name|x2
operator|-
name|xRadius
block|,
name|y2
block|,
name|x1
operator|+
name|xRadius
block|,
name|y2
block|,
comment|// LineTo
name|x1
operator|+
operator|(
literal|1
operator|-
name|KAPPA
operator|)
operator|*
name|xRadius
block|,
name|y2
block|,
comment|// CurveTo
name|x1
block|,
name|y2
operator|-
operator|(
literal|1
operator|-
name|KAPPA
operator|)
operator|*
name|yRadius
block|,
name|x1
block|,
name|y2
operator|-
name|yRadius
block|,
name|x1
block|,
name|y1
operator|+
name|yRadius
block|,
comment|// LineTo
name|x1
block|,
name|y1
operator|+
operator|(
literal|1
operator|-
name|KAPPA
operator|)
operator|*
name|yRadius
block|,
comment|// CurveTo
name|x1
operator|+
operator|(
literal|1
operator|-
name|KAPPA
operator|)
operator|*
name|xRadius
block|,
name|y1
block|,
name|x1
operator|+
name|xRadius
block|,
name|y1
block|}
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
name|VGPath
name|vgpath
init|=
name|roundRectPath
decl_stmt|;
if|if
condition|(
operator|!
name|vgpath
condition|)
block|{
name|vgpath
operator|=
name|vgCreatePath
argument_list|(
name|VG_PATH_FORMAT_STANDARD
argument_list|,
name|VG_PATH_DATATYPE_F
argument_list|,
literal|1.0f
argument_list|,
comment|// scale
literal|0.0f
argument_list|,
comment|// bias
literal|10
argument_list|,
comment|// segmentCapacityHint
literal|17
operator|*
literal|2
argument_list|,
comment|// coordCapacityHint
name|VG_PATH_CAPABILITY_ALL
argument_list|)
expr_stmt|;
name|vgAppendPathData
argument_list|(
name|vgpath
argument_list|,
literal|10
argument_list|,
name|roundedrect_types
argument_list|,
name|pts
argument_list|)
expr_stmt|;
name|roundRectPath
operator|=
name|vgpath
expr_stmt|;
block|}
else|else
block|{
name|vgModifyPathCoords
argument_list|(
name|vgpath
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|,
name|pts
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|VGPath
name|vgpath
init|=
name|vgCreatePath
argument_list|(
name|VG_PATH_FORMAT_STANDARD
argument_list|,
name|VG_PATH_DATATYPE_F
argument_list|,
literal|1.0f
argument_list|,
comment|// scale
literal|0.0f
argument_list|,
comment|// bias
literal|10
argument_list|,
comment|// segmentCapacityHint
literal|17
operator|*
literal|2
argument_list|,
comment|// coordCapacityHint
name|VG_PATH_CAPABILITY_ALL
argument_list|)
decl_stmt|;
name|vgAppendPathData
argument_list|(
name|vgpath
argument_list|,
literal|10
argument_list|,
name|roundedrect_types
argument_list|,
name|pts
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|vgpath
return|;
block|}
end_function
begin_function_decl
name|Q_GUI_EXPORT
name|QImage
name|qt_imageForBrush
parameter_list|(
name|int
name|style
parameter_list|,
name|bool
name|invert
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|colorizeBitmap
specifier|static
name|QImage
name|colorizeBitmap
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
name|QImage
name|sourceImage
init|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_MonoLSB
argument_list|)
decl_stmt|;
name|QImage
name|dest
init|=
name|QImage
argument_list|(
name|sourceImage
operator|.
name|size
argument_list|()
argument_list|,
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
decl_stmt|;
name|QRgb
name|fg
init|=
name|PREMUL
argument_list|(
name|color
operator|.
name|rgba
argument_list|()
argument_list|)
decl_stmt|;
name|QRgb
name|bg
init|=
literal|0
decl_stmt|;
name|int
name|height
init|=
name|sourceImage
operator|.
name|height
argument_list|()
decl_stmt|;
name|int
name|width
init|=
name|sourceImage
operator|.
name|width
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
block|{
specifier|const
name|uchar
modifier|*
name|source
init|=
name|sourceImage
operator|.
name|constScanLine
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|QRgb
modifier|*
name|target
init|=
cast|reinterpret_cast
argument_list|<
name|QRgb
operator|*
argument_list|>
argument_list|(
name|dest
operator|.
name|scanLine
argument_list|(
name|y
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
operator|++
name|x
control|)
name|target
index|[
name|x
index|]
operator|=
operator|(
name|source
index|[
name|x
operator|>>
literal|3
index|]
operator|>>
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
operator|&
literal|1
condition|?
name|fg
else|:
name|bg
expr_stmt|;
block|}
return|return
name|dest
return|;
block|}
end_function
begin_function
DECL|function|toVGImage
specifier|static
name|VGImage
name|toVGImage
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
init|=
name|Qt
operator|::
name|AutoColor
parameter_list|)
block|{
name|QImage
name|img
argument_list|(
name|image
argument_list|)
decl_stmt|;
name|VGImageFormat
name|format
decl_stmt|;
switch|switch
condition|(
name|img
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_Mono
case|:
name|img
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_MonoLSB
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|img
operator|.
name|invertPixels
argument_list|()
expr_stmt|;
name|format
operator|=
name|VG_BW_1
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
name|img
operator|.
name|invertPixels
argument_list|()
expr_stmt|;
name|format
operator|=
name|VG_BW_1
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
name|format
operator|=
name|VG_sXRGB_8888
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
name|format
operator|=
name|VG_sARGB_8888
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|format
operator|=
name|VG_sARGB_8888_PRE
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|format
operator|=
name|VG_sRGB_565
expr_stmt|;
break|break;
default|default:
comment|// Convert everything else into ARGB32_Premultiplied.
name|img
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|format
operator|=
name|VG_sARGB_8888_PRE
expr_stmt|;
break|break;
block|}
specifier|const
name|uchar
modifier|*
name|pixels
init|=
name|img
operator|.
name|constBits
argument_list|()
decl_stmt|;
name|VGImage
name|vgImg
init|=
name|QVGImagePool
operator|::
name|instance
argument_list|()
operator|->
name|createPermanentImage
argument_list|(
name|format
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|,
name|VG_IMAGE_QUALITY_FASTER
argument_list|)
decl_stmt|;
name|vgImageSubData
argument_list|(
name|vgImg
argument_list|,
name|pixels
argument_list|,
name|img
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vgImg
return|;
block|}
end_function
begin_function
DECL|function|toVGImageSubRect
specifier|static
name|VGImage
name|toVGImageSubRect
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QRect
modifier|&
name|sr
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
init|=
name|Qt
operator|::
name|AutoColor
parameter_list|)
block|{
name|QImage
name|img
argument_list|(
name|image
argument_list|)
decl_stmt|;
name|VGImageFormat
name|format
decl_stmt|;
name|int
name|bpp
init|=
literal|4
decl_stmt|;
switch|switch
condition|(
name|img
operator|.
name|format
argument_list|()
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_Mono
case|:
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
return|return
name|VG_INVALID_HANDLE
return|;
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
name|format
operator|=
name|VG_sXRGB_8888
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
name|format
operator|=
name|VG_sARGB_8888
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
name|format
operator|=
name|VG_sARGB_8888_PRE
expr_stmt|;
break|break;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
name|format
operator|=
name|VG_sRGB_565
expr_stmt|;
name|bpp
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
comment|// Convert everything else into ARGB32_Premultiplied.
name|img
operator|=
name|image
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|format
operator|=
name|VG_sARGB_8888_PRE
expr_stmt|;
break|break;
block|}
specifier|const
name|uchar
modifier|*
name|pixels
init|=
name|img
operator|.
name|constBits
argument_list|()
operator|+
name|bpp
operator|*
name|sr
operator|.
name|x
argument_list|()
operator|+
name|img
operator|.
name|bytesPerLine
argument_list|()
operator|*
name|sr
operator|.
name|y
argument_list|()
decl_stmt|;
name|VGImage
name|vgImg
init|=
name|QVGImagePool
operator|::
name|instance
argument_list|()
operator|->
name|createPermanentImage
argument_list|(
name|format
argument_list|,
name|sr
operator|.
name|width
argument_list|()
argument_list|,
name|sr
operator|.
name|height
argument_list|()
argument_list|,
name|VG_IMAGE_QUALITY_FASTER
argument_list|)
decl_stmt|;
name|vgImageSubData
argument_list|(
name|vgImg
argument_list|,
name|pixels
argument_list|,
name|img
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sr
operator|.
name|width
argument_list|()
argument_list|,
name|sr
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vgImg
return|;
block|}
end_function
begin_function
DECL|function|toVGImageWithOpacity
specifier|static
name|VGImage
name|toVGImageWithOpacity
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|qreal
name|opacity
parameter_list|)
block|{
name|QImage
name|img
argument_list|(
name|image
operator|.
name|size
argument_list|()
argument_list|,
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
decl_stmt|;
name|img
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QPainter
name|painter
decl_stmt|;
name|painter
operator|.
name|begin
argument_list|(
operator|&
name|img
argument_list|)
expr_stmt|;
name|painter
operator|.
name|setOpacity
argument_list|(
name|opacity
argument_list|)
expr_stmt|;
name|painter
operator|.
name|drawImage
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|painter
operator|.
name|end
argument_list|()
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|pixels
init|=
name|img
operator|.
name|constBits
argument_list|()
decl_stmt|;
name|VGImage
name|vgImg
init|=
name|QVGImagePool
operator|::
name|instance
argument_list|()
operator|->
name|createPermanentImage
argument_list|(
name|VG_sARGB_8888_PRE
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|,
name|VG_IMAGE_QUALITY_FASTER
argument_list|)
decl_stmt|;
name|vgImageSubData
argument_list|(
name|vgImg
argument_list|,
name|pixels
argument_list|,
name|img
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
name|VG_sARGB_8888_PRE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vgImg
return|;
block|}
end_function
begin_function
DECL|function|toVGImageWithOpacitySubRect
specifier|static
name|VGImage
name|toVGImageWithOpacitySubRect
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
name|qreal
name|opacity
parameter_list|,
specifier|const
name|QRect
modifier|&
name|sr
parameter_list|)
block|{
name|QImage
name|img
argument_list|(
name|sr
operator|.
name|size
argument_list|()
argument_list|,
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
decl_stmt|;
name|img
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QPainter
name|painter
decl_stmt|;
name|painter
operator|.
name|begin
argument_list|(
operator|&
name|img
argument_list|)
expr_stmt|;
name|painter
operator|.
name|setOpacity
argument_list|(
name|opacity
argument_list|)
expr_stmt|;
name|painter
operator|.
name|drawImage
argument_list|(
name|QPoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|image
argument_list|,
name|sr
argument_list|)
expr_stmt|;
name|painter
operator|.
name|end
argument_list|()
expr_stmt|;
specifier|const
name|uchar
modifier|*
name|pixels
init|=
name|img
operator|.
name|constBits
argument_list|()
decl_stmt|;
name|VGImage
name|vgImg
init|=
name|QVGImagePool
operator|::
name|instance
argument_list|()
operator|->
name|createPermanentImage
argument_list|(
name|VG_sARGB_8888_PRE
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|,
name|VG_IMAGE_QUALITY_FASTER
argument_list|)
decl_stmt|;
name|vgImageSubData
argument_list|(
name|vgImg
argument_list|,
name|pixels
argument_list|,
name|img
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
name|VG_sARGB_8888_PRE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vgImg
return|;
block|}
end_function
begin_function
DECL|function|setBrush
name|VGPaintType
name|QVGPaintEnginePrivate
operator|::
name|setBrush
parameter_list|(
name|VGPaint
name|paint
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|,
name|VGMatrixMode
name|mode
parameter_list|,
name|VGPaintType
name|prevType
parameter_list|)
block|{
name|VGfloat
name|values
index|[
literal|5
index|]
decl_stmt|;
name|setBrushTransform
argument_list|(
name|brush
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|// Reset the paint pattern on the brush, which will discard
comment|// the previous VGImage if one was set.
if|if
condition|(
name|prevType
operator|==
name|VG_PAINT_TYPE_PATTERN
operator|||
name|prevType
operator|==
operator|(
name|VGPaintType
operator|)
literal|0
condition|)
name|vgPaintPattern
argument_list|(
name|paint
argument_list|,
name|VG_INVALID_HANDLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|brush
operator|.
name|style
argument_list|()
condition|)
block|{
case|case
name|Qt
operator|::
name|SolidPattern
case|:
block|{
comment|// The brush is a solid color.
name|QColor
name|color
argument_list|(
name|brush
operator|.
name|color
argument_list|()
argument_list|)
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
name|color
operator|.
name|redF
argument_list|()
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
name|color
operator|.
name|greenF
argument_list|()
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
name|color
operator|.
name|blueF
argument_list|()
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|color
operator|.
name|alphaF
argument_list|()
operator|*
name|opacity
expr_stmt|;
if|if
condition|(
name|prevType
operator|!=
name|VG_PAINT_TYPE_COLOR
condition|)
name|vgSetParameteri
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_TYPE
argument_list|,
name|VG_PAINT_TYPE_COLOR
argument_list|)
expr_stmt|;
name|vgSetParameterfv
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_COLOR
argument_list|,
literal|4
argument_list|,
name|values
argument_list|)
expr_stmt|;
return|return
name|VG_PAINT_TYPE_COLOR
return|;
block|}
case|case
name|Qt
operator|::
name|LinearGradientPattern
case|:
block|{
comment|// The brush is a linear gradient.
name|Q_ASSERT
argument_list|(
name|brush
operator|.
name|gradient
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|QGradient
operator|::
name|LinearGradient
argument_list|)
expr_stmt|;
specifier|const
name|QLinearGradient
modifier|*
name|grad
init|=
cast|static_cast
argument_list|<
specifier|const
name|QLinearGradient
operator|*
argument_list|>
argument_list|(
name|brush
operator|.
name|gradient
argument_list|()
argument_list|)
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
name|grad
operator|->
name|start
argument_list|()
operator|.
name|x
argument_list|()
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
name|grad
operator|->
name|start
argument_list|()
operator|.
name|y
argument_list|()
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
name|grad
operator|->
name|finalStop
argument_list|()
operator|.
name|x
argument_list|()
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|grad
operator|->
name|finalStop
argument_list|()
operator|.
name|y
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevType
operator|!=
name|VG_PAINT_TYPE_LINEAR_GRADIENT
condition|)
name|vgSetParameteri
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_TYPE
argument_list|,
name|VG_PAINT_TYPE_LINEAR_GRADIENT
argument_list|)
expr_stmt|;
name|vgSetParameterfv
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_LINEAR_GRADIENT
argument_list|,
literal|4
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|setupColorRamp
argument_list|(
name|grad
argument_list|,
name|paint
argument_list|)
expr_stmt|;
return|return
name|VG_PAINT_TYPE_LINEAR_GRADIENT
return|;
block|}
case|case
name|Qt
operator|::
name|RadialGradientPattern
case|:
block|{
comment|// The brush is a radial gradient.
name|Q_ASSERT
argument_list|(
name|brush
operator|.
name|gradient
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|QGradient
operator|::
name|RadialGradient
argument_list|)
expr_stmt|;
specifier|const
name|QRadialGradient
modifier|*
name|grad
init|=
cast|static_cast
argument_list|<
specifier|const
name|QRadialGradient
operator|*
argument_list|>
argument_list|(
name|brush
operator|.
name|gradient
argument_list|()
argument_list|)
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
name|grad
operator|->
name|center
argument_list|()
operator|.
name|x
argument_list|()
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
name|grad
operator|->
name|center
argument_list|()
operator|.
name|y
argument_list|()
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
name|grad
operator|->
name|focalPoint
argument_list|()
operator|.
name|x
argument_list|()
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|grad
operator|->
name|focalPoint
argument_list|()
operator|.
name|y
argument_list|()
expr_stmt|;
name|values
index|[
literal|4
index|]
operator|=
name|grad
operator|->
name|radius
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevType
operator|!=
name|VG_PAINT_TYPE_RADIAL_GRADIENT
condition|)
name|vgSetParameteri
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_TYPE
argument_list|,
name|VG_PAINT_TYPE_RADIAL_GRADIENT
argument_list|)
expr_stmt|;
name|vgSetParameterfv
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_RADIAL_GRADIENT
argument_list|,
literal|5
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|setupColorRamp
argument_list|(
name|grad
argument_list|,
name|paint
argument_list|)
expr_stmt|;
return|return
name|VG_PAINT_TYPE_RADIAL_GRADIENT
return|;
block|}
case|case
name|Qt
operator|::
name|TexturePattern
case|:
block|{
comment|// The brush is a texture specified by a QPixmap/QImage.
name|QPixmapData
modifier|*
name|pd
init|=
name|brush
operator|.
name|texture
argument_list|()
operator|.
name|pixmapData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pd
condition|)
break|break;
comment|// null QPixmap
name|VGImage
name|vgImg
decl_stmt|;
name|bool
name|deref
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|pd
operator|->
name|pixelType
argument_list|()
operator|==
name|QPixmapData
operator|::
name|BitmapType
condition|)
block|{
comment|// Colorize bitmaps using the brush color and opacity.
name|QColor
name|color
init|=
name|brush
operator|.
name|color
argument_list|()
decl_stmt|;
if|if
condition|(
name|opacity
operator|!=
literal|1.0
condition|)
name|color
operator|.
name|setAlphaF
argument_list|(
name|color
operator|.
name|alphaF
argument_list|()
operator|*
name|opacity
argument_list|)
expr_stmt|;
name|QImage
name|image
init|=
name|colorizeBitmap
argument_list|(
operator|*
operator|(
name|pd
operator|->
name|buffer
argument_list|()
operator|)
argument_list|,
name|color
argument_list|)
decl_stmt|;
name|vgImg
operator|=
name|toVGImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|deref
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opacity
operator|==
literal|1.0
condition|)
block|{
if|if
condition|(
name|pd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|OpenVGClass
condition|)
block|{
name|QVGPixmapData
modifier|*
name|vgpd
init|=
cast|static_cast
argument_list|<
name|QVGPixmapData
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
decl_stmt|;
name|vgImg
operator|=
name|vgpd
operator|->
name|toVGImage
argument_list|()
expr_stmt|;
comment|// We don't want the pool to reclaim this image
comment|// because we cannot predict when the paint object
comment|// will stop using it.  Replacing the image with
comment|// new data will make the paint object invalid.
name|vgpd
operator|->
name|detachImageFromPool
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|vgImg
operator|=
name|toVGImage
argument_list|(
operator|*
operator|(
name|pd
operator|->
name|buffer
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|deref
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|OpenVGClass
condition|)
block|{
name|QVGPixmapData
modifier|*
name|vgpd
init|=
cast|static_cast
argument_list|<
name|QVGPixmapData
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
decl_stmt|;
name|vgImg
operator|=
name|vgpd
operator|->
name|toVGImage
argument_list|(
name|opacity
argument_list|)
expr_stmt|;
name|vgpd
operator|->
name|detachImageFromPool
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|vgImg
operator|=
name|toVGImageWithOpacity
argument_list|(
operator|*
operator|(
name|pd
operator|->
name|buffer
argument_list|()
operator|)
argument_list|,
name|opacity
argument_list|)
expr_stmt|;
name|deref
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|vgImg
operator|==
name|VG_INVALID_HANDLE
condition|)
break|break;
if|if
condition|(
name|prevType
operator|!=
name|VG_PAINT_TYPE_PATTERN
condition|)
name|vgSetParameteri
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_TYPE
argument_list|,
name|VG_PAINT_TYPE_PATTERN
argument_list|)
expr_stmt|;
name|vgSetParameteri
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_PATTERN_TILING_MODE
argument_list|,
name|VG_TILE_REPEAT
argument_list|)
expr_stmt|;
name|vgPaintPattern
argument_list|(
name|paint
argument_list|,
name|vgImg
argument_list|)
expr_stmt|;
if|if
condition|(
name|deref
condition|)
name|vgDestroyImage
argument_list|(
name|vgImg
argument_list|)
expr_stmt|;
comment|// Will be valid until pattern is destroyed.
return|return
name|VG_PAINT_TYPE_PATTERN
return|;
block|}
case|case
name|Qt
operator|::
name|ConicalGradientPattern
case|:
block|{
comment|// Convert conical gradients into the first stop color.
name|qWarning
argument_list|()
operator|<<
literal|"QVGPaintEnginePrivate::setBrush: conical gradients are not supported by OpenVG"
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|brush
operator|.
name|gradient
argument_list|()
operator|->
name|type
argument_list|()
operator|==
name|QGradient
operator|::
name|ConicalGradient
argument_list|)
expr_stmt|;
specifier|const
name|QConicalGradient
modifier|*
name|grad
init|=
cast|static_cast
argument_list|<
specifier|const
name|QConicalGradient
operator|*
argument_list|>
argument_list|(
name|brush
operator|.
name|gradient
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|QGradientStops
name|stops
init|=
name|grad
operator|->
name|stops
argument_list|()
decl_stmt|;
name|QColor
name|color
decl_stmt|;
if|if
condition|(
name|stops
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
name|color
operator|=
name|stops
index|[
literal|0
index|]
operator|.
name|second
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|=
name|color
operator|.
name|redF
argument_list|()
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
name|color
operator|.
name|greenF
argument_list|()
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
name|color
operator|.
name|blueF
argument_list|()
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|color
operator|.
name|alphaF
argument_list|()
operator|*
name|opacity
expr_stmt|;
if|if
condition|(
name|prevType
operator|!=
name|VG_PAINT_TYPE_COLOR
condition|)
name|vgSetParameteri
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_TYPE
argument_list|,
name|VG_PAINT_TYPE_COLOR
argument_list|)
expr_stmt|;
name|vgSetParameterfv
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_COLOR
argument_list|,
literal|4
argument_list|,
name|values
argument_list|)
expr_stmt|;
return|return
name|VG_PAINT_TYPE_COLOR
return|;
block|}
case|case
name|Qt
operator|::
name|Dense1Pattern
case|:
case|case
name|Qt
operator|::
name|Dense2Pattern
case|:
case|case
name|Qt
operator|::
name|Dense3Pattern
case|:
case|case
name|Qt
operator|::
name|Dense4Pattern
case|:
case|case
name|Qt
operator|::
name|Dense5Pattern
case|:
case|case
name|Qt
operator|::
name|Dense6Pattern
case|:
case|case
name|Qt
operator|::
name|Dense7Pattern
case|:
case|case
name|Qt
operator|::
name|HorPattern
case|:
case|case
name|Qt
operator|::
name|VerPattern
case|:
case|case
name|Qt
operator|::
name|CrossPattern
case|:
case|case
name|Qt
operator|::
name|BDiagPattern
case|:
case|case
name|Qt
operator|::
name|FDiagPattern
case|:
case|case
name|Qt
operator|::
name|DiagCrossPattern
case|:
block|{
comment|// The brush is a traditional dotted or cross-hatched pattern brush.
name|QColor
name|color
init|=
name|brush
operator|.
name|color
argument_list|()
decl_stmt|;
if|if
condition|(
name|opacity
operator|!=
literal|1.0
condition|)
name|color
operator|.
name|setAlphaF
argument_list|(
name|color
operator|.
name|alphaF
argument_list|()
operator|*
name|opacity
argument_list|)
expr_stmt|;
name|QImage
name|image
init|=
name|colorizeBitmap
argument_list|(
name|qt_imageForBrush
argument_list|(
name|brush
operator|.
name|style
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|,
name|color
argument_list|)
decl_stmt|;
name|VGImage
name|vgImg
init|=
name|toVGImage
argument_list|(
name|image
argument_list|)
decl_stmt|;
if|if
condition|(
name|prevType
operator|!=
name|VG_PAINT_TYPE_PATTERN
condition|)
name|vgSetParameteri
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_TYPE
argument_list|,
name|VG_PAINT_TYPE_PATTERN
argument_list|)
expr_stmt|;
name|vgSetParameteri
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_PATTERN_TILING_MODE
argument_list|,
name|VG_TILE_REPEAT
argument_list|)
expr_stmt|;
name|vgPaintPattern
argument_list|(
name|paint
argument_list|,
name|vgImg
argument_list|)
expr_stmt|;
name|vgDestroyImage
argument_list|(
name|vgImg
argument_list|)
expr_stmt|;
comment|// Will stay valid until pattern is destroyed.
return|return
name|VG_PAINT_TYPE_PATTERN
return|;
block|}
default|default:
break|break;
block|}
return|return
operator|(
name|VGPaintType
operator|)
literal|0
return|;
block|}
end_function
begin_function
DECL|function|setPenParams
name|void
name|QVGPaintEnginePrivate
operator|::
name|setPenParams
parameter_list|(
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
comment|// Note: OpenVG does not support zero-width or cosmetic pens,
comment|// so we have to simulate cosmetic pens by reversing the scale.
name|VGfloat
name|width
init|=
name|pen
operator|.
name|widthF
argument_list|()
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0.0f
condition|)
name|width
operator|=
literal|1.0f
expr_stmt|;
if|if
condition|(
name|pen
operator|.
name|isCosmetic
argument_list|()
condition|)
block|{
if|if
condition|(
name|penScale
operator|!=
literal|1.0
operator|&&
name|penScale
operator|!=
literal|0.0
condition|)
name|width
operator|/=
name|penScale
expr_stmt|;
block|}
name|vgSetf
argument_list|(
name|VG_STROKE_LINE_WIDTH
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|pen
operator|.
name|capStyle
argument_list|()
operator|==
name|Qt
operator|::
name|FlatCap
condition|)
name|vgSetf
argument_list|(
name|VG_STROKE_CAP_STYLE
argument_list|,
name|VG_CAP_BUTT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pen
operator|.
name|capStyle
argument_list|()
operator|==
name|Qt
operator|::
name|SquareCap
condition|)
name|vgSetf
argument_list|(
name|VG_STROKE_CAP_STYLE
argument_list|,
name|VG_CAP_SQUARE
argument_list|)
expr_stmt|;
else|else
name|vgSetf
argument_list|(
name|VG_STROKE_CAP_STYLE
argument_list|,
name|VG_CAP_ROUND
argument_list|)
expr_stmt|;
if|if
condition|(
name|pen
operator|.
name|joinStyle
argument_list|()
operator|==
name|Qt
operator|::
name|MiterJoin
condition|)
block|{
name|vgSetf
argument_list|(
name|VG_STROKE_JOIN_STYLE
argument_list|,
name|VG_JOIN_MITER
argument_list|)
expr_stmt|;
name|vgSetf
argument_list|(
name|VG_STROKE_MITER_LIMIT
argument_list|,
name|pen
operator|.
name|miterLimit
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pen
operator|.
name|joinStyle
argument_list|()
operator|==
name|Qt
operator|::
name|BevelJoin
condition|)
block|{
name|vgSetf
argument_list|(
name|VG_STROKE_JOIN_STYLE
argument_list|,
name|VG_JOIN_BEVEL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vgSetf
argument_list|(
name|VG_STROKE_JOIN_STYLE
argument_list|,
name|VG_JOIN_ROUND
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pen
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|SolidLine
condition|)
block|{
name|vgSetfv
argument_list|(
name|VG_STROKE_DASH_PATTERN
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QVector
argument_list|<
name|qreal
argument_list|>
name|dashPattern
init|=
name|pen
operator|.
name|dashPattern
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|VGfloat
argument_list|>
name|currentDashPattern
argument_list|(
name|dashPattern
operator|.
name|count
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dashPattern
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
name|currentDashPattern
index|[
name|i
index|]
operator|=
name|dashPattern
index|[
name|i
index|]
operator|*
name|width
expr_stmt|;
name|vgSetfv
argument_list|(
name|VG_STROKE_DASH_PATTERN
argument_list|,
name|currentDashPattern
operator|.
name|count
argument_list|()
argument_list|,
name|currentDashPattern
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|vgSetf
argument_list|(
name|VG_STROKE_DASH_PHASE
argument_list|,
name|pen
operator|.
name|dashOffset
argument_list|()
argument_list|)
expr_stmt|;
name|vgSetf
argument_list|(
name|VG_STROKE_DASH_PHASE_RESET
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setBrushTransform
name|void
name|QVGPaintEnginePrivate
operator|::
name|setBrushTransform
parameter_list|(
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|,
name|VGMatrixMode
name|mode
parameter_list|)
block|{
comment|// Compute the new brush transformation matrix.
name|QTransform
name|transform
argument_list|(
name|brush
operator|.
name|transform
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|brushOrigin
operator|.
name|x
argument_list|()
operator|!=
literal|0.0f
operator|||
name|brushOrigin
operator|.
name|y
argument_list|()
operator|!=
literal|0.0f
condition|)
name|transform
operator|.
name|translate
argument_list|(
name|brushOrigin
operator|.
name|x
argument_list|()
argument_list|,
name|brushOrigin
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
comment|// Bail out if the matrix is the same as last time, to avoid
comment|// updating the VG context state unless absolutely necessary.
comment|// Most applications won't have a brush transformation set,
comment|// which will leave the VG setting at its default of identity.
comment|// Always change the transform if coming out of raw VG mode.
if|if
condition|(
name|mode
operator|==
name|VG_MATRIX_FILL_PAINT_TO_USER
condition|)
block|{
if|if
condition|(
operator|!
name|rawVG
operator|&&
name|transform
operator|==
name|brushTransform
condition|)
return|return;
name|brushTransform
operator|=
name|transform
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rawVG
operator|&&
name|transform
operator|==
name|penTransform
condition|)
return|return;
name|penTransform
operator|=
name|transform
expr_stmt|;
block|}
comment|// Set the brush transformation matrix.
if|if
condition|(
name|mode
operator|!=
name|matrixMode
condition|)
block|{
name|vgSeti
argument_list|(
name|VG_MATRIX_MODE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|matrixMode
operator|=
name|mode
expr_stmt|;
block|}
if|if
condition|(
name|transform
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
name|vgLoadIdentity
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|VGfloat
name|mat
index|[
literal|9
index|]
decl_stmt|;
name|mat
index|[
literal|0
index|]
operator|=
name|transform
operator|.
name|m11
argument_list|()
expr_stmt|;
name|mat
index|[
literal|1
index|]
operator|=
name|transform
operator|.
name|m12
argument_list|()
expr_stmt|;
name|mat
index|[
literal|2
index|]
operator|=
name|transform
operator|.
name|m13
argument_list|()
expr_stmt|;
name|mat
index|[
literal|3
index|]
operator|=
name|transform
operator|.
name|m21
argument_list|()
expr_stmt|;
name|mat
index|[
literal|4
index|]
operator|=
name|transform
operator|.
name|m22
argument_list|()
expr_stmt|;
name|mat
index|[
literal|5
index|]
operator|=
name|transform
operator|.
name|m23
argument_list|()
expr_stmt|;
name|mat
index|[
literal|6
index|]
operator|=
name|transform
operator|.
name|m31
argument_list|()
expr_stmt|;
name|mat
index|[
literal|7
index|]
operator|=
name|transform
operator|.
name|m32
argument_list|()
expr_stmt|;
name|mat
index|[
literal|8
index|]
operator|=
name|transform
operator|.
name|m33
argument_list|()
expr_stmt|;
name|vgLoadMatrix
argument_list|(
name|mat
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setupColorRamp
name|void
name|QVGPaintEnginePrivate
operator|::
name|setupColorRamp
parameter_list|(
specifier|const
name|QGradient
modifier|*
name|grad
parameter_list|,
name|VGPaint
name|paint
parameter_list|)
block|{
name|QGradient
operator|::
name|Spread
name|spread
init|=
name|grad
operator|->
name|spread
argument_list|()
decl_stmt|;
name|VGColorRampSpreadMode
name|spreadMode
decl_stmt|;
if|if
condition|(
name|spread
operator|==
name|QGradient
operator|::
name|ReflectSpread
condition|)
name|spreadMode
operator|=
name|VG_COLOR_RAMP_SPREAD_REFLECT
expr_stmt|;
elseif|else
if|if
condition|(
name|spread
operator|==
name|QGradient
operator|::
name|RepeatSpread
condition|)
name|spreadMode
operator|=
name|VG_COLOR_RAMP_SPREAD_REPEAT
expr_stmt|;
else|else
name|spreadMode
operator|=
name|VG_COLOR_RAMP_SPREAD_PAD
expr_stmt|;
specifier|const
name|QGradientStops
name|stops
init|=
name|grad
operator|->
name|stops
argument_list|()
decl_stmt|;
name|int
name|n
init|=
literal|5
operator|*
name|stops
operator|.
name|size
argument_list|()
decl_stmt|;
name|QVector
argument_list|<
name|VGfloat
argument_list|>
name|fill_stops
argument_list|(
name|n
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stops
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QColor
name|col
init|=
name|stops
index|[
name|i
index|]
operator|.
name|second
decl_stmt|;
name|fill_stops
index|[
name|i
operator|*
literal|5
index|]
operator|=
name|stops
index|[
name|i
index|]
operator|.
name|first
expr_stmt|;
name|fill_stops
index|[
name|i
operator|*
literal|5
operator|+
literal|1
index|]
operator|=
name|col
operator|.
name|redF
argument_list|()
expr_stmt|;
name|fill_stops
index|[
name|i
operator|*
literal|5
operator|+
literal|2
index|]
operator|=
name|col
operator|.
name|greenF
argument_list|()
expr_stmt|;
name|fill_stops
index|[
name|i
operator|*
literal|5
operator|+
literal|3
index|]
operator|=
name|col
operator|.
name|blueF
argument_list|()
expr_stmt|;
name|fill_stops
index|[
name|i
operator|*
literal|5
operator|+
literal|4
index|]
operator|=
name|col
operator|.
name|alphaF
argument_list|()
operator|*
name|opacity
expr_stmt|;
block|}
name|vgSetParameteri
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_COLOR_RAMP_SPREAD_MODE
argument_list|,
name|spreadMode
argument_list|)
expr_stmt|;
name|vgSetParameteri
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_COLOR_RAMP_PREMULTIPLIED
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|vgSetParameterfv
argument_list|(
name|paint
argument_list|,
name|VG_PAINT_COLOR_RAMP_STOPS
argument_list|,
name|n
argument_list|,
name|fill_stops
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_constructor
DECL|function|QVGPainterState
name|QVGPainterState
operator|::
name|QVGPainterState
parameter_list|(
name|QVGPainterState
modifier|&
name|other
parameter_list|)
member_init_list|:
name|QPainterState
argument_list|(
name|other
argument_list|)
member_init_list|,
name|isNew
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|clipRegion
argument_list|(
name|other
operator|.
name|clipRegion
argument_list|)
member_init_list|,
name|savedDirty
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QVGPainterState
name|QVGPainterState
operator|::
name|QVGPainterState
parameter_list|()
member_init_list|:
name|isNew
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|savedDirty
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QVGPainterState
name|QVGPainterState
operator|::
name|~
name|QVGPainterState
parameter_list|()
block|{ }
end_destructor
begin_constructor
DECL|function|QVGPaintEngine
name|QVGPaintEngine
operator|::
name|QVGPaintEngine
parameter_list|()
member_init_list|:
name|QPaintEngineEx
argument_list|(
operator|*
operator|new
name|QVGPaintEnginePrivate
argument_list|(
name|this
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_constructor
DECL|function|QVGPaintEngine
name|QVGPaintEngine
operator|::
name|QVGPaintEngine
parameter_list|(
name|QVGPaintEnginePrivate
modifier|&
name|data
parameter_list|)
member_init_list|:
name|QPaintEngineEx
argument_list|(
name|data
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QVGPaintEngine
name|QVGPaintEngine
operator|::
name|~
name|QVGPaintEngine
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|createState
name|QPainterState
modifier|*
name|QVGPaintEngine
operator|::
name|createState
parameter_list|(
name|QPainterState
modifier|*
name|orig
parameter_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|orig
condition|)
block|{
return|return
operator|new
name|QVGPainterState
argument_list|()
return|;
block|}
else|else
block|{
name|Q_D
argument_list|(
specifier|const
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|QVGPaintEnginePrivate
modifier|*
name|d2
init|=
cast|const_cast
argument_list|<
name|QVGPaintEnginePrivate
operator|*
argument_list|>
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|QVGPainterState
modifier|*
name|origState
init|=
cast|static_cast
argument_list|<
name|QVGPainterState
operator|*
argument_list|>
argument_list|(
name|orig
argument_list|)
decl_stmt|;
name|origState
operator|->
name|savedDirty
operator|=
name|d2
operator|->
name|dirty
expr_stmt|;
name|d2
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
return|return
operator|new
name|QVGPainterState
argument_list|(
operator|*
name|origState
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|draw
name|void
name|QVGPaintEnginePrivate
operator|::
name|draw
parameter_list|(
name|VGPath
name|path
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|,
name|VGint
name|rule
parameter_list|)
block|{
name|VGbitfield
name|mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|qpen_style
argument_list|(
name|pen
argument_list|)
operator|!=
name|Qt
operator|::
name|NoPen
operator|&&
name|qbrush_style
argument_list|(
name|qpen_brush
argument_list|(
name|pen
argument_list|)
argument_list|)
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
block|{
name|ensurePen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
name|mode
operator||=
name|VG_STROKE_PATH
expr_stmt|;
block|}
if|if
condition|(
name|brush
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoBrush
condition|)
block|{
name|ensureBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|setFillRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|mode
operator||=
name|VG_FILL_PATH
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
literal|0
condition|)
block|{
name|ensurePathTransform
argument_list|()
expr_stmt|;
name|vgDrawPath
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|stroke
name|void
name|QVGPaintEnginePrivate
operator|::
name|stroke
parameter_list|(
name|VGPath
name|path
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
if|if
condition|(
name|pen
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoPen
condition|)
return|return;
name|ensurePen
argument_list|(
name|pen
argument_list|)
expr_stmt|;
name|ensurePathTransform
argument_list|()
expr_stmt|;
name|vgDrawPath
argument_list|(
name|path
argument_list|,
name|VG_STROKE_PATH
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fill
name|void
name|QVGPaintEnginePrivate
operator|::
name|fill
parameter_list|(
name|VGPath
name|path
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|,
name|VGint
name|rule
parameter_list|)
block|{
if|if
condition|(
name|brush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoBrush
condition|)
return|return;
name|ensureBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|setFillRule
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|QPen
name|savedPen
init|=
name|currentPen
decl_stmt|;
name|currentPen
operator|=
name|Qt
operator|::
name|NoPen
expr_stmt|;
name|ensurePathTransform
argument_list|()
expr_stmt|;
name|currentPen
operator|=
name|savedPen
expr_stmt|;
name|vgDrawPath
argument_list|(
name|path
argument_list|,
name|VG_FILL_PATH
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|begin
name|bool
name|QVGPaintEngine
operator|::
name|begin
parameter_list|(
name|QPaintDevice
modifier|*
name|pdev
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
comment|// Initialize the VG painting objects if we haven't done it yet.
if|if
condition|(
operator|!
name|d
operator|->
name|penPaint
condition|)
name|d
operator|->
name|initObjects
argument_list|()
expr_stmt|;
comment|// The initial clip region is the entire device area.
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
name|s
operator|->
name|clipRegion
operator|=
name|defaultClipRegion
argument_list|()
expr_stmt|;
comment|// Initialize the VG state for this paint operation.
name|restoreState
argument_list|(
name|QPaintEngine
operator|::
name|AllDirty
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|rawVG
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|end
name|bool
name|QVGPaintEngine
operator|::
name|end
parameter_list|()
block|{
name|vgSeti
argument_list|(
name|VG_SCISSORING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|draw
name|void
name|QVGPaintEngine
operator|::
name|draw
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|()
condition|)
block|{
name|QPaintEngineEx
operator|::
name|draw
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
name|VGPath
name|vgpath
init|=
name|d
operator|->
name|vectorPathToVGPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|hasWindingFill
argument_list|()
condition|)
name|d
operator|->
name|draw
argument_list|(
name|vgpath
argument_list|,
name|s
operator|->
name|pen
argument_list|,
name|s
operator|->
name|brush
argument_list|,
name|VG_EVEN_ODD
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|draw
argument_list|(
name|vgpath
argument_list|,
name|s
operator|->
name|pen
argument_list|,
name|s
operator|->
name|brush
argument_list|,
name|VG_NON_ZERO
argument_list|)
expr_stmt|;
name|vgDestroyPath
argument_list|(
name|vgpath
argument_list|)
expr_stmt|;
block|}
end_function
begin_function_decl
specifier|extern
name|QPainterPath
name|qt_painterPathFromVectorPath
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|fill
name|void
name|QVGPaintEngine
operator|::
name|fill
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|(
name|brush
argument_list|)
condition|)
block|{
name|QPainter
modifier|*
name|p
init|=
name|painter
argument_list|()
decl_stmt|;
name|QBrush
name|oldBrush
init|=
name|p
operator|->
name|brush
argument_list|()
decl_stmt|;
name|p
operator|->
name|setBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|qt_draw_helper
argument_list|(
name|p
operator|->
name|d_ptr
operator|.
name|data
argument_list|()
argument_list|,
name|qt_painterPathFromVectorPath
argument_list|(
name|path
argument_list|)
argument_list|,
name|QPainterPrivate
operator|::
name|FillDraw
argument_list|)
expr_stmt|;
name|p
operator|->
name|setBrush
argument_list|(
name|oldBrush
argument_list|)
expr_stmt|;
return|return;
block|}
name|VGPath
name|vgpath
init|=
name|d
operator|->
name|vectorPathToVGPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|hasWindingFill
argument_list|()
condition|)
name|d
operator|->
name|fill
argument_list|(
name|vgpath
argument_list|,
name|brush
argument_list|,
name|VG_EVEN_ODD
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|fill
argument_list|(
name|vgpath
argument_list|,
name|brush
argument_list|,
name|VG_NON_ZERO
argument_list|)
expr_stmt|;
name|vgDestroyPath
argument_list|(
name|vgpath
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stroke
name|void
name|QVGPaintEngine
operator|::
name|stroke
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
specifier|const
name|QPen
modifier|&
name|pen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|(
name|pen
operator|.
name|brush
argument_list|()
argument_list|)
condition|)
block|{
name|QPaintEngineEx
operator|::
name|stroke
argument_list|(
name|path
argument_list|,
name|pen
argument_list|)
expr_stmt|;
return|return;
block|}
name|VGPath
name|vgpath
init|=
name|d
operator|->
name|vectorPathToVGPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|d
operator|->
name|stroke
argument_list|(
name|vgpath
argument_list|,
name|pen
argument_list|)
expr_stmt|;
name|vgDestroyPath
argument_list|(
name|vgpath
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Determine if a co-ordinate transform is simple enough to allow
end_comment
begin_comment
comment|// rectangle-based clipping with vgMask().  Simple transforms most
end_comment
begin_comment
comment|// often result from origin translations.
end_comment
begin_function
DECL|function|clipTransformIsSimple
specifier|static
specifier|inline
name|bool
name|clipTransformIsSimple
parameter_list|(
specifier|const
name|QTransform
modifier|&
name|transform
parameter_list|)
block|{
name|QTransform
operator|::
name|TransformationType
name|type
init|=
name|transform
operator|.
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|QTransform
operator|::
name|TxNone
operator|||
name|type
operator|==
name|QTransform
operator|::
name|TxTranslate
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|type
operator|==
name|QTransform
operator|::
name|TxRotate
condition|)
block|{
comment|// Check for 0, 90, 180, and 270 degree rotations.
comment|// (0 might happen after 4 rotations of 90 degrees).
name|qreal
name|m11
init|=
name|transform
operator|.
name|m11
argument_list|()
decl_stmt|;
name|qreal
name|m12
init|=
name|transform
operator|.
name|m12
argument_list|()
decl_stmt|;
name|qreal
name|m21
init|=
name|transform
operator|.
name|m21
argument_list|()
decl_stmt|;
name|qreal
name|m22
init|=
name|transform
operator|.
name|m22
argument_list|()
decl_stmt|;
if|if
condition|(
name|m11
operator|==
literal|0.0f
operator|&&
name|m22
operator|==
literal|0.0f
condition|)
block|{
if|if
condition|(
name|m12
operator|==
literal|1.0f
operator|&&
name|m21
operator|==
operator|-
literal|1.0f
condition|)
return|return
literal|true
return|;
comment|// 90 degrees.
elseif|else
if|if
condition|(
name|m12
operator|==
operator|-
literal|1.0f
operator|&&
name|m21
operator|==
literal|1.0f
condition|)
return|return
literal|true
return|;
comment|// 270 degrees.
block|}
elseif|else
if|if
condition|(
name|m12
operator|==
literal|0.0f
operator|&&
name|m21
operator|==
literal|0.0f
condition|)
block|{
if|if
condition|(
name|m11
operator|==
operator|-
literal|1.0f
operator|&&
name|m22
operator|==
operator|-
literal|1.0f
condition|)
return|return
literal|true
return|;
comment|// 180 degrees.
elseif|else
if|if
condition|(
name|m11
operator|==
literal|1.0f
operator|&&
name|m22
operator|==
literal|1.0f
condition|)
return|return
literal|true
return|;
comment|// 0 degrees.
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|QVG_SCISSOR_CLIP
argument_list|)
end_if
begin_function
DECL|function|clip
name|void
name|QVGPaintEngine
operator|::
name|clip
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
name|Qt
operator|::
name|ClipOperation
name|op
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyClipRegion
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|Qt
operator|::
name|NoClip
condition|)
block|{
name|s
operator|->
name|clipRegion
operator|=
name|defaultClipRegion
argument_list|()
expr_stmt|;
name|updateScissor
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// We aren't using masking, so handle simple QRectF's only.
if|if
condition|(
name|path
operator|.
name|shape
argument_list|()
operator|==
name|QVectorPath
operator|::
name|RectangleHint
operator|&&
name|path
operator|.
name|elementCount
argument_list|()
operator|==
literal|4
operator|&&
name|clipTransformIsSimple
argument_list|(
name|d
operator|->
name|transform
argument_list|)
condition|)
block|{
comment|// Clipping region that resulted from QPainter::setClipRect(QRectF).
comment|// Convert it into a QRect and apply.
specifier|const
name|qreal
modifier|*
name|points
init|=
name|path
operator|.
name|points
argument_list|()
decl_stmt|;
name|QRectF
name|rect
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|,
name|points
index|[
literal|1
index|]
argument_list|,
name|points
index|[
literal|2
index|]
operator|-
name|points
index|[
literal|0
index|]
argument_list|,
name|points
index|[
literal|5
index|]
operator|-
name|points
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|clip
argument_list|(
name|rect
operator|.
name|toRect
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Try converting the path into a QRegion that tightly follows
comment|// the outline of the path we want to clip with.
name|QRegion
name|region
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
name|region
operator|=
name|QRegion
argument_list|(
name|path
operator|.
name|convertToPainterPath
argument_list|()
operator|.
name|toFillPolygon
argument_list|(
name|QTransform
argument_list|()
argument_list|)
operator|.
name|toPolygon
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|Qt
operator|::
name|NoClip
case|:
block|{
name|region
operator|=
name|defaultClipRegion
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|ReplaceClip
case|:
block|{
name|region
operator|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|IntersectClip
case|:
block|{
name|region
operator|=
name|s
operator|->
name|clipRegion
operator|.
name|intersect
argument_list|(
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|region
operator|.
name|numRects
argument_list|()
operator|<=
name|d
operator|->
name|maxScissorRects
condition|)
block|{
comment|// We haven't reached the maximum scissor count yet, so we can
comment|// still make use of this region.
name|s
operator|->
name|clipRegion
operator|=
name|region
expr_stmt|;
name|updateScissor
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// The best we can do is clip to the bounding rectangle
comment|// of all control points.
name|clip
argument_list|(
name|path
operator|.
name|controlPointRect
argument_list|()
operator|.
name|toRect
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clip
name|void
name|QVGPaintEngine
operator|::
name|clip
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
name|Qt
operator|::
name|ClipOperation
name|op
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyClipRegion
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|Qt
operator|::
name|NoClip
case|:
block|{
name|s
operator|->
name|clipRegion
operator|=
name|defaultClipRegion
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|ReplaceClip
case|:
block|{
name|s
operator|->
name|clipRegion
operator|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|QRegion
argument_list|(
name|rect
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|IntersectClip
case|:
block|{
name|s
operator|->
name|clipRegion
operator|=
name|s
operator|->
name|clipRegion
operator|.
name|intersect
argument_list|(
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|QRegion
argument_list|(
name|rect
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|updateScissor
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clip
name|void
name|QVGPaintEngine
operator|::
name|clip
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|,
name|Qt
operator|::
name|ClipOperation
name|op
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyClipRegion
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|Qt
operator|::
name|NoClip
case|:
block|{
name|s
operator|->
name|clipRegion
operator|=
name|defaultClipRegion
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|ReplaceClip
case|:
block|{
name|s
operator|->
name|clipRegion
operator|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|IntersectClip
case|:
block|{
name|s
operator|->
name|clipRegion
operator|=
name|s
operator|->
name|clipRegion
operator|.
name|intersect
argument_list|(
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|updateScissor
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clip
name|void
name|QVGPaintEngine
operator|::
name|clip
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|Qt
operator|::
name|ClipOperation
name|op
parameter_list|)
block|{
name|QPaintEngineEx
operator|::
name|clip
argument_list|(
name|path
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|// !QVG_SCISSOR_CLIP
end_comment
begin_function
DECL|function|clip
name|void
name|QVGPaintEngine
operator|::
name|clip
parameter_list|(
specifier|const
name|QVectorPath
modifier|&
name|path
parameter_list|,
name|Qt
operator|::
name|ClipOperation
name|op
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyClipRegion
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|Qt
operator|::
name|NoClip
condition|)
block|{
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// We don't have vgRenderToMask(), so handle simple QRectF's only.
if|if
condition|(
name|path
operator|.
name|shape
argument_list|()
operator|==
name|QVectorPath
operator|::
name|RectangleHint
operator|&&
name|path
operator|.
name|elementCount
argument_list|()
operator|==
literal|4
operator|&&
name|clipTransformIsSimple
argument_list|(
name|d
operator|->
name|transform
argument_list|)
condition|)
block|{
comment|// Clipping region that resulted from QPainter::setClipRect(QRectF).
comment|// Convert it into a QRect and apply.
specifier|const
name|qreal
modifier|*
name|points
init|=
name|path
operator|.
name|points
argument_list|()
decl_stmt|;
name|QRectF
name|rect
argument_list|(
name|points
index|[
literal|0
index|]
argument_list|,
name|points
index|[
literal|1
index|]
argument_list|,
name|points
index|[
literal|2
index|]
operator|-
name|points
index|[
literal|0
index|]
argument_list|,
name|points
index|[
literal|5
index|]
operator|-
name|points
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|clip
argument_list|(
name|rect
operator|.
name|toRect
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_RENDER_TO_MASK
argument_list|)
name|QPaintDevice
modifier|*
name|pdev
init|=
name|paintDevice
argument_list|()
decl_stmt|;
name|int
name|width
init|=
name|pdev
operator|->
name|width
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|pdev
operator|->
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|Qt
operator|::
name|ReplaceClip
condition|)
block|{
name|vgMask
argument_list|(
name|VG_INVALID_HANDLE
argument_list|,
name|VG_CLEAR_MASK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|maskValid
condition|)
block|{
name|d
operator|->
name|ensureMask
argument_list|(
name|this
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|ensurePathTransform
argument_list|()
expr_stmt|;
name|VGPath
name|vgpath
init|=
name|d
operator|->
name|vectorPathToVGPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|Qt
operator|::
name|ReplaceClip
case|:
case|case
name|Qt
operator|::
name|IntersectClip
case|:
name|vgRenderToMask
argument_list|(
name|vgpath
argument_list|,
name|VG_FILL_PATH
argument_list|,
name|VG_INTERSECT_MASK
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|vgDestroyPath
argument_list|(
name|vgpath
argument_list|)
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_TRUE
argument_list|)
expr_stmt|;
name|d
operator|->
name|maskValid
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|clip
name|void
name|QVGPaintEngine
operator|::
name|clip
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
name|Qt
operator|::
name|ClipOperation
name|op
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyClipRegion
expr_stmt|;
comment|// If we have a non-simple transform, then use path-based clipping.
if|if
condition|(
name|op
operator|!=
name|Qt
operator|::
name|NoClip
operator|&&
operator|!
name|clipTransformIsSimple
argument_list|(
name|d
operator|->
name|transform
argument_list|)
condition|)
block|{
name|QPaintEngineEx
operator|::
name|clip
argument_list|(
name|rect
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|Qt
operator|::
name|NoClip
case|:
block|{
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|ReplaceClip
case|:
block|{
name|QRect
name|r
init|=
name|d
operator|->
name|transform
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
decl_stmt|;
if|if
condition|(
name|isDefaultClipRect
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// Replacing the clip with a full-window region is the
comment|// same as turning off clipping.
if|if
condition|(
name|d
operator|->
name|maskValid
condition|)
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Special case: if the intersection of the system
comment|// clip and "r" is a single rectangle, then use the
comment|// scissor for clipping.  We try to avoid allocating a
comment|// QRegion copy on the heap for the test if we can.
name|QRegion
name|clip
init|=
name|d
operator|->
name|systemClip
decl_stmt|;
comment|// Reference-counted, no alloc.
name|QRect
name|clipRect
decl_stmt|;
if|if
condition|(
name|clip
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|clipRect
operator|=
name|clip
operator|.
name|boundingRect
argument_list|()
operator|.
name|intersected
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clip
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|clipRect
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
name|clip
operator|=
name|clip
operator|.
name|intersect
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|clip
operator|.
name|rectCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|d
operator|->
name|modifyMask
argument_list|(
name|this
argument_list|,
name|VG_FILL_MASK
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
name|clipRect
operator|=
name|clip
operator|.
name|boundingRect
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|clipRect
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|updateScissor
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Qt
operator|::
name|IntersectClip
case|:
block|{
name|QRect
name|r
init|=
name|d
operator|->
name|transform
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|maskValid
condition|)
block|{
comment|// Mask has not been used yet, so intersect with
comment|// the previous scissor-based region in maskRect.
if|if
condition|(
name|d
operator|->
name|scissorMask
condition|)
name|r
operator|=
name|r
operator|.
name|intersect
argument_list|(
name|d
operator|->
name|maskRect
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDefaultClipRect
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// The clip is the full window, so turn off clipping.
name|d
operator|->
name|maskIsSet
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Activate the scissor on a smaller maskRect.
name|d
operator|->
name|maskIsSet
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|r
expr_stmt|;
block|}
name|d
operator|->
name|scissorMask
operator|=
literal|true
expr_stmt|;
name|updateScissor
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|maskIsSet
operator|&&
name|isDefaultClipRect
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// Intersecting a full-window clip with a full-window
comment|// region is the same as turning off clipping.
if|if
condition|(
name|d
operator|->
name|maskValid
condition|)
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|modifyMask
argument_list|(
name|this
argument_list|,
name|VG_INTERSECT_MASK
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_function
begin_function
DECL|function|clip
name|void
name|QVGPaintEngine
operator|::
name|clip
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|,
name|Qt
operator|::
name|ClipOperation
name|op
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
comment|// Use the QRect case if the region consists of a single rectangle.
if|if
condition|(
name|region
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|clip
argument_list|(
name|region
operator|.
name|boundingRect
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyClipRegion
expr_stmt|;
comment|// If we have a non-simple transform, then use path-based clipping.
if|if
condition|(
name|op
operator|!=
name|Qt
operator|::
name|NoClip
operator|&&
operator|!
name|clipTransformIsSimple
argument_list|(
name|d
operator|->
name|transform
argument_list|)
condition|)
block|{
name|QPaintEngineEx
operator|::
name|clip
argument_list|(
name|region
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|Qt
operator|::
name|NoClip
case|:
block|{
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Qt
operator|::
name|ReplaceClip
case|:
block|{
name|QRegion
name|r
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|region
argument_list|)
decl_stmt|;
if|if
condition|(
name|isDefaultClipRegion
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// Replacing the clip with a full-window region is the
comment|// same as turning off clipping.
if|if
condition|(
name|d
operator|->
name|maskValid
condition|)
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Special case: if the intersection of the system
comment|// clip and the region is a single rectangle, then
comment|// use the scissor for clipping.
name|QRegion
name|clip
init|=
name|d
operator|->
name|systemClip
decl_stmt|;
if|if
condition|(
name|clip
operator|.
name|isEmpty
argument_list|()
condition|)
name|clip
operator|=
name|r
expr_stmt|;
else|else
name|clip
operator|=
name|clip
operator|.
name|intersect
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|clip
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|clip
operator|.
name|boundingRect
argument_list|()
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|updateScissor
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|d
operator|->
name|modifyMask
argument_list|(
name|this
argument_list|,
name|VG_FILL_MASK
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|Qt
operator|::
name|IntersectClip
case|:
block|{
if|if
condition|(
name|region
operator|.
name|rectCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
comment|// If there is more than one rectangle, then intersecting
comment|// the rectangles one by one in modifyMask() will not give
comment|// the desired result.  So fall back to path-based clipping.
name|QPaintEngineEx
operator|::
name|clip
argument_list|(
name|region
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
name|QRegion
name|r
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|region
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|maskIsSet
operator|&&
name|isDefaultClipRegion
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|// Intersecting a full-window clip with a full-window
comment|// region is the same as turning off clipping.
if|if
condition|(
name|d
operator|->
name|maskValid
condition|)
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|modifyMask
argument_list|(
name|this
argument_list|,
name|VG_INTERSECT_MASK
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_RENDER_TO_MASK
argument_list|)
end_if
begin_comment
comment|// Copied from qpathclipper.cpp.
end_comment
begin_function
DECL|function|qt_vg_pathToRect
specifier|static
name|bool
name|qt_vg_pathToRect
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|QRectF
modifier|*
name|rect
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|elementCount
argument_list|()
operator|!=
literal|5
condition|)
return|return
literal|false
return|;
specifier|const
name|bool
name|mightBeRect
init|=
name|path
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
operator|.
name|isMoveTo
argument_list|()
operator|&&
name|path
operator|.
name|elementAt
argument_list|(
literal|1
argument_list|)
operator|.
name|isLineTo
argument_list|()
operator|&&
name|path
operator|.
name|elementAt
argument_list|(
literal|2
argument_list|)
operator|.
name|isLineTo
argument_list|()
operator|&&
name|path
operator|.
name|elementAt
argument_list|(
literal|3
argument_list|)
operator|.
name|isLineTo
argument_list|()
operator|&&
name|path
operator|.
name|elementAt
argument_list|(
literal|4
argument_list|)
operator|.
name|isLineTo
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|mightBeRect
condition|)
return|return
literal|false
return|;
specifier|const
name|qreal
name|x1
init|=
name|path
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
operator|.
name|x
decl_stmt|;
specifier|const
name|qreal
name|y1
init|=
name|path
operator|.
name|elementAt
argument_list|(
literal|0
argument_list|)
operator|.
name|y
decl_stmt|;
specifier|const
name|qreal
name|x2
init|=
name|path
operator|.
name|elementAt
argument_list|(
literal|1
argument_list|)
operator|.
name|x
decl_stmt|;
specifier|const
name|qreal
name|y2
init|=
name|path
operator|.
name|elementAt
argument_list|(
literal|2
argument_list|)
operator|.
name|y
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|elementAt
argument_list|(
literal|1
argument_list|)
operator|.
name|y
operator|!=
name|y1
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|path
operator|.
name|elementAt
argument_list|(
literal|2
argument_list|)
operator|.
name|x
operator|!=
name|x2
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|path
operator|.
name|elementAt
argument_list|(
literal|3
argument_list|)
operator|.
name|x
operator|!=
name|x1
operator|||
name|path
operator|.
name|elementAt
argument_list|(
literal|3
argument_list|)
operator|.
name|y
operator|!=
name|y2
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|path
operator|.
name|elementAt
argument_list|(
literal|4
argument_list|)
operator|.
name|x
operator|!=
name|x1
operator|||
name|path
operator|.
name|elementAt
argument_list|(
literal|4
argument_list|)
operator|.
name|y
operator|!=
name|y1
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|rect
condition|)
operator|*
name|rect
operator|=
name|QRectF
argument_list|(
name|QPointF
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
argument_list|,
name|QPointF
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|clip
name|void
name|QVGPaintEngine
operator|::
name|clip
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|,
name|Qt
operator|::
name|ClipOperation
name|op
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_RENDER_TO_MASK
argument_list|)
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
comment|// If the path is a simple rectangle, then use clip(QRect) instead.
name|QRectF
name|simpleRect
decl_stmt|;
if|if
condition|(
name|qt_vg_pathToRect
argument_list|(
name|path
argument_list|,
operator|&
name|simpleRect
argument_list|)
condition|)
block|{
name|clip
argument_list|(
name|simpleRect
operator|.
name|toRect
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyClipRegion
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|Qt
operator|::
name|NoClip
condition|)
block|{
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
name|QPaintDevice
modifier|*
name|pdev
init|=
name|paintDevice
argument_list|()
decl_stmt|;
name|int
name|width
init|=
name|pdev
operator|->
name|width
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|pdev
operator|->
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|Qt
operator|::
name|ReplaceClip
condition|)
block|{
name|vgMask
argument_list|(
name|VG_INVALID_HANDLE
argument_list|,
name|VG_CLEAR_MASK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|maskValid
condition|)
block|{
name|d
operator|->
name|ensureMask
argument_list|(
name|this
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|ensurePathTransform
argument_list|()
expr_stmt|;
name|VGPath
name|vgpath
init|=
name|d
operator|->
name|painterPathToVGPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|Qt
operator|::
name|ReplaceClip
case|:
case|case
name|Qt
operator|::
name|IntersectClip
case|:
name|vgRenderToMask
argument_list|(
name|vgpath
argument_list|,
name|VG_FILL_PATH
argument_list|,
name|VG_INTERSECT_MASK
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|vgDestroyPath
argument_list|(
name|vgpath
argument_list|)
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_TRUE
argument_list|)
expr_stmt|;
name|d
operator|->
name|maskValid
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
else|#
directive|else
name|QPaintEngineEx
operator|::
name|clip
argument_list|(
name|path
argument_list|,
name|op
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|ensureMask
name|void
name|QVGPaintEnginePrivate
operator|::
name|ensureMask
parameter_list|(
name|QVGPaintEngine
modifier|*
name|engine
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|scissorMask
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|maskIsSet
condition|)
block|{
name|vgMask
argument_list|(
name|VG_INVALID_HANDLE
argument_list|,
name|VG_FILL_MASK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|vgMask
argument_list|(
name|VG_INVALID_HANDLE
argument_list|,
name|VG_CLEAR_MASK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|maskRect
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|vgMask
argument_list|(
name|VG_INVALID_HANDLE
argument_list|,
name|VG_FILL_MASK
argument_list|,
name|maskRect
operator|.
name|x
argument_list|()
argument_list|,
name|height
operator|-
name|maskRect
operator|.
name|y
argument_list|()
operator|-
name|maskRect
operator|.
name|height
argument_list|()
argument_list|,
name|maskRect
operator|.
name|width
argument_list|()
argument_list|,
name|maskRect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|engine
operator|->
name|updateScissor
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|modifyMask
name|void
name|QVGPaintEnginePrivate
operator|::
name|modifyMask
parameter_list|(
name|QVGPaintEngine
modifier|*
name|engine
parameter_list|,
name|VGMaskOperation
name|op
parameter_list|,
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|QPaintDevice
modifier|*
name|pdev
init|=
name|engine
operator|->
name|paintDevice
argument_list|()
decl_stmt|;
name|int
name|width
init|=
name|pdev
operator|->
name|width
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|pdev
operator|->
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|maskValid
condition|)
name|ensureMask
argument_list|(
name|engine
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|vgMask
argument_list|(
name|VG_INVALID_HANDLE
argument_list|,
name|op
argument_list|,
name|rects
index|[
name|i
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|height
operator|-
name|rects
index|[
name|i
index|]
operator|.
name|y
argument_list|()
operator|-
name|rects
index|[
name|i
index|]
operator|.
name|height
argument_list|()
argument_list|,
name|rects
index|[
name|i
index|]
operator|.
name|width
argument_list|()
argument_list|,
name|rects
index|[
name|i
index|]
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_TRUE
argument_list|)
expr_stmt|;
name|maskValid
operator|=
literal|true
expr_stmt|;
name|maskIsSet
operator|=
literal|false
expr_stmt|;
name|scissorMask
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_function
DECL|function|modifyMask
name|void
name|QVGPaintEnginePrivate
operator|::
name|modifyMask
parameter_list|(
name|QVGPaintEngine
modifier|*
name|engine
parameter_list|,
name|VGMaskOperation
name|op
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|QPaintDevice
modifier|*
name|pdev
init|=
name|engine
operator|->
name|paintDevice
argument_list|()
decl_stmt|;
name|int
name|width
init|=
name|pdev
operator|->
name|width
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|pdev
operator|->
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|maskValid
condition|)
name|ensureMask
argument_list|(
name|engine
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|rect
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|vgMask
argument_list|(
name|VG_INVALID_HANDLE
argument_list|,
name|op
argument_list|,
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|height
operator|-
name|rect
operator|.
name|y
argument_list|()
operator|-
name|rect
operator|.
name|height
argument_list|()
argument_list|,
name|rect
operator|.
name|width
argument_list|()
argument_list|,
name|rect
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_TRUE
argument_list|)
expr_stmt|;
name|maskValid
operator|=
literal|true
expr_stmt|;
name|maskIsSet
operator|=
literal|false
expr_stmt|;
name|scissorMask
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QVG_SCISSOR_CLIP
end_comment
begin_function
DECL|function|updateScissor
name|void
name|QVGPaintEngine
operator|::
name|updateScissor
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|QRegion
name|region
init|=
name|d
operator|->
name|systemClip
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QVG_SCISSOR_CLIP
argument_list|)
comment|// Using the scissor to do clipping, so combine the systemClip
comment|// with the current painting clipRegion.
if|if
condition|(
name|d
operator|->
name|maskValid
condition|)
block|{
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
block|}
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|clipEnabled
condition|)
block|{
if|if
condition|(
name|region
operator|.
name|isEmpty
argument_list|()
condition|)
name|region
operator|=
name|s
operator|->
name|clipRegion
expr_stmt|;
else|else
name|region
operator|=
name|region
operator|.
name|intersect
argument_list|(
name|s
operator|->
name|clipRegion
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDefaultClipRegion
argument_list|(
name|region
argument_list|)
condition|)
block|{
comment|// The scissor region is the entire drawing surface,
comment|// so there is no point doing any scissoring.
name|vgSeti
argument_list|(
name|VG_SCISSORING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|d
operator|->
name|scissorActive
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorDirty
operator|=
literal|false
expr_stmt|;
return|return;
block|}
block|}
else|else
endif|#
directive|endif
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_SCISSOR_CLIP
argument_list|)
comment|// Combine the system clip with the simple mask rectangle.
if|if
condition|(
name|d
operator|->
name|scissorMask
condition|)
block|{
if|if
condition|(
name|region
operator|.
name|isEmpty
argument_list|()
condition|)
name|region
operator|=
name|d
operator|->
name|maskRect
expr_stmt|;
else|else
name|region
operator|=
name|region
operator|.
name|intersect
argument_list|(
name|d
operator|->
name|maskRect
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDefaultClipRegion
argument_list|(
name|region
argument_list|)
condition|)
block|{
comment|// The scissor region is the entire drawing surface,
comment|// so there is no point doing any scissoring.
name|vgSeti
argument_list|(
name|VG_SCISSORING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|d
operator|->
name|scissorActive
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorDirty
operator|=
literal|false
expr_stmt|;
return|return;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|// Disable the scissor completely if the system clip is empty.
if|if
condition|(
name|region
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|vgSeti
argument_list|(
name|VG_SCISSORING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|d
operator|->
name|scissorActive
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorDirty
operator|=
literal|false
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|scissorActive
operator|&&
name|region
operator|==
name|d
operator|->
name|scissorRegion
operator|&&
operator|!
name|d
operator|->
name|scissorDirty
condition|)
return|return;
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|rects
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>
name|d
operator|->
name|maxScissorRects
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_SCISSOR_CLIP
argument_list|)
name|count
operator|=
name|d
operator|->
name|maxScissorRects
expr_stmt|;
else|#
directive|else
comment|// Use masking
name|int
name|width
init|=
name|paintDevice
argument_list|()
operator|->
name|width
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|paintDevice
argument_list|()
operator|->
name|height
argument_list|()
decl_stmt|;
name|vgMask
argument_list|(
name|VG_INVALID_HANDLE
argument_list|,
name|VG_CLEAR_MASK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|vgMask
argument_list|(
name|VG_INVALID_HANDLE
argument_list|,
name|VG_FILL_MASK
argument_list|,
name|rects
index|[
name|i
index|]
operator|.
name|x
argument_list|()
argument_list|,
name|height
operator|-
name|rects
index|[
name|i
index|]
operator|.
name|y
argument_list|()
operator|-
name|rects
index|[
name|i
index|]
operator|.
name|height
argument_list|()
argument_list|,
name|rects
index|[
name|i
index|]
operator|.
name|width
argument_list|()
argument_list|,
name|rects
index|[
name|i
index|]
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|vgSeti
argument_list|(
name|VG_SCISSORING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_TRUE
argument_list|)
expr_stmt|;
name|d
operator|->
name|maskValid
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorActive
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorDirty
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorRegion
operator|=
name|region
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
name|QVarLengthArray
argument_list|<
name|VGint
argument_list|>
name|params
argument_list|(
name|count
operator|*
literal|4
argument_list|)
decl_stmt|;
name|int
name|height
init|=
name|paintDevice
argument_list|()
operator|->
name|height
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
operator|*
literal|4
operator|+
literal|0
index|]
operator|=
name|rects
index|[
name|i
index|]
operator|.
name|x
argument_list|()
expr_stmt|;
name|params
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|=
name|height
operator|-
name|rects
index|[
name|i
index|]
operator|.
name|y
argument_list|()
operator|-
name|rects
index|[
name|i
index|]
operator|.
name|height
argument_list|()
expr_stmt|;
name|params
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|=
name|rects
index|[
name|i
index|]
operator|.
name|width
argument_list|()
expr_stmt|;
name|params
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
operator|=
name|rects
index|[
name|i
index|]
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
name|vgSetiv
argument_list|(
name|VG_SCISSOR_RECTS
argument_list|,
name|count
operator|*
literal|4
argument_list|,
name|params
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_SCISSORING
argument_list|,
name|VG_TRUE
argument_list|)
expr_stmt|;
name|d
operator|->
name|scissorDirty
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorActive
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|scissorRegion
operator|=
name|region
expr_stmt|;
block|}
end_function
begin_function
DECL|function|defaultClipRegion
name|QRegion
name|QVGPaintEngine
operator|::
name|defaultClipRegion
parameter_list|()
block|{
comment|// The default clip region for a paint device is the whole drawing area.
name|QPaintDevice
modifier|*
name|pdev
init|=
name|paintDevice
argument_list|()
decl_stmt|;
return|return
name|QRegion
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|pdev
operator|->
name|width
argument_list|()
argument_list|,
name|pdev
operator|->
name|height
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isDefaultClipRegion
name|bool
name|QVGPaintEngine
operator|::
name|isDefaultClipRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
if|if
condition|(
name|region
operator|.
name|rectCount
argument_list|()
operator|!=
literal|1
condition|)
return|return
literal|false
return|;
name|QPaintDevice
modifier|*
name|pdev
init|=
name|paintDevice
argument_list|()
decl_stmt|;
name|int
name|width
init|=
name|pdev
operator|->
name|width
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|pdev
operator|->
name|height
argument_list|()
decl_stmt|;
name|QRect
name|rect
init|=
name|region
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
return|return
operator|(
name|rect
operator|.
name|x
argument_list|()
operator|==
literal|0
operator|&&
name|rect
operator|.
name|y
argument_list|()
operator|==
literal|0
operator|&&
name|rect
operator|.
name|width
argument_list|()
operator|==
name|width
operator|&&
name|rect
operator|.
name|height
argument_list|()
operator|==
name|height
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isDefaultClipRect
name|bool
name|QVGPaintEngine
operator|::
name|isDefaultClipRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|)
block|{
name|QPaintDevice
modifier|*
name|pdev
init|=
name|paintDevice
argument_list|()
decl_stmt|;
name|int
name|width
init|=
name|pdev
operator|->
name|width
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|pdev
operator|->
name|height
argument_list|()
decl_stmt|;
return|return
operator|(
name|rect
operator|.
name|x
argument_list|()
operator|==
literal|0
operator|&&
name|rect
operator|.
name|y
argument_list|()
operator|==
literal|0
operator|&&
name|rect
operator|.
name|width
argument_list|()
operator|==
name|width
operator|&&
name|rect
operator|.
name|height
argument_list|()
operator|==
name|height
operator|)
return|;
block|}
end_function
begin_function
DECL|function|clipEnabledChanged
name|void
name|QVGPaintEngine
operator|::
name|clipEnabledChanged
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QVG_SCISSOR_CLIP
argument_list|)
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
comment|// disable mask fallback
name|updateScissor
argument_list|()
expr_stmt|;
else|#
directive|else
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyClipEnabled
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|clipEnabled
operator|&&
name|s
operator|->
name|clipOperation
operator|!=
name|Qt
operator|::
name|NoClip
condition|)
block|{
comment|// Replay the entire clip stack to put the mask into the right state.
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|s
operator|->
name|clipRegion
operator|=
name|defaultClipRegion
argument_list|()
expr_stmt|;
name|d
operator|->
name|replayClipOperations
argument_list|()
expr_stmt|;
name|d
operator|->
name|transform
operator|=
name|s
operator|->
name|transform
argument_list|()
expr_stmt|;
name|d
operator|->
name|updateTransform
argument_list|(
name|paintDevice
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|penChanged
name|void
name|QVGPaintEngine
operator|::
name|penChanged
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyPen
expr_stmt|;
name|d
operator|->
name|hasExtendedRadialGradientPen
operator|=
name|state
argument_list|()
operator|->
name|pen
operator|.
name|style
argument_list|()
operator|!=
name|Qt
operator|::
name|NoPen
operator|&&
name|d
operator|->
name|needsEmulation
argument_list|(
name|state
argument_list|()
operator|->
name|pen
operator|.
name|brush
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|brushChanged
name|void
name|QVGPaintEngine
operator|::
name|brushChanged
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyBrush
expr_stmt|;
name|d
operator|->
name|hasExtendedRadialGradientPen
operator|=
name|d
operator|->
name|needsEmulation
argument_list|(
name|state
argument_list|()
operator|->
name|brush
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|brushOriginChanged
name|void
name|QVGPaintEngine
operator|::
name|brushOriginChanged
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyBrushOrigin
expr_stmt|;
name|d
operator|->
name|brushOrigin
operator|=
name|state
argument_list|()
operator|->
name|brushOrigin
expr_stmt|;
name|d
operator|->
name|forcePenChange
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|forceBrushChange
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|opacityChanged
name|void
name|QVGPaintEngine
operator|::
name|opacityChanged
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyOpacity
expr_stmt|;
name|d
operator|->
name|opacity
operator|=
name|state
argument_list|()
operator|->
name|opacity
expr_stmt|;
name|d
operator|->
name|forcePenChange
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|forceBrushChange
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|compositionModeChanged
name|void
name|QVGPaintEngine
operator|::
name|compositionModeChanged
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyCompositionMode
expr_stmt|;
name|VGint
name|vgMode
init|=
name|VG_BLEND_SRC_OVER
decl_stmt|;
switch|switch
condition|(
name|state
argument_list|()
operator|->
name|composition_mode
condition|)
block|{
case|case
name|QPainter
operator|::
name|CompositionMode_SourceOver
case|:
name|vgMode
operator|=
name|VG_BLEND_SRC_OVER
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_DestinationOver
case|:
name|vgMode
operator|=
name|VG_BLEND_DST_OVER
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Source
case|:
name|vgMode
operator|=
name|VG_BLEND_SRC
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_SourceIn
case|:
name|vgMode
operator|=
name|VG_BLEND_SRC_IN
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_DestinationIn
case|:
name|vgMode
operator|=
name|VG_BLEND_DST_IN
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Plus
case|:
name|vgMode
operator|=
name|VG_BLEND_ADDITIVE
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Multiply
case|:
name|vgMode
operator|=
name|VG_BLEND_MULTIPLY
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Screen
case|:
name|vgMode
operator|=
name|VG_BLEND_SCREEN
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Darken
case|:
name|vgMode
operator|=
name|VG_BLEND_DARKEN
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Lighten
case|:
name|vgMode
operator|=
name|VG_BLEND_LIGHTEN
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|d
operator|->
name|hasAdvancedBlending
condition|)
block|{
switch|switch
condition|(
name|state
argument_list|()
operator|->
name|composition_mode
condition|)
block|{
case|case
name|QPainter
operator|::
name|CompositionMode_Overlay
case|:
name|vgMode
operator|=
name|QVGPaintEnginePrivate
operator|::
name|QT_VG_BLEND_OVERLAY_KHR
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_ColorDodge
case|:
name|vgMode
operator|=
name|QVGPaintEnginePrivate
operator|::
name|QT_VG_BLEND_COLORDODGE_KHR
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_ColorBurn
case|:
name|vgMode
operator|=
name|QVGPaintEnginePrivate
operator|::
name|QT_VG_BLEND_COLORBURN_KHR
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_HardLight
case|:
name|vgMode
operator|=
name|QVGPaintEnginePrivate
operator|::
name|QT_VG_BLEND_HARDLIGHT_KHR
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_SoftLight
case|:
name|vgMode
operator|=
name|QVGPaintEnginePrivate
operator|::
name|QT_VG_BLEND_SOFTLIGHT_KHR
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Difference
case|:
name|vgMode
operator|=
name|QVGPaintEnginePrivate
operator|::
name|QT_VG_BLEND_DIFFERENCE_KHR
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Exclusion
case|:
name|vgMode
operator|=
name|QVGPaintEnginePrivate
operator|::
name|QT_VG_BLEND_EXCLUSION_KHR
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_SourceOut
case|:
name|vgMode
operator|=
name|QVGPaintEnginePrivate
operator|::
name|QT_VG_BLEND_SRC_OUT_KHR
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_DestinationOut
case|:
name|vgMode
operator|=
name|QVGPaintEnginePrivate
operator|::
name|QT_VG_BLEND_DST_OUT_KHR
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_SourceAtop
case|:
name|vgMode
operator|=
name|QVGPaintEnginePrivate
operator|::
name|QT_VG_BLEND_SRC_ATOP_KHR
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_DestinationAtop
case|:
name|vgMode
operator|=
name|QVGPaintEnginePrivate
operator|::
name|QT_VG_BLEND_DST_ATOP_KHR
expr_stmt|;
break|break;
case|case
name|QPainter
operator|::
name|CompositionMode_Xor
case|:
name|vgMode
operator|=
name|QVGPaintEnginePrivate
operator|::
name|QT_VG_BLEND_XOR_KHR
expr_stmt|;
break|break;
default|default:
break|break;
comment|// Fall back to VG_BLEND_SRC_OVER.
block|}
block|}
if|if
condition|(
name|vgMode
operator|==
name|VG_BLEND_SRC_OVER
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QVGPaintEngine::compositionModeChanged unsupported mode"
operator|<<
name|state
argument_list|()
operator|->
name|composition_mode
expr_stmt|;
break|break;
block|}
name|d
operator|->
name|setBlendMode
argument_list|(
name|VGBlendMode
argument_list|(
name|vgMode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|renderHintsChanged
name|void
name|QVGPaintEngine
operator|::
name|renderHintsChanged
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyHints
expr_stmt|;
name|QPainter
operator|::
name|RenderHints
name|hints
init|=
name|state
argument_list|()
operator|->
name|renderHints
decl_stmt|;
name|VGRenderingQuality
name|rq
init|=
operator|(
name|hints
operator|&
name|QPainter
operator|::
name|Antialiasing
operator|)
condition|?
name|VG_RENDERING_QUALITY_BETTER
else|:
name|VG_RENDERING_QUALITY_NONANTIALIASED
decl_stmt|;
name|VGImageQuality
name|iq
init|=
operator|(
name|hints
operator|&
name|QPainter
operator|::
name|SmoothPixmapTransform
operator|)
condition|?
name|VG_IMAGE_QUALITY_BETTER
else|:
name|VG_IMAGE_QUALITY_NONANTIALIASED
decl_stmt|;
name|d
operator|->
name|setRenderingQuality
argument_list|(
name|rq
argument_list|)
expr_stmt|;
name|d
operator|->
name|setImageQuality
argument_list|(
name|iq
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|transformChanged
name|void
name|QVGPaintEngine
operator|::
name|transformChanged
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
name|d
operator|->
name|dirty
operator||=
name|QPaintEngine
operator|::
name|DirtyTransform
expr_stmt|;
name|d
operator|->
name|transform
operator|=
name|s
operator|->
name|transform
argument_list|()
expr_stmt|;
name|qreal
name|oldPenScale
init|=
name|d
operator|->
name|penScale
decl_stmt|;
name|d
operator|->
name|updateTransform
argument_list|(
name|paintDevice
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|penScale
operator|!=
name|oldPenScale
condition|)
name|d
operator|->
name|forcePenChange
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clearRect
name|bool
name|QVGPaintEngine
operator|::
name|clearRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|clipEnabled
operator|||
name|s
operator|->
name|clipOperation
operator|==
name|Qt
operator|::
name|NoClip
condition|)
block|{
name|QRect
name|r
init|=
name|d
operator|->
name|transform
operator|.
name|mapRect
argument_list|(
name|rect
argument_list|)
operator|.
name|toRect
argument_list|()
decl_stmt|;
name|int
name|height
init|=
name|paintDevice
argument_list|()
operator|->
name|height
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|clearColor
operator|!=
name|color
operator|||
name|d
operator|->
name|clearOpacity
operator|!=
name|s
operator|->
name|opacity
condition|)
block|{
name|VGfloat
name|values
index|[
literal|4
index|]
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
name|color
operator|.
name|redF
argument_list|()
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
name|color
operator|.
name|greenF
argument_list|()
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
name|color
operator|.
name|blueF
argument_list|()
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|color
operator|.
name|alphaF
argument_list|()
operator|*
name|s
operator|->
name|opacity
expr_stmt|;
name|vgSetfv
argument_list|(
name|VG_CLEAR_COLOR
argument_list|,
literal|4
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|d
operator|->
name|clearColor
operator|=
name|color
expr_stmt|;
name|d
operator|->
name|clearOpacity
operator|=
name|s
operator|->
name|opacity
expr_stmt|;
block|}
name|vgClear
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|height
operator|-
name|r
operator|.
name|y
argument_list|()
operator|-
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|fillRect
name|void
name|QVGPaintEngine
operator|::
name|fillRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|brush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoBrush
condition|)
return|return;
comment|// Check to see if we can use vgClear() for faster filling.
if|if
condition|(
name|brush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|SolidPattern
operator|&&
name|brush
operator|.
name|isOpaque
argument_list|()
operator|&&
name|clipTransformIsSimple
argument_list|(
name|d
operator|->
name|transform
argument_list|)
operator|&&
name|d
operator|->
name|opacity
operator|==
literal|1.0f
operator|&&
name|clearRect
argument_list|(
name|rect
argument_list|,
name|brush
operator|.
name|color
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|(
name|brush
argument_list|)
condition|)
block|{
name|QPaintEngineEx
operator|::
name|fillRect
argument_list|(
name|rect
argument_list|,
name|brush
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
name|VGfloat
name|coords
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|coords
index|[
literal|0
index|]
operator|=
name|rect
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|rect
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|coords
index|[
literal|1
index|]
expr_stmt|;
name|coords
index|[
literal|4
index|]
operator|=
name|coords
index|[
literal|2
index|]
expr_stmt|;
name|coords
index|[
literal|5
index|]
operator|=
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
expr_stmt|;
name|coords
index|[
literal|6
index|]
operator|=
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|coords
index|[
literal|7
index|]
operator|=
name|coords
index|[
literal|5
index|]
expr_stmt|;
block|}
else|else
block|{
name|QPointF
name|tl
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|rect
operator|.
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|tr
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|rect
operator|.
name|topRight
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|bl
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|rect
operator|.
name|bottomLeft
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|br
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|rect
operator|.
name|bottomRight
argument_list|()
argument_list|)
decl_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
name|tl
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|tl
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|tr
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|tr
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|4
index|]
operator|=
name|br
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|5
index|]
operator|=
name|br
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|6
index|]
operator|=
name|bl
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|7
index|]
operator|=
name|bl
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
name|vgModifyPathCoords
argument_list|(
name|d
operator|->
name|rectPath
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|coords
argument_list|)
expr_stmt|;
name|d
operator|->
name|fill
argument_list|(
name|d
operator|->
name|rectPath
argument_list|,
name|brush
argument_list|)
expr_stmt|;
else|#
directive|else
name|QPaintEngineEx
operator|::
name|fillRect
argument_list|(
name|rect
argument_list|,
name|brush
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|fillRect
name|void
name|QVGPaintEngine
operator|::
name|fillRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
comment|// Check to see if we can use vgClear() for faster filling.
if|if
condition|(
name|clipTransformIsSimple
argument_list|(
name|d
operator|->
name|transform
argument_list|)
operator|&&
name|d
operator|->
name|opacity
operator|==
literal|1.0f
operator|&&
name|color
operator|.
name|alpha
argument_list|()
operator|==
literal|255
operator|&&
name|clearRect
argument_list|(
name|rect
argument_list|,
name|color
argument_list|)
condition|)
block|{
return|return;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
name|VGfloat
name|coords
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|coords
index|[
literal|0
index|]
operator|=
name|rect
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|rect
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|coords
index|[
literal|1
index|]
expr_stmt|;
name|coords
index|[
literal|4
index|]
operator|=
name|coords
index|[
literal|2
index|]
expr_stmt|;
name|coords
index|[
literal|5
index|]
operator|=
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
expr_stmt|;
name|coords
index|[
literal|6
index|]
operator|=
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|coords
index|[
literal|7
index|]
operator|=
name|coords
index|[
literal|5
index|]
expr_stmt|;
block|}
else|else
block|{
name|QPointF
name|tl
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|rect
operator|.
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|tr
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|rect
operator|.
name|topRight
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|bl
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|rect
operator|.
name|bottomLeft
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|br
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|rect
operator|.
name|bottomRight
argument_list|()
argument_list|)
decl_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
name|tl
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|tl
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|tr
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|tr
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|4
index|]
operator|=
name|br
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|5
index|]
operator|=
name|br
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|6
index|]
operator|=
name|bl
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|7
index|]
operator|=
name|bl
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
name|vgModifyPathCoords
argument_list|(
name|d
operator|->
name|rectPath
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|coords
argument_list|)
expr_stmt|;
name|d
operator|->
name|fill
argument_list|(
name|d
operator|->
name|rectPath
argument_list|,
name|QBrush
argument_list|(
name|color
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|QPaintEngineEx
operator|::
name|fillRect
argument_list|(
name|rect
argument_list|,
name|QBrush
argument_list|(
name|color
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|drawRoundedRect
name|void
name|QVGPaintEngine
operator|::
name|drawRoundedRect
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|rect
parameter_list|,
name|qreal
name|xrad
parameter_list|,
name|qreal
name|yrad
parameter_list|,
name|Qt
operator|::
name|SizeMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|()
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawRoundedRect
argument_list|(
name|rect
argument_list|,
name|xrad
argument_list|,
name|yrad
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
name|VGPath
name|vgpath
init|=
name|d
operator|->
name|roundedRectPath
argument_list|(
name|rect
argument_list|,
name|xrad
argument_list|,
name|yrad
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|d
operator|->
name|draw
argument_list|(
name|vgpath
argument_list|,
name|s
operator|->
name|pen
argument_list|,
name|s
operator|->
name|brush
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
name|vgDestroyPath
argument_list|(
name|vgpath
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|QPaintEngineEx
operator|::
name|drawRoundedRect
argument_list|(
name|rect
argument_list|,
name|xrad
argument_list|,
name|yrad
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|drawRects
name|void
name|QVGPaintEngine
operator|::
name|drawRects
parameter_list|(
specifier|const
name|QRect
modifier|*
name|rects
parameter_list|,
name|int
name|rectCount
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|()
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawRects
argument_list|(
name|rects
argument_list|,
name|rectCount
argument_list|)
expr_stmt|;
return|return;
block|}
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rectCount
condition|;
operator|++
name|i
operator|,
operator|++
name|rects
control|)
block|{
name|VGfloat
name|coords
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|coords
index|[
literal|0
index|]
operator|=
name|rects
operator|->
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|rects
operator|->
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|rects
operator|->
name|x
argument_list|()
operator|+
name|rects
operator|->
name|width
argument_list|()
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|coords
index|[
literal|1
index|]
expr_stmt|;
name|coords
index|[
literal|4
index|]
operator|=
name|coords
index|[
literal|2
index|]
expr_stmt|;
name|coords
index|[
literal|5
index|]
operator|=
name|rects
operator|->
name|y
argument_list|()
operator|+
name|rects
operator|->
name|height
argument_list|()
expr_stmt|;
name|coords
index|[
literal|6
index|]
operator|=
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|coords
index|[
literal|7
index|]
operator|=
name|coords
index|[
literal|5
index|]
expr_stmt|;
block|}
else|else
block|{
name|QPointF
name|tl
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|rects
operator|->
name|x
argument_list|()
argument_list|,
name|rects
operator|->
name|y
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QPointF
name|tr
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|rects
operator|->
name|x
argument_list|()
operator|+
name|rects
operator|->
name|width
argument_list|()
argument_list|,
name|rects
operator|->
name|y
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QPointF
name|bl
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|rects
operator|->
name|x
argument_list|()
argument_list|,
name|rects
operator|->
name|y
argument_list|()
operator|+
name|rects
operator|->
name|height
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QPointF
name|br
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|rects
operator|->
name|x
argument_list|()
operator|+
name|rects
operator|->
name|width
argument_list|()
argument_list|,
name|rects
operator|->
name|y
argument_list|()
operator|+
name|rects
operator|->
name|height
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
name|tl
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|tl
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|tr
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|tr
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|4
index|]
operator|=
name|br
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|5
index|]
operator|=
name|br
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|6
index|]
operator|=
name|bl
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|7
index|]
operator|=
name|bl
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
name|vgModifyPathCoords
argument_list|(
name|d
operator|->
name|rectPath
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|coords
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw
argument_list|(
name|d
operator|->
name|rectPath
argument_list|,
name|s
operator|->
name|pen
argument_list|,
name|s
operator|->
name|brush
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|QPaintEngineEx
operator|::
name|drawRects
argument_list|(
name|rects
argument_list|,
name|rectCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|drawRects
name|void
name|QVGPaintEngine
operator|::
name|drawRects
parameter_list|(
specifier|const
name|QRectF
modifier|*
name|rects
parameter_list|,
name|int
name|rectCount
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|()
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawRects
argument_list|(
name|rects
argument_list|,
name|rectCount
argument_list|)
expr_stmt|;
return|return;
block|}
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rectCount
condition|;
operator|++
name|i
operator|,
operator|++
name|rects
control|)
block|{
name|VGfloat
name|coords
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|coords
index|[
literal|0
index|]
operator|=
name|rects
operator|->
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|rects
operator|->
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|rects
operator|->
name|x
argument_list|()
operator|+
name|rects
operator|->
name|width
argument_list|()
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|coords
index|[
literal|1
index|]
expr_stmt|;
name|coords
index|[
literal|4
index|]
operator|=
name|coords
index|[
literal|2
index|]
expr_stmt|;
name|coords
index|[
literal|5
index|]
operator|=
name|rects
operator|->
name|y
argument_list|()
operator|+
name|rects
operator|->
name|height
argument_list|()
expr_stmt|;
name|coords
index|[
literal|6
index|]
operator|=
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|coords
index|[
literal|7
index|]
operator|=
name|coords
index|[
literal|5
index|]
expr_stmt|;
block|}
else|else
block|{
name|QPointF
name|tl
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|rects
operator|->
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|tr
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|rects
operator|->
name|topRight
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|bl
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|rects
operator|->
name|bottomLeft
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|br
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|rects
operator|->
name|bottomRight
argument_list|()
argument_list|)
decl_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
name|tl
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|tl
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|tr
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|tr
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|4
index|]
operator|=
name|br
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|5
index|]
operator|=
name|br
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|6
index|]
operator|=
name|bl
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|7
index|]
operator|=
name|bl
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
name|vgModifyPathCoords
argument_list|(
name|d
operator|->
name|rectPath
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|coords
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw
argument_list|(
name|d
operator|->
name|rectPath
argument_list|,
name|s
operator|->
name|pen
argument_list|,
name|s
operator|->
name|brush
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|QPaintEngineEx
operator|::
name|drawRects
argument_list|(
name|rects
argument_list|,
name|rectCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|drawLines
name|void
name|QVGPaintEngine
operator|::
name|drawLines
parameter_list|(
specifier|const
name|QLine
modifier|*
name|lines
parameter_list|,
name|int
name|lineCount
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|()
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawLines
argument_list|(
name|lines
argument_list|,
name|lineCount
argument_list|)
expr_stmt|;
return|return;
block|}
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lineCount
condition|;
operator|++
name|i
operator|,
operator|++
name|lines
control|)
block|{
name|VGfloat
name|coords
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|coords
index|[
literal|0
index|]
operator|=
name|lines
operator|->
name|x1
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|lines
operator|->
name|y1
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|lines
operator|->
name|x2
argument_list|()
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|lines
operator|->
name|y2
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QPointF
name|p1
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|lines
operator|->
name|x1
argument_list|()
argument_list|,
name|lines
operator|->
name|y1
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|QPointF
name|p2
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
name|lines
operator|->
name|x2
argument_list|()
argument_list|,
name|lines
operator|->
name|y2
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
name|p1
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|p1
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|p2
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|p2
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
name|vgModifyPathCoords
argument_list|(
name|d
operator|->
name|linePath
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|coords
argument_list|)
expr_stmt|;
name|d
operator|->
name|stroke
argument_list|(
name|d
operator|->
name|linePath
argument_list|,
name|s
operator|->
name|pen
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|QPaintEngineEx
operator|::
name|drawLines
argument_list|(
name|lines
argument_list|,
name|lineCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|drawLines
name|void
name|QVGPaintEngine
operator|::
name|drawLines
parameter_list|(
specifier|const
name|QLineF
modifier|*
name|lines
parameter_list|,
name|int
name|lineCount
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|()
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawLines
argument_list|(
name|lines
argument_list|,
name|lineCount
argument_list|)
expr_stmt|;
return|return;
block|}
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lineCount
condition|;
operator|++
name|i
operator|,
operator|++
name|lines
control|)
block|{
name|VGfloat
name|coords
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|coords
index|[
literal|0
index|]
operator|=
name|lines
operator|->
name|x1
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|lines
operator|->
name|y1
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|lines
operator|->
name|x2
argument_list|()
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|lines
operator|->
name|y2
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|QPointF
name|p1
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|lines
operator|->
name|p1
argument_list|()
argument_list|)
decl_stmt|;
name|QPointF
name|p2
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|lines
operator|->
name|p2
argument_list|()
argument_list|)
decl_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
name|p1
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|p1
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|p2
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|p2
operator|.
name|y
argument_list|()
expr_stmt|;
block|}
name|vgModifyPathCoords
argument_list|(
name|d
operator|->
name|linePath
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|coords
argument_list|)
expr_stmt|;
name|d
operator|->
name|stroke
argument_list|(
name|d
operator|->
name|linePath
argument_list|,
name|s
operator|->
name|pen
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|QPaintEngineEx
operator|::
name|drawLines
argument_list|(
name|lines
argument_list|,
name|lineCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|drawEllipse
name|void
name|QVGPaintEngine
operator|::
name|drawEllipse
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|)
block|{
comment|// Based on the description of vguEllipse() in the OpenVG specification.
comment|// We don't use vguEllipse(), to avoid unnecessary library dependencies.
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|()
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawEllipse
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
name|VGPath
name|path
init|=
name|vgCreatePath
argument_list|(
name|VG_PATH_FORMAT_STANDARD
argument_list|,
name|VG_PATH_DATATYPE_F
argument_list|,
literal|1.0f
argument_list|,
comment|// scale
literal|0.0f
argument_list|,
comment|// bias
literal|4
argument_list|,
comment|// segmentCapacityHint
literal|12
argument_list|,
comment|// coordCapacityHint
name|VG_PATH_CAPABILITY_ALL
argument_list|)
decl_stmt|;
specifier|static
name|VGubyte
name|segments
index|[
literal|4
index|]
init|=
block|{
name|VG_MOVE_TO_ABS
block|,
name|VG_SCCWARC_TO_REL
block|,
name|VG_SCCWARC_TO_REL
block|,
name|VG_CLOSE_PATH
block|}
decl_stmt|;
name|VGfloat
name|coords
index|[
literal|12
index|]
decl_stmt|;
name|VGfloat
name|halfwid
init|=
name|r
operator|.
name|width
argument_list|()
operator|/
literal|2
decl_stmt|;
name|VGfloat
name|halfht
init|=
name|r
operator|.
name|height
argument_list|()
operator|/
literal|2
decl_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
name|r
operator|.
name|x
argument_list|()
operator|+
name|r
operator|.
name|width
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|r
operator|.
name|y
argument_list|()
operator|+
name|halfht
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|halfwid
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|halfht
expr_stmt|;
name|coords
index|[
literal|4
index|]
operator|=
literal|0.0f
expr_stmt|;
name|coords
index|[
literal|5
index|]
operator|=
operator|-
name|r
operator|.
name|width
argument_list|()
expr_stmt|;
name|coords
index|[
literal|6
index|]
operator|=
literal|0.0f
expr_stmt|;
name|coords
index|[
literal|7
index|]
operator|=
name|halfwid
expr_stmt|;
name|coords
index|[
literal|8
index|]
operator|=
name|halfht
expr_stmt|;
name|coords
index|[
literal|9
index|]
operator|=
literal|0.0f
expr_stmt|;
name|coords
index|[
literal|10
index|]
operator|=
name|r
operator|.
name|width
argument_list|()
expr_stmt|;
name|coords
index|[
literal|11
index|]
operator|=
literal|0.0f
expr_stmt|;
name|vgAppendPathData
argument_list|(
name|path
argument_list|,
literal|4
argument_list|,
name|segments
argument_list|,
name|coords
argument_list|)
expr_stmt|;
name|d
operator|->
name|draw
argument_list|(
name|path
argument_list|,
name|s
operator|->
name|pen
argument_list|,
name|s
operator|->
name|brush
argument_list|)
expr_stmt|;
name|vgDestroyPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The projective transform version of an ellipse is difficult.
comment|// Generate a QVectorPath containing cubic curves and transform that.
name|QPaintEngineEx
operator|::
name|drawEllipse
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|drawEllipse
name|void
name|QVGPaintEngine
operator|::
name|drawEllipse
parameter_list|(
specifier|const
name|QRect
modifier|&
name|r
parameter_list|)
block|{
name|drawEllipse
argument_list|(
name|QRectF
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawPath
name|void
name|QVGPaintEngine
operator|::
name|drawPath
parameter_list|(
specifier|const
name|QPainterPath
modifier|&
name|path
parameter_list|)
block|{
comment|// Shortcut past the QPainterPath -> QVectorPath conversion,
comment|// converting the QPainterPath directly into a VGPath.
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|()
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
name|VGPath
name|vgpath
init|=
name|d
operator|->
name|painterPathToVGPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|fillRule
argument_list|()
operator|==
name|Qt
operator|::
name|OddEvenFill
condition|)
name|d
operator|->
name|draw
argument_list|(
name|vgpath
argument_list|,
name|s
operator|->
name|pen
argument_list|,
name|s
operator|->
name|brush
argument_list|,
name|VG_EVEN_ODD
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|draw
argument_list|(
name|vgpath
argument_list|,
name|s
operator|->
name|pen
argument_list|,
name|s
operator|->
name|brush
argument_list|,
name|VG_NON_ZERO
argument_list|)
expr_stmt|;
name|vgDestroyPath
argument_list|(
name|vgpath
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawPoints
name|void
name|QVGPaintEngine
operator|::
name|drawPoints
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsPenEmulation
argument_list|()
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawPoints
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Set up a new pen if necessary.
name|QPen
name|pen
init|=
name|state
argument_list|()
operator|->
name|pen
decl_stmt|;
if|if
condition|(
name|pen
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoPen
condition|)
return|return;
if|if
condition|(
name|pen
operator|.
name|capStyle
argument_list|()
operator|==
name|Qt
operator|::
name|FlatCap
condition|)
name|pen
operator|.
name|setCapStyle
argument_list|(
name|Qt
operator|::
name|SquareCap
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
operator|,
operator|++
name|points
control|)
block|{
name|VGfloat
name|coords
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|coords
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|coords
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|QPointF
name|p
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
operator|*
name|points
argument_list|)
decl_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
name|p
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|p
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|coords
index|[
literal|1
index|]
expr_stmt|;
block|}
name|vgModifyPathCoords
argument_list|(
name|d
operator|->
name|linePath
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|coords
argument_list|)
expr_stmt|;
name|d
operator|->
name|stroke
argument_list|(
name|d
operator|->
name|linePath
argument_list|,
name|pen
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|QPaintEngineEx
operator|::
name|drawPoints
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|drawPoints
name|void
name|QVGPaintEngine
operator|::
name|drawPoints
parameter_list|(
specifier|const
name|QPoint
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|()
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawPoints
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Set up a new pen if necessary.
name|QPen
name|pen
init|=
name|state
argument_list|()
operator|->
name|pen
decl_stmt|;
if|if
condition|(
name|pen
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|NoPen
condition|)
return|return;
if|if
condition|(
name|pen
operator|.
name|capStyle
argument_list|()
operator|==
name|Qt
operator|::
name|FlatCap
condition|)
name|pen
operator|.
name|setCapStyle
argument_list|(
name|Qt
operator|::
name|SquareCap
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
operator|,
operator|++
name|points
control|)
block|{
name|VGfloat
name|coords
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|coords
index|[
literal|0
index|]
operator|=
name|points
operator|->
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|points
operator|->
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|coords
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|QPointF
name|p
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
operator|*
name|points
argument_list|)
argument_list|)
decl_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
name|p
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|p
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|coords
index|[
literal|1
index|]
expr_stmt|;
block|}
name|vgModifyPathCoords
argument_list|(
name|d
operator|->
name|linePath
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|coords
argument_list|)
expr_stmt|;
name|d
operator|->
name|stroke
argument_list|(
name|d
operator|->
name|linePath
argument_list|,
name|pen
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|QPaintEngineEx
operator|::
name|drawPoints
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|drawPolygon
name|void
name|QVGPaintEngine
operator|::
name|drawPolygon
parameter_list|(
specifier|const
name|QPointF
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|,
name|PolygonDrawMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|()
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
name|VGPath
name|path
init|=
name|vgCreatePath
argument_list|(
name|VG_PATH_FORMAT_STANDARD
argument_list|,
name|VG_PATH_DATATYPE_F
argument_list|,
literal|1.0f
argument_list|,
comment|// scale
literal|0.0f
argument_list|,
comment|// bias
name|pointCount
operator|+
literal|1
argument_list|,
comment|// segmentCapacityHint
name|pointCount
operator|*
literal|2
argument_list|,
comment|// coordCapacityHint
name|VG_PATH_CAPABILITY_ALL
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|VGfloat
argument_list|,
literal|16
argument_list|>
name|coords
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|VGubyte
argument_list|,
literal|10
argument_list|>
name|segments
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
operator|,
operator|++
name|points
control|)
block|{
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|coords
operator|.
name|append
argument_list|(
name|points
operator|->
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|points
operator|->
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QPointF
name|temp
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
operator|*
name|points
argument_list|)
decl_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|segments
operator|.
name|append
argument_list|(
name|VG_MOVE_TO_ABS
argument_list|)
expr_stmt|;
else|else
name|segments
operator|.
name|append
argument_list|(
name|VG_LINE_TO_ABS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|QPaintEngine
operator|::
name|PolylineMode
condition|)
name|segments
operator|.
name|append
argument_list|(
name|VG_CLOSE_PATH
argument_list|)
expr_stmt|;
name|vgAppendPathData
argument_list|(
name|path
argument_list|,
name|segments
operator|.
name|count
argument_list|()
argument_list|,
name|segments
operator|.
name|constData
argument_list|()
argument_list|,
name|coords
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QPaintEngine
operator|::
name|WindingMode
case|:
name|d
operator|->
name|draw
argument_list|(
name|path
argument_list|,
name|s
operator|->
name|pen
argument_list|,
name|s
operator|->
name|brush
argument_list|,
name|VG_NON_ZERO
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPaintEngine
operator|::
name|PolylineMode
case|:
name|d
operator|->
name|stroke
argument_list|(
name|path
argument_list|,
name|s
operator|->
name|pen
argument_list|)
expr_stmt|;
break|break;
default|default:
name|d
operator|->
name|draw
argument_list|(
name|path
argument_list|,
name|s
operator|->
name|pen
argument_list|,
name|s
operator|->
name|brush
argument_list|,
name|VG_EVEN_ODD
argument_list|)
expr_stmt|;
break|break;
block|}
name|vgDestroyPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawPolygon
name|void
name|QVGPaintEngine
operator|::
name|drawPolygon
parameter_list|(
specifier|const
name|QPoint
modifier|*
name|points
parameter_list|,
name|int
name|pointCount
parameter_list|,
name|PolygonDrawMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|needsEmulation
argument_list|()
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawPolygon
argument_list|(
name|points
argument_list|,
name|pointCount
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
name|QVGPainterState
modifier|*
name|s
init|=
name|state
argument_list|()
decl_stmt|;
name|VGPath
name|path
init|=
name|vgCreatePath
argument_list|(
name|VG_PATH_FORMAT_STANDARD
argument_list|,
name|VG_PATH_DATATYPE_F
argument_list|,
literal|1.0f
argument_list|,
comment|// scale
literal|0.0f
argument_list|,
comment|// bias
name|pointCount
operator|+
literal|1
argument_list|,
comment|// segmentCapacityHint
name|pointCount
operator|*
literal|2
argument_list|,
comment|// coordCapacityHint
name|VG_PATH_CAPABILITY_ALL
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|VGfloat
argument_list|,
literal|16
argument_list|>
name|coords
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|VGubyte
argument_list|,
literal|10
argument_list|>
name|segments
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pointCount
condition|;
operator|++
name|i
operator|,
operator|++
name|points
control|)
block|{
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|coords
operator|.
name|append
argument_list|(
name|points
operator|->
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|points
operator|->
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QPointF
name|temp
init|=
name|d
operator|->
name|transform
operator|.
name|map
argument_list|(
name|QPointF
argument_list|(
operator|*
name|points
argument_list|)
argument_list|)
decl_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|x
argument_list|()
argument_list|)
expr_stmt|;
name|coords
operator|.
name|append
argument_list|(
name|temp
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|segments
operator|.
name|append
argument_list|(
name|VG_MOVE_TO_ABS
argument_list|)
expr_stmt|;
else|else
name|segments
operator|.
name|append
argument_list|(
name|VG_LINE_TO_ABS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|QPaintEngine
operator|::
name|PolylineMode
condition|)
name|segments
operator|.
name|append
argument_list|(
name|VG_CLOSE_PATH
argument_list|)
expr_stmt|;
name|vgAppendPathData
argument_list|(
name|path
argument_list|,
name|segments
operator|.
name|count
argument_list|()
argument_list|,
name|segments
operator|.
name|constData
argument_list|()
argument_list|,
name|coords
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QPaintEngine
operator|::
name|WindingMode
case|:
name|d
operator|->
name|draw
argument_list|(
name|path
argument_list|,
name|s
operator|->
name|pen
argument_list|,
name|s
operator|->
name|brush
argument_list|,
name|VG_NON_ZERO
argument_list|)
expr_stmt|;
break|break;
case|case
name|QPaintEngine
operator|::
name|PolylineMode
case|:
name|d
operator|->
name|stroke
argument_list|(
name|path
argument_list|,
name|s
operator|->
name|pen
argument_list|)
expr_stmt|;
break|break;
default|default:
name|d
operator|->
name|draw
argument_list|(
name|path
argument_list|,
name|s
operator|->
name|pen
argument_list|,
name|s
operator|->
name|brush
argument_list|,
name|VG_EVEN_ODD
argument_list|)
expr_stmt|;
break|break;
block|}
name|vgDestroyPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setImageOptions
name|void
name|QVGPaintEnginePrivate
operator|::
name|setImageOptions
parameter_list|()
block|{
if|if
condition|(
name|opacity
operator|!=
literal|1.0f
operator|&&
name|simpleTransform
condition|)
block|{
if|if
condition|(
name|opacity
operator|!=
name|paintOpacity
condition|)
block|{
name|VGfloat
name|values
index|[
literal|4
index|]
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
literal|1.0f
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
literal|1.0f
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
literal|1.0f
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|opacity
expr_stmt|;
name|vgSetParameterfv
argument_list|(
name|opacityPaint
argument_list|,
name|VG_PAINT_COLOR
argument_list|,
literal|4
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|paintOpacity
operator|=
name|opacity
expr_stmt|;
block|}
if|if
condition|(
name|fillPaint
operator|!=
name|opacityPaint
condition|)
block|{
name|vgSetPaint
argument_list|(
name|opacityPaint
argument_list|,
name|VG_FILL_PATH
argument_list|)
expr_stmt|;
name|fillPaint
operator|=
name|opacityPaint
expr_stmt|;
block|}
name|setImageMode
argument_list|(
name|VG_DRAW_IMAGE_MULTIPLY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setImageMode
argument_list|(
name|VG_DRAW_IMAGE_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|systemStateChanged
name|void
name|QVGPaintEnginePrivate
operator|::
name|systemStateChanged
parameter_list|()
block|{
name|q
operator|->
name|updateScissor
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawVGImage
specifier|static
name|void
name|drawVGImage
parameter_list|(
name|QVGPaintEnginePrivate
modifier|*
name|d
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
name|VGImage
name|vgImg
parameter_list|,
specifier|const
name|QSize
modifier|&
name|imageSize
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|sr
parameter_list|)
block|{
if|if
condition|(
name|vgImg
operator|==
name|VG_INVALID_HANDLE
condition|)
return|return;
name|VGImage
name|child
init|=
name|VG_INVALID_HANDLE
decl_stmt|;
if|if
condition|(
name|sr
operator|.
name|topLeft
argument_list|()
operator|.
name|isNull
argument_list|()
operator|&&
name|sr
operator|.
name|size
argument_list|()
operator|==
name|imageSize
condition|)
block|{
name|child
operator|=
name|vgImg
expr_stmt|;
block|}
else|else
block|{
name|QRect
name|src
init|=
name|sr
operator|.
name|toRect
argument_list|()
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_SHIVAVG
argument_list|)
name|child
operator|=
name|vgChildImage
argument_list|(
name|vgImg
argument_list|,
name|src
operator|.
name|x
argument_list|()
argument_list|,
name|src
operator|.
name|y
argument_list|()
argument_list|,
name|src
operator|.
name|width
argument_list|()
argument_list|,
name|src
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|child
operator|=
name|vgImg
expr_stmt|;
comment|// XXX: ShivaVG doesn't have vgChildImage().
endif|#
directive|endif
block|}
name|QTransform
name|transform
argument_list|(
name|d
operator|->
name|imageTransform
argument_list|)
decl_stmt|;
name|VGfloat
name|scaleX
init|=
name|sr
operator|.
name|width
argument_list|()
operator|==
literal|0.0f
condition|?
literal|0.0f
else|:
name|r
operator|.
name|width
argument_list|()
operator|/
name|sr
operator|.
name|width
argument_list|()
decl_stmt|;
name|VGfloat
name|scaleY
init|=
name|sr
operator|.
name|height
argument_list|()
operator|==
literal|0.0f
condition|?
literal|0.0f
else|:
name|r
operator|.
name|height
argument_list|()
operator|/
name|sr
operator|.
name|height
argument_list|()
decl_stmt|;
name|transform
operator|.
name|translate
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|transform
operator|.
name|scale
argument_list|(
name|scaleX
argument_list|,
name|scaleY
argument_list|)
expr_stmt|;
name|d
operator|->
name|setTransform
argument_list|(
name|VG_MATRIX_IMAGE_USER_TO_SURFACE
argument_list|,
name|transform
argument_list|)
expr_stmt|;
name|d
operator|->
name|setImageOptions
argument_list|()
expr_stmt|;
name|vgDrawImage
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|vgImg
condition|)
name|vgDestroyImage
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawVGImage
specifier|static
name|void
name|drawVGImage
parameter_list|(
name|QVGPaintEnginePrivate
modifier|*
name|d
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
name|VGImage
name|vgImg
parameter_list|)
block|{
if|if
condition|(
name|vgImg
operator|==
name|VG_INVALID_HANDLE
condition|)
return|return;
name|QTransform
name|transform
argument_list|(
name|d
operator|->
name|imageTransform
argument_list|)
decl_stmt|;
name|transform
operator|.
name|translate
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|setTransform
argument_list|(
name|VG_MATRIX_IMAGE_USER_TO_SURFACE
argument_list|,
name|transform
argument_list|)
expr_stmt|;
name|d
operator|->
name|setImageOptions
argument_list|()
expr_stmt|;
name|vgDrawImage
argument_list|(
name|vgImg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawImageTiled
specifier|static
name|void
name|drawImageTiled
parameter_list|(
name|QVGPaintEnginePrivate
modifier|*
name|d
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|sr
init|=
name|QRectF
argument_list|()
parameter_list|)
block|{
specifier|const
name|int
name|minTileSize
init|=
literal|16
decl_stmt|;
name|int
name|tileWidth
init|=
literal|512
decl_stmt|;
name|int
name|tileHeight
init|=
name|tileWidth
decl_stmt|;
name|VGImageFormat
name|tileFormat
init|=
name|qt_vg_image_to_vg_format
argument_list|(
name|image
operator|.
name|format
argument_list|()
argument_list|)
decl_stmt|;
name|VGImage
name|tile
init|=
name|VG_INVALID_HANDLE
decl_stmt|;
name|QVGImagePool
modifier|*
name|pool
init|=
name|QVGImagePool
operator|::
name|instance
argument_list|()
decl_stmt|;
while|while
condition|(
name|tile
operator|==
name|VG_INVALID_HANDLE
operator|&&
name|tileWidth
operator|>=
name|minTileSize
condition|)
block|{
name|tile
operator|=
name|pool
operator|->
name|createPermanentImage
argument_list|(
name|tileFormat
argument_list|,
name|tileWidth
argument_list|,
name|tileHeight
argument_list|,
name|VG_IMAGE_QUALITY_FASTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|tile
operator|==
name|VG_INVALID_HANDLE
condition|)
block|{
name|tileWidth
operator|/=
literal|2
expr_stmt|;
name|tileHeight
operator|/=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tile
operator|==
name|VG_INVALID_HANDLE
condition|)
block|{
name|qWarning
argument_list|(
literal|"drawImageTiled: Failed to create %dx%d tile, giving up"
argument_list|,
name|tileWidth
argument_list|,
name|tileHeight
argument_list|)
expr_stmt|;
return|return;
block|}
name|VGfloat
name|opacityMatrix
index|[
literal|20
index|]
init|=
block|{
literal|1.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|1.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|1.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
name|d
operator|->
name|opacity
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|,
literal|0.0f
block|}
decl_stmt|;
name|VGImage
name|tileWithOpacity
init|=
name|VG_INVALID_HANDLE
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|opacity
operator|!=
literal|1
condition|)
block|{
name|tileWithOpacity
operator|=
name|pool
operator|->
name|createPermanentImage
argument_list|(
name|VG_sARGB_8888_PRE
argument_list|,
name|tileWidth
argument_list|,
name|tileHeight
argument_list|,
name|VG_IMAGE_QUALITY_FASTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|tileWithOpacity
operator|==
name|VG_INVALID_HANDLE
condition|)
name|qWarning
argument_list|(
literal|"drawImageTiled: Failed to create extra tile, ignoring opacity"
argument_list|)
expr_stmt|;
block|}
name|QRect
name|sourceRect
init|=
name|sr
operator|.
name|toRect
argument_list|()
decl_stmt|;
if|if
condition|(
name|sourceRect
operator|.
name|isNull
argument_list|()
condition|)
name|sourceRect
operator|=
name|QRect
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|image
operator|.
name|width
argument_list|()
argument_list|,
name|image
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|VGfloat
name|scaleX
init|=
name|r
operator|.
name|width
argument_list|()
operator|/
name|sourceRect
operator|.
name|width
argument_list|()
decl_stmt|;
name|VGfloat
name|scaleY
init|=
name|r
operator|.
name|height
argument_list|()
operator|/
name|sourceRect
operator|.
name|height
argument_list|()
decl_stmt|;
name|d
operator|->
name|setImageOptions
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|y
init|=
name|sourceRect
operator|.
name|y
argument_list|()
init|;
name|y
operator|<
name|sourceRect
operator|.
name|height
argument_list|()
condition|;
name|y
operator|+=
name|tileHeight
control|)
block|{
name|int
name|h
init|=
name|qMin
argument_list|(
name|tileHeight
argument_list|,
name|sourceRect
operator|.
name|height
argument_list|()
operator|-
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|<
literal|1
condition|)
break|break;
for|for
control|(
name|int
name|x
init|=
name|sourceRect
operator|.
name|x
argument_list|()
init|;
name|x
operator|<
name|sourceRect
operator|.
name|width
argument_list|()
condition|;
name|x
operator|+=
name|tileWidth
control|)
block|{
name|int
name|w
init|=
name|qMin
argument_list|(
name|tileWidth
argument_list|,
name|sourceRect
operator|.
name|width
argument_list|()
operator|-
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|1
condition|)
break|break;
name|int
name|bytesPerPixel
init|=
name|image
operator|.
name|depth
argument_list|()
operator|/
literal|8
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|sptr
init|=
name|image
operator|.
name|constBits
argument_list|()
operator|+
name|x
operator|*
name|bytesPerPixel
operator|+
name|y
operator|*
name|image
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
name|vgImageSubData
argument_list|(
name|tile
argument_list|,
name|sptr
argument_list|,
name|image
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
name|tileFormat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|QTransform
name|transform
argument_list|(
name|d
operator|->
name|imageTransform
argument_list|)
decl_stmt|;
name|transform
operator|.
name|translate
argument_list|(
name|r
operator|.
name|x
argument_list|()
operator|+
name|x
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|+
name|y
argument_list|)
expr_stmt|;
name|transform
operator|.
name|scale
argument_list|(
name|scaleX
argument_list|,
name|scaleY
argument_list|)
expr_stmt|;
name|d
operator|->
name|setTransform
argument_list|(
name|VG_MATRIX_IMAGE_USER_TO_SURFACE
argument_list|,
name|transform
argument_list|)
expr_stmt|;
name|VGImage
name|actualTile
init|=
name|tile
decl_stmt|;
if|if
condition|(
name|tileWithOpacity
operator|!=
name|VG_INVALID_HANDLE
condition|)
block|{
name|vgColorMatrix
argument_list|(
name|tileWithOpacity
argument_list|,
name|actualTile
argument_list|,
name|opacityMatrix
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|<
name|tileWidth
operator|||
name|h
operator|<
name|tileHeight
condition|)
name|actualTile
operator|=
name|vgChildImage
argument_list|(
name|tileWithOpacity
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
else|else
name|actualTile
operator|=
name|tileWithOpacity
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|<
name|tileWidth
operator|||
name|h
operator|<
name|tileHeight
condition|)
block|{
name|actualTile
operator|=
name|vgChildImage
argument_list|(
name|tile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
name|vgDrawImage
argument_list|(
name|actualTile
argument_list|)
expr_stmt|;
if|if
condition|(
name|actualTile
operator|!=
name|tile
operator|&&
name|actualTile
operator|!=
name|tileWithOpacity
condition|)
name|vgDestroyImage
argument_list|(
name|actualTile
argument_list|)
expr_stmt|;
block|}
block|}
name|vgDestroyImage
argument_list|(
name|tile
argument_list|)
expr_stmt|;
if|if
condition|(
name|tileWithOpacity
operator|!=
name|VG_INVALID_HANDLE
condition|)
name|vgDestroyImage
argument_list|(
name|tileWithOpacity
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Used by qpixmapfilter_vg.cpp to draw filtered VGImage's.
end_comment
begin_function
DECL|function|qt_vg_drawVGImage
name|void
name|qt_vg_drawVGImage
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
name|VGImage
name|vgImg
parameter_list|)
block|{
name|QVGPaintEngine
modifier|*
name|engine
init|=
cast|static_cast
argument_list|<
name|QVGPaintEngine
operator|*
argument_list|>
argument_list|(
name|painter
operator|->
name|paintEngine
argument_list|()
argument_list|)
decl_stmt|;
name|drawVGImage
argument_list|(
name|engine
operator|->
name|vgPrivate
argument_list|()
argument_list|,
name|pos
argument_list|,
name|vgImg
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Used by qpixmapfilter_vg.cpp to draw filtered VGImage's as a stencil.
end_comment
begin_function
DECL|function|qt_vg_drawVGImageStencil
name|void
name|qt_vg_drawVGImageStencil
parameter_list|(
name|QPainter
modifier|*
name|painter
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
name|VGImage
name|vgImg
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
name|QVGPaintEngine
modifier|*
name|engine
init|=
cast|static_cast
argument_list|<
name|QVGPaintEngine
operator|*
argument_list|>
argument_list|(
name|painter
operator|->
name|paintEngine
argument_list|()
argument_list|)
decl_stmt|;
name|QVGPaintEnginePrivate
modifier|*
name|d
init|=
name|engine
operator|->
name|vgPrivate
argument_list|()
decl_stmt|;
name|QTransform
name|transform
argument_list|(
name|d
operator|->
name|imageTransform
argument_list|)
decl_stmt|;
name|transform
operator|.
name|translate
argument_list|(
name|pos
operator|.
name|x
argument_list|()
argument_list|,
name|pos
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|setTransform
argument_list|(
name|VG_MATRIX_IMAGE_USER_TO_SURFACE
argument_list|,
name|transform
argument_list|)
expr_stmt|;
name|d
operator|->
name|ensureBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|d
operator|->
name|setImageMode
argument_list|(
name|VG_DRAW_IMAGE_STENCIL
argument_list|)
expr_stmt|;
name|vgDrawImage
argument_list|(
name|vgImg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|canVgWritePixels
name|bool
name|QVGPaintEngine
operator|::
name|canVgWritePixels
parameter_list|(
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QVGPaintEngine
argument_list|)
expr_stmt|;
comment|// qt_vg_image_to_vg_format returns VG_sARGB_8888 as
comment|// fallback case if no matching VG format is found.
comment|// If given image format is not Format_ARGB32 and returned
comment|// format is VG_sARGB_8888, it means that no match was
comment|// found. In that case vgWritePixels cannot be used.
comment|// Also 1-bit formats cannot be used directly either.
if|if
condition|(
operator|(
name|image
operator|.
name|format
argument_list|()
operator|!=
name|QImage
operator|::
name|Format_ARGB32
operator|&&
name|qt_vg_image_to_vg_format
argument_list|(
name|image
operator|.
name|format
argument_list|()
argument_list|)
operator|==
name|VG_sARGB_8888
operator|)
operator|||
name|image
operator|.
name|depth
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// vgWritePixels ignores masking, blending and xforms so we can only use it if
comment|// ALL of the following conditions are true:
comment|// - It is a simple translate, or a scale of -1 on the y-axis (inverted)
comment|// - The opacity is totally opaque
comment|// - The composition mode is "source" OR "source over" provided the image is opaque
return|return
operator|(
name|d
operator|->
name|imageTransform
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxScale
operator|&&
name|d
operator|->
name|imageTransform
operator|.
name|m11
argument_list|()
operator|==
literal|1.0
operator|&&
name|qAbs
argument_list|(
name|d
operator|->
name|imageTransform
operator|.
name|m22
argument_list|()
argument_list|)
operator|==
literal|1.0
operator|)
operator|&&
name|d
operator|->
name|opacity
operator|==
literal|1.0f
operator|&&
operator|(
name|d
operator|->
name|blendMode
operator|==
name|VG_BLEND_SRC
operator|||
operator|(
name|d
operator|->
name|blendMode
operator|==
name|VG_BLEND_SRC_OVER
operator|&&
operator|!
name|image
operator|.
name|hasAlphaChannel
argument_list|()
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|drawPixmap
name|void
name|QVGPaintEngine
operator|::
name|drawPixmap
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pm
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|sr
parameter_list|)
block|{
name|QPixmapData
modifier|*
name|pd
init|=
name|pm
operator|.
name|pixmapData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pd
condition|)
return|return;
comment|// null QPixmap
if|if
condition|(
name|pd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|OpenVGClass
condition|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|QVGPixmapData
modifier|*
name|vgpd
init|=
cast|static_cast
argument_list|<
name|QVGPixmapData
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vgpd
operator|->
name|isValid
argument_list|()
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
name|drawVGImage
argument_list|(
name|d
argument_list|,
name|r
argument_list|,
name|vgpd
operator|->
name|toVGImage
argument_list|()
argument_list|,
name|vgpd
operator|->
name|size
argument_list|()
argument_list|,
name|sr
argument_list|)
expr_stmt|;
else|else
name|drawVGImage
argument_list|(
name|d
argument_list|,
name|r
argument_list|,
name|vgpd
operator|->
name|toVGImage
argument_list|(
name|d
operator|->
name|opacity
argument_list|)
argument_list|,
name|vgpd
operator|->
name|size
argument_list|()
argument_list|,
name|sr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vgpd
operator|->
name|failedToAlloc
condition|)
return|return;
comment|// try to reallocate next time if reasonable small pixmap
name|QSize
name|screenSize
init|=
name|QApplication
operator|::
name|desktop
argument_list|()
operator|->
name|screenGeometry
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|pm
operator|.
name|size
argument_list|()
operator|.
name|width
argument_list|()
operator|<=
name|screenSize
operator|.
name|width
argument_list|()
operator|&&
name|pm
operator|.
name|size
argument_list|()
operator|.
name|height
argument_list|()
operator|<=
name|screenSize
operator|.
name|height
argument_list|()
condition|)
name|vgpd
operator|->
name|failedToAlloc
operator|=
literal|false
expr_stmt|;
name|vgpd
operator|->
name|source
operator|.
name|beginDataAccess
argument_list|()
expr_stmt|;
name|drawImage
argument_list|(
name|r
argument_list|,
name|vgpd
operator|->
name|source
operator|.
name|imageRef
argument_list|()
argument_list|,
name|sr
argument_list|,
name|Qt
operator|::
name|AutoColor
argument_list|)
expr_stmt|;
name|vgpd
operator|->
name|source
operator|.
name|endDataAccess
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drawImage
argument_list|(
name|r
argument_list|,
operator|*
operator|(
name|pd
operator|->
name|buffer
argument_list|()
operator|)
argument_list|,
name|sr
argument_list|,
name|Qt
operator|::
name|AutoColor
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|drawPixmap
name|void
name|QVGPaintEngine
operator|::
name|drawPixmap
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pm
parameter_list|)
block|{
name|QPixmapData
modifier|*
name|pd
init|=
name|pm
operator|.
name|pixmapData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pd
condition|)
return|return;
comment|// null QPixmap
if|if
condition|(
name|pd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|OpenVGClass
condition|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|QVGPixmapData
modifier|*
name|vgpd
init|=
cast|static_cast
argument_list|<
name|QVGPixmapData
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vgpd
operator|->
name|isValid
argument_list|()
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|simpleTransform
condition|)
name|drawVGImage
argument_list|(
name|d
argument_list|,
name|pos
argument_list|,
name|vgpd
operator|->
name|toVGImage
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|drawVGImage
argument_list|(
name|d
argument_list|,
name|pos
argument_list|,
name|vgpd
operator|->
name|toVGImage
argument_list|(
name|d
operator|->
name|opacity
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vgpd
operator|->
name|failedToAlloc
condition|)
return|return;
comment|// try to reallocate next time if reasonable small pixmap
name|QSize
name|screenSize
init|=
name|QApplication
operator|::
name|desktop
argument_list|()
operator|->
name|screenGeometry
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|pm
operator|.
name|size
argument_list|()
operator|.
name|width
argument_list|()
operator|<=
name|screenSize
operator|.
name|width
argument_list|()
operator|&&
name|pm
operator|.
name|size
argument_list|()
operator|.
name|height
argument_list|()
operator|<=
name|screenSize
operator|.
name|height
argument_list|()
condition|)
name|vgpd
operator|->
name|failedToAlloc
operator|=
literal|false
expr_stmt|;
name|vgpd
operator|->
name|source
operator|.
name|beginDataAccess
argument_list|()
expr_stmt|;
name|drawImage
argument_list|(
name|pos
argument_list|,
name|vgpd
operator|->
name|source
operator|.
name|imageRef
argument_list|()
argument_list|)
expr_stmt|;
name|vgpd
operator|->
name|source
operator|.
name|endDataAccess
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drawImage
argument_list|(
name|pos
argument_list|,
operator|*
operator|(
name|pd
operator|->
name|buffer
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|drawImage
name|void
name|QVGPaintEngine
operator|::
name|drawImage
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|,
specifier|const
name|QRectF
modifier|&
name|sr
parameter_list|,
name|Qt
operator|::
name|ImageConversionFlags
name|flags
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|VGImage
name|vgImg
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|simpleTransform
operator|||
name|d
operator|->
name|opacity
operator|==
literal|1.0f
condition|)
name|vgImg
operator|=
name|toVGImageSubRect
argument_list|(
name|image
argument_list|,
name|sr
operator|.
name|toRect
argument_list|()
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|vgImg
operator|=
name|toVGImageWithOpacitySubRect
argument_list|(
name|image
argument_list|,
name|d
operator|->
name|opacity
argument_list|,
name|sr
operator|.
name|toRect
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|vgImg
operator|!=
name|VG_INVALID_HANDLE
condition|)
block|{
if|if
condition|(
name|r
operator|.
name|size
argument_list|()
operator|==
name|sr
operator|.
name|size
argument_list|()
condition|)
block|{
name|drawVGImage
argument_list|(
name|d
argument_list|,
name|r
operator|.
name|topLeft
argument_list|()
argument_list|,
name|vgImg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drawVGImage
argument_list|(
name|d
argument_list|,
name|r
argument_list|,
name|vgImg
argument_list|,
name|sr
operator|.
name|size
argument_list|()
operator|.
name|toSize
argument_list|()
argument_list|,
name|QRectF
argument_list|(
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sr
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|canVgWritePixels
argument_list|(
name|image
argument_list|)
operator|&&
operator|(
name|r
operator|.
name|size
argument_list|()
operator|==
name|sr
operator|.
name|size
argument_list|()
operator|)
operator|&&
operator|!
name|flags
condition|)
block|{
comment|// Optimization for straight blits, no blending
name|int
name|x
init|=
name|sr
operator|.
name|x
argument_list|()
decl_stmt|;
name|int
name|y
init|=
name|sr
operator|.
name|y
argument_list|()
decl_stmt|;
name|int
name|bpp
init|=
name|image
operator|.
name|depth
argument_list|()
operator|>>
literal|3
decl_stmt|;
comment|// bytes
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|bpl
init|=
name|image
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|imageTransform
operator|.
name|m22
argument_list|()
operator|<
literal|0
condition|)
block|{
comment|// inverted
name|offset
operator|=
operator|(
operator|(
name|y
operator|+
name|sr
operator|.
name|height
argument_list|()
operator|)
operator|*
name|bpl
operator|)
operator|-
operator|(
operator|(
name|image
operator|.
name|width
argument_list|()
operator|-
name|x
operator|)
operator|*
name|bpp
operator|)
expr_stmt|;
name|bpl
operator|=
operator|-
name|bpl
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
operator|(
name|y
operator|*
name|bpl
operator|)
operator|+
operator|(
name|x
operator|*
name|bpp
operator|)
expr_stmt|;
block|}
specifier|const
name|uchar
modifier|*
name|bits
init|=
name|image
operator|.
name|constBits
argument_list|()
operator|+
name|offset
decl_stmt|;
name|QPointF
name|mapped
init|=
name|d
operator|->
name|imageTransform
operator|.
name|map
argument_list|(
name|r
operator|.
name|topLeft
argument_list|()
argument_list|)
decl_stmt|;
name|vgWritePixels
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|,
name|qt_vg_image_to_vg_format
argument_list|(
name|image
operator|.
name|format
argument_list|()
argument_list|)
argument_list|,
name|mapped
operator|.
name|x
argument_list|()
argument_list|,
name|mapped
operator|.
name|y
argument_list|()
operator|-
name|sr
operator|.
name|height
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|// Monochrome images need to use the vgChildImage() path.
name|vgImg
operator|=
name|toVGImage
argument_list|(
name|image
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|vgImg
operator|==
name|VG_INVALID_HANDLE
condition|)
name|drawImageTiled
argument_list|(
name|d
argument_list|,
name|r
argument_list|,
name|image
argument_list|,
name|sr
argument_list|)
expr_stmt|;
else|else
name|drawVGImage
argument_list|(
name|d
argument_list|,
name|r
argument_list|,
name|vgImg
argument_list|,
name|image
operator|.
name|size
argument_list|()
argument_list|,
name|sr
argument_list|)
expr_stmt|;
block|}
block|}
name|vgDestroyImage
argument_list|(
name|vgImg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawImage
name|void
name|QVGPaintEngine
operator|::
name|drawImage
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|pos
parameter_list|,
specifier|const
name|QImage
modifier|&
name|image
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|VGImage
name|vgImg
decl_stmt|;
if|if
condition|(
name|canVgWritePixels
argument_list|(
name|image
argument_list|)
condition|)
block|{
comment|// Optimization for straight blits, no blending
name|bool
name|inverted
init|=
operator|(
name|d
operator|->
name|imageTransform
operator|.
name|m22
argument_list|()
operator|<
literal|0
operator|)
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|bits
init|=
name|inverted
condition|?
name|image
operator|.
name|constBits
argument_list|()
operator|+
name|image
operator|.
name|byteCount
argument_list|()
else|:
name|image
operator|.
name|constBits
argument_list|()
decl_stmt|;
name|int
name|bpl
init|=
name|inverted
condition|?
operator|-
name|image
operator|.
name|bytesPerLine
argument_list|()
else|:
name|image
operator|.
name|bytesPerLine
argument_list|()
decl_stmt|;
name|QPointF
name|mapped
init|=
name|d
operator|->
name|imageTransform
operator|.
name|map
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|vgWritePixels
argument_list|(
name|bits
argument_list|,
name|bpl
argument_list|,
name|qt_vg_image_to_vg_format
argument_list|(
name|image
operator|.
name|format
argument_list|()
argument_list|)
argument_list|,
name|mapped
operator|.
name|x
argument_list|()
argument_list|,
name|mapped
operator|.
name|y
argument_list|()
operator|-
name|image
operator|.
name|height
argument_list|()
argument_list|,
name|image
operator|.
name|width
argument_list|()
argument_list|,
name|image
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|simpleTransform
operator|||
name|d
operator|->
name|opacity
operator|==
literal|1.0f
condition|)
block|{
name|vgImg
operator|=
name|toVGImage
argument_list|(
name|image
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vgImg
operator|=
name|toVGImageWithOpacity
argument_list|(
name|image
argument_list|,
name|d
operator|->
name|opacity
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vgImg
operator|==
name|VG_INVALID_HANDLE
condition|)
name|drawImageTiled
argument_list|(
name|d
argument_list|,
name|QRectF
argument_list|(
name|pos
argument_list|,
name|image
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|image
argument_list|)
expr_stmt|;
else|else
name|drawVGImage
argument_list|(
name|d
argument_list|,
name|pos
argument_list|,
name|vgImg
argument_list|)
expr_stmt|;
name|vgDestroyImage
argument_list|(
name|vgImg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawTiledPixmap
name|void
name|QVGPaintEngine
operator|::
name|drawTiledPixmap
parameter_list|(
specifier|const
name|QRectF
modifier|&
name|r
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|s
parameter_list|)
block|{
name|QBrush
name|brush
argument_list|(
name|state
argument_list|()
operator|->
name|pen
operator|.
name|color
argument_list|()
argument_list|,
name|pixmap
argument_list|)
decl_stmt|;
name|QTransform
name|xform
init|=
name|QTransform
operator|::
name|fromTranslate
argument_list|(
name|r
operator|.
name|x
argument_list|()
operator|-
name|s
operator|.
name|x
argument_list|()
argument_list|,
name|r
operator|.
name|y
argument_list|()
operator|-
name|s
operator|.
name|y
argument_list|()
argument_list|)
decl_stmt|;
name|brush
operator|.
name|setTransform
argument_list|(
name|xform
argument_list|)
expr_stmt|;
name|fillRect
argument_list|(
name|r
argument_list|,
name|brush
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Best performance will be achieved with QDrawPixmaps::OpaqueHint
end_comment
begin_comment
comment|// (i.e. no opacity), no rotation or scaling, and drawing the full
end_comment
begin_comment
comment|// pixmap rather than parts of the pixmap.  Even having just one of
end_comment
begin_comment
comment|// these conditions will improve performance.
end_comment
begin_function
DECL|function|drawPixmapFragments
name|void
name|QVGPaintEngine
operator|::
name|drawPixmapFragments
parameter_list|(
specifier|const
name|QPainter
operator|::
name|PixmapFragment
modifier|*
name|drawingData
parameter_list|,
name|int
name|dataCount
parameter_list|,
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
name|QFlags
argument_list|<
name|QPainter
operator|::
name|PixmapFragmentHint
argument_list|>
name|hints
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_SHIVAVG
argument_list|)
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
comment|// If the pixmap is not VG, or the transformation is projective,
comment|// then fall back to the default implementation.
name|QPixmapData
modifier|*
name|pd
init|=
name|pixmap
operator|.
name|pixmapData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pd
condition|)
return|return;
comment|// null QPixmap
if|if
condition|(
name|pd
operator|->
name|classId
argument_list|()
operator|!=
name|QPixmapData
operator|::
name|OpenVGClass
operator|||
operator|!
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawPixmapFragments
argument_list|(
name|drawingData
argument_list|,
name|dataCount
argument_list|,
name|pixmap
argument_list|,
name|hints
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Bail out if nothing to do.
if|if
condition|(
name|dataCount
operator|<=
literal|0
condition|)
return|return;
comment|// Bail out if we don't have a usable VGImage for the pixmap.
name|QVGPixmapData
modifier|*
name|vgpd
init|=
cast|static_cast
argument_list|<
name|QVGPixmapData
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vgpd
operator|->
name|isValid
argument_list|()
condition|)
return|return;
name|VGImage
name|vgImg
init|=
name|vgpd
operator|->
name|toVGImage
argument_list|()
decl_stmt|;
if|if
condition|(
name|vgImg
operator|==
name|VG_INVALID_HANDLE
condition|)
return|return;
comment|// We cache the results of any vgChildImage() calls because the
comment|// same child is very likely to be used over and over in particle
comment|// systems.  However, performance is even better if vgChildImage()
comment|// isn't needed at all, so use full source rects where possible.
name|QVarLengthArray
argument_list|<
name|VGImage
argument_list|>
name|cachedImages
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|QRect
argument_list|>
name|cachedSources
decl_stmt|;
comment|// Select the opacity paint object.
if|if
condition|(
operator|(
name|hints
operator|&
name|QPainter
operator|::
name|OpaqueHint
operator|)
operator|!=
literal|0
operator|&&
name|d
operator|->
name|opacity
operator|==
literal|1.0f
condition|)
block|{
name|d
operator|->
name|setImageMode
argument_list|(
name|VG_DRAW_IMAGE_NORMAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hints
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fillPaint
operator|!=
name|d
operator|->
name|opacityPaint
condition|)
block|{
name|vgSetPaint
argument_list|(
name|d
operator|->
name|opacityPaint
argument_list|,
name|VG_FILL_PATH
argument_list|)
expr_stmt|;
name|d
operator|->
name|fillPaint
operator|=
name|d
operator|->
name|opacityPaint
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dataCount
condition|;
operator|++
name|i
control|)
block|{
name|QTransform
name|transform
argument_list|(
name|d
operator|->
name|imageTransform
argument_list|)
decl_stmt|;
name|transform
operator|.
name|translate
argument_list|(
name|drawingData
index|[
name|i
index|]
operator|.
name|x
argument_list|,
name|drawingData
index|[
name|i
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|transform
operator|.
name|rotate
argument_list|(
name|drawingData
index|[
name|i
index|]
operator|.
name|rotation
argument_list|)
expr_stmt|;
name|VGImage
name|child
decl_stmt|;
name|QSize
name|imageSize
init|=
name|vgpd
operator|->
name|size
argument_list|()
decl_stmt|;
name|QRectF
name|sr
argument_list|(
name|drawingData
index|[
name|i
index|]
operator|.
name|sourceLeft
argument_list|,
name|drawingData
index|[
name|i
index|]
operator|.
name|sourceTop
argument_list|,
name|drawingData
index|[
name|i
index|]
operator|.
name|width
argument_list|,
name|drawingData
index|[
name|i
index|]
operator|.
name|height
argument_list|)
decl_stmt|;
if|if
condition|(
name|sr
operator|.
name|topLeft
argument_list|()
operator|.
name|isNull
argument_list|()
operator|&&
name|sr
operator|.
name|size
argument_list|()
operator|==
name|imageSize
condition|)
block|{
name|child
operator|=
name|vgImg
expr_stmt|;
block|}
else|else
block|{
comment|// Look for a previous child with the same source rectangle
comment|// to avoid constantly calling vgChildImage()/vgDestroyImage().
name|QRect
name|src
init|=
name|sr
operator|.
name|toRect
argument_list|()
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cachedSources
operator|.
name|size
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|cachedSources
index|[
name|j
index|]
operator|==
name|src
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|<
name|cachedSources
operator|.
name|size
argument_list|()
condition|)
block|{
name|child
operator|=
name|cachedImages
index|[
name|j
index|]
expr_stmt|;
block|}
else|else
block|{
name|child
operator|=
name|vgChildImage
argument_list|(
name|vgImg
argument_list|,
name|src
operator|.
name|x
argument_list|()
argument_list|,
name|src
operator|.
name|y
argument_list|()
argument_list|,
name|src
operator|.
name|width
argument_list|()
argument_list|,
name|src
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|cachedImages
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|cachedSources
operator|.
name|append
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
block|}
name|VGfloat
name|scaleX
init|=
name|drawingData
index|[
name|i
index|]
operator|.
name|scaleX
decl_stmt|;
name|VGfloat
name|scaleY
init|=
name|drawingData
index|[
name|i
index|]
operator|.
name|scaleY
decl_stmt|;
name|transform
operator|.
name|translate
argument_list|(
operator|-
literal|0.5
operator|*
name|scaleX
operator|*
name|sr
operator|.
name|width
argument_list|()
argument_list|,
operator|-
literal|0.5
operator|*
name|scaleY
operator|*
name|sr
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|transform
operator|.
name|scale
argument_list|(
name|scaleX
argument_list|,
name|scaleY
argument_list|)
expr_stmt|;
name|d
operator|->
name|setTransform
argument_list|(
name|VG_MATRIX_IMAGE_USER_TO_SURFACE
argument_list|,
name|transform
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hints
operator|&
name|QPainter
operator|::
name|OpaqueHint
operator|)
operator|==
literal|0
condition|)
block|{
name|qreal
name|opacity
init|=
name|d
operator|->
name|opacity
operator|*
name|drawingData
index|[
name|i
index|]
operator|.
name|opacity
decl_stmt|;
if|if
condition|(
name|opacity
operator|!=
literal|1.0f
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|paintOpacity
operator|!=
name|opacity
condition|)
block|{
name|VGfloat
name|values
index|[
literal|4
index|]
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
literal|1.0f
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
literal|1.0f
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
literal|1.0f
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|opacity
expr_stmt|;
name|d
operator|->
name|paintOpacity
operator|=
name|opacity
expr_stmt|;
name|vgSetParameterfv
argument_list|(
name|d
operator|->
name|opacityPaint
argument_list|,
name|VG_PAINT_COLOR
argument_list|,
literal|4
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|setImageMode
argument_list|(
name|VG_DRAW_IMAGE_MULTIPLY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|setImageMode
argument_list|(
name|VG_DRAW_IMAGE_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
name|vgDrawImage
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
comment|// Destroy the cached child sub-images.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cachedImages
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|vgDestroyImage
argument_list|(
name|cachedImages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|QPaintEngineEx
operator|::
name|drawPixmapFragments
argument_list|(
name|drawingData
argument_list|,
name|dataCount
argument_list|,
name|pixmap
argument_list|,
name|hints
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_constructor
DECL|function|QVGFontEngineCleaner
name|QVGFontEngineCleaner
operator|::
name|QVGFontEngineCleaner
parameter_list|(
name|QVGPaintEnginePrivate
modifier|*
name|d
parameter_list|)
member_init_list|:
name|QObject
argument_list|()
member_init_list|,
name|d_ptr
argument_list|(
name|d
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QVGFontEngineCleaner
name|QVGFontEngineCleaner
operator|::
name|~
name|QVGFontEngineCleaner
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|fontEngineDestroyed
name|void
name|QVGFontEngineCleaner
operator|::
name|fontEngineDestroyed
parameter_list|()
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_DRAW_GLYPHS
argument_list|)
name|QFontEngine
modifier|*
name|engine
init|=
cast|static_cast
argument_list|<
name|QFontEngine
operator|*
argument_list|>
argument_list|(
name|sender
argument_list|()
argument_list|)
decl_stmt|;
name|QVGFontCache
operator|::
name|Iterator
name|it
init|=
name|d_ptr
operator|->
name|fontCache
operator|.
name|find
argument_list|(
name|engine
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|d_ptr
operator|->
name|fontCache
operator|.
name|end
argument_list|()
condition|)
block|{
operator|delete
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
name|d_ptr
operator|->
name|fontCache
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_DRAW_GLYPHS
argument_list|)
end_if
begin_constructor
DECL|function|QVGFontGlyphCache
name|QVGFontGlyphCache
operator|::
name|QVGFontGlyphCache
parameter_list|()
block|{
name|font
operator|=
name|vgCreateFont
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|scaleX
operator|=
name|scaleY
operator|=
literal|0.0
expr_stmt|;
name|invertedGlyphs
operator|=
literal|false
expr_stmt|;
name|memset
argument_list|(
name|cachedGlyphsMask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cachedGlyphsMask
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QVGFontGlyphCache
name|QVGFontGlyphCache
operator|::
name|~
name|QVGFontGlyphCache
parameter_list|()
block|{
if|if
condition|(
name|font
operator|!=
name|VG_INVALID_HANDLE
condition|)
name|vgDestroyFont
argument_list|(
name|font
argument_list|)
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|setScaleFromText
name|void
name|QVGFontGlyphCache
operator|::
name|setScaleFromText
parameter_list|(
specifier|const
name|QFont
modifier|&
name|font
parameter_list|,
name|QFontEngine
modifier|*
name|fontEngine
parameter_list|)
block|{
name|QFontInfo
name|fi
argument_list|(
name|font
argument_list|)
decl_stmt|;
name|qreal
name|pixelSize
init|=
name|fi
operator|.
name|pixelSize
argument_list|()
decl_stmt|;
name|qreal
name|emSquare
init|=
name|fontEngine
operator|->
name|properties
argument_list|()
operator|.
name|emSquare
operator|.
name|toReal
argument_list|()
decl_stmt|;
name|scaleX
operator|=
name|scaleY
operator|=
cast|static_cast
argument_list|<
name|VGfloat
argument_list|>
argument_list|(
name|pixelSize
operator|/
name|emSquare
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cacheGlyphs
name|void
name|QVGFontGlyphCache
operator|::
name|cacheGlyphs
parameter_list|(
name|QVGPaintEnginePrivate
modifier|*
name|d
parameter_list|,
name|QFontEngine
modifier|*
name|fontEngine
parameter_list|,
specifier|const
name|glyph_t
modifier|*
name|g
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|VGfloat
name|origin
index|[
literal|2
index|]
decl_stmt|;
name|VGfloat
name|escapement
index|[
literal|2
index|]
decl_stmt|;
name|glyph_metrics_t
name|metrics
decl_stmt|;
comment|// Some Qt font engines don't set yoff in getUnscaledGlyph().
comment|// Zero the metric structure so that everything has a default value.
name|memset
argument_list|(
operator|&
name|metrics
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|metrics
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
comment|// Skip this glyph if we have already cached it before.
name|glyph_t
name|glyph
init|=
operator|*
name|g
operator|++
decl_stmt|;
if|if
condition|(
name|glyph
operator|<
literal|256
condition|)
block|{
if|if
condition|(
operator|(
name|cachedGlyphsMask
index|[
name|glyph
operator|/
literal|32
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|glyph
operator|%
literal|32
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|cachedGlyphsMask
index|[
name|glyph
operator|/
literal|32
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|glyph
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cachedGlyphs
operator|.
name|contains
argument_list|(
name|glyph
argument_list|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|cachedGlyphs
operator|.
name|insert
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_IMAGE_GLYPHS
argument_list|)
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|QImage
name|scaledImage
init|=
name|fontEngine
operator|->
name|alphaMapForGlyph
argument_list|(
name|glyph
argument_list|)
decl_stmt|;
name|VGImage
name|vgImage
init|=
name|VG_INVALID_HANDLE
decl_stmt|;
name|metrics
operator|=
name|fontEngine
operator|->
name|boundingBox
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scaledImage
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// Not a space character
if|if
condition|(
name|scaledImage
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_Indexed8
condition|)
block|{
name|vgImage
operator|=
name|vgCreateImage
argument_list|(
name|VG_A_8
argument_list|,
name|scaledImage
operator|.
name|width
argument_list|()
argument_list|,
name|scaledImage
operator|.
name|height
argument_list|()
argument_list|,
name|VG_IMAGE_QUALITY_FASTER
argument_list|)
expr_stmt|;
name|vgImageSubData
argument_list|(
name|vgImage
argument_list|,
name|scaledImage
operator|.
name|constBits
argument_list|()
argument_list|,
name|scaledImage
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
name|VG_A_8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|scaledImage
operator|.
name|width
argument_list|()
argument_list|,
name|scaledImage
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scaledImage
operator|.
name|format
argument_list|()
operator|==
name|QImage
operator|::
name|Format_Mono
condition|)
block|{
name|QImage
name|img
init|=
name|scaledImage
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_Indexed8
argument_list|)
decl_stmt|;
name|vgImage
operator|=
name|vgCreateImage
argument_list|(
name|VG_A_8
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|,
name|VG_IMAGE_QUALITY_FASTER
argument_list|)
expr_stmt|;
name|vgImageSubData
argument_list|(
name|vgImage
argument_list|,
name|img
operator|.
name|constBits
argument_list|()
argument_list|,
name|img
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
name|VG_A_8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QImage
name|img
init|=
name|scaledImage
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
decl_stmt|;
name|vgImage
operator|=
name|vgCreateImage
argument_list|(
name|VG_sARGB_8888_PRE
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|,
name|VG_IMAGE_QUALITY_FASTER
argument_list|)
expr_stmt|;
name|vgImageSubData
argument_list|(
name|vgImage
argument_list|,
name|img
operator|.
name|constBits
argument_list|()
argument_list|,
name|img
operator|.
name|bytesPerLine
argument_list|()
argument_list|,
name|VG_sARGB_8888_PRE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|origin
index|[
literal|0
index|]
operator|=
operator|-
name|metrics
operator|.
name|x
operator|.
name|toReal
argument_list|()
expr_stmt|;
name|origin
index|[
literal|1
index|]
operator|=
operator|-
name|metrics
operator|.
name|y
operator|.
name|toReal
argument_list|()
expr_stmt|;
name|escapement
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|escapement
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|vgSetGlyphToImage
argument_list|(
name|font
argument_list|,
name|glyph
argument_list|,
name|vgImage
argument_list|,
name|origin
argument_list|,
name|escapement
argument_list|)
expr_stmt|;
name|vgDestroyImage
argument_list|(
name|vgImage
argument_list|)
expr_stmt|;
comment|// Reduce reference count.
else|#
directive|else
comment|// Calculate the path for the glyph and cache it.
name|QPainterPath
name|path
decl_stmt|;
name|fontEngine
operator|->
name|getUnscaledGlyph
argument_list|(
name|glyph
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
name|VGPath
name|vgPath
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|vgPath
operator|=
name|d
operator|->
name|painterPathToVGPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Probably a "space" character with no visible outline.
name|vgPath
operator|=
name|VG_INVALID_HANDLE
expr_stmt|;
block|}
name|origin
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|origin
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|escapement
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|escapement
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|vgSetGlyphToPath
argument_list|(
name|font
argument_list|,
name|glyph
argument_list|,
name|vgPath
argument_list|,
name|VG_FALSE
argument_list|,
name|origin
argument_list|,
name|escapement
argument_list|)
expr_stmt|;
name|vgDestroyPath
argument_list|(
name|vgPath
argument_list|)
expr_stmt|;
comment|// Reduce reference count.
endif|#
directive|endif
comment|// !defined(QVG_NO_IMAGE_GLYPHS)
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !defined(QVG_NO_DRAW_GLYPHS)
end_comment
begin_function
DECL|function|drawTextItem
name|void
name|QVGPaintEngine
operator|::
name|drawTextItem
parameter_list|(
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QTextItem
modifier|&
name|textItem
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_DRAW_GLYPHS
argument_list|)
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
specifier|const
name|QTextItemInt
modifier|&
name|ti
init|=
cast|static_cast
argument_list|<
specifier|const
name|QTextItemInt
operator|&
argument_list|>
argument_list|(
name|textItem
argument_list|)
decl_stmt|;
comment|// If we are not using a simple transform, then fall back
comment|// to the default Qt path stroking algorithm.
if|if
condition|(
operator|!
name|d
operator|->
name|simpleTransform
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawTextItem
argument_list|(
name|p
argument_list|,
name|textItem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|needsPenEmulation
argument_list|()
condition|)
block|{
name|QPaintEngineEx
operator|::
name|drawTextItem
argument_list|(
name|p
argument_list|,
name|textItem
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Get the glyphs and positions associated with the text item.
name|QVarLengthArray
argument_list|<
name|QFixedPoint
argument_list|>
name|positions
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|glyph_t
argument_list|>
name|glyphs
decl_stmt|;
name|QTransform
name|matrix
decl_stmt|;
name|ti
operator|.
name|fontEngine
operator|->
name|getGlyphPositions
argument_list|(
name|ti
operator|.
name|glyphs
argument_list|,
name|matrix
argument_list|,
name|ti
operator|.
name|flags
argument_list|,
name|glyphs
argument_list|,
name|positions
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drawCachedGlyphs
argument_list|(
name|glyphs
operator|.
name|size
argument_list|()
argument_list|,
name|glyphs
operator|.
name|data
argument_list|()
argument_list|,
name|ti
operator|.
name|font
argument_list|()
argument_list|,
name|ti
operator|.
name|fontEngine
argument_list|,
name|p
argument_list|,
name|positions
operator|.
name|data
argument_list|()
argument_list|)
condition|)
name|QPaintEngineEx
operator|::
name|drawTextItem
argument_list|(
name|p
argument_list|,
name|textItem
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// OpenGL 1.0 does not have support for VGFont and glyphs,
comment|// so fall back to the default Qt path stroking algorithm.
name|QPaintEngineEx
operator|::
name|drawTextItem
argument_list|(
name|p
argument_list|,
name|textItem
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|drawStaticTextItem
name|void
name|QVGPaintEngine
operator|::
name|drawStaticTextItem
parameter_list|(
name|QStaticTextItem
modifier|*
name|textItem
parameter_list|)
block|{
name|drawCachedGlyphs
argument_list|(
name|textItem
operator|->
name|numGlyphs
argument_list|,
name|textItem
operator|->
name|glyphs
argument_list|,
name|textItem
operator|->
name|font
argument_list|,
name|textItem
operator|->
name|fontEngine
argument_list|()
argument_list|,
name|QPointF
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|textItem
operator|->
name|glyphPositions
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|drawCachedGlyphs
name|bool
name|QVGPaintEngine
operator|::
name|drawCachedGlyphs
parameter_list|(
name|int
name|numGlyphs
parameter_list|,
specifier|const
name|glyph_t
modifier|*
name|glyphs
parameter_list|,
specifier|const
name|QFont
modifier|&
name|font
parameter_list|,
name|QFontEngine
modifier|*
name|fontEngine
parameter_list|,
specifier|const
name|QPointF
modifier|&
name|p
parameter_list|,
specifier|const
name|QFixedPoint
modifier|*
name|positions
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_DRAW_GLYPHS
argument_list|)
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
comment|// Find the glyph cache for this font.
name|QVGFontCache
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|fontCache
operator|.
name|constFind
argument_list|(
name|fontEngine
argument_list|)
decl_stmt|;
name|QVGFontGlyphCache
modifier|*
name|glyphCache
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|d
operator|->
name|fontCache
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|glyphCache
operator|=
name|it
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
name|glyphCache
operator|=
operator|new
name|QSymbianVGFontGlyphCache
argument_list|()
expr_stmt|;
else|#
directive|else
name|glyphCache
operator|=
operator|new
name|QVGFontGlyphCache
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|glyphCache
operator|->
name|font
operator|==
name|VG_INVALID_HANDLE
condition|)
block|{
name|qWarning
argument_list|(
literal|"QVGPaintEngine::drawTextItem: OpenVG fonts are not supported by the OpenVG engine"
argument_list|)
expr_stmt|;
operator|delete
name|glyphCache
expr_stmt|;
return|return
literal|false
return|;
block|}
name|glyphCache
operator|->
name|setScaleFromText
argument_list|(
name|font
argument_list|,
name|fontEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|fontCache
operator|.
name|insert
argument_list|(
name|fontEngine
argument_list|,
name|glyphCache
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|fontEngineCleaner
condition|)
name|d
operator|->
name|fontEngineCleaner
operator|=
operator|new
name|QVGFontEngineCleaner
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|fontEngine
argument_list|,
name|SIGNAL
argument_list|(
name|destroyed
argument_list|()
argument_list|)
argument_list|,
name|d
operator|->
name|fontEngineCleaner
argument_list|,
name|SLOT
argument_list|(
name|fontEngineDestroyed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Set the transformation to use for drawing the current glyphs.
name|QTransform
name|glyphTransform
argument_list|(
name|d
operator|->
name|pathTransform
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|transform
operator|.
name|type
argument_list|()
operator|<=
name|QTransform
operator|::
name|TxTranslate
condition|)
block|{
comment|// Prevent blurriness of unscaled, unrotated text by forcing integer coordinates.
name|glyphTransform
operator|.
name|translate
argument_list|(
name|floor
argument_list|(
name|p
operator|.
name|x
argument_list|()
operator|+
name|glyphTransform
operator|.
name|dx
argument_list|()
operator|+
name|aliasedCoordinateDelta
argument_list|)
operator|-
name|glyphTransform
operator|.
name|dx
argument_list|()
argument_list|,
name|floor
argument_list|(
name|p
operator|.
name|y
argument_list|()
operator|-
name|glyphTransform
operator|.
name|dy
argument_list|()
operator|+
name|aliasedCoordinateDelta
argument_list|)
operator|+
name|glyphTransform
operator|.
name|dy
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glyphTransform
operator|.
name|translate
argument_list|(
name|p
operator|.
name|x
argument_list|()
argument_list|,
name|p
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QVG_NO_IMAGE_GLYPHS
argument_list|)
name|glyphTransform
operator|.
name|scale
argument_list|(
name|glyphCache
operator|->
name|scaleX
argument_list|,
name|glyphCache
operator|->
name|scaleY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Some glyph caches can create the VGImage upright
if|if
condition|(
name|glyphCache
operator|->
name|invertedGlyphs
condition|)
name|glyphTransform
operator|.
name|scale
argument_list|(
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|setTransform
argument_list|(
name|VG_MATRIX_GLYPH_USER_TO_SURFACE
argument_list|,
name|glyphTransform
argument_list|)
expr_stmt|;
comment|// Add the glyphs from the text item into the glyph cache.
name|glyphCache
operator|->
name|cacheGlyphs
argument_list|(
name|d
argument_list|,
name|fontEngine
argument_list|,
name|glyphs
argument_list|,
name|numGlyphs
argument_list|)
expr_stmt|;
comment|// Create the array of adjustments between glyphs
name|QVarLengthArray
argument_list|<
name|VGfloat
argument_list|>
name|adjustments_x
argument_list|(
name|numGlyphs
argument_list|)
decl_stmt|;
name|QVarLengthArray
argument_list|<
name|VGfloat
argument_list|>
name|adjustments_y
argument_list|(
name|numGlyphs
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numGlyphs
condition|;
operator|++
name|i
control|)
block|{
name|adjustments_x
index|[
name|i
operator|-
literal|1
index|]
operator|=
operator|(
name|positions
index|[
name|i
index|]
operator|.
name|x
operator|-
name|positions
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|x
operator|)
operator|.
name|round
argument_list|()
operator|.
name|toReal
argument_list|()
expr_stmt|;
name|adjustments_y
index|[
name|i
operator|-
literal|1
index|]
operator|=
operator|(
name|positions
index|[
name|i
index|]
operator|.
name|y
operator|-
name|positions
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|y
operator|)
operator|.
name|round
argument_list|()
operator|.
name|toReal
argument_list|()
expr_stmt|;
block|}
comment|// Set the glyph drawing origin.
name|VGfloat
name|origin
index|[
literal|2
index|]
decl_stmt|;
name|origin
index|[
literal|0
index|]
operator|=
name|positions
index|[
literal|0
index|]
operator|.
name|x
operator|.
name|round
argument_list|()
operator|.
name|toReal
argument_list|()
expr_stmt|;
name|origin
index|[
literal|1
index|]
operator|=
name|positions
index|[
literal|0
index|]
operator|.
name|y
operator|.
name|round
argument_list|()
operator|.
name|toReal
argument_list|()
expr_stmt|;
name|vgSetfv
argument_list|(
name|VG_GLYPH_ORIGIN
argument_list|,
literal|2
argument_list|,
name|origin
argument_list|)
expr_stmt|;
comment|// Fast anti-aliasing for paths, better for images.
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_IMAGE_GLYPHS
argument_list|)
name|d
operator|->
name|setImageQuality
argument_list|(
name|VG_IMAGE_QUALITY_BETTER
argument_list|)
expr_stmt|;
name|d
operator|->
name|setImageMode
argument_list|(
name|VG_DRAW_IMAGE_STENCIL
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|setRenderingQuality
argument_list|(
name|VG_RENDERING_QUALITY_FASTER
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Draw the glyphs.  We need to fill with the brush associated with
comment|// the Qt pen, not the Qt brush.
name|d
operator|->
name|ensureBrush
argument_list|(
name|state
argument_list|()
operator|->
name|pen
operator|.
name|brush
argument_list|()
argument_list|)
expr_stmt|;
name|vgDrawGlyphs
argument_list|(
name|glyphCache
operator|->
name|font
argument_list|,
name|numGlyphs
argument_list|,
operator|(
name|VGuint
operator|*
operator|)
name|glyphs
argument_list|,
name|adjustments_x
operator|.
name|data
argument_list|()
argument_list|,
name|adjustments_y
operator|.
name|data
argument_list|()
argument_list|,
name|VG_FILL_PATH
argument_list|,
name|VG_TRUE
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|numGlyphs
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|glyphs
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|font
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|fontEngine
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|positions
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|setState
name|void
name|QVGPaintEngine
operator|::
name|setState
parameter_list|(
name|QPainterState
modifier|*
name|s
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
name|QPaintEngineEx
operator|::
name|setState
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|QVGPainterState
modifier|*
name|ps
init|=
cast|static_cast
argument_list|<
name|QVGPainterState
operator|*
argument_list|>
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|isNew
condition|)
block|{
comment|// Newly created state object.  The call to setState()
comment|// will either be followed by a call to begin(), or we are
comment|// setting the state as part of a save().
name|ps
operator|->
name|isNew
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// This state object was set as part of a restore().
name|restoreState
argument_list|(
name|d
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirty
operator|=
name|ps
operator|->
name|savedDirty
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|beginNativePainting
name|void
name|QVGPaintEngine
operator|::
name|beginNativePainting
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
comment|// About to enter raw VG mode: flush pending changes and make
comment|// sure that all matrices are set to the current transformation.
name|QVGPainterState
modifier|*
name|s
init|=
name|this
operator|->
name|state
argument_list|()
decl_stmt|;
name|d
operator|->
name|ensurePen
argument_list|(
name|s
operator|->
name|pen
argument_list|)
expr_stmt|;
name|d
operator|->
name|ensureBrush
argument_list|(
name|s
operator|->
name|brush
argument_list|)
expr_stmt|;
name|d
operator|->
name|ensurePathTransform
argument_list|()
expr_stmt|;
name|d
operator|->
name|setTransform
argument_list|(
name|VG_MATRIX_IMAGE_USER_TO_SURFACE
argument_list|,
name|d
operator|->
name|imageTransform
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_DRAW_GLYPHS
argument_list|)
name|d
operator|->
name|setTransform
argument_list|(
name|VG_MATRIX_GLYPH_USER_TO_SURFACE
argument_list|,
name|d
operator|->
name|pathTransform
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vgSeti
argument_list|(
name|VG_SCISSORING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_MASKING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|d
operator|->
name|rawVG
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|endNativePainting
name|void
name|QVGPaintEngine
operator|::
name|endNativePainting
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
comment|// Exiting raw VG mode: force all state values to be
comment|// explicitly set on the VG engine to undo any changes
comment|// that were made by the raw VG function calls.
name|QPaintEngine
operator|::
name|DirtyFlags
name|dirty
init|=
name|d
operator|->
name|dirty
decl_stmt|;
name|d
operator|->
name|clearModes
argument_list|()
expr_stmt|;
name|d
operator|->
name|forcePenChange
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|forceBrushChange
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|penType
operator|=
operator|(
name|VGPaintType
operator|)
literal|0
expr_stmt|;
name|d
operator|->
name|brushType
operator|=
operator|(
name|VGPaintType
operator|)
literal|0
expr_stmt|;
name|d
operator|->
name|clearColor
operator|=
name|QColor
argument_list|()
expr_stmt|;
name|d
operator|->
name|fillPaint
operator|=
name|d
operator|->
name|brushPaint
expr_stmt|;
name|d
operator|->
name|scissorDirty
operator|=
literal|true
expr_stmt|;
name|restoreState
argument_list|(
name|QPaintEngine
operator|::
name|AllDirty
argument_list|)
expr_stmt|;
name|d
operator|->
name|dirty
operator|=
name|dirty
expr_stmt|;
name|d
operator|->
name|rawVG
operator|=
literal|false
expr_stmt|;
name|vgSetPaint
argument_list|(
name|d
operator|->
name|penPaint
argument_list|,
name|VG_STROKE_PATH
argument_list|)
expr_stmt|;
name|vgSetPaint
argument_list|(
name|d
operator|->
name|brushPaint
argument_list|,
name|VG_FILL_PATH
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pixmapFilter
name|QPixmapFilter
modifier|*
name|QVGPaintEngine
operator|::
name|pixmapFilter
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|QPixmapFilter
modifier|*
name|prototype
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_SHIVAVG
argument_list|)
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QPixmapFilter
operator|::
name|ConvolutionFilter
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|convolutionFilter
condition|)
name|d
operator|->
name|convolutionFilter
operator|.
name|reset
argument_list|(
operator|new
name|QVGPixmapConvolutionFilter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|convolutionFilter
operator|.
name|data
argument_list|()
return|;
case|case
name|QPixmapFilter
operator|::
name|ColorizeFilter
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|colorizeFilter
condition|)
name|d
operator|->
name|colorizeFilter
operator|.
name|reset
argument_list|(
operator|new
name|QVGPixmapColorizeFilter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|colorizeFilter
operator|.
name|data
argument_list|()
return|;
case|case
name|QPixmapFilter
operator|::
name|DropShadowFilter
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|dropShadowFilter
condition|)
name|d
operator|->
name|dropShadowFilter
operator|.
name|reset
argument_list|(
operator|new
name|QVGPixmapDropShadowFilter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|dropShadowFilter
operator|.
name|data
argument_list|()
return|;
case|case
name|QPixmapFilter
operator|::
name|BlurFilter
case|:
if|if
condition|(
operator|!
name|d
operator|->
name|blurFilter
condition|)
name|d
operator|->
name|blurFilter
operator|.
name|reset
argument_list|(
operator|new
name|QVGPixmapBlurFilter
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|blurFilter
operator|.
name|data
argument_list|()
return|;
default|default:
break|break;
block|}
endif|#
directive|endif
return|return
name|QPaintEngineEx
operator|::
name|pixmapFilter
argument_list|(
name|type
argument_list|,
name|prototype
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|restoreState
name|void
name|QVGPaintEngine
operator|::
name|restoreState
parameter_list|(
name|QPaintEngine
operator|::
name|DirtyFlags
name|dirty
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
comment|// Restore the pen, brush, and other settings.
if|if
condition|(
operator|(
name|dirty
operator|&
name|QPaintEngine
operator|::
name|DirtyBrushOrigin
operator|)
operator|!=
literal|0
condition|)
name|brushOriginChanged
argument_list|()
expr_stmt|;
name|d
operator|->
name|fillRule
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|clearColor
operator|=
name|QColor
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|dirty
operator|&
name|QPaintEngine
operator|::
name|DirtyOpacity
operator|)
operator|!=
literal|0
condition|)
name|opacityChanged
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|dirty
operator|&
name|QPaintEngine
operator|::
name|DirtyTransform
operator|)
operator|!=
literal|0
condition|)
name|transformChanged
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|dirty
operator|&
name|QPaintEngine
operator|::
name|DirtyCompositionMode
operator|)
operator|!=
literal|0
condition|)
name|compositionModeChanged
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|dirty
operator|&
name|QPaintEngine
operator|::
name|DirtyHints
operator|)
operator|!=
literal|0
condition|)
name|renderHintsChanged
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|dirty
operator|&
operator|(
name|QPaintEngine
operator|::
name|DirtyClipRegion
operator||
name|QPaintEngine
operator|::
name|DirtyClipPath
operator||
name|QPaintEngine
operator|::
name|DirtyClipEnabled
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|d
operator|->
name|maskValid
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskIsSet
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorMask
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|maskRect
operator|=
name|QRect
argument_list|()
expr_stmt|;
name|d
operator|->
name|scissorDirty
operator|=
literal|true
expr_stmt|;
name|clipEnabledChanged
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QVG_SCISSOR_CLIP
argument_list|)
if|if
condition|(
operator|(
name|dirty
operator|&
operator|(
name|QPaintEngine
operator|::
name|DirtyClipRegion
operator||
name|QPaintEngine
operator|::
name|DirtyClipPath
operator||
name|QPaintEngine
operator|::
name|DirtyClipEnabled
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|updateScissor
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
name|updateScissor
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|fillRegion
name|void
name|QVGPaintEngine
operator|::
name|fillRegion
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|,
specifier|const
name|QColor
modifier|&
name|color
parameter_list|,
specifier|const
name|QSize
modifier|&
name|surfaceSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QVGPaintEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|clearColor
operator|!=
name|color
operator|||
name|d
operator|->
name|clearOpacity
operator|!=
literal|1.0f
condition|)
block|{
name|VGfloat
name|values
index|[
literal|4
index|]
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
name|color
operator|.
name|redF
argument_list|()
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
name|color
operator|.
name|greenF
argument_list|()
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
name|color
operator|.
name|blueF
argument_list|()
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|color
operator|.
name|alphaF
argument_list|()
expr_stmt|;
name|vgSetfv
argument_list|(
name|VG_CLEAR_COLOR
argument_list|,
literal|4
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|d
operator|->
name|clearColor
operator|=
name|color
expr_stmt|;
name|d
operator|->
name|clearOpacity
operator|=
literal|1.0f
expr_stmt|;
block|}
if|if
condition|(
name|region
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|QRect
name|r
init|=
name|region
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
name|vgClear
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|surfaceSize
operator|.
name|height
argument_list|()
operator|-
name|r
operator|.
name|y
argument_list|()
operator|-
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QRect
name|r
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|vgClear
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|surfaceSize
operator|.
name|height
argument_list|()
operator|-
name|r
operator|.
name|y
argument_list|()
operator|-
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_SINGLE_CONTEXT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|QT_NO_EGL
argument_list|)
end_if
begin_constructor
DECL|function|QVGCompositionHelper
name|QVGCompositionHelper
operator|::
name|QVGCompositionHelper
parameter_list|()
block|{
name|d
operator|=
name|qt_vg_create_paint_engine
argument_list|()
operator|->
name|vgPrivate
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QVGCompositionHelper
name|QVGCompositionHelper
operator|::
name|~
name|QVGCompositionHelper
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|startCompositing
name|void
name|QVGCompositionHelper
operator|::
name|startCompositing
parameter_list|(
specifier|const
name|QSize
modifier|&
name|screenSize
parameter_list|)
block|{
name|this
operator|->
name|screenSize
operator|=
name|screenSize
expr_stmt|;
name|clearScissor
argument_list|()
expr_stmt|;
name|d
operator|->
name|setBlendMode
argument_list|(
name|VG_BLEND_SRC_OVER
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|endCompositing
name|void
name|QVGCompositionHelper
operator|::
name|endCompositing
parameter_list|()
block|{
name|clearScissor
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|blitWindow
name|void
name|QVGCompositionHelper
operator|::
name|blitWindow
parameter_list|(
name|VGImage
name|image
parameter_list|,
specifier|const
name|QSize
modifier|&
name|imageSize
parameter_list|,
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|topLeft
parameter_list|,
name|int
name|opacity
parameter_list|)
block|{
if|if
condition|(
name|image
operator|==
name|VG_INVALID_HANDLE
condition|)
return|return;
comment|// Determine which sub rectangle of the window to draw.
name|QRect
name|sr
init|=
name|rect
operator|.
name|translated
argument_list|(
operator|-
name|topLeft
argument_list|)
decl_stmt|;
if|if
condition|(
name|opacity
operator|>=
literal|255
condition|)
block|{
comment|// Fully opaque: use vgSetPixels() to directly copy the sub-region.
name|int
name|y
init|=
name|screenSize
operator|.
name|height
argument_list|()
operator|-
operator|(
name|rect
operator|.
name|bottom
argument_list|()
operator|+
literal|1
operator|)
decl_stmt|;
name|vgSetPixels
argument_list|(
name|rect
operator|.
name|x
argument_list|()
argument_list|,
name|y
argument_list|,
name|image
argument_list|,
name|sr
operator|.
name|x
argument_list|()
argument_list|,
name|imageSize
operator|.
name|height
argument_list|()
operator|-
operator|(
name|sr
operator|.
name|y
argument_list|()
operator|+
name|sr
operator|.
name|height
argument_list|()
operator|)
argument_list|,
name|sr
operator|.
name|width
argument_list|()
argument_list|,
name|sr
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Extract the child image that we want to draw.
name|VGImage
name|child
decl_stmt|;
if|if
condition|(
name|sr
operator|.
name|topLeft
argument_list|()
operator|.
name|isNull
argument_list|()
operator|&&
name|sr
operator|.
name|size
argument_list|()
operator|==
name|imageSize
condition|)
name|child
operator|=
name|image
expr_stmt|;
else|else
block|{
name|child
operator|=
name|vgChildImage
argument_list|(
name|image
argument_list|,
name|sr
operator|.
name|x
argument_list|()
argument_list|,
name|imageSize
operator|.
name|height
argument_list|()
operator|-
operator|(
name|sr
operator|.
name|y
argument_list|()
operator|+
name|sr
operator|.
name|height
argument_list|()
operator|)
argument_list|,
name|sr
operator|.
name|width
argument_list|()
argument_list|,
name|sr
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Set the image transform.
name|QTransform
name|transform
decl_stmt|;
name|int
name|y
init|=
name|screenSize
operator|.
name|height
argument_list|()
operator|-
operator|(
name|rect
operator|.
name|bottom
argument_list|()
operator|+
literal|1
operator|)
decl_stmt|;
name|transform
operator|.
name|translate
argument_list|(
name|rect
operator|.
name|x
argument_list|()
operator|-
literal|0.5f
argument_list|,
name|y
operator|-
literal|0.5f
argument_list|)
expr_stmt|;
name|d
operator|->
name|setTransform
argument_list|(
name|VG_MATRIX_IMAGE_USER_TO_SURFACE
argument_list|,
name|transform
argument_list|)
expr_stmt|;
comment|// Enable opacity for image drawing if necessary.
if|if
condition|(
name|opacity
operator|!=
name|d
operator|->
name|paintOpacity
condition|)
block|{
name|VGfloat
name|values
index|[
literal|4
index|]
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
literal|1.0f
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
literal|1.0f
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
literal|1.0f
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|VGfloat
operator|)
name|opacity
operator|)
operator|/
literal|255.0f
expr_stmt|;
name|vgSetParameterfv
argument_list|(
name|d
operator|->
name|opacityPaint
argument_list|,
name|VG_PAINT_COLOR
argument_list|,
literal|4
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|d
operator|->
name|paintOpacity
operator|=
name|values
index|[
literal|3
index|]
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|fillPaint
operator|!=
name|d
operator|->
name|opacityPaint
condition|)
block|{
name|vgSetPaint
argument_list|(
name|d
operator|->
name|opacityPaint
argument_list|,
name|VG_FILL_PATH
argument_list|)
expr_stmt|;
name|d
operator|->
name|fillPaint
operator|=
name|d
operator|->
name|opacityPaint
expr_stmt|;
block|}
name|d
operator|->
name|setImageMode
argument_list|(
name|VG_DRAW_IMAGE_MULTIPLY
argument_list|)
expr_stmt|;
comment|// Draw the child image.
name|vgDrawImage
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|// Destroy the child image.
if|if
condition|(
name|child
operator|!=
name|image
condition|)
name|vgDestroyImage
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|fillBackgroundRect
specifier|static
name|void
name|fillBackgroundRect
parameter_list|(
specifier|const
name|QRect
modifier|&
name|rect
parameter_list|,
name|QVGPaintEnginePrivate
modifier|*
name|d
parameter_list|)
block|{
name|VGfloat
name|coords
index|[
literal|8
index|]
decl_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
name|rect
operator|.
name|x
argument_list|()
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|rect
operator|.
name|y
argument_list|()
expr_stmt|;
name|coords
index|[
literal|2
index|]
operator|=
name|rect
operator|.
name|x
argument_list|()
operator|+
name|rect
operator|.
name|width
argument_list|()
expr_stmt|;
name|coords
index|[
literal|3
index|]
operator|=
name|coords
index|[
literal|1
index|]
expr_stmt|;
name|coords
index|[
literal|4
index|]
operator|=
name|coords
index|[
literal|2
index|]
expr_stmt|;
name|coords
index|[
literal|5
index|]
operator|=
name|rect
operator|.
name|y
argument_list|()
operator|+
name|rect
operator|.
name|height
argument_list|()
expr_stmt|;
name|coords
index|[
literal|6
index|]
operator|=
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|coords
index|[
literal|7
index|]
operator|=
name|coords
index|[
literal|5
index|]
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QVG_NO_MODIFY_PATH
argument_list|)
name|vgModifyPathCoords
argument_list|(
name|d
operator|->
name|rectPath
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|coords
argument_list|)
expr_stmt|;
name|vgDrawPath
argument_list|(
name|d
operator|->
name|rectPath
argument_list|,
name|VG_FILL_PATH
argument_list|)
expr_stmt|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|VGPath
name|rectPath
init|=
name|vgCreatePath
argument_list|(
name|VG_PATH_FORMAT_STANDARD
argument_list|,
name|VG_PATH_DATATYPE_F
argument_list|,
literal|1.0f
argument_list|,
comment|// scale
literal|0.0f
argument_list|,
comment|// bias
literal|5
argument_list|,
comment|// segmentCapacityHint
literal|8
argument_list|,
comment|// coordCapacityHint
name|VG_PATH_CAPABILITY_ALL
argument_list|)
decl_stmt|;
specifier|static
name|VGubyte
specifier|const
name|segments
index|[
literal|5
index|]
init|=
block|{
name|VG_MOVE_TO_ABS
block|,
name|VG_LINE_TO_ABS
block|,
name|VG_LINE_TO_ABS
block|,
name|VG_LINE_TO_ABS
block|,
name|VG_CLOSE_PATH
block|}
decl_stmt|;
name|vgAppendPathData
argument_list|(
name|rectPath
argument_list|,
literal|5
argument_list|,
name|segments
argument_list|,
name|coords
argument_list|)
expr_stmt|;
name|vgDrawPath
argument_list|(
name|rectPath
argument_list|,
name|VG_FILL_PATH
argument_list|)
expr_stmt|;
name|vgDestroyPath
argument_list|(
name|rectPath
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|fillBackground
name|void
name|QVGCompositionHelper
operator|::
name|fillBackground
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|,
specifier|const
name|QBrush
modifier|&
name|brush
parameter_list|)
block|{
if|if
condition|(
name|brush
operator|.
name|style
argument_list|()
operator|==
name|Qt
operator|::
name|SolidPattern
condition|)
block|{
comment|// Use vgClear() to quickly fill the background.
name|QColor
name|color
init|=
name|brush
operator|.
name|color
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|clearColor
operator|!=
name|color
operator|||
name|d
operator|->
name|clearOpacity
operator|!=
literal|1.0f
condition|)
block|{
name|VGfloat
name|values
index|[
literal|4
index|]
decl_stmt|;
name|values
index|[
literal|0
index|]
operator|=
name|color
operator|.
name|redF
argument_list|()
expr_stmt|;
name|values
index|[
literal|1
index|]
operator|=
name|color
operator|.
name|greenF
argument_list|()
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
name|color
operator|.
name|blueF
argument_list|()
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|color
operator|.
name|alphaF
argument_list|()
expr_stmt|;
name|vgSetfv
argument_list|(
name|VG_CLEAR_COLOR
argument_list|,
literal|4
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|d
operator|->
name|clearColor
operator|=
name|color
expr_stmt|;
name|d
operator|->
name|clearOpacity
operator|=
literal|1.0f
expr_stmt|;
block|}
if|if
condition|(
name|region
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|QRect
name|r
init|=
name|region
operator|.
name|boundingRect
argument_list|()
decl_stmt|;
name|vgClear
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|screenSize
operator|.
name|height
argument_list|()
operator|-
name|r
operator|.
name|y
argument_list|()
operator|-
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|QRect
name|r
init|=
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|vgClear
argument_list|(
name|r
operator|.
name|x
argument_list|()
argument_list|,
name|screenSize
operator|.
name|height
argument_list|()
operator|-
name|r
operator|.
name|y
argument_list|()
operator|-
name|r
operator|.
name|height
argument_list|()
argument_list|,
name|r
operator|.
name|width
argument_list|()
argument_list|,
name|r
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// Set the path transform to the default viewport transformation.
name|VGfloat
name|devh
init|=
name|screenSize
operator|.
name|height
argument_list|()
decl_stmt|;
name|QTransform
name|viewport
argument_list|(
literal|1.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
operator|-
literal|1.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
name|devh
argument_list|,
literal|1.0f
argument_list|)
decl_stmt|;
name|d
operator|->
name|setTransform
argument_list|(
name|VG_MATRIX_PATH_USER_TO_SURFACE
argument_list|,
name|viewport
argument_list|)
expr_stmt|;
comment|// Set the brush to use to fill the background.
name|d
operator|->
name|ensureBrush
argument_list|(
name|brush
argument_list|)
expr_stmt|;
name|d
operator|->
name|setFillRule
argument_list|(
name|VG_EVEN_ODD
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|.
name|rectCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|fillBackgroundRect
argument_list|(
name|region
operator|.
name|boundingRect
argument_list|()
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rects
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
name|fillBackgroundRect
argument_list|(
name|rects
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
comment|// We will need to reset the path transform during the next paint.
name|d
operator|->
name|pathTransformSet
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|drawCursorPixmap
name|void
name|QVGCompositionHelper
operator|::
name|drawCursorPixmap
parameter_list|(
specifier|const
name|QPixmap
modifier|&
name|pixmap
parameter_list|,
specifier|const
name|QPoint
modifier|&
name|offset
parameter_list|)
block|{
name|VGImage
name|vgImage
init|=
name|VG_INVALID_HANDLE
decl_stmt|;
comment|// Fetch the VGImage from the pixmap if possible.
name|QPixmapData
modifier|*
name|pd
init|=
name|pixmap
operator|.
name|pixmapData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pd
condition|)
return|return;
comment|// null QPixmap
if|if
condition|(
name|pd
operator|->
name|classId
argument_list|()
operator|==
name|QPixmapData
operator|::
name|OpenVGClass
condition|)
block|{
name|QVGPixmapData
modifier|*
name|vgpd
init|=
cast|static_cast
argument_list|<
name|QVGPixmapData
operator|*
argument_list|>
argument_list|(
name|pd
argument_list|)
decl_stmt|;
if|if
condition|(
name|vgpd
operator|->
name|isValid
argument_list|()
condition|)
name|vgImage
operator|=
name|vgpd
operator|->
name|toVGImage
argument_list|()
expr_stmt|;
block|}
comment|// Set the image transformation and modes.
name|VGfloat
name|devh
init|=
name|screenSize
operator|.
name|height
argument_list|()
decl_stmt|;
name|QTransform
name|transform
argument_list|(
literal|1.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
operator|-
literal|1.0f
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
name|devh
argument_list|,
literal|1.0f
argument_list|)
decl_stmt|;
name|transform
operator|.
name|translate
argument_list|(
name|offset
operator|.
name|x
argument_list|()
argument_list|,
name|offset
operator|.
name|y
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|setTransform
argument_list|(
name|VG_MATRIX_IMAGE_USER_TO_SURFACE
argument_list|,
name|transform
argument_list|)
expr_stmt|;
name|d
operator|->
name|setImageMode
argument_list|(
name|VG_DRAW_IMAGE_NORMAL
argument_list|)
expr_stmt|;
comment|// Draw the VGImage.
if|if
condition|(
name|vgImage
operator|!=
name|VG_INVALID_HANDLE
condition|)
block|{
name|vgDrawImage
argument_list|(
name|vgImage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QImage
name|img
init|=
name|pixmap
operator|.
name|toImage
argument_list|()
operator|.
name|convertToFormat
argument_list|(
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
argument_list|)
decl_stmt|;
name|vgImage
operator|=
name|vgCreateImage
argument_list|(
name|VG_sARGB_8888_PRE
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|,
name|VG_IMAGE_QUALITY_FASTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|vgImage
operator|==
name|VG_INVALID_HANDLE
condition|)
return|return;
name|vgImageSubData
argument_list|(
name|vgImage
argument_list|,
name|img
operator|.
name|constBits
argument_list|()
operator|+
name|img
operator|.
name|bytesPerLine
argument_list|()
operator|*
operator|(
name|img
operator|.
name|height
argument_list|()
operator|-
literal|1
operator|)
argument_list|,
operator|-
operator|(
name|img
operator|.
name|bytesPerLine
argument_list|()
operator|)
argument_list|,
name|VG_sARGB_8888_PRE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|img
operator|.
name|width
argument_list|()
argument_list|,
name|img
operator|.
name|height
argument_list|()
argument_list|)
expr_stmt|;
name|vgDrawImage
argument_list|(
name|vgImage
argument_list|)
expr_stmt|;
name|vgDestroyImage
argument_list|(
name|vgImage
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setScissor
name|void
name|QVGCompositionHelper
operator|::
name|setScissor
parameter_list|(
specifier|const
name|QRegion
modifier|&
name|region
parameter_list|)
block|{
name|QVector
argument_list|<
name|QRect
argument_list|>
name|rects
init|=
name|region
operator|.
name|rects
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|rects
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|>
name|d
operator|->
name|maxScissorRects
condition|)
name|count
operator|=
name|d
operator|->
name|maxScissorRects
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|VGint
argument_list|>
name|params
argument_list|(
name|count
operator|*
literal|4
argument_list|)
decl_stmt|;
name|int
name|height
init|=
name|screenSize
operator|.
name|height
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|params
index|[
name|i
operator|*
literal|4
operator|+
literal|0
index|]
operator|=
name|rects
index|[
name|i
index|]
operator|.
name|x
argument_list|()
expr_stmt|;
name|params
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|=
name|height
operator|-
name|rects
index|[
name|i
index|]
operator|.
name|y
argument_list|()
operator|-
name|rects
index|[
name|i
index|]
operator|.
name|height
argument_list|()
expr_stmt|;
name|params
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|=
name|rects
index|[
name|i
index|]
operator|.
name|width
argument_list|()
expr_stmt|;
name|params
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
operator|=
name|rects
index|[
name|i
index|]
operator|.
name|height
argument_list|()
expr_stmt|;
block|}
name|vgSetiv
argument_list|(
name|VG_SCISSOR_RECTS
argument_list|,
name|count
operator|*
literal|4
argument_list|,
name|params
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|vgSeti
argument_list|(
name|VG_SCISSORING
argument_list|,
name|VG_TRUE
argument_list|)
expr_stmt|;
name|d
operator|->
name|scissorDirty
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorActive
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|scissorRegion
operator|=
name|region
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clearScissor
name|void
name|QVGCompositionHelper
operator|::
name|clearScissor
parameter_list|()
block|{
if|if
condition|(
name|d
operator|->
name|scissorActive
operator|||
name|d
operator|->
name|scissorDirty
condition|)
block|{
name|vgSeti
argument_list|(
name|VG_SCISSORING
argument_list|,
name|VG_FALSE
argument_list|)
expr_stmt|;
name|d
operator|->
name|scissorActive
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|scissorDirty
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// !QVG_NO_SINGLE_CONTEXT&& !QT_NO_EGL
end_comment
begin_function
DECL|function|qt_vg_image_to_vg_format
name|VGImageFormat
name|qt_vg_image_to_vg_format
parameter_list|(
name|QImage
operator|::
name|Format
name|format
parameter_list|)
block|{
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|QImage
operator|::
name|Format_MonoLSB
case|:
return|return
name|VG_BW_1
return|;
case|case
name|QImage
operator|::
name|Format_Indexed8
case|:
return|return
name|VG_sL_8
return|;
case|case
name|QImage
operator|::
name|Format_ARGB32_Premultiplied
case|:
return|return
name|VG_sARGB_8888_PRE
return|;
case|case
name|QImage
operator|::
name|Format_RGB32
case|:
return|return
name|VG_sXRGB_8888
return|;
case|case
name|QImage
operator|::
name|Format_ARGB32
case|:
return|return
name|VG_sARGB_8888
return|;
case|case
name|QImage
operator|::
name|Format_RGB16
case|:
return|return
name|VG_sRGB_565
return|;
case|case
name|QImage
operator|::
name|Format_ARGB4444_Premultiplied
case|:
return|return
name|VG_sARGB_4444
return|;
default|default:
break|break;
block|}
return|return
name|VG_sARGB_8888
return|;
comment|// XXX
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"qpaintengine_vg.moc"
end_include
end_unit
