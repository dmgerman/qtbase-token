begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtCore module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QTCONCURRENT_REDUCEKERNEL_H
end_ifndef
begin_define
DECL|macro|QTCONCURRENT_REDUCEKERNEL_H
define|#
directive|define
name|QTCONCURRENT_REDUCEKERNEL_H
end_define
begin_include
include|#
directive|include
file|<QtConcurrent/qtconcurrent_global.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_CONCURRENT
end_ifndef
begin_include
include|#
directive|include
file|<QtCore/qatomic.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qlist.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmap.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmutex.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qthread.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qthreadpool.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvector.h>
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|namespace
name|QtConcurrent
block|{
ifndef|#
directive|ifndef
name|Q_QDOC
comment|/*     The ReduceQueueStartLimit and ReduceQueueThrottleLimit constants     limit the reduce queue size for MapReduce. When the number of     reduce blocks in the queue exceeds ReduceQueueStartLimit,     MapReduce won't start any new threads, and when it exceeds     ReduceQueueThrottleLimit running threads will be stopped. */
enum|enum
block|{
name|ReduceQueueStartLimit
init|=
literal|20
block|,
name|ReduceQueueThrottleLimit
init|=
literal|30
block|}
enum|;
comment|// IntermediateResults holds a block of intermediate results from a
comment|// map or filter functor. The begin/end offsets indicates the origin
comment|// and range of the block.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|IntermediateResults
block|{
name|public
operator|:
name|int
name|begin
block|,
name|end
block|;
name|QVector
operator|<
name|T
operator|>
name|vector
block|; }
expr_stmt|;
endif|#
directive|endif
comment|// Q_QDOC
enum|enum
name|ReduceOption
block|{
name|UnorderedReduce
init|=
literal|0x1
block|,
name|OrderedReduce
init|=
literal|0x2
block|,
name|SequentialReduce
init|=
literal|0x4
comment|// ParallelReduce = 0x8
block|}
enum|;
name|Q_DECLARE_FLAGS
argument_list|(
argument|ReduceOptions
argument_list|,
argument|ReduceOption
argument_list|)
name|Q_DECLARE_OPERATORS_FOR_FLAGS
argument_list|(
argument|ReduceOptions
argument_list|)
ifndef|#
directive|ifndef
name|Q_QDOC
comment|// supports both ordered and out-of-order reduction
name|template
operator|<
name|typename
name|ReduceFunctor
operator|,
name|typename
name|ReduceResultType
operator|,
name|typename
name|T
operator|>
name|class
name|ReduceKernel
block|{
typedef|typedef
name|QMap
operator|<
name|int
operator|,
name|IntermediateResults
operator|<
name|T
operator|>
expr|>
name|ResultsMap
expr_stmt|;
specifier|const
name|ReduceOptions
name|reduceOptions
expr_stmt|;
name|QMutex
name|mutex
decl_stmt|;
name|int
name|progress
decl_stmt|,
name|resultsMapSize
decl_stmt|,
name|threadCount
decl_stmt|;
name|ResultsMap
name|resultsMap
decl_stmt|;
name|bool
name|canReduce
argument_list|(
name|int
name|begin
argument_list|)
decl|const
block|{
return|return
operator|(
operator|(
operator|(
name|reduceOptions
operator|&
name|UnorderedReduce
operator|)
operator|&&
name|progress
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|reduceOptions
operator|&
name|OrderedReduce
operator|)
operator|&&
name|progress
operator|==
name|begin
operator|)
operator|)
return|;
block|}
name|void
name|reduceResult
argument_list|(
name|ReduceFunctor
operator|&
name|reduce
argument_list|,
name|ReduceResultType
operator|&
name|r
argument_list|,
specifier|const
name|IntermediateResults
operator|<
name|T
operator|>
operator|&
name|result
argument_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|result
operator|.
name|vector
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|reduce
argument_list|(
name|r
argument_list|,
name|result
operator|.
name|vector
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|reduceResults
parameter_list|(
name|ReduceFunctor
modifier|&
name|reduce
parameter_list|,
name|ReduceResultType
modifier|&
name|r
parameter_list|,
name|ResultsMap
modifier|&
name|map
parameter_list|)
block|{
name|typename
name|ResultsMap
operator|::
name|iterator
name|it
operator|=
name|map
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|!=
name|map
operator|.
name|end
argument_list|()
condition|)
block|{
name|reduceResult
argument_list|(
name|reduce
argument_list|,
name|r
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
block|}
name|public
label|:
name|ReduceKernel
argument_list|(
argument|ReduceOptions _reduceOptions
argument_list|)
block|:
name|reduceOptions
argument_list|(
name|_reduceOptions
argument_list|)
operator|,
name|progress
argument_list|(
literal|0
argument_list|)
operator|,
name|resultsMapSize
argument_list|(
literal|0
argument_list|)
operator|,
name|threadCount
argument_list|(
argument|QThreadPool::globalInstance()->maxThreadCount()
argument_list|)
block|{ }
name|void
name|runReduce
argument_list|(
argument|ReduceFunctor&reduce
argument_list|,
argument|ReduceResultType&r
argument_list|,
argument|const IntermediateResults<T>&result
argument_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
block|;
if|if
condition|(
operator|!
name|canReduce
argument_list|(
name|result
operator|.
name|begin
argument_list|)
condition|)
block|{
operator|++
name|resultsMapSize
expr_stmt|;
name|resultsMap
operator|.
name|insert
argument_list|(
name|result
operator|.
name|begin
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reduceOptions
operator|&
name|UnorderedReduce
condition|)
block|{
comment|// UnorderedReduce
name|progress
operator|=
operator|-
literal|1
expr_stmt|;
comment|// reduce this result
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|reduceResult
argument_list|(
name|reduce
argument_list|,
name|r
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
comment|// reduce all stored results as well
while|while
condition|(
operator|!
name|resultsMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ResultsMap
name|resultsMapCopy
init|=
name|resultsMap
decl_stmt|;
name|resultsMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|reduceResults
argument_list|(
name|reduce
argument_list|,
name|r
argument_list|,
name|resultsMapCopy
argument_list|)
expr_stmt|;
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
name|resultsMapSize
operator|-=
name|resultsMapCopy
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|progress
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// reduce this result
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|reduceResult
argument_list|(
name|reduce
argument_list|,
name|r
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
comment|// OrderedReduce
name|progress
operator|+=
name|result
operator|.
name|end
operator|-
name|result
operator|.
name|begin
expr_stmt|;
comment|// reduce as many other results as possible
name|typename
name|ResultsMap
operator|::
name|iterator
name|it
operator|=
name|resultsMap
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|!=
name|resultsMap
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|.
name|value
argument_list|()
operator|.
name|begin
operator|!=
name|progress
condition|)
break|break;
name|locker
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|reduceResult
argument_list|(
name|reduce
argument_list|,
name|r
argument_list|,
name|it
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|locker
operator|.
name|relock
argument_list|()
expr_stmt|;
operator|--
name|resultsMapSize
expr_stmt|;
name|progress
operator|+=
name|it
operator|.
name|value
argument_list|()
operator|.
name|end
operator|-
name|it
operator|.
name|value
argument_list|()
operator|.
name|begin
expr_stmt|;
name|it
operator|=
name|resultsMap
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// final reduction
name|void
name|finish
argument_list|(
argument|ReduceFunctor&reduce
argument_list|,
argument|ReduceResultType&r
argument_list|)
block|{
name|reduceResults
argument_list|(
name|reduce
argument_list|,
name|r
argument_list|,
name|resultsMap
argument_list|)
block|;     }
specifier|inline
name|bool
name|shouldThrottle
argument_list|()
block|{
return|return
operator|(
name|resultsMapSize
operator|>
operator|(
name|ReduceQueueThrottleLimit
operator|*
name|threadCount
operator|)
operator|)
return|;
block|}
specifier|inline
name|bool
name|shouldStartThread
parameter_list|()
block|{
return|return
operator|(
name|resultsMapSize
operator|<=
operator|(
name|ReduceQueueStartLimit
operator|*
name|threadCount
operator|)
operator|)
return|;
block|}
block|}
end_decl_stmt
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_expr_stmt
name|template
operator|<
name|typename
name|Sequence
operator|,
name|typename
name|Base
operator|,
name|typename
name|Functor1
operator|,
name|typename
name|Functor2
operator|>
expr|struct
name|SequenceHolder2
operator|:
name|public
name|Base
block|{
name|SequenceHolder2
argument_list|(
argument|const Sequence&_sequence
argument_list|,
argument|Functor1 functor1
argument_list|,
argument|Functor2 functor2
argument_list|,
argument|ReduceOptions reduceOptions
argument_list|)
operator|:
name|Base
argument_list|(
name|_sequence
operator|.
name|begin
argument_list|()
argument_list|,
name|_sequence
operator|.
name|end
argument_list|()
argument_list|,
name|functor1
argument_list|,
name|functor2
argument_list|,
name|reduceOptions
argument_list|)
block|,
name|sequence
argument_list|(
argument|_sequence
argument_list|)
block|{ }
name|Sequence
name|sequence
block|;
name|void
name|finish
argument_list|()
block|{
name|Base
operator|::
name|finish
argument_list|()
block|;
comment|// Clear the sequence to make sure all temporaries are destroyed
comment|// before finished is signaled.
name|sequence
operator|=
name|Sequence
argument_list|()
block|;     }
block|}
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//Q_QDOC
end_comment
begin_comment
unit|}
comment|// namespace QtConcurrent
end_comment
begin_endif
unit|QT_END_NAMESPACE
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_CONCURRENT
end_comment
begin_endif
endif|#
directive|endif
end_endif
end_unit
