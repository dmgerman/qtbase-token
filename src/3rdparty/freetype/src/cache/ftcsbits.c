begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftcsbits.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType sbits manager (body).                                       */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006 by                   */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_CACHE_H
end_include
begin_include
include|#
directive|include
file|"ftcsbits.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_ERRORS_H
end_include
begin_include
include|#
directive|include
file|"ftccback.h"
end_include
begin_include
include|#
directive|include
file|"ftcerror.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                     SBIT CACHE NODES                          *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ftc_sbit_copy_bitmap
name|ftc_sbit_copy_bitmap
parameter_list|(
name|FTC_SBit
name|sbit
parameter_list|,
name|FT_Bitmap
modifier|*
name|bitmap
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Int
name|pitch
init|=
name|bitmap
operator|->
name|pitch
decl_stmt|;
name|FT_ULong
name|size
decl_stmt|;
if|if
condition|(
name|pitch
operator|<
literal|0
condition|)
name|pitch
operator|=
operator|-
name|pitch
expr_stmt|;
name|size
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
name|pitch
operator|*
name|bitmap
operator|->
name|rows
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FT_ALLOC
argument_list|(
name|sbit
operator|->
name|buffer
argument_list|,
name|size
argument_list|)
condition|)
name|FT_MEM_COPY
argument_list|(
name|sbit
operator|->
name|buffer
argument_list|,
name|bitmap
operator|->
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ftc_snode_free
name|ftc_snode_free
argument_list|(
argument|FTC_Node   ftcsnode
argument_list|,
argument|FTC_Cache  cache
argument_list|)
end_macro
begin_block
block|{
name|FTC_SNode
name|snode
init|=
operator|(
name|FTC_SNode
operator|)
name|ftcsnode
decl_stmt|;
name|FTC_SBit
name|sbit
init|=
name|snode
operator|->
name|sbits
decl_stmt|;
name|FT_UInt
name|count
init|=
name|snode
operator|->
name|count
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|cache
operator|->
name|memory
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|sbit
operator|++
operator|,
name|count
operator|--
control|)
name|FT_FREE
argument_list|(
name|sbit
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|FTC_GNode_Done
argument_list|(
name|FTC_GNODE
argument_list|(
name|snode
argument_list|)
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|snode
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FTC_SNode_Free
name|FTC_SNode_Free
argument_list|(
argument|FTC_SNode  snode
argument_list|,
argument|FTC_Cache  cache
argument_list|)
end_macro
begin_block
block|{
name|ftc_snode_free
argument_list|(
name|FTC_NODE
argument_list|(
name|snode
argument_list|)
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*    *  This function tries to load a small bitmap within a given FTC_SNode.    *  Note that it returns a non-zero error code _only_ in the case of    *  out-of-memory condition.  For all other errors (e.g., corresponding    *  to a bad font file), this function will mark the sbit as `unavailable'    *  and return a value of 0.    *    *  You should also read the comment within the @ftc_snode_compare    *  function below to see how out-of-memory is handled during a lookup.    */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ftc_snode_load
name|ftc_snode_load
parameter_list|(
name|FTC_SNode
name|snode
parameter_list|,
name|FTC_Manager
name|manager
parameter_list|,
name|FT_UInt
name|gindex
parameter_list|,
name|FT_ULong
modifier|*
name|asize
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FTC_GNode
name|gnode
init|=
name|FTC_GNODE
argument_list|(
name|snode
argument_list|)
decl_stmt|;
name|FTC_Family
name|family
init|=
name|gnode
operator|->
name|family
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|manager
operator|->
name|memory
decl_stmt|;
name|FT_Face
name|face
decl_stmt|;
name|FTC_SBit
name|sbit
decl_stmt|;
name|FTC_SFamilyClass
name|clazz
decl_stmt|;
if|if
condition|(
call|(
name|FT_UInt
call|)
argument_list|(
name|gindex
operator|-
name|gnode
operator|->
name|gindex
argument_list|)
operator|>=
name|snode
operator|->
name|count
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"ftc_snode_load: invalid glyph index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FTC_Err_Invalid_Argument
return|;
block|}
name|sbit
operator|=
name|snode
operator|->
name|sbits
operator|+
operator|(
name|gindex
operator|-
name|gnode
operator|->
name|gindex
operator|)
expr_stmt|;
name|clazz
operator|=
operator|(
name|FTC_SFamilyClass
operator|)
name|family
operator|->
name|clazz
expr_stmt|;
name|sbit
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|clazz
operator|->
name|family_load_glyph
argument_list|(
name|family
argument_list|,
name|gindex
argument_list|,
name|manager
argument_list|,
operator|&
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|BadGlyph
goto|;
block|{
name|FT_Int
name|temp
decl_stmt|;
name|FT_GlyphSlot
name|slot
init|=
name|face
operator|->
name|glyph
decl_stmt|;
name|FT_Bitmap
modifier|*
name|bitmap
init|=
operator|&
name|slot
operator|->
name|bitmap
decl_stmt|;
name|FT_Int
name|xadvance
decl_stmt|,
name|yadvance
decl_stmt|;
if|if
condition|(
name|slot
operator|->
name|format
operator|!=
name|FT_GLYPH_FORMAT_BITMAP
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"%s: glyph loaded didn't return a bitmap!\n"
operator|,
literal|"ftc_snode_load"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|BadGlyph
goto|;
block|}
comment|/* Check that our values fit into 8-bit containers!       */
comment|/* If this is not the case, our bitmap is too large       */
comment|/* and we will leave it as `missing' with sbit.buffer = 0 */
DECL|macro|CHECK_CHAR
define|#
directive|define
name|CHECK_CHAR
parameter_list|(
name|d
parameter_list|)
value|( temp = (FT_Char)d, temp == d )
DECL|macro|CHECK_BYTE
define|#
directive|define
name|CHECK_BYTE
parameter_list|(
name|d
parameter_list|)
value|( temp = (FT_Byte)d, temp == d )
comment|/* horizontal advance in pixels */
name|xadvance
operator|=
operator|(
name|slot
operator|->
name|advance
operator|.
name|x
operator|+
literal|32
operator|)
operator|>>
literal|6
expr_stmt|;
name|yadvance
operator|=
operator|(
name|slot
operator|->
name|advance
operator|.
name|y
operator|+
literal|32
operator|)
operator|>>
literal|6
expr_stmt|;
if|if
condition|(
operator|!
name|CHECK_BYTE
argument_list|(
name|bitmap
operator|->
name|rows
argument_list|)
operator|||
operator|!
name|CHECK_BYTE
argument_list|(
name|bitmap
operator|->
name|width
argument_list|)
operator|||
operator|!
name|CHECK_CHAR
argument_list|(
name|bitmap
operator|->
name|pitch
argument_list|)
operator|||
operator|!
name|CHECK_CHAR
argument_list|(
name|slot
operator|->
name|bitmap_left
argument_list|)
operator|||
operator|!
name|CHECK_CHAR
argument_list|(
name|slot
operator|->
name|bitmap_top
argument_list|)
operator|||
operator|!
name|CHECK_CHAR
argument_list|(
name|xadvance
argument_list|)
operator|||
operator|!
name|CHECK_CHAR
argument_list|(
name|yadvance
argument_list|)
condition|)
goto|goto
name|BadGlyph
goto|;
name|sbit
operator|->
name|width
operator|=
operator|(
name|FT_Byte
operator|)
name|bitmap
operator|->
name|width
expr_stmt|;
name|sbit
operator|->
name|height
operator|=
operator|(
name|FT_Byte
operator|)
name|bitmap
operator|->
name|rows
expr_stmt|;
name|sbit
operator|->
name|pitch
operator|=
operator|(
name|FT_Char
operator|)
name|bitmap
operator|->
name|pitch
expr_stmt|;
name|sbit
operator|->
name|left
operator|=
operator|(
name|FT_Char
operator|)
name|slot
operator|->
name|bitmap_left
expr_stmt|;
name|sbit
operator|->
name|top
operator|=
operator|(
name|FT_Char
operator|)
name|slot
operator|->
name|bitmap_top
expr_stmt|;
name|sbit
operator|->
name|xadvance
operator|=
operator|(
name|FT_Char
operator|)
name|xadvance
expr_stmt|;
name|sbit
operator|->
name|yadvance
operator|=
operator|(
name|FT_Char
operator|)
name|yadvance
expr_stmt|;
name|sbit
operator|->
name|format
operator|=
operator|(
name|FT_Byte
operator|)
name|bitmap
operator|->
name|pixel_mode
expr_stmt|;
name|sbit
operator|->
name|max_grays
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|bitmap
operator|->
name|num_grays
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* copy the bitmap into a new buffer -- ignore error */
name|error
operator|=
name|ftc_sbit_copy_bitmap
argument_list|(
name|sbit
argument_list|,
name|bitmap
argument_list|,
name|memory
argument_list|)
expr_stmt|;
comment|/* now, compute size */
if|if
condition|(
name|asize
condition|)
operator|*
name|asize
operator|=
name|FT_ABS
argument_list|(
name|sbit
operator|->
name|pitch
argument_list|)
operator|*
name|sbit
operator|->
name|height
expr_stmt|;
block|}
comment|/* glyph loading successful */
comment|/* ignore the errors that might have occurred --   */
comment|/* we mark unloaded glyphs with `sbit.buffer == 0' */
comment|/* and `width == 255', `height == 0'               */
comment|/*                                                 */
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|FTC_Err_Out_Of_Memory
condition|)
block|{
name|BadGlyph
label|:
name|sbit
operator|->
name|width
operator|=
literal|255
expr_stmt|;
name|sbit
operator|->
name|height
operator|=
literal|0
expr_stmt|;
name|sbit
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|asize
condition|)
operator|*
name|asize
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FTC_SNode_New
argument_list|(
argument|FTC_SNode  *psnode
argument_list|,
argument|FTC_GQuery  gquery
argument_list|,
argument|FTC_Cache   cache
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|cache
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FTC_SNode
name|snode
init|=
name|NULL
decl_stmt|;
name|FT_UInt
name|gindex
init|=
name|gquery
operator|->
name|gindex
decl_stmt|;
name|FTC_Family
name|family
init|=
name|gquery
operator|->
name|family
decl_stmt|;
name|FTC_SFamilyClass
name|clazz
init|=
name|FTC_CACHE__SFAMILY_CLASS
argument_list|(
name|cache
argument_list|)
decl_stmt|;
name|FT_UInt
name|total
decl_stmt|;
name|total
operator|=
name|clazz
operator|->
name|family_get_count
argument_list|(
name|family
argument_list|,
name|cache
operator|->
name|manager
argument_list|)
expr_stmt|;
if|if
condition|(
name|total
operator|==
literal|0
operator|||
name|gindex
operator|>=
name|total
condition|)
block|{
name|error
operator|=
name|FT_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|FT_NEW
argument_list|(
name|snode
argument_list|)
condition|)
block|{
name|FT_UInt
name|count
decl_stmt|,
name|start
decl_stmt|;
name|start
operator|=
name|gindex
operator|-
operator|(
name|gindex
operator|%
name|FTC_SBIT_ITEMS_PER_NODE
operator|)
expr_stmt|;
name|count
operator|=
name|total
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|FTC_SBIT_ITEMS_PER_NODE
condition|)
name|count
operator|=
name|FTC_SBIT_ITEMS_PER_NODE
expr_stmt|;
name|FTC_GNode_Init
argument_list|(
name|FTC_GNODE
argument_list|(
name|snode
argument_list|)
argument_list|,
name|start
argument_list|,
name|family
argument_list|)
expr_stmt|;
name|snode
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|error
operator|=
name|ftc_snode_load
argument_list|(
name|snode
argument_list|,
name|cache
operator|->
name|manager
argument_list|,
name|gindex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FTC_SNode_Free
argument_list|(
name|snode
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|snode
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|Exit
label|:
operator|*
name|psnode
operator|=
name|snode
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ftc_snode_new
argument_list|(
argument|FTC_Node   *ftcpsnode
argument_list|,
argument|FT_Pointer  ftcgquery
argument_list|,
argument|FTC_Cache   cache
argument_list|)
end_macro
begin_block
block|{
name|FTC_SNode
modifier|*
name|psnode
init|=
operator|(
name|FTC_SNode
operator|*
operator|)
name|ftcpsnode
decl_stmt|;
name|FTC_GQuery
name|gquery
init|=
operator|(
name|FTC_GQuery
operator|)
name|ftcgquery
decl_stmt|;
return|return
name|FTC_SNode_New
argument_list|(
name|psnode
argument_list|,
name|gquery
argument_list|,
name|cache
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_ULong
argument_list|)
end_macro
begin_macro
name|ftc_snode_weight
argument_list|(
argument|FTC_Node   ftcsnode
argument_list|,
argument|FTC_Cache  cache
argument_list|)
end_macro
begin_block
block|{
name|FTC_SNode
name|snode
init|=
operator|(
name|FTC_SNode
operator|)
name|ftcsnode
decl_stmt|;
name|FT_UInt
name|count
init|=
name|snode
operator|->
name|count
decl_stmt|;
name|FTC_SBit
name|sbit
init|=
name|snode
operator|->
name|sbits
decl_stmt|;
name|FT_Int
name|pitch
decl_stmt|;
name|FT_ULong
name|size
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|snode
operator|->
name|count
operator|<=
name|FTC_SBIT_ITEMS_PER_NODE
argument_list|)
expr_stmt|;
comment|/* the node itself */
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|snode
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|sbit
operator|++
control|)
block|{
if|if
condition|(
name|sbit
operator|->
name|buffer
condition|)
block|{
name|pitch
operator|=
name|sbit
operator|->
name|pitch
expr_stmt|;
if|if
condition|(
name|pitch
operator|<
literal|0
condition|)
name|pitch
operator|=
operator|-
name|pitch
expr_stmt|;
comment|/* add the size of a given glyph image */
name|size
operator|+=
name|pitch
operator|*
name|sbit
operator|->
name|height
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_block
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|FT_LOCAL_DEF( FT_ULong )   FTC_SNode_Weight( FTC_SNode  snode )   {     return ftc_snode_weight( FTC_NODE( snode ), NULL );   }
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Bool
argument_list|)
end_macro
begin_macro
name|ftc_snode_compare
argument_list|(
argument|FTC_Node    ftcsnode
argument_list|,
argument|FT_Pointer  ftcgquery
argument_list|,
argument|FTC_Cache   cache
argument_list|)
end_macro
begin_block
block|{
name|FTC_SNode
name|snode
init|=
operator|(
name|FTC_SNode
operator|)
name|ftcsnode
decl_stmt|;
name|FTC_GQuery
name|gquery
init|=
operator|(
name|FTC_GQuery
operator|)
name|ftcgquery
decl_stmt|;
name|FTC_GNode
name|gnode
init|=
name|FTC_GNODE
argument_list|(
name|snode
argument_list|)
decl_stmt|;
name|FT_UInt
name|gindex
init|=
name|gquery
operator|->
name|gindex
decl_stmt|;
name|FT_Bool
name|result
decl_stmt|;
name|result
operator|=
name|FT_BOOL
argument_list|(
name|gnode
operator|->
name|family
operator|==
name|gquery
operator|->
name|family
operator|&&
call|(
name|FT_UInt
call|)
argument_list|(
name|gindex
operator|-
name|gnode
operator|->
name|gindex
argument_list|)
operator|<
name|snode
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
comment|/* check if we need to load the glyph bitmap now */
name|FTC_SBit
name|sbit
init|=
name|snode
operator|->
name|sbits
operator|+
operator|(
name|gindex
operator|-
name|gnode
operator|->
name|gindex
operator|)
decl_stmt|;
comment|/*        *  The following code illustrates what to do when you want to        *  perform operations that may fail within a lookup function.        *        *  Here, we want to load a small bitmap on-demand; we thus        *  need to call the `ftc_snode_load' function which may return        *  a non-zero error code only when we are out of memory (OOM).        *        *  The correct thing to do is to use @FTC_CACHE_TRYLOOP and        *  @FTC_CACHE_TRYLOOP_END in order to implement a retry loop        *  that is capable of flushing the cache incrementally when        *  an OOM errors occur.        *        *  However, we need to `lock' the node before this operation to        *  prevent it from being flushed within the loop.        *        *  When we exit the loop, we unlock the node, then check the `error'        *  variable.  If it is non-zero, this means that the cache was        *  completely flushed and that no usable memory was found to load        *  the bitmap.        *        *  We then prefer to return a value of 0 (i.e., NO MATCH).  This        *  ensures that the caller will try to allocate a new node.        *  This operation consequently _fail_ and the lookup function        *  returns the appropriate OOM error code.        *        *  Note that `buffer == NULL&& width == 255' is a hack used to        *  tag `unavailable' bitmaps in the array.  We should never try        *  to load these.        *        */
if|if
condition|(
name|sbit
operator|->
name|buffer
operator|==
name|NULL
operator|&&
name|sbit
operator|->
name|width
operator|!=
literal|255
condition|)
block|{
name|FT_ULong
name|size
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|ftcsnode
operator|->
name|ref_count
operator|++
expr_stmt|;
comment|/* lock node to prevent flushing */
comment|/* in retry loop                 */
name|FTC_CACHE_TRYLOOP
argument_list|(
argument|cache
argument_list|)
block|{
name|error
operator|=
name|ftc_snode_load
argument_list|(
name|snode
argument_list|,
name|cache
operator|->
name|manager
argument_list|,
name|gindex
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
name|FTC_CACHE_TRYLOOP_END
argument_list|()
expr_stmt|;
name|ftcsnode
operator|->
name|ref_count
operator|--
expr_stmt|;
comment|/* unlock the node */
if|if
condition|(
name|error
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
name|cache
operator|->
name|manager
operator|->
name|cur_weight
operator|+=
name|size
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Bool
argument_list|)
end_macro
begin_macro
name|FTC_SNode_Compare
argument_list|(
argument|FTC_SNode   snode
argument_list|,
argument|FTC_GQuery  gquery
argument_list|,
argument|FTC_Cache   cache
argument_list|)
end_macro
begin_block
block|{
return|return
name|ftc_snode_compare
argument_list|(
name|FTC_NODE
argument_list|(
name|snode
argument_list|)
argument_list|,
name|gquery
argument_list|,
name|cache
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
