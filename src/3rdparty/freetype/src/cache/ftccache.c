begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftccache.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    The FreeType internal cache interface (body).                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009 by       */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
file|"ftcmanag.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
file|"ftccback.h"
end_include
begin_include
include|#
directive|include
file|"ftcerror.h"
end_include
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_cache
end_define
begin_define
DECL|macro|FTC_HASH_MAX_LOAD
define|#
directive|define
name|FTC_HASH_MAX_LOAD
value|2
end_define
begin_define
DECL|macro|FTC_HASH_MIN_LOAD
define|#
directive|define
name|FTC_HASH_MIN_LOAD
value|1
end_define
begin_define
DECL|macro|FTC_HASH_SUB_LOAD
define|#
directive|define
name|FTC_HASH_SUB_LOAD
value|( FTC_HASH_MAX_LOAD - FTC_HASH_MIN_LOAD )
end_define
begin_comment
comment|/* this one _must_ be a power of 2! */
end_comment
begin_define
DECL|macro|FTC_HASH_INITIAL_SIZE
define|#
directive|define
name|FTC_HASH_INITIAL_SIZE
value|8
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                   CACHE NODE DEFINITIONS                      *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* add a new node to the head of the manager's circular MRU list */
end_comment
begin_function
specifier|static
name|void
DECL|function|ftc_node_mru_link
name|ftc_node_mru_link
parameter_list|(
name|FTC_Node
name|node
parameter_list|,
name|FTC_Manager
name|manager
parameter_list|)
block|{
name|void
modifier|*
name|nl
init|=
operator|&
name|manager
operator|->
name|nodes_list
decl_stmt|;
name|FTC_MruNode_Prepend
argument_list|(
operator|(
name|FTC_MruNode
operator|*
operator|)
name|nl
argument_list|,
operator|(
name|FTC_MruNode
operator|)
name|node
argument_list|)
expr_stmt|;
name|manager
operator|->
name|num_nodes
operator|++
expr_stmt|;
block|}
end_function
begin_comment
comment|/* remove a node from the manager's MRU list */
end_comment
begin_function
specifier|static
name|void
DECL|function|ftc_node_mru_unlink
name|ftc_node_mru_unlink
parameter_list|(
name|FTC_Node
name|node
parameter_list|,
name|FTC_Manager
name|manager
parameter_list|)
block|{
name|void
modifier|*
name|nl
init|=
operator|&
name|manager
operator|->
name|nodes_list
decl_stmt|;
name|FTC_MruNode_Remove
argument_list|(
operator|(
name|FTC_MruNode
operator|*
operator|)
name|nl
argument_list|,
operator|(
name|FTC_MruNode
operator|)
name|node
argument_list|)
expr_stmt|;
name|manager
operator|->
name|num_nodes
operator|--
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|FTC_INLINE
end_ifndef
begin_comment
comment|/* move a node to the head of the manager's MRU list */
end_comment
begin_function
specifier|static
name|void
DECL|function|ftc_node_mru_up
name|ftc_node_mru_up
parameter_list|(
name|FTC_Node
name|node
parameter_list|,
name|FTC_Manager
name|manager
parameter_list|)
block|{
name|FTC_MruNode_Up
argument_list|(
operator|(
name|FTC_MruNode
operator|*
operator|)
operator|&
name|manager
operator|->
name|nodes_list
argument_list|,
operator|(
name|FTC_MruNode
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FTC_INLINE */
end_comment
begin_comment
comment|/* Note that this function cannot fail.  If we cannot re-size the    * buckets array appropriately, we simply degrade the hash table's    * performance!    */
end_comment
begin_function
specifier|static
name|void
DECL|function|ftc_cache_resize
name|ftc_cache_resize
parameter_list|(
name|FTC_Cache
name|cache
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|FTC_Node
name|node
decl_stmt|,
modifier|*
name|pnode
decl_stmt|;
name|FT_UFast
name|p
init|=
name|cache
operator|->
name|p
decl_stmt|;
name|FT_UFast
name|mask
init|=
name|cache
operator|->
name|mask
decl_stmt|;
name|FT_UFast
name|count
init|=
name|mask
operator|+
name|p
operator|+
literal|1
decl_stmt|;
comment|/* number of buckets */
comment|/* do we need to shrink the buckets array? */
if|if
condition|(
name|cache
operator|->
name|slack
operator|<
literal|0
condition|)
block|{
name|FTC_Node
name|new_list
init|=
name|NULL
decl_stmt|;
comment|/* try to expand the buckets array _before_ splitting          * the bucket lists          */
if|if
condition|(
name|p
operator|>=
name|mask
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|cache
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* if we can't expand the array, leave immediately */
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|cache
operator|->
name|buckets
argument_list|,
operator|(
name|mask
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|,
operator|(
name|mask
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|)
condition|)
break|break;
block|}
comment|/* split a single bucket */
name|pnode
operator|=
name|cache
operator|->
name|buckets
operator|+
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|node
operator|=
operator|*
name|pnode
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|node
operator|->
name|hash
operator|&
operator|(
name|mask
operator|+
literal|1
operator|)
condition|)
block|{
operator|*
name|pnode
operator|=
name|node
operator|->
name|link
expr_stmt|;
name|node
operator|->
name|link
operator|=
name|new_list
expr_stmt|;
name|new_list
operator|=
name|node
expr_stmt|;
block|}
else|else
name|pnode
operator|=
operator|&
name|node
operator|->
name|link
expr_stmt|;
block|}
name|cache
operator|->
name|buckets
index|[
name|p
operator|+
name|mask
operator|+
literal|1
index|]
operator|=
name|new_list
expr_stmt|;
name|cache
operator|->
name|slack
operator|+=
name|FTC_HASH_MAX_LOAD
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|mask
condition|)
block|{
name|cache
operator|->
name|mask
operator|=
literal|2
operator|*
name|mask
operator|+
literal|1
expr_stmt|;
name|cache
operator|->
name|p
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cache
operator|->
name|p
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
comment|/* do we need to expand the buckets array? */
elseif|else
if|if
condition|(
name|cache
operator|->
name|slack
operator|>
operator|(
name|FT_Long
operator|)
name|count
operator|*
name|FTC_HASH_SUB_LOAD
condition|)
block|{
name|FT_UFast
name|old_index
init|=
name|p
operator|+
name|mask
decl_stmt|;
name|FTC_Node
modifier|*
name|pold
decl_stmt|;
if|if
condition|(
name|old_index
operator|+
literal|1
operator|<=
name|FTC_HASH_INITIAL_SIZE
condition|)
break|break;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|cache
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* if we can't shrink the array, leave immediately */
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|cache
operator|->
name|buckets
argument_list|,
operator|(
name|mask
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|,
name|mask
operator|+
literal|1
argument_list|)
condition|)
break|break;
name|cache
operator|->
name|mask
operator|>>=
literal|1
expr_stmt|;
name|p
operator|=
name|cache
operator|->
name|mask
expr_stmt|;
block|}
else|else
name|p
operator|--
expr_stmt|;
name|pnode
operator|=
name|cache
operator|->
name|buckets
operator|+
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|pnode
condition|)
name|pnode
operator|=
operator|&
operator|(
operator|*
name|pnode
operator|)
operator|->
name|link
expr_stmt|;
name|pold
operator|=
name|cache
operator|->
name|buckets
operator|+
name|old_index
expr_stmt|;
operator|*
name|pnode
operator|=
operator|*
name|pold
expr_stmt|;
operator|*
name|pold
operator|=
name|NULL
expr_stmt|;
name|cache
operator|->
name|slack
operator|-=
name|FTC_HASH_MAX_LOAD
expr_stmt|;
name|cache
operator|->
name|p
operator|=
name|p
expr_stmt|;
block|}
else|else
comment|/* the hash table is balanced */
break|break;
block|}
block|}
end_function
begin_comment
comment|/* remove a node from its cache's hash table */
end_comment
begin_function
specifier|static
name|void
DECL|function|ftc_node_hash_unlink
name|ftc_node_hash_unlink
parameter_list|(
name|FTC_Node
name|node0
parameter_list|,
name|FTC_Cache
name|cache
parameter_list|)
block|{
name|FTC_Node
modifier|*
name|pnode
decl_stmt|;
name|FT_UInt
name|idx
decl_stmt|;
name|idx
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|node0
operator|->
name|hash
operator|&
name|cache
operator|->
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|cache
operator|->
name|p
condition|)
name|idx
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|node0
operator|->
name|hash
operator|&
operator|(
literal|2
operator|*
name|cache
operator|->
name|mask
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|pnode
operator|=
name|cache
operator|->
name|buckets
operator|+
name|idx
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FTC_Node
name|node
init|=
operator|*
name|pnode
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"ftc_node_hash_unlink: unknown node\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|node
operator|==
name|node0
condition|)
break|break;
name|pnode
operator|=
operator|&
operator|(
operator|*
name|pnode
operator|)
operator|->
name|link
expr_stmt|;
block|}
operator|*
name|pnode
operator|=
name|node0
operator|->
name|link
expr_stmt|;
name|node0
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
name|cache
operator|->
name|slack
operator|++
expr_stmt|;
name|ftc_cache_resize
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* add a node to the `top' of its cache's hash table */
end_comment
begin_function
specifier|static
name|void
DECL|function|ftc_node_hash_link
name|ftc_node_hash_link
parameter_list|(
name|FTC_Node
name|node
parameter_list|,
name|FTC_Cache
name|cache
parameter_list|)
block|{
name|FTC_Node
modifier|*
name|pnode
decl_stmt|;
name|FT_UInt
name|idx
decl_stmt|;
name|idx
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|node
operator|->
name|hash
operator|&
name|cache
operator|->
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|cache
operator|->
name|p
condition|)
name|idx
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|node
operator|->
name|hash
operator|&
operator|(
literal|2
operator|*
name|cache
operator|->
name|mask
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|pnode
operator|=
name|cache
operator|->
name|buckets
operator|+
name|idx
expr_stmt|;
name|node
operator|->
name|link
operator|=
operator|*
name|pnode
expr_stmt|;
operator|*
name|pnode
operator|=
name|node
expr_stmt|;
name|cache
operator|->
name|slack
operator|--
expr_stmt|;
name|ftc_cache_resize
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* remove a node from the cache manager */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_OLD_INTERNALS
end_ifdef
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_else
else|#
directive|else
end_else
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_macro
DECL|function|ftc_node_destroy
name|ftc_node_destroy
argument_list|(
argument|FTC_Node     node
argument_list|,
argument|FTC_Manager  manager
argument_list|)
end_macro
begin_block
block|{
name|FTC_Cache
name|cache
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_ERROR
comment|/* find node's cache */
if|if
condition|(
name|node
operator|->
name|cache_index
operator|>=
name|manager
operator|->
name|num_caches
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"ftc_node_destroy: invalid node handle\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|cache
operator|=
name|manager
operator|->
name|caches
index|[
name|node
operator|->
name|cache_index
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_ERROR
if|if
condition|(
name|cache
operator|==
name|NULL
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"ftc_node_destroy: invalid node handle\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|manager
operator|->
name|cur_weight
operator|-=
name|cache
operator|->
name|clazz
operator|.
name|node_weight
argument_list|(
name|node
argument_list|,
name|cache
argument_list|)
expr_stmt|;
comment|/* remove node from mru list */
name|ftc_node_mru_unlink
argument_list|(
name|node
argument_list|,
name|manager
argument_list|)
expr_stmt|;
comment|/* remove node from cache's hash table */
name|ftc_node_hash_unlink
argument_list|(
name|node
argument_list|,
name|cache
argument_list|)
expr_stmt|;
comment|/* now finalize it */
name|cache
operator|->
name|clazz
operator|.
name|node_free
argument_list|(
name|node
argument_list|,
name|cache
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* check, just in case of general corruption :-) */
block|if ( manager->num_nodes == 0 )       FT_TRACE0(( "ftc_node_destroy: invalid cache node count (%d)\n",                   manager->num_nodes ));
endif|#
directive|endif
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                    ABSTRACT CACHE CLASS                       *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FTC_Cache_Init
argument_list|(
argument|FTC_Cache  cache
argument_list|)
end_macro
begin_block
block|{
return|return
name|ftc_cache_init
argument_list|(
name|cache
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ftc_cache_init
argument_list|(
argument|FTC_Cache  cache
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|cache
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|cache
operator|->
name|p
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|mask
operator|=
name|FTC_HASH_INITIAL_SIZE
operator|-
literal|1
expr_stmt|;
name|cache
operator|->
name|slack
operator|=
name|FTC_HASH_INITIAL_SIZE
operator|*
name|FTC_HASH_MAX_LOAD
expr_stmt|;
operator|(
name|void
operator|)
name|FT_NEW_ARRAY
argument_list|(
name|cache
operator|->
name|buckets
argument_list|,
name|FTC_HASH_INITIAL_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|FTC_Cache_Clear
name|FTC_Cache_Clear
parameter_list|(
name|FTC_Cache
name|cache
parameter_list|)
block|{
if|if
condition|(
name|cache
condition|)
block|{
name|FTC_Manager
name|manager
init|=
name|cache
operator|->
name|manager
decl_stmt|;
name|FT_UFast
name|i
decl_stmt|;
name|FT_UFast
name|count
decl_stmt|;
name|count
operator|=
name|cache
operator|->
name|p
operator|+
name|cache
operator|->
name|mask
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|FTC_Node
modifier|*
name|pnode
init|=
name|cache
operator|->
name|buckets
operator|+
name|i
decl_stmt|,
name|next
decl_stmt|,
name|node
init|=
operator|*
name|pnode
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|next
operator|=
name|node
operator|->
name|link
expr_stmt|;
name|node
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
comment|/* remove node from mru list */
name|ftc_node_mru_unlink
argument_list|(
name|node
argument_list|,
name|manager
argument_list|)
expr_stmt|;
comment|/* now finalize it */
name|manager
operator|->
name|cur_weight
operator|-=
name|cache
operator|->
name|clazz
operator|.
name|node_weight
argument_list|(
name|node
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|cache
operator|->
name|clazz
operator|.
name|node_free
argument_list|(
name|node
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|node
operator|=
name|next
expr_stmt|;
block|}
name|cache
operator|->
name|buckets
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|ftc_cache_resize
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ftc_cache_done
name|ftc_cache_done
argument_list|(
argument|FTC_Cache  cache
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|cache
operator|->
name|memory
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|cache
operator|->
name|memory
decl_stmt|;
name|FTC_Cache_Clear
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|cache
operator|->
name|buckets
argument_list|)
expr_stmt|;
name|cache
operator|->
name|mask
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|p
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|slack
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|memory
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FTC_Cache_Done
name|FTC_Cache_Done
argument_list|(
argument|FTC_Cache  cache
argument_list|)
end_macro
begin_block
block|{
name|ftc_cache_done
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|ftc_cache_add
name|ftc_cache_add
parameter_list|(
name|FTC_Cache
name|cache
parameter_list|,
name|FT_UInt32
name|hash
parameter_list|,
name|FTC_Node
name|node
parameter_list|)
block|{
name|node
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|node
operator|->
name|cache_index
operator|=
operator|(
name|FT_UInt16
operator|)
name|cache
operator|->
name|index
expr_stmt|;
name|node
operator|->
name|ref_count
operator|=
literal|0
expr_stmt|;
name|ftc_node_hash_link
argument_list|(
name|node
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|ftc_node_mru_link
argument_list|(
name|node
argument_list|,
name|cache
operator|->
name|manager
argument_list|)
expr_stmt|;
block|{
name|FTC_Manager
name|manager
init|=
name|cache
operator|->
name|manager
decl_stmt|;
name|manager
operator|->
name|cur_weight
operator|+=
name|cache
operator|->
name|clazz
operator|.
name|node_weight
argument_list|(
name|node
argument_list|,
name|cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|cur_weight
operator|>=
name|manager
operator|->
name|max_weight
condition|)
block|{
name|node
operator|->
name|ref_count
operator|++
expr_stmt|;
name|FTC_Manager_Compress
argument_list|(
name|manager
argument_list|)
expr_stmt|;
name|node
operator|->
name|ref_count
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FTC_Cache_NewNode
argument_list|(
argument|FTC_Cache   cache
argument_list|,
argument|FT_UInt32   hash
argument_list|,
argument|FT_Pointer  query
argument_list|,
argument|FTC_Node   *anode
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FTC_Node
name|node
decl_stmt|;
comment|/*      * We use the FTC_CACHE_TRYLOOP macros to support out-of-memory      * errors (OOM) correctly, i.e., by flushing the cache progressively      * in order to make more room.      */
name|FTC_CACHE_TRYLOOP
argument_list|(
argument|cache
argument_list|)
block|{
name|error
operator|=
name|cache
operator|->
name|clazz
operator|.
name|node_new
argument_list|(
operator|&
name|node
argument_list|,
name|query
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
name|FTC_CACHE_TRYLOOP_END
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|node
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* don't assume that the cache has the same number of buckets, since       * our allocation request might have triggered global cache flushing       */
name|ftc_cache_add
argument_list|(
name|cache
argument_list|,
name|hash
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
operator|*
name|anode
operator|=
name|node
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_ifndef
ifndef|#
directive|ifndef
name|FTC_INLINE
end_ifndef
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FTC_Cache_Lookup
argument_list|(
argument|FTC_Cache   cache
argument_list|,
argument|FT_UInt32   hash
argument_list|,
argument|FT_Pointer  query
argument_list|,
argument|FTC_Node   *anode
argument_list|)
end_macro
begin_block
block|{
name|FT_UFast
name|idx
decl_stmt|;
name|FTC_Node
modifier|*
name|bucket
decl_stmt|;
name|FTC_Node
modifier|*
name|pnode
decl_stmt|;
name|FTC_Node
name|node
decl_stmt|;
name|FT_Error
name|error
init|=
literal|0
decl_stmt|;
name|FTC_Node_CompareFunc
name|compare
init|=
name|cache
operator|->
name|clazz
operator|.
name|node_compare
decl_stmt|;
if|if
condition|(
name|cache
operator|==
name|NULL
operator|||
name|anode
operator|==
name|NULL
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|idx
operator|=
name|hash
operator|&
name|cache
operator|->
name|mask
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|cache
operator|->
name|p
condition|)
name|idx
operator|=
name|hash
operator|&
operator|(
name|cache
operator|->
name|mask
operator|*
literal|2
operator|+
literal|1
operator|)
expr_stmt|;
name|bucket
operator|=
name|cache
operator|->
name|buckets
operator|+
name|idx
expr_stmt|;
name|pnode
operator|=
name|bucket
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|node
operator|=
operator|*
name|pnode
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
goto|goto
name|NewNode
goto|;
if|if
condition|(
name|node
operator|->
name|hash
operator|==
name|hash
operator|&&
name|compare
argument_list|(
name|node
argument_list|,
name|query
argument_list|,
name|cache
argument_list|)
condition|)
break|break;
name|pnode
operator|=
operator|&
name|node
operator|->
name|link
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|!=
operator|*
name|bucket
condition|)
block|{
operator|*
name|pnode
operator|=
name|node
operator|->
name|link
expr_stmt|;
name|node
operator|->
name|link
operator|=
operator|*
name|bucket
expr_stmt|;
operator|*
name|bucket
operator|=
name|node
expr_stmt|;
block|}
comment|/* move to head of MRU list */
block|{
name|FTC_Manager
name|manager
init|=
name|cache
operator|->
name|manager
decl_stmt|;
if|if
condition|(
name|node
operator|!=
name|manager
operator|->
name|nodes_list
condition|)
name|ftc_node_mru_up
argument_list|(
name|node
argument_list|,
name|manager
argument_list|)
expr_stmt|;
block|}
operator|*
name|anode
operator|=
name|node
expr_stmt|;
return|return
name|error
return|;
name|NewNode
label|:
return|return
name|FTC_Cache_NewNode
argument_list|(
name|cache
argument_list|,
name|hash
argument_list|,
name|query
argument_list|,
name|anode
argument_list|)
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FTC_INLINE */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FTC_Cache_RemoveFaceID
name|FTC_Cache_RemoveFaceID
argument_list|(
argument|FTC_Cache   cache
argument_list|,
argument|FTC_FaceID  face_id
argument_list|)
end_macro
begin_block
block|{
name|FT_UFast
name|i
decl_stmt|,
name|count
decl_stmt|;
name|FTC_Manager
name|manager
init|=
name|cache
operator|->
name|manager
decl_stmt|;
name|FTC_Node
name|frees
init|=
name|NULL
decl_stmt|;
name|count
operator|=
name|cache
operator|->
name|p
operator|+
name|cache
operator|->
name|mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|FTC_Node
modifier|*
name|bucket
init|=
name|cache
operator|->
name|buckets
operator|+
name|i
decl_stmt|;
name|FTC_Node
modifier|*
name|pnode
init|=
name|bucket
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FTC_Node
name|node
init|=
operator|*
name|pnode
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|cache
operator|->
name|clazz
operator|.
name|node_remove_faceid
argument_list|(
name|node
argument_list|,
name|face_id
argument_list|,
name|cache
argument_list|)
condition|)
block|{
operator|*
name|pnode
operator|=
name|node
operator|->
name|link
expr_stmt|;
name|node
operator|->
name|link
operator|=
name|frees
expr_stmt|;
name|frees
operator|=
name|node
expr_stmt|;
block|}
else|else
name|pnode
operator|=
operator|&
name|node
operator|->
name|link
expr_stmt|;
block|}
block|}
comment|/* remove all nodes in the free list */
while|while
condition|(
name|frees
condition|)
block|{
name|FTC_Node
name|node
decl_stmt|;
name|node
operator|=
name|frees
expr_stmt|;
name|frees
operator|=
name|node
operator|->
name|link
expr_stmt|;
name|manager
operator|->
name|cur_weight
operator|-=
name|cache
operator|->
name|clazz
operator|.
name|node_weight
argument_list|(
name|node
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|ftc_node_mru_unlink
argument_list|(
name|node
argument_list|,
name|manager
argument_list|)
expr_stmt|;
name|cache
operator|->
name|clazz
operator|.
name|node_free
argument_list|(
name|node
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|cache
operator|->
name|slack
operator|++
expr_stmt|;
block|}
name|ftc_cache_resize
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
