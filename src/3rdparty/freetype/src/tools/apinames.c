begin_unit
begin_comment
comment|/*  * This little program is used to parse the FreeType headers and  * find the declaration of all public APIs.  This is easy, because  * they all look like the following:  *  *   FT_EXPORT( return_type )  *   function_name( function arguments );  *  * You must pass the list of header files as arguments.  Wildcards are  * accepted if you are using GCC for compilation (and probably by  * other compilers too).  *  * Author: David Turner, 2005, 2006, 2008  *  * This code is explicitly placed into the public domain.  *  */
end_comment
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_define
DECL|macro|PROGRAM_NAME
define|#
directive|define
name|PROGRAM_NAME
value|"apinames"
end_define
begin_define
DECL|macro|PROGRAM_VERSION
define|#
directive|define
name|PROGRAM_VERSION
value|"0.1"
end_define
begin_define
DECL|macro|LINEBUFF_SIZE
define|#
directive|define
name|LINEBUFF_SIZE
value|1024
end_define
begin_typedef
DECL|enum|OutputFormat_
typedef|typedef
enum|enum
name|OutputFormat_
block|{
DECL|enumerator|OUTPUT_LIST
name|OUTPUT_LIST
init|=
literal|0
block|,
comment|/* output the list of names, one per line             */
DECL|enumerator|OUTPUT_WINDOWS_DEF
name|OUTPUT_WINDOWS_DEF
block|,
comment|/* output a Windows .DEF file for Visual C++ or Mingw */
DECL|enumerator|OUTPUT_BORLAND_DEF
name|OUTPUT_BORLAND_DEF
block|,
comment|/* output a Windows .DEF file for Borland C++         */
DECL|enumerator|OUTPUT_WATCOM_LBC
name|OUTPUT_WATCOM_LBC
comment|/* output a Watcom Linker Command File                */
block|}
DECL|typedef|OutputFormat
name|OutputFormat
typedef|;
end_typedef
begin_function
specifier|static
name|void
DECL|function|panic
name|panic
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PANIC: %s\n"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
begin_typedef
DECL|struct|NameRec_
typedef|typedef
struct|struct
name|NameRec_
block|{
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|hash
name|unsigned
name|int
name|hash
decl_stmt|;
block|}
DECL|typedef|NameRec
DECL|typedef|Name
name|NameRec
operator|,
typedef|*
name|Name
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|the_names
specifier|static
name|Name
name|the_names
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|num_names
specifier|static
name|int
name|num_names
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|max_names
specifier|static
name|int
name|max_names
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|void
DECL|function|names_add
name|names_add
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|int
name|nn
decl_stmt|,
name|len
decl_stmt|,
name|h
decl_stmt|;
name|Name
name|nm
decl_stmt|;
if|if
condition|(
name|end
operator|<=
name|name
condition|)
return|return;
comment|/* compute hash value */
name|len
operator|=
call|(
name|int
call|)
argument_list|(
name|end
operator|-
name|name
argument_list|)
expr_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|len
condition|;
name|nn
operator|++
control|)
name|h
operator|=
name|h
operator|*
literal|33
operator|+
name|name
index|[
name|nn
index|]
expr_stmt|;
comment|/* check for an pre-existing name */
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_names
condition|;
name|nn
operator|++
control|)
block|{
name|nm
operator|=
name|the_names
operator|+
name|nn
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|nm
operator|->
name|hash
operator|==
name|h
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
name|nm
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|nm
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|0
condition|)
return|return;
block|}
comment|/* add new name */
if|if
condition|(
name|num_names
operator|>=
name|max_names
condition|)
block|{
name|max_names
operator|+=
operator|(
name|max_names
operator|>>
literal|1
operator|)
operator|+
literal|4
expr_stmt|;
name|the_names
operator|=
operator|(
name|NameRec
operator|*
operator|)
name|realloc
argument_list|(
name|the_names
argument_list|,
sizeof|sizeof
argument_list|(
name|the_names
index|[
literal|0
index|]
argument_list|)
operator|*
name|max_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_names
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"not enough memory"
argument_list|)
expr_stmt|;
block|}
name|nm
operator|=
operator|&
name|the_names
index|[
name|num_names
operator|++
index|]
expr_stmt|;
name|nm
operator|->
name|hash
operator|=
name|h
expr_stmt|;
name|nm
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm
operator|->
name|name
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"not enough memory"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nm
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nm
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|name_compare
name|name_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|name1
parameter_list|,
specifier|const
name|void
modifier|*
name|name2
parameter_list|)
block|{
name|Name
name|n1
init|=
operator|(
name|Name
operator|)
name|name1
decl_stmt|;
name|Name
name|n2
init|=
operator|(
name|Name
operator|)
name|name2
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|n1
operator|->
name|name
argument_list|,
name|n2
operator|->
name|name
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|names_sort
name|names_sort
parameter_list|(
name|void
parameter_list|)
block|{
name|qsort
argument_list|(
name|the_names
argument_list|,
operator|(
name|size_t
operator|)
name|num_names
argument_list|,
sizeof|sizeof
argument_list|(
name|the_names
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|name_compare
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|names_dump
name|names_dump
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|OutputFormat
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|dll_name
parameter_list|)
block|{
name|int
name|nn
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|OUTPUT_WINDOWS_DEF
case|:
if|if
condition|(
name|dll_name
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"LIBRARY %s\n"
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"DESCRIPTION  FreeType 2 DLL\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"EXPORTS\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_names
condition|;
name|nn
operator|++
control|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"  %s\n"
argument_list|,
name|the_names
index|[
name|nn
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_BORLAND_DEF
case|:
if|if
condition|(
name|dll_name
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"LIBRARY %s\n"
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"DESCRIPTION  FreeType 2 DLL\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"EXPORTS\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_names
condition|;
name|nn
operator|++
control|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"  _%s\n"
argument_list|,
name|the_names
index|[
name|nn
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_WATCOM_LBC
case|:
block|{
comment|/* we must omit the .dll suffix from the library name */
name|char
name|temp
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|dot
decl_stmt|;
if|if
condition|(
name|dll_name
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"you must provide a DLL name with the -d option !!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|dot
operator|=
name|strchr
argument_list|(
name|dll_name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
init|=
operator|(
name|dot
operator|-
name|dll_name
operator|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|temp
argument_list|,
name|dll_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|temp
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|dll_name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|temp
expr_stmt|;
block|}
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_names
condition|;
name|nn
operator|++
control|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"++_%s.%s.%s\n"
argument_list|,
name|the_names
index|[
name|nn
index|]
operator|.
name|name
argument_list|,
name|dll_name
argument_list|,
name|the_names
index|[
name|nn
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* LIST */
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_names
condition|;
name|nn
operator|++
control|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|the_names
index|[
name|nn
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* states of the line parser */
end_comment
begin_typedef
DECL|enum|State_
typedef|typedef
enum|enum
name|State_
block|{
DECL|enumerator|STATE_START
name|STATE_START
init|=
literal|0
block|,
comment|/* waiting for FT_EXPORT keyword and return type */
DECL|enumerator|STATE_TYPE
name|STATE_TYPE
comment|/* type was read, waiting for function name      */
block|}
DECL|typedef|State
name|State
typedef|;
end_typedef
begin_function
specifier|static
name|int
DECL|function|read_header_file
name|read_header_file
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
name|LINEBUFF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|State
name|state
init|=
name|STATE_START
decl_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|buff
argument_list|,
name|LINEBUFF_SIZE
argument_list|,
name|file
argument_list|)
condition|)
break|break;
name|p
operator|=
name|buff
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\\'
operator|)
condition|)
comment|/* skip leading whitespace */
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
comment|/* skip empty lines */
continue|continue;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|STATE_START
case|:
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"FT_EXPORT("
argument_list|,
literal|10
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|p
operator|+=
literal|10
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
goto|goto
name|NextLine
goto|;
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
block|{
name|p
operator|++
expr_stmt|;
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
name|state
operator|=
name|STATE_TYPE
expr_stmt|;
comment|/* sometimes, the name is just after the FT_EXPORT(...), so           * skip whitespace, and fall-through if we find an alphanumeric           * character           */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
block|}
comment|/* fall-through */
case|case
name|STATE_TYPE
case|:
block|{
name|char
modifier|*
name|name
init|=
name|p
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|name
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">>> %.*s\n"
argument_list|,
name|p
operator|-
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|names_add
argument_list|(
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|STATE_START
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
name|NextLine
label|:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|usage
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|format
init|=
literal|"%s %s: extract FreeType API names from header files\n\n"
literal|"this program is used to extract the list of public FreeType API\n"
literal|"functions. It receives the list of header files as argument and\n"
literal|"generates a sorted list of unique identifiers\n\n"
literal|"usage: %s header1 [options] [header2 ...]\n\n"
literal|"options:   -      : parse the content of stdin, ignore arguments\n"
literal|"           -v     : verbose mode, output sent to standard error\n"
literal|"           -oFILE : write output to FILE instead of standard output\n"
literal|"           -dNAME : indicate DLL file name, 'freetype.dll' by default\n"
literal|"           -w     : output .DEF file for Visual C++ and Mingw\n"
literal|"           -wB    : output .DEF file for Borland C++\n"
literal|"           -wW    : output Watcom Linker Response File\n"
literal|"\n"
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|PROGRAM_NAME
argument_list|,
name|PROGRAM_VERSION
argument_list|,
name|PROGRAM_NAME
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|from_stdin
init|=
literal|0
decl_stmt|;
name|int
name|verbose
init|=
literal|0
decl_stmt|;
name|OutputFormat
name|format
init|=
name|OUTPUT_LIST
decl_stmt|;
comment|/* the default */
name|FILE
modifier|*
name|out
init|=
name|stdout
decl_stmt|;
specifier|const
name|char
modifier|*
name|library_name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* '-' used as a single argument means read source file from stdin */
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
specifier|const
name|char
modifier|*
name|arg
init|=
name|argv
index|[
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|arg
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
name|arg
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
else|else
name|arg
operator|+=
literal|2
expr_stmt|;
name|out
operator|=
name|fopen
argument_list|(
name|arg
argument_list|,
literal|"wt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not open '%s' for writing\n"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
name|arg
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
else|else
name|arg
operator|+=
literal|2
expr_stmt|;
name|library_name
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|format
operator|=
name|OUTPUT_WINDOWS_DEF
expr_stmt|;
switch|switch
condition|(
name|arg
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'B'
case|:
name|format
operator|=
name|OUTPUT_BORLAND_DEF
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|format
operator|=
name|OUTPUT_WATCOM_LBC
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
name|from_stdin
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|from_stdin
condition|)
block|{
name|read_header_file
argument_list|(
name|stdin
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
operator|--
name|argc
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
name|FILE
modifier|*
name|file
init|=
name|fopen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to open '%s'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"opening '%s'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|read_header_file
argument_list|(
name|file
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|num_names
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"could not find exported functions !!\n"
argument_list|)
expr_stmt|;
name|names_sort
argument_list|()
expr_stmt|;
name|names_dump
argument_list|(
name|out
argument_list|,
name|format
argument_list|,
name|library_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
