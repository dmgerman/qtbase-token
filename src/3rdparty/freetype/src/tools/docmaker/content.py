begin_unit
comment|'#  Content (c) 2002, 2004, 2006, 2007, 2008, 2009'
nl|'\n'
comment|'#    David Turner <david@freetype.org>'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  This file contains routines used to parse the content of documentation'
nl|'\n'
comment|'#  comment blocks and build more structured objects out of them.'
nl|'\n'
comment|'#'
nl|'\n'
nl|'\n'
name|'from'
name|'sources'
name|'import'
op|'*'
newline|'\n'
name|'from'
name|'utils'
name|'import'
op|'*'
newline|'\n'
name|'import'
name|'string'
op|','
name|'re'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# this regular expression is used to detect code sequences. these'
nl|'\n'
comment|"# are simply code fragments embedded in '{' and '}' like in:"
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  {'
nl|'\n'
comment|'#    x = y + z;'
nl|'\n'
comment|'#    if ( zookoo == 2 )'
nl|'\n'
comment|'#    {'
nl|'\n'
comment|'#      foobar();'
nl|'\n'
comment|'#    }'
nl|'\n'
comment|'#  }'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# note that indentation of the starting and ending accolades must be'
nl|'\n'
comment|'# exactly the same. the code sequence can contain accolades at greater'
nl|'\n'
comment|'# indentation'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_code_start
name|'re_code_start'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|'r"(\\s*){\\s*$"'
op|')'
newline|'\n'
DECL|variable|re_code_end
name|'re_code_end'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|'r"(\\s*)}\\s*$"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# this regular expression is used to isolate identifiers from'
nl|'\n'
comment|'# other text'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_identifier
name|'re_identifier'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'(\\w*)'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|"# we collect macros ending in `_H'; while outputting the object data, we use"
nl|'\n'
comment|"# this info together with the object's file location to emit the appropriate"
nl|'\n'
comment|'# header file macro and name before the object itself'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_header_macro
name|'re_header_macro'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'^#define\\s{1,}(\\w{1,}_H)\\s{1,}<(.*)>'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#############################################################################'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# The DocCode class is used to store source code lines.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"#   'self.lines' contains a set of source code lines that will be dumped as"
nl|'\n'
comment|'#   HTML in a <PRE> tag.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#   The object is filled line by line by the parser; it strips the leading'
nl|'\n'
comment|'#   "margin" space from each input line before storing it in \'self.lines\'.'
nl|'\n'
comment|'#'
nl|'\n'
DECL|class|DocCode
name|'class'
name|'DocCode'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'margin'
op|','
name|'lines'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'lines'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'words'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# remove margin spaces'
nl|'\n'
name|'for'
name|'l'
name|'in'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'string'
op|'.'
name|'strip'
op|'('
name|'l'
op|'['
op|':'
name|'margin'
op|']'
op|')'
op|'=='
string|'""'
op|':'
newline|'\n'
indent|'                '
name|'l'
op|'='
name|'l'
op|'['
name|'margin'
op|':'
op|']'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'lines'
op|'.'
name|'append'
op|'('
name|'l'
op|')'
newline|'\n'
nl|'\n'
DECL|member|dump
dedent|''
dedent|''
name|'def'
name|'dump'
op|'('
name|'self'
op|','
name|'prefix'
op|'='
string|'""'
op|','
name|'width'
op|'='
number|'60'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'lines'
op|'='
name|'self'
op|'.'
name|'dump_lines'
op|'('
number|'0'
op|','
name|'width'
op|')'
newline|'\n'
name|'for'
name|'l'
name|'in'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'print'
name|'prefix'
op|'+'
name|'l'
newline|'\n'
nl|'\n'
DECL|member|dump_lines
dedent|''
dedent|''
name|'def'
name|'dump_lines'
op|'('
name|'self'
op|','
name|'margin'
op|'='
number|'0'
op|','
name|'width'
op|'='
number|'60'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'l'
name|'in'
name|'self'
op|'.'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'.'
name|'append'
op|'('
string|'" "'
op|'*'
name|'margin'
op|'+'
name|'l'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'#############################################################################'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# The DocPara class is used to store "normal" text paragraph.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"#   'self.words' contains the list of words that make up the paragraph"
nl|'\n'
comment|'#'
nl|'\n'
DECL|class|DocPara
dedent|''
dedent|''
name|'class'
name|'DocPara'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'lines'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'lines'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'words'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'l'
name|'in'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'l'
op|'='
name|'string'
op|'.'
name|'strip'
op|'('
name|'l'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'words'
op|'.'
name|'extend'
op|'('
name|'string'
op|'.'
name|'split'
op|'('
name|'l'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|dump
dedent|''
dedent|''
name|'def'
name|'dump'
op|'('
name|'self'
op|','
name|'prefix'
op|'='
string|'""'
op|','
name|'width'
op|'='
number|'60'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'lines'
op|'='
name|'self'
op|'.'
name|'dump_lines'
op|'('
number|'0'
op|','
name|'width'
op|')'
newline|'\n'
name|'for'
name|'l'
name|'in'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'print'
name|'prefix'
op|'+'
name|'l'
newline|'\n'
nl|'\n'
DECL|member|dump_lines
dedent|''
dedent|''
name|'def'
name|'dump_lines'
op|'('
name|'self'
op|','
name|'margin'
op|'='
number|'0'
op|','
name|'width'
op|'='
number|'60'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cur'
op|'='
string|'""'
comment|'# current line'
newline|'\n'
name|'col'
op|'='
number|'0'
comment|'# current width'
newline|'\n'
name|'result'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'word'
name|'in'
name|'self'
op|'.'
name|'words'
op|':'
newline|'\n'
indent|'            '
name|'ln'
op|'='
name|'len'
op|'('
name|'word'
op|')'
newline|'\n'
name|'if'
name|'col'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'ln'
op|'='
name|'ln'
op|'+'
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'col'
op|'+'
name|'ln'
op|'>'
name|'width'
op|':'
newline|'\n'
indent|'                '
name|'result'
op|'.'
name|'append'
op|'('
string|'" "'
op|'*'
name|'margin'
op|'+'
name|'cur'
op|')'
newline|'\n'
name|'cur'
op|'='
name|'word'
newline|'\n'
name|'col'
op|'='
name|'len'
op|'('
name|'word'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'col'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'cur'
op|'='
name|'cur'
op|'+'
string|'" "'
newline|'\n'
dedent|''
name|'cur'
op|'='
name|'cur'
op|'+'
name|'word'
newline|'\n'
name|'col'
op|'='
name|'col'
op|'+'
name|'ln'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'col'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'.'
name|'append'
op|'('
string|'" "'
op|'*'
name|'margin'
op|'+'
name|'cur'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'#############################################################################'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  The DocField class is used to store a list containing either DocPara or'
nl|'\n'
comment|'#  DocCode objects. Each DocField also has an optional "name" which is used'
nl|'\n'
comment|'#  when the object corresponds to a field or value definition'
nl|'\n'
comment|'#'
nl|'\n'
DECL|class|DocField
dedent|''
dedent|''
name|'class'
name|'DocField'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'lines'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'name'
op|'='
name|'name'
comment|'# can be None for normal paragraphs/sources'
newline|'\n'
name|'self'
op|'.'
name|'items'
op|'='
op|'['
op|']'
comment|'# list of items'
newline|'\n'
nl|'\n'
name|'mode_none'
op|'='
number|'0'
comment|'# start parsing mode'
newline|'\n'
name|'mode_code'
op|'='
number|'1'
comment|'# parsing code sequences'
newline|'\n'
name|'mode_para'
op|'='
number|'3'
comment|'# parsing normal paragraph'
newline|'\n'
nl|'\n'
name|'margin'
op|'='
op|'-'
number|'1'
comment|'# current code sequence indentation'
newline|'\n'
name|'cur_lines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# now analyze the markup lines to see if they contain paragraphs,'
nl|'\n'
comment|'# code sequences or fields definitions'
nl|'\n'
comment|'#'
nl|'\n'
name|'start'
op|'='
number|'0'
newline|'\n'
name|'mode'
op|'='
name|'mode_none'
newline|'\n'
nl|'\n'
name|'for'
name|'l'
name|'in'
name|'lines'
op|':'
newline|'\n'
comment|'# are we parsing a code sequence ?'
nl|'\n'
indent|'            '
name|'if'
name|'mode'
op|'=='
name|'mode_code'
op|':'
newline|'\n'
indent|'                '
name|'m'
op|'='
name|'re_code_end'
op|'.'
name|'match'
op|'('
name|'l'
op|')'
newline|'\n'
name|'if'
name|'m'
name|'and'
name|'len'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
op|')'
op|'<='
name|'margin'
op|':'
newline|'\n'
comment|"# that's it, we finished the code sequence"
nl|'\n'
indent|'                    '
name|'code'
op|'='
name|'DocCode'
op|'('
number|'0'
op|','
name|'cur_lines'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'items'
op|'.'
name|'append'
op|'('
name|'code'
op|')'
newline|'\n'
name|'margin'
op|'='
op|'-'
number|'1'
newline|'\n'
name|'cur_lines'
op|'='
op|'['
op|']'
newline|'\n'
name|'mode'
op|'='
name|'mode_none'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# nope, continue the code sequence'
nl|'\n'
indent|'                    '
name|'cur_lines'
op|'.'
name|'append'
op|'('
name|'l'
op|'['
name|'margin'
op|':'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# start of code sequence ?'
nl|'\n'
indent|'                '
name|'m'
op|'='
name|'re_code_start'
op|'.'
name|'match'
op|'('
name|'l'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
comment|'# save current lines'
nl|'\n'
indent|'                    '
name|'if'
name|'cur_lines'
op|':'
newline|'\n'
indent|'                        '
name|'para'
op|'='
name|'DocPara'
op|'('
name|'cur_lines'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'items'
op|'.'
name|'append'
op|'('
name|'para'
op|')'
newline|'\n'
name|'cur_lines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# switch to code extraction mode'
nl|'\n'
dedent|''
name|'margin'
op|'='
name|'len'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
op|')'
newline|'\n'
name|'mode'
op|'='
name|'mode_code'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'not'
name|'string'
op|'.'
name|'split'
op|'('
name|'l'
op|')'
name|'and'
name|'cur_lines'
op|':'
newline|'\n'
comment|'# if the line is empty, we end the current paragraph,'
nl|'\n'
comment|'# if any'
nl|'\n'
indent|'                        '
name|'para'
op|'='
name|'DocPara'
op|'('
name|'cur_lines'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'items'
op|'.'
name|'append'
op|'('
name|'para'
op|')'
newline|'\n'
name|'cur_lines'
op|'='
op|'['
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# otherwise, simply add the line to the current'
nl|'\n'
comment|'# paragraph'
nl|'\n'
indent|'                        '
name|'cur_lines'
op|'.'
name|'append'
op|'('
name|'l'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'if'
name|'mode'
op|'=='
name|'mode_code'
op|':'
newline|'\n'
comment|'# unexpected end of code sequence'
nl|'\n'
indent|'            '
name|'code'
op|'='
name|'DocCode'
op|'('
name|'margin'
op|','
name|'cur_lines'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'items'
op|'.'
name|'append'
op|'('
name|'code'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'cur_lines'
op|':'
newline|'\n'
indent|'            '
name|'para'
op|'='
name|'DocPara'
op|'('
name|'cur_lines'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'items'
op|'.'
name|'append'
op|'('
name|'para'
op|')'
newline|'\n'
nl|'\n'
DECL|member|dump
dedent|''
dedent|''
name|'def'
name|'dump'
op|'('
name|'self'
op|','
name|'prefix'
op|'='
string|'""'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'field'
op|':'
newline|'\n'
indent|'            '
name|'print'
name|'prefix'
op|'+'
name|'self'
op|'.'
name|'field'
op|'+'
string|'" ::"'
newline|'\n'
name|'prefix'
op|'='
name|'prefix'
op|'+'
string|'"----"'
newline|'\n'
nl|'\n'
dedent|''
name|'first'
op|'='
number|'1'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'self'
op|'.'
name|'items'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'first'
op|':'
newline|'\n'
indent|'                '
name|'print'
string|'""'
newline|'\n'
dedent|''
name|'p'
op|'.'
name|'dump'
op|'('
name|'prefix'
op|')'
newline|'\n'
name|'first'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|dump_lines
dedent|''
dedent|''
name|'def'
name|'dump_lines'
op|'('
name|'self'
op|','
name|'margin'
op|'='
number|'0'
op|','
name|'width'
op|'='
number|'60'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
op|'['
op|']'
newline|'\n'
name|'nl'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'for'
name|'p'
name|'in'
name|'self'
op|'.'
name|'items'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'nl'
op|':'
newline|'\n'
indent|'                '
name|'result'
op|'.'
name|'append'
op|'('
string|'""'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'result'
op|'.'
name|'extend'
op|'('
name|'p'
op|'.'
name|'dump_lines'
op|'('
name|'margin'
op|','
name|'width'
op|')'
op|')'
newline|'\n'
name|'nl'
op|'='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'# this regular expression is used to detect field definitions'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_field
dedent|''
dedent|''
name|'re_field'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|'r"\\s*(\\w*|\\w(\\w|\\.)*\\w)\\s*::"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DocMarkup
name|'class'
name|'DocMarkup'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'tag'
op|','
name|'lines'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'tag'
op|'='
name|'string'
op|'.'
name|'lower'
op|'('
name|'tag'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'fields'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'cur_lines'
op|'='
op|'['
op|']'
newline|'\n'
name|'field'
op|'='
name|'None'
newline|'\n'
name|'mode'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'for'
name|'l'
name|'in'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'m'
op|'='
name|'re_field'
op|'.'
name|'match'
op|'('
name|'l'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
comment|'# we detected the start of a new field definition'
nl|'\n'
nl|'\n'
comment|'# first, save the current one'
nl|'\n'
indent|'                '
name|'if'
name|'cur_lines'
op|':'
newline|'\n'
indent|'                    '
name|'f'
op|'='
name|'DocField'
op|'('
name|'field'
op|','
name|'cur_lines'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'fields'
op|'.'
name|'append'
op|'('
name|'f'
op|')'
newline|'\n'
name|'cur_lines'
op|'='
op|'['
op|']'
newline|'\n'
name|'field'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'field'
op|'='
name|'m'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
comment|'# record field name'
newline|'\n'
name|'ln'
op|'='
name|'len'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
name|'l'
op|'='
string|'" "'
op|'*'
name|'ln'
op|'+'
name|'l'
op|'['
name|'ln'
op|':'
op|']'
newline|'\n'
name|'cur_lines'
op|'='
op|'['
name|'l'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'cur_lines'
op|'.'
name|'append'
op|'('
name|'l'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'field'
name|'or'
name|'cur_lines'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'='
name|'DocField'
op|'('
name|'field'
op|','
name|'cur_lines'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'fields'
op|'.'
name|'append'
op|'('
name|'f'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_name
dedent|''
dedent|''
name|'def'
name|'get_name'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'fields'
op|'['
number|'0'
op|']'
op|'.'
name|'items'
op|'['
number|'0'
op|']'
op|'.'
name|'words'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
DECL|member|get_start
dedent|''
dedent|''
name|'def'
name|'get_start'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
string|'""'
newline|'\n'
name|'for'
name|'word'
name|'in'
name|'self'
op|'.'
name|'fields'
op|'['
number|'0'
op|']'
op|'.'
name|'items'
op|'['
number|'0'
op|']'
op|'.'
name|'words'
op|':'
newline|'\n'
indent|'                '
name|'result'
op|'='
name|'result'
op|'+'
string|'" "'
op|'+'
name|'word'
newline|'\n'
dedent|''
name|'return'
name|'result'
op|'['
number|'1'
op|':'
op|']'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|'"ERROR"'
newline|'\n'
nl|'\n'
DECL|member|dump
dedent|''
dedent|''
name|'def'
name|'dump'
op|'('
name|'self'
op|','
name|'margin'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'print'
string|'" "'
op|'*'
name|'margin'
op|'+'
string|'"<"'
op|'+'
name|'self'
op|'.'
name|'tag'
op|'+'
string|'">"'
newline|'\n'
name|'for'
name|'f'
name|'in'
name|'self'
op|'.'
name|'fields'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'.'
name|'dump'
op|'('
string|'"  "'
op|')'
newline|'\n'
dedent|''
name|'print'
string|'" "'
op|'*'
name|'margin'
op|'+'
string|'"</"'
op|'+'
name|'self'
op|'.'
name|'tag'
op|'+'
string|'">"'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DocChapter
dedent|''
dedent|''
name|'class'
name|'DocChapter'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'block'
op|'='
name|'block'
newline|'\n'
name|'self'
op|'.'
name|'sections'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'block'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'name'
op|'='
name|'block'
op|'.'
name|'name'
newline|'\n'
name|'self'
op|'.'
name|'title'
op|'='
name|'block'
op|'.'
name|'get_markup_words'
op|'('
string|'"title"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'order'
op|'='
name|'block'
op|'.'
name|'get_markup_words'
op|'('
string|'"sections"'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'name'
op|'='
string|'"Other"'
newline|'\n'
name|'self'
op|'.'
name|'title'
op|'='
name|'string'
op|'.'
name|'split'
op|'('
string|'"Miscellaneous"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'order'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DocSection
dedent|''
dedent|''
dedent|''
name|'class'
name|'DocSection'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'name'
op|'='
string|'"Other"'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'name'
op|'='
name|'name'
newline|'\n'
name|'self'
op|'.'
name|'blocks'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'block_names'
op|'='
op|'['
op|']'
comment|'# ordered block names in section'
newline|'\n'
name|'self'
op|'.'
name|'defs'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'abstract'
op|'='
string|'""'
newline|'\n'
name|'self'
op|'.'
name|'description'
op|'='
string|'""'
newline|'\n'
name|'self'
op|'.'
name|'order'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'title'
op|'='
string|'"ERROR"'
newline|'\n'
name|'self'
op|'.'
name|'chapter'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|add_def
dedent|''
name|'def'
name|'add_def'
op|'('
name|'self'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'defs'
op|'.'
name|'append'
op|'('
name|'block'
op|')'
newline|'\n'
nl|'\n'
DECL|member|add_block
dedent|''
name|'def'
name|'add_block'
op|'('
name|'self'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'block_names'
op|'.'
name|'append'
op|'('
name|'block'
op|'.'
name|'name'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'blocks'
op|'['
name|'block'
op|'.'
name|'name'
op|']'
op|'='
name|'block'
newline|'\n'
nl|'\n'
DECL|member|process
dedent|''
name|'def'
name|'process'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# look up one block that contains a valid section description'
nl|'\n'
indent|'        '
name|'for'
name|'block'
name|'in'
name|'self'
op|'.'
name|'defs'
op|':'
newline|'\n'
indent|'            '
name|'title'
op|'='
name|'block'
op|'.'
name|'get_markup_text'
op|'('
string|'"title"'
op|')'
newline|'\n'
name|'if'
name|'title'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'title'
op|'='
name|'title'
newline|'\n'
name|'self'
op|'.'
name|'abstract'
op|'='
name|'block'
op|'.'
name|'get_markup_words'
op|'('
string|'"abstract"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'description'
op|'='
name|'block'
op|'.'
name|'get_markup_items'
op|'('
string|'"description"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'order'
op|'='
name|'block'
op|'.'
name|'get_markup_words'
op|'('
string|'"order"'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
DECL|member|reorder
dedent|''
dedent|''
dedent|''
name|'def'
name|'reorder'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'block_names'
op|'='
name|'sort_order_list'
op|'('
name|'self'
op|'.'
name|'block_names'
op|','
name|'self'
op|'.'
name|'order'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ContentProcessor
dedent|''
dedent|''
name|'class'
name|'ContentProcessor'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""initialize a block content processor"""'
newline|'\n'
name|'self'
op|'.'
name|'reset'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'sections'
op|'='
op|'{'
op|'}'
comment|'# dictionary of documentation sections'
newline|'\n'
name|'self'
op|'.'
name|'section'
op|'='
name|'None'
comment|'# current documentation section'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'chapters'
op|'='
op|'['
op|']'
comment|'# list of chapters'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'headers'
op|'='
op|'{'
op|'}'
comment|'# dictionary of header macros'
newline|'\n'
nl|'\n'
DECL|member|set_section
dedent|''
name|'def'
name|'set_section'
op|'('
name|'self'
op|','
name|'section_name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""set current section during parsing"""'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'sections'
op|'.'
name|'has_key'
op|'('
name|'section_name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'section'
op|'='
name|'DocSection'
op|'('
name|'section_name'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sections'
op|'['
name|'section_name'
op|']'
op|'='
name|'section'
newline|'\n'
name|'self'
op|'.'
name|'section'
op|'='
name|'section'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'section'
op|'='
name|'self'
op|'.'
name|'sections'
op|'['
name|'section_name'
op|']'
newline|'\n'
nl|'\n'
DECL|member|add_chapter
dedent|''
dedent|''
name|'def'
name|'add_chapter'
op|'('
name|'self'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'chapter'
op|'='
name|'DocChapter'
op|'('
name|'block'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'chapters'
op|'.'
name|'append'
op|'('
name|'chapter'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|reset
dedent|''
name|'def'
name|'reset'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""reset the content processor for a new block"""'
newline|'\n'
name|'self'
op|'.'
name|'markups'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'markup'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'markup_lines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|add_markup
dedent|''
name|'def'
name|'add_markup'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""add a new markup section"""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'markup'
name|'and'
name|'self'
op|'.'
name|'markup_lines'
op|':'
newline|'\n'
nl|'\n'
comment|"# get rid of last line of markup if it's empty"
nl|'\n'
indent|'            '
name|'marks'
op|'='
name|'self'
op|'.'
name|'markup_lines'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'marks'
op|')'
op|'>'
number|'0'
name|'and'
name|'not'
name|'string'
op|'.'
name|'strip'
op|'('
name|'marks'
op|'['
op|'-'
number|'1'
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'markup_lines'
op|'='
name|'marks'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'m'
op|'='
name|'DocMarkup'
op|'('
name|'self'
op|'.'
name|'markup'
op|','
name|'self'
op|'.'
name|'markup_lines'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'markups'
op|'.'
name|'append'
op|'('
name|'m'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'markup'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'markup_lines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|process_content
dedent|''
dedent|''
name|'def'
name|'process_content'
op|'('
name|'self'
op|','
name|'content'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""process a block content and return a list of DocMarkup objects\n           corresponding to it"""'
newline|'\n'
name|'markup'
op|'='
name|'None'
newline|'\n'
name|'markup_lines'
op|'='
op|'['
op|']'
newline|'\n'
name|'first'
op|'='
number|'1'
newline|'\n'
nl|'\n'
name|'for'
name|'line'
name|'in'
name|'content'
op|':'
newline|'\n'
indent|'            '
name|'found'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'t'
name|'in'
name|'re_markup_tags'
op|':'
newline|'\n'
indent|'                '
name|'m'
op|'='
name|'t'
op|'.'
name|'match'
op|'('
name|'line'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
indent|'                    '
name|'found'
op|'='
name|'string'
op|'.'
name|'lower'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
op|')'
newline|'\n'
name|'prefix'
op|'='
name|'len'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
name|'line'
op|'='
string|'" "'
op|'*'
name|'prefix'
op|'+'
name|'line'
op|'['
name|'prefix'
op|':'
op|']'
comment|'# remove markup from line'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
comment|'# is it the start of a new markup section ?'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'found'
op|':'
newline|'\n'
indent|'                '
name|'first'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'add_markup'
op|'('
op|')'
comment|'# add current markup content'
newline|'\n'
name|'self'
op|'.'
name|'markup'
op|'='
name|'found'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'string'
op|'.'
name|'strip'
op|'('
name|'line'
op|')'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'markup_lines'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'first'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'markup_lines'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'add_markup'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'markups'
newline|'\n'
nl|'\n'
DECL|member|parse_sources
dedent|''
name|'def'
name|'parse_sources'
op|'('
name|'self'
op|','
name|'source_processor'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'blocks'
op|'='
name|'source_processor'
op|'.'
name|'blocks'
newline|'\n'
name|'count'
op|'='
name|'len'
op|'('
name|'blocks'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'n'
name|'in'
name|'range'
op|'('
name|'count'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'source'
op|'='
name|'blocks'
op|'['
name|'n'
op|']'
newline|'\n'
name|'if'
name|'source'
op|'.'
name|'content'
op|':'
newline|'\n'
comment|'# this is a documentation comment, we need to catch'
nl|'\n'
comment|'# all following normal blocks in the "follow" list'
nl|'\n'
comment|'#'
nl|'\n'
indent|'                '
name|'follow'
op|'='
op|'['
op|']'
newline|'\n'
name|'m'
op|'='
name|'n'
op|'+'
number|'1'
newline|'\n'
name|'while'
name|'m'
op|'<'
name|'count'
name|'and'
name|'not'
name|'blocks'
op|'['
name|'m'
op|']'
op|'.'
name|'content'
op|':'
newline|'\n'
indent|'                    '
name|'follow'
op|'.'
name|'append'
op|'('
name|'blocks'
op|'['
name|'m'
op|']'
op|')'
newline|'\n'
name|'m'
op|'='
name|'m'
op|'+'
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'doc_block'
op|'='
name|'DocBlock'
op|'('
name|'source'
op|','
name|'follow'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|finish
dedent|''
dedent|''
dedent|''
name|'def'
name|'finish'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# process all sections to extract their abstract, description'
nl|'\n'
comment|'# and ordered list of items'
nl|'\n'
comment|'#'
nl|'\n'
indent|'        '
name|'for'
name|'sec'
name|'in'
name|'self'
op|'.'
name|'sections'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'sec'
op|'.'
name|'process'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# process chapters to check that all sections are correctly'
nl|'\n'
comment|'# listed there'
nl|'\n'
dedent|''
name|'for'
name|'chap'
name|'in'
name|'self'
op|'.'
name|'chapters'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'sec'
name|'in'
name|'chap'
op|'.'
name|'order'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'sections'
op|'.'
name|'has_key'
op|'('
name|'sec'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'section'
op|'='
name|'self'
op|'.'
name|'sections'
op|'['
name|'sec'
op|']'
newline|'\n'
name|'section'
op|'.'
name|'chapter'
op|'='
name|'chap'
newline|'\n'
name|'section'
op|'.'
name|'reorder'
op|'('
op|')'
newline|'\n'
name|'chap'
op|'.'
name|'sections'
op|'.'
name|'append'
op|'('
name|'section'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'sys'
op|'.'
name|'stderr'
op|'.'
name|'write'
op|'('
string|'"WARNING: chapter \'"'
op|'+'
name|'chap'
op|'.'
name|'name'
op|'+'
string|'"\' in "'
op|'+'
name|'chap'
op|'.'
name|'block'
op|'.'
name|'location'
op|'('
op|')'
op|'+'
string|'" lists unknown section \'"'
op|'+'
name|'sec'
op|'+'
string|'"\'\\n"'
op|')'
newline|'\n'
nl|'\n'
comment|'# check that all sections are in a chapter'
nl|'\n'
comment|'#'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'others'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'sec'
name|'in'
name|'self'
op|'.'
name|'sections'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'sec'
op|'.'
name|'chapter'
op|':'
newline|'\n'
indent|'                '
name|'others'
op|'.'
name|'append'
op|'('
name|'sec'
op|')'
newline|'\n'
nl|'\n'
comment|'# create a new special chapter for all remaining sections'
nl|'\n'
comment|'# when necessary'
nl|'\n'
comment|'#'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'others'
op|':'
newline|'\n'
indent|'            '
name|'chap'
op|'='
name|'DocChapter'
op|'('
name|'None'
op|')'
newline|'\n'
name|'chap'
op|'.'
name|'sections'
op|'='
name|'others'
newline|'\n'
name|'self'
op|'.'
name|'chapters'
op|'.'
name|'append'
op|'('
name|'chap'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DocBlock
dedent|''
dedent|''
dedent|''
name|'class'
name|'DocBlock'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'source'
op|','
name|'follow'
op|','
name|'processor'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'processor'
op|'.'
name|'reset'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'source'
op|'='
name|'source'
newline|'\n'
name|'self'
op|'.'
name|'code'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'type'
op|'='
string|'"ERRTYPE"'
newline|'\n'
name|'self'
op|'.'
name|'name'
op|'='
string|'"ERRNAME"'
newline|'\n'
name|'self'
op|'.'
name|'section'
op|'='
name|'processor'
op|'.'
name|'section'
newline|'\n'
name|'self'
op|'.'
name|'markups'
op|'='
name|'processor'
op|'.'
name|'process_content'
op|'('
name|'source'
op|'.'
name|'content'
op|')'
newline|'\n'
nl|'\n'
comment|'# compute block type from first markup tag'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'type'
op|'='
name|'self'
op|'.'
name|'markups'
op|'['
number|'0'
op|']'
op|'.'
name|'tag'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# compute block name from first markup paragraph'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'markup'
op|'='
name|'self'
op|'.'
name|'markups'
op|'['
number|'0'
op|']'
newline|'\n'
name|'para'
op|'='
name|'markup'
op|'.'
name|'fields'
op|'['
number|'0'
op|']'
op|'.'
name|'items'
op|'['
number|'0'
op|']'
newline|'\n'
name|'name'
op|'='
name|'para'
op|'.'
name|'words'
op|'['
number|'0'
op|']'
newline|'\n'
name|'m'
op|'='
name|'re_identifier'
op|'.'
name|'match'
op|'('
name|'name'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
indent|'                '
name|'name'
op|'='
name|'m'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'name'
op|'='
name|'name'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'type'
op|'=='
string|'"section"'
op|':'
newline|'\n'
comment|'# detect new section starts'
nl|'\n'
indent|'            '
name|'processor'
op|'.'
name|'set_section'
op|'('
name|'self'
op|'.'
name|'name'
op|')'
newline|'\n'
name|'processor'
op|'.'
name|'section'
op|'.'
name|'add_def'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'type'
op|'=='
string|'"chapter"'
op|':'
newline|'\n'
comment|'# detect new chapter'
nl|'\n'
indent|'            '
name|'processor'
op|'.'
name|'add_chapter'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'processor'
op|'.'
name|'section'
op|'.'
name|'add_block'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
comment|'# now, compute the source lines relevant to this documentation'
nl|'\n'
comment|'# block. We keep normal comments in for obvious reasons (??)'
nl|'\n'
dedent|''
name|'source'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'b'
name|'in'
name|'follow'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'b'
op|'.'
name|'format'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
name|'for'
name|'l'
name|'in'
name|'b'
op|'.'
name|'lines'
op|':'
newline|'\n'
comment|'# collect header macro definitions'
nl|'\n'
indent|'                '
name|'m'
op|'='
name|'re_header_macro'
op|'.'
name|'match'
op|'('
name|'l'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
indent|'                    '
name|'processor'
op|'.'
name|'headers'
op|'['
name|'m'
op|'.'
name|'group'
op|'('
number|'2'
op|')'
op|']'
op|'='
name|'m'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
op|';'
newline|'\n'
nl|'\n'
comment|'# we use "/* */" as a separator'
nl|'\n'
dedent|''
name|'if'
name|'re_source_sep'
op|'.'
name|'match'
op|'('
name|'l'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
dedent|''
name|'source'
op|'.'
name|'append'
op|'('
name|'l'
op|')'
newline|'\n'
nl|'\n'
comment|'# now strip the leading and trailing empty lines from the sources'
nl|'\n'
dedent|''
dedent|''
name|'start'
op|'='
number|'0'
newline|'\n'
name|'end'
op|'='
name|'len'
op|'('
name|'source'
op|')'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
name|'while'
name|'start'
op|'<'
name|'end'
name|'and'
name|'not'
name|'string'
op|'.'
name|'strip'
op|'('
name|'source'
op|'['
name|'start'
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'start'
op|'='
name|'start'
op|'+'
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'start'
op|'<'
name|'end'
name|'and'
name|'not'
name|'string'
op|'.'
name|'strip'
op|'('
name|'source'
op|'['
name|'end'
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'end'
op|'='
name|'end'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'start'
op|'=='
name|'end'
name|'and'
name|'not'
name|'string'
op|'.'
name|'strip'
op|'('
name|'source'
op|'['
name|'start'
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'code'
op|'='
op|'['
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'code'
op|'='
name|'source'
op|'['
name|'start'
op|':'
name|'end'
op|'+'
number|'1'
op|']'
newline|'\n'
nl|'\n'
DECL|member|location
dedent|''
dedent|''
name|'def'
name|'location'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'source'
op|'.'
name|'location'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_markup
dedent|''
name|'def'
name|'get_markup'
op|'('
name|'self'
op|','
name|'tag_name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""return the DocMarkup corresponding to a given tag in a block"""'
newline|'\n'
name|'for'
name|'m'
name|'in'
name|'self'
op|'.'
name|'markups'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'m'
op|'.'
name|'tag'
op|'=='
name|'string'
op|'.'
name|'lower'
op|'('
name|'tag_name'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'m'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
DECL|member|get_markup_name
dedent|''
name|'def'
name|'get_markup_name'
op|'('
name|'self'
op|','
name|'tag_name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""return the name of a given primary markup in a block"""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'m'
op|'='
name|'self'
op|'.'
name|'get_markup'
op|'('
name|'tag_name'
op|')'
newline|'\n'
name|'return'
name|'m'
op|'.'
name|'get_name'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
DECL|member|get_markup_words
dedent|''
dedent|''
name|'def'
name|'get_markup_words'
op|'('
name|'self'
op|','
name|'tag_name'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'m'
op|'='
name|'self'
op|'.'
name|'get_markup'
op|'('
name|'tag_name'
op|')'
newline|'\n'
name|'return'
name|'m'
op|'.'
name|'fields'
op|'['
number|'0'
op|']'
op|'.'
name|'items'
op|'['
number|'0'
op|']'
op|'.'
name|'words'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|get_markup_text
dedent|''
dedent|''
name|'def'
name|'get_markup_text'
op|'('
name|'self'
op|','
name|'tag_name'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
name|'self'
op|'.'
name|'get_markup_words'
op|'('
name|'tag_name'
op|')'
newline|'\n'
name|'return'
name|'string'
op|'.'
name|'join'
op|'('
name|'result'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_markup_items
dedent|''
name|'def'
name|'get_markup_items'
op|'('
name|'self'
op|','
name|'tag_name'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'m'
op|'='
name|'self'
op|'.'
name|'get_markup'
op|'('
name|'tag_name'
op|')'
newline|'\n'
name|'return'
name|'m'
op|'.'
name|'fields'
op|'['
number|'0'
op|']'
op|'.'
name|'items'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
comment|'# eof'
nl|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
