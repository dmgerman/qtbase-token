begin_unit
comment|'#'
nl|'\n'
comment|'#  sources.py'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Convert source code comments to multi-line blocks (library file).'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  Copyright 2002-2015 by'
nl|'\n'
comment|'#  David Turner.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  This file is part of the FreeType project, and may only be used,'
nl|'\n'
comment|'#  modified, and distributed under the terms of the FreeType project'
nl|'\n'
comment|'#  license, LICENSE.TXT.  By continuing to use, modify, or distribute'
nl|'\n'
comment|'#  this file you indicate that you have read the license and'
nl|'\n'
comment|'#  understand and accept it fully.'
nl|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This library file contains definitions of classes needed to decompose C'
nl|'\n'
comment|"# source code files into a series of multi-line `blocks'.  There are two"
nl|'\n'
comment|'# kinds of blocks.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#   - Normal blocks, which contain source code or ordinary comments.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#   - Documentation blocks, which have restricted formatting, and whose text'
nl|'\n'
comment|"#     always start with a documentation markup tag like `<Function>',"
nl|'\n'
comment|"#     `<Type>', etc."
nl|'\n'
comment|'#'
nl|'\n'
comment|'# The routines to process the content of documentation blocks are contained'
nl|'\n'
comment|"# in file `content.py'; the classes and methods found here only deal with"
nl|'\n'
comment|'# text parsing and basic documentation block extraction.'
nl|'\n'
comment|'#'
nl|'\n'
nl|'\n'
nl|'\n'
name|'import'
name|'fileinput'
op|','
name|'re'
op|','
name|'sys'
op|','
name|'os'
op|','
name|'string'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'################################################################'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##  SOURCE BLOCK FORMAT CLASS'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##  A simple class containing compiled regular expressions to detect'
nl|'\n'
comment|'##  potential documentation format block comments within C source code.'
nl|'\n'
comment|'##'
nl|'\n'
comment|"##  The `column' pattern must contain a group to `unbox' the content of"
nl|'\n'
comment|'##  documentation comment blocks.'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##  Later on, paragraphs are converted to long lines, which simplifies the'
nl|'\n'
comment|'##  regular expressions that act upon the text.'
nl|'\n'
comment|'##'
nl|'\n'
DECL|class|SourceBlockFormat
name|'class'
name|'SourceBlockFormat'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'id'
op|','
name|'start'
op|','
name|'column'
op|','
name|'end'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a block pattern, used to recognize special documentation\n           blocks."""'
newline|'\n'
name|'self'
op|'.'
name|'id'
op|'='
name|'id'
newline|'\n'
name|'self'
op|'.'
name|'start'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
name|'start'
op|','
name|'re'
op|'.'
name|'VERBOSE'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'column'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
name|'column'
op|','
name|'re'
op|'.'
name|'VERBOSE'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'end'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
name|'end'
op|','
name|'re'
op|'.'
name|'VERBOSE'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Format 1 documentation comment blocks.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    /************************************/ (at least 2 asterisks)'
nl|'\n'
comment|'#    /*                                  */'
nl|'\n'
comment|'#    /*                                  */'
nl|'\n'
comment|'#    /*                                  */'
nl|'\n'
comment|'#    /************************************/ (at least 2 asterisks)'
nl|'\n'
comment|'#'
nl|'\n'
dedent|''
dedent|''
name|'start'
op|'='
string|"r'''\n  \\s*      # any number of whitespace\n  /\\*{2,}/ # followed by '/' and at least two asterisks then '/'\n  \\s*$     # probably followed by whitespace\n'''"
newline|'\n'
nl|'\n'
name|'column'
op|'='
string|"r'''\n  \\s*      # any number of whitespace\n  /\\*{1}   # followed by '/' and precisely one asterisk\n  ([^*].*) # followed by anything (group 1)\n  \\*{1}/   # followed by one asterisk and a '/'\n  \\s*$     # probably followed by whitespace\n'''"
newline|'\n'
nl|'\n'
DECL|variable|re_source_block_format1
name|'re_source_block_format1'
op|'='
name|'SourceBlockFormat'
op|'('
number|'1'
op|','
name|'start'
op|','
name|'column'
op|','
name|'start'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Format 2 documentation comment blocks.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    /************************************ (at least 2 asterisks)'
nl|'\n'
comment|'#     *'
nl|'\n'
comment|'#     *                                    (1 asterisk)'
nl|'\n'
comment|'#     *'
nl|'\n'
comment|'#     */                                   (1 or more asterisks)'
nl|'\n'
comment|'#'
nl|'\n'
name|'start'
op|'='
string|"r'''\n  \\s*     # any number of whitespace\n  /\\*{2,} # followed by '/' and at least two asterisks\n  \\s*$    # probably followed by whitespace\n'''"
newline|'\n'
nl|'\n'
name|'column'
op|'='
string|"r'''\n  \\s*           # any number of whitespace\n  \\*{1}(?![*/]) # followed by precisely one asterisk not followed by `/'\n  (.*)          # then anything (group1)\n'''"
newline|'\n'
nl|'\n'
name|'end'
op|'='
string|"r'''\n  \\s*  # any number of whitespace\n  \\*+/ # followed by at least one asterisk, then '/'\n'''"
newline|'\n'
nl|'\n'
DECL|variable|re_source_block_format2
name|'re_source_block_format2'
op|'='
name|'SourceBlockFormat'
op|'('
number|'2'
op|','
name|'start'
op|','
name|'column'
op|','
name|'end'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# The list of supported documentation block formats.  We could add new ones'
nl|'\n'
comment|'# quite easily.'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_source_block_formats
name|'re_source_block_formats'
op|'='
op|'['
name|'re_source_block_format1'
op|','
name|'re_source_block_format2'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# The following regular expressions correspond to markup tags within the'
nl|'\n'
comment|'# documentation comment blocks.  They are equivalent despite their different'
nl|'\n'
comment|'# syntax.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"# A markup tag consists of letters or character `-', to be found in group 1."
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Notice that a markup tag _must_ begin a new paragraph.'
nl|'\n'
comment|'#'
nl|'\n'
name|'re_markup_tag1'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'''\\s*<((?:\\w|-)*)>'''"
op|')'
comment|'# <xxxx> format'
newline|'\n'
name|'re_markup_tag2'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'''\\s*@((?:\\w|-)*):'''"
op|')'
comment|'# @xxxx: format'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# The list of supported markup tags.  We could add new ones quite easily.'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_markup_tags
name|'re_markup_tags'
op|'='
op|'['
name|'re_markup_tag1'
op|','
name|'re_markup_tag2'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# A regular expression to detect a cross reference, after markup tags have'
nl|'\n'
comment|'# been stripped off.  Group 1 is the reference, group 2 the rest of the'
nl|'\n'
comment|'# line.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"# A cross reference consists of letters, digits, or characters `-' and `_'."
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_crossref
name|'re_crossref'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'@((?:\\w|-)*)(.*)'"
op|')'
comment|'#  @foo'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Two regular expressions to detect italic and bold markup, respectively.'
nl|'\n'
comment|'# Group 1 is the markup, group 2 the rest of the line.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Note that the markup is limited to words consisting of letters, digits,'
nl|'\n'
comment|"# the characters `_' and `-', or an apostrophe (but not as the first"
nl|'\n'
comment|'# character).'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_italic
name|'re_italic'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|'r"_((?:\\w|-)(?:\\w|\'|-)*)_(.*)"'
op|')'
comment|'#  _italic_'
newline|'\n'
DECL|variable|re_bold
name|'re_bold'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|'r"\\*((?:\\w|-)(?:\\w|\'|-)*)\\*(.*)"'
op|')'
comment|'#  *bold*'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This regular expression code to identify an URL has been taken from'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#   http://mail.python.org/pipermail/tutor/2002-September/017228.html'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# (with slight modifications).'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|urls
name|'urls'
op|'='
string|"r'(?:https?|telnet|gopher|file|wais|ftp)'"
newline|'\n'
DECL|variable|ltrs
name|'ltrs'
op|'='
string|"r'\\w'"
newline|'\n'
DECL|variable|gunk
name|'gunk'
op|'='
string|"r'/#~:.?+=&%@!\\-'"
newline|'\n'
DECL|variable|punc
name|'punc'
op|'='
string|"r'.:?\\-'"
newline|'\n'
DECL|variable|any
name|'any'
op|'='
string|'"%(ltrs)s%(gunk)s%(punc)s"'
op|'%'
op|'{'
string|"'ltrs'"
op|':'
name|'ltrs'
op|','
nl|'\n'
string|"'gunk'"
op|':'
name|'gunk'
op|','
nl|'\n'
string|"'punc'"
op|':'
name|'punc'
op|'}'
newline|'\n'
name|'url'
op|'='
string|'r"""\n         (\n           \\b                    # start at word boundary\n           %(urls)s :            # need resource and a colon\n           [%(any)s] +?          # followed by one or more of any valid\n                                 # character, but be conservative and\n                                 # take only what you need to...\n           (?=                   # [look-ahead non-consumptive assertion]\n             [%(punc)s]*         # either 0 or more punctuation\n             (?:                 # [non-grouping parentheses]\n               [^%(any)s] | $    # followed by a non-url char\n                                 # or end of the string\n             )\n           )\n         )\n        """'
op|'%'
op|'{'
string|"'urls'"
op|':'
name|'urls'
op|','
nl|'\n'
string|"'any'"
op|':'
name|'any'
op|','
nl|'\n'
string|"'punc'"
op|':'
name|'punc'
op|'}'
newline|'\n'
nl|'\n'
DECL|variable|re_url
name|'re_url'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
name|'url'
op|','
name|'re'
op|'.'
name|'VERBOSE'
op|'|'
name|'re'
op|'.'
name|'MULTILINE'
op|')'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# A regular expression that stops collection of comments for the current'
nl|'\n'
comment|'# block.'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_source_sep
name|'re_source_sep'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'\\s*/\\*\\s*\\*/'"
op|')'
comment|'#  /* */'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# A regular expression to find possible C identifiers while outputting'
nl|'\n'
comment|"# source code verbatim, covering things like `*foo' or `(bar'.  Group 1 is"
nl|'\n'
comment|'# the prefix, group 2 the identifier -- since we scan lines from left to'
nl|'\n'
comment|'# right, sequentially splitting the source code into prefix and identifier'
nl|'\n'
comment|'# is fully sufficient for our purposes.'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_source_crossref
name|'re_source_crossref'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'(\\W*)(\\w*)'"
op|')'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# A regular expression that matches a list of reserved C source keywords.'
nl|'\n'
comment|'#'
nl|'\n'
name|'re_source_keywords'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"'''\\\\b ( typedef   |\n                                          struct    |\n                                          enum      |\n                                          union     |\n                                          const     |\n                                          char      |\n                                          int       |\n                                          short     |\n                                          long      |\n                                          void      |\n                                          signed    |\n                                          unsigned  |\n                                          \\#include |\n                                          \\#define  |\n                                          \\#undef   |\n                                          \\#if      |\n                                          \\#ifdef   |\n                                          \\#ifndef  |\n                                          \\#else    |\n                                          \\#endif   ) \\\\b'''"
op|','
name|'re'
op|'.'
name|'VERBOSE'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'################################################################'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##  SOURCE BLOCK CLASS'
nl|'\n'
comment|'##'
nl|'\n'
comment|"##  There are two important fields in a `SourceBlock' object."
nl|'\n'
comment|'##'
nl|'\n'
comment|'##    self.lines'
nl|'\n'
comment|'##      A list of text lines for the corresponding block.'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##    self.content'
nl|'\n'
comment|'##      For documentation comment blocks only, this is the block content'
nl|'\n'
comment|"##      that has been `unboxed' from its decoration.  This is `None' for all"
nl|'\n'
comment|'##      other blocks (i.e., sources or ordinary comments with no starting'
nl|'\n'
comment|'##      markup tag)'
nl|'\n'
comment|'##'
nl|'\n'
DECL|class|SourceBlock
name|'class'
name|'SourceBlock'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'processor'
op|','
name|'filename'
op|','
name|'lineno'
op|','
name|'lines'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'processor'
op|'='
name|'processor'
newline|'\n'
name|'self'
op|'.'
name|'filename'
op|'='
name|'filename'
newline|'\n'
name|'self'
op|'.'
name|'lineno'
op|'='
name|'lineno'
newline|'\n'
name|'self'
op|'.'
name|'lines'
op|'='
name|'lines'
op|'['
op|':'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'format'
op|'='
name|'processor'
op|'.'
name|'format'
newline|'\n'
name|'self'
op|'.'
name|'content'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'format'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'words'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# extract comment lines'
nl|'\n'
name|'lines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'line0'
name|'in'
name|'self'
op|'.'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'m'
op|'='
name|'self'
op|'.'
name|'format'
op|'.'
name|'column'
op|'.'
name|'match'
op|'('
name|'line0'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
indent|'                '
name|'lines'
op|'.'
name|'append'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# now, look for a markup tag'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'l'
name|'in'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'l'
op|'='
name|'string'
op|'.'
name|'strip'
op|'('
name|'l'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'l'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'tag'
name|'in'
name|'re_markup_tags'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'tag'
op|'.'
name|'match'
op|'('
name|'l'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'content'
op|'='
name|'lines'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
DECL|member|location
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'location'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'"("'
op|'+'
name|'self'
op|'.'
name|'filename'
op|'+'
string|'":"'
op|'+'
name|'repr'
op|'('
name|'self'
op|'.'
name|'lineno'
op|')'
op|'+'
string|'")"'
newline|'\n'
nl|'\n'
comment|'# debugging only -- not used in normal operations'
nl|'\n'
DECL|member|dump
dedent|''
name|'def'
name|'dump'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'content'
op|':'
newline|'\n'
indent|'            '
name|'print'
string|'"{{{content start---"'
newline|'\n'
name|'for'
name|'l'
name|'in'
name|'self'
op|'.'
name|'content'
op|':'
newline|'\n'
indent|'                '
name|'print'
name|'l'
newline|'\n'
dedent|''
name|'print'
string|'"---content end}}}"'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'fmt'
op|'='
string|'""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'format'
op|':'
newline|'\n'
indent|'            '
name|'fmt'
op|'='
name|'repr'
op|'('
name|'self'
op|'.'
name|'format'
op|'.'
name|'id'
op|')'
op|'+'
string|'" "'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'line'
name|'in'
name|'self'
op|'.'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'print'
name|'line'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'################################################################'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##  SOURCE PROCESSOR CLASS'
nl|'\n'
comment|'##'
nl|'\n'
comment|"##  The `SourceProcessor' is in charge of reading a C source file and"
nl|'\n'
comment|"##  decomposing it into a series of different `SourceBlock' objects."
nl|'\n'
comment|'##'
nl|'\n'
comment|'##  A SourceBlock object consists of the following data.'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##    - A documentation comment block using one of the layouts above.  Its'
nl|'\n'
comment|'##      exact format will be discussed later.'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##    - Normal sources lines, including comments.'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##'
nl|'\n'
DECL|class|SourceProcessor
dedent|''
dedent|''
dedent|''
name|'class'
name|'SourceProcessor'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize a source processor."""'
newline|'\n'
name|'self'
op|'.'
name|'blocks'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'filename'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'format'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'lines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|reset
dedent|''
name|'def'
name|'reset'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reset a block processor and clean up all its blocks."""'
newline|'\n'
name|'self'
op|'.'
name|'blocks'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'format'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|parse_file
dedent|''
name|'def'
name|'parse_file'
op|'('
name|'self'
op|','
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Parse a C source file and add its blocks to the processor\'s\n           list."""'
newline|'\n'
name|'self'
op|'.'
name|'reset'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'filename'
op|'='
name|'filename'
newline|'\n'
nl|'\n'
name|'fileinput'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'format'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'lineno'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'lines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'line'
name|'in'
name|'fileinput'
op|'.'
name|'input'
op|'('
name|'filename'
op|')'
op|':'
newline|'\n'
comment|'# strip trailing newlines, important on Windows machines!'
nl|'\n'
indent|'            '
name|'if'
name|'line'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
string|"'\\012'"
op|':'
newline|'\n'
indent|'                '
name|'line'
op|'='
name|'line'
op|'['
number|'0'
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'format'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'process_normal_line'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'format'
op|'.'
name|'end'
op|'.'
name|'match'
op|'('
name|'line'
op|')'
op|':'
newline|'\n'
comment|"# A normal block end.  Add it to `lines' and create a"
nl|'\n'
comment|'# new block'
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'lines'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'add_block_lines'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'format'
op|'.'
name|'column'
op|'.'
name|'match'
op|'('
name|'line'
op|')'
op|':'
newline|'\n'
comment|"# A normal column line.  Add it to `lines'."
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'lines'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# An unexpected block end.  Create a new block, but'
nl|'\n'
comment|"# don't process the line."
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'add_block_lines'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# we need to process the line again'
nl|'\n'
name|'self'
op|'.'
name|'process_normal_line'
op|'('
name|'line'
op|')'
newline|'\n'
nl|'\n'
comment|'# record the last lines'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'self'
op|'.'
name|'add_block_lines'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|process_normal_line
dedent|''
name|'def'
name|'process_normal_line'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Process a normal line and check whether it is the start of a new\n           block."""'
newline|'\n'
name|'for'
name|'f'
name|'in'
name|'re_source_block_formats'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'f'
op|'.'
name|'start'
op|'.'
name|'match'
op|'('
name|'line'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'add_block_lines'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'format'
op|'='
name|'f'
newline|'\n'
name|'self'
op|'.'
name|'lineno'
op|'='
name|'fileinput'
op|'.'
name|'filelineno'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'lines'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
nl|'\n'
DECL|member|add_block_lines
dedent|''
name|'def'
name|'add_block_lines'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Add the current accumulated lines and create a new block."""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'lines'
op|'!='
op|'['
op|']'
op|':'
newline|'\n'
indent|'            '
name|'block'
op|'='
name|'SourceBlock'
op|'('
name|'self'
op|','
nl|'\n'
name|'self'
op|'.'
name|'filename'
op|','
nl|'\n'
name|'self'
op|'.'
name|'lineno'
op|','
nl|'\n'
name|'self'
op|'.'
name|'lines'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'blocks'
op|'.'
name|'append'
op|'('
name|'block'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'format'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'lines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# debugging only, not used in normal operations'
nl|'\n'
DECL|member|dump
dedent|''
dedent|''
name|'def'
name|'dump'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Print all blocks in a processor."""'
newline|'\n'
name|'for'
name|'b'
name|'in'
name|'self'
op|'.'
name|'blocks'
op|':'
newline|'\n'
indent|'            '
name|'b'
op|'.'
name|'dump'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# eof'
nl|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
