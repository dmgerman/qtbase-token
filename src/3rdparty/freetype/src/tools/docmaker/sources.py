begin_unit
comment|'#  Sources (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009'
nl|'\n'
comment|'#    David Turner <david@freetype.org>'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# this file contains definitions of classes needed to decompose'
nl|'\n'
comment|'# C sources files into a series of multi-line "blocks". There are'
nl|'\n'
comment|'# two kinds of blocks:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#   - normal blocks, which contain source code or ordinary comments'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#   - documentation blocks, which have restricted formatting, and'
nl|'\n'
comment|'#     whose text always start with a documentation markup tag like'
nl|'\n'
comment|'#     "<Function>", "<Type>", etc..'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# the routines used to process the content of documentation blocks'
nl|'\n'
comment|'# are not contained here, but in "content.py"'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# the classes and methods found here only deal with text parsing'
nl|'\n'
comment|'# and basic documentation block extraction'
nl|'\n'
comment|'#'
nl|'\n'
nl|'\n'
name|'import'
name|'fileinput'
op|','
name|'re'
op|','
name|'sys'
op|','
name|'os'
op|','
name|'string'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'################################################################'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##  BLOCK FORMAT PATTERN'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##   A simple class containing compiled regular expressions used'
nl|'\n'
comment|'##   to detect potential documentation format block comments within'
nl|'\n'
comment|'##   C source code'
nl|'\n'
comment|'##'
nl|'\n'
comment|"##   note that the 'column' pattern must contain a group that will"
nl|'\n'
comment|'##   be used to "unbox" the content of documentation comment blocks'
nl|'\n'
comment|'##'
nl|'\n'
DECL|class|SourceBlockFormat
name|'class'
name|'SourceBlockFormat'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'id'
op|','
name|'start'
op|','
name|'column'
op|','
name|'end'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""create a block pattern, used to recognize special documentation blocks"""'
newline|'\n'
name|'self'
op|'.'
name|'id'
op|'='
name|'id'
newline|'\n'
name|'self'
op|'.'
name|'start'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
name|'start'
op|','
name|'re'
op|'.'
name|'VERBOSE'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'column'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
name|'column'
op|','
name|'re'
op|'.'
name|'VERBOSE'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'end'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
name|'end'
op|','
name|'re'
op|'.'
name|'VERBOSE'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# format 1 documentation comment blocks look like the following:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    /************************************/'
nl|'\n'
comment|'#    /*                                  */'
nl|'\n'
comment|'#    /*                                  */'
nl|'\n'
comment|'#    /*                                  */'
nl|'\n'
comment|'#    /************************************/'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# we define a few regular expressions here to detect them'
nl|'\n'
comment|'#'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'start'
op|'='
string|"r'''\n  \\s*      # any number of whitespace\n  /\\*{2,}/ # followed by '/' and at least two asterisks then '/'\n  \\s*$     # probably followed by whitespace\n'''"
newline|'\n'
nl|'\n'
name|'column'
op|'='
string|"r'''\n  \\s*      # any number of whitespace\n  /\\*{1}   # followed by '/' and precisely one asterisk\n  ([^*].*) # followed by anything (group 1)\n  \\*{1}/   # followed by one asterisk and a '/'\n  \\s*$     # probably followed by whitespace\n'''"
newline|'\n'
nl|'\n'
DECL|variable|re_source_block_format1
name|'re_source_block_format1'
op|'='
name|'SourceBlockFormat'
op|'('
number|'1'
op|','
name|'start'
op|','
name|'column'
op|','
name|'start'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# format 2 documentation comment blocks look like the following:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    /************************************ (at least 2 asterisks)'
nl|'\n'
comment|'#     *'
nl|'\n'
comment|'#     *'
nl|'\n'
comment|'#     *'
nl|'\n'
comment|'#     *'
nl|'\n'
comment|'#     **/       (1 or more asterisks at the end)'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# we define a few regular expressions here to detect them'
nl|'\n'
comment|'#'
nl|'\n'
name|'start'
op|'='
string|"r'''\n  \\s*     # any number of whitespace\n  /\\*{2,} # followed by '/' and at least two asterisks\n  \\s*$    # probably followed by whitespace\n'''"
newline|'\n'
nl|'\n'
name|'column'
op|'='
string|"r'''\n  \\s*        # any number of whitespace\n  \\*{1}(?!/) # followed by precisely one asterisk not followed by `/'\n  (.*)       # then anything (group1)\n'''"
newline|'\n'
nl|'\n'
name|'end'
op|'='
string|"r'''\n  \\s*  # any number of whitespace\n  \\*+/ # followed by at least one asterisk, then '/'\n'''"
newline|'\n'
nl|'\n'
DECL|variable|re_source_block_format2
name|'re_source_block_format2'
op|'='
name|'SourceBlockFormat'
op|'('
number|'2'
op|','
name|'start'
op|','
name|'column'
op|','
name|'end'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# the list of supported documentation block formats, we could add new ones'
nl|'\n'
comment|'# relatively easily'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_source_block_formats
name|'re_source_block_formats'
op|'='
op|'['
name|'re_source_block_format1'
op|','
name|'re_source_block_format2'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# the following regular expressions corresponds to markup tags'
nl|'\n'
comment|"# within the documentation comment blocks. they're equivalent"
nl|'\n'
comment|'# despite their different syntax'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# notice how each markup tag _must_ begin a new line'
nl|'\n'
comment|'#'
nl|'\n'
name|'re_markup_tag1'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'''\\s*<(\\w*)>'''"
op|')'
comment|'# <xxxx> format'
newline|'\n'
name|'re_markup_tag2'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'''\\s*@(\\w*):'''"
op|')'
comment|'# @xxxx: format'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# the list of supported markup tags, we could add new ones relatively'
nl|'\n'
comment|'# easily'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_markup_tags
name|'re_markup_tags'
op|'='
op|'['
name|'re_markup_tag1'
op|','
name|'re_markup_tag2'
op|']'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# used to detect a cross-reference, after markup tags have been stripped'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_crossref
name|'re_crossref'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'@(\\w*)(.*)'"
op|')'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# used to detect italic and bold styles in paragraph text'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_italic
name|'re_italic'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|'r"_(\\w(\\w|\')*)_(.*)"'
op|')'
comment|'#  _italic_'
newline|'\n'
DECL|variable|re_bold
name|'re_bold'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|'r"\\*(\\w(\\w|\')*)\\*(.*)"'
op|')'
comment|'#  *bold*'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# used to detect the end of commented source lines'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_source_sep
name|'re_source_sep'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'\\s*/\\*\\s*\\*/'"
op|')'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# used to perform cross-reference within source output'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|re_source_crossref
name|'re_source_crossref'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'(\\W*)(\\w*)'"
op|')'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# a list of reserved source keywords'
nl|'\n'
comment|'#'
nl|'\n'
name|'re_source_keywords'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"'''\\\\b ( typedef   |\n                                          struct    |\n                                          enum      |\n                                          union     |\n                                          const     |\n                                          char      |\n                                          int       |\n                                          short     |\n                                          long      |\n                                          void      |\n                                          signed    |\n                                          unsigned  |\n                                          \\#include |\n                                          \\#define  |\n                                          \\#undef   |\n                                          \\#if      |\n                                          \\#ifdef   |\n                                          \\#ifndef  |\n                                          \\#else    |\n                                          \\#endif   ) \\\\b'''"
op|','
name|'re'
op|'.'
name|'VERBOSE'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'################################################################'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##  SOURCE BLOCK CLASS'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##   A SourceProcessor is in charge of reading a C source file'
nl|'\n'
comment|'##   and decomposing it into a series of different "SourceBlocks".'
nl|'\n'
comment|'##   each one of these blocks can be made of the following data:'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##   - A documentation comment block that starts with "/**" and'
nl|'\n'
comment|'##     whose exact format will be discussed later'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##   - normal sources lines, including comments'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##   the important fields in a text block are the following ones:'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##     self.lines   : a list of text lines for the corresponding block'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##     self.content : for documentation comment blocks only, this is the'
nl|'\n'
comment|'##                    block content that has been "unboxed" from its'
nl|'\n'
comment|'##                    decoration. This is None for all other blocks'
nl|'\n'
comment|'##                    (i.e. sources or ordinary comments with no starting'
nl|'\n'
comment|'##                     markup tag)'
nl|'\n'
comment|'##'
nl|'\n'
DECL|class|SourceBlock
name|'class'
name|'SourceBlock'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'processor'
op|','
name|'filename'
op|','
name|'lineno'
op|','
name|'lines'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'processor'
op|'='
name|'processor'
newline|'\n'
name|'self'
op|'.'
name|'filename'
op|'='
name|'filename'
newline|'\n'
name|'self'
op|'.'
name|'lineno'
op|'='
name|'lineno'
newline|'\n'
name|'self'
op|'.'
name|'lines'
op|'='
name|'lines'
op|'['
op|':'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'format'
op|'='
name|'processor'
op|'.'
name|'format'
newline|'\n'
name|'self'
op|'.'
name|'content'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'format'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'words'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# extract comment lines'
nl|'\n'
name|'lines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'line0'
name|'in'
name|'self'
op|'.'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'m'
op|'='
name|'self'
op|'.'
name|'format'
op|'.'
name|'column'
op|'.'
name|'match'
op|'('
name|'line0'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
indent|'                '
name|'lines'
op|'.'
name|'append'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# now, look for a markup tag'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'l'
name|'in'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'l'
op|'='
name|'string'
op|'.'
name|'strip'
op|'('
name|'l'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'l'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'tag'
name|'in'
name|'re_markup_tags'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'tag'
op|'.'
name|'match'
op|'('
name|'l'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'content'
op|'='
name|'lines'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
DECL|member|location
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'location'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'"("'
op|'+'
name|'self'
op|'.'
name|'filename'
op|'+'
string|'":"'
op|'+'
name|'repr'
op|'('
name|'self'
op|'.'
name|'lineno'
op|')'
op|'+'
string|'")"'
newline|'\n'
nl|'\n'
comment|'# debugging only - not used in normal operations'
nl|'\n'
DECL|member|dump
dedent|''
name|'def'
name|'dump'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'content'
op|':'
newline|'\n'
indent|'            '
name|'print'
string|'"{{{content start---"'
newline|'\n'
name|'for'
name|'l'
name|'in'
name|'self'
op|'.'
name|'content'
op|':'
newline|'\n'
indent|'                '
name|'print'
name|'l'
newline|'\n'
dedent|''
name|'print'
string|'"---content end}}}"'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'fmt'
op|'='
string|'""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'format'
op|':'
newline|'\n'
indent|'            '
name|'fmt'
op|'='
name|'repr'
op|'('
name|'self'
op|'.'
name|'format'
op|'.'
name|'id'
op|')'
op|'+'
string|'" "'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'line'
name|'in'
name|'self'
op|'.'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'print'
name|'line'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'################################################################'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##  SOURCE PROCESSOR CLASS'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##   The SourceProcessor is in charge of reading a C source file'
nl|'\n'
comment|'##   and decomposing it into a series of different "SourceBlock"'
nl|'\n'
comment|'##   objects.'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##   each one of these blocks can be made of the following data:'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##   - A documentation comment block that starts with "/**" and'
nl|'\n'
comment|'##     whose exact format will be discussed later'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##   - normal sources lines, include comments'
nl|'\n'
comment|'##'
nl|'\n'
comment|'##'
nl|'\n'
DECL|class|SourceProcessor
dedent|''
dedent|''
dedent|''
name|'class'
name|'SourceProcessor'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""initialize a source processor"""'
newline|'\n'
name|'self'
op|'.'
name|'blocks'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'filename'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'format'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'lines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|reset
dedent|''
name|'def'
name|'reset'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""reset a block processor, clean all its blocks"""'
newline|'\n'
name|'self'
op|'.'
name|'blocks'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'format'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|parse_file
dedent|''
name|'def'
name|'parse_file'
op|'('
name|'self'
op|','
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""parse a C source file, and add its blocks to the processor\'s list"""'
newline|'\n'
name|'self'
op|'.'
name|'reset'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'filename'
op|'='
name|'filename'
newline|'\n'
nl|'\n'
name|'fileinput'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'format'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'lineno'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'lines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'line'
name|'in'
name|'fileinput'
op|'.'
name|'input'
op|'('
name|'filename'
op|')'
op|':'
newline|'\n'
comment|'# strip trailing newlines, important on Windows machines!'
nl|'\n'
indent|'            '
name|'if'
name|'line'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
string|"'\\012'"
op|':'
newline|'\n'
indent|'                '
name|'line'
op|'='
name|'line'
op|'['
number|'0'
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'format'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'process_normal_line'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'format'
op|'.'
name|'end'
op|'.'
name|'match'
op|'('
name|'line'
op|')'
op|':'
newline|'\n'
comment|"# that's a normal block end, add it to 'lines' and"
nl|'\n'
comment|'# create a new block'
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'lines'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'add_block_lines'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'format'
op|'.'
name|'column'
op|'.'
name|'match'
op|'('
name|'line'
op|')'
op|':'
newline|'\n'
comment|"# that's a normal column line, add it to 'lines'"
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'lines'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# humm.. this is an unexpected block end,'
nl|'\n'
comment|"# create a new block, but don't process the line"
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'add_block_lines'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# we need to process the line again'
nl|'\n'
name|'self'
op|'.'
name|'process_normal_line'
op|'('
name|'line'
op|')'
newline|'\n'
nl|'\n'
comment|'# record the last lines'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'self'
op|'.'
name|'add_block_lines'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|process_normal_line
dedent|''
name|'def'
name|'process_normal_line'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""process a normal line and check whether it is the start of a new block"""'
newline|'\n'
name|'for'
name|'f'
name|'in'
name|'re_source_block_formats'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'f'
op|'.'
name|'start'
op|'.'
name|'match'
op|'('
name|'line'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'add_block_lines'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'format'
op|'='
name|'f'
newline|'\n'
name|'self'
op|'.'
name|'lineno'
op|'='
name|'fileinput'
op|'.'
name|'filelineno'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'lines'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
nl|'\n'
DECL|member|add_block_lines
dedent|''
name|'def'
name|'add_block_lines'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""add the current accumulated lines and create a new block"""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'lines'
op|'!='
op|'['
op|']'
op|':'
newline|'\n'
indent|'            '
name|'block'
op|'='
name|'SourceBlock'
op|'('
name|'self'
op|','
name|'self'
op|'.'
name|'filename'
op|','
name|'self'
op|'.'
name|'lineno'
op|','
name|'self'
op|'.'
name|'lines'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'blocks'
op|'.'
name|'append'
op|'('
name|'block'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'format'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'lines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# debugging only, not used in normal operations'
nl|'\n'
DECL|member|dump
dedent|''
dedent|''
name|'def'
name|'dump'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""print all blocks in a processor"""'
newline|'\n'
name|'for'
name|'b'
name|'in'
name|'self'
op|'.'
name|'blocks'
op|':'
newline|'\n'
indent|'            '
name|'b'
op|'.'
name|'dump'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# eof'
nl|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
