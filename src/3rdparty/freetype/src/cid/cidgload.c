begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  cidgload.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    CID-keyed Type1 Glyph Loader (body).                                 */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010 by */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
file|"cidload.h"
end_include
begin_include
include|#
directive|include
file|"cidgload.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_OUTLINE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
file|"ciderrs.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_cidgload
end_define
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cid_load_glyph
argument_list|(
argument|T1_Decoder  decoder
argument_list|,
argument|FT_UInt     glyph_index
argument_list|)
end_macro
begin_block
block|{
name|CID_Face
name|face
init|=
operator|(
name|CID_Face
operator|)
name|decoder
operator|->
name|builder
operator|.
name|face
decl_stmt|;
name|CID_FaceInfo
name|cid
init|=
operator|&
name|face
operator|->
name|cid
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_UInt
name|fd_select
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|cid_stream
decl_stmt|;
name|FT_Error
name|error
init|=
name|CID_Err_Ok
decl_stmt|;
name|FT_Byte
modifier|*
name|charstring
init|=
literal|0
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_ULong
name|glyph_length
init|=
literal|0
decl_stmt|;
name|PSAux_Service
name|psaux
init|=
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
name|FT_Incremental_InterfaceRec
modifier|*
name|inc
init|=
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
decl_stmt|;
endif|#
directive|endif
name|FT_TRACE4
argument_list|(
operator|(
literal|"cid_load_glyph: glyph index %d\n"
operator|,
name|glyph_index
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* For incremental fonts get the character data using */
comment|/* the callback function.                             */
if|if
condition|(
name|inc
condition|)
block|{
name|FT_Data
name|glyph_data
decl_stmt|;
name|error
operator|=
name|inc
operator|->
name|funcs
operator|->
name|get_glyph_data
argument_list|(
name|inc
operator|->
name|object
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|glyph_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|glyph_data
operator|.
name|pointer
expr_stmt|;
name|fd_select
operator|=
operator|(
name|FT_UInt
operator|)
name|cid_get_offset
argument_list|(
operator|&
name|p
argument_list|,
operator|(
name|FT_Byte
operator|)
name|cid
operator|->
name|fd_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyph_data
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|glyph_length
operator|=
name|glyph_data
operator|.
name|length
operator|-
name|cid
operator|->
name|fd_bytes
expr_stmt|;
operator|(
name|void
operator|)
name|FT_ALLOC
argument_list|(
name|charstring
argument_list|,
name|glyph_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|ft_memcpy
argument_list|(
name|charstring
argument_list|,
name|glyph_data
operator|.
name|pointer
operator|+
name|cid
operator|->
name|fd_bytes
argument_list|,
name|glyph_length
argument_list|)
expr_stmt|;
block|}
name|inc
operator|->
name|funcs
operator|->
name|free_glyph_data
argument_list|(
name|inc
operator|->
name|object
argument_list|,
operator|&
name|glyph_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
comment|/* For ordinary fonts read the CID font dictionary index */
comment|/* and charstring offset from the CIDMap.                */
block|{
name|FT_UInt
name|entry_len
init|=
name|cid
operator|->
name|fd_bytes
operator|+
name|cid
operator|->
name|gd_bytes
decl_stmt|;
name|FT_ULong
name|off1
decl_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|cid
operator|->
name|data_offset
operator|+
name|cid
operator|->
name|cidmap_offset
operator|+
name|glyph_index
operator|*
name|entry_len
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
literal|2
operator|*
name|entry_len
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|stream
operator|->
name|cursor
expr_stmt|;
name|fd_select
operator|=
operator|(
name|FT_UInt
operator|)
name|cid_get_offset
argument_list|(
operator|&
name|p
argument_list|,
operator|(
name|FT_Byte
operator|)
name|cid
operator|->
name|fd_bytes
argument_list|)
expr_stmt|;
name|off1
operator|=
operator|(
name|FT_ULong
operator|)
name|cid_get_offset
argument_list|(
operator|&
name|p
argument_list|,
operator|(
name|FT_Byte
operator|)
name|cid
operator|->
name|gd_bytes
argument_list|)
expr_stmt|;
name|p
operator|+=
name|cid
operator|->
name|fd_bytes
expr_stmt|;
name|glyph_length
operator|=
name|cid_get_offset
argument_list|(
operator|&
name|p
argument_list|,
operator|(
name|FT_Byte
operator|)
name|cid
operator|->
name|gd_bytes
argument_list|)
operator|-
name|off1
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|fd_select
operator|>=
operator|(
name|FT_UInt
operator|)
name|cid
operator|->
name|num_dicts
condition|)
block|{
name|error
operator|=
name|CID_Err_Invalid_Offset
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|glyph_length
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|charstring
argument_list|,
name|glyph_length
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_STREAM_READ_AT
argument_list|(
name|cid
operator|->
name|data_offset
operator|+
name|off1
argument_list|,
name|charstring
argument_list|,
name|glyph_length
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* Now set up the subrs array and parse the charstrings. */
block|{
name|CID_FaceDict
name|dict
decl_stmt|;
name|CID_Subrs
name|cid_subrs
init|=
name|face
operator|->
name|subrs
operator|+
name|fd_select
decl_stmt|;
name|FT_Int
name|cs_offset
decl_stmt|;
comment|/* Set up subrs */
name|decoder
operator|->
name|num_subrs
operator|=
name|cid_subrs
operator|->
name|num_subrs
expr_stmt|;
name|decoder
operator|->
name|subrs
operator|=
name|cid_subrs
operator|->
name|code
expr_stmt|;
name|decoder
operator|->
name|subrs_len
operator|=
literal|0
expr_stmt|;
comment|/* Set up font matrix */
name|dict
operator|=
name|cid
operator|->
name|font_dicts
operator|+
name|fd_select
expr_stmt|;
name|decoder
operator|->
name|font_matrix
operator|=
name|dict
operator|->
name|font_matrix
expr_stmt|;
name|decoder
operator|->
name|font_offset
operator|=
name|dict
operator|->
name|font_offset
expr_stmt|;
name|decoder
operator|->
name|lenIV
operator|=
name|dict
operator|->
name|private_dict
operator|.
name|lenIV
expr_stmt|;
comment|/* Decode the charstring. */
comment|/* Adjustment for seed bytes. */
name|cs_offset
operator|=
operator|(
name|decoder
operator|->
name|lenIV
operator|>=
literal|0
condition|?
name|decoder
operator|->
name|lenIV
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Decrypt only if lenIV>= 0. */
if|if
condition|(
name|decoder
operator|->
name|lenIV
operator|>=
literal|0
condition|)
name|psaux
operator|->
name|t1_decrypt
argument_list|(
name|charstring
argument_list|,
name|glyph_length
argument_list|,
literal|4330
argument_list|)
expr_stmt|;
name|error
operator|=
name|decoder
operator|->
name|funcs
operator|.
name|parse_charstrings
argument_list|(
name|decoder
argument_list|,
name|charstring
operator|+
name|cs_offset
argument_list|,
operator|(
name|FT_Int
operator|)
name|glyph_length
operator|-
name|cs_offset
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|charstring
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* Incremental fonts can optionally override the metrics. */
if|if
condition|(
operator|!
name|error
operator|&&
name|inc
operator|&&
name|inc
operator|->
name|funcs
operator|->
name|get_glyph_metrics
condition|)
block|{
name|FT_Incremental_MetricsRec
name|metrics
decl_stmt|;
name|metrics
operator|.
name|bearing_x
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|.
name|x
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|bearing_y
operator|=
literal|0
expr_stmt|;
name|metrics
operator|.
name|advance
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|->
name|builder
operator|.
name|advance
operator|.
name|x
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|advance_v
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|->
name|builder
operator|.
name|advance
operator|.
name|y
argument_list|)
expr_stmt|;
name|error
operator|=
name|inc
operator|->
name|funcs
operator|->
name|get_glyph_metrics
argument_list|(
name|inc
operator|->
name|object
argument_list|,
name|glyph_index
argument_list|,
name|FALSE
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|.
name|x
operator|=
name|INT_TO_FIXED
argument_list|(
name|metrics
operator|.
name|bearing_x
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|advance
operator|.
name|x
operator|=
name|INT_TO_FIXED
argument_list|(
name|metrics
operator|.
name|advance
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|advance
operator|.
name|y
operator|=
name|INT_TO_FIXED
argument_list|(
name|metrics
operator|.
name|advance_v
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/**********            COMPUTE THE MAXIMUM ADVANCE WIDTH         *********/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/**********    The following code is in charge of computing      *********/
end_comment
begin_comment
comment|/**********    the maximum advance width of the font.  It        *********/
end_comment
begin_comment
comment|/**********    quickly processes each glyph charstring to        *********/
end_comment
begin_comment
comment|/**********    extract the value from either a `sbw' or `seac'   *********/
end_comment
begin_comment
comment|/**********    operator.                                         *********/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
unit|FT_LOCAL_DEF( FT_Error )   cid_face_compute_max_advance( CID_Face  face,                                 FT_Int*   max_advance )   {     FT_Error       error;     T1_DecoderRec  decoder;     FT_Int         glyph_index;      PSAux_Service  psaux = (PSAux_Service)face->psaux;       *max_advance = 0;
comment|/* Initialize load decoder */
end_comment
begin_comment
unit|error = psaux->t1_decoder_funcs->init(&decoder,                                            (FT_Face)face,                                            0,
comment|/* size       */
end_comment
begin_comment
unit|0,
comment|/* glyph slot */
end_comment
begin_comment
unit|0,
comment|/* glyph names! XXX */
end_comment
begin_comment
unit|0,
comment|/* blend == 0 */
end_comment
begin_comment
unit|0,
comment|/* hinting == 0 */
end_comment
begin_comment
unit|cid_load_glyph );     if ( error )       return error;
comment|/* TODO: initialize decoder.len_buildchar and decoder.buildchar */
end_comment
begin_comment
comment|/*       if we ever support CID-keyed multiple master fonts     */
end_comment
begin_comment
unit|decoder.builder.metrics_only = 1;     decoder.builder.load_points  = 0;
comment|/* for each glyph, parse the glyph charstring and extract */
end_comment
begin_comment
comment|/* the advance width                                      */
end_comment
begin_comment
unit|for ( glyph_index = 0; glyph_index< face->root.num_glyphs;           glyph_index++ )     {
comment|/* now get load the unscaled outline */
end_comment
begin_comment
unit|error = cid_load_glyph(&decoder, glyph_index );
comment|/* ignore the error if one occurred - skip to next glyph */
end_comment
begin_endif
unit|}      *max_advance = FIXED_TO_INT( decoder.builder.advance.x );      psaux->t1_decoder_funcs->done(&decoder );      return CID_Err_Ok;   }
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cid_slot_load_glyph
argument_list|(
argument|FT_GlyphSlot  cidglyph
argument_list|,
comment|/* CID_GlyphSlot */
argument|FT_Size       cidsize
argument_list|,
comment|/* CID_Size      */
argument|FT_UInt       glyph_index
argument_list|,
argument|FT_Int32      load_flags
argument_list|)
end_macro
begin_block
block|{
name|CID_GlyphSlot
name|glyph
init|=
operator|(
name|CID_GlyphSlot
operator|)
name|cidglyph
decl_stmt|;
name|CID_Size
name|size
init|=
operator|(
name|CID_Size
operator|)
name|cidsize
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|T1_DecoderRec
name|decoder
decl_stmt|;
name|CID_Face
name|face
init|=
operator|(
name|CID_Face
operator|)
name|cidglyph
operator|->
name|face
decl_stmt|;
name|FT_Bool
name|hinting
decl_stmt|;
name|PSAux_Service
name|psaux
init|=
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
decl_stmt|;
name|FT_Matrix
name|font_matrix
decl_stmt|;
name|FT_Vector
name|font_offset
decl_stmt|;
if|if
condition|(
name|glyph_index
operator|>=
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|root
operator|.
name|num_glyphs
condition|)
block|{
name|error
operator|=
name|CID_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_NO_RECURSE
condition|)
name|load_flags
operator||=
name|FT_LOAD_NO_SCALE
operator||
name|FT_LOAD_NO_HINTING
expr_stmt|;
name|glyph
operator|->
name|x_scale
operator|=
name|cidsize
operator|->
name|metrics
operator|.
name|x_scale
expr_stmt|;
name|glyph
operator|->
name|y_scale
operator|=
name|cidsize
operator|->
name|metrics
operator|.
name|y_scale
expr_stmt|;
name|cidglyph
operator|->
name|outline
operator|.
name|n_points
operator|=
literal|0
expr_stmt|;
name|cidglyph
operator|->
name|outline
operator|.
name|n_contours
operator|=
literal|0
expr_stmt|;
name|hinting
operator|=
name|FT_BOOL
argument_list|(
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_HINTING
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|cidglyph
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_OUTLINE
expr_stmt|;
name|error
operator|=
name|psaux
operator|->
name|t1_decoder_funcs
operator|->
name|init
argument_list|(
operator|&
name|decoder
argument_list|,
name|cidglyph
operator|->
name|face
argument_list|,
name|cidsize
argument_list|,
name|cidglyph
argument_list|,
literal|0
argument_list|,
comment|/* glyph names -- XXX */
literal|0
argument_list|,
comment|/* blend == 0 */
name|hinting
argument_list|,
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
argument_list|,
name|cid_load_glyph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* TODO: initialize decoder.len_buildchar and decoder.buildchar */
comment|/*       if we ever support CID-keyed multiple master fonts     */
comment|/* set up the decoder */
name|decoder
operator|.
name|builder
operator|.
name|no_recurse
operator|=
name|FT_BOOL
argument_list|(
operator|(
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_RECURSE
operator|)
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cid_load_glyph
argument_list|(
operator|&
name|decoder
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|font_matrix
operator|=
name|decoder
operator|.
name|font_matrix
expr_stmt|;
name|font_offset
operator|=
name|decoder
operator|.
name|font_offset
expr_stmt|;
comment|/* save new glyph tables */
name|psaux
operator|->
name|t1_decoder_funcs
operator|->
name|done
argument_list|(
operator|&
name|decoder
argument_list|)
expr_stmt|;
comment|/* now set the metrics -- this is rather simple, as    */
comment|/* the left side bearing is the xMin, and the top side */
comment|/* bearing the yMax                                    */
name|cidglyph
operator|->
name|outline
operator|.
name|flags
operator|&=
name|FT_OUTLINE_OWNER
expr_stmt|;
name|cidglyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_REVERSE_FILL
expr_stmt|;
comment|/* for composite glyphs, return only left side bearing and */
comment|/* advance width                                           */
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_NO_RECURSE
condition|)
block|{
name|FT_Slot_Internal
name|internal
init|=
name|cidglyph
operator|->
name|internal
decl_stmt|;
name|cidglyph
operator|->
name|metrics
operator|.
name|horiBearingX
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|.
name|builder
operator|.
name|left_bearing
operator|.
name|x
argument_list|)
expr_stmt|;
name|cidglyph
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|x
argument_list|)
expr_stmt|;
name|internal
operator|->
name|glyph_matrix
operator|=
name|font_matrix
expr_stmt|;
name|internal
operator|->
name|glyph_delta
operator|=
name|font_offset
expr_stmt|;
name|internal
operator|->
name|glyph_transformed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|FT_BBox
name|cbox
decl_stmt|;
name|FT_Glyph_Metrics
modifier|*
name|metrics
init|=
operator|&
name|cidglyph
operator|->
name|metrics
decl_stmt|;
name|FT_Vector
name|advance
decl_stmt|;
comment|/* copy the _unscaled_ advance width */
name|metrics
operator|->
name|horiAdvance
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|x
argument_list|)
expr_stmt|;
name|cidglyph
operator|->
name|linearHoriAdvance
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|x
argument_list|)
expr_stmt|;
name|cidglyph
operator|->
name|internal
operator|->
name|glyph_transformed
operator|=
literal|0
expr_stmt|;
comment|/* make up vertical ones */
name|metrics
operator|->
name|vertAdvance
operator|=
operator|(
name|face
operator|->
name|cid
operator|.
name|font_bbox
operator|.
name|yMax
operator|-
name|face
operator|->
name|cid
operator|.
name|font_bbox
operator|.
name|yMin
operator|)
operator|>>
literal|16
expr_stmt|;
name|cidglyph
operator|->
name|linearVertAdvance
operator|=
name|metrics
operator|->
name|vertAdvance
expr_stmt|;
name|cidglyph
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_OUTLINE
expr_stmt|;
if|if
condition|(
name|size
operator|&&
name|cidsize
operator|->
name|metrics
operator|.
name|y_ppem
operator|<
literal|24
condition|)
name|cidglyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_HIGH_PRECISION
expr_stmt|;
comment|/* apply the font matrix */
name|FT_Outline_Transform
argument_list|(
operator|&
name|cidglyph
operator|->
name|outline
argument_list|,
operator|&
name|font_matrix
argument_list|)
expr_stmt|;
name|FT_Outline_Translate
argument_list|(
operator|&
name|cidglyph
operator|->
name|outline
argument_list|,
name|font_offset
operator|.
name|x
argument_list|,
name|font_offset
operator|.
name|y
argument_list|)
expr_stmt|;
name|advance
operator|.
name|x
operator|=
name|metrics
operator|->
name|horiAdvance
expr_stmt|;
name|advance
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|FT_Vector_Transform
argument_list|(
operator|&
name|advance
argument_list|,
operator|&
name|font_matrix
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|horiAdvance
operator|=
name|advance
operator|.
name|x
operator|+
name|font_offset
operator|.
name|x
expr_stmt|;
name|advance
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|advance
operator|.
name|y
operator|=
name|metrics
operator|->
name|vertAdvance
expr_stmt|;
name|FT_Vector_Transform
argument_list|(
operator|&
name|advance
argument_list|,
operator|&
name|font_matrix
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
name|advance
operator|.
name|y
operator|+
name|font_offset
operator|.
name|y
expr_stmt|;
if|if
condition|(
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* scale the outline and the metrics */
name|FT_Int
name|n
decl_stmt|;
name|FT_Outline
modifier|*
name|cur
init|=
name|decoder
operator|.
name|builder
operator|.
name|base
decl_stmt|;
name|FT_Vector
modifier|*
name|vec
init|=
name|cur
operator|->
name|points
decl_stmt|;
name|FT_Fixed
name|x_scale
init|=
name|glyph
operator|->
name|x_scale
decl_stmt|;
name|FT_Fixed
name|y_scale
init|=
name|glyph
operator|->
name|y_scale
decl_stmt|;
comment|/* First of all, scale the points */
if|if
condition|(
operator|!
name|hinting
operator|||
operator|!
name|decoder
operator|.
name|builder
operator|.
name|hints_funcs
condition|)
for|for
control|(
name|n
operator|=
name|cur
operator|->
name|n_points
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
operator|,
name|vec
operator|++
control|)
block|{
name|vec
operator|->
name|x
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
comment|/* Then scale the metrics */
name|metrics
operator|->
name|horiAdvance
operator|=
name|FT_MulFix
argument_list|(
name|metrics
operator|->
name|horiAdvance
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
name|FT_MulFix
argument_list|(
name|metrics
operator|->
name|vertAdvance
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
comment|/* compute the other metrics */
name|FT_Outline_Get_CBox
argument_list|(
operator|&
name|cidglyph
operator|->
name|outline
argument_list|,
operator|&
name|cbox
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|width
operator|=
name|cbox
operator|.
name|xMax
operator|-
name|cbox
operator|.
name|xMin
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
name|cbox
operator|.
name|yMax
operator|-
name|cbox
operator|.
name|yMin
expr_stmt|;
name|metrics
operator|->
name|horiBearingX
operator|=
name|cbox
operator|.
name|xMin
expr_stmt|;
name|metrics
operator|->
name|horiBearingY
operator|=
name|cbox
operator|.
name|yMax
expr_stmt|;
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_VERTICAL_LAYOUT
condition|)
block|{
comment|/* make up vertical ones */
name|ft_synthesize_vertical_metrics
argument_list|(
name|metrics
argument_list|,
name|metrics
operator|->
name|vertAdvance
argument_list|)
expr_stmt|;
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
