begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  cidload.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    CID-keyed Type1 font loader (body).                                  */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2009 by             */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_CONFIG_CONFIG_H
end_include
begin_include
include|#
directive|include
include|FT_MULTIPLE_MASTERS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_TYPE1_TYPES_H
end_include
begin_include
include|#
directive|include
file|"cidload.h"
end_include
begin_include
include|#
directive|include
file|"ciderrs.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_cidload
end_define
begin_comment
comment|/* read a single offset */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|cid_get_offset
argument_list|(
argument|FT_Byte*  *start
argument_list|,
argument|FT_Byte    offsize
argument_list|)
end_macro
begin_block
block|{
name|FT_Long
name|result
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
operator|*
name|start
decl_stmt|;
for|for
control|(
name|result
operator|=
literal|0
init|;
name|offsize
operator|>
literal|0
condition|;
name|offsize
operator|--
control|)
block|{
name|result
operator|<<=
literal|8
expr_stmt|;
name|result
operator||=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|start
operator|=
name|p
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                    TYPE 1 SYMBOL PARSING                      *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|cid_load_keyword
name|cid_load_keyword
parameter_list|(
name|CID_Face
name|face
parameter_list|,
name|CID_Loader
modifier|*
name|loader
parameter_list|,
specifier|const
name|T1_Field
name|keyword
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|CID_Parser
modifier|*
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|FT_Byte
modifier|*
name|object
decl_stmt|;
name|void
modifier|*
name|dummy_object
decl_stmt|;
name|CID_FaceInfo
name|cid
init|=
operator|&
name|face
operator|->
name|cid
decl_stmt|;
comment|/* if the keyword has a dedicated callback, call it */
if|if
condition|(
name|keyword
operator|->
name|type
operator|==
name|T1_FIELD_TYPE_CALLBACK
condition|)
block|{
name|keyword
operator|->
name|reader
argument_list|(
operator|(
name|FT_Face
operator|)
name|face
argument_list|,
name|parser
argument_list|)
expr_stmt|;
name|error
operator|=
name|parser
operator|->
name|root
operator|.
name|error
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* we must now compute the address of our target object */
switch|switch
condition|(
name|keyword
operator|->
name|location
condition|)
block|{
case|case
name|T1_FIELD_LOCATION_CID_INFO
case|:
name|object
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|cid
expr_stmt|;
break|break;
case|case
name|T1_FIELD_LOCATION_FONT_INFO
case|:
name|object
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
operator|&
name|cid
operator|->
name|font_info
expr_stmt|;
break|break;
case|case
name|T1_FIELD_LOCATION_FONT_EXTRA
case|:
name|object
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
operator|&
name|face
operator|->
name|font_extra
expr_stmt|;
break|break;
case|case
name|T1_FIELD_LOCATION_BBOX
case|:
name|object
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
operator|&
name|cid
operator|->
name|font_bbox
expr_stmt|;
break|break;
default|default:
block|{
name|CID_FaceDict
name|dict
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|num_dict
operator|<
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cid_load_keyword: invalid use of `%s'!\n"
operator|,
name|keyword
operator|->
name|ident
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CID_Err_Syntax_Error
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|dict
operator|=
name|cid
operator|->
name|font_dicts
operator|+
name|parser
operator|->
name|num_dict
expr_stmt|;
switch|switch
condition|(
name|keyword
operator|->
name|location
condition|)
block|{
case|case
name|T1_FIELD_LOCATION_PRIVATE
case|:
name|object
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
operator|&
name|dict
operator|->
name|private_dict
expr_stmt|;
break|break;
default|default:
name|object
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|dict
expr_stmt|;
block|}
block|}
block|}
name|dummy_object
operator|=
name|object
expr_stmt|;
comment|/* now, load the keyword data in the object's field(s) */
if|if
condition|(
name|keyword
operator|->
name|type
operator|==
name|T1_FIELD_TYPE_INTEGER_ARRAY
operator|||
name|keyword
operator|->
name|type
operator|==
name|T1_FIELD_TYPE_FIXED_ARRAY
condition|)
name|error
operator|=
name|cid_parser_load_field_table
argument_list|(
operator|&
name|loader
operator|->
name|parser
argument_list|,
name|keyword
argument_list|,
operator|&
name|dummy_object
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|cid_parser_load_field
argument_list|(
operator|&
name|loader
operator|->
name|parser
argument_list|,
name|keyword
argument_list|,
operator|&
name|dummy_object
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|parse_font_matrix
argument_list|(
argument|CID_Face     face
argument_list|,
argument|CID_Parser*  parser
argument_list|)
end_macro
begin_block
block|{
name|FT_Matrix
modifier|*
name|matrix
decl_stmt|;
name|FT_Vector
modifier|*
name|offset
decl_stmt|;
name|CID_FaceDict
name|dict
decl_stmt|;
name|FT_Face
name|root
init|=
operator|(
name|FT_Face
operator|)
operator|&
name|face
operator|->
name|root
decl_stmt|;
name|FT_Fixed
name|temp
index|[
literal|6
index|]
decl_stmt|;
name|FT_Fixed
name|temp_scale
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|num_dict
operator|>=
literal|0
condition|)
block|{
name|dict
operator|=
name|face
operator|->
name|cid
operator|.
name|font_dicts
operator|+
name|parser
operator|->
name|num_dict
expr_stmt|;
name|matrix
operator|=
operator|&
name|dict
operator|->
name|font_matrix
expr_stmt|;
name|offset
operator|=
operator|&
name|dict
operator|->
name|font_offset
expr_stmt|;
operator|(
name|void
operator|)
name|cid_parser_to_fixed_array
argument_list|(
name|parser
argument_list|,
literal|6
argument_list|,
name|temp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|temp_scale
operator|=
name|FT_ABS
argument_list|(
name|temp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Set units per EM based on FontMatrix values.  We set the value to */
comment|/* `1000/temp_scale', because temp_scale was already multiplied by   */
comment|/* 1000 (in `t1_tofixed', from psobjs.c).                            */
name|root
operator|->
name|units_per_EM
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|FT_DivFix
argument_list|(
literal|0x10000L
argument_list|,
name|FT_DivFix
argument_list|(
name|temp_scale
argument_list|,
literal|1000
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we need to scale the values by 1.0/temp[3] */
if|if
condition|(
name|temp_scale
operator|!=
literal|0x10000L
condition|)
block|{
name|temp
index|[
literal|0
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|0
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|1
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|1
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|2
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|2
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|4
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|4
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|5
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|5
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|3
index|]
operator|=
literal|0x10000L
expr_stmt|;
block|}
name|matrix
operator|->
name|xx
operator|=
name|temp
index|[
literal|0
index|]
expr_stmt|;
name|matrix
operator|->
name|yx
operator|=
name|temp
index|[
literal|1
index|]
expr_stmt|;
name|matrix
operator|->
name|xy
operator|=
name|temp
index|[
literal|2
index|]
expr_stmt|;
name|matrix
operator|->
name|yy
operator|=
name|temp
index|[
literal|3
index|]
expr_stmt|;
comment|/* note that the font offsets are expressed in integer font units */
name|offset
operator|->
name|x
operator|=
name|temp
index|[
literal|4
index|]
operator|>>
literal|16
expr_stmt|;
name|offset
operator|->
name|y
operator|=
name|temp
index|[
literal|5
index|]
operator|>>
literal|16
expr_stmt|;
block|}
return|return
name|CID_Err_Ok
return|;
comment|/* this is a callback function; */
comment|/* we must return an error code */
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|parse_fd_array
argument_list|(
argument|CID_Face     face
argument_list|,
argument|CID_Parser*  parser
argument_list|)
end_macro
begin_block
block|{
name|CID_FaceInfo
name|cid
init|=
operator|&
name|face
operator|->
name|cid
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|CID_Err_Ok
decl_stmt|;
name|FT_Long
name|num_dicts
decl_stmt|;
name|num_dicts
operator|=
name|cid_parser_to_int
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cid
operator|->
name|font_dicts
condition|)
block|{
name|FT_Int
name|n
decl_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|cid
operator|->
name|font_dicts
argument_list|,
name|num_dicts
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|cid
operator|->
name|num_dicts
operator|=
operator|(
name|FT_UInt
operator|)
name|num_dicts
expr_stmt|;
comment|/* don't forget to set a few defaults */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|cid
operator|->
name|num_dicts
condition|;
name|n
operator|++
control|)
block|{
name|CID_FaceDict
name|dict
init|=
name|cid
operator|->
name|font_dicts
operator|+
name|n
decl_stmt|;
comment|/* default value for lenIV */
name|dict
operator|->
name|private_dict
operator|.
name|lenIV
operator|=
literal|4
expr_stmt|;
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* by mistake, `expansion_factor' appears both in PS_PrivateRec */
end_comment
begin_comment
comment|/* and CID_FaceDictRec (both are public header files and can't  */
end_comment
begin_comment
comment|/* changed); we simply copy the value                           */
end_comment
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|parse_expansion_factor
argument_list|(
argument|CID_Face     face
argument_list|,
argument|CID_Parser*  parser
argument_list|)
end_macro
begin_block
block|{
name|CID_FaceDict
name|dict
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|num_dict
operator|>=
literal|0
condition|)
block|{
name|dict
operator|=
name|face
operator|->
name|cid
operator|.
name|font_dicts
operator|+
name|parser
operator|->
name|num_dict
expr_stmt|;
name|dict
operator|->
name|expansion_factor
operator|=
name|cid_parser_to_fixed
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dict
operator|->
name|private_dict
operator|.
name|expansion_factor
operator|=
name|dict
operator|->
name|expansion_factor
expr_stmt|;
block|}
return|return
name|CID_Err_Ok
return|;
block|}
end_block
begin_decl_stmt
specifier|static
DECL|variable|cid_field_records
specifier|const
name|T1_FieldRec
name|cid_field_records
index|[]
init|=
block|{
include|#
directive|include
file|"cidtoken.h"
name|T1_FIELD_CALLBACK
argument_list|(
literal|"FDArray"
argument_list|,
argument|parse_fd_array
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"FontMatrix"
argument_list|,
argument|parse_font_matrix
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"ExpansionFactor"
argument_list|,
argument|parse_expansion_factor
argument_list|,
literal|0
argument_list|)
block|{
literal|0
block|,
name|T1_FIELD_LOCATION_CID_INFO
block|,
name|T1_FIELD_TYPE_NONE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|FT_Error
DECL|function|cid_parse_dict
name|cid_parse_dict
parameter_list|(
name|CID_Face
name|face
parameter_list|,
name|CID_Loader
modifier|*
name|loader
parameter_list|,
name|FT_Byte
modifier|*
name|base
parameter_list|,
name|FT_Long
name|size
parameter_list|)
block|{
name|CID_Parser
modifier|*
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|base
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|base
operator|+
name|size
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|CID_Err_Ok
expr_stmt|;
block|{
name|FT_Byte
modifier|*
name|cur
init|=
name|base
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|cur
operator|+
name|size
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_Byte
modifier|*
name|newlimit
decl_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|cur
expr_stmt|;
name|cid_parser_skip_spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|>=
name|limit
condition|)
name|newlimit
operator|=
name|limit
operator|-
literal|1
operator|-
literal|17
expr_stmt|;
else|else
name|newlimit
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|-
literal|17
expr_stmt|;
comment|/* look for `%ADOBeginFontDict' */
for|for
control|(
init|;
name|cur
operator|<
name|newlimit
condition|;
name|cur
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cur
operator|==
literal|'%'
operator|&&
name|ft_strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cur
argument_list|,
literal|"%ADOBeginFontDict"
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* if /FDArray was found, then cid->num_dicts is> 0, and */
comment|/* we can start increasing parser->num_dict               */
if|if
condition|(
name|face
operator|->
name|cid
operator|.
name|num_dicts
operator|>
literal|0
condition|)
name|parser
operator|->
name|num_dict
operator|++
expr_stmt|;
block|}
block|}
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
comment|/* no error can occur in cid_parser_skip_spaces */
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
break|break;
name|cid_parser_skip_PS_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|>=
name|limit
operator|||
name|parser
operator|->
name|root
operator|.
name|error
condition|)
break|break;
comment|/* look for immediates */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'/'
operator|&&
name|cur
operator|+
literal|2
operator|<
name|limit
condition|)
block|{
name|FT_PtrDist
name|len
decl_stmt|;
name|cur
operator|++
expr_stmt|;
name|len
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|-
name|cur
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<
literal|22
condition|)
block|{
comment|/* now compare the immediate name to the keyword table */
name|T1_Field
name|keyword
init|=
operator|(
name|T1_Field
operator|)
name|cid_field_records
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_Byte
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|keyword
operator|->
name|ident
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
break|break;
if|if
condition|(
name|cur
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
name|len
operator|==
operator|(
name|FT_PtrDist
operator|)
name|ft_strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|)
condition|)
block|{
name|FT_PtrDist
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|len
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|cur
index|[
name|n
index|]
operator|!=
name|name
index|[
name|n
index|]
condition|)
break|break;
if|if
condition|(
name|n
operator|>=
name|len
condition|)
block|{
comment|/* we found it - run the parsing callback */
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|cid_load_keyword
argument_list|(
name|face
argument_list|,
name|loader
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return
name|parser
operator|->
name|root
operator|.
name|error
return|;
break|break;
block|}
block|}
name|keyword
operator|++
expr_stmt|;
block|}
block|}
block|}
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
block|}
block|}
return|return
name|parser
operator|->
name|root
operator|.
name|error
return|;
block|}
end_function
begin_comment
comment|/* read the subrmap and the subrs of each font dict */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|cid_read_subrs
name|cid_read_subrs
parameter_list|(
name|CID_Face
name|face
parameter_list|)
block|{
name|CID_FaceInfo
name|cid
init|=
operator|&
name|face
operator|->
name|cid
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|cid_stream
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Int
name|n
decl_stmt|;
name|CID_Subrs
name|subr
decl_stmt|;
name|FT_UInt
name|max_offsets
init|=
literal|0
decl_stmt|;
name|FT_ULong
modifier|*
name|offsets
init|=
literal|0
decl_stmt|;
name|PSAux_Service
name|psaux
init|=
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
decl_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|face
operator|->
name|subrs
argument_list|,
name|cid
operator|->
name|num_dicts
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|subr
operator|=
name|face
operator|->
name|subrs
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|cid
operator|->
name|num_dicts
condition|;
name|n
operator|++
operator|,
name|subr
operator|++
control|)
block|{
name|CID_FaceDict
name|dict
init|=
name|cid
operator|->
name|font_dicts
operator|+
name|n
decl_stmt|;
name|FT_Int
name|lenIV
init|=
name|dict
operator|->
name|private_dict
operator|.
name|lenIV
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|,
name|num_subrs
init|=
name|dict
operator|->
name|num_subrs
decl_stmt|;
name|FT_ULong
name|data_len
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
comment|/* reallocate offsets array if needed */
if|if
condition|(
name|num_subrs
operator|+
literal|1
operator|>
name|max_offsets
condition|)
block|{
name|FT_UInt
name|new_max
init|=
name|FT_PAD_CEIL
argument_list|(
name|num_subrs
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|offsets
argument_list|,
name|max_offsets
argument_list|,
name|new_max
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|max_offsets
operator|=
name|new_max
expr_stmt|;
block|}
comment|/* read the subrmap's offsets */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|cid
operator|->
name|data_offset
operator|+
name|dict
operator|->
name|subrmap_offset
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
operator|(
name|num_subrs
operator|+
literal|1
operator|)
operator|*
name|dict
operator|->
name|sd_bytes
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|p
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|stream
operator|->
name|cursor
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<=
name|num_subrs
condition|;
name|count
operator|++
control|)
name|offsets
index|[
name|count
index|]
operator|=
name|cid_get_offset
argument_list|(
operator|&
name|p
argument_list|,
operator|(
name|FT_Byte
operator|)
name|dict
operator|->
name|sd_bytes
argument_list|)
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
comment|/* now, compute the size of subrs charstrings, */
comment|/* allocate, and read them                     */
name|data_len
operator|=
name|offsets
index|[
name|num_subrs
index|]
operator|-
name|offsets
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|subr
operator|->
name|code
argument_list|,
name|num_subrs
operator|+
literal|1
argument_list|)
operator|||
name|FT_ALLOC
argument_list|(
name|subr
operator|->
name|code
index|[
literal|0
index|]
argument_list|,
name|data_len
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|cid
operator|->
name|data_offset
operator|+
name|offsets
index|[
literal|0
index|]
argument_list|)
operator|||
name|FT_STREAM_READ
argument_list|(
name|subr
operator|->
name|code
index|[
literal|0
index|]
argument_list|,
name|data_len
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
comment|/* set up pointers */
for|for
control|(
name|count
operator|=
literal|1
init|;
name|count
operator|<=
name|num_subrs
condition|;
name|count
operator|++
control|)
block|{
name|FT_ULong
name|len
decl_stmt|;
name|len
operator|=
name|offsets
index|[
name|count
index|]
operator|-
name|offsets
index|[
name|count
operator|-
literal|1
index|]
expr_stmt|;
name|subr
operator|->
name|code
index|[
name|count
index|]
operator|=
name|subr
operator|->
name|code
index|[
name|count
operator|-
literal|1
index|]
operator|+
name|len
expr_stmt|;
block|}
comment|/* decrypt subroutines, but only if lenIV>= 0 */
if|if
condition|(
name|lenIV
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|num_subrs
condition|;
name|count
operator|++
control|)
block|{
name|FT_ULong
name|len
decl_stmt|;
name|len
operator|=
name|offsets
index|[
name|count
operator|+
literal|1
index|]
operator|-
name|offsets
index|[
name|count
index|]
expr_stmt|;
name|psaux
operator|->
name|t1_decrypt
argument_list|(
name|subr
operator|->
name|code
index|[
name|count
index|]
argument_list|,
name|len
argument_list|,
literal|4330
argument_list|)
expr_stmt|;
block|}
block|}
name|subr
operator|->
name|num_subrs
operator|=
name|num_subrs
expr_stmt|;
block|}
name|Exit
label|:
name|FT_FREE
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
return|return
name|error
return|;
name|Fail
label|:
if|if
condition|(
name|face
operator|->
name|subrs
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|cid
operator|->
name|num_dicts
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|face
operator|->
name|subrs
index|[
name|n
index|]
operator|.
name|code
condition|)
name|FT_FREE
argument_list|(
name|face
operator|->
name|subrs
index|[
name|n
index|]
operator|.
name|code
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|subrs
index|[
name|n
index|]
operator|.
name|code
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|face
operator|->
name|subrs
argument_list|)
expr_stmt|;
block|}
goto|goto
name|Exit
goto|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|t1_init_loader
name|t1_init_loader
parameter_list|(
name|CID_Loader
modifier|*
name|loader
parameter_list|,
name|CID_Face
name|face
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|loader
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|loader
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|t1_done_loader
name|t1_done_loader
parameter_list|(
name|CID_Loader
modifier|*
name|loader
parameter_list|)
block|{
name|CID_Parser
modifier|*
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
comment|/* finalize parser */
name|cid_parser_done
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cid_hex_to_binary
name|cid_hex_to_binary
parameter_list|(
name|FT_Byte
modifier|*
name|data
parameter_list|,
name|FT_Long
name|data_len
parameter_list|,
name|FT_ULong
name|offset
parameter_list|,
name|CID_Face
name|face
parameter_list|)
block|{
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|root
operator|.
name|stream
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Byte
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|,
modifier|*
name|plimit
decl_stmt|;
name|FT_Byte
modifier|*
name|d
decl_stmt|,
modifier|*
name|dlimit
decl_stmt|;
name|FT_Byte
name|val
decl_stmt|;
name|FT_Bool
name|upper_nibble
decl_stmt|,
name|done
decl_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|offset
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|d
operator|=
name|data
expr_stmt|;
name|dlimit
operator|=
name|d
operator|+
name|data_len
expr_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
name|plimit
operator|=
name|p
expr_stmt|;
name|upper_nibble
operator|=
literal|1
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|d
operator|<
name|dlimit
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|plimit
condition|)
block|{
name|FT_ULong
name|oldpos
init|=
name|FT_STREAM_POS
argument_list|()
decl_stmt|;
name|FT_ULong
name|size
init|=
name|stream
operator|->
name|size
operator|-
name|oldpos
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|CID_Err_Syntax_Error
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|FT_STREAM_READ
argument_list|(
name|buffer
argument_list|,
literal|256
operator|>
name|size
condition|?
name|size
else|:
literal|256
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|=
name|buffer
expr_stmt|;
name|plimit
operator|=
name|p
operator|+
name|FT_STREAM_POS
argument_list|()
operator|-
name|oldpos
expr_stmt|;
block|}
if|if
condition|(
name|ft_isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|val
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|*
name|p
operator|-
literal|'0'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'f'
condition|)
name|val
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|*
name|p
operator|-
literal|'a'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'F'
condition|)
name|val
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|*
name|p
operator|-
literal|'A'
operator|+
literal|10
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|'\r'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\f'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'>'
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|CID_Err_Syntax_Error
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|upper_nibble
condition|)
operator|*
name|d
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|val
operator|<<
literal|4
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|d
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|*
name|d
operator|+
name|val
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
name|upper_nibble
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
literal|1
operator|-
name|upper_nibble
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|CID_Err_Ok
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cid_face_open
argument_list|(
argument|CID_Face  face
argument_list|,
argument|FT_Int    face_index
argument_list|)
end_macro
begin_block
block|{
name|CID_Loader
name|loader
decl_stmt|;
name|CID_Parser
modifier|*
name|parser
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|t1_init_loader
argument_list|(
operator|&
name|loader
argument_list|,
name|face
argument_list|)
expr_stmt|;
name|parser
operator|=
operator|&
name|loader
operator|.
name|parser
expr_stmt|;
name|error
operator|=
name|cid_parser_new
argument_list|(
name|parser
argument_list|,
name|face
operator|->
name|root
operator|.
name|stream
argument_list|,
name|face
operator|->
name|root
operator|.
name|memory
argument_list|,
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|cid_parse_dict
argument_list|(
name|face
argument_list|,
operator|&
name|loader
argument_list|,
name|parser
operator|->
name|postscript
argument_list|,
name|parser
operator|->
name|postscript_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|face_index
operator|<
literal|0
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|face
operator|->
name|cid_stream
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|parser
operator|->
name|binary_length
condition|)
block|{
comment|/* we must convert the data section from hexadecimal to binary */
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|face
operator|->
name|binary_data
argument_list|,
name|parser
operator|->
name|binary_length
argument_list|)
operator|||
name|cid_hex_to_binary
argument_list|(
name|face
operator|->
name|binary_data
argument_list|,
name|parser
operator|->
name|binary_length
argument_list|,
name|parser
operator|->
name|data_offset
argument_list|,
name|face
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|FT_Stream_OpenMemory
argument_list|(
name|face
operator|->
name|cid_stream
argument_list|,
name|face
operator|->
name|binary_data
argument_list|,
name|parser
operator|->
name|binary_length
argument_list|)
expr_stmt|;
name|face
operator|->
name|cid
operator|.
name|data_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|face
operator|->
name|cid_stream
operator|=
operator|*
name|face
operator|->
name|root
operator|.
name|stream
expr_stmt|;
name|face
operator|->
name|cid
operator|.
name|data_offset
operator|=
name|loader
operator|.
name|parser
operator|.
name|data_offset
expr_stmt|;
block|}
name|error
operator|=
name|cid_read_subrs
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|Exit
label|:
name|t1_done_loader
argument_list|(
operator|&
name|loader
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
