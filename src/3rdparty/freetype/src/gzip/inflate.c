begin_unit
begin_comment
comment|/* inflate.c -- zlib interface to inflate modules  * Copyright (C) 1995-2002 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment
begin_include
include|#
directive|include
file|"zutil.h"
end_include
begin_include
include|#
directive|include
file|"infblock.h"
end_include
begin_define
DECL|macro|DONE
define|#
directive|define
name|DONE
value|INFLATE_DONE
end_define
begin_define
DECL|macro|BAD
define|#
directive|define
name|BAD
value|INFLATE_BAD
end_define
begin_typedef
typedef|typedef
enum|enum
block|{
DECL|enumerator|METHOD
name|METHOD
block|,
comment|/* waiting for method byte */
DECL|enumerator|FLAG
name|FLAG
block|,
comment|/* waiting for flag byte */
DECL|enumerator|DICT4
name|DICT4
block|,
comment|/* four dictionary check bytes to go */
DECL|enumerator|DICT3
name|DICT3
block|,
comment|/* three dictionary check bytes to go */
DECL|enumerator|DICT2
name|DICT2
block|,
comment|/* two dictionary check bytes to go */
DECL|enumerator|DICT1
name|DICT1
block|,
comment|/* one dictionary check byte to go */
DECL|enumerator|DICT0
name|DICT0
block|,
comment|/* waiting for inflateSetDictionary */
DECL|enumerator|BLOCKS
name|BLOCKS
block|,
comment|/* decompressing blocks */
DECL|enumerator|CHECK4
name|CHECK4
block|,
comment|/* four check bytes to go */
DECL|enumerator|CHECK3
name|CHECK3
block|,
comment|/* three check bytes to go */
DECL|enumerator|CHECK2
name|CHECK2
block|,
comment|/* two check bytes to go */
DECL|enumerator|CHECK1
name|CHECK1
block|,
comment|/* one check byte to go */
DECL|enumerator|DONE
name|DONE
block|,
comment|/* finished check, done */
DECL|enumerator|BAD
name|BAD
block|}
comment|/* got an error--stay here */
DECL|typedef|inflate_mode
name|inflate_mode
typedef|;
end_typedef
begin_comment
comment|/* inflate private state */
end_comment
begin_struct
DECL|struct|internal_state
struct|struct
name|internal_state
block|{
comment|/* mode */
DECL|member|mode
name|inflate_mode
name|mode
decl_stmt|;
comment|/* current inflate mode */
comment|/* mode dependent information */
union|union
block|{
DECL|member|method
name|uInt
name|method
decl_stmt|;
comment|/* if FLAGS, method byte */
struct|struct
block|{
DECL|member|was
name|uLong
name|was
decl_stmt|;
comment|/* computed check value */
DECL|member|need
name|uLong
name|need
decl_stmt|;
comment|/* stream check value */
block|}
DECL|member|check
name|check
struct|;
comment|/* if CHECK, check values to compare */
DECL|member|marker
name|uInt
name|marker
decl_stmt|;
comment|/* if BAD, inflateSync's marker bytes count */
block|}
DECL|member|sub
name|sub
union|;
comment|/* submode */
comment|/* mode independent information */
DECL|member|nowrap
name|int
name|nowrap
decl_stmt|;
comment|/* flag for no wrapper */
DECL|member|wbits
name|uInt
name|wbits
decl_stmt|;
comment|/* log2(window size)  (8..15, defaults to 15) */
name|inflate_blocks_statef
DECL|member|blocks
modifier|*
name|blocks
decl_stmt|;
comment|/* current inflate_blocks state */
block|}
struct|;
end_struct
begin_macro
DECL|function|inflateReset
name|ZEXPORT
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|inflateReset
name|inflateReset
argument_list|(
comment|/* z) */
argument|z_streamp z
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|z
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|z
operator|->
name|total_in
operator|=
name|z
operator|->
name|total_out
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|z
operator|->
name|state
operator|->
name|nowrap
condition|?
name|BLOCKS
else|:
name|METHOD
expr_stmt|;
name|inflate_blocks_reset
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|z
argument_list|,
name|Z_NULL
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: reset\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_block
begin_macro
DECL|function|inflateEnd
name|ZEXPORT
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|inflateEnd
name|inflateEnd
argument_list|(
comment|/* z) */
argument|z_streamp z
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|z
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|zfree
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|z
operator|->
name|state
operator|->
name|blocks
operator|!=
name|Z_NULL
condition|)
name|inflate_blocks_free
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|ZFREE
argument_list|(
name|z
argument_list|,
name|z
operator|->
name|state
argument_list|)
expr_stmt|;
name|z
operator|->
name|state
operator|=
name|Z_NULL
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: end\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_block
begin_macro
DECL|function|inflateInit2_
name|ZEXPORT
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|inflateInit2_
name|inflateInit2_
argument_list|(
comment|/* z, w, version, stream_size) */
argument|z_streamp z
argument_list|,
argument|int w
argument_list|,
argument|const char *version
argument_list|,
argument|int stream_size
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|version
operator|==
name|Z_NULL
operator|||
name|version
index|[
literal|0
index|]
operator|!=
name|ZLIB_VERSION
index|[
literal|0
index|]
operator|||
name|stream_size
operator|!=
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
condition|)
return|return
name|Z_VERSION_ERROR
return|;
comment|/* initialize state */
if|if
condition|(
name|z
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|z
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|zalloc
operator|==
name|Z_NULL
condition|)
block|{
name|z
operator|->
name|zalloc
operator|=
name|zcalloc
expr_stmt|;
name|z
operator|->
name|opaque
operator|=
operator|(
name|voidpf
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|->
name|zfree
operator|==
name|Z_NULL
condition|)
name|z
operator|->
name|zfree
operator|=
name|zcfree
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|->
name|state
operator|=
operator|(
expr|struct
name|internal_state
name|FAR
operator|*
operator|)
name|ZALLOC
argument_list|(
name|z
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_state
argument_list|)
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
return|return
name|Z_MEM_ERROR
return|;
name|z
operator|->
name|state
operator|->
name|blocks
operator|=
name|Z_NULL
expr_stmt|;
comment|/* handle undocumented nowrap option (no zlib header or check) */
name|z
operator|->
name|state
operator|->
name|nowrap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|w
operator|=
operator|-
name|w
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|nowrap
operator|=
literal|1
expr_stmt|;
block|}
comment|/* set window size */
if|if
condition|(
name|w
operator|<
literal|8
operator|||
name|w
operator|>
literal|15
condition|)
block|{
name|inflateEnd
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
name|Z_STREAM_ERROR
return|;
block|}
name|z
operator|->
name|state
operator|->
name|wbits
operator|=
operator|(
name|uInt
operator|)
name|w
expr_stmt|;
comment|/* create inflate_blocks state */
if|if
condition|(
operator|(
name|z
operator|->
name|state
operator|->
name|blocks
operator|=
name|inflate_blocks_new
argument_list|(
name|z
argument_list|,
name|z
operator|->
name|state
operator|->
name|nowrap
condition|?
name|Z_NULL
else|:
name|adler32
argument_list|,
operator|(
name|uInt
operator|)
literal|1
operator|<<
name|w
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
block|{
name|inflateEnd
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
name|Z_MEM_ERROR
return|;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: allocated\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* reset state */
name|inflateReset
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_block
begin_undef
DECL|macro|NEEDBYTE
undef|#
directive|undef
name|NEEDBYTE
end_undef
begin_define
DECL|macro|NEEDBYTE
define|#
directive|define
name|NEEDBYTE
value|{if(z->avail_in==0)return r;r=f;}
end_define
begin_undef
DECL|macro|NEXTBYTE
undef|#
directive|undef
name|NEXTBYTE
end_undef
begin_define
DECL|macro|NEXTBYTE
define|#
directive|define
name|NEXTBYTE
value|(z->avail_in--,z->total_in++,*z->next_in++)
end_define
begin_macro
DECL|function|inflate
name|ZEXPORT
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|inflate
name|inflate
argument_list|(
comment|/* z, f) */
argument|z_streamp z
argument_list|,
argument|int f
argument_list|)
end_macro
begin_block
block|{
name|int
name|r
decl_stmt|;
name|uInt
name|b
decl_stmt|;
if|if
condition|(
name|z
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|next_in
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|f
operator|=
name|f
operator|==
name|Z_FINISH
condition|?
name|Z_BUF_ERROR
else|:
name|Z_OK
expr_stmt|;
name|r
operator|=
name|Z_BUF_ERROR
expr_stmt|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|z
operator|->
name|state
operator|->
name|mode
condition|)
block|{
case|case
name|METHOD
case|:
name|NEEDBYTE
if|if
condition|(
operator|(
operator|(
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|method
operator|=
name|NEXTBYTE
operator|)
operator|&
literal|0xf
operator|)
operator|!=
name|Z_DEFLATED
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"unknown compression method"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|5
expr_stmt|;
comment|/* can't try inflateSync */
break|break;
block|}
if|if
condition|(
operator|(
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|method
operator|>>
literal|4
operator|)
operator|+
literal|8
operator|>
name|z
operator|->
name|state
operator|->
name|wbits
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid window size"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|5
expr_stmt|;
comment|/* can't try inflateSync */
break|break;
block|}
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|FLAG
expr_stmt|;
case|case
name|FLAG
case|:
name|NEEDBYTE
name|b
init|=
name|NEXTBYTE
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|method
operator|<<
literal|8
operator|)
operator|+
name|b
operator|)
operator|%
literal|31
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"incorrect header check"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|5
expr_stmt|;
comment|/* can't try inflateSync */
break|break;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: zlib header ok\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|&
name|PRESET_DICT
operator|)
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BLOCKS
expr_stmt|;
break|break;
block|}
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DICT4
expr_stmt|;
case|case
name|DICT4
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
init|=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|24
decl_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DICT3
expr_stmt|;
case|case
name|DICT3
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|16
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DICT2
expr_stmt|;
case|case
name|DICT2
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|8
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DICT1
expr_stmt|;
case|case
name|DICT1
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
expr_stmt|;
name|z
operator|->
name|adler
operator|=
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DICT0
expr_stmt|;
return|return
name|Z_NEED_DICT
return|;
case|case
name|DICT0
case|:
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"need dictionary"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|0
expr_stmt|;
comment|/* can try inflateSync */
return|return
name|Z_STREAM_ERROR
return|;
case|case
name|BLOCKS
case|:
name|r
operator|=
name|inflate_blocks
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|z
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|Z_DATA_ERROR
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|0
expr_stmt|;
comment|/* can try inflateSync */
break|break;
block|}
if|if
condition|(
name|r
operator|==
name|Z_OK
condition|)
name|r
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|Z_STREAM_END
condition|)
return|return
name|r
return|;
name|r
operator|=
name|f
expr_stmt|;
name|inflate_blocks_reset
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|z
argument_list|,
operator|&
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|was
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|state
operator|->
name|nowrap
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DONE
expr_stmt|;
break|break;
block|}
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|CHECK4
expr_stmt|;
case|case
name|CHECK4
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
init|=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|24
decl_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|CHECK3
expr_stmt|;
case|case
name|CHECK3
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|16
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|CHECK2
expr_stmt|;
case|case
name|CHECK2
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|8
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|CHECK1
expr_stmt|;
case|case
name|CHECK1
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|was
operator|!=
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"incorrect data check"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|5
expr_stmt|;
comment|/* can't try inflateSync */
break|break;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: zlib check ok\n"
operator|)
argument_list|)
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DONE
expr_stmt|;
case|case
name|DONE
case|:
return|return
name|Z_STREAM_END
return|;
case|case
name|BAD
case|:
return|return
name|Z_DATA_ERROR
return|;
default|default:
return|return
name|Z_STREAM_ERROR
return|;
block|}
ifdef|#
directive|ifdef
name|NEED_DUMMY_RETURN
return|return
name|Z_STREAM_ERROR
return|;
comment|/* Some dumb compilers complain without this */
endif|#
directive|endif
block|}
end_block
end_unit
