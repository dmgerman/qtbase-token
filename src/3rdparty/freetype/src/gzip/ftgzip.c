begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftgzip.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType support for .gz compressed files.                           */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This optional component relies on zlib.  It should mainly be used to   */
end_comment
begin_comment
comment|/*  parse compressed PCF fonts, as found with many X11 server              */
end_comment
begin_comment
comment|/*  distributions.                                                         */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2002-2015 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_MEMORY_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_GZIP_H
end_include
begin_include
include|#
directive|include
include|FT_CONFIG_STANDARD_LIBRARY_H
end_include
begin_include
include|#
directive|include
include|FT_MODULE_ERRORS_H
end_include
begin_undef
DECL|macro|__FTERRORS_H__
undef|#
directive|undef
name|__FTERRORS_H__
end_undef
begin_undef
DECL|macro|FT_ERR_PREFIX
undef|#
directive|undef
name|FT_ERR_PREFIX
end_undef
begin_define
DECL|macro|FT_ERR_PREFIX
define|#
directive|define
name|FT_ERR_PREFIX
value|Gzip_Err_
end_define
begin_define
DECL|macro|FT_ERR_BASE
define|#
directive|define
name|FT_ERR_BASE
value|FT_Mod_Err_Gzip
end_define
begin_include
include|#
directive|include
include|FT_ERRORS_H
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_USE_ZLIB
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
end_ifdef
begin_error
error|#
directive|error
literal|"gzip code does not support PIC yet"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_SYSTEM_ZLIB
end_ifdef
begin_include
include|#
directive|include
file|<zlib.h>
end_include
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_CONFIG_OPTION_SYSTEM_ZLIB */
end_comment
begin_comment
comment|/* In this case, we include our own modified sources of the ZLib    */
end_comment
begin_comment
comment|/* within the "ftgzip" component.  The modifications were necessary */
end_comment
begin_comment
comment|/* to #include all files without conflicts, as well as preventing   */
end_comment
begin_comment
comment|/* the definition of "extern" functions that may cause linking      */
end_comment
begin_comment
comment|/* conflicts when a program is linked with both FreeType and the    */
end_comment
begin_comment
comment|/* original ZLib.                                                   */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USE_ZLIB_ZCALLOC
end_ifndef
begin_define
DECL|macro|MY_ZCALLOC
define|#
directive|define
name|MY_ZCALLOC
end_define
begin_comment
DECL|macro|MY_ZCALLOC
comment|/* prevent all zcalloc()& zfree() in zutils.c */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"zlib.h"
end_include
begin_undef
DECL|macro|SLOW
undef|#
directive|undef
name|SLOW
end_undef
begin_define
DECL|macro|SLOW
define|#
directive|define
name|SLOW
value|1
end_define
begin_comment
DECL|macro|SLOW
comment|/* we can't use asm-optimized sources here! */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_comment
comment|/* Visual C++ (and Intel C++)   */
end_comment
begin_comment
comment|/* We disable the warning `conversion from XXX to YYY,     */
end_comment
begin_comment
comment|/* possible loss of data' in order to compile cleanly with */
end_comment
begin_comment
comment|/* the maximum level of warnings: zlib is non-FreeType     */
end_comment
begin_comment
comment|/* code.                                                   */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|push
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4244
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* _MSC_VER */
end_comment
begin_comment
comment|/* Urgh.  `inflate_mask' must not be declared twice -- C++ doesn't like      this.  We temporarily disable it and load all necessary header files. */
end_comment
begin_define
DECL|macro|NO_INFLATE_MASK
define|#
directive|define
name|NO_INFLATE_MASK
end_define
begin_include
include|#
directive|include
file|"zutil.h"
end_include
begin_include
include|#
directive|include
file|"inftrees.h"
end_include
begin_include
include|#
directive|include
file|"infblock.h"
end_include
begin_include
include|#
directive|include
file|"infcodes.h"
end_include
begin_include
include|#
directive|include
file|"infutil.h"
end_include
begin_undef
DECL|macro|NO_INFLATE_MASK
undef|#
directive|undef
name|NO_INFLATE_MASK
end_undef
begin_comment
comment|/* infutil.c must be included before infcodes.c */
end_comment
begin_include
include|#
directive|include
file|"zutil.c"
end_include
begin_include
include|#
directive|include
file|"inftrees.c"
end_include
begin_include
include|#
directive|include
file|"infutil.c"
end_include
begin_include
include|#
directive|include
file|"infcodes.c"
end_include
begin_include
include|#
directive|include
file|"infblock.c"
end_include
begin_include
include|#
directive|include
file|"inflate.c"
end_include
begin_include
include|#
directive|include
file|"adler32.c"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|pop
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_CONFIG_OPTION_SYSTEM_ZLIB */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/*****            Z L I B   M E M O R Y   M A N A G E M E N T          *****/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/* it is better to use FreeType memory routines instead of raw      'malloc/free' */
end_comment
begin_function
specifier|static
name|voidpf
DECL|function|ft_gzip_alloc
name|ft_gzip_alloc
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|uInt
name|items
parameter_list|,
name|uInt
name|size
parameter_list|)
block|{
name|FT_ULong
name|sz
init|=
operator|(
name|FT_ULong
operator|)
name|size
operator|*
name|items
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Pointer
name|p
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|FT_ALLOC
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_gzip_free
name|ft_gzip_free
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|voidpf
name|address
parameter_list|)
block|{
name|FT_MEM_FREE
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FT_CONFIG_OPTION_SYSTEM_ZLIB
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USE_ZLIB_ZCALLOC
argument_list|)
end_if
begin_function
name|local
name|voidpf
DECL|function|zcalloc
name|zcalloc
parameter_list|(
name|voidpf
name|opaque
parameter_list|,
name|unsigned
name|items
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
return|return
name|ft_gzip_alloc
argument_list|(
operator|(
name|FT_Memory
operator|)
name|opaque
argument_list|,
name|items
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function
begin_function
name|local
name|void
DECL|function|zcfree
name|zcfree
parameter_list|(
name|voidpf
name|opaque
parameter_list|,
name|voidpf
name|ptr
parameter_list|)
block|{
name|ft_gzip_free
argument_list|(
operator|(
name|FT_Memory
operator|)
name|opaque
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !SYSTEM_ZLIB&& !USE_ZLIB_ZCALLOC */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/*****               Z L I B   F I L E   D E S C R I P T O R           *****/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_define
DECL|macro|FT_GZIP_BUFFER_SIZE
define|#
directive|define
name|FT_GZIP_BUFFER_SIZE
value|4096
end_define
begin_typedef
DECL|struct|FT_GZipFileRec_
typedef|typedef
struct|struct
name|FT_GZipFileRec_
block|{
DECL|member|source
name|FT_Stream
name|source
decl_stmt|;
comment|/* parent/source stream        */
DECL|member|stream
name|FT_Stream
name|stream
decl_stmt|;
comment|/* embedding stream            */
DECL|member|memory
name|FT_Memory
name|memory
decl_stmt|;
comment|/* memory allocator            */
DECL|member|zstream
name|z_stream
name|zstream
decl_stmt|;
comment|/* zlib input stream           */
DECL|member|start
name|FT_ULong
name|start
decl_stmt|;
comment|/* starting position, after .gz header */
DECL|member|input
name|FT_Byte
name|input
index|[
name|FT_GZIP_BUFFER_SIZE
index|]
decl_stmt|;
comment|/* input read buffer  */
DECL|member|buffer
name|FT_Byte
name|buffer
index|[
name|FT_GZIP_BUFFER_SIZE
index|]
decl_stmt|;
comment|/* output buffer      */
DECL|member|pos
name|FT_ULong
name|pos
decl_stmt|;
comment|/* position in output */
DECL|member|cursor
name|FT_Byte
modifier|*
name|cursor
decl_stmt|;
DECL|member|limit
name|FT_Byte
modifier|*
name|limit
decl_stmt|;
block|}
DECL|typedef|FT_GZipFileRec
DECL|typedef|FT_GZipFile
name|FT_GZipFileRec
operator|,
typedef|*
name|FT_GZipFile
typedef|;
end_typedef
begin_comment
comment|/* gzip flag byte */
end_comment
begin_define
DECL|macro|FT_GZIP_ASCII_FLAG
define|#
directive|define
name|FT_GZIP_ASCII_FLAG
value|0x01
end_define
begin_comment
DECL|macro|FT_GZIP_ASCII_FLAG
comment|/* bit 0 set: file probably ascii text */
end_comment
begin_define
DECL|macro|FT_GZIP_HEAD_CRC
define|#
directive|define
name|FT_GZIP_HEAD_CRC
value|0x02
end_define
begin_comment
DECL|macro|FT_GZIP_HEAD_CRC
comment|/* bit 1 set: header CRC present */
end_comment
begin_define
DECL|macro|FT_GZIP_EXTRA_FIELD
define|#
directive|define
name|FT_GZIP_EXTRA_FIELD
value|0x04
end_define
begin_comment
DECL|macro|FT_GZIP_EXTRA_FIELD
comment|/* bit 2 set: extra field present */
end_comment
begin_define
DECL|macro|FT_GZIP_ORIG_NAME
define|#
directive|define
name|FT_GZIP_ORIG_NAME
value|0x08
end_define
begin_comment
DECL|macro|FT_GZIP_ORIG_NAME
comment|/* bit 3 set: original file name present */
end_comment
begin_define
DECL|macro|FT_GZIP_COMMENT
define|#
directive|define
name|FT_GZIP_COMMENT
value|0x10
end_define
begin_comment
DECL|macro|FT_GZIP_COMMENT
comment|/* bit 4 set: file comment present */
end_comment
begin_define
DECL|macro|FT_GZIP_RESERVED
define|#
directive|define
name|FT_GZIP_RESERVED
value|0xE0
end_define
begin_comment
DECL|macro|FT_GZIP_RESERVED
comment|/* bits 5..7: reserved */
end_comment
begin_comment
comment|/* check and skip .gz header - we don't support `transparent' compression */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_gzip_check_header
name|ft_gzip_check_header
parameter_list|(
name|FT_Stream
name|stream
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Byte
name|head
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
operator|||
name|FT_STREAM_READ
argument_list|(
name|head
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* head[0]&& head[1] are the magic numbers;    */
comment|/* head[2] is the method, and head[3] the flags */
if|if
condition|(
name|head
index|[
literal|0
index|]
operator|!=
literal|0x1F
operator|||
name|head
index|[
literal|1
index|]
operator|!=
literal|0x8B
operator|||
name|head
index|[
literal|2
index|]
operator|!=
name|Z_DEFLATED
operator|||
operator|(
name|head
index|[
literal|3
index|]
operator|&
name|FT_GZIP_RESERVED
operator|)
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* skip time, xflags and os code */
operator|(
name|void
operator|)
name|FT_STREAM_SKIP
argument_list|(
literal|6
argument_list|)
expr_stmt|;
comment|/* skip the extra field */
if|if
condition|(
name|head
index|[
literal|3
index|]
operator|&
name|FT_GZIP_EXTRA_FIELD
condition|)
block|{
name|FT_UInt
name|len
decl_stmt|;
if|if
condition|(
name|FT_READ_USHORT_LE
argument_list|(
name|len
argument_list|)
operator|||
name|FT_STREAM_SKIP
argument_list|(
name|len
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* skip original file name */
if|if
condition|(
name|head
index|[
literal|3
index|]
operator|&
name|FT_GZIP_ORIG_NAME
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_UInt
name|c
decl_stmt|;
if|if
condition|(
name|FT_READ_BYTE
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* skip .gz comment */
if|if
condition|(
name|head
index|[
literal|3
index|]
operator|&
name|FT_GZIP_COMMENT
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_UInt
name|c
decl_stmt|;
if|if
condition|(
name|FT_READ_BYTE
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* skip CRC */
if|if
condition|(
name|head
index|[
literal|3
index|]
operator|&
name|FT_GZIP_HEAD_CRC
condition|)
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
literal|2
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_gzip_file_init
name|ft_gzip_file_init
parameter_list|(
name|FT_GZipFile
name|zip
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_Stream
name|source
parameter_list|)
block|{
name|z_stream
modifier|*
name|zstream
init|=
operator|&
name|zip
operator|->
name|zstream
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|zip
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|zip
operator|->
name|source
operator|=
name|source
expr_stmt|;
name|zip
operator|->
name|memory
operator|=
name|stream
operator|->
name|memory
expr_stmt|;
name|zip
operator|->
name|limit
operator|=
name|zip
operator|->
name|buffer
operator|+
name|FT_GZIP_BUFFER_SIZE
expr_stmt|;
name|zip
operator|->
name|cursor
operator|=
name|zip
operator|->
name|limit
expr_stmt|;
name|zip
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
comment|/* check and skip .gz header */
block|{
name|stream
operator|=
name|source
expr_stmt|;
name|error
operator|=
name|ft_gzip_check_header
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|zip
operator|->
name|start
operator|=
name|FT_STREAM_POS
argument_list|()
expr_stmt|;
block|}
comment|/* initialize zlib -- there is no zlib header in the compressed stream */
name|zstream
operator|->
name|zalloc
operator|=
operator|(
name|alloc_func
operator|)
name|ft_gzip_alloc
expr_stmt|;
name|zstream
operator|->
name|zfree
operator|=
operator|(
name|free_func
operator|)
name|ft_gzip_free
expr_stmt|;
name|zstream
operator|->
name|opaque
operator|=
name|stream
operator|->
name|memory
expr_stmt|;
name|zstream
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
name|zstream
operator|->
name|next_in
operator|=
name|zip
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|inflateInit2
argument_list|(
name|zstream
argument_list|,
operator|-
name|MAX_WBITS
argument_list|)
operator|!=
name|Z_OK
operator|||
name|zstream
operator|->
name|next_in
operator|==
name|NULL
condition|)
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_gzip_file_done
name|ft_gzip_file_done
parameter_list|(
name|FT_GZipFile
name|zip
parameter_list|)
block|{
name|z_stream
modifier|*
name|zstream
init|=
operator|&
name|zip
operator|->
name|zstream
decl_stmt|;
name|inflateEnd
argument_list|(
name|zstream
argument_list|)
expr_stmt|;
comment|/* clear the rest */
name|zstream
operator|->
name|zalloc
operator|=
name|NULL
expr_stmt|;
name|zstream
operator|->
name|zfree
operator|=
name|NULL
expr_stmt|;
name|zstream
operator|->
name|opaque
operator|=
name|NULL
expr_stmt|;
name|zstream
operator|->
name|next_in
operator|=
name|NULL
expr_stmt|;
name|zstream
operator|->
name|next_out
operator|=
name|NULL
expr_stmt|;
name|zstream
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
name|zstream
operator|->
name|avail_out
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|memory
operator|=
name|NULL
expr_stmt|;
name|zip
operator|->
name|source
operator|=
name|NULL
expr_stmt|;
name|zip
operator|->
name|stream
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_gzip_file_reset
name|ft_gzip_file_reset
parameter_list|(
name|FT_GZipFile
name|zip
parameter_list|)
block|{
name|FT_Stream
name|stream
init|=
name|zip
operator|->
name|source
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|FT_STREAM_SEEK
argument_list|(
name|zip
operator|->
name|start
argument_list|)
condition|)
block|{
name|z_stream
modifier|*
name|zstream
init|=
operator|&
name|zip
operator|->
name|zstream
decl_stmt|;
name|inflateReset
argument_list|(
name|zstream
argument_list|)
expr_stmt|;
name|zstream
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
name|zstream
operator|->
name|next_in
operator|=
name|zip
operator|->
name|input
expr_stmt|;
name|zstream
operator|->
name|avail_out
operator|=
literal|0
expr_stmt|;
name|zstream
operator|->
name|next_out
operator|=
name|zip
operator|->
name|buffer
expr_stmt|;
name|zip
operator|->
name|limit
operator|=
name|zip
operator|->
name|buffer
operator|+
name|FT_GZIP_BUFFER_SIZE
expr_stmt|;
name|zip
operator|->
name|cursor
operator|=
name|zip
operator|->
name|limit
expr_stmt|;
name|zip
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_gzip_file_fill_input
name|ft_gzip_file_fill_input
parameter_list|(
name|FT_GZipFile
name|zip
parameter_list|)
block|{
name|z_stream
modifier|*
name|zstream
init|=
operator|&
name|zip
operator|->
name|zstream
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|zip
operator|->
name|source
decl_stmt|;
name|FT_ULong
name|size
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|read
condition|)
block|{
name|size
operator|=
name|stream
operator|->
name|read
argument_list|(
name|stream
argument_list|,
name|stream
operator|->
name|pos
argument_list|,
name|zip
operator|->
name|input
argument_list|,
name|FT_GZIP_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|limit
operator|=
name|zip
operator|->
name|cursor
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Invalid_Stream_Operation
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|size
operator|=
name|stream
operator|->
name|size
operator|-
name|stream
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|FT_GZIP_BUFFER_SIZE
condition|)
name|size
operator|=
name|FT_GZIP_BUFFER_SIZE
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|limit
operator|=
name|zip
operator|->
name|cursor
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Invalid_Stream_Operation
argument_list|)
return|;
block|}
name|FT_MEM_COPY
argument_list|(
name|zip
operator|->
name|input
argument_list|,
name|stream
operator|->
name|base
operator|+
name|stream
operator|->
name|pos
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|pos
operator|+=
name|size
expr_stmt|;
name|zstream
operator|->
name|next_in
operator|=
name|zip
operator|->
name|input
expr_stmt|;
name|zstream
operator|->
name|avail_in
operator|=
name|size
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_gzip_file_fill_output
name|ft_gzip_file_fill_output
parameter_list|(
name|FT_GZipFile
name|zip
parameter_list|)
block|{
name|z_stream
modifier|*
name|zstream
init|=
operator|&
name|zip
operator|->
name|zstream
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|zip
operator|->
name|cursor
operator|=
name|zip
operator|->
name|buffer
expr_stmt|;
name|zstream
operator|->
name|next_out
operator|=
name|zip
operator|->
name|cursor
expr_stmt|;
name|zstream
operator|->
name|avail_out
operator|=
name|FT_GZIP_BUFFER_SIZE
expr_stmt|;
while|while
condition|(
name|zstream
operator|->
name|avail_out
operator|>
literal|0
condition|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|zstream
operator|->
name|avail_in
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ft_gzip_file_fill_input
argument_list|(
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|err
operator|=
name|inflate
argument_list|(
name|zstream
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|Z_STREAM_END
condition|)
block|{
name|zip
operator|->
name|limit
operator|=
name|zstream
operator|->
name|next_out
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|limit
operator|==
name|zip
operator|->
name|cursor
condition|)
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Stream_Operation
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
block|{
name|zip
operator|->
name|limit
operator|=
name|zip
operator|->
name|cursor
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Stream_Operation
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* fill output buffer; `count' must be<= FT_GZIP_BUFFER_SIZE */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_gzip_file_skip_output
name|ft_gzip_file_skip_output
parameter_list|(
name|FT_GZipFile
name|zip
parameter_list|,
name|FT_ULong
name|count
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_ULong
name|delta
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|delta
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
name|zip
operator|->
name|limit
operator|-
name|zip
operator|->
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
name|count
condition|)
name|delta
operator|=
name|count
expr_stmt|;
name|zip
operator|->
name|cursor
operator|+=
name|delta
expr_stmt|;
name|zip
operator|->
name|pos
operator|+=
name|delta
expr_stmt|;
name|count
operator|-=
name|delta
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
name|error
operator|=
name|ft_gzip_file_fill_output
argument_list|(
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_ULong
DECL|function|ft_gzip_file_io
name|ft_gzip_file_io
parameter_list|(
name|FT_GZipFile
name|zip
parameter_list|,
name|FT_ULong
name|pos
parameter_list|,
name|FT_Byte
modifier|*
name|buffer
parameter_list|,
name|FT_ULong
name|count
parameter_list|)
block|{
name|FT_ULong
name|result
init|=
literal|0
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* Reset inflate stream if we're seeking backwards.        */
comment|/* Yes, that is not too efficient, but it saves memory :-) */
if|if
condition|(
name|pos
operator|<
name|zip
operator|->
name|pos
condition|)
block|{
name|error
operator|=
name|ft_gzip_file_reset
argument_list|(
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* skip unwanted bytes */
if|if
condition|(
name|pos
operator|>
name|zip
operator|->
name|pos
condition|)
block|{
name|error
operator|=
name|ft_gzip_file_skip_output
argument_list|(
name|zip
argument_list|,
call|(
name|FT_ULong
call|)
argument_list|(
name|pos
operator|-
name|zip
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
comment|/* now read the data */
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_ULong
name|delta
decl_stmt|;
name|delta
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
name|zip
operator|->
name|limit
operator|-
name|zip
operator|->
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
name|count
condition|)
name|delta
operator|=
name|count
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|buffer
argument_list|,
name|zip
operator|->
name|cursor
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|delta
expr_stmt|;
name|result
operator|+=
name|delta
expr_stmt|;
name|zip
operator|->
name|cursor
operator|+=
name|delta
expr_stmt|;
name|zip
operator|->
name|pos
operator|+=
name|delta
expr_stmt|;
name|count
operator|-=
name|delta
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
name|error
operator|=
name|ft_gzip_file_fill_output
argument_list|(
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|Exit
label|:
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/*****               G Z   E M B E D D I N G   S T R E A M             *****/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|ft_gzip_stream_close
name|ft_gzip_stream_close
parameter_list|(
name|FT_Stream
name|stream
parameter_list|)
block|{
name|FT_GZipFile
name|zip
init|=
operator|(
name|FT_GZipFile
operator|)
name|stream
operator|->
name|descriptor
operator|.
name|pointer
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|zip
condition|)
block|{
comment|/* finalize gzip file descriptor */
name|ft_gzip_file_done
argument_list|(
name|zip
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|zip
argument_list|)
expr_stmt|;
name|stream
operator|->
name|descriptor
operator|.
name|pointer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stream
operator|->
name|read
condition|)
name|FT_FREE
argument_list|(
name|stream
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|unsigned
name|long
DECL|function|ft_gzip_stream_io
name|ft_gzip_stream_io
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|)
block|{
name|FT_GZipFile
name|zip
init|=
operator|(
name|FT_GZipFile
operator|)
name|stream
operator|->
name|descriptor
operator|.
name|pointer
decl_stmt|;
return|return
name|ft_gzip_file_io
argument_list|(
name|zip
argument_list|,
name|offset
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|FT_ULong
DECL|function|ft_gzip_get_uncompressed_size
name|ft_gzip_get_uncompressed_size
parameter_list|(
name|FT_Stream
name|stream
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_ULong
name|old_pos
decl_stmt|;
name|FT_ULong
name|result
init|=
literal|0
decl_stmt|;
name|old_pos
operator|=
name|stream
operator|->
name|pos
expr_stmt|;
if|if
condition|(
operator|!
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
name|stream
operator|->
name|size
operator|-
literal|4
argument_list|)
condition|)
block|{
name|result
operator|=
name|FT_Stream_ReadULongLE
argument_list|(
name|stream
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|result
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
name|old_pos
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/* documentation is in ftgzip.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stream_OpenGzip
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Stream  source
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_GZipFile
name|zip
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|stream
operator|||
operator|!
name|source
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Stream_Handle
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memory
operator|=
name|source
operator|->
name|memory
expr_stmt|;
comment|/*      *  check the header right now; this prevents allocating un-necessary      *  objects when we don't need them      */
name|error
operator|=
name|ft_gzip_check_header
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|FT_ZERO
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
if|if
condition|(
operator|!
name|FT_QNEW
argument_list|(
name|zip
argument_list|)
condition|)
block|{
name|error
operator|=
name|ft_gzip_file_init
argument_list|(
name|zip
argument_list|,
name|stream
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FT_FREE
argument_list|(
name|zip
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|stream
operator|->
name|descriptor
operator|.
name|pointer
operator|=
name|zip
expr_stmt|;
block|}
comment|/*      *  We use the following trick to try to dramatically improve the      *  performance while dealing with small files.  If the original stream      *  size is less than a certain threshold, we try to load the whole font      *  file into memory.  This saves us from using the 32KB buffer needed      *  to inflate the file, plus the two 4KB intermediate input/output      *  buffers used in the `FT_GZipFile' structure.      */
block|{
name|FT_ULong
name|zip_size
init|=
name|ft_gzip_get_uncompressed_size
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|zip_size
operator|!=
literal|0
operator|&&
name|zip_size
operator|<
literal|40
operator|*
literal|1024
condition|)
block|{
name|FT_Byte
modifier|*
name|zip_buff
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|FT_ALLOC
argument_list|(
name|zip_buff
argument_list|,
name|zip_size
argument_list|)
condition|)
block|{
name|FT_ULong
name|count
decl_stmt|;
name|count
operator|=
name|ft_gzip_file_io
argument_list|(
name|zip
argument_list|,
literal|0
argument_list|,
name|zip_buff
argument_list|,
name|zip_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|zip_size
condition|)
block|{
name|ft_gzip_file_done
argument_list|(
name|zip
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|zip
argument_list|)
expr_stmt|;
name|stream
operator|->
name|descriptor
operator|.
name|pointer
operator|=
name|NULL
expr_stmt|;
name|stream
operator|->
name|size
operator|=
name|zip_size
expr_stmt|;
name|stream
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|base
operator|=
name|zip_buff
expr_stmt|;
name|stream
operator|->
name|read
operator|=
name|NULL
expr_stmt|;
name|stream
operator|->
name|close
operator|=
name|ft_gzip_stream_close
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|ft_gzip_file_io
argument_list|(
name|zip
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|zip_buff
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
block|}
block|}
name|stream
operator|->
name|size
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
comment|/* don't know the real size! */
name|stream
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
name|stream
operator|->
name|read
operator|=
name|ft_gzip_stream_io
expr_stmt|;
name|stream
operator|->
name|close
operator|=
name|ft_gzip_stream_close
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftgzip.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Gzip_Uncompress
argument_list|(
argument|FT_Memory       memory
argument_list|,
argument|FT_Byte*        output
argument_list|,
argument|FT_ULong*       output_len
argument_list|,
argument|const FT_Byte*  input
argument_list|,
argument|FT_ULong        input_len
argument_list|)
end_macro
begin_block
block|{
name|z_stream
name|stream
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* check for `input' delayed to `inflate' */
if|if
condition|(
operator|!
name|memory
operator|||
operator|!
name|output_len
operator|||
operator|!
name|output
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
comment|/* this function is modeled after zlib's `uncompress' function */
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|input
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|input_len
expr_stmt|;
name|stream
operator|.
name|next_out
operator|=
name|output
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
operator|*
name|output_len
expr_stmt|;
name|stream
operator|.
name|zalloc
operator|=
operator|(
name|alloc_func
operator|)
name|ft_gzip_alloc
expr_stmt|;
name|stream
operator|.
name|zfree
operator|=
operator|(
name|free_func
operator|)
name|ft_gzip_free
expr_stmt|;
name|stream
operator|.
name|opaque
operator|=
name|memory
expr_stmt|;
name|err
operator|=
name|inflateInit2
argument_list|(
operator|&
name|stream
argument_list|,
name|MAX_WBITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|err
operator|=
name|inflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|Z_OK
condition|)
name|err
operator|=
name|Z_BUF_ERROR
expr_stmt|;
block|}
else|else
block|{
operator|*
name|output_len
operator|=
name|stream
operator|.
name|total_out
expr_stmt|;
name|err
operator|=
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|Z_MEM_ERROR
condition|)
return|return
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
return|;
if|if
condition|(
name|err
operator|==
name|Z_BUF_ERROR
condition|)
return|return
name|FT_THROW
argument_list|(
name|Array_Too_Large
argument_list|)
return|;
if|if
condition|(
name|err
operator|==
name|Z_DATA_ERROR
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
return|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_CONFIG_OPTION_USE_ZLIB */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stream_OpenGzip
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Stream  source
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|source
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Gzip_Uncompress
argument_list|(
argument|FT_Memory       memory
argument_list|,
argument|FT_Byte*        output
argument_list|,
argument|FT_ULong*       output_len
argument_list|,
argument|const FT_Byte*  input
argument_list|,
argument|FT_ULong        input_len
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|memory
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|output_len
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|input_len
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_CONFIG_OPTION_USE_ZLIB */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
